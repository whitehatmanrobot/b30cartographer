ions->Next;

    }

    SetupCloseInfFile( hInputinf );


    

    //
    // Print totals.
    //
    printf( "\n\n==================================================\n\n" );
    printf( "%d files processed\n", LineCount );
    if( MissedFiles > 0 ) {
        printf( "%d files were not found\n", MissedFiles );
    }

    if( LocalSource ) {
        char_ptr = "TempDirSpace";

        //
        // TempDirSpace is given in bytes.
        //
        i = 1;
    } else {
        char_ptr = "WinDirSpace";

        //
        // WinDir space is given in KBytes.
        //
        i = 1024;
    }

    printf( "Raw size: %12d\n", Running_RawSize+Slop );
    printf( "%s512  = %12d\n", char_ptr, (Running_512+Slop)/i );
    printf( "%s1K   = %12d\n", char_ptr, (Running_1K+Slop)/i );
    printf( "%s2K   = %12d\n", char_ptr, (Running_2K+Slop)/i );
    printf( "%s4K   = %12d\n", char_ptr, (Running_4K+Slop)/i );
    printf( "%s8K   = %12d\n", char_ptr, (Running_8K+Slop)/i );
    printf( "%s16K  = %12d\n", char_ptr, (Running_16K+Slop)/i );
    printf( "%s32K  = %12d\n", char_ptr, (Running_32K+Slop)/i );
    printf( "%s64K  = %12d\n", char_ptr, (Running_64K+Slop)/i );
    printf( "%s128K = %12d\n", char_ptr, (Running_128K+Slop)/i );
    printf( "%s256K = %12d\n", char_ptr, (Running_256K+Slop)/i );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\makefile.inc ===
$(O)\unitext.res: utmsgs.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\stampinf\stampinf.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "stampinf.h"

DRIVER_VER_DATA dvdata;
BOOLEAN HaveDate = FALSE;
BOOLEAN HaveVersion = FALSE;

int _cdecl main (int argc, char **argv)
{

    char *StampInfEnv;
    //
    // Zero out our main data structure
    //

    ZeroMemory (&dvdata, sizeof (DRIVER_VER_DATA));

    //
    // Process and validate the arguments
    //

    lstrcpy (dvdata.SectionName, "Version");

    if (StampInfEnv = getenv("STAMPINF_DATE")) {
        if (ValidateDate (StampInfEnv)) {
            lstrcpy (dvdata.DateString, StampInfEnv);
            HaveDate = TRUE;
        }
        else printf ("Date error\n");
    }

    if (StampInfEnv = getenv("STAMPINF_VERSION")) {
        lstrcpyn (dvdata.VersionString, StampInfEnv, 20);
        HaveVersion = TRUE;
    }

    if (!GetArgs (argc, argv)) {
        DisplayHelp ();
        return 1;
    }

    //
    // Write the DriverVer key to the inf
    //

    if (!StampInf ()) {
        printf ("Error writing to inf!\n");
        return 1;
    }

    return 0;
}

BOOLEAN GetArgs (int argc, char **argv)
{
    int args;
    char *arg;
    ARGTYPE argtype = ArgSwitch;


    //
    // Loop through the arguments, the filename is required
    // but version and date are optional.
    //


    for (args = 1; args < argc; args++) {

        arg = argv[args];


        //
        // switch based on the type of argument
        // we are expecting.
        //

        switch (argtype) {
            case ArgSwitch:

                //
                // better be a switch prefix
                //

                if (*arg != '-') return FALSE;
                else arg++;

                switch (toupper(*arg)) {

                    case 'F':
                        argtype = ArgFileName;
                        break;

                    case 'D':
                        argtype = ArgDate;
                        break;

                    case 'V':
                        argtype = ArgVersion;
                        break;

                    case 'S':
                        argtype = ArgSection;
                        break;

                    default:
                        printf ("Invalid argument %s\n", arg);
                }
                break;

            case ArgFileName:

                //
                // See if the provided filename includes any
                // path separators.  If it doesn't prepend .\
                // because the WritePrivateProfile api
                // defaults to the Windows dir unless
                // you specify a path.
                //

                if (strchr (arg, '\\') == NULL) {
                    lstrcpy (dvdata.InfName, ".\\");
                }

                //
                // concatenate the actual file name
                //

                lstrcat (dvdata.InfName, arg);
                argtype = ArgSwitch;
                break;

            case ArgDate:

                //
                // If the user specified a date, do some basic validation.
                //

                if (ValidateDate (arg)) {
                    lstrcpy (dvdata.DateString, arg);
                    HaveDate = TRUE;
                }
                else printf ("Date error\n");
                argtype = ArgSwitch;

                break;

            case ArgVersion:

                //
                // If the user specified a version override, use it.
                //

                lstrcpyn (dvdata.VersionString, arg, 20);
                argtype = ArgSwitch;
                HaveVersion = TRUE;
                break;

            case ArgSection:

                lstrcpyn (dvdata.SectionName, arg, 64);
                argtype = ArgSwitch;
                break;
        }
    }

    if (!HaveDate) {

        //
        // Get the date in xx/yy/zzzz format.
        //

        GetDateFormat (LOCALE_SYSTEM_DEFAULT, 0, NULL, "MM'/'dd'/'yyyy", dvdata.DateString, 11);
    }

    if (!HaveVersion) {

        //
        // If the user didn't provide a version override, then open and read
        // ntverp.h and figure out what the version stamp should be.
        //

        if (!ProcessNtVerP (dvdata.VersionString)) {
            return FALSE;
        }
    }

    //
    // Must have a name.
    //

    return (dvdata.InfName[0] != '\0');
}

BOOLEAN ValidateDate (char *datestring)
{
    ULONG Month, Day, Year;

    if (lstrlen (datestring) != 10) return FALSE;

    Month = atoi(&datestring[0]);

    if (Month < 1 || Month > 12) return FALSE;

    Day = atoi (&datestring[3]);

    if (Day < 1 || Day > 31) return FALSE;

    Year = atoi (&datestring[6]);

    if (Year < 1980 || Year > 2099) return FALSE;

    return TRUE;
}

ULONG GetLengthOfLine (WCHAR *Pos, WCHAR *LastChar)
{
    ULONG Length=0;

    if (Pos == NULL) return 0;

    while ( (Pos < LastChar) && (*Pos != 0x00D) ) {
        Pos++;
        Length++;
    }

    if (Pos < LastChar) Length+=2;

    return Length;
}

WCHAR *GetNextLine (WCHAR *CurPos, WCHAR *LastChar)
{
    LastChar--;

    for (;CurPos < LastChar;CurPos++) {
        if ( (CurPos[0] == 0x00D) && (CurPos[1] == 0x00A) ) break;
    }

    return ( (&(CurPos[2]) <= LastChar) ? &(CurPos[2]) : NULL );
}

BOOLEAN DoesLineMatch (WCHAR *Target, WCHAR *Sample, WCHAR *LastChar)
{
    USHORT LineLength = 0;
    WCHAR *Pos = Sample;
    WCHAR *buffer;
    BOOLEAN result;
    ULONG TargetLength;

    if (Pos == NULL) return FALSE;

    while ( (Pos <= LastChar) && (*Pos != 0x00D) ) {
        LineLength++;
        Pos++;
    }

    TargetLength = lstrlenW (Target);

    if (TargetLength > LineLength) {
        return FALSE;
    }

    return (BOOLEAN)(!memcmp (Target, Sample, TargetLength));
}

USHORT FindEntry (WCHAR *FileStart, WCHAR *FileEnd, WCHAR *SectionNameW, WCHAR **Entry)
{
    WCHAR *FilePos=FileStart;
    WCHAR FixedSectionNameW[64+2];
    BOOLEAN FoundMatch = FALSE;
    ULONG iter = 0;

    wsprintfW (FixedSectionNameW, L"[%s]", SectionNameW);

    for (FilePos = FileStart; FilePos; FilePos = GetNextLine (FilePos, FileEnd)) {

        if (DoesLineMatch (FixedSectionNameW, FilePos, FileEnd)) {
            FoundMatch = TRUE;
            break;
        }
    }

    if (FoundMatch) {

        FoundMatch = FALSE;

        while ( ((FilePos = GetNextLine (FilePos, FileEnd)) != NULL) && (*FilePos != L'[') ) {

            if (DoesLineMatch (L"DriverVer", FilePos, FileEnd)) {
                FoundMatch = TRUE;
                break;
            }
        }
        if (FoundMatch) {
            *Entry = FilePos;
            return FOUND_ENTRY;
        }
        if (FilePos) {
            *Entry = FilePos;
            return FOUND_SECTION;
        }
    }

    *Entry = NULL;
    return FOUND_NOTHING;
}


UINT UniWPPS (char *SectionName, char *Stamp, char *InfName)
{
    WCHAR SectionNameW [64];
    WCHAR *NextLinePtr;
    WCHAR NewEntryW [64];
    WCHAR StampW [32];
    WCHAR InfNameW [MAX_PATH];
    HANDLE hFile, hMapping;
    WCHAR *MappedBuffer;
    ULONG filesize;
    WCHAR *LastChar;
    WCHAR *Entry = NULL;
    ULONG result;
    ULONG StampLength;
    ULONG numwritten;
    ULONG deleted;

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         SectionName,
                         (int)-1,
                         SectionNameW,
                         64);

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         Stamp,
                         (int)-1,
                         StampW,
                         32);

    MultiByteToWideChar (CP_ACP,
                         MB_PRECOMPOSED,
                         InfName,
                         (int)-1,
                         InfNameW,
                         MAX_PATH);

    StampLength = lstrlenW (StampW);

    hFile = CreateFile (InfName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return 0;
    }

    filesize = GetFileSize (hFile, NULL);

    hMapping = CreateFileMapping (hFile, NULL, PAGE_READWRITE, 0, filesize+128, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return 0;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return 0;
    }

    LastChar = (WCHAR *)((ULONG_PTR)MappedBuffer+filesize-sizeof(WCHAR));

    result = FindEntry (MappedBuffer, LastChar, SectionNameW, &Entry);

    wsprintfW (NewEntryW, L"DriverVer=%s\r\n",StampW);
    StampLength = lstrlenW (NewEntryW);

    switch (result) {

        case FOUND_SECTION:

            MoveMemory ((WCHAR *)((ULONG_PTR)Entry+(StampLength*sizeof(WCHAR))), Entry, (ULONG_PTR)LastChar-(ULONG_PTR)Entry+sizeof(WCHAR));
            CopyMemory (Entry, NewEntryW, StampLength*sizeof(WCHAR));
            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize+StampLength*sizeof(WCHAR), NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;

        case FOUND_ENTRY:

            deleted = GetLengthOfLine (Entry, LastChar);
            deleted *=sizeof(WCHAR);
            NextLinePtr = GetNextLine (Entry, LastChar);
            MoveMemory ((WCHAR *)((ULONG_PTR)Entry+(StampLength*sizeof(WCHAR))), NextLinePtr, (ULONG_PTR)LastChar-(ULONG_PTR)NextLinePtr+sizeof(WCHAR));
            CopyMemory (Entry, NewEntryW, StampLength*sizeof(WCHAR));
            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize+StampLength*sizeof(WCHAR)-deleted, NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;

        case FOUND_NOTHING:

            UnmapViewOfFile (MappedBuffer);
            CloseHandle (hMapping);
            SetFilePointer (hFile, filesize, NULL, FILE_BEGIN);
            SetEndOfFile (hFile);
            break;
    }

    CloseHandle (hFile);
    return 1;
}

BOOLEAN IsInfUnicode (VOID)
{
    HANDLE hFile, hMapping;
    char *MappedBuffer;
    ULONG filesize;
    BOOLEAN unicode = FALSE;

    hFile = CreateFile (dvdata.InfName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return FALSE;
    }

    hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return FALSE;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return FALSE;
    }

    filesize = GetFileSize (hFile, NULL);

    if (filesize < sizeof (WCHAR)) return 0;

    if ( *((WCHAR *)MappedBuffer) == 0xFEFF ) {
        unicode = TRUE;
    }
    if ( IsTextUnicode (MappedBuffer, filesize, NULL) ) {
        unicode = TRUE;
    }


    UnmapViewOfFile (MappedBuffer);
    CloseHandle (hMapping);
    CloseHandle (hFile);

    return unicode;
}

BOOLEAN StampInf (VOID)
{

    char DateVerStamp[32];

    wsprintf (DateVerStamp, "%s,%s",dvdata.DateString,dvdata.VersionString);

    printf ("Stamping %s [%s] section with DriverVer=%s\n",dvdata.InfName, dvdata.SectionName, DateVerStamp);

    //
    // Let WritePrivateProfile do all of our work!
    //

    if (IsInfUnicode()) {

        printf ("Unicode Inf Detected\n");

        if (UniWPPS (dvdata.SectionName, DateVerStamp, dvdata.InfName) == 0) {
            printf ("Error\n");
            return FALSE;
        }

    }
    else {

        if (WritePrivateProfileString (dvdata.SectionName, "DriverVer", DateVerStamp, dvdata.InfName) == 0) {
            printf ("Error\n");
            return FALSE;
        }
    }

    return TRUE;

}

VOID DisplayHelp (VOID)
{
    printf ("\tUSAGE:\n");
    printf ("\tstampinf -f filename [-s section] [-d xx/yy/zzzz] [-v w.x.y.z]\n");
}

DWORD NextInterestingCharacter (DWORD CurFilePos, DWORD Size, char *MappedBuffer)
{
    char thischar;
    DWORD NewPos;

    //
    // Find the next character that is not whitespace, EOL, or within a comment block.
    // Return the offset into the buffer for that character, or Size if there is no
    // such character.
    //

    while (CurFilePos < Size) {

        thischar = MappedBuffer[CurFilePos];

        if ( (thischar == 0x0A) || (thischar == 0x0D) || (thischar == ' ') ) {
            CurFilePos++;
            continue;
        }

        if (CurFilePos == Size-1)
	    break;
        if ( (thischar == '/') && (MappedBuffer[CurFilePos+1] == '*') ) {


            //
            // Skip past the comment char's and search for the end of the comment block
            //


            NewPos = CurFilePos+2;
            while (NewPos < (Size-1)) {

                if ( (MappedBuffer[NewPos] == '*') && (MappedBuffer[NewPos+1] == '/') ) {

                    CurFilePos = NewPos+1;
                    break;
                }
                NewPos++;
            }
        }
        else if ( (thischar == '/') && (MappedBuffer[CurFilePos+1] == '/') ) {

	    // Search for newline or EOF

	    CurFilePos += 2;
            while (CurFilePos < (Size-1)) {
	        if ( (MappedBuffer[CurFilePos] == 0x0A) || (MappedBuffer[CurFilePos] == 0x0D)) {
                    break;
                }
                CurFilePos++;
            }
        }
        else {
            break;
        }
        CurFilePos++;
    }

    return CurFilePos;
}

DWORD FindLengthOfInterestingCharacters (DWORD CurFilePos, DWORD Size, char *MappedBuffer)
{
    DWORD Pos = CurFilePos;
    char thischar;

    //
    // Find the length of a string.  Return the length.
    //

    while (Pos < Size) {

        thischar = MappedBuffer[Pos];

        if ( (thischar == 0x0A) || (thischar == 0x0D) || (thischar == ' ') || (thischar == '/') ) {
            return (Pos-CurFilePos);
        }

        Pos++;

    }
    printf ("How did we get here?\n");
    return 0;
}

BOOLEAN ProcessNtVerP (char *VersionString)
{
    HANDLE hFile, hMapping;
    char *MappedBuffer, *location;
    DWORD pos;
    DWORD qfelen,buildlen,majorverlen,minorverlen;
    char qfe[5]={'0','0','0','0',0};
    char build[5]={'0','0','0','0',0};
    char majorversion[5]={'0','0','0','0',0};
    char minorversion[5]={'0','0','0','0',0};
    DWORD filesize;
    char *p;
    TCHAR ntroot[MAX_PATH];

    if ( GetEnvironmentVariable ("_NTDRIVE", ntroot, 3) == 0 ) {
        printf ("Unable to evaluate _NTDRIVE!\n");
        return FALSE;
    }

    if ( GetEnvironmentVariable ("_NTROOT", &(ntroot[2]), MAX_PATH-2) == 0 ) {
        printf ("Unable to evaluate _NTROOT!\n");
        return FALSE;
    }

    lstrcat (ntroot, "\\public\\sdk\\inc\\ntverp.h");

    printf ("Using version information from %s\n",ntroot);

    //
    // Create a memory mapped image of ntverp.h
    //

    hFile = CreateFile (ntroot, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        printf ("Create file failed!\n");
        return FALSE;
    }

    filesize = GetFileSize (hFile, NULL);
    hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!hMapping) {
        printf ("Map file failed!\n");
        CloseHandle (hFile);
        return FALSE;
    }

    MappedBuffer = MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0);

    if (!MappedBuffer) {
        printf ("MapView Failed!\n");
        CloseHandle (hMapping);
        CloseHandle (hFile);
        return FALSE;
    }

    //
    // The version is made up of a.b.c.d where a.b is the Product Version.
    // c is the Build and d is the QFE level.  (e.g. 5.0.1922.1)
    //

    location = strstr (MappedBuffer, "#define VER_PRODUCTMAJORVERSION ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+32), filesize, MappedBuffer);
    majorverlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (majorversion, &(MappedBuffer[pos]), majorverlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTMINORVERSION ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+32), filesize, MappedBuffer);
    minorverlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (minorversion, &(MappedBuffer[pos]), minorverlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTBUILD ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+25), filesize, MappedBuffer);
    buildlen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (build, &(MappedBuffer[pos]), buildlen+1);

    location = strstr (MappedBuffer, "#define VER_PRODUCTBUILD_QFE ");
    pos = NextInterestingCharacter ((DWORD)(location-MappedBuffer+29), filesize, MappedBuffer);
    qfelen = FindLengthOfInterestingCharacters (pos, filesize, MappedBuffer);
    lstrcpyn (qfe, &(MappedBuffer[pos]), qfelen+1);

    wsprintf (VersionString, "%s.%s.%s.%s",majorversion, minorversion, build, qfe);

    UnmapViewOfFile (MappedBuffer);
    CloseHandle (hMapping);
    CloseHandle (hFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\stampinf\stampinf.h ===
typedef struct _DRIVER_VER_DATA {

    char InfName[MAX_PATH];
    char SectionName[64];
    char DateString[11];
    char VersionString[20];
    int  RawVersion [4];    

}DRIVER_VER_DATA, *PDRIVER_VER_DATA;

BOOLEAN GetArgs (int argc, char **argv);

BOOLEAN ValidateDate (char *datestring);

BOOLEAN StampInf (VOID);

VOID DisplayHelp (VOID);

BOOLEAN ProcessNtVerP (char *VersionString);

typedef enum _ARGTYPE {
    
    ArgSwitch,
    ArgFileName,
    ArgDate,
    ArgVersion,
    ArgSection    

} ARGTYPE;

#define FOUND_NOTHING 0
#define FOUND_SECTION 1 
#define FOUND_ENTRY 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\unitext.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Unitext.h

Abstract:

    Main header file for unicode <--> ansi/oem text file translator.

Author:

    Ted Miller (tedm) 16-March-1993

Revision History:

--*/


#define UNICODE

//
// Include files
//

#include <windows.h>
#include <stdarg.h>
#include <process.h>
#include "utmsgs.h"
#include "wargs.h"



//
// Unicode byte order marks.
//
#define BYTE_ORDER_MARK         0xfeff
#define SWAPPED_BYTE_ORDER_MARK 0xfffe

//
// Define flags for a type of text file.
//
#define TFILE_NONE       0
#define TFILE_UNICODE    0x0001
#define TFILE_ANSI       0x0010
#define TFILE_OEM        0x0020
#define TFILE_USERCP     0x0040
#define TFILE_MULTIBYTE  0x00f0

//
// Define conversion types.
//
#define CONVERT_NONE    0
#define UNICODE_TO_MB   1
#define MB_TO_UNICODE   2

//
// Define conversion options
//
#define CHECK_NONE		3
#define CHECK_ALREADY_UNICODE	4
#define CHECK_IF_NOT_UNICODE	5
#define CHECK_CONVERSION	6

//
//
// Function prototypes
//

//
// From ututil.c
//
VOID
MsgPrintfW(
    IN DWORD MessageId,
    ...
    );

VOID
vMsgPrintfW(
    IN DWORD   MessageId,
    IN va_list arglist
    );

VOID
ErrorAbort(
    IN DWORD MessageId,
    ...
    );

VOID
MyReadFile(
    IN  HANDLE FileHandle,
    OUT PVOID  Buffer,
    IN  DWORD  BytesToRead,
    IN  LPWSTR Filename
    );


//
// From utmb2u.c
//
VOID
MultibyteTextFileToUnicode(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   SourceCodePage
    );


//
// From utu2mb.c
//
VOID
UnicodeTextFileToMultibyte(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   TargetCodePage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\unitext.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Unitext.c

Abstract:

    Main module for unicode <--> ansi/oem text file translator.

    This program converts files between unicode and multibyte
    character sets (ansi or oem).  Usage is a follows:

    unitext [-m|-u] [-o|-a|-<nnn>] [-z] <src_file> <dst_file>

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/

#include "unitext.h"
#include <wchar.h>


//
// Globals and prototypes for use within this module.
//

//
// Unicode argc/argv.
//
int     _argcW;
PWCHAR *_argvW;

//
// Codepage for multibyte file.
//
DWORD CodePage = (DWORD)(-1);

//
// File handles.
//
HANDLE SourceFileHandle,TargetFileHandle;

//
// Size of source file.
//
DWORD SourceFileSize;

//
// Type of the multibyte file (source or destination).
//
DWORD MultibyteType = TFILE_NONE;

//
// Conversion type.
//
DWORD ConversionType = CONVERT_NONE;
DWORD ConversionOption = CHECK_NONE;
DWORD ConversionCheck = CHECK_NONE;

//
// Filenames.
//
LPWSTR SourceFilename = NULL,
       TargetFilename = NULL;






BOOL
_ParseCommandLineArgs(
    VOID
    );

VOID
_CheckFilesAndOpen(
    VOID
    );


VOID
__cdecl
main(
    VOID
    )
{
    //
    // Get command line arguments.
    //
    if(!InitializeUnicodeArguments(&_argcW,&_argvW)) {
        ErrorAbort(MSG_INSUFFICIENT_MEMORY);
    }

    //
    // Parse command line arguments.
    //
    if(!_ParseCommandLineArgs()) {
        ErrorAbort(MSG_USAGE);
    }

    //
    // Check source and destination files.
    //
    _CheckFilesAndOpen();


    //
    // Perform conversion.
    //
    switch(ConversionType) {

    case MB_TO_UNICODE:

        MultibyteTextFileToUnicode(
            SourceFilename,
            TargetFilename,
            SourceFileHandle,
            TargetFileHandle,
            SourceFileSize,
            CodePage
            );

        break;

    case UNICODE_TO_MB:

        UnicodeTextFileToMultibyte(
            SourceFilename,
            TargetFilename,
            SourceFileHandle,
            TargetFileHandle,
            SourceFileSize,
            CodePage
            );

        break;
    }

    CloseHandle(SourceFileHandle);
    CloseHandle(TargetFileHandle);

    //
    // Clean up and exit.
    //
    FreeUnicodeArguments(_argcW,_argvW);
}




BOOL
_ParseCommandLineArgs(
    VOID
    )

/*++

Routine Description:

    Parse command line arguments.

Arguments:

    None.  Uses globals _argcW and _argvW.

Return Value:

    FALSE if invalid arguments specified.

--*/

{
    int     argc;
    PWCHAR *argv;
    PWCHAR arg;


    //
    // Initialize local variables.
    //
    argc = _argcW;
    argv = _argvW;

    //
    // Skip argv[0] (the program name).
    //
    if(argc) {
        argc--;
        argv++;
    }

    while(argc) {

        arg = *argv;

        if((*arg == L'-') || (*arg == L'/')) {

            switch(*(++arg)) {

            case L'a':
            case L'A':

                // if already specifed, error
                if(MultibyteType != TFILE_NONE) {
                    return(FALSE);
                }
                MultibyteType = TFILE_ANSI;
                break;

            case L'o':
            case L'O':

                // if already specifed, error
                if(MultibyteType != TFILE_NONE) {
                    return(FALSE);
                }
                MultibyteType = TFILE_OEM;
                break;

            case L'm':
            case L'M':

                if(ConversionType != CONVERT_NONE) {
                    return(FALSE);
                }

                ConversionType = MB_TO_UNICODE;
                break;

            case L'u':
            case L'U':

                if(ConversionType != CONVERT_NONE) {
                    return(FALSE);
                }

                ConversionType = UNICODE_TO_MB;
                break;
	
            case L'z':
            case L'Z':
        
	        if(ConversionCheck != CHECK_NONE) {
                    return(FALSE);
                }

                ConversionCheck = CHECK_CONVERSION;
                break;

            default:

                if(iswdigit(*arg)) {

                    if((CodePage != (DWORD)(-1)) || (MultibyteType != TFILE_NONE)) {
                        return(FALSE);
                    }

                    swscanf(arg,L"%u",&CodePage);

                    MultibyteType = TFILE_USERCP;

                } else {

                    return(FALSE);
                }

                break;
            }

        } else {

            if(SourceFilename == NULL) {

                SourceFilename = arg;

            } else if(TargetFilename == NULL) {

                TargetFilename = arg;

            } else {

                return(FALSE);
            }

        }

        argv++;
        argc--;
    }

    //
    // Must have source, destination filenames.
    //
    if(!SourceFilename || !TargetFilename) {
        return(FALSE);
    }

    return(TRUE);
}




VOID
_CheckFilesAndOpen(
    VOID
    )

/*++

Routine Description:

    Open the source and destination files, and try to make a guess
    about the type of the source file.  If we think the source file is
    a different type than the user specified, print a warning.

    Also check the codepage given by the user.

Arguments:

    None.

Return Value:

    None.  Does not return if a serious error occurs.

--*/

{
    DWORD SourceFileType;
    UCHAR FirstPartOfSource[256];
    DWORD ReadSize;

    //
    // Determine and check codepage.  Default to oem.
    //
    switch(MultibyteType) {
    case TFILE_ANSI:
        CodePage = GetACP();
    case TFILE_USERCP:
        break;
    default:                    // oem or none.
        CodePage = GetOEMCP();
        break;
    }

    if(!IsValidCodePage(CodePage)) {
        ErrorAbort(MSG_BAD_CODEPAGE,CodePage);
    }

    //
    // Try to open the source file.
    //
    SourceFileHandle = CreateFileW(
                            SourceFilename,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );


    if(SourceFileHandle == INVALID_HANDLE_VALUE) {
        ErrorAbort(MSG_CANT_OPEN_SOURCE,SourceFilename,GetLastError());
    }

    //
    // Attempt to determine to determine the size of the source file.
    //
    SourceFileSize = GetFileSize(SourceFileHandle,NULL);
    if(SourceFileSize == -1) {
        ErrorAbort(MSG_CANT_GET_SIZE,SourceFilename,GetLastError());
    }

    //
    // Filter out 0-length files here.
    //
    if(!SourceFileSize) {
        ErrorAbort(MSG_ZERO_LENGTH,SourceFilename);
    }

    //
    // Assume multibyte.
    //
    SourceFileType = TFILE_MULTIBYTE;

    //
    // Read first 256 bytes of file and call win32 api
    // to determine if the text is probably unicode.
    //
    ReadSize = min(SourceFileSize,256);
    MyReadFile(SourceFileHandle,FirstPartOfSource,ReadSize,SourceFilename);
    if(IsTextUnicode(FirstPartOfSource,ReadSize,NULL)) {
        SourceFileType = TFILE_UNICODE;
    }

    //
    // If the user did not specify a conversion type, set it here
    // based on the above test.
    //
    if(ConversionType == CONVERT_NONE) {

        ConversionType = (SourceFileType == TFILE_UNICODE)
                       ? UNICODE_TO_MB
                       : MB_TO_UNICODE;
    } else {

	if(ConversionCheck == CHECK_CONVERSION) {
		if(ConversionType == UNICODE_TO_MB) {
			ConversionOption = CHECK_IF_NOT_UNICODE;
		}
		else if(ConversionType == MB_TO_UNICODE) {
			ConversionOption = CHECK_ALREADY_UNICODE;
		}
		else {
			ConversionOption = CHECK_NONE;
		}
	}

	//
	// check if the file is UNICODE and we are trying to convert from MB_TO_UNICODE
	// then issue an warning and exit

     		if((ConversionType == MB_TO_UNICODE) && 
		   (SourceFileType == TFILE_UNICODE) &&
		   (ConversionOption == CHECK_ALREADY_UNICODE)) {
			CloseHandle(SourceFileHandle);
			MsgPrintfW(MSG_ERR_SRC_IS_UNICODE,SourceFilename);
			FreeUnicodeArguments(_argcW,_argvW);
			exit(0);
		}

	//
	// check if the file is not unicode and if we are trying to convert from 
	// unicode to MB, then issue an warning and exit

		if((ConversionType == UNICODE_TO_MB) && 
                  (SourceFileType != TFILE_UNICODE) &&
		  (ConversionOption == CHECK_IF_NOT_UNICODE)) {
			CloseHandle(SourceFileHandle);
			MsgPrintfW(MSG_ERR_SRC_IS_MB,SourceFilename);
	    		FreeUnicodeArguments(_argcW,_argvW);
			exit(0);
        	}
        //
        // Check to see if what we guessed is what the user asked for.
        // If not, issue a warning.
        //

        if((ConversionType == UNICODE_TO_MB) && (SourceFileType != TFILE_UNICODE)) {
            MsgPrintfW(MSG_WARN_SRC_IS_MB,SourceFilename);
        } else {
            if((ConversionType == MB_TO_UNICODE) && (SourceFileType == TFILE_UNICODE)) {
                MsgPrintfW(MSG_WARN_SRC_IS_UNICODE,SourceFilename);
            }
        }
    }

    //
    // Try to create target file.
    //
    TargetFileHandle = CreateFileW(
                            TargetFilename,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

    if(TargetFileHandle == INVALID_HANDLE_VALUE) {
        ErrorAbort(MSG_CANT_OPEN_TARGET,TargetFilename,GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\utmb2u.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Utmb2u.c

Abstract:

    Module that contains code to convert a multibyte file
    to unicode.

Author:

    Ted Miller (tedm) 17-June-1993

Revision History:

--*/

#include "unitext.h"




VOID
MultibyteTextFileToUnicode(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   SourceCodePage
    )

/*++

Routine Description:

    Convert an open multibyte text file to a unicode text file,
    interpreting the data in the multibyte text file as a stream
    of characters in a given codepage.

Arguments:

    SourceFileName - name of source (multibyte) text file.

    TargetFileName - name of target (unicode) text file.

    SourceFileHandle - win32 handle to the open source file.
        The file pointer should be fully rewound.

    TargetFileHandle - win32 handle to the open target file.
        The file pointer should be fully rewound.

    SourceFileSize - size in bytes of the source file.

    SourceCodePage - codepage for the source file.

Return Value:

    None.  Does not return if error.

--*/

{
    HANDLE SourceMapping,TargetMapping;
    LPSTR  SourceView;
    LPWSTR TargetView;
    int    CharsConverted;
    DWORD  MaxTargetSize;
    DWORD  EndOfFile;
    DWORD  err;

    //
    // Tell the user what we're doing.
    //
    MsgPrintfW(MSG_CONV_MB_TO_UNICODE,SourceFileName,TargetFileName,SourceCodePage);

    //
    // Create a file mapping object that maps the entire source file.
    //
    SourceMapping = CreateFileMapping(
                        SourceFileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        SourceFileSize,
                        NULL
                        );

    if(SourceMapping == NULL) {
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    //
    // Calculate the maximum target file size.  This is twice the
    // source file size, plus one wchar for the byte order mark.
    // The file could be smaller if there are double-byte characters
    // in the source file.
    //
    MaxTargetSize = (SourceFileSize+1)*sizeof(WCHAR);

    //
    // Create a file mapping object that maps the maximum size of
    // the target file.
    //
    TargetMapping = CreateFileMapping(
                        TargetFileHandle,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        MaxTargetSize,
                        NULL
                        );

    if(TargetMapping == NULL) {
        CloseHandle(SourceMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }


    //
    // Map views of the two files.
    //
    SourceView = MapViewOfFile(
                    SourceMapping,
                    FILE_MAP_READ,
                    0,0,
                    SourceFileSize
                    );

    if(SourceView == NULL) {
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    TargetView = MapViewOfFile(
                    TargetMapping,
                    FILE_MAP_WRITE,
                    0,0,
                    MaxTargetSize
                    );

    if(TargetView == NULL) {
        UnmapViewOfFile(SourceView);
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }

    //
    // Write the byte-order mark into the target file.
    //
    *TargetView++ = BYTE_ORDER_MARK;

    //
    // Do the conversion in one fell swoop.
    //
    CharsConverted = MultiByteToWideChar(
                        SourceCodePage,
                        MB_PRECOMPOSED,
                        SourceView,
                        SourceFileSize,
                        TargetView,
                        MaxTargetSize
                        );

    if(!CharsConverted) {
        err = GetLastError();
    }

    //
    // Do some cleanup.
    //
    UnmapViewOfFile(SourceView);
    UnmapViewOfFile(TargetView);
    CloseHandle(SourceMapping);
    CloseHandle(TargetMapping);

    //
    // Check for error in conversion.
    //
    if(!CharsConverted) {
        ErrorAbort(MSG_CONVERT_FAILED,err);
    }

    //
    // We know how many characters there are in the target file now,
    // so set the target file size accordingly.
    //
    EndOfFile = (CharsConverted+1)*sizeof(WCHAR);

    if(SetFilePointer(TargetFileHandle,EndOfFile,NULL,FILE_BEGIN) != EndOfFile) {
        ErrorAbort(MSG_SEEK_ERROR,TargetFileName,GetLastError());
    }

    if(!SetEndOfFile(TargetFileHandle)) {
        ErrorAbort(MSG_ERROR_SET_EOF,TargetFileName,GetLastError());
    }

    MsgPrintfW(MSG_CONVERT_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\utu2mb.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    Utmb2u.c

Abstract:

    Module that contains code to convert a unicode file
    to multibyte.

Author:

    Ted Miller (tedm) 17-June-1993

Revision History:

--*/

#include "unitext.h"




VOID
UnicodeTextFileToMultibyte(
    IN LPWSTR SourceFileName,
    IN LPWSTR TargetFileName,
    IN HANDLE SourceFileHandle,
    IN HANDLE TargetFileHandle,
    IN DWORD  SourceFileSize,
    IN UINT   TargetCodePage
    )

/*++

Routine Description:

    Convert an open unicode text file to a multibyte text file,
    whose characters are in a given codepage.

Arguments:

    SourceFileName - name of source (unicode) text file.

    TargetFileName - name of target (multibyte) text file.

    SourceFileHandle - win32 handle to the open source file.
        The file pointer should be fully rewound.

    TargetFileHandle - win32 handle to the open target file.
        The file pointer should be fully rewound.

    SourceFileSize - size in bytes of the source file.

    SourceCodePage - codepage for the target file.

Return Value:

    None.  Does not return if error.

--*/

{
    HANDLE SourceMapping,TargetMapping;
    LPWSTR SourceView;
    LPSTR  TargetView;
    int    BytesWritten;
    DWORD  MaxTargetSize;
    BOOL   UsedDefaultChar;

    //
    // Tell the user what we're doing.
    //
    MsgPrintfW(MSG_CONV_UNICODE_TO_MB,SourceFileName,TargetFileName,TargetCodePage);

    //
    // Create a file mapping object that maps the entire source file.
    //
    SourceMapping = CreateFileMapping(
                        SourceFileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        SourceFileSize,
                        NULL
                        );

    if(SourceMapping == NULL) {
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    //
    // Calculate the maximum target file size.  This is the same as
    // source file size (instead of half its size) because there
    // could be double-byte characters in the target file.
    //
    MaxTargetSize = SourceFileSize;

    //
    // Create a file mapping object that maps the maximum size of
    // the target file.
    //
    TargetMapping = CreateFileMapping(
                        TargetFileHandle,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        MaxTargetSize,
                        NULL
                        );

    if(TargetMapping == NULL) {
        CloseHandle(SourceMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }


    //
    // Map views of the two files.
    //
    SourceView = MapViewOfFile(
                    SourceMapping,
                    FILE_MAP_READ,
                    0,0,
                    SourceFileSize
                    );

    if(SourceView == NULL) {
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,SourceFileName,GetLastError());
    }

    TargetView = MapViewOfFile(
                    TargetMapping,
                    FILE_MAP_WRITE,
                    0,0,
                    MaxTargetSize
                    );

    if(TargetView == NULL) {
        UnmapViewOfFile(SourceView);
        CloseHandle(SourceMapping);
        CloseHandle(TargetMapping);
        ErrorAbort(MSG_CANT_MAP_FILE,TargetFileName,GetLastError());
    }

    //
    // If the first character in the source file is the byte-order mark,
    // skip over it.
    //
    if(*SourceView == BYTE_ORDER_MARK) {
        SourceView++;
        SourceFileSize -= sizeof(WCHAR);
    }

    //
    // If the first character is reversed byte-order mark, bail.
    //
    if(*SourceView == SWAPPED_BYTE_ORDER_MARK) {
        ErrorAbort(MSG_ERROR_BYTES_SWAPPED);
    }

    //
    // Do the conversion in one fell swoop.
    //
    BytesWritten = WideCharToMultiByte(
                       TargetCodePage,
                       0,
                       SourceView,
                       SourceFileSize / sizeof(WCHAR),
                       TargetView,
                       MaxTargetSize,
                       NULL,
                       &UsedDefaultChar
                       );

    //
    // Do some cleanup.
    //
    UnmapViewOfFile(SourceView);
    UnmapViewOfFile(TargetView);
    CloseHandle(SourceMapping);
    CloseHandle(TargetMapping);

    //
    // Check for error in conversion.
    //
    if(!BytesWritten) {
        ErrorAbort(MSG_CONVERT_FAILED,GetLastError());
    }

    //
    // We know how many bytes there are in the target file now,
    // so set the target file size accordingly.
    //
    if(SetFilePointer(TargetFileHandle,BytesWritten,NULL,FILE_BEGIN) != (DWORD)BytesWritten) {
        ErrorAbort(MSG_SEEK_ERROR,TargetFileName,GetLastError());
    }

    if(!SetEndOfFile(TargetFileHandle)) {
        ErrorAbort(MSG_ERROR_SET_EOF,TargetFileName,GetLastError());
    }

    MsgPrintfW(UsedDefaultChar ? MSG_USED_DEFAULT_CHAR : MSG_CONVERT_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\ututil.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ututil.c

Abstract:

    Miscellaneous utility functions for unitext.exe.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/


#include "unitext.h"
#include <process.h>


//
//  BOOL
//  IsConsoleHandle(
//      IN HANDLE ConsoleHandle
//      );
//

#define IsConsoleHandle( h )    \
    ((( DWORD_PTR )( h )) & 1 )


VOID
MsgPrintfW(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Print a formatted message from the applications's resources.

Arguments:

    MessageId - supplies id of the message to print.

    ... - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,MessageId);
    vMsgPrintfW(MessageId,arglist);
    va_end(arglist);
}


VOID
vMsgPrintfW(
    IN DWORD   MessageId,
    IN va_list arglist
    )

/*++

Routine Description:

    Print a formatted message from the applications's resources.

Arguments:

    MessageId - supplies id of the message to print.

    arglist - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    WCHAR MessageBuffer[2048];
    HANDLE StdOut;
    DWORD WrittenCount;
    DWORD CharCount;

    CharCount = FormatMessageW(
                    FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    MessageId,
                    0,
                    MessageBuffer,
                    sizeof(MessageBuffer)/sizeof(MessageBuffer[0]),
                    &arglist
                    );

    if(!CharCount) {
        ErrorAbort(MSG_BAD_MSG,MessageId);
    }

    if((StdOut = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // If the standard output handle is a console handle, write the string.
    //

    if(IsConsoleHandle(StdOut)) {

        WriteConsoleW(
            StdOut,
            MessageBuffer,
            CharCount,
            &WrittenCount,
            NULL
            );

    } else {

        CHAR  TmpBuffer[2048];
        DWORD ByteCount;

        ByteCount = WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        MessageBuffer,
                        CharCount,
                        TmpBuffer,
                        sizeof(TmpBuffer),
                        NULL,
                        NULL
                        );

        WriteFile(
            StdOut,
            TmpBuffer,
            ByteCount,
            &WrittenCount,
            NULL
            );
    }
}




VOID
ErrorAbort(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Print a message and exit.

Arguments:

    MessageId - supplies id of the message to print.

    ... - supplies arguments to be substituted in the message.

Return Value:

    None.

--*/

{
    va_list arglist;

    va_start(arglist,MessageId);
    vMsgPrintfW(MessageId,arglist);
    va_end(arglist);

    exit(0);
}



VOID
MyReadFile(
    IN  HANDLE FileHandle,
    OUT PVOID  Buffer,
    IN  DWORD  BytesToRead,
    IN  LPWSTR Filename
    )

/*++

Routine Description:

    Read from a file and don't return if an error occurs.

Arguments:

    FileHandle - supplies handle of open file.

    Buffer - supplies buffer into which data will be read.

    BytesToRead - supplies number of bytes to read from the file.

    Filename - supplies name of file being read.

Return Value:

    None.

--*/

{
    DWORD BytesRead;
    BOOL  b;

    b = ReadFile(
            FileHandle,
            Buffer,
            BytesToRead,
            &BytesRead,
            NULL
            );

    if(!b || (BytesRead != BytesToRead)) {
        ErrorAbort(MSG_READ_ERROR,Filename,GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\wargs.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    wargs.c

Abstract:

    Routines to process unicode command line arguments
    into argc and argv.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/


#include <windows.h>
#include <wargs.h>
#include <wchar.h>



LPWSTR
_NextToken(
    IN OUT LPWSTR *CurrentPosition
    )

/*++

Routine Description:

    Get the next token from the command line.

Arguments:

    argcW - receives the number of arguments.

    argvW - receives pointer to array of wide char strings.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    FALSE if not.

--*/

{
    BOOL InQuote;
    LPWSTR Start;
    UINT Length;
    LPWSTR p;
    LPWSTR Token;

    //
    // Skip leading whitespace.
    //
    Start = *CurrentPosition;
    while(*Start && iswspace(*Start)) {
        Start++;
    }

    //
    // If first char is a quote, skip it.
    //
    if(*Start == '\"') {
        InQuote = TRUE;
        Start++;
    } else {
        InQuote = FALSE;
    }

    //
    // Scan until we find the end of the token.
    //
    p = Start;
    while(*p) {

        if(iswspace(*p) && !InQuote) {
           break;
        }

        if((*p == '\"') && InQuote) {
            p++;
            break;
        }

        p++;
    }

    //
    // p is the first character that is not part of the token.
    //
    Length = (UINT)(p-Start);
    if(InQuote) {
        Length--;       // compensate for terminating quote.
    }

    //
    // Skip past trailing whitespace.
    //
    while(*p && iswspace(*p)) {
        p++;
    }

    //
    // Copy the token.
    //
    if(Token = LocalAlloc(LPTR,(Length+1)*sizeof(WCHAR))) {
        CopyMemory(Token,Start,Length*sizeof(WCHAR));
    }

    *CurrentPosition = p;
    return(Token);
}



BOOL
InitializeUnicodeArguments(
    OUT int     *argcW,
    OUT PWCHAR **argvW
    )

/*++

Routine Description:

    Fetch the unicode command line and process it into argc/argv-like
    global variables.

Arguments:

    argcW - receives the number of arguments.

    argvW - receives pointer to array of wide char strings.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    FALSE if not.

--*/

{
    LPWSTR  CommandLine;
    LPWSTR  CurrentPosition;
    int     ArgCount;
    LPWSTR  Arg;
    PWCHAR *Args=NULL;
    PWCHAR *TmpArgs;


    CommandLine = GetCommandLineW();

    CurrentPosition=CommandLine;
    ArgCount = 0;

    while(*CurrentPosition) {

        Arg = _NextToken(&CurrentPosition);
        if(Arg) {

            if(Args) {
                TmpArgs = LocalReAlloc((HLOCAL)Args,(ArgCount+1)*sizeof(PWCHAR),LMEM_MOVEABLE);
                if ( TmpArgs )
                    Args = TmpArgs;
                else {
                    LocalFree(Args);
                    Args = NULL;
                }
            } else {
                Args = LocalAlloc(LPTR,sizeof(PWCHAR));
            }

            if(Args == NULL) {
                return(FALSE);
            }

            Args[ArgCount++] = Arg;

        } else {

            return(FALSE);
        }
    }

    *argcW = ArgCount;
    *argvW = Args;
    return(TRUE);
}




VOID
FreeUnicodeArguments(
    IN int     argcW,
    IN PWCHAR *argvW
    )

/*++

Routine Description:

    Free any resources used by the global unicode argc/argv.

Arguments:

    None.

Return Value:

    TRUE if the command line was parsed and stored successfully.
    The global variables argcW and argvW will be filled in.

--*/

{
    int i;

    for(i=0; i<argcW; i++) {
        if(argvW[i]) {
            LocalFree((HLOCAL)argvW[i]);
        }
    }

    LocalFree((HLOCAL)argvW);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\wowlist\wowlist.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wowlist.c

Abstract:

    This module implements a program that determines which files in an NT
    product INF should be installed as wow files.  It then builds a list
    of these files that can be appended to other sections in a master inf.

    The input to the program consists of a filtered NT product INF (for example
    the layout.inf for i386, all products), and a control INF that specifies
    mappings and rules about how to migrate files.

Author:

    Andrew Ritz (andrewr) 24-Nov-1999   Created It.

Revision History:
    ATM Shafiqul Khalid(askhalid) 27-April-2001
        Make changes in HandleSetupapiQuotingForString() to add double 
        quote if the string contains ','.


--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <setupapi.h>
#include <sputils.h>
#include <shlwapi.h>

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[MAX_INF_STRING_LENGTH];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG

//
// String Macros
//
#define AS(x)           ( sizeof(x) / sizeof(x[0]) )
#define LSTRCPY(x,y)    ( lstrcpyn(x, y, AS(x)) )
#define LSTRCAT(x,y)    ( lstrcpyn(x + lstrlen(x), y, AS(x) - lstrlen(x)) )

//
// backward-compatible depreciated export from setupapi.dll
//

BOOL
SetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );

//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1

typedef enum _WOWLISTACTION {
    BuildCopyList,
    BuildOLEList,
    BuildSetupINF,
    WowListMax
} WOWLISTACTION;

#define KEYWORD_COPYFILES      0x00000001
#define KEYWORD_DELFILES       0x00000002
#define KEYWORD_RENFILES       0x00000004
#define KEYWORD_REGISTERDLLS   0x00000008
#define KEYWORD_UNREGISTERDLLS 0x00000010
#define KEYWORD_ADDREG         0x00000020
#define KEYWORD_DELREG         0x00000040

#define KEYWORD_NEEDDESTDIRS   (KEYWORD_COPYFILES | KEYWORD_DELFILES | KEYWORD_RENFILES)
#define KEYWORD_NEEDLAYOUTDATA (KEYWORD_COPYFILES)
#define KEYWORD_NEEDFILENAME   (KEYWORD_COPYFILES)


PCTSTR KeywordArray[] = {
    TEXT("CopyFiles"),
    TEXT("DelFiles"),
    TEXT("RenFiles"),
    TEXT("RegisterDlls"),
    TEXT("UnRegisterDlls"),
    TEXT("AddReg"),
    TEXT("DelReg")
} ;

#define INDEX_COPYFILES        0
#define INDEX_DELFILES         1
#define INDEX_RENFILES         2
#define INDEX_REGISTERDLLS     3
#define INDEX_UNREGISTERDLLS   4
#define INDEX_ADDREG           5
#define INDEX_DELREG           6

typedef struct _PERSECTION_CONTEXT {
    //
    // remember the destinationdir that we're outputting to
    //
    DWORD DestinationDir;

    //
    // remember the keywords we're processing
    //
    DWORD KeywordVector;
} PERSECTION_CONTEXT, *PPERSECTION_CONTEXT;


typedef struct _SETUPINF_CONTEXT {
    FILE * OutFile;
    FILE * OutLayoutFile;
    FILE * OutInfLayoutFile;
    HINF hControlInf;
    HINF hInputInf;
    BOOL AlreadyOutputKeyword;
} SETUPINF_CONTEXT, *PSETUPINF_CONTEXT;

typedef struct _SUBST_STRING {
    PTSTR InputString;
    PTSTR SourceInputString;
    PTSTR OutputString;
} SUBST_STRING,*PSUBST_STRING;

//
// note that WOW64 does file system redirection of system32, but it does NOT do
// redirection of program files, etc.  So we must substitute in the 32 bit
// environment variables in those cases where WOW64 does not do it for us
// automatically
//
SUBST_STRING StringArray[] = {
    //
    // order of these 2 is important!
    //
    { NULL, TEXT("%SystemRoot%\\system32"),      TEXT("%16425%")   },
    { NULL, TEXT("%SystemRoot%"),               TEXT("%10%")   },
    //
    // order of these 2 is important!
    //
    { NULL, TEXT("%CommonProgramFiles%"),  TEXT("%16428%") },
    { NULL, TEXT("%ProgramFiles%"),        TEXT("%16426%")       },
    { NULL, TEXT("%SystemDrive%"),              TEXT("%30%")        }
} ;

PSUBST_STRING StringList;

//
// Keep statistics...
//
INT     ProcessedLines = 0;

TCHAR   InputInf[MAX_PATH];
TCHAR   ControlInf[MAX_PATH];
TCHAR   OLEInputInf[MAX_PATH];
PCTSTR  OutputFile;
PCTSTR  OutputLayoutFile = NULL;
PCTSTR  HeaderText;
PCTSTR  OLESection;
PCTSTR  FilePrefix;
PCTSTR  SectionDecoration;
PCTSTR  ThisProgramName;
WOWLISTACTION Action = WowListMax;
BOOL    fDoAnsiOutput = TRUE;
BOOL    fDoVerboseDebugOutput = FALSE;
BOOL    g_PostBuild = FALSE;
PCTSTR  OutputInfLayoutFile = NULL;

//
// a global scratch buffer for getting a decorated sectionname
//
TCHAR   DecoratedSectionName[MAX_PATH];

//
// global scratch buffer for line data
//
TCHAR LineText[MAX_INF_STRING_LENGTH];
TCHAR ScratchText[MAX_INF_STRING_LENGTH];
TCHAR ScratchTextEnv[MAX_INF_STRING_LENGTH];

PSUBST_STRING InitializeStringList(
    VOID
    )
{
    DWORD SizeNeeded,i;
    PSUBST_STRING StringList;

    SizeNeeded = (sizeof(StringArray)/sizeof(SUBST_STRING)) *
                 (sizeof(SUBST_STRING)+(MAX_PATH*sizeof(TCHAR)));

    StringList = pSetupMalloc( SizeNeeded );

    if (!StringList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    RtlCopyMemory( StringList, &StringArray, sizeof(StringArray) );

    for (i = 0; i < sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
        StringList[i].InputString = (PTSTR) ((PBYTE)StringList + (ULONG_PTR)sizeof(StringArray)+(i*sizeof(TCHAR)*MAX_PATH));

        ExpandEnvironmentStrings( StringList[i].SourceInputString, StringList[i].InputString, MAX_PATH );
    }

    return StringList;

}

PTSTR
MyGetDecoratedSectionName(
    HINF ControlInfHandle,
    PCTSTR String
    )
{
    INFCONTEXT Context;

    _tcscpy(DecoratedSectionName,String);

    if (SectionDecoration){
        _tcscat(DecoratedSectionName,TEXT("."));
        _tcscat(DecoratedSectionName,SectionDecoration);

        if( !SetupFindFirstLine(
            ControlInfHandle,
            DecoratedSectionName,
            NULL,
            &Context)){
            _tcscpy(DecoratedSectionName,String);
        }

    }
        
    return DecoratedSectionName;
    
        
}

void
FixupSetupapiPercents(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine doubles up the '%' char if present in the input string.
    
    
    
Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/
{

    PTCHAR p,q;

    if( !String || !String[0] )
        return;

    p = String;
    q = ScratchTextEnv;

    ZeroMemory(ScratchTextEnv,sizeof(ScratchTextEnv));

    while( *p && (q < (ScratchTextEnv+MAX_INF_STRING_LENGTH-1)) ){

        if (*p == TEXT('%')) {
            *(q++) = TEXT('%');
         }
         *q = *p;

         p++;
         q++;
    }
    *q = 0;

    lstrcpy( String, ScratchTextEnv );

    return;

}

BOOL
pSubstituteEnvVarsForActualPaths(
    IN OUT PTSTR String
    )
/*++

Routine Description:

    This routine filters and outputs the input line.  It looks for a string
    pattern that matches one of a known list of strings, and replaces the
    known string with a substitution string.

Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/

{
    BOOL RetVal = TRUE;

    if (!StringList) {
        StringList = InitializeStringList();
        if (!StringList) {
            RetVal = FALSE;
        }
    }

    if (RetVal) {
        DWORD i;
        PTSTR p,q;
        TCHAR c;

        MYASSERT( StringList != NULL );

        for (i = 0; i< sizeof(StringArray)/sizeof(SUBST_STRING); i++) {
            if (p = StrStrI(String,StringList[i].InputString)) {
                //
                // if we found a hit, then find the end of the string
                // and concatenate that to our source string, which gives
                // the resultant string with substitutions.
                //
                q = p + _tcslen(StringList[i].InputString);
                c = *p;
                *p = TEXT('\0');
                _tcscpy(ScratchTextEnv,String);
                *p = c;
                _tcscat(ScratchTextEnv,StringList[i].OutputString);
                _tcscat(ScratchTextEnv,q);
                _tcscpy(String,ScratchTextEnv);
                //
                // recursively call in case there are more strings.
                //
                pSubstituteEnvVarsForActualPaths(String);
                break;
            }
        }
    }

    return(RetVal);
}

BOOL
MyGetFilePrefix(
    HINF ControlInfHandle,
    PCTSTR Filename,
    PTSTR Prefix
    )
{

    TCHAR Entry[MAX_PATH];
    INFCONTEXT ControlContext;

    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("MyGetFilePrefix: Called for %s\n"), Filename);

    if( !Filename || !Prefix ) {
        _ftprintf(stderr, TEXT("MyGetFilePrefix: Filename or prefix bad - Filename - %s\n"), Filename);
        return FALSE;
    }

    if( !FilePrefix ){
        Prefix[0] = (TCHAR)NULL;
    }else{
        lstrcpy( Prefix, FilePrefix );
    }

    


    if (SetupFindFirstLine(
                        ControlInfHandle,
                        TEXT("NativeDataToWowData.FilePrefixList"),
                        Filename,
                        &ControlContext)) {

        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("MyGetFilePrefix: SetupFindFirstLine succeeded for %s\n"), Filename);
    
        if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("MyGetFilePrefix():SetupGetStringField [%s] failed, ec = 0x%08x\n"),Filename,GetLastError());
        }else{
            lstrcpy( Prefix, Entry );
        }
    }else{
        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("MyGetFilePrefix: SetupFindFirstLine failed for %s - ec = 0x%08x\n"), Filename,GetLastError());
    }

    return TRUE;

}

BOOL
ParseArgs(
    IN int   argc,
    IN TCHAR *argv[]
    )
/*++

Routine Description:

    This function reads the cmdline, translating arguments into the appropriate
    global variable.

Arguments:

    argc - number of arguments from main().
    argv - argument array.

Return Value:

    Boolean value, true indicates that the cmdline arguments are valid.

--*/

{
    int i;
    PTSTR p;
    ThisProgramName = argv[0];


    if(argc < 4) {
        return(FALSE);
    }

    for (i = 0; i < argc; i++) {
        if (argv[i][0] == TEXT('-')) {
            switch (tolower(argv[i][1])) {
                case TEXT('a'):
                    switch(tolower(argv[i][2])) {
                        case TEXT('c'):
                            Action = BuildCopyList;
                            break;
                        case TEXT('o'):
                            Action = BuildOLEList;
                            break;
                        case TEXT('s'):
                            Action = BuildSetupINF;
                            break;
                        default:
                            _ftprintf(stderr, TEXT("unknown arg %s\n"),argv[i]);
                            return(FALSE);
                    }
                    break;
                case TEXT('c'):
                    GetFullPathName(argv[i+1],sizeof(ControlInf)/sizeof(TCHAR),ControlInf,&p);
                    break;
                case TEXT('d'):
                    OutputLayoutFile = argv[i+1];
                    break;
                case TEXT('f'):
                    FilePrefix = argv[i+1];
                    break;
                case TEXT('g'):
                    SectionDecoration = argv[i+1];
                    break;
                case TEXT('h'):
                    HeaderText = argv[i+1];
                    break;
                case TEXT('i'):
                    GetFullPathName(argv[i+1],sizeof(InputInf)/sizeof(TCHAR),InputInf,&p);
                    break;
                case TEXT('l'):
                    GetFullPathName(argv[i+1],sizeof(OLEInputInf)/sizeof(TCHAR),OLEInputInf,&p);
                    break;
                case TEXT('n'):
                    OutputInfLayoutFile = argv[i+1];
                    break;
                case TEXT('o'):
                    OutputFile = argv[i+1];
                    break;
                case TEXT('p'):
                    g_PostBuild = TRUE;
                    break;
                case TEXT('s'):
                    OLESection = argv[i+1];
                    break;
                case TEXT('u'):
                    fDoAnsiOutput = FALSE;
                    break;
                case TEXT('v'):
                    fDoVerboseDebugOutput = TRUE;
                    break;
                default:
                    _ftprintf(stderr, TEXT("unknown arg %s\n"),argv[i]);
                    return(FALSE);
            }
        }
    }

    _ftprintf(stderr, TEXT("%s\n"),InputInf);
    if (Action == WowListMax) {
        return(FALSE);
    }

    return(TRUE);
}

int
myftprintf(
    FILE * FileHandle,
    BOOL AnsiOutput,
    PCTSTR FormatString,
    ...
    )
{
    va_list arglist;
    TCHAR text[MAX_INF_STRING_LENGTH];
    DWORD d;
    int retval;



    va_start(arglist,FormatString);

    _vstprintf(text,FormatString,arglist);


#ifdef UNICODE

    if (AnsiOutput) {
        PCSTR TextA = pSetupUnicodeToAnsi(text);
        retval = fputs(TextA,FileHandle);
        pSetupFree(TextA);
    } else {
        PWSTR p,q;
        // Assume we opened the file in binary mode for Unicode stream I/O
        p = text;
        while(1){
            if( q = wcschr( p, L'\n' )){
                *q=L'\0';
                retval = fputws(p,FileHandle);
                retval = fputws(L"\r\n", FileHandle);
                if( *(q+1) )
                    p = q+1;
                else
                    break;
            }else{
                retval = fputws(p,FileHandle);
                break;
            }
        }
        
    }

#else

    if (AnsiOutput) {
        retval = fputs(text,FileHandle);
    } else{
        PCWSTR TextW = pSetupAnsiToUnicode(text);
        retval = fputws(TextW,FileHandle);
        pSetupFree(TextW);
    }

#endif


    return(retval);
}

BOOL
AppendWowFileToCopyList(
    IN HINF  hControlInf,
    IN PINFCONTEXT LineContext,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine appends the file specified by LineContext to the output file,
    writing the data in a form required by textmode setup.  see layout.inx for
    a detailed description of this syntax.

Arguments:

    hControlInf - inf handle that contains control directives.
    LineContext - inf context from layout.inf for the file we want to output.
    OutFile - file handle to write the data into

Return Value:

    Boolean value, true indicates the file was properly written.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    TCHAR TempFileName[MAX_PATH], FileName[MAX_PATH], Prefix[40];
    BOOL RetVal;

    DWORD EntryCount,i;

    
    ZeroMemory(LineText,sizeof(LineText));
    ZeroMemory(Prefix,sizeof(Prefix));

    

    //
    // get the filename
    //
    if (!SetupGetStringField(
                    LineContext,
                    0,
                    TempFileName,
                    sizeof(TempFileName)/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Current File - %s\n"),TempFileName);

    MyGetFilePrefix( hControlInf, TempFileName, Prefix );
    _tcscpy(FileName, Prefix);
    _tcscat(FileName, TempFileName );

    

    EntryCount = SetupGetFieldCount(LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[40];
        INFCONTEXT ControlContext;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(LineContext,i,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // now do any necessary substitutions
        //

        //
        // SourceDisksNames substitution
        //
        if (i == 1) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.SourceInfo"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        //
        // Directory Id substitution
        //
        if (i == 8) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.DirectoryInformation.Textmode"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        //
        // filename rename
        //
        if (i == 11) {
            //
            // if there was already a renaming to be done, then just use that.
            // otherwise we may have to add a rename entry if there was a
            // filename prefix
            //
            if (Entry[0] == (TCHAR)NULL) {
               if (Prefix[0]) {
                  _tcsncpy(Entry, TempFileName, AS(Entry));
               }
            }
        }

        _tcscat(LineText, Entry);

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

        //
        // filename rename
        //
        if (EntryCount < 11 && i == EntryCount) {
            //
            // if there is no renaming to be done, we may have to add a rename
            // entry if there was a filename prefix
            //
            if (Prefix[0]) {
               DWORD j;
               for (j=i;j<11;j++) {
                  _tcscat(LineText, TEXT(","));
               }
               _tcscat(LineText, TempFileName);
            }
        }



    }

    if( g_PostBuild ){
        myftprintf(OutFile, fDoAnsiOutput, TEXT("%s:%s=%s\n"),TempFileName,FileName,LineText);
    }else{
        myftprintf(OutFile, fDoAnsiOutput, TEXT("%s=%s\n"),FileName,LineText);
    }

    RetVal = TRUE;

exit:
    return(RetVal);
}

BOOL
AppendWowFileToOLEList(
    IN HINF  hControlInf,
    IN HINF  hOLEInputInf,
    IN PINFCONTEXT LineContext,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine appends the file specified by LineContext to the output file,
    writing the data in OLE Registration form.

    OLE Registration form is as follows:

    <DIRID>,<subdir>,filename,[flags]

    where <DIRID> is a standard setupapi DIRID; <subdir> is optional and
    represents a subdir of the given directory; filename is the name
    of the dll.


Arguments:

    hControlInf - inf handle that contains control directives.
    hOLEInputInf - inf handle that contains OLE list information.
    LineContext - inf context from layout.inf for the file we want to output.
    OutFile - file handle to write the data into

Return Value:

    Boolean value, true indicates the file was properly written.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT OLEContext;

    DWORD EntryCount,i;


    ZeroMemory(LineText,sizeof(LineText));

    EntryCount = SetupGetFieldCount(LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[MAX_INF_STRING_LENGTH];
        INFCONTEXT ControlContext;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(LineContext,i,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Entry (1)- %s\n"),Entry);
        FixupSetupapiPercents(Entry);
        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Entry (2)- %s\n"),Entry);
        pSubstituteEnvVarsForActualPaths(Entry);

        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Entry (3)- %s\n"),Entry);

        //
        // now do any necessary substitutions
        //

        //
        // DIRID substitution
        //
        if (i == 1) {
            //
            // look in the appropriate control inf section for the data
            //
            if (!SetupFindFirstLine(
                            hControlInf,
                            TEXT("NativeDataToWowData.DirectoryInformation.SetupAPI"),
                            Entry,
                            &ControlContext)) {
                _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto exit;
            }

            if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto exit;
            }

        }

        _tcscat(LineText, Entry);

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }

    }

    myftprintf(OutFile, TRUE, TEXT("%s\n"),LineText);

    RetVal = TRUE;

exit:
    return(RetVal);
}


BOOL
IsWowFile(
    IN HINF  hControlInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine determines if the specified file is to be installed for
    as a wow file.

    This is determined by comparing directives in the control inf with
    the installation information in file inf context.


Arguments:

    hControlInf - inf handle that contains control directives.
    LineContext - inf context from layout.inf for the file we want to examine.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal = FALSE;
    TCHAR FileName[40];
    DWORD Disposition,DirectoryId;
    PTSTR p;

    INFCONTEXT ControlContext;
    TCHAR Extension[8];
    DWORD ExtensionCount,i;
    DWORD ControlDirId;

    //
    // get the filename
    //
    if (!SetupGetStringField(LineContext,0,FileName,sizeof(FileName)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    //
    // see if the file is in our "exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Files.Exclude"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our exclusion list\n"),
                FileName);
        RetVal = FALSE;
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

    //
    // see if the file is in our "inclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Files.Include"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("force inclusion of [%ws] because it's in our inclusion list\n"),
                FileName);
        RetVal = TRUE;
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

    //
    // see if the file is installed by textmode setup
    //
    if (!SetupGetIntField(LineContext,9,&Disposition)) {
        _ftprintf(stderr, TEXT("SetupGetIntField (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    if (Disposition == 3) {
        _ftprintf(stderr, TEXT("[%ws] is not an installed file\n"),FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = FALSE;
        goto e0;
    }

    //
    // get the extension of the file and compare it to the list of extensions
    // we're trolling for
    //
    p = _tcsrchr( FileName, TEXT('.') );
    if (p) {
        p+=1;
    } else {
        _ftprintf(stderr, TEXT("[%ws] does not have a file extension\n"),FileName);
        p = TEXT("");
    }



    if(!SetupFindFirstLine(
                        hControlInf,
                        TEXT("WowData.Filter"),
                        TEXT("FileExtensions"),
                        &ControlContext
                        )) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine (ControlInf) failed\n"));
        RetVal = FALSE;
        goto e0;
    }

    RetVal = FALSE;
    

    do{

        ExtensionCount = SetupGetFieldCount(&ControlContext);
        //
        // this is a 1-based index
        //
        for (i = 1; i <= ExtensionCount ; i++) {
            if (SetupGetStringField(&ControlContext,i,Extension,sizeof(Extension)/sizeof(TCHAR),NULL)) {
                if (_tcsicmp(Extension,p)==0) {
                   RetVal = TRUE;
                   break;
                }
            }else{
                _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
                RetVal = FALSE;
                goto e0;

            }
        }

    }while(SetupFindNextMatchLine(&ControlContext, TEXT("FileExtensions"), &ControlContext));

    if (!RetVal) {
        _ftprintf(stderr, TEXT("%ws does not match extension list\n"),FileName);
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }



    //
    // get the directory the file is installed into and see if it's in our list
    // of directories we're trolling for.
    //
    if (!SetupGetIntField(LineContext,8,&DirectoryId)) {
        _ftprintf(stderr, TEXT("SetupGetIntField (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    RetVal = FALSE;
    if(!SetupFindFirstLine(
                        hControlInf,
                        TEXT("WowData.Filter"),
                        TEXT("DirectoryToMap"),
                        &ControlContext
                        )) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto e0;
    }

    do {

        if (!SetupGetIntField(&ControlContext,1,&ControlDirId)) {
            _ftprintf(stderr, TEXT("SetupGetIntField (\"DirectoryToMap\") (%ws) failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto e0;
        }

        if (ControlDirId == DirectoryId) {
            RetVal = TRUE;
            break;
        }

    } while ( SetupFindNextMatchLine(&ControlContext,TEXT("DirectoryToMap"),&ControlContext ));

    if (!RetVal) {
        _ftprintf(stderr, TEXT("directory id %d for [%ws] is not in list\n"),DirectoryId,FileName);
        SetLastError(ERROR_SUCCESS);
        goto e0;
    }

e0:
    return(RetVal);
}

BOOL
IsWowOLEFile(
    IN HINF  hControlInf,
    IN HINF  hInputInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine determines if the specified file requires OLE self
    registration.

    This is determined by comparing directives in the control inf with
    the installation information in file inf context.


Arguments:

    hControlInf - inf handle that contains control directives.
    hInputInf   - inf handle that contains layout information.
    LineContext - inf context from syssetup.inf for the file we want to examine.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal = FALSE;
    TCHAR FileName[40];
    PTSTR p;
    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;

    INFCONTEXT ControlContext,InfContext;
    INFCONTEXT InputContext;


    //
    // get the filename
    //
    FileName[0] = L'\0';
    if (!SetupGetStringField(LineContext,3,FileName,sizeof(FileName)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto e0;
    }


    MYASSERT(FileName[0] != (TCHAR)NULL);

    //
    // see if the file is in our "exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.OLEList.Exclude"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our exclusion list\n"),
                FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = FALSE;
        goto e0;
    }

    //
    // see if the file is in our "inclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.OLELIst.Include"),
                    FileName,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("force inclusion of [%ws] because it's in our inclusion list\n"),
                FileName);
        SetLastError(ERROR_SUCCESS);
        RetVal = TRUE;
        goto e0;
    }

    //
    // see if the file is in the layout file and if it is,
    // we have success
    //
    //
    // get the required architecture decoration
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Filter"),
                    TEXT("SourceArchitecture"),
                    &InfContext) ||
        !SetupGetStringField(
                    &InfContext,
                    1,
                    SourceArchitecture,
                    sizeof(SourceArchitecture)/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr,TEXT("Unable to get SourceArchitecture\n"));
        goto e0;
    }

    FirstTime = TRUE;
    _tcscpy(SourceDiskFiles, TEXT("SourceDisksFiles"));

    while (TRUE) {
        DWORD FileCount;

        if (!FirstTime) {
            _tcscat(SourceDiskFiles,TEXT("."));
            _tcscat(SourceDiskFiles,SourceArchitecture);
        }

        if(SetupFindFirstLine(
                        hInputInf,
                        SourceDiskFiles,
                        FileName,
                        &InputContext) &&
           IsWowFile(hControlInf,&InputContext)) {
            RetVal = TRUE;
            break;
        }

        if (!FirstTime) {
            RetVal = FALSE;
            break;
        }

        FirstTime = FALSE;

    }

e0:
    SetLastError(ERROR_SUCCESS);
    return(RetVal);
}



BOOL
DoCopyListSection(
    IN PCTSTR  InputSectionName,
    IN HINF    hInputInf,
    IN HINF    hControlInf,
    IN FILE   *OutFile
    )
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    TCHAR      SourceFileName[MAX_PATH];

    if(!SetupFindFirstLine(
                        hInputInf,
                        InputSectionName,
                        NULL,
                        &InputContext)){
        _ftprintf(stderr, TEXT("%s: Warning - Section %s not present: Ignoring Section\n"), ThisProgramName, InputSectionName);
        return(TRUE);

    }

    SectionCount = SetupGetLineCount(hInputInf,InputSectionName);

    
    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndex(hInputInf, InputSectionName, i, &InputContext)) {
            if (IsWowFile(hControlInf,&InputContext)) {

                AppendWowFileToCopyList(hControlInf,&InputContext, OutFile);

            } else if (GetLastError() != NO_ERROR) {
                _ftprintf(stderr, TEXT("IsWowFile failed\n"));
                return(FALSE);
            }
        } else {
            _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }

        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoCopyList(
    IN PCTSTR InputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile
    )
{
    PCWSTR InputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    INFCONTEXT InfContext;
    FILE *HeaderFile;

    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;


    BOOL b;

    b = TRUE;

    
    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }

#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif

    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInfA, GetLastError());
        goto e1;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e2;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e3;
    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
      fclose(HeaderFile);
    }
    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // get the required architecture decoration
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("WowData.Filter"),
                    TEXT("SourceArchitecture"),
                    &InfContext) ||
        !SetupGetStringField(
                    &InfContext,
                    1,
                    SourceArchitecture,
                    sizeof(SourceArchitecture)/sizeof(TCHAR),
                    NULL)) {
        _ftprintf(stderr,TEXT("Unable to get SourceArchitecture\n"));
        goto e4;
    }

    FirstTime = TRUE;
    _tcscpy(SourceDiskFiles, TEXT("SourceDisksFiles"));
    
    while (TRUE) {
        DWORD FileCount;

        if (!FirstTime) {
            _tcscat(SourceDiskFiles,TEXT("."));
            _tcscat(SourceDiskFiles,SourceArchitecture);
        }

        DoCopyListSection(
            SourceDiskFiles,
            hInputInf,
            hControlInf,
            OutFile
            );

        if (FirstTime) {
            FirstTime = FALSE;
        } else {
            break;
        }

    }


e4:
    SetupCloseInfFile( hControlInf );
e3:
    SetupCloseInfFile( hInputInf );
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}



BOOL
DoOLEListSection(
    IN HINF    hInputInf,
    IN HINF    hOLEInputInf,
    IN HINF    hControlInf,
    IN FILE   *OutFile
    )
/*++

Routine Description:

    This routine iterates through all files in the input inf specified by the
    section name.  If the specified file is a WOW file, then we check if it
    is in the ole registration list.  If it is, then we do the appropriate
    transform on the data and output the data to our data file.

Arguments:

    hInputInf        - inf handle with file list in it.
    hOLEInputInf     - inf handle with ole lists in it.
    hControlInf      - inf handle for control inf that drives our filters
    OutFile          - file handle where the output data gets placed into

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    DWORD SectionCount, i;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    TCHAR      SourceFileName[MAX_PATH];

    SetupFindFirstLine(
                        hOLEInputInf,
                        OLESection,
                        NULL,
                        &InputContext);

    SectionCount = SetupGetLineCount(hOLEInputInf,OLESection);

    for (i = 0; i < SectionCount; i++) {
        if (SetupGetLineByIndex(hOLEInputInf, OLESection, i, &InputContext)) {
            if (IsWowOLEFile(hControlInf,hInputInf, &InputContext)) {

                AppendWowFileToOLEList(hControlInf,hOLEInputInf,&InputContext, OutFile);

            } else if (GetLastError() != NO_ERROR) {
                _ftprintf(stderr, TEXT("IsWowOLEFile failed\n"));
                return(FALSE);
            }
        } else {
            _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
            return(FALSE);
        }

        ProcessedLines += 1;
    }

    return(TRUE);
}

BOOL
DoOLEList(
    IN PCTSTR InputInfA,
    IN PCTSTR OLEInputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile
    )
/*++

Routine Description:

    This routine runs through the list of specified files in the input inf
    and feeds them into a worker routine which will build the list of OLE
    Control dlls.

Arguments:

    InputInfA -    name of input inf containing the files to be run through
                   our "filter"
    OLEInputInfA - name of input inf containing the ole directives to be
                   processed
    ControlInfA  - name of the control inf that tells us how to parse the
                   input infs
    OutFile      - file pointer for the file to be written

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    PCWSTR InputInf;
    PCWSTR OLEInputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    HINF hOLEInputInf;
    INFCONTEXT InfContext;
    FILE *HeaderFile;

    BOOL b = FALSE;

    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }
#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif
    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInf, GetLastError());
        goto e1;
    }

#ifdef UNICODE
    OLEInputInf = OLEInputInfA;
#else
    OLEInputInf = pSetupAnsiToUnicode(OLEInputInfA);
#endif

    if (!OLEInputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),OLEInputInfA, GetLastError());
        goto e2;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e3;
    }

    hOLEInputInf = SetupOpenInfFileW(OLEInputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hOLEInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),OLEInputInf, GetLastError());
        goto e4;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e5;
    }

    myftprintf(OutFile, TRUE, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
    }

    myftprintf(OutFile, TRUE, TEXT("\n"));


    b = DoOLEListSection(
             hInputInf,
             hOLEInputInf,
             hControlInf,
             OutFile
             );

    SetupCloseInfFile( hControlInf );
e5:
    SetupCloseInfFile( hOLEInputInf );
e4:
    SetupCloseInfFile( hInputInf );
e3:
#ifndef UNICODE
    pSetupFree(OLEInputInf);
#endif
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}

BOOL
pFilterSetupInfSection(
    PVOID FilteredSectionsStringTable,
    PCTSTR SectionName,
    PSETUPINF_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines if a given section should be filtered by
    looking in the control inf for the directives that we're interested
    in.

Arguments:

    FilteredSectionsStringTable - pointer to a string table which we'll
        add our filtered section name to if we find a hit

    SectionName - name of the section in the INF we're interested in

    Context - contains context information for this function, like
              input infs name, etc.

Return Value:

    Boolean value, true indicates the file is a wow file.

--*/
{
    BOOL RetVal;
    TCHAR KeywordList[MAX_PATH];
    PCTSTR CurrentKeyword;
    DWORD KeywordBitmap;
    INFCONTEXT ControlInfContext;
    DWORD i;
    BOOL AlreadyOutputSectionName,AlreadyOutputKeyword;

    //
    // get the keywords that we're supposed to map.
    //
    // bugbug look at having a per-inf extension to this
    //
    if (!SetupFindFirstLine(
                        Context->hControlInf,
                        MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                        TEXT("Keywords"),
                        &ControlInfContext)) {
        _ftprintf(stderr, TEXT("Could not get Keywords line in [NativeDataToWowData.SetupINF.Keyword]: SetupFindFirstLine failed, ec = 0x%08x\n"),GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    //
    // now look for each keyword
    //
    SetupGetIntField(&ControlInfContext,1,&KeywordBitmap);

    AlreadyOutputSectionName = FALSE;
    AlreadyOutputKeyword = FALSE;
    CurrentKeyword = NULL;
    for (i = 0; i < 32;i++) {
        INFCONTEXT InputInfContext;
        INFCONTEXT ContextDirId;
        BOOL LookatDirIds;
        DWORD FieldCount,Field;
        TCHAR ActualSectionName[LINE_LEN];

        if (KeywordBitmap & (1<<i)) {
            CurrentKeyword = KeywordArray[i];
            MYASSERT( CurrentKeyword != NULL);
        }

        if (!CurrentKeyword) {
            continue;
        }

        if (!SetupFindFirstLine(
                          Context->hControlInf,
                          MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                          CurrentKeyword,
                          &ContextDirId)) {
            _ftprintf(stderr, TEXT("Could not get %s line in [NativeDataToWowData.SetupINF.Keyword]: SetupFindFirstLine failed, ec = 0x%08x\n"), CurrentKeyword, GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // field 2 is "MapDirId".  If it's specified, then we
        // need to look at the destinationdirs keyword
        //
        LookatDirIds = (SetupGetFieldCount(&ContextDirId)>=2) ? TRUE : FALSE;

        //
        // look for specified keyword in our section
        //
        if (SetupFindFirstLine(
                          Context->hInputInf,
                          SectionName,
                          CurrentKeyword,
                          &InputInfContext
                          )) {
            //
            // we found a hit.  see if we need to map this keyword
            //
            do {

                //
                // each field is a section name.
                //
                FieldCount = SetupGetFieldCount(&InputInfContext);
                for(Field=1; Field<=FieldCount; Field++) {
                    BOOL MapThisSection = FALSE;
                    TCHAR DirId[LINE_LEN];
                    DWORD MappedDirId = 0;
                    INFCONTEXT InputDirId,ControlDirId;

                    SetupGetStringField(&InputInfContext,Field,ActualSectionName,LINE_LEN,NULL);

                    //
                    // if we need to look at the destination dirs keyword,
                    // then look it up and compare it against the control inf
                    // mapper
                    //
                    if (LookatDirIds) {
                        if(!SetupFindFirstLine(
                                        Context->hInputInf,
                                        TEXT("DestinationDirs"),
                                        ActualSectionName,
                                        &InputDirId)) {
                            if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x finding %s in %s \n"),GetLastError(), ActualSectionName, TEXT("DestinationDirs"));

                            if(!SetupFindFirstLine(
                                        Context->hInputInf,
                                        TEXT("DestinationDirs"),
                                        TEXT("DefaultDestDir"),
                                        &InputDirId)) {
                                _ftprintf(stderr, TEXT("SetupFindFirstLine failed, ec = 0x%08x finding %s in %s\n"),GetLastError(), TEXT("DefaultDestDir"), TEXT("DestinationDirs"));
                                RetVal = FALSE;
                                goto exit;
                            }
                        }

                        if(SetupGetStringField(&InputDirId,1,DirId,LINE_LEN,NULL) &&
                                SetupFindFirstLine(
                                               Context->hControlInf,
                                               MyGetDecoratedSectionName(Context->hControlInf, TEXT("NativeDataToWowData.SetupINF.DestinationDirsToMap")),
                                               DirId,
                                               &ControlDirId)) {
                            //
                            // we found a hit, thus we should map this section
                            //
                            MapThisSection = TRUE;
                            SetupGetIntField(&ControlDirId,1,&MappedDirId);
                            if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Mapping %s to %lu\n"), DirId, MappedDirId);

                        }
                    } else {
                        MapThisSection = TRUE;
                    }

                    if (MapThisSection) {
                        DWORD StringId;
                        PERSECTION_CONTEXT SectionContext;
                        BOOL AddNewEntry;
                        //
                        // output the toplevel section name if we haven't done
                        // so already.  this section name is not decorated
                        //
                        if (!AlreadyOutputSectionName) {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n[%s]\n"),SectionName);
                            AlreadyOutputSectionName = TRUE;
                        }

                        //
                        // output the keyword and decorated section name
                        // note that we need to separate the section names
                        // by a comma
                        //
                        if (!AlreadyOutputKeyword) {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s="), CurrentKeyword);
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s%s"),FilePrefix,ActualSectionName);
                            AlreadyOutputKeyword = TRUE;
                        } else {
                            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT(",%s%s"),FilePrefix,ActualSectionName);
                        }

                        //
                        // now append the section to the string table
                        //
                        StringId = pSetupStringTableLookUpString(
                                            FilteredSectionsStringTable,
                                            (PTSTR)ActualSectionName,
                                            STRTAB_CASE_INSENSITIVE);

                        if (StringId != -1) {
                            pSetupStringTableGetExtraData(
                                            FilteredSectionsStringTable,
                                            StringId,
                                            &SectionContext,
                                            sizeof(SectionContext));
                            AddNewEntry = FALSE;
                        } else {
                            RtlZeroMemory(&SectionContext,sizeof(SectionContext));
                            AddNewEntry = TRUE;
                        }

                        SectionContext.DestinationDir = MappedDirId;
                        SectionContext.KeywordVector |= (1<<i);

                        if (AddNewEntry) {

                            if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Adding %s to string table\n"), ActualSectionName);

                            if ( -1 == pSetupStringTableAddStringEx(
                                            FilteredSectionsStringTable,
                                            (PTSTR)ActualSectionName,
                                            STRTAB_CASE_SENSITIVE | STRTAB_NEW_EXTRADATA,
                                            &SectionContext,
                                            sizeof(SectionContext))){

                                _ftprintf(stderr, TEXT("Could not add %s to string table\n"), ActualSectionName);


                            }
                        } else {

                            if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Adding %s to string table\n"), ActualSectionName);

                            if ( !pSetupStringTableSetExtraData(
                                            FilteredSectionsStringTable,
                                            StringId,
                                            &SectionContext,
                                            sizeof(SectionContext))){

                                _ftprintf(stderr, TEXT("Could not add %s to string table\n"), ActualSectionName);}
                        }
                    }
                }

            } while ( SetupFindNextMatchLine(&InputInfContext,
                                             CurrentKeyword,
                                             &InputInfContext ));

        }

        if (AlreadyOutputKeyword) {
            myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n"));
        }
        //
        // reset this for the next keyword
        //
        AlreadyOutputKeyword = FALSE;
        CurrentKeyword = NULL;

    }

exit:
    return(RetVal);
}

BOOL
AppendSetupInfDataToLayoutFile(
    IN FILE  *OutFile,
    IN FILE  *OutInfFile,
    IN HINF  hControlInf,
    IN HINF  hInputInf,
    IN PINFCONTEXT LineContext
    )
/*++

Routine Description:

    This routine filters and outputs a layout line.

    We only need to filter "Copyfiles" sections, and since the files are
    not installed by textmode setup, the line which we output is largely
    hardcoded.


Arguments:

    OutFile      - output file handle
    
    OutInfFile   - output file handle for layout information within INF

    hControlInf  - inf handle to the inf with the control directives

    LineContext  - inf context to the input line we want to filter.

Return Value:

    Boolean indicating outcome.

--*/
{
    TCHAR FileName[MAX_PATH],InfField[MAX_PATH],Entry[50], Prefix[40];
    INFCONTEXT ControlContext;
    BOOL RetVal;
    INT SourceID = 1;
    TCHAR SourceIDStr[6], DefaultIDStr[6];
    BOOL LayoutWithinInf = FALSE;

    DWORD EntryCount,i;


    ZeroMemory(Entry,sizeof(Entry));
    ZeroMemory(Prefix,sizeof(Prefix));

    
    //
    // get the source filename
    //
    EntryCount = SetupGetFieldCount(LineContext);
    if ((((EntryCount <= 1)
        || !SetupGetStringField(LineContext,2,InfField,MAX_PATH,NULL)
        || !InfField[0]))
        && (!SetupGetStringField(LineContext,1,InfField,MAX_PATH,NULL)
                || !InfField[0])) {
        //
        // bad line?
        //
        MYASSERT(0);
        _ftprintf(stderr, TEXT("AppendSetupInfDataToLayoutFile: Could not get source filename - ec = 0x%08x\n"), GetLastError());
    }

    MyGetFilePrefix( hControlInf, InfField, Prefix );
    _tcscpy(FileName, Prefix);
    _tcscat(FileName, InfField );

    

    //
    // see if the file is in our "SetupInf exclusion list"
    //
    if(SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("WowData.SetupInfLayout.Exclude")),
                    InfField,
                    &ControlContext) ||
        SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExclude")),
                    InfField,
                    &ControlContext)) {
        _ftprintf(stderr,
                TEXT("filtering %ws because it's in our SetupInf exclusion list\n"),
                InfField);
        RetVal = FALSE;
        goto exit;
    }

    //
    // Get Default Source ID
    // By default this means the Source ID that is processed for dosnet.inf, txtsetup.sif etc.
    // i.e layout.inf today only has = 1,,,,,,, type of entries that translate to = 55,,,,,
    // Currently we can support only one such mapping as the default translation
    // That means that we will take SourceDisksFiles entries pertaining to the default and always output it into the layout.inf stub
    // so that dosnet.inf gets it.
    //


    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("NativeDataToWowData.SourceInfo"),
                    TEXT("Default"), //bugbug need a way to get this for other source disks
                    &ControlContext) ||

        !SetupGetStringField(&ControlContext,1,DefaultIDStr,sizeof(DefaultIDStr)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine to get default SourceID for file %s failed - Using %s, ec = 0x%08x\n"),FileName,DefaultIDStr,GetLastError());
        // As last resort use 1
        lstrcpy( DefaultIDStr, TEXT("1"));
    }


    if( !SetupGetSourceFileLocation(hInputInf,
                               LineContext,
                               NULL,
                               &SourceID,
                               NULL,
                               0,
                               NULL)){


        _ftprintf(stderr, TEXT("SetupGetSourceFileLocation [%s] failed - Using SourceID 1, ec = 0x%08x\n"),FileName,GetLastError());
        //Assume Default
        lstrcpy( SourceIDStr, DefaultIDStr);
        LayoutWithinInf = FALSE;
    }else{
        LayoutWithinInf = TRUE;;
        _itot( SourceID, SourceIDStr, 10);
    }
    


    //
    // look in the appropriate control inf section for the data
    //
    if (!SetupFindFirstLine(
                    hControlInf,
                    TEXT("NativeDataToWowData.SourceInfo"),
                    SourceIDStr, 
                    &ControlContext)) {
        _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x finding %s key in [NativeDataToWowData.SourceInfo]\n"),FileName,GetLastError(), SourceIDStr);
        RetVal = FALSE;
        goto exit;
    }

    if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
        _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
        RetVal = FALSE;
        goto exit;
    }

    if( LayoutWithinInf && OutInfFile){
        //If we found SourceFileInfo within this file and we were
        //asked to add the WOW equivalent to the same INF then do so.
        myftprintf(OutInfFile, fDoAnsiOutput, TEXT("%s:%s=%s,,,,,,,,3,3\n"),InfField,FileName,Entry);

        //Also if the SourceID matches the default we want to output to the layout.inf stub as well so 
        //that it makes it into dosnet.inf. See earlier comments about the DefaultIDStr
        //InfField is the filename without the prefix - useful for postbuild. Has to be stripped out before appending the layout.inf stub.

        if( !lstrcmpi( SourceIDStr, DefaultIDStr )){
            myftprintf(OutFile, TRUE, TEXT("%s:%s=%s,,,,,,,,3,3\n"),InfField,FileName,Entry);
        }

    }else{
        myftprintf(OutFile, TRUE, TEXT("%s:%s=%s,,,,,,,,3,3\n"),InfField,FileName,Entry);
    }
    
    RetVal = TRUE;

exit:
    return(RetVal);
}





void
HandleSetupapiQuotingForString( 
    IN OUT PTSTR String 
    )
/*++

Routine Description:

    This routine looks at the passed in line and does the right quoting and handling of
    the string to handle characters that may have been stripped off by setupapi.
    
    It first scans through the string looking for characters <= 0x20, '\"','%','\\'
    If it finds any of these then it places a " at the beginning and end of the string. Additionally it doubles
    every quote within.
    
    
Arguments:

    String       - input string to be searched.  We edit this string
                   in-place if we find a match.

Return Value:

    Boolean indicating outcome.

--*/
{
    PTCHAR p,q;
    BOOL Pass2Needed = FALSE;

    

    if( !String || !String[0] )
        return;

    p = String;

    //
    // [askhalid] ',' Need to be considered as well
    //
    while( *p ){
        if( (*p <= 0x20) || (*p == TEXT('\"')) || (*p == TEXT(',')) || (*p == TEXT(';')) ||(*p == TEXT('%')) || (*p == TEXT('\\')))
            Pass2Needed = TRUE;
        p++;
    }// while

    if( Pass2Needed ){
        // Quote the start
        p = String;
        q = ScratchTextEnv+1;

        ZeroMemory(ScratchTextEnv,sizeof(ScratchTextEnv));

        ScratchTextEnv[0] = TEXT('\"');
        
        while( *p && (q < (ScratchTextEnv+MAX_INF_STRING_LENGTH-3)) ){
        
            // If we have a quote in the string double it

            if (*p == TEXT('\"')) {
                *(q++) = TEXT('\"');
            }
            *q = *p;
    
            p++;q++;

        }// while

        // Quote the end
        *(q++) = TEXT('\"');
        *q = 0;

        lstrcpy( String, ScratchTextEnv );
    }

    return;

}



BOOL
AppendSetupInfDataToSection(
    IN FILE *OutFile,
    IN HINF hControlInf,
    IN PINFCONTEXT InputContext,
    IN PCTSTR KeywordName
    )
/*++

Routine Description:

    This routine filters and outputs an input line.  The control inf
    lists the syntax for the specified keyword.  We filter the keywords
    we know about and let the other ones just fall through.

Arguments:

    OutFile      - output file handle

    hControlInf  - inf handle to the inf with the control directives

    InputContext - inf context to the input line we want to filter.

    KeywordName  - string indicating the keyword associated with the section
                   we are filtering.

Return Value:

    Boolean indicating outcome.

--*/
{
    TCHAR FileName[40], Prefix[40];
    TCHAR KeyName[LINE_LEN];
    TCHAR Cmd[LINE_LEN];
    BOOL RetVal;
    DWORD EntryCount,i;
    INFCONTEXT ControlContext,KeywordContext;

    //
    // ISSUE-2000/06/27-JamieHun Appears to be no error checking here, someone should fix this
    //
    SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.Keyword")),
                KeywordName,
                &ControlContext);

    if(SetupGetStringField(&ControlContext,1,KeyName,LINE_LEN,NULL)) {
        SetupFindFirstLine(
                    hControlInf,
                    MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.Syntax")),
                    KeyName,
                    &KeywordContext);
    }

    ZeroMemory(LineText,sizeof(LineText));
    FileName[0] = TEXT('\0');

   if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("KeywordName - %s\n"),KeywordName);

    EntryCount = SetupGetFieldCount(InputContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR ScratchEntry[MAX_PATH];

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(InputContext,i,ScratchText,sizeof(ScratchText)/sizeof(TCHAR),NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
            RetVal = FALSE;
            goto exit;
        }


        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("ScratchText (1)- %s\n"),ScratchText);
        FixupSetupapiPercents(ScratchText);
        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("ScratchText (2)- %s\n"),ScratchText);
        pSubstituteEnvVarsForActualPaths(ScratchText);

        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("ScratchText (3)- %s\n"),ScratchText);

        //
        // now do any necessary substitutions
        //
        if(SetupGetStringField(&KeywordContext,i,Cmd,LINE_LEN,NULL)
            && Cmd[0]) {

            //
            // dirid substitution
            //
            if (!_tcsicmp(Cmd,TEXT("MapDirId"))) {
                //
                // look in the appropriate control inf section for the data
                //
                if (!SetupFindFirstLine(
                                hControlInf,
                                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.DestinationDirsToMap")),
                                ScratchText,
                                &ControlContext)) {
                    _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }

                if (!SetupGetStringField(&ControlContext,1,ScratchText,sizeof(ScratchText)/sizeof(TCHAR),NULL)) {
                    _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }
            }

            //
            // source name substitution
            //
            if (!_tcsicmp(Cmd,TEXT("srcname"))) {

                MyGetFilePrefix( hControlInf, FileName, Prefix );
                LSTRCPY(ScratchEntry,Prefix);
                if (ScratchText[0]) {
                    LSTRCAT(ScratchEntry,ScratchText);
                } else {
                    LSTRCAT(ScratchEntry,FileName);
                }

                LSTRCPY(ScratchText,ScratchEntry);
            }

            //_ftprintf(stderr, TEXT("ScratchText(2) - %s\n"),ScratchText);


            if (!_tcsicmp(Cmd,TEXT("RegistryFlags"))) {
                DWORD RegVal,CurrentRegVal;
                //
                // look in the appropriate control inf section for the data
                //
                if (!SetupFindFirstLine(
                                hControlInf,
                                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.RegistryInformation")),
                                TEXT("RegistryFlags"),
                                &ControlContext)) {
                    _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                    RetVal = FALSE;
                    goto exit;
                }

                CurrentRegVal = 0;
                RegVal = 0;
                SetupGetIntField(&ControlContext,1,&RegVal);
                SetupGetIntField(InputContext,i,&CurrentRegVal);

                CurrentRegVal |= RegVal;

                _stprintf(ScratchText, TEXT("0x%08x"), CurrentRegVal);

            }


            if (!_tcsicmp(Cmd,TEXT("dstname"))) {
                LSTRCPY(FileName,ScratchText);
            }

            

        }


        HandleSetupapiQuotingForString(ScratchText); 

        _tcscat(LineText, ScratchText);
        

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(LineText, TEXT(","));
        }
        

    }

    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("LineText - %s\n"),LineText);


    //
    // Check if we need to exclude the DLL
    //

    if (KeywordName == KeywordArray[INDEX_COPYFILES] ||
        KeywordName == KeywordArray[INDEX_DELFILES] ||
        KeywordName == KeywordArray[INDEX_RENFILES] ||
        KeywordName == KeywordArray[INDEX_REGISTERDLLS]){

    
        // Check if we need to exclude this file from processing

        if( SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExclude")),
                FileName,
                &ControlContext)){

            return TRUE;
        }

    }

    
    if (KeywordName == KeywordArray[INDEX_COPYFILES]) {

        //
        // if we didn't have a file rename in copyfiles, we add it now.
        //
    
        if ((--i) < SetupGetFieldCount(&KeywordContext)) {
            _tcscat(LineText, TEXT(","));
            if( MyGetFilePrefix( hControlInf, FileName, Prefix )){
                _tcscat(LineText, Prefix);
            }
            _tcscat(LineText, FileName);
        }
        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("LineText(2) - %s\n"),LineText);

    } else if (KeywordName == KeywordArray[INDEX_ADDREG] ||
               KeywordName == KeywordArray[INDEX_DELREG]) {
        //
        // we need to pad out AddReg or DelReg if necessary.
        //
        DWORD count;
        TCHAR Entry[MAX_PATH];
        count = SetupGetFieldCount(&KeywordContext);
        if (count > i ) {
            while (i <= count) {
                if(SetupGetStringField(&KeywordContext,i,Cmd,LINE_LEN,NULL)
                    && Cmd[0]) {
                    if (!_tcsicmp(Cmd,TEXT("RegistryFlags"))) {
                        //
                        // look in the appropriate control inf section for the data
                        //
                        if (!SetupFindFirstLine(
                                        hControlInf,
                                        MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.RegistryInformation")),
                                        TEXT("RegistryFlags"),
                                        &ControlContext)) {
                            _ftprintf(stderr, TEXT("SetupFindFirstLine [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                            RetVal = FALSE;
                            goto exit;
                        }

                        if (!SetupGetStringField(&ControlContext,1,Entry,sizeof(Entry)/sizeof(TCHAR),NULL)) {
                            _ftprintf(stderr, TEXT("SetupGetStringField [%s] failed, ec = 0x%08x\n"),FileName,GetLastError());
                            RetVal = FALSE;
                            goto exit;
                        }

                        _tcscat(LineText, TEXT(","));
                        _tcscat(LineText, Entry);

                    }
                }

                if (i != count) {
                    _tcscat(LineText, TEXT(","));
                }

                i +=1;

            }

        }
    }else if (KeywordName == KeywordArray[INDEX_REGISTERDLLS]) {

        // Check if we need to exclude this file from RegisterDlls
        if( SetupFindFirstLine(
                hControlInf,
                MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.FilesToExcludeFromRegistration")),
                FileName,
                &ControlContext)){

            return TRUE;
        }


    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("%s\n"),LineText);

    RetVal = TRUE;

exit:
    return(RetVal);

}


BOOL
pOutputSectionData(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN PPERSECTION_CONTEXT      SectionContext,
    IN UINT                     SectionContextSize,
    IN LPARAM                   cntxt
    )

/*++

Routine Description:

    String table callback.

    This routine outputs the contents of the specified section to both the
    system layout file and the output file.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE. There is a bug in setupapi where we will jump into 
    the next hash_bucket and may process few more entries.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT LineContext;

    DWORD EntryCount,i,SectionCount;
    INFCONTEXT InputContext;
    UCHAR      line[MAX_INF_STRING_LENGTH];
    PSETUPINF_CONTEXT  Context = (PSETUPINF_CONTEXT)cntxt;


    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Enumerating Section %s\n"), String);

    
    //
    // output the decorated section header
    //
    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("[%s%s]\n"),FilePrefix,String);

    //
    // get the section context
    //
    if(! SetupFindFirstLine(
                Context->hInputInf,
                String,
                NULL,
                &InputContext)){

        _ftprintf(stderr, TEXT("Could not find lines in Section %s\n"), String);

        //continue with next section

        return TRUE;
    }

    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Output Section %s\n"), String);

    do {

        SectionCount = SetupGetLineCount(Context->hInputInf,String);

        for (i = 0; i < SectionCount; i++) {
            if (SetupGetLineByIndex(
                                Context->hInputInf,
                                String,
                                i,&InputContext)) {
                //
                // get the keyword for the section we're mapping
                //
                PCTSTR KeywordName = NULL;
                DWORD j=0;
                MYASSERT(SectionContext->KeywordVector != 0);
                while (!KeywordName) {
                    if (SectionContext->KeywordVector & (1<<j)) {
                        KeywordName = KeywordArray[j];
                        break;
                    }

                    j += 1;
                }

                MYASSERT(KeywordName != NULL);

                //
                // filter and output the data
                //
                AppendSetupInfDataToSection(
                                    Context->OutFile,
                                    Context->hControlInf,
                                    &InputContext,
                                    KeywordName );

                if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Got back from AppendSetupInfDataToSection\n"));


                //
                // output the data to the layout file if we need to
                //
                if ((SectionContext->KeywordVector & KEYWORD_NEEDLAYOUTDATA) && Context->OutLayoutFile) {

                    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Calling AppendSetupInfDataToLayoutFile\n"));

                    AppendSetupInfDataToLayoutFile(
                                            Context->OutLayoutFile,
                                            Context->OutInfLayoutFile,
                                            Context->hControlInf,
                                            Context->hInputInf,
                                            &InputContext );

                    if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("Got back from AppendSetupInfDataToLayoutFile\n"));

                }

            } else {
                _ftprintf(stderr, TEXT("SetupGetLineByIndex failed, ec = %d\n"), GetLastError());
                return(FALSE);
            }
        }

    } while (SetupFindNextLine( &InputContext,
                                &InputContext)); // bugbug is this really
                                                 // necessary ??

    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("\n"));
    RetVal = TRUE;
    return(RetVal);
}


BOOL
pOutputDestinationDirs(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN PPERSECTION_CONTEXT      SectionContext,
    IN UINT                     SectionContextSize,
    IN LPARAM                   cntxt
    )
/*++

Routine Description:

    String table callback.

    This routine outputs the destination dirs keyword
    followed by the decorated section name and dirid mapping.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE.

--*/
{
    TCHAR LineText[MAX_INF_STRING_LENGTH];
    BOOL RetVal;
    INFCONTEXT LineContext;

    DWORD EntryCount,i,cch;
    PSETUPINF_CONTEXT        Context = (PSETUPINF_CONTEXT)cntxt;

    //
    // only process this entry if it need destination dirs
    //

    if (0 == (SectionContext->KeywordVector & (KEYWORD_NEEDDESTDIRS))) {
        RetVal = TRUE;
        goto exit;
    }

    
    //
    // first output "destinationdirs" if we haven't done so already
    //
    if (!Context->AlreadyOutputKeyword) {
         myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("[DestinationDirs]\n"));
         Context->AlreadyOutputKeyword = TRUE;
    }

    //
    // now get the unfiltered data so that we can filter it
    //
    if( !SetupFindFirstLine(
                    Context->hInputInf,
                    TEXT("DestinationDirs"),
                    String,
                    &LineContext)){

        SetupFindFirstLine(
                    Context->hInputInf,
                    TEXT("DestinationDirs"),
                    TEXT("DefaultDestDir"),
                    &LineContext);

    }


    ZeroMemory(LineText,sizeof(LineText));
    cch = sizeof(LineText)/sizeof(LineText[0]);

    EntryCount = SetupGetFieldCount(&LineContext);

    for (i = 1; i<=EntryCount; i++) {
        TCHAR Entry[MAX_PATH+1];    // The extra character is for the possible comma at the end.
        INFCONTEXT ControlContext;
        DWORD cchEntry;

        //
        // get the current text to be appended
        //
        if (!SetupGetStringField(&LineContext,i,Entry,MAX_PATH,NULL)) {
            _ftprintf(stderr, TEXT("SetupGetStringField failed, ec = 0x%08x\n"),GetLastError());
            RetVal = FALSE;
            goto exit;
        }

        //
        // now do any necessary substitutions
        //
        if (i == 1) {
            _stprintf(Entry, TEXT("%d"), SectionContext->DestinationDir);
        }

        //
        // now append a comma if necessary
        //
        if (i !=EntryCount) {
            _tcscat(Entry, TEXT(","));
        }

        //
        // check for buffer overruns
        //
        cchEntry = _tcslen(Entry);
        if (cchEntry >= cch) {
            _ftprintf(stderr, TEXT("pOutputDestinationDirs: line too long, File = %s\n"), String);
            RetVal = FALSE;
            goto exit;
        }

        _tcscat(LineText, Entry);
        cch -= cchEntry;

        if (fDoVerboseDebugOutput) _ftprintf(stderr, TEXT("LineText = %s\n"), LineText, SectionContext->DestinationDir);

    }

    //
    // output the filtered data
    //
    myftprintf(Context->OutFile, fDoAnsiOutput, TEXT("%s%s=%s\n"),FilePrefix,String,LineText);

    RetVal = TRUE;

exit:
    return(RetVal);
}


BOOL
DoSetupINF(
    IN PCTSTR InputInfA,
    IN PCTSTR ControlInfA,
    IN FILE *OutFile,
    IN FILE *OutLayoutFile,
    IN FILE *OutInfLayoutFile
    )
/*++

Routine Description:

    Filters a setupapi-based INF.

Arguments:

    InputInfA     - name of the inf to be filtered.
    ControlInfA   - name of the control directive inf
    OutFile       - output file handle
    OutLayoutFile - output file handle for layout information
    OutInfLayoutFile - output file handle for layout information contained in this INF

Return Value:

    NONE.

--*/
{
    PCWSTR InputInf;
    PCWSTR ControlInf;
    HINF hInputInf;
    HINF hControlInf;
    INFCONTEXT InfContext;
    SETUPINF_CONTEXT Context;
    PERSECTION_CONTEXT SectionContext;
    FILE *HeaderFile;

    TCHAR SourceArchitecture[10];
    TCHAR SourceDiskFiles[80];
    BOOL FirstTime;
    PTSTR Sections,Current;
    DWORD SizeNeeded;
    PVOID FilteredSectionsStringTable;

    BOOL b;

    b = FALSE;

    //
    // initialize and open the infs
    //
#ifdef UNICODE
    InputInf = InputInfA;
#else
    InputInf = pSetupAnsiToUnicode(InputInfA);
#endif
    if (!InputInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),InputInfA, GetLastError());
        goto e0;
    }
#ifdef UNICODE
    ControlInf = ControlInfA;
#else
    ControlInf = pSetupAnsiToUnicode(ControlInfA);
#endif
    if (!ControlInf) {
        _ftprintf(stderr,TEXT("Unable to convert %s to Unicode %d\n"),ControlInfA, GetLastError());
        goto e1;
    }

    hInputInf = SetupOpenInfFileW(InputInf,NULL,INF_STYLE_WIN4,NULL);
    if(hInputInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),InputInf, GetLastError());
        goto e2;
    }

    hControlInf = SetupOpenInfFileW(ControlInf,NULL,INF_STYLE_WIN4,NULL);
    if(hControlInf == INVALID_HANDLE_VALUE) {
        _ftprintf(stderr,TEXT("Unable to open Inf %ws, ec=0x%08x\n"),ControlInf, GetLastError());
        goto e3;
    }


    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n\n"));

    //
    // write the output file header
    //
    HeaderFile = _tfopen(HeaderText,TEXT("rt"));
    if (HeaderFile) {
      while (!feof(HeaderFile)) {
         TCHAR Buffer[100];
         DWORD CharsRead;

         CharsRead = fread(Buffer,sizeof(TCHAR),sizeof(Buffer)/sizeof(TCHAR),HeaderFile);

         if (CharsRead) {
            fwrite(Buffer,sizeof(TCHAR),CharsRead,OutFile);
         }
      }
      fclose(HeaderFile);
    }

    myftprintf(OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // get all of the section names
    //
    if (!SetupGetInfSections(hInputInf, NULL, 0, &SizeNeeded)) {
        _ftprintf(stderr,TEXT("Unable to get section names, ec=0x%08x\n"), GetLastError());
        goto e4;
    }
    if (SizeNeeded == 0) {
        b= TRUE;
        goto e4;
    }

    Sections = pSetupMalloc (SizeNeeded + 1);
    if (!Sections) {
        _ftprintf(stderr,TEXT("Unable to allocate memory, ec=0x%08x\n"), GetLastError());
        goto e4;
    }

    if (!SetupGetInfSections(hInputInf, Sections, SizeNeeded, NULL)) {
        _ftprintf(stderr,TEXT("Unable to allocate memory, ec=0x%08x\n"), GetLastError());
        goto e5;
    }

    FilteredSectionsStringTable = pSetupStringTableInitializeEx( sizeof(PERSECTION_CONTEXT),0);
    if (!FilteredSectionsStringTable) {
        _ftprintf(stderr,TEXT("Unable to create string table, ec=0x%08x\n"), GetLastError());
        goto e5;
    }

    Current = Sections;
    Context.OutFile = OutFile;
    Context.OutLayoutFile = OutLayoutFile;
    Context.OutInfLayoutFile = OutInfLayoutFile;
    Context.hControlInf = hControlInf;
    Context.hInputInf = hInputInf;
    Context.AlreadyOutputKeyword = FALSE;

    //
    // process each section, which will output the
    // sections names and keywords that we want to filter
    //
    while (*Current) {

        if (SetupFindFirstLine(
                            hControlInf,
                            MyGetDecoratedSectionName(hControlInf, TEXT("NativeDataToWowData.SetupINF.ExcludeSection")),
                            Current,
                            &InfContext)) {
            _ftprintf(stderr, TEXT("Skipping section %s as per [NativeDataToWowData.SetupINF.ExcludeSection]: ec = 0x%08x\n"), Current, GetLastError());
            Current += lstrlen(Current)+1;
            continue;
        }


        if (fDoVerboseDebugOutput) _ftprintf(stderr,TEXT("Processing section %s\n"), Current );

        pFilterSetupInfSection(
                    FilteredSectionsStringTable,
                    Current,
                    &Context);

        Current += lstrlen(Current)+1;
    }

    myftprintf(Context.OutFile, fDoAnsiOutput, TEXT("\n"));

    //
    // for each section that we decided to filter, we now need to output the
    // actual section
    //
    pSetupStringTableEnum(
        FilteredSectionsStringTable,
        &SectionContext,
        sizeof(PERSECTION_CONTEXT),
        pOutputSectionData,
        (LPARAM)&Context
        );


    //
    // now we need to output the destination dirs section
    //
    pSetupStringTableEnum(
        FilteredSectionsStringTable,
        &SectionContext,
        sizeof(PERSECTION_CONTEXT),
        pOutputDestinationDirs,
        (LPARAM)&Context
        );

    b = TRUE;

    pSetupStringTableDestroy(FilteredSectionsStringTable);
e5:
    pSetupFree(Sections);
e4:
    SetupCloseInfFile( hControlInf );
e3:
    SetupCloseInfFile( hInputInf );
e2:
#ifndef UNICODE
    pSetupFree(ControlInf);
#endif
e1:
#ifndef UNICODE
    pSetupFree(InputInf);
#endif
e0:
    return(b);
}


void
Usage(
    VOID
    )
/*++

Routine Description:

    Prints the usage to stderr.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _fputts( TEXT("generate list of wow files. Usage:\n")
             TEXT("wowlist <options> <inf file> -c <control inf> -l <ole inf> -o <output file> -a{cos} -h <header file> -g <section> -d <output layout> -f <file prefix>\n")
             TEXT("\n") 
             TEXT("  -i <inf file>      - input inf containing list of dependencies\n") 
             TEXT("  -c <control inf>   - contains directives for creating list.\n") 
             TEXT("  -l <OLE inf>       - contains ole registration directives.\n") 
             TEXT("  -o <output file>   - output list\n") 
             TEXT("  -g <section>       - SetupAPI INF filtering decoration for per-inf filtering\n") 
             TEXT("  -h <header file>   - append this to top of the output list\n") 
             TEXT("  -s <section name>  - specifies section in OLE Inf to process\n") 
             TEXT("  -d <output layout> - output layout.inf information for SetupAPI INF filtering\n") 
             TEXT("  -f <file prefix>   - specifies the decoration to be prepended to filtered files.\n") 
             TEXT("  -a <c|o|s>         - specifies filter action\n") 
             TEXT("  -u                 - create UNICODE output list (only with /o)\n") 
             TEXT("  -n <file>          - create layout file for SourceDisksFiles within the INF (to be appended to INF itself)\n") 
             TEXT("\tc - Create copy list.\n") 
             TEXT("\to - Create OLE list.\n") 
             TEXT("\ts - Create SetupINF list.\n") 
             TEXT("\n") 
             TEXT("\n"),
             stderr );
}

int
__cdecl
_tmain(
    IN int   argc,
    IN TCHAR *argv[]
    )
{
    FILE *hFileOut,*hFileLayoutOut = NULL, *hFileInfLayoutOut=NULL;
    BOOL b;


    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(!ParseArgs(argc,argv)) {
        Usage();
        goto exit;
    }

    //
    // Open the output file.
    //
    if( fDoAnsiOutput )
        hFileOut = _tfopen(OutputFile,TEXT("wt"));
    else
        hFileOut = _tfopen(OutputFile,TEXT("wb"));
    if(hFileOut) {

        if (Action == BuildCopyList) {

            _ftprintf(stdout,TEXT("%s: creating copy list %s from %s and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    InputInf,
                    ControlInf);
            b = DoCopyList(
                      InputInf,
                      ControlInf,
                      hFileOut );

        } else if (Action == BuildOLEList) {

            _ftprintf(stdout,
                    TEXT("%s: creating OLE list %s from %s, %s, and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    InputInf,
                    OLEInputInf,
                    ControlInf);

            b = DoOLEList(
                      InputInf,
                      OLEInputInf,
                      ControlInf,
                      hFileOut );

        } else if (Action == BuildSetupINF) {

            if( OutputLayoutFile )
                hFileLayoutOut = _tfopen(OutputLayoutFile,TEXT("wt"));

            // Check if we want to process layout information that needs to be added
            // to the INF itself. This is used for INFs that have their own layout information.
            // This file will get the layout information for thunked files which had 
            // SourceDisksFiles entries within this INF.

            if(OutputInfLayoutFile){

                if( fDoAnsiOutput )
                    hFileInfLayoutOut = _tfopen(OutputInfLayoutFile,TEXT("wt"));
                else
                    hFileInfLayoutOut = _tfopen(OutputInfLayoutFile,TEXT("wb"));

            }

            _ftprintf(stdout,
                    TEXT("%s: creating SetupINF list %s (layout %s) from %s and %s\n"),
                    ThisProgramName,
                    OutputFile,
                    OutputLayoutFile,
                    InputInf,
                    ControlInf);

            b = DoSetupINF(
                      InputInf,
                      ControlInf,
                      hFileOut,
                      hFileLayoutOut, 
                      hFileInfLayoutOut);

            if( hFileLayoutOut )
                fclose( hFileLayoutOut );

            if( hFileInfLayoutOut )
                fclose( hFileInfLayoutOut );

        } else {
            _ftprintf(stderr,TEXT("unknown action."));
            MYASSERT(FALSE);
        }

        fclose(hFileOut);

    } else {
        _ftprintf(stderr,TEXT("%s: Unable to create output file %s\n"),ThisProgramName,OutputFile);
    }


exit:

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\legacy\exe\resource.h ===
#define IDD_ABORTDIALOG 100

#define IDS_PASSWORD_BANNER             1000
#define IDS_CONFIRM_PASSWORD_BANNER     1002
#define IDS_DIFFERENT_PASSWORDS_MESSAGE 1003
#define IDS_BAD_PASSWORD_CONTENTS       1004
#define IDS_UNATTEND_FIXUP_DONE         1005

#define IDS_PID_BANNER_1                1015
#define IDS_PID_BANNER_2                1016
#define IDS_PID_INVALID                 1017

#define IDS_EULA_ACCEPT_DECLINE         1029
#define IDS_EULA_MORE                   1030

#define IDS_CHANNEL_NAME                1050
#define IDS_CHANNEL_DESCRIPTION         1051
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\unitext\wargs.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    args.c

Abstract:

    Header file for routines to process unicode command line arguments
    into argc and argv.

Author:

    Ted Miller (tedm) 16-June-1993

Revision History:

--*/



//
// Function protypes.
//

BOOL
InitializeUnicodeArguments(
    OUT int     *argcW,
    OUT PWCHAR **argvW
    );


VOID
FreeUnicodeArguments(
    IN int     argcW,
    IN PWCHAR *argvW
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\legacy\exe\ems.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ntddsac.h>
#include <emsapi.h>
#include <ASSERT.h>
#include <initguid.h>
#include <spidgen.h>
#include <compliance.h>
#include <winnt32.h>
#include <syssetup.h>
#include <setupbat.h>
#include "resource.h"
#include "ems.h"

//
// winnt32.h wants to define this to MyWritePrivateProfileString.
// Undo that.
//
#ifdef WritePrivateProfileStringW
#undef WritePrivateProfileStringW
#endif

//
// status globals for keeping track of what the user wanted and entered
//

BOOL gMiniSetup = FALSE;
BOOL gRejectedEula = FALSE;

//
// EMS channel globals
//
SAC_CHANNEL_OPEN_ATTRIBUTES GlobalChannelAttributes;
EMSVTUTF8Channel *gEMSChannel = NULL;


BOOL 
IsHeadlessPresent(
    OUT EMSVTUTF8Channel **Channel
    )
/*++

Routine Description:

    Determine if EMS is present by attempting to create the Unattend channel

    note: this must be called after InitializeGlobalChannelAttributes
                                           
Arguments:

    Channel - on success, contains a pointer to a channel object
              
Return Value:

    TRUE  - headless is active and we have a channel
    FALSE - otherwise

--*/
{
    BOOL RetVal;

    *Channel = EMSVTUTF8Channel::Construct(GlobalChannelAttributes);

    RetVal = (*Channel != NULL);
    return(RetVal);
}
    
BOOL
InitializeGlobalChannelAttributes(
    PSAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    )
/*++

Routine Description:

    populate the EMS channel attributes
    
    note: this must be called before IsHeadlessPresent
                                           
Arguments:

    ChannelAttributes - on success, contains a pointer to initialized channel attrs.
              
Return Value:

    TRUE  - headless is active and we have a channel
    FALSE - otherwise

--*/
{
    UNICODE_STRING Name,Description;
    BOOL RetVal = FALSE;

    RtlZeroMemory(ChannelAttributes,sizeof(SAC_CHANNEL_OPEN_ATTRIBUTES));

    if (!LoadStringResource( &Name, IDS_CHANNEL_NAME )) {
        goto e0;
    }

    if (!LoadStringResource( &Description, IDS_CHANNEL_DESCRIPTION)) {
        goto e1;
    }

    ChannelAttributes->Type = ChannelTypeVTUTF8;
    wcsncpy(ChannelAttributes->Name, Name.Buffer, SAC_MAX_CHANNEL_NAME_LENGTH);
    wcsncpy(ChannelAttributes->Description, Description.Buffer, SAC_MAX_CHANNEL_DESCRIPTION_LENGTH);
    ChannelAttributes->Flags = SAC_CHANNEL_FLAG_HAS_NEW_DATA_EVENT;
    ChannelAttributes->HasNewDataEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    ChannelAttributes->ApplicationType = SAC_CHANNEL_GUI_SETUP_PROMPT;

    RetVal = ((ChannelAttributes->HasNewDataEvent != NULL) 
            ? TRUE
            : FALSE);

    RtlFreeUnicodeString(&Description);
e1:
    RtlFreeUnicodeString(&Name);
e0:
    return(RetVal);
}


inline 
BOOL 
IsAsyncCancelSignalled(
    HANDLE hEvent
    ) 
/*++

Routine Description:

    Test the given event to see if it is signaled
                                           
Arguments:

    hEvent - event to be tested
              
Return Value:

    TRUE  - signaled
    FALSE - otherwise

--*/
{
    //
    // check if the async cacnel signal fired.
    //
    if( (hEvent) &&
        (hEvent != INVALID_HANDLE_VALUE) ) {
        return (WaitForSingleObject(hEvent,0) == WAIT_OBJECT_0);
    } else {    
        return (FALSE);
    }
}

//
// ====================================
// EMS-specific communication functions
// ====================================
//
BOOL
WaitForUserInputFromEMS(
    IN  DWORD   TimeOut,
    OUT BOOL    *TimedOut    OPTIONAL,
    IN  HANDLE  hCancelEvent   OPTIONAL
    )
/*++

Routine Description:

    Wait for input from the EMS port 
    
    Note: this routine does not read any data from the port
                                           
Arguments:

    TimeOut - timeout parameter for user input
    TimedOut- OPTIONAL parameter denoting if we timed out or not
    hCancelEvent - if supplied, then we wait on this event too
                 this lets us not block if timeout is infinite, etc.
          
Return Value:

    returns TRUE for user input or timeout (non-error)

--*/
{
    DWORD       dwRetVal;
    BOOL        bSuccess = FALSE;
    HANDLE      handles[2];
    ULONG       handleCount = 0;

    if (TimedOut) {
        *TimedOut = FALSE;
    }

    handles[0] = GlobalChannelAttributes.HasNewDataEvent;
    handleCount++;

    if ((hCancelEvent != NULL) && 
        (hCancelEvent != INVALID_HANDLE_VALUE)) {
        handles[1] = hCancelEvent;
        handleCount++;
    }

    //
    // Wait for our event
    //
    dwRetVal = WaitForMultipleObjects(
        handleCount,
        handles,
        FALSE,
        TimeOut
        );

    switch ( dwRetVal ) {
    case WAIT_OBJECT_0: {
        //
        // EMS port got data
        //
        bSuccess = TRUE;
        break;
    }
    case (WAIT_OBJECT_0+1): {
        //
        // if the hCancelEvent occured then we
        // need to report an error status, hence
        // we return FALSE status if we get here
        //
        bSuccess = FALSE;
        break;
    }
    case WAIT_TIMEOUT: {
        if (TimedOut) {
            *TimedOut = TRUE;
        }
        bSuccess = TRUE;
        break;
    }
    default:

        //
        // we return FALSE status if we get here
        //

        break;
    }

    return bSuccess;
}

BOOL
ReadCharFromEMS(
    OUT PWCHAR  awc,
    IN HANDLE   hCancelEvent   OPTIONAL
    ) 
/*++

Routine Description:

    This routine will read a single char from the EMS Channel
    
Arguments:

    awc         - pointer to a wchar
    hCancelEvent  - if supplied, then we wait on this event too
                  this lets us not block if timeout is infinite, etc.
        
Return Value:

    status

--*/
{
    BOOL        bSuccess;
    ULONG       BytesRead = 0;
        
    //
    // wait for input
    //
    bSuccess = WaitForUserInputFromEMS(
        INFINITE,
        NULL,
        hCancelEvent
        );

    if (IsAsyncCancelSignalled(hCancelEvent)) {
        bSuccess = FALSE;
        goto exit;
    }

    if (bSuccess) {
        
        //
        // consume character
        //
        bSuccess = gEMSChannel->Read( 
            (PWSTR)awc, 
            sizeof(WCHAR),
            &BytesRead 
            );
    
    }

exit:
    return bSuccess;
}

BOOL
GetStringFromEMS(
    OUT PWSTR   String,
    IN  ULONG   BufferSize,
    IN  BOOL    GetAllChars,
    IN  BOOL    EchoClearText,
    IN  HANDLE  hCancelEvent      OPTIONAL
    )
/*++

Routine Description:

    This routine will read in a string from the EMS port.
    
Arguments:

    String          - on success, contains the credential
    BufferSize      - the # of BYTES in the String buffer
                      this should include space for null-termination
    GetAllChars     - the user must enter StringLength Chars
    EchoClearText   - TRUE: echo user input in clear text
                      FALSE: echo user input as '*'
    hCancelEvent  - if supplied, then we wait on this event too
                  this lets us not block if timeout is infinite, etc.
    
Return Value:

    TRUE    - we got a valid string
    FALSE   - otherwise

--*/
{
    BOOL        Done = FALSE;
    WCHAR       InputBuffer[MY_MAX_STRING_LENGTH+1];
    BOOL        GotAString = FALSE;
    ULONG       BytesRead = 0;
    BOOL        bSuccess;
    ULONG       CurrentCharacterIndex = 0;
    ULONG       InputBufferIndex = 0;
    ULONG       StringLength = (BufferSize / sizeof(WCHAR)) - 1;

    if( (String == NULL)) {
        return FALSE;
    }

    bSuccess = TRUE;

    //
    // Keep asking the user until we get what we want.
    //
    Done = FALSE;
    memset( String,
            0,
            BufferSize
            ); 

    //
    // Start reading input until we get something good.
    //
    GotAString = FALSE;
    CurrentCharacterIndex = 0;
    
    while( !GotAString && 
           bSuccess
           ) {
        
        //
        // wait for input
        //
        bSuccess = WaitForUserInputFromEMS(
            INFINITE,
            NULL,
            hCancelEvent
            );

        if (IsAsyncCancelSignalled(hCancelEvent)) {
            bSuccess = FALSE;
            goto exit;
        }

        if (bSuccess) {

            //
            // consume character
            //
            bSuccess = gEMSChannel->Read( 
                (PWSTR)InputBuffer, 
                MY_MAX_STRING_LENGTH * sizeof(WCHAR),
                &BytesRead 
                );

            if( (bSuccess) && 
                (BytesRead > 0) ) {

                ULONG   WCharsRead = BytesRead / sizeof(WCHAR);

                //
                // Append these characters onto the end of our string.
                //
                InputBufferIndex = 0;

                while( (InputBufferIndex < WCharsRead) &&
                       (CurrentCharacterIndex < StringLength) &&
                       (!GotAString) &&
                       bSuccess
                       ) {

                    if( (InputBuffer[InputBufferIndex] == 0x0D) ||
                        (InputBuffer[InputBufferIndex] == 0x0A) ) {

                        // ignore cr/lf until we get all the chars
                        if (!GetAllChars) {
                            GotAString = TRUE;
                        } 

                    } else {

                        if( InputBuffer[InputBufferIndex] == '\b' ) {
                            //
                            // If the user gave us a backspace, we need to:
                            // 1. cover up the last character on the screen.
                            // 2. ignore the previous character he gave us.
                            //
                            if( CurrentCharacterIndex > 0 ) {
                                CurrentCharacterIndex--;
                                String[CurrentCharacterIndex] = '\0';
                                gEMSChannel->Write( (PWSTR)L"\b \b",
                                                    (ULONG)(wcslen(L"\b \b") * sizeof(WCHAR)) );
                            }
                        } else {

                            //
                            // Record this character.
                            //
                            String[CurrentCharacterIndex] = InputBuffer[InputBufferIndex];
                            CurrentCharacterIndex++;

                            //
                            // Echo 1 character
                            //
                            gEMSChannel->Write( 
                                (EchoClearText ? (PWSTR)&InputBuffer[InputBufferIndex] : (PWSTR)L"*"),
                                sizeof(WCHAR) 
                                );

                        }
                    }

                    //
                    // Go to the next letter of input.
                    //
                    InputBufferIndex++;

                }
            } 
        } 

        if( CurrentCharacterIndex == StringLength ) {
            GotAString = TRUE;
        }

    }
    
exit:
    return bSuccess;
}

VOID
ClearEMSScreen() 
/*++

Routine Description:

    This routine will clear the EMS channel screen
    
Arguments:

    none
    
Return Value:

    none
    
--*/
{
    gEMSChannel->Write( (PWSTR)VTUTF8_CLEAR_SCREEN,
                    (ULONG)(wcslen( VTUTF8_CLEAR_SCREEN ) * sizeof(WCHAR)) );
}

#define ESC_CTRL_SEQUENCE_TIMEOUT (2 * 1000)

BOOL
GetDecodedKeyPressFromEMS(
    OUT PULONG  KeyPress,
    IN  HANDLE  hCancelEvent      OPTIONAL
    )

/*++

Routine Description:

    Read in a (possible) sequence of keystrokes and return a Key value.

Arguments:

    KeyPress    - on success contains a decoded input value:
    
                lower 16bits contains unicode value 
                upper 16bits contains <esc> key sequence ids
    
    hCancelEvent  - if supplied, then we wait on this event too
                  this lets us not block if timeout is infinite, etc.

Return Value:

    TRUE    - we got a valid key press
    FALSE   - otherwise

--*/

{
    BOOL bSuccess = FALSE;
    WCHAR   wc = 0;
    BOOL bTimedOut;

    if (!KeyPress) {
        return FALSE;
    }

    *KeyPress = 0;

    do {
        
        //
        // Read first character
        //
        bSuccess = ReadCharFromEMS(
            &wc, 
            hCancelEvent
            );

        if (IsAsyncCancelSignalled(hCancelEvent)) {
            bSuccess = FALSE;
            goto exit;
        }

        if (!bSuccess) {
            break;
        }

        //
        // Handle all the special escape codes.
        //
        if (wc == 0x8) {   // backspace (^h)
            *KeyPress = ASCI_BS;
        }
        if (wc == 0x7F) {  // delete
            *KeyPress = KEY_DELETE;
        }
        if ((wc == '\r') || (wc == '\n')) {  // return
            *KeyPress = ASCI_CR;
        }

        if (wc == 0x1b) {    // Escape key

            bSuccess = WaitForUserInputFromEMS(
                ESC_CTRL_SEQUENCE_TIMEOUT,
                &bTimedOut,
                hCancelEvent
                );

            if (IsAsyncCancelSignalled(hCancelEvent)) {
                bSuccess = FALSE;
                goto exit;
            }
            
            if (bSuccess) {
                
                if (bTimedOut) {
                    
                    *KeyPress = ASCI_ESC;
                
                } else {

                    //
                    // the user entered something within in the timeout window
                    // so lets try to figure out if they are sending some
                    // esc sequence
                    //

                    do {

                        ULONG   BytesRead;

                        //
                        // consume character
                        //
                        bSuccess = gEMSChannel->Read( 
                            &wc, 
                            sizeof(WCHAR),
                            &BytesRead 
                            );

                        if (!bSuccess) {
                            wc = ASCI_ESC;
                            break;
                        }

                        //
                        // Some terminals send ESC, or ESC-[ to mean
                        // they're about to send a control sequence.  We've already
                        // gotten an ESC key, so ignore an '[' if it comes in.
                        //

                    } while ( wc == L'[' );

                    switch (wc) {
                    case '@':
                        *KeyPress = KEY_F12;
                        break;
                    case '!':
                        *KeyPress = KEY_F11;
                        break;
                    case '0':
                        *KeyPress = KEY_F10;
                        break;
                    case '9':
                        *KeyPress = KEY_F9;
                        break;
                    case '8':
                        *KeyPress = KEY_F8;
                        break;
                    case '7':
                        *KeyPress = KEY_F7;
                        break;
                    case '6':
                        *KeyPress = KEY_F6;
                        break;
                    case '5':
                        *KeyPress = KEY_F5;
                        break;
                    case '4':
                        *KeyPress = KEY_F4;
                        break;
                    case '3':
                        *KeyPress = KEY_F3;
                        break;
                    case '2':
                        *KeyPress = KEY_F2;
                        break;
                    case '1':
                        *KeyPress = KEY_F1;
                        break;
                    case '+':
                        *KeyPress = KEY_INSERT;
                        break;
                    case '-':
                        *KeyPress = KEY_DELETE;
                        break;
                    case 'H':
                        *KeyPress = KEY_HOME;
                        break;
                    case 'K':
                        *KeyPress = KEY_END;
                        break;
                    case '?':
                        *KeyPress = KEY_PAGEUP;
                        break;
                    case '/':
                        *KeyPress = KEY_PAGEDOWN;
                        break;
                    case 'A':
                        *KeyPress = KEY_UP;
                        break;
                    case 'B':
                        *KeyPress = KEY_DOWN;
                        break;
                    case 'C':
                        *KeyPress = KEY_RIGHT;
                        break;
                    case 'D':
                        *KeyPress = KEY_LEFT;
                        break;
                    default:
                        //
                        // We didn't get anything we recognized after the
                        // ESC key.  Just return the ESC key.
                        //
                        *KeyPress = ASCI_ESC;
                        break;
                    }
                }
            }
        } // Escape key
    } while ( FALSE );

exit:
    return bSuccess;
}

//
// ====================================
// PID helper functions
// ====================================
//

typedef enum {
    CDRetail,
    CDOem,
    CDSelect
} CDTYPE;

PCWSTR szPidKeyName                 = L"SYSTEM\\Setup\\Pid";
PCWSTR szPidValueName               = L"Pid";
PCWSTR szFinalPidKeyName            = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
PCWSTR szFinalPidValueName          = L"ProductId";
TCHAR  Pid30Rpc[8]                  = TEXT("00000");
TCHAR  Pid30Site[4]                 = {0};
DWORD  g_dwGroupID                  = 0;
CDTYPE CDType                       = CDRetail;
DWORD InstallVar                    = 0;

//
// Syssetup apparently needs the sku info
// so turn this define if necessary
//
const WCHAR pwLanmanNt[]            = WINNT_A_LANMANNT;
const WCHAR pwServerNt[]            = WINNT_A_SERVERNT;
const WCHAR pwWinNt[]               = WINNT_A_WINNT;
PCWSTR szPidSelectId                = L"270";
PCWSTR szPidOemId                   = L"OEM";

#define MAX_PARAM_LEN               (256)
#define PID_30_LENGTH               (29)
#define PID_30_SIZE                 (30)

LONG    ProductType = PRODUCT_SERVER_STANDALONE;
WCHAR   TmpData[MAX_PATH+1];

//
// sku info
//
PCWSTR szSkuProfessionalFPP         = L"B23-00079";
PCWSTR szSkuProfessionalCCP         = L"B23-00082";
PCWSTR szSkuProfessionalSelect      = L"B23-00305";
PCWSTR szSkuProfessionalEval        = L"B23-00084";
PCWSTR szSkuServerFPP               = L"C11-00016";
PCWSTR szSkuServerCCP               = L"C11-00027";
PCWSTR szSkuServerSelect            = L"C11-00222";
PCWSTR szSkuServerEval              = L"C11-00026";
PCWSTR szSkuServerNFR               = L"C11-00025";
PCWSTR szSkuAdvServerFPP            = L"C10-00010";
PCWSTR szSkuAdvServerCCP            = L"C10-00015";
PCWSTR szSkuAdvServerSelect         = L"C10-00098";
PCWSTR szSkuAdvServerEval           = L"C10-00014";
PCWSTR szSkuAdvServerNFR            = L"C10-00013";
PCWSTR szSkuDTCFPP                  = L"C49-00001";
PCWSTR szSkuDTCSelect               = L"C49-00023";
PCWSTR szSkuUnknown                 = L"A22-00001";
PCWSTR szSkuOEM                     = L"OEM-93523";

PCWSTR GetStockKeepingUnit( 
    PWCHAR pMPC,
    UINT ProductType,
    CDTYPE MediaType
)
/*++

Routine Description:

    This returns the Stock Keeping Unit based off the MPC.

Arguments:

    pMPC - pointer to 5 digit MPC code, null terminated.
    ProductType - Product type flag, tells us if this is a workataion or server sku. 
    CdType - one of InstallType enum

Return Value:

    Returns pointer to sku.
    If no match found returns szSkuUnknown.

--*/
{
    // check for eval
    if (!_wcsicmp(pMPC,EVAL_MPC) || !_wcsicmp(pMPC,DOTNET_EVAL_MPC)){
        // this is eval media ...
        if (ProductType == PRODUCT_WORKSTATION){
            return (szSkuProfessionalEval);
        } // else
        // else it is server or advanced server.  I don't think that at this point
        // we can easily tell the difference.  Since it's been said that having the
        // correct sku is not critically important, I shall give them both the sku
        // code of server
        return (szSkuServerEval);
    }

    // check for NFR
    if (!_wcsicmp(pMPC,SRV_NFR_MPC)){
        return (szSkuServerNFR);
    }
    if (!_wcsicmp(pMPC,ASRV_NFR_MPC)){
        return (szSkuAdvServerNFR);
    }

    if (MediaType == CDRetail) {
        if (!_wcsicmp(pMPC,L"51873")){
            return (szSkuProfessionalFPP);
        }
        if (!_wcsicmp(pMPC,L"51874")){
            return (szSkuProfessionalCCP);
        }
        if (!_wcsicmp(pMPC,L"51876")){
            return (szSkuServerFPP);
        }
        if (!_wcsicmp(pMPC,L"51877")){
            return (szSkuServerCCP);
        }
        if (!_wcsicmp(pMPC,L"51879")){
            return (szSkuAdvServerFPP);
        }
        if (!_wcsicmp(pMPC,L"51880")){
            return (szSkuAdvServerCCP);
        }
        if (!_wcsicmp(pMPC,L"51891")){
            return (szSkuDTCFPP);
        }
    } else if (MediaType == CDSelect) {
        if (!_wcsicmp(pMPC,L"51873")){
            return (szSkuProfessionalSelect);
        }
        if (!_wcsicmp(pMPC,L"51876")){
            return (szSkuServerSelect);
        }
        if (!_wcsicmp(pMPC,L"51879")){
            return (szSkuAdvServerSelect);
        }
        if (!_wcsicmp(pMPC,L"51891")){
            return (szSkuDTCSelect);
        }
    }

    return (szSkuUnknown);
}

BOOL
GetProductTypeFromRegistry(
    VOID
    )
/*++

Routine Description:

    Reads the Product Type from the parameters files and sets up
    the ProductType global variable.

Arguments:

    None

Returns:

    Bool value indicating outcome.

--*/
{
    WCHAR   p[MAX_PARAM_LEN] = {0};
    DWORD   rc = 0;
    DWORD   d = 0;
    DWORD   Type = 0;
    HKEY    hKey = (HKEY)INVALID_HANDLE_VALUE;
    
    rc = 0;
    if( !gMiniSetup ) {

        WCHAR   AnswerFilePath[MAX_PATH] = {0};
        
        //
        // Go try and get the product type out of the [data] section
        // of $winnt$.sif
        //
        rc = GetWindowsDirectory( AnswerFilePath, MAX_PATH );
        wcsncat( AnswerFilePath, TEXT("\\system32\\$winnt$.inf"), MAX_PATH );
        AnswerFilePath[MAX_PATH-1] = TEXT('\0');

        rc = GetPrivateProfileString( WINNT_DATA,
                                      WINNT_D_PRODUCT,
                                      L"",
                                      p,
                                      MAX_PARAM_LEN,
                                      AnswerFilePath );

    }

    //
    // Either this is a MiniSetup, or we failed to get the key out of
    // the unattend file.  Go look in the registry.
    //
    
    if( rc == 0 ) {    
        
        //
        // Open the key.
        //
        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                           0,
                           KEY_READ,
                           &hKey );
    
        if( rc != NO_ERROR ) {
            return( FALSE );
        }
    
    
        //
        // Get the size of the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              NULL,
                              &d );
    
        if( rc != NO_ERROR ) {
            return( FALSE );
        }
    
        //
        // Get the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              (LPBYTE)p,
                              &d );
    
        if( rc != NO_ERROR ) {
            return( FALSE );
        }

    }

    //
    // We managed to find an entry in the parameters file
    // so we *should* be able to decode it
    //
    if(!lstrcmpi(p,pwWinNt)) {
        //
        // We have a WINNT product
        //
        ProductType = PRODUCT_WORKSTATION;

    } else if(!lstrcmpi(p,pwLanmanNt)) {
        //
        // We have a PRIMARY SERVER product
        //
        ProductType = PRODUCT_SERVER_PRIMARY;

    } else if(!lstrcmpi(p,pwServerNt)) {
        //
        // We have a STANDALONE SERVER product
        // NOTE: this case can currently never occur, since text mode
        // always sets WINNT_D_PRODUCT to lanmannt or winnt.
        //
        ProductType = PRODUCT_SERVER_STANDALONE;

    } else {
        //
        // We can't determine what we are, so fail
        //
        return (FALSE);
    }

    return (TRUE);
}

BOOL
ValidatePidEx(
    LPTSTR PID
    )
/*++

Routine Description:

    This routine validates the given PID string using the PID Gen DLL.
    
    Note: this routine loads the pidgen.dll and therefore makes setup.exe
          dependent upon pidgen.dll

Arguments:

    PID         - the PID to be validated [should be in PID 30 format]
    
Returns:

    TRUE - valid
    FALSE - otherwise
    

--*/
{
    BOOL          bRet  = FALSE;
    TCHAR         Pid20Id[MAX_PATH];
    BYTE          Pid30[1024]={0};
    TCHAR         pszSkuCode[10];
    HINSTANCE     hPidgenDll;
    SETUPPIDGENW  pfnSetupPIDGen;
    DWORD         Error = ERROR_SUCCESS;
    DWORD         cbData = 0;
    PWSTR         p;
    HKEY          Key;
    DWORD         Type;

    // Load library pidgen.dll
    hPidgenDll = LoadLibrary ( L"pidgen.dll" );

    if ( hPidgenDll ) 
    {
        // Get the function pointer
        pfnSetupPIDGen = (SETUPPIDGENW)GetProcAddress(hPidgenDll, "SetupPIDGenW");

        if ( pfnSetupPIDGen ) 
        {
            GetProductTypeFromRegistry();

            //
            // Derive the release type and media type we're installing from.
            //
            Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  (gMiniSetup) ? L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion" : L"SYSTEM\\Setup\\Pid",
                                  0,
                                  KEY_READ,
                                  &Key );

            if( Error == ERROR_SUCCESS ) {
                cbData = sizeof(TmpData);
                
                Error = RegQueryValueEx( Key,
                                         (gMiniSetup) ? L"ProductId" : L"Pid",
                                         0,
                                         &Type,
                                         ( LPBYTE )TmpData,
                                         &cbData );
                RegCloseKey( Key );

                //
                // If we're in MiniSetup, then the value in TmpData
                // looks like: 12345-xxx-67890...
                // We want the 12345 to go into Pid30Rpc
                // and xxx to go into Pid30Site.
                //
                // If we're not in MiniSetup, then the value in
                // Tmpdata looks like: 12345XXX67890...
                //
                wcsncpy( Pid30Rpc, TmpData, MAX_PID30_RPC );
                Pid30Rpc[MAX_PID30_RPC] = (WCHAR)'\0';
                
                if( gMiniSetup ) {
                    p = TmpData + (MAX_PID30_RPC + 1);
                } else {
                    p = TmpData + (MAX_PID30_RPC);
                }
                wcsncpy(Pid30Site,p,MAX_PID30_SITE+1);
                Pid30Site[MAX_PID30_SITE] = (WCHAR)'\0';                

            
                //
                // Derive the media type.
                //
                if( _wcsicmp(Pid30Site, szPidSelectId) == 0) {
                    CDType = CDSelect;
                } else if( _wcsicmp(Pid30Site, szPidOemId) == 0) {
                    CDType = CDOem;
                } else {
                    // no idea...  Assume retail.
                    CDType = CDRetail;
                }
            
            }


            PCWSTR tmpP = GetStockKeepingUnit(
                Pid30Rpc,
                ProductType,
                CDType
                );
            lstrcpy(pszSkuCode, tmpP);

            *(LPDWORD)Pid30 = sizeof(Pid30);

            //
            // attempt to validate the PID
            //
            if ( pfnSetupPIDGen(
                PID,                                // [IN] 25-character Secure CD-Key (gets U-Cased)
                Pid30Rpc,                           // [IN] 5-character Release Product Code
                pszSkuCode,                         // [IN] Stock Keeping Unit (formatted like 123-12345)
                (CDType == CDOem),                  // [IN] is this an OEM install?
                Pid20Id,                            // [OUT] PID 2.0, pass in ptr to 24 character array
                Pid30,                              // [OUT] pointer to binary PID3 buffer. First DWORD is the length
                NULL                                // [OUT] optional ptr to Compliance Checking flag (can be NULL)
               ) )
            {
                // The Group ID is the dword starting at offset 0x20
                g_dwGroupID = (DWORD) ( Pid30[ 0x20 ] );

                // Set the return Value to true
                bRet = TRUE;
            }
        }
        
        FreeLibrary ( hPidgenDll ) ;
    }
    
    // if the caller wants, return if this is a Volume License PID
    return bRet;
}

BOOL
GetPid( PWSTR   PidString, 
        ULONG   BufferSize,
        HANDLE  hCancelEvent
       )
/*++

Routine Description:

    Prompts the user for a valid PID.
    
Arguments:

    PidString   - Buffer that will recieve the PID.  The resulting
                  string has the form: VVVVV-WWWWW-XXXXX-YYYYY-ZZZZZ.
    
    BufferSize  - specifies the # of bytes in the PidString buffer 
                  (including null termination)
    
    hCancelEvent - an event, which if signalled indicates that this routine
                   should exit and return failure.
    
Return Value:

    Win32 Error code.  Should be ERROR_SUCCESS if everything goes well.

--*/
{
   
    BOOL        Done = FALSE;
    BOOL        bSuccess = FALSE;
    ULONG       i = 0;
    ULONG       PidStringLength = (BufferSize / sizeof(WCHAR)) - 1;

    if( (PidString == NULL) || PidStringLength < PID_30_LENGTH) {
        return FALSE;
    }

    //
    // Keep asking the user until we get what we want.
    //
    Done = FALSE;
    memset( PidString,
            0,
            BufferSize
            ); 

    do {

        //
        // Clear the screen.
        //
        ClearEMSScreen();

        //
        // Write some instructions/information.
        //
        WriteResourceMessage( IDS_PID_BANNER_1 );
        WriteResourceMessage( IDS_PID_BANNER_2 );

        //
        // get the PID entry
        //
        bSuccess = GetStringFromEMS(
            PidString,
            BufferSize,
            FALSE,
            TRUE,
            hCancelEvent
            );

        if (IsAsyncCancelSignalled(hCancelEvent)) {
            bSuccess = FALSE;
            goto exit;
        }

        if (!bSuccess) {
            goto exit;
        }
            
        //
        // Make sure the PID is in the form we're expecting.  Actually
        // make sure it's in the form that guimode setup is expecting.
        //
        // Then go validate it.
        //
        if( (wcslen(PidString) == PID_30_LENGTH) && ValidatePidEx(PidString) ) {
            Done = TRUE;
        } else {
            
            WCHAR   wc;

            Done = FALSE;

            //
            // invalid pid.  inform the user and try again.
            //
            WriteResourceMessage( IDS_PID_INVALID );
            
            bSuccess = ReadCharFromEMS(&wc, hCancelEvent);

            if (IsAsyncCancelSignalled(hCancelEvent)) {
                bSuccess = FALSE;
                goto exit;
            }

            if (!bSuccess) {
                goto exit;
            }

        }
        
    } while ( !Done );
    
exit:
    return(bSuccess);
}

BOOL
PresentEula(
    HANDLE hCancelEvent
    )
/*++

Routine Description:

    This function will present the user with an end-user-license-agreement (EULA).
    If the user rejects the EULA, then the function will return FALSE, otherwise
    TRUE.
    
Arguments:

    hCancelEvent - an event, which if signalled indicates that this routine 
                   should exit, returning error immediately.
    
Return Value:

    TRUE    - the EULA was accepted.
    FALSE   - the EULA was rejected.

--*/
{
    WCHAR   EulaPath[MAX_PATH];
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hFileMapping = INVALID_HANDLE_VALUE;
    DWORD   FileSize;
    BYTE    *pbFile = NULL;
    PWSTR   EulaText = NULL;
    ULONG   i;
    ULONG   j;
    BOOL    bSuccess;
    BOOL    Done;
    BOOL    bValidUserInput;
    BOOL    bAtEULAEnd;
    BOOL    ConvertResult;
    
    //
    // default: EULA was not accepted
    //
    bSuccess = FALSE;

    //
    // Load the EULA
    //

    //
    // Map the file containing the licensing agreement.
    //
    if(!GetSystemDirectory(EulaPath, MAX_PATH)){
        goto exit;
    }
    wcsncat( EulaPath, TEXT("\\eula.txt"), MAX_PATH );
    EulaPath[MAX_PATH-1] = TEXT('\0');

    hFile = CreateFile (
        EulaPath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(hFile == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    hFileMapping = CreateFileMapping (
        hFile,
        NULL,
        PAGE_READONLY,
        0, 0,
        NULL
        );
    if(hFileMapping == NULL) {
        goto exit;
    }

    pbFile = (BYTE*)MapViewOfFile (
        hFileMapping,
        FILE_MAP_READ,
        0, 0,
        0
        );
    if(pbFile == NULL) {
        goto exit;
    }

    //
    // Translate the text from ANSI to Unicode.
    //
    FileSize = GetFileSize (hFile, NULL);
    if(FileSize == 0xFFFFFFFF) {
        goto exit;
    }

    EulaText = (PWSTR)malloc ((FileSize+1) * sizeof(WCHAR));
    if(EulaText == NULL) {
        goto exit;
    }

    ConvertResult = MultiByteToWideChar(
        CP_ACP,
        0,
        (LPCSTR)pbFile,
        FileSize,
        EulaText,
        FileSize+1
        );

    if (!ConvertResult) {
        goto exit;
    }

    //
    // make sure there is a null terminator.
    //
    EulaText[FileSize] = 0;

    //
    // present the EULA to the EMS user
    //

    j=0;        
    Done = FALSE;
    bAtEULAEnd = FALSE;

    do {

        //
        // Clear the screen.
        //
        ClearEMSScreen();

        i=0;

        do {

            gEMSChannel->Write( (PWSTR)(&(EulaText[j])), sizeof(WCHAR) );

            // look for 0x0D0x0A pairs to denote EOL
            if (EulaText[j] == 0x0D) {
                if (j+1 < FileSize) {
                    if (EulaText[j+1] == 0x0A) {
                        i++;
                        if (i == EULA_LINES_PER_SCREEN) {
                            j++; // skip 0x0A if this is the last line on the screen
                                 // so that the next screen doesnt start with a lf
                            gEMSChannel->Write( (PWSTR)(&(EulaText[j])), sizeof(WCHAR) );
                        }
                    }
                }
            }

            j++;

        } while ( (i < EULA_LINES_PER_SCREEN) && (j < FileSize));
    
        //
        // Write some instructions/information.
        //
        WriteResourceMessage( IDS_EULA_ACCEPT_DECLINE );
        
        if (j < FileSize) {
            WriteResourceMessage( IDS_EULA_MORE );
        } else {
            // there are no more pages to display
            bAtEULAEnd = TRUE;
            gEMSChannel->Write( (PWSTR)(L"\r\n"), sizeof(WCHAR)*2 );
        }

        //
        // attempt to get a valid response from the user
        //
        // F8 == accept EULA
        // ESC == decline EULA
        // PAGE DOWN == go to next page if there is one
        // else just loop
        //
        do {

            ULONG   UserInputChar;
            BOOL    bHaveChar;

            bValidUserInput = FALSE;
            
            //
            // see what the user wants to do
            //
            bHaveChar = GetDecodedKeyPressFromEMS(
                &UserInputChar,
                hCancelEvent
                );

            if (IsAsyncCancelSignalled(hCancelEvent)) {
                bSuccess = FALSE;
                goto exit;
            }

            if (!bHaveChar) {
                bSuccess = FALSE;
                goto exit;
            }

            switch(UserInputChar) {
            case KEY_F8: 
                bSuccess = TRUE;
                Done = TRUE;
                bValidUserInput = TRUE;
                break;
            case ASCI_ESC:
                bSuccess = FALSE;
                Done = TRUE;
                bValidUserInput = TRUE;
                break;
            case KEY_PAGEDOWN:
                if (!bAtEULAEnd) {
                    // go to the next page if there is one
                    bValidUserInput = TRUE;
                    break;
                }
                // else consider this extraneous input and
                // fall through to default
            default:
                
                //
                // do nothing unless they give us what we want
                //
                NOTHING;

                break;
            }
        } while ( !bValidUserInput);
    } while ( !Done );

    //
    // cleanup
    //
    
exit:

    if (pbFile != NULL) {
        UnmapViewOfFile(pbFile);
    }
    if (hFileMapping != INVALID_HANDLE_VALUE) {
        CloseHandle(hFileMapping);
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
    if (EulaText != NULL) {
        free(EulaText);
    }

    return(bSuccess);
}




//
// ====================================
// Core functionality
// ====================================
//
INT_PTR CALLBACK 
UserInputAbortProc(
    HWND hwndDlg,  // handle to dialog box
    UINT uMsg,     // message
    WPARAM wParam, // first message parameter
    LPARAM lParam  // second message parameter
    )
{
    BOOL retval = FALSE;
    static UINT_PTR TimerId;
    static HANDLE hRemoveUI;
    
    switch(uMsg) {
    case WM_INITDIALOG:
        hRemoveUI = (HANDLE)lParam;
        //
        // create a timer that fires every second.  we will use this timer to 
        // determine if the dialog should go away.
        //
        if (!(TimerId = SetTimer(hwndDlg,0,1000,NULL))) {
            EndDialog(hwndDlg,0);
        }
        break;

    case WM_TIMER:
        //
        // check if the thread that created this dialog should go away.
        //
        if (WaitForSingleObject(hRemoveUI,0) == WAIT_OBJECT_0) {
            //
            // yes, the event signaled. cleanup and exit. 
            //
            KillTimer(hwndDlg,TimerId);
            EndDialog(hwndDlg,1);
        }
        break;

    case WM_COMMAND:
        switch (HIWORD( wParam ))
        {
        case BN_CLICKED:
            switch (LOWORD( wParam ))
            {
            case IDOK:
            case IDCANCEL:
                //
                // the user doesn't want prompted over the headless port.
                // kill the timer and exit.
                //
                KillTimer(hwndDlg,TimerId);
                EndDialog(hwndDlg,2);
            }
        };
    }

    return(retval);

}

DWORD    
PromptForUserInputThreadOverHeadlessConnection(
    PVOID params
    )
{
    PUserInputParams Params = (PUserInputParams)params;
    
    
    //
    // Go examine the unattend file.  If we find keys that either
    // aren't present, or will prevent us from going fully unattended,
    // then we'll fix them.
    //
    // We'll also prompt for a PID and/or EULA if necessary (i.e. if
    // the unattend file says we need to.
    //
    ProcessUnattendFile( TRUE, NULL, &Params->hRemoveUI );

    SetEvent(Params->hInputCompleteEvent);

    return 0;
}

DWORD    
PromptForUserInputThreadViaLocalDialog(
    PVOID params
    )
{
    PUserInputParams Params = (PUserInputParams)params;
    
    DialogBoxParam(
            GetModuleHandle(NULL),
            MAKEINTRESOURCE(IDD_ABORTDIALOG),
            NULL,
            UserInputAbortProc,
            (LPARAM)Params->hRemoveUI);
        
    SetEvent(Params->hInputCompleteEvent);
    
    return 0;
}

BOOL LoadStringResource(
    PUNICODE_STRING  pUnicodeString,
    INT              MsgId
    )
/*++

Routine Description:

    This is a simple implementation of LoadString().

Arguments:

    usString        - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
  
Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PWSTR MyString;
    DWORD StringLength,RetVal;
    BOOL  bSuccess = FALSE;

    //
    // the compiler clips string table entries at 256,
    // so this should be large enough for all calls
    //
    StringLength = 512;
    RetVal = 0;
    
    MyString = (PWSTR)malloc(StringLength*sizeof(WCHAR));
    
    if (MyString) {
        RetVal = LoadString(
                        GetModuleHandle(NULL),
                        MsgId,
                        MyString,
                        StringLength
                        );
        if (RetVal != 0) {
            RtlCreateUnicodeString(pUnicodeString, (PWSTR)MyString);
            bSuccess = TRUE;
        }

        free(MyString);
    }

    return(bSuccess);
}

BOOL
WriteResourceMessage(
    ULONG   MessageID
    )

/*++

Routine Description:

    This routine writes a resource string message to
    the global headless channel gEMSChannel.

Arguments:

    MessageID   - the id of the message to write                           
          
Return Value:

    TRUE    - the message was loaded and written
    FALSE   - failed

--*/
{
    UNICODE_STRING  UnicodeString = {0};
    BOOL            bSuccess = FALSE;

    bSuccess = LoadStringResource( &UnicodeString, MessageID );    
    if ( bSuccess ) {

        //
        // Write the message
        //
        gEMSChannel->Write( (PWSTR)UnicodeString.Buffer,
                            (ULONG)(wcslen( UnicodeString.Buffer) * sizeof(WCHAR)) );

        RtlFreeUnicodeString(&UnicodeString);

    }

    return bSuccess;
}

BOOL
PromptForPassword(
    PWSTR   Password,
    ULONG   BufferSize,
    HANDLE  hCancelEvent
    )
/*++

/*++

Routine Description:

    This routine asks the user for an administrator password.
    
    The contents of the response are checked to ensure the password
    is reasonable.  If the response is not deemed reasonable, then
    the user is informed and requeried.

Arguments:

    AdministratorPassword - Pointer to a string which holds the password.

    BufferSize  - the # of bytes in the Password buffer
                  (including the null termination)
    
    hCancelEvent - an event that signals that the routine should exit without completing.

Return Value:

    Returns TRUE if the password is successfully retrieved.
    
    FALSE otherwise.

--*/
{
    //
    // this is an arbitrary length, but needed so that the password UI doesn't wrap on a console screen.
    // if the user really wants a long password, they can change it post setup.  
    //
    #define     MY_MAX_PASSWORD_LENGTH (20)
    BOOL        Done = FALSE;
    WCHAR       InputBuffer[MY_MAX_PASSWORD_LENGTH+1];
    WCHAR       ConfirmAdministratorPassword[MY_MAX_PASSWORD_LENGTH+1];
    BOOL        GotAPassword;
    ULONG       MaxPasswordLength = 0;
    ULONG       BytesRead = 0;
    UNICODE_STRING  UnicodeString = {0};
    BOOL        bSuccess;    
    ULONG       CurrentPasswordCharacterIndex = 0;
    ULONG       PasswordLength = (BufferSize / sizeof(WCHAR)) - 1;

    MaxPasswordLength = min( PasswordLength, MY_MAX_PASSWORD_LENGTH );

    if( (Password == NULL) || (MaxPasswordLength == 0) ) {
        return FALSE;
    }

    //
    // Keep asking the user until we get what we want.
    //
    Done = FALSE;
    memset( Password,
            0,
            BufferSize
            ); 
    
    do {

        //
        // Clear the screen.
        //
        ClearEMSScreen();

        //
        // Write some instructions/information.
        //
        WriteResourceMessage( IDS_PASSWORD_BANNER );

        //
        // get the first password entry
        //
        bSuccess = GetStringFromEMS(
            Password,
            MaxPasswordLength * sizeof(WCHAR),
            FALSE,
            FALSE,
            hCancelEvent
            );

        if (IsAsyncCancelSignalled(hCancelEvent)) {
            bSuccess = FALSE;
            goto exit;
        }

        if (!bSuccess) {
            goto exit;
        }
        
        //
        // Now prompt for it a second time to confirm.
        //
        //
        // Write some instructions/information.
        //
        WriteResourceMessage( IDS_CONFIRM_PASSWORD_BANNER );

        //
        // get the second password entry
        //
        bSuccess = GetStringFromEMS(
            ConfirmAdministratorPassword,
            MaxPasswordLength * sizeof(WCHAR),
            FALSE,
            FALSE,
            hCancelEvent
            );

        if (IsAsyncCancelSignalled(hCancelEvent)) {
            bSuccess = FALSE;
            goto exit;
        }

        if (!bSuccess) {
            goto exit;
        }

        //
        // Now compare the two.
        //
        Done = TRUE;
        if( (wcslen(Password) != wcslen(ConfirmAdministratorPassword)) ||
            wcsncmp(Password, ConfirmAdministratorPassword, wcslen(Password)) ) {
            
            //
            // They entered 2 different passwords.
            //
            WriteResourceMessage( IDS_DIFFERENT_PASSWORDS_MESSAGE );

            Done = FALSE;

        } else {
            
            ULONG       i = 0;
            
            //
            // Make sure they entered something decent.
            //
            for( i = 0; i < wcslen(Password); i++ ) {
                if( (Password[i] <= 0x20) ||
                    (Password[i] >= 0x7F) ) {
                    
                    Done = FALSE;
                    break;
                
                }
            }

            //
            // Also make sure they didn't give me a blank
            //
            if( Password[0] == L'\0' ) {
                Done = FALSE;
            }

            if (!Done) {
                //
                // It's a bad password.
                //
                WriteResourceMessage( IDS_BAD_PASSWORD_CONTENTS );
            }
        }

        if (!Done) {
            
            WCHAR   wc;

            //
            // we posted a message, so
            // wait for them to hit a key and we'll keep going.
            //
            bSuccess = ReadCharFromEMS(&wc, hCancelEvent);

            if (IsAsyncCancelSignalled(hCancelEvent)) {
                bSuccess = FALSE;
                goto exit;
            }

            if (!bSuccess) {
                goto exit;
            }

        }

    } while ( !Done );
    
exit:
    return(bSuccess);
}

DWORD
ProcessUnattendFile(
    BOOL     FixUnattendFile,
    PBOOL    NeedsProcessing, OPTIONAL
    PHANDLE  hEvent OPTIONAL
    )
/*++

Routine Description:

    This function will the unattend file and determine if guimode
    setup will be able to proceed all the way through without any user input.
    
    If user input is required, we will either call someone to provide the
    ask for input, or we'll fill in a default value to allow setup to proceed.
    
    NOTE:
    The interesting bit here is that we need to go search for the unattend file.
    That's because we might be running as a result of sysprep, or we might be
    running as a result of just booting into guimode setup.  If we came through
    sysprep, then we need to go modify \sysprep\sysprep.inf.  That's because
    Setup will take sysprep.inf and overwrite %windir%\system32\$winnt$.inf
    before proceeding.  We'll intercept, fix sysprep.inf, then let it get
    copied on top of $winnt$.inf.

Arguments:

    FixUnattendFile - Indicates if we should only examine, or actually
                      fix the file by writing new values into it.
                      
                      If this comes in as false, no updates are made and
                      no prompts are sent to the user.
                      
    NeedsProcessing - if FixUnattendFile is FALSE, this gets filled in with
                      whether we need to update the unattend file.
                      
    hEvent          - a handle, which if supplied and signalled, indicates that the routine
                      should exit with status ERROR_CANCELLED.

Return Value:

    Win32 Error code indicating outcome.

--*/
{
    DWORD   Result = 0;
    WCHAR   AnswerFilePath[MAX_PATH] = {0};
    WCHAR   Answer[MAX_PATH] = {0};
    BOOL    b = TRUE;
    DWORD   ReturnCode = ERROR_SUCCESS;
    BOOL    NeedEula = TRUE;
    BOOL    OEMPreinstall = FALSE;
    HANDLE  hCancelEvent;

    if (hEvent) {
        hCancelEvent = *hEvent;
    } else {
        hEvent = NULL;
    }


    if (NeedsProcessing) {
        *NeedsProcessing = FALSE;
    }

    //
    // Build the path to the unattend file.
    //
    Result = GetWindowsDirectory( AnswerFilePath, MAX_PATH );
    if( Result == 0) {
        // Odd...
        return GetLastError();
    }


    if( gMiniSetup ) {
        //
        // This is a boot into minisetup.  Go load \sysprep\sysprep.inf
        //
        AnswerFilePath[3] = 0;
        wcsncat( AnswerFilePath, TEXT("sysprep\\sysprep.inf"), MAX_PATH );
        AnswerFilePath[MAX_PATH-1] = TEXT('\0');
    } else {
        //
        // This is a boot into guimode setup.  Go load %windir%\system32\$winnt$.inf
        //
        wcsncat( AnswerFilePath, TEXT("\\system32\\$winnt$.inf"), MAX_PATH );
        AnswerFilePath[MAX_PATH-1] = TEXT('\0');
    }


    //
    // ===================
    // Go check the keys that are required to make the install
    // happen completely unattendedly.
    // ===================
    //


    //
    // First check if it's an upgrade.  If so, then there will
    // be no prompts during guimode setup, so we can be done.
    //
    Answer[0] = TEXT('\0');
    Result = GetPrivateProfileString( WINNT_DATA,
                                      WINNT_D_NTUPGRADE,
                                      L"",
                                      Answer,
                                      MAX_PATH,
                                      AnswerFilePath );
    if( (Result != 0) && 
        !_wcsicmp(Answer, L"Yes") ) {
        //
        // It's an upgrade so We have zero work
        // to do.  Tell our caller that nothing's
        // needed.
        //
        return ERROR_SUCCESS;
    }

    //
    // Check if key present to skip this processing of Unattend file
    //
    Answer[0] = TEXT('\0');
    Result = GetPrivateProfileString( WINNT_UNATTENDED,
                                      L"EMSSkipUnattendProcessing",
                                      L"",
                                      Answer,
                                      MAX_PATH,
                                      AnswerFilePath );
    if(Result != 0) {
        
        //
        // if the flag was set, 
        // then we dont need to process anything
        // and we are done
        //
        
        if (NeedsProcessing) {
            *NeedsProcessing = FALSE;
        }

        return ERROR_SUCCESS;
    }


    //
    // Now see if it's an OEM preinstall.  We need this because some
    // unattend keys are ignored if it's a preinstall, so we
    // have to resort to the secret keys to make some wizard
    // pages really go away.
    //
    Answer[0] = TEXT('\0');
    Result = GetPrivateProfileString( WINNT_UNATTENDED,
                                      WINNT_OEMPREINSTALL,
                                      L"",
                                      Answer,
                                      MAX_PATH,
                                      AnswerFilePath );
    if( (!_wcsicmp(Answer, L"yes")) || (gMiniSetup) ) {
        OEMPreinstall = TRUE;
    }


    //
    // MiniSetup specific fixups/checks.
    //
    if( (gMiniSetup) &&
        (FixUnattendFile) ) {

        WCHAR   SysprepDirPath[MAX_PATH];
        HKEY    hKeySetup;

        //
        // We need to be careful here.  If they're doing a minisetup,
        // and the machine gets restarted before we actually launch into
        // guimode setup, the machine will be wedged.
        // We need to hack the registry to make it so minisetup will
        // restart correctly.
        //


        //
        // Reset the SetupType entry to 1.  We'll clear
        // it at the end of gui-mode.
        //
        Result = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  L"System\\Setup",
                                  0,
                                  KEY_SET_VALUE | KEY_QUERY_VALUE,
                                  &hKeySetup );

        if(Result == NO_ERROR) {
            //
            // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
            //
            Result = 1;
            RegSetValueEx( hKeySetup,
                           TEXT( "SetupType" ),
                           0,
                           REG_DWORD,
                           (CONST BYTE *)&Result,
                           sizeof(DWORD));

            RegCloseKey(hKeySetup);
        }

        
        //
        // If FixUnattendFile is set, then we're about to actually
        // start fiddling with their unattend file.  It happens that
        // they could have run sysprep in a way that there's no c:\sysprep
        // directory.  Before we start fixing the unattend file in
        // there, we should make sure the directory exists.  That
        // way our calls to WritePrivateProfileString will work
        // correctly and all will fly through unattendedly.
        //
        
        Result = GetWindowsDirectory( SysprepDirPath, MAX_PATH );
        if( Result == 0) {
            // Odd...
            return GetLastError();
        }

        SysprepDirPath[3] = 0;
        wcsncat( SysprepDirPath, TEXT("sysprep"), MAX_PATH );
        SysprepDirPath[MAX_PATH-1] = TEXT('\0');

        //
        // If the directory exists, this is a no-op.  If it
        // doesn't, we'll create it.  Note that permissions don't
        // really matter here because:
        // 1. this is how sysprep itself creates this directory.
        // 2. minisetup will delete this directory very shortly.
        //
        CreateDirectory( SysprepDirPath, NULL ); 

    }



    //
    // If FixUnattendFile is set, then we're about to actually
    // start fiddling with their unattend file.  It happens that
    // they could have run sysprep in a way that there's no c:\sysprep
    // directory.  Before we start fixing the unattend file in
    // there, we should make sure the directory exists.  That
    // way our calls to WritePrivateProfileString will work
    // correctly and all will fly through unattendedly.
    //



    //
    // Start fixing the individual sections.
    //


    //
    // [Unattended] section.
    // ---------------------
    //


    //
    // NOTE WELL:
    //
    // ====================================
    // Make sure to put all the code that actually prompts the user
    // right up here at the top of the function.  It's possible that
    // some of these keys might already exist, so we'll proceed through
    // some before stopping for a user prompt.  We want to make
    // sure to get ALL the user input before partying on their
    // unattend file.  That way, we never half-way process the unattend
    // file, then wait and give the user a chance to dismiss the dialog
    // on the local console.  Thus, leaving a 1/2-baked unattend file.
    //
    // Don't put any code that actually sets any of the unattend
    // settings before going and prompting for the EULA, PID
    // and Administrator password!!
    // ====================================
    //
    
    //
    // OemSkipEula
    //
    NeedEula = TRUE;
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_UNATTENDED,
                                          L"OemSkipEula",
                                          L"No",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( !_wcsicmp(Answer, L"Yes") ) {
            //
            // They won't get prompted for a EULA.  Make
            // sure we don't present here.
            //
            NeedEula = FALSE;
        }
    }

    //
    // EulaComplete
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DATA,
                                          WINNT_D_EULADONE,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result != 0) && 
            (!gMiniSetup) ) {
            //
            // EulaDone is there, and this isn't minisetup.
            // That means they've already accepted the EULA
            // and it won't be presented during guimode setup.
            // That also means we don't need to present it here.
            //
            NeedEula = FALSE;
        }
    }


    //
    // If we need to present the EULA, now would be a good
    // time.
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        if( NeedEula ) {
            if( FixUnattendFile ) {
                if( PresentEula(hCancelEvent) ) {
                    //
                    // They read and accepted the EULA.  Set a key
                    // so they won't get prompted during guimode setup.
                    //
                    b = WritePrivateProfileString( WINNT_DATA,
                                               WINNT_D_EULADONE,
                                               L"1",
                                               AnswerFilePath );
                    if( OEMPreinstall || gMiniSetup ) {
                        //
                        // This is the only way to make the EULA go away
                        // if it's a preinstall.
                        //
                        b = b & WritePrivateProfileString( WINNT_UNATTENDED,
                                                   L"OemSkipEula",
                                                   L"yes",
                                                   AnswerFilePath );
                    }

                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
    
                } else {
                    //
                    // See if they rejected the EULA, or if our UI got
                    // cancelled via the local console.
                    //
                    if( IsAsyncCancelSignalled(hCancelEvent) ) {
                        ReturnCode = ERROR_CANCELLED;
                    } else {
                        ReturnCode = ERROR_CANCELLED;
                        gRejectedEula = TRUE;
                    }
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }                
            }
    
        }
    }


    //
    // ProductKey
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_USERDATA,
                                          WINNT_US_PRODUCTKEY,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        //
        // If they gave us something (anything), then assume
        // it's okay.  We're not in the business of trying to
        // fix their PID in the answer file.
        //
        if( !_wcsicmp(Answer, L"") ) {
            
            //
            // Either they don't have a PID, or it's
            // a bad PID.  Go get a new one.
            //
            
            if( FixUnattendFile ) {
            
                Answer[0] = TEXT('\0');
                b = GetPid( Answer, MAX_PATH * sizeof(WCHAR), hCancelEvent );
        
                //
                // GetPid will only come back when he's got
                // a PID.  Write it into the unattend file.
                //
                if( b ) {
        
                    b = WritePrivateProfileString( WINNT_USERDATA,
                                                   WINNT_US_PRODUCTKEY,
                                                   Answer,
                                                   AnswerFilePath );
                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
                } else {
                    //
                    // GetPid shouldn't have come back unless we got
                    // a valid PID or if we got cancelled via the local
                    // console.  Either way, just set a cancelled
                    // code.
                    //
                    ReturnCode = ERROR_CANCELLED;
                }

            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }



    //
    // AdminPassword
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                          WINNT_US_ADMINPASS,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a AdminPassword.
            //
            // Maybe need to go prompt for a password!
            //
            if( FixUnattendFile ) {

                b = PromptForPassword( Answer, MAX_PATH * sizeof(WCHAR), hCancelEvent );
                
                if( b ) {

                    b = WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                                   WINNT_US_ADMINPASS,
                                                   Answer,
                                                   AnswerFilePath );
                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
                } else {
                    //
                    // We should never come back from PromptForPassword
                    // unless we got cancelled from the UI on the local
                    // console.  Set a cancelled status.
                    //
                    ReturnCode = ERROR_CANCELLED;
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // ====================================
    // If we get here, then it's okay to start actually modifying their
    // unattend file.  From here on out, there should be NO need to
    // ask the user anything.
    // ====================================
    //

    //
    // If we've made it here, and if FixUnattendFile is set,
    // then they've accepted the EULA through the headless port
    // and we're about to start partying on their unattend file.
    // We need to set an entry in their unattend file that tells 
    // support folks that they we stepped on their unattend file.
    // 
    if( (ReturnCode == ERROR_SUCCESS) &&
        (FixUnattendFile) ) {
        WritePrivateProfileString( WINNT_DATA,
                                   L"EMSGeneratedAnswers",
                                   L"1",
                                   AnswerFilePath );
    }



    //
    // Unattendmode
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_UNATTENDED,
                                          WINNT_U_UNATTENDMODE,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( _wcsicmp(Answer, WINNT_A_FULLUNATTENDED) ) {
            //
            // They're not running fully unattended.
            // Set it.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_UNATTENDED,
                                           WINNT_U_UNATTENDMODE,
                                           WINNT_A_FULLUNATTENDED,
                                           AnswerFilePath );                
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }





    //
    // [Data] section
    // --------------
    //
    
    
    //
    // unattendedinstall
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DATA,
                                          WINNT_D_INSTALL,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (_wcsicmp(Answer, L"yes")) ) {
            //
            // They don't have the super-double-secret key
            // that tells guimode to go fully unattended.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_DATA,
                                                        WINNT_D_INSTALL,
                                                        L"yes",
                                                        AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }



    //
    // msdosinitiated
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DATA,
                                          WINNT_D_MSDOS,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (_wcsicmp(Answer, L"1")) ) {
            if( FixUnattendFile ) {
                //
                // They'll get the welcome screen without this.
                //
                b = WritePrivateProfileString( WINNT_DATA,
                                                        WINNT_D_MSDOS,
                                                        L"1",
                                                        AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // floppyless
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DATA,
                                          WINNT_D_FLOPPY,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (_wcsicmp(Answer, L"1")) ) {
            if( FixUnattendFile ) {
                //
                // They'll get the welcome screen without this.
                //
                b = WritePrivateProfileString( WINNT_DATA,
                                                        WINNT_D_FLOPPY,
                                                        L"1",
                                                        AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }




    //
    // skipmissingfiles
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_SETUPPARAMS,
                                          WINNT_S_SKIPMISSING,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (_wcsicmp(Answer, L"1")) ) {
            //
            // They might get prompted for missing files w/o this setting.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_SETUPPARAMS,
                                                        WINNT_S_SKIPMISSING,
                                                        L"1",
                                                        AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }



    //
    // [UserData] section
    // ------------------
    //


    //
    // FullName
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_USERDATA,
                                          WINNT_US_FULLNAME,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a name.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_USERDATA,
                                               WINNT_US_FULLNAME,
                                               L"UserName",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // OrgName
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_USERDATA,
                                          WINNT_US_ORGNAME,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a name.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_USERDATA,
                                               WINNT_US_ORGNAME,
                                               L"OrganizationName",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // ComputerName
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_USERDATA,
                                          WINNT_US_COMPNAME,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a ComputerName.
            //
            if( FixUnattendFile ) {
                
                b = WritePrivateProfileString( WINNT_USERDATA,
                                               WINNT_US_COMPNAME,
                                               L"*",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // [GuiUnattended] section
    // -----------------------
    //

    //
    // TimeZone
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                          WINNT_G_TIMEZONE,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
            
                b = WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                               WINNT_G_TIMEZONE,
                                               L"004",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }

            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // OEMSkipWelcome
    //

    //
    // If this is a preinstall, or a sysprep/MiniSetup, then
    // they're going to get hit with the welcome screen no
    // matter the unattend mode.  If either of those are
    // true, then we need to set this key.
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        if( OEMPreinstall || gMiniSetup ) {
            //
            // It's a preinstall, or it's a sysprep, which means
            // it will be interpreted as a preinstall.  Make sure
            // they've got the skip welcome set or guimode will
            // halt on the welcome page.
            //

            Answer[0] = TEXT('\0');
            Result = GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                              L"OEMSkipWelcome",
                                              L"",
                                              Answer,
                                              MAX_PATH,
                                              AnswerFilePath );
            if( (Result == 0) || (_wcsicmp(Answer, L"1")) ) {
                //
                // He's going to hit the welcome screen.
                //
                if( FixUnattendFile ) {
                    b = WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                                   L"OEMSkipWelcome",
                                                   L"1",
                                                   AnswerFilePath );
                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
                } else {
                    //
                    // Tell someone there's work to do here.
                    //
                    if (NeedsProcessing) {
                        *NeedsProcessing = TRUE;
                    }
                }
            
            }
        }
    }


    //
    // OemSkipRegional
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        if( OEMPreinstall || gMiniSetup ) {
            //
            // It's a preinstall, or it's a sysprep, which means
            // it will be interpreted as a preinstall.  Make sure
            // they've got the skip regional set or guimode will
            // halt on the regional settings page.
            //

            Answer[0] = TEXT('\0');
            Result = GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                              L"OEMSkipRegional",
                                              L"",
                                              Answer,
                                              MAX_PATH,
                                              AnswerFilePath );
            if( (Result == 0) || (_wcsicmp(Answer, L"1")) ) {
                //
                // He's going to hit the welcome screen.
                //
                if( FixUnattendFile ) {
                    b = WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                                   L"OEMSkipRegional",
                                                   L"1",
                                                   AnswerFilePath );
                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
                } else {
                    //
                    // Tell someone there's work to do here.
                    //
                    if (NeedsProcessing) {
                        *NeedsProcessing = TRUE;
                    }
                }
            
            }
        }
    }



    //
    // [LicenseFilePrintData] section
    // ------------------------------
    //

    //
    // AutoMode
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_LICENSEDATA,
                                          WINNT_L_AUTOMODE,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_LICENSEDATA,
                                               WINNT_L_AUTOMODE,
                                               L"PerServer",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // AutoUsers
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_LICENSEDATA,
                                          WINNT_L_AUTOUSERS,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_LICENSEDATA,
                                               WINNT_L_AUTOUSERS,
                                               L"5",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // [Display] section
    // -----------------
    //

    //
    // BitsPerPel
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DISPLAY,
                                          WINNT_DISP_BITSPERPEL,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_DISPLAY,
                                               WINNT_DISP_BITSPERPEL,
                                               L"16",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // XResolution
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DISPLAY,
                                          WINNT_DISP_XRESOLUTION,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                
                b = WritePrivateProfileString( WINNT_DISPLAY,
                                               WINNT_DISP_XRESOLUTION,
                                               L"800",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // YResolution
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DISPLAY,
                                          WINNT_DISP_YRESOLUTION,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_DISPLAY,
                                               WINNT_DISP_YRESOLUTION,
                                               L"600",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }

    //
    // VRefresh
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( WINNT_DISPLAY,
                                          WINNT_DISP_VREFRESH,
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a TimeZone.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( WINNT_DISPLAY,
                                               WINNT_DISP_VREFRESH,
                                               L"70",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }




    //
    // [Identification] section
    // ------------------------
    //

    //
    // JoinWorkgroup
    //
    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileString( L"Identification",
                                          L"JoinWorkgroup",
                                          L"",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
            //
            // They don't have a JoinWorkgroup.  See if they've
            // got JoinDomain?
            //
            Answer[0] = TEXT('\0');
            Result = GetPrivateProfileString( L"Identification",
                                              L"JoinDomain",
                                              L"",
                                              Answer,
                                              MAX_PATH,
                                              AnswerFilePath );
            if( (Result == 0) || (!_wcsicmp(Answer, L"")) ) {
                //
                // Nope.  Go plug in a JoinWorkgroup entry.  That
                // way we don't need to prompt/specify which domain to join.
                //   
                if( FixUnattendFile ) {
                    b = WritePrivateProfileString( L"Identification",
                                                   L"JoinWorkgroup",
                                                   L"Workgroup",
                                                   AnswerFilePath );
                    if( !b ) {
                        //
                        // Remember the error and keep going.
                        //
                        ReturnCode = GetLastError();
                    }
                } else {
                    //
                    // Tell someone there's work to do here.
                    //
                    if (NeedsProcessing) {
                        *NeedsProcessing = TRUE;
                    }
                }
        
            }
        }
    }


    //
    // [Networking]
    //

    //
    // This section must at least exist.  If it doesn't, we'll
    // get prompted during network configuration.  Make sure it's
    // at least there.
    //

    if( ReturnCode == ERROR_SUCCESS ) {
        Answer[0] = TEXT('\0');
        Result = GetPrivateProfileSection( L"Networking",
                                          Answer,
                                          MAX_PATH,
                                          AnswerFilePath );
        if( Result == 0 ) {
            //
            // They don't have a [Networking] section.
            //
            if( FixUnattendFile ) {
                b = WritePrivateProfileString( L"Networking",
                                               L"unused",
                                               L"0",
                                               AnswerFilePath );
                if( !b ) {
                    //
                    // Remember the error and keep going.
                    //
                    ReturnCode = GetLastError();
                }
            } else {
                //
                // Tell someone there's work to do here.
                //
                if (NeedsProcessing) {
                    *NeedsProcessing = TRUE;
                }
            }
        }
    }


    //
    // We're done.
    //

    //
    // If we've just successfully fixed up their unattend file, give them
    // a little notification here.
    //
    if( (FixUnattendFile) && (ReturnCode == ERROR_SUCCESS) ) {

        //
        // Clear the screen.
        //
        ClearEMSScreen();

        //
        // Write some instructions/information, then pause
        // before proceeding.
        //
        WriteResourceMessage( IDS_UNATTEND_FIXUP_DONE );

        //
        // wait...
        //
        Sleep( 5 * 1000);
    
    }

    return( ReturnCode );
}


extern "C"
BOOL
CheckEMS(
    IN int argc,
    WCHAR *argvW[]
    )
/*++

Routine Description:

    main entrypoint to code.
        
Arguments:

    argc  - number of args
    argvW - array of args.
Return Value:

    Win32 Error code indicating outcome.  FALSE means we had a problem.

--*/
{
    UserInputParams Params,ParamsDialog;
    DWORD ThreadId;
    HANDLE Handles[2];
    HANDLE hThreadHeadless = NULL,hThreadUI = NULL;
    ULONG   i = 0;
    BOOL RetVal;
    BOOL NeedsProcessing;

    RtlZeroMemory(&Params,sizeof(Params));
    RtlZeroMemory(&ParamsDialog,sizeof(ParamsDialog));

    //
    // Check if headless feature is present on this machine.  If not, just
    // run setup like normal.
    //
    
    
    //
    // initialize our headless channel data which we'll soon need.
    //
    if (!InitializeGlobalChannelAttributes(&GlobalChannelAttributes)) {
        RetVal = FALSE;
        goto exit;
    }
    
    //
    // Go see if headless is present and if so, create
    // a channel.
    //
    if(!IsHeadlessPresent(&gEMSChannel)) {
        //
        // There's no work to do.  Go run Setup.
        //
        RetVal = TRUE;
        goto exit;
    }

    //
    // See if we're running MiniSetup or base Guimode Setup.
    //
    for( i = 0; i < (ULONG)argc; i++ ) {
        if( !_wcsnicmp(argvW[i], L"-mini", wcslen(L"-mini")) ) {
            gMiniSetup = TRUE;
        }
    }

    //
    // Check if there is any work for us to do.  If not, just run setup like
    // normal.
    //
    if( ProcessUnattendFile(FALSE,&NeedsProcessing, NULL) != ERROR_SUCCESS ) {    
        //
        // something catastrophic happened.  exit.        
        //
        RetVal = FALSE;
        goto exit;
    }

    if( !NeedsProcessing) {    
        //
        // There's no work to do.  Go run Setup.
        //
        RetVal = TRUE;
        goto exit;
    }

    //
    // Create a pait of threads for getting data from the user via 
    // the headless port or the local UI
    //
    Params.Channel = gEMSChannel;
    Params.hInputCompleteEvent  = CreateEvent(NULL,TRUE,FALSE,NULL);
    ParamsDialog.hInputCompleteEvent  = CreateEvent(NULL,TRUE,FALSE,NULL);    
    Params.hRemoveUI = ParamsDialog.hRemoveUI = CreateEvent(NULL,TRUE,FALSE,NULL);    
    
    if (!Params.hInputCompleteEvent || 
        !ParamsDialog.hInputCompleteEvent ||
        !Params.hRemoveUI) {
        RetVal = FALSE;
        goto exit;
    }

    if (!(hThreadHeadless = CreateThread(
                    NULL,
                    0,
                    &PromptForUserInputThreadOverHeadlessConnection,
                    &Params,
                    0,
                    &ThreadId))) {
            RetVal = FALSE;
            goto exit;
    } 

    if (!(hThreadUI = CreateThread(
            NULL,
            0,
            &PromptForUserInputThreadViaLocalDialog,
            &ParamsDialog,
            0,
            &ThreadId))) {
        RetVal = FALSE;
        goto exit;
    }    

    //
    // wait for either of our named events to fire off which signals that one of the threads is done.
    //
    Handles[0] = Params.hInputCompleteEvent;
    Handles[1] = ParamsDialog.hInputCompleteEvent;

    WaitForMultipleObjects(2,Handles,FALSE,INFINITE);
    
    //
    // set an event that signals that the other thread should terminate.
    //
    SetEvent(Params.hRemoveUI);

    //
    // now wait for both of the threads to terminate before proceeding.
    //
    Handles[0] = hThreadHeadless;
    Handles[1] = hThreadUI;
    
    WaitForMultipleObjects(2,Handles,TRUE,INFINITE);

    RetVal = TRUE;

exit:
    if (hThreadHeadless) {
        CloseHandle(hThreadHeadless);
    }

    if (hThreadUI) {
        CloseHandle(hThreadUI);
    }

    if (Params.hInputCompleteEvent) {
        CloseHandle(Params.hInputCompleteEvent);
    }

    if (ParamsDialog.hInputCompleteEvent) {
        CloseHandle(ParamsDialog.hInputCompleteEvent);
    }

    if (Params.hRemoveUI) {
        CloseHandle(Params.hRemoveUI);
    }
    
    if (gEMSChannel) {
        delete (gEMSChannel);
    }

    //
    // Careful here.  If they actually rejected the
    // EULA through the headless port, then we want
    // to terminate instead of firing off setup.
    // We'll tell our caller about that by returning
    // zero.
    //
    if( gRejectedEula || RetVal == FALSE ) {
        return FALSE ;
    } else {
        return TRUE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\legacy\exe\ems.h ===
//
// Headless communication constants and structures.
//
#define VTUTF8_CLEAR_SCREEN         L"\033[2J\033[0;0H"
#define MY_MAX_STRING_LENGTH        (256)

typedef struct _UserInputParams {
    EMSVTUTF8Channel* Channel; // headless channel object
    HANDLE hInputCompleteEvent; //signals that the user is done.
    HANDLE hRemoveUI;  //signals that we should abort.
} UserInputParams, *PUserInputParams;

            


typedef BOOL    ( STDAPICALLTYPE *SETUPPIDGENW )(
                        LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
                        LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
                        LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
                        BOOL   fOem,                // [IN] is this an OEM install?
                        LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
                        LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
                        LPBOOL  pfCCP);              // [OUT] optional ptr to Compliance Checking flag (can be NULL)


DEFINE_GUID(
    SAC_CHANNEL_GUI_SETUP_PROMPT, /* 77320899-e37c-41bc-8cbc-840920e12b60 */
    0x77320899,0xe37c,0x41bc,0x8c, 0xbc, 0x84, 0x09, 0x20, 0xe1, 0x2b, 0x60);





//
// PID presentation constants.
//
#define MAX_PID30_SITE              (3)
#define MAX_PID30_RPC               (5)
#define SETUP_TYPE_BUFFER_LEN       (8)


//
// EULA presentation constants.
//
#define EULA_LINES_PER_SCREEN       (15)






//
// EMS communication function prototypes.
//

BOOL 
IsHeadlessPresent(
    OUT EMSVTUTF8Channel **Channel
    );

BOOL
InitializeGlobalChannelAttributes(
    PSAC_CHANNEL_OPEN_ATTRIBUTES ChannelAttributes
    );

BOOL
WaitForUserInputFromEMS(
    IN  DWORD   TimeOut,
    OUT BOOL    *TimedOut,  OPTIONAL
    IN  HANDLE  hCancelEvent  OPTIONAL
    );

BOOL
ReadCharFromEMS(
    OUT PWCHAR  awc,
    IN  HANDLE  hCancelEvent  OPTIONAL
    );

BOOL
GetStringFromEMS(
    OUT PWSTR   String,
    IN  ULONG   BufferSize,
    IN  BOOL    GetAllChars,
    IN  BOOL    EchoClearText,
    IN  HANDLE  hCancelEvent  OPTIONAL
    );

VOID
ClearEMSScreen();

BOOL
GetDecodedKeyPressFromEMS(
    OUT PULONG  KeyPress,
    IN  HANDLE  hCancelEvent  OPTIONAL
    );

#define ASCI_ETX    3   //  control-C
#define ASCI_BS     8
#define ASCI_NL     10
#define ASCI_C      67
#define ASCI_LOWER_C 99
#define ASCI_CR     13
#define ASCI_ESC    27

//
// Character codes are passed around as ULONGs within setup.
// The low word is a Unicode character value; the high word
// is used for various other keypresses.
//
#define KEY_PAGEUP          0x00010000
#define KEY_PAGEDOWN        0x00020000
#define KEY_UP              0x00030000
#define KEY_DOWN            0x00040000
#define KEY_LEFT            0x00050000
#define KEY_RIGHT           0x00060000
#define KEY_HOME            0x00070000
#define KEY_END             0x00080000
#define KEY_INSERT          0x00090000
#define KEY_DELETE          0x000a0000
#define KEY_F1              0x00110000
#define KEY_F2              0x00120000
#define KEY_F3              0x00130000
#define KEY_F4              0x00140000
#define KEY_F5              0x00150000
#define KEY_F6              0x00160000
#define KEY_F7              0x00170000
#define KEY_F8              0x00180000
#define KEY_F9              0x00190000
#define KEY_F10             0x001a0000
#define KEY_F11             0x001b0000
#define KEY_F12             0x001c0000
//
// PID function prototypes.
//
BOOL
InitializePidVariables(
    );

BOOL
ValidatePidEx(
    LPTSTR PID, 
    BOOL *pbStepup, 
    BOOL *bSelect
    );

BOOL
ValidatePid30(
    LPTSTR aPID
    );

BOOL
ValidatePid30Assemble(
    LPTSTR Edit1,
    LPTSTR Edit2,
    LPTSTR Edit3,
    LPTSTR Edit4,
    LPTSTR Edit5
    );

BOOL
GetPid( 
    IN PWSTR   PidString, 
    IN ULONG   BufferSize,
    IN HANDLE  hCancelEvent
    );

//
// EULA function prototypes
//
BOOL
PresentEula(
    HANDLE  hCancelEvent
    );

//
// Core Functionality
//

INT_PTR CALLBACK 
UserInputAbortProc(
    HWND hwndDlg,  // handle to dialog box
    UINT uMsg,     // message
    WPARAM wParam, // first message parameter
    LPARAM lParam  // second message parameter
    );

DWORD    
PromptForUserInputThreadOverHeadlessConnection(
    PVOID params
    );

DWORD    
PromptForUserInputThreadViaLocalDialog(
    PVOID params
    );

BOOL
LoadStringResource(
    PUNICODE_STRING  pUnicodeString,
    INT              MsgId
    );

BOOL
WriteResourceMessage(
    ULONG   MessageID
    );

BOOL
PromptForPassword(
    IN PWSTR   Password,
    IN ULONG   BufferSize,
    IN HANDLE  hCancelEvent
    );

DWORD
ProcessUnattendFile(
    BOOL    FixUnattendFile,
    PBOOL   ProcessingRequired, OPTIONAL
    PHANDLE hCancelEvent OPTIONAL
    );

extern "C"
BOOL
CheckEMS(
    IN int argc,
    WCHAR *argvW[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\inf\win4\tools\xdosnet\xdosnet.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dosnet.c

Abstract:

    This module implements a program that generates the [Files]
    section of dosnet.inf.

    The input consists of the layout inf; the output consists of
    an intermediary form of dosnet.inf.

Author:

    Ted Miller (tedm) 20-May-1995

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <sputils.h>


//
// Define program result codes (returned from main()).
//
#define SUCCESS 0
#define FAILURE 1


//
// Keep statistics...
//
INT     ProcessedLines = 0;
INT     RemovedEntries = 0;
INT     DuplicateEntries = 0;
INT     PassThroughEntries = 0;

HINF    hExclusionInf = INVALID_HANDLE_VALUE;

BOOL
ParseArgs(
    IN int   argc,
    IN char *argv[]
    )
{
    return(argc > 5);
}


BOOL
IsEntryInFilterFile(
    IN HINF    hFilterinf,
    IN PCWSTR  Inputval
    )
{
INFCONTEXT Context,SectionContext;
PCWSTR     CabName;
WCHAR      SectionName[LINE_LEN];
UINT       Field,
           FieldCount;

    //
    // First make sure we actually have a filter inf.
    // If not, then the entry certainly isn't in there.
    //
    if( !hFilterinf ) {
        return( FALSE );
    }

    //
    // Now get the section names that we have to search.
    //
    if (!SetupFindFirstLineW( hFilterinf, L"Version", L"CabFiles", &SectionContext)) {
        return( FALSE );
    }

    //
    // Search the sections for our entry.
    //
    do {

        FieldCount = SetupGetFieldCount(&SectionContext);
        for( Field=1; Field<=FieldCount; Field++ ) {
            if(SetupGetStringFieldW(&SectionContext,Field,SectionName,LINE_LEN,NULL)
               && SetupFindFirstLineW(hFilterinf, SectionName, Inputval, &Context)) {
                //
                // we found a match
                //
                return( TRUE );
            }
        }

    } while (SetupFindNextMatchLine(&SectionContext,TEXT("CabFiles"),&SectionContext));

    //
    // If we get here, we didn't find a match.
    //
    return( FALSE );
}

void
AddToTempFile(
    PCWSTR FileName,
    PINFCONTEXT InfContext,
    FILE   *TempFile
    ){

    WCHAR BootFloppyval[LINE_LEN];
    UCHAR      line[MAX_INF_STRING_LENGTH];

    if(SetupGetStringFieldW(InfContext,7,BootFloppyval,LINE_LEN,NULL)
            && BootFloppyval[0]){

        WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        FileName,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

        fprintf(TempFile,"%s\n",line);
        //fprintf(stderr,"xdosnet: Writing file %s\n",FileName);
    }

    return;

}


BOOL
InExclusionList(
    PCWSTR FileName,
    PINFCONTEXT InfContext
    )
{
    WCHAR BootFloppyval[LINE_LEN];
    INFCONTEXT Ctxt;


    //
    // first look in our global hardcoded exclusion list for the file
    //
    if (hExclusionInf != INVALID_HANDLE_VALUE) {
        if (SetupFindFirstLineW(hExclusionInf, L"Files", FileName, &Ctxt)) {
//            printf("excluding via inf file %ws\n",FileName);
            return(TRUE);
        }
    }

    //
    // now we need to see if this is a boot-disk file, which must be
    // excluded
    //
    if (SetupGetStringFieldW(InfContext,7,BootFloppyval,LINE_LEN,NULL)
            && !BootFloppyval[0]) {
        return(FALSE);
    }

//    printf("excluding boot file %ws\n",FileName);

    return(TRUE);

}

// Returns the DiskId of the file.  This is basically
// 1 or 2 for now.
void pGetDiskIdStr(
	IN INFCONTEXT InputContext,
	IN DWORD DiskID,
	IN PSTR StrDiskID,
	IN DWORD  StrLen
	)
{
	WCHAR      Tmp[20];

    if ( DiskID == -1 )
	{
		if(SetupGetStringFieldW(&InputContext,1,Tmp,sizeof(Tmp)/sizeof(WCHAR),NULL)) 
		{
            // Hack to make the CHS, CHT & KOR builds working.  They use 7 as the
            // diskid for some reason.  This means unless we do this hack the binaries
            // are marked to be on the 7th disk and that creates havoc with winnt.exe
            // not being able to copy stuff etc.
            // The hack is to see if the diskid is 7 and if it is then reset it to
            // 1.  This is what would have happened before the 2CD changes to
            // xdosnet.exe,  makefile.inc in MergedComponents\SetupInfs
            if ( ! lstrcmpW(Tmp,L"7") )
                lstrcpyW(Tmp, L"1");
		}
		else
		{
			// say it is d1 if the above fails
			lstrcpyW(Tmp,L"1");
		}
	}
	else
	{
		swprintf(Tmp, L"%d", DiskID);
	}
	
	WideCharToMultiByte(
		CP_OEMCP,
		0,
		Tmp,
		-1,
		StrDiskID,
		StrLen,
		NULL,
		NULL
		);
}

BOOL
DoSection(
    IN HINF    hInputinf,
    IN PCWSTR  InputSectionName,
    IN HINF    hFilterinf,
    IN DWORD   DiskID,
    IN FILE   *OutFile,
    IN FILE   *ExcludeFile,
    IN FILE   *TempFile
    )
{
#define VERBOSE 1
INFCONTEXT InputContext;
UCHAR      line[MAX_INF_STRING_LENGTH];
WCHAR      Inputval[MAX_INF_STRING_LENGTH];
BOOL       WriteEntry = TRUE;
UCHAR      StrDiskID[20];


    if(SetupFindFirstLineW(hInputinf,InputSectionName,NULL,&InputContext)) {

        do {

        //
        // Keep track of how many lines we process from the original inf (layout.inf)
        //
        ProcessedLines++;

            if(SetupGetStringFieldW(&InputContext,0,Inputval,MAX_INF_STRING_LENGTH,NULL)) {

                //
                // Assume the entry is good unless proven otherwise.
                //
                WriteEntry = TRUE;

                if( TempFile ) {
                    AddToTempFile( Inputval, &InputContext, TempFile );
                }
                    


                //
                // See if it's in the filter file.
                //
                if( IsEntryInFilterFile( hFilterinf, Inputval ) ) {
                    if (!InExclusionList(Inputval, &InputContext )) {
                        //
                        // It's in the exclusion list.  Skip it.
                        //
                        RemovedEntries++;
                        WriteEntry = FALSE;

                        if (ExcludeFile) {

                            if( WideCharToMultiByte(
                                CP_OEMCP,
                                0,
                                Inputval,
                                -1,
                                line,
                                sizeof(line),
                                NULL,
                                NULL
                                ) ){

                                fprintf(ExcludeFile,"%s\n",line);

                            }

                            

                        }
                    } else {
                        //
                        // It's a boot file.  Keep it.  Note that it's a
                        // duplicate and will appear both inside and outside
                        // the CAB.
                        //
                        DuplicateEntries++;
                    }
                } else {
                    //
                    // It's not even in the filter file.  Log it for
                    // statistics.
                    //
                    PassThroughEntries++;
                }

                //
                // Write the entry out only if it's not supposed to
                // be filtered out.
                //
                if( WriteEntry ) {
                    //
                    // Dosnet.inf is in OEM chars.
                    //
                    WideCharToMultiByte(
                        CP_OEMCP,
                        0,
                        Inputval,
                        -1,
                        line,
                        sizeof(line),
                        NULL,
                        NULL
                        );

					// We need to find the disk this file is on and add that
					// to the file description.
					pGetDiskIdStr(InputContext, DiskID, StrDiskID, sizeof(StrDiskID));

                    fprintf(OutFile,"d%s,%s\n",StrDiskID,line);
                }


            } else {
                fprintf(stderr,"A line in section %ws has no key\n",InputSectionName);
                return(FALSE);
            }
        } while(SetupFindNextLine(&InputContext,&InputContext));

    } else {
        fprintf(stderr,"Section %ws is empty or missing\n",InputSectionName);
        return(FALSE);
    }

    return(TRUE);
}

BOOL
DoIt(
    IN char *InFilename,
    IN char *FilterFilename,
    IN DWORD DiskID,
    IN FILE *OutFile,
    IN FILE *ExcludeFile,
    IN char *PlatformExtension,
    IN FILE *TempFile
    )
{
    PCWSTR inFilename;
    PCWSTR filterFilename;
    PCWSTR extension;
    HINF hInputinf,
         hFilterinf;
    BOOL b;
    WCHAR sectionName[256];
    INFCONTEXT Ctxt;

    b = FALSE;

    inFilename = pSetupAnsiToUnicode(InFilename);
    filterFilename = pSetupAnsiToUnicode(FilterFilename);

    //
    // Only proceed if we've got a file to work with.
    //
    if( inFilename ) {

        //
        // Only proceed if we've got a filter file to work with.
        //
        if( filterFilename ) {

            hInputinf = SetupOpenInfFileW(inFilename,NULL,INF_STYLE_WIN4,NULL);
            if(hInputinf != INVALID_HANDLE_VALUE) {

                //
                // If the filter-file fails, just keep going.  This will
                // result in a big dosnet.inf, which means we'll have files
                // present both inside and outside the driver CAB, but
                // that's not fatal.
                //
                hFilterinf = SetupOpenInfFileW(filterFilename,NULL,INF_STYLE_WIN4,NULL);
                if(hFilterinf == INVALID_HANDLE_VALUE) {
                    fprintf(stderr,"Unable to open inf file %s\n",FilterFilename);
                    hFilterinf = NULL;
                }


                //
                // We're actually ready to process the sections!
                //
                fprintf(OutFile,"[Files]\n");

                if (ExcludeFile) {
                    fprintf(ExcludeFile,"[Version]\n");
                    fprintf(ExcludeFile,"signature=\"$Windows NT$\"\n");
                    fprintf(ExcludeFile,"[Files]\n");
                }


                b = DoSection( hInputinf,
                               L"SourceDisksFiles",
                               hFilterinf,
                               DiskID,
                               OutFile,
                               ExcludeFile,
                               TempFile );

                if( b ) {

                    //
                    // Now process the x86-or-Alpha-specific section.
                    //
                    if(extension = pSetupAnsiToUnicode(PlatformExtension)) {

                        lstrcpyW(sectionName,L"SourceDisksFiles");
                        lstrcatW(sectionName,L".");
                        lstrcatW(sectionName,extension);
                        b = DoSection( hInputinf,
                                       sectionName,
                                       hFilterinf,
                                       DiskID,
                                       OutFile,
                                       ExcludeFile,
                                       TempFile );

                        pSetupFree(extension);
                    } else {
                        fprintf(stderr,"Unable to convert string %s to Unicode\n",PlatformExtension);
                    }
                }

                //Write the files in the input exclude INF to the [ForceCopyDriverCabFiles] section

                if (hExclusionInf != INVALID_HANDLE_VALUE) {

                    WCHAR Filename[LINE_LEN];
                    UCHAR line[MAX_INF_STRING_LENGTH];


                    if (SetupFindFirstLineW(hExclusionInf, L"Files", NULL, &Ctxt)){


                        fprintf(OutFile,"\n\n[ForceCopyDriverCabFiles]\n");


                        do{

                            if( SetupGetStringFieldW( &Ctxt, 1, Filename, LINE_LEN, NULL )){


                                //
                                // Dosnet.inf is in OEM chars.
                                //
                                WideCharToMultiByte(
                                    CP_OEMCP,
                                    0,
                                    Filename,
                                    -1,
                                    line,
                                    sizeof(line),
                                    NULL,
                                    NULL
                                    );

                                
                                fprintf(OutFile,"%s\n",line);

                            }


                        }while( SetupFindNextLine( &Ctxt, &Ctxt ));

                    }else{

                        fprintf(stderr,"Could not find the Files section in the Exclude INF file\n");
                    }

                    

                }


                //
                // Print Statistics...
                //
                fprintf( stderr, "                               Total lines processed: %6d\n", ProcessedLines );
                fprintf( stderr, "                     Entries removed via filter file: %6d\n", RemovedEntries );
                fprintf( stderr, "Entries appearing both inside and outside driver CAB: %6d\n", DuplicateEntries );
                fprintf( stderr, "                Entries not appearing in filter file: %6d\n", PassThroughEntries );

                //
                // Close up our inf handles.
                //
                if( hFilterinf ) {
                    SetupCloseInfFile( hFilterinf );
                }
                SetupCloseInfFile(hInputinf);

            } else {
                fprintf(stderr,"Unable to open inf file %s\n",InFilename);
            }

            pSetupFree( filterFilename );

        } else {
            fprintf(stderr,"Unable to convert filename %s to Unicode\n",FilterFilename);
        }
        pSetupFree(inFilename);
    } else {
        fprintf(stderr,"Unable to convert filename %s to Unicode\n",InFilename);
        return(FALSE);
    }

    return(b);
}


int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    FILE *OutputFile,*ExcludeFile, *TempFile;
    BOOL b;
    DWORD DiskID;
    char input_filename_fullpath[MAX_PATH];
    char *p;

    //
    // Assume failure.
    //
    b = FALSE;

    if(!pSetupInitializeUtils()) {
        return FAILURE;
    }

    if(ParseArgs(argc,argv)) {

        //
        // Open the output file.
        //
        OutputFile = fopen(argv[4],"wt");
        
        if (argc >= 7) {
            ExcludeFile = fopen(argv[6],"wt");
        } else {
            ExcludeFile = NULL;
        }

        if (argc >= 8) {
            hExclusionInf = SetupOpenInfFileA(argv[7],NULL,INF_STYLE_WIN4,NULL);
            if (hExclusionInf != INVALID_HANDLE_VALUE) {
                fprintf(stderr,"xdosnet: Opened file %s\n",argv[7]);
            }
            
        } else {
            hExclusionInf = INVALID_HANDLE_VALUE;
        }

        if (argc >= 9) {
            TempFile = fopen(argv[8],"wt");
            if( !TempFile )
                fprintf(stderr,"%s: Unable to create temp file %s\n",argv[0],argv[8]);
            //fprintf(stderr,"xdosnet: Created file %s\n",argv[8]);
        }else{
            TempFile = NULL;
        }

		// Special case handling Disk 1, Disk 2 etc. for x86.  Since we want to process
		// all lines - this just means ignore the disk id specified on the command line
		// and pick up the Disk ID that is specified in the layout.inx entry itself.
        if ( argv[3][0] == '*' )
			DiskID = -1;
		else
			DiskID = atoi(argv[3]);

        GetFullPathName(
                argv[1],
                sizeof(input_filename_fullpath),
                input_filename_fullpath,
                &p);


        if(OutputFile) {

            fprintf(
                stdout,
                "%s: creating %s from %s and %s for %s (%s)\n",
                argv[0],
                argv[4],
                input_filename_fullpath,
                argv[2],
                argv[5],
                argv[6]);

            b = DoIt( input_filename_fullpath,
                      argv[2],
                      DiskID,
                      OutputFile,
                      ExcludeFile,
                      argv[5],
                      TempFile);

            fclose(OutputFile);

        } else {
            fprintf(stderr,"%s: Unable to create output file %s\n",argv[0],argv[3]);
        }

        if (ExcludeFile) {
	    fclose(ExcludeFile);
        }
        if (TempFile) {
	    fclose(TempFile);
        }

    } else {
        fprintf( stderr,"Merge 3 inf files.  Usage:\n" );
        fprintf( stderr,"%s  <input file1> <filter file> <diskid> <output file> <platform extension> <optional output exclude file> <optional input exclusion inf>\n", argv[0] );
        fprintf( stderr,"\n" );
        fprintf( stderr,"  <input file1> - original inf file (i.e. layout.inf)\n" );
        fprintf( stderr,"  <filter file> - contains a list of entries to be excluded\n" );
        fprintf( stderr,"                  from the final output file\n" );
        fprintf( stderr,"  <disk id>     - output disk id (i.e. 1 or 2)\n" );
        fprintf( stderr,"  <output file> - output inf (i.e. dosnet.inf)\n" );
        fprintf( stderr,"  <platform extension>\n" );
        fprintf( stderr,"  <output exclude file> - optional output file containing files that were filtered\n" );
        fprintf( stderr,"  <input exclusion inf> - optional input inf containing files that should never be filtered\n" );
        fprintf( stderr,"  <temp file> - optional file to be used to write boot file list into (IA64 temporary workaround)\n");
        fprintf( stderr,"\n" );
        fprintf( stderr,"\n" );

    }

    pSetupUninitializeUtils();

    return(b ? SUCCESS : FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\libmsg\libmsg.h ===
#include <windows.h>

//
// Message output routines.
//

#if defined(__cplusplus)

extern "C"
{
#endif

LPTSTR
GetFormattedMessage(
    IN HMODULE  ThisModule, OPTIONAL
    IN BOOL     SystemMessage,
    OUT PWCHAR  Message,
    IN ULONG    LengthOfBuffer,
    IN UINT     MessageId,
    ...
    );

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\legacy\exe\setup.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>

#define PNP_NEW_HW_PIPE       L"\\\\.\\pipe\\PNP_New_HW_Found"
#define PNP_CREATE_PIPE_EVENT L"PNP_Create_Pipe_Event"
#define PNP_PIPE_TIMEOUT      180000

typedef BOOL     (WINAPI *FP_DEVINSTALLW)(HDEVINFO, PSP_DEVINFO_DATA);
typedef HDEVINFO (WINAPI *FP_CREATEDEVICEINFOLIST)(LPGUID, HWND);
typedef BOOL     (WINAPI *FP_OPENDEVICEINFO)(HDEVINFO, PCWSTR, HWND, DWORD, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_DESTROYDEVICEINFOLIST)(HDEVINFO);
typedef BOOL     (WINAPI *FP_GETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS_W);
typedef BOOL     (WINAPI *FP_ENUMDEVICEINFO)(HDEVINFO, DWORD, PSP_DEVINFO_DATA);
typedef  INT      (WINAPI *FP_PROMPTREBOOT)(HSPFILEQ, HWND, BOOL);


extern
BOOL
CheckEMS(
    IN int argc,
    WCHAR *argvW[]
    );


VOID
InstallNewHardware(
    IN HMODULE hSysSetup
    );

int
__cdecl
wmain(
    IN int   argc,
    IN wchar_t *argv[]
    )
{
    BOOL    NewSetup = TRUE;
    BOOL    NewHardware = FALSE;
    BOOL    CheckedEms = FALSE;
    INT     i;
    HMODULE h = NULL;
    FARPROC p = NULL;
    WCHAR   FileName[MAX_PATH / 2];

    //
    // Scan Command Line for -newsetup flag
    //
    for(i = 0; i < argc; i++) {
        PCWSTR arg = argv[i];
        if(arg[0] == '-') {
            arg += 1;
            if(_wcsicmp(arg,L"newsetup") == 0) {
                NewSetup = TRUE;
            } else if (_wcsicmp(arg, L"plugplay") == 0) {
                NewHardware = TRUE;
            } else if (
                   _wcsicmp(arg, L"asr") == 0
                || _wcsicmp(arg, L"asrquicktest") == 0
                || _wcsicmp(arg, L"mini") == 0
                ) {
                ;   // do nothing
            } else
                return ERROR_INVALID_PARAMETER;
        }
    }


    i = ERROR_INVALID_PARAMETER;
    if (NewSetup && !NewHardware) {
        //
        // Go see if there's a headless port that we need to
        // get setup values from.
        //
        // He'll return FALSE *only* if we shouldn't run
        // setup (like if the user rejected the EULA
        // through the EMS port).  Otherwise he'll return
        // TRUE and we should run through setup.
        //
        
        CheckedEms = TRUE;

        if (!CheckEMS(argc, argv)) {
            //
            // Set our return code for bailing.
            //
            i = 0;
        }
    }
    

    if (!CheckedEms || i != 0 ) {
    
        //
        // Load the Appropriate Libary and function pointer
        //
                
        h = LoadLibraryW(L"syssetup.dll");
    
    
        if( h ){
    
            if (NewHardware) {
                InstallNewHardware(h);
            } else {
                const PPEB Peb = NtCurrentPeb();
    #if DBG
                if (   !RTL_SOFT_ASSERT(Peb->ActivationContextData == NULL)
                    || !RTL_SOFT_ASSERT(Peb->ProcessAssemblyStorageMap == NULL)
                    || !RTL_SOFT_ASSERT(Peb->SystemDefaultActivationContextData == NULL)
                    || !RTL_SOFT_ASSERT(Peb->SystemAssemblyStorageMap == NULL)) {
    
                    ASSERTMSG(
                    "setup -newsetup has a process default or system default\n"
                    "activation context. Did you forget the -isd switch to ntsd?\n",
                        FALSE);
                }
    #endif
                // for people debugging with VC
                Peb->ActivationContextData = NULL;
                Peb->ProcessAssemblyStorageMap = NULL;
                Peb->SystemDefaultActivationContextData = NULL;
                Peb->SystemAssemblyStorageMap = NULL;
    
                //
                // Call the target function.
                //
                p=GetProcAddress(h,"InstallWindowsNt");
                if(p) {
                    i = (int) p(argc,argv);
                }
    
            }
        } else {
            i = GetLastError();            
        }        
    }

    //
    // Make sure that the library goes away
    //

    while(h && GetModuleFileNameW(h,FileName,RTL_NUMBER_OF(FileName))) {
        FreeLibrary(h);
    }    
    
    return i;
}



VOID
InstallNewHardware(
    IN HMODULE hSysSetup
    )
{
    FP_DEVINSTALLW            fpDevInstallW = NULL;
    FP_CREATEDEVICEINFOLIST   fpCreateDeviceInfoList = NULL;
    FP_OPENDEVICEINFO         fpOpenDeviceInfoW = NULL;
    FP_DESTROYDEVICEINFOLIST  fpDestroyDeviceInfoList;
    FP_GETDEVICEINSTALLPARAMS fpGetDeviceInstallParams;
    FP_ENUMDEVICEINFO         fpEnumDeviceInfo;
    FP_PROMPTREBOOT           fpPromptReboot;

    HMODULE             hSetupApi = NULL;
    WCHAR               szBuffer[MAX_PATH];
    ULONG               ulSize = 0, Index;
    HANDLE              hPipe = INVALID_HANDLE_VALUE;
    HANDLE              hEvent = NULL;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA     DeviceInfoData;
    SP_DEVINSTALL_PARAMS_W DeviceInstallParams;
    BOOL                bReboot = FALSE;
    BOOL                Status = FALSE;

    //
    // retrieve a proc address of the DevInstallW procedure in syssetup
    //
    if (!(fpDevInstallW =
            (FP_DEVINSTALLW)GetProcAddress(hSysSetup, "DevInstallW"))) {

        goto Clean0;
    }

    //
    // also load setupapi and retrieve following proc addresses
    //
    hSetupApi = LoadLibraryW(L"setupapi.dll");

    if (!(fpCreateDeviceInfoList =
            (FP_CREATEDEVICEINFOLIST)GetProcAddress(hSetupApi,
                                "SetupDiCreateDeviceInfoList"))) {
        goto Clean0;
    }

    if (!(fpOpenDeviceInfoW =
            (FP_OPENDEVICEINFO)GetProcAddress(hSetupApi,
                                "SetupDiOpenDeviceInfoW"))) {
        goto Clean0;
    }

    if (!(fpDestroyDeviceInfoList =
            (FP_DESTROYDEVICEINFOLIST)GetProcAddress(hSetupApi,
                                "SetupDiDestroyDeviceInfoList"))) {
        goto Clean0;
    }

    if (!(fpGetDeviceInstallParams =
            (FP_GETDEVICEINSTALLPARAMS)GetProcAddress(hSetupApi,
                                "SetupDiGetDeviceInstallParamsW"))) {
        goto Clean0;
    }

    if (!(fpEnumDeviceInfo =
            (FP_ENUMDEVICEINFO)GetProcAddress(hSetupApi,
                                "SetupDiEnumDeviceInfo"))) {
        goto Clean0;
    }

    if (!(fpPromptReboot =
            (FP_PROMPTREBOOT)GetProcAddress(hSetupApi,
                                "SetupPromptReboot"))) {
        goto Clean0;
    }

    //
    // open the event that will be used to signal the successful
    // creation of the named pipe (event should have been created
    // before I was called but if this process is started by anyone
    // else then it will go away now safely)
    //
    hEvent = OpenEventW(EVENT_MODIFY_STATE,
                       FALSE,
                       PNP_CREATE_PIPE_EVENT);

    if (hEvent == NULL) {
        goto Clean0;
    }

    //
    // create the named pipe, umpnpmgr will write requests to
    // this pipe if new hardware is found
    //
    hPipe = CreateNamedPipeW(PNP_NEW_HW_PIPE,
                            PIPE_ACCESS_INBOUND,
                            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                            1,                         // only one connection
                            MAX_PATH * sizeof(WCHAR),  // out buffer size
                            MAX_PATH * sizeof(WCHAR),  // in buffer size
                            PNP_PIPE_TIMEOUT,          // default timeout
                            NULL                       // default security
                            );

    //
    // signal the event now, whether the pipe was successfully created
    // or not (don't keep userinit/cfgmgr32 waiting)
    //
    SetEvent(hEvent);

    if (hPipe == INVALID_HANDLE_VALUE) {
        goto Clean0;
    }

    //
    // connect to the newly created named pipe
    //
    if (ConnectNamedPipe(hPipe, NULL)) {
        //
        // create a devinfo handle and device info data set to
        // pass to DevInstall
        //
        if((hDevInfo = (fpCreateDeviceInfoList)(NULL, NULL))
                        == INVALID_HANDLE_VALUE) {
            goto Clean0;
        }

        while (TRUE) {
            //
            // listen to the named pipe by submitting read
            // requests until the named pipe is broken on the
            // other end.
            //
            if (!ReadFile(hPipe,
                     (LPBYTE)szBuffer,    // device instance id
                     MAX_PATH * sizeof(WCHAR),
                     &ulSize,
                     NULL)) {

                if (GetLastError() != ERROR_BROKEN_PIPE) {
                    // Perhaps Log an Event
                }

                goto Clean0;
            }

            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            if(!(fpOpenDeviceInfoW)(hDevInfo, szBuffer, NULL, 0, &DeviceInfoData)) {
                goto Clean0;
            }

            //
            // call syssetup, DevInstallW
            //
            if ((fpDevInstallW)(hDevInfo, &DeviceInfoData)) {
                Status = TRUE;  // at least one device installed successfully
            }
        }
    }

    Clean0:

    //
    // If at least one device was successfully installed, then determine
    // whether a reboot prompt is necessary.
    //
    if (Status && hDevInfo != INVALID_HANDLE_VALUE) {
        //
        // Enumerate each device that is associated with the device info set.
        //
        Index = 0;
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        while ((fpEnumDeviceInfo)(hDevInfo,
                                  Index,
                                  &DeviceInfoData)) {
            //
            // Get device install params, keep track if any report needing
            // a reboot.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);
            if ((fpGetDeviceInstallParams)(hDevInfo,
                                           &DeviceInfoData,
                                           &DeviceInstallParams)) {

                if ((DeviceInstallParams.Flags & DI_NEEDREBOOT) ||
                    (DeviceInstallParams.Flags & DI_NEEDRESTART)) {

                    bReboot = TRUE;
                }
            }
            Index++;
        }

        (fpDestroyDeviceInfoList)(hDevInfo);

        //
        // If any devices need reboot, prompt for reboot now.
        //
        if (bReboot) {
            (fpPromptReboot)(NULL, NULL, FALSE);
        }
    }

    if (hSetupApi != NULL) {
        FreeLibrary(hSetupApi);
    }
    if (hPipe != INVALID_HANDLE_VALUE) {
        DisconnectNamedPipe(hPipe);
        CloseHandle(hPipe);
    }
    if (hEvent != NULL) {
        CloseHandle(hEvent);
    }

    return;

} // InstallNewHardware
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\libmsg\libmsg.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    libmsg.c

Abstract:

    Message handling routines.

Author:

    Mandar Gokhale(mandarg) 20-Dec-2001

Revision History:

--*/

#include "libmsg.h"

LPTSTR
GetFormattedMessage(
    IN  HMODULE ThisModule, OPTIONAL
    IN  BOOL    SystemMessage,
    OUT PWCHAR  Message,
    IN  ULONG   LengthOfBuffer,
    IN  UINT    MessageId,
    ...
    )
/*++

Routine Description:

    Retreive and format a message.

Arguments:

    ThisModule - Handle to this module that contains the message.

    SystemMessage - specifies whether the message is to be located in
        this module, or whether it's a system message.

    Message  - Message buffer that will contain the formatted message.

    LengthOfBuffer - Length of the message buffer in characters.

    MessageId - If SystemMessage is TRUE, then this supplies a system message id,
        such as a Win32 error code. If SystemMessage is FALSE, the this supplies
        the id for the message within this module's resources.

    Additional arguments supply values to be inserted in the message text.

Return Value:

    Returns a pointer to the message buffer if a message is retrieved 
    into the messaage buffer otherwise returns NULL.
	

--*/

{
    va_list arglist;
    DWORD d;
    

    if (Message && LengthOfBuffer){

	*Message = UNICODE_NULL;
    	va_start(arglist,MessageId);
    	d = FormatMessage(
            SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
            ThisModule,
            MessageId,
            0,
            Message,
            LengthOfBuffer,
            &arglist
            );
	    va_end(arglist);
    }
	 
    	return(Message);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migdlls\src\miglib\miglibp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    migdllsp.h

Abstract:

    Private header for miglib.

Author:

    Marc R. Whitten (marcw) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "plugin.h"
#include "mgdlllib.h"

#define DBG_FOO     "Foo"

//
// Strings
//

#define DBG_MIGDLLS     "MIGDLLS"

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//






typedef LONG (CALLBACK *P_QUERY_MIGRATION_INFO_A)(
                            OUT PMIGRATIONINFOA * Info
                            );

typedef LONG (CALLBACK *P_INITIALIZE_SRC_A)(
                            IN PCSTR WorkingDirectories,
                            IN PCSTR SourceDirectories,
                            IN PCSTR MediaDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_USER_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCSTR UserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_SYSTEM_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_QUERY_MIGRATION_INFO_W)(
                            OUT PMIGRATIONINFOW * Info
                            );

typedef LONG (CALLBACK *P_INITIALIZE_SRC_W)(
                            IN PCWSTR WorkingDirectories,
                            IN PCWSTR SourceDirectories,
                            IN PCWSTR MediaDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_USER_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCWSTR UserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_GATHER_SYSTEM_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            PVOID Reserved
                            );



typedef LONG (CALLBACK *P_INITIALIZE_DST_W)(
                            IN PCWSTR WorkingDirectories,
                            IN PCWSTR SourceDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_USER_SETTINGS_W)(
                            IN HINF AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCWSTR UserName,
                            IN PCWSTR UserDomain,
                            IN PCWSTR FixedUserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_SYSTEM_SETTINGS_W)(
                            IN PCWSTR AnswerFile,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_INITIALIZE_DST_A)(
                            IN PCSTR WorkingDirectories,
                            IN PCSTR SourceDirectories,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_USER_SETTINGS_A)(
                            IN HINF AnswerFile,
                            IN HKEY UserRegKey,
                            IN PCSTR UserName,
                            IN PCSTR UserDomain,
                            IN PCSTR FixedUserName,
                            PVOID Reserved
                            );

typedef LONG (CALLBACK *P_APPLY_SYSTEM_SETTINGS_A)(
                            IN PCSTR AnswerFile,
                            PVOID Reserved
                            );


//
// Globals
//

extern POOLHANDLE g_MigLibPool;
extern CHAR g_MigIsolPathA[MAX_MBCHAR_PATH];
extern WCHAR g_MigIsolPathW[MAX_WCHAR_PATH];

//
// Macro expansion list
//

// None

//
// Public function prototypes
//


//
// Oldstyle migration dll entry points.
//

BOOL
CallQueryVersion (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA  MigInfo
    );

BOOL
CallInitialize9x (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceDirList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    );

BOOL
CallMigrateUser9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    );


BOOL
CallMigrateSystem9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    );

BOOL
CallInitializeNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

BOOL
CallMigrateUserNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PCWSTR RootKey,
    IN      PCWSTR Win9xUserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UserProfilePath,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

BOOL
CallMigrateSystemNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

//
// Helper functions.
//
BOOL
IsCodePageArrayValid (
    IN      PDWORD CodePageArray
    );

BOOL
ValidateBinary (
    IN      PBYTE Data,
    IN      UINT Size,
    IN      BOOL ReadWrite
    );

BOOL
ValidateNonNullStringA (
    IN      PCSTR String
    );

BOOL
ValidateNonNullStringW (
    IN      PCWSTR String
    );


BOOL
ValidateIntArray (
    IN      PINT Array
    );

BOOL
ValidateMultiStringA (
    IN      PCSTR Strings
    );

BOOL
ValidateMultiStringW (
    IN      PCWSTR Strings
    );


//
// Macro expansion definition
//

// None

//
// ANSI/UNICODE macros
//

// None
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migdlls\src\miglib\oldstyle.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    oldstyle.c

Abstract:

    Implements entry points for handling old style (Windows 2000 era) migration dlls.
    Culled from code in the win95upg project.

Author:

    Marc R. Whitten (marcw) 25-Feb-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "miglibp.h"


//
// Strings
//



//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

PBYTE g_Data;
DWORD g_DataSize;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
VOID
pSetCwd (
    OUT     PWSTR SavedWorkDir, 
    IN      UINT CharCount, 
    IN      PCWSTR NewWorkDir
    )
{
    GetCurrentDirectoryW (CharCount, SavedWorkDir);
    SetCurrentDirectoryW (NewWorkDir);
}

VOID
pFreeGlobalIpcBuffer (
    VOID
    )
{
    //
    // Free old return param buffer
    //
    if (g_Data) {
        MemFree (g_hHeap, 0, g_Data);
        g_Data = NULL;
    }

    g_DataSize = 0;
}

DWORD
pFinishHandshake (
    IN      PCTSTR FunctionName
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    BOOL b;
    UINT Count = 40;            // about 5 minutes
    UINT AliveAllowance = 10;   // about 30 minutes

    do {
        //
        // No OUT parameters on the NT side, so we don't care
        // about the return data
        //

        b = GetIpcCommandResults (
                IPC_GET_RESULTS_NT,
                NULL,
                NULL,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // Loop if no data received, but process is alive
        //

        if (!b) {
            if (!IsIpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }

            // continue if command was not sent yet but exe is still OK
            Count--;
            if (Count == 0) {
            /*
                if (WaitForSingleObject (g_AliveEvent, 0) == WAIT_OBJECT_0) {
                    DEBUGMSG ((DBG_WARNING, "Alive allowance given to migration DLL"));

                    AliveAllowance--;
                    if (AliveAllowance) {
                        Count = 24;        // about 3 minutes
                    }
                }
             */
                if (Count == 0) {
                    rc = ERROR_SEM_TIMEOUT;
                    break;
                }
            }
        }

    } while (!b);


    return rc;
}


DWORD
pFinishHandshake9x(
    VOID
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    DWORD DataSize = 0;
    PBYTE Data = NULL;
    BOOL b;

    pFreeGlobalIpcBuffer();

    do {
        b = GetIpcCommandResults (
                IPC_GET_RESULTS_WIN9X,
                &Data,
                &DataSize,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // Loop if no data received, but process is alive
        //
        if (!b) {
            if (!IsIpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }


        }

    } while (!b);

    if (b) {
        //
        // Save return param block and loop back for IPC_LOG or IPC_DONE
        //

        g_DataSize = DataSize;
        g_Data = Data;


    }

    return rc;
}



BOOL
CallQueryVersion (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA  MigInfo
    )
{
    P_QUERY_VERSION QueryVersion;
    DWORD rc;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PBYTE DataPtr;
    INT ReturnArraySize;
    PDWORD ReturnArray;
    PCTSTR p;
    DWORD DataSize;

    if(!MigInfo){
        MYASSERT(FALSE);
        return FALSE;
    }

    MigInfo->StaticProductIdentifier = NULL;
    MigInfo->DllVersion = 1;
    MigInfo->NeededFileList = NULL;
    MigInfo->VendorInfo = NULL;
    MigInfo->SourceOs = OS_WINDOWS9X;
    MigInfo->TargetOs = OS_WINDOWS2000;

    if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "QueryVersion called before Migration DLL opened."));
            return FALSE;
        }

        QueryVersion = (P_QUERY_VERSION) GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION);
        if (!QueryVersion) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for QueryVersion."));
            return FALSE;
        }

        //
        // Call the function.
        //
        rc = QueryVersion (
                &MigInfo->StaticProductIdentifier,
                &MigInfo->DllVersion,
                &MigInfo->CodePageArray,
                MigInfo->NeededFileList,
                &MigInfo->VendorInfo
                );

        SetLastError (rc);

        if (rc != ERROR_SUCCESS && rc != ERROR_NOT_INSTALLED) {
            return FALSE;
        }

    }
    else {

        //
        // Isolated call.
        //
        pFreeGlobalIpcBuffer();

    __try {

            //
            // Send the working directory, since migisol will need to set this before
            // calling QueryVersion.
            //

            MultiSzAppendA (&GrowBuf, WorkingDirectory);

            DEBUGMSG ((DBG_MIGDLLS, "Calling QueryVersion via migisol.exe"));

            if (!SendIpcCommand (
                    IPC_QUERY,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteQueryVersion failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return code.
            //

            rc = pFinishHandshake9x();
            SetLastError (rc);

            if (rc != ERROR_SUCCESS && rc != ERROR_NOT_INSTALLED) {
                return FALSE;
            }


            //
            // Unpack the buffer, if received.
            //
            if (g_Data) {

                DEBUGMSG ((DBG_MIGDLLS, "Parsing QueryVersion return data"));

                __try {
                    DataPtr = g_Data;

                    //
                    // Unpack product ID
                    //
                    MigInfo->StaticProductIdentifier = DataPtr;
                    DataPtr = GetEndOfStringA ((PCSTR) DataPtr) + 1;

                    //
                    // Unpack DLL version
                    //
                    MigInfo->DllVersion = *((PINT) DataPtr);
                    DataPtr += sizeof(INT);

                    //
                    // Unpack the CP array
                    //
                    ReturnArraySize = *((PINT) DataPtr);
                    DataPtr += sizeof(INT);

                    if (ReturnArraySize) {
                        ReturnArray = (PDWORD) DataPtr;
                        DataPtr += ReturnArraySize * sizeof (DWORD);
                    } else {
                        ReturnArray = NULL;
                    }

                    MigInfo->CodePageArray = ReturnArray;

                    //
                    // Unpack Exe name buffer
                    //
                    MigInfo->NeededFileList = (PSTR *) DataPtr;

                    if (MigInfo->NeededFileList && *MigInfo->NeededFileList) {
                        p = *MigInfo->NeededFileList;
                        while (p && *p) {
                            p = GetEndOfStringA (p) + 1;
                        }
                        DataPtr = (PBYTE) (p + 1);
                    }

                    MigInfo->VendorInfo = ((PVENDORINFO) DataPtr);
                    DataPtr += sizeof (PVENDORINFO);

                    DEBUGMSG ((DBG_MIGDLLS, "Unpacked VendorInfo pointer is 0x%X", *MigInfo->VendorInfo));

                    if (MigInfo->VendorInfo) {
                        DataSize = *((PDWORD) DataPtr);
                        DataPtr += sizeof (DWORD);
                        MYASSERT (DataSize == sizeof (VENDORINFO));

                        MigInfo->VendorInfo = (PVENDORINFO) PoolMemDuplicateMemory (g_MigLibPool, DataPtr, sizeof (VENDORINFO));
                        DataPtr += sizeof (VENDORINFO);
                    }

                    DEBUGMSG ((DBG_MIGDLLS, "QueryVersion is complete, rc=%u", rc));
                }

                __except(EXCEPTION_EXECUTE_HANDLER) {
                    LOG ((LOG_ERROR, "An error occurred while unpacking params"));
                    rc = ERROR_INVALID_PARAMETER;
                }
            } else {
                DEBUGMSG ((DBG_WARNING, "pRemoteQueryVersion: No OUT params received"));

                //
                // We should never return ERROR_SUCCESS if no buffer is received.
                //
                if (rc == ERROR_SUCCESS) {
                    SetLastError (ERROR_INVALID_PARAMETER);

                }

                return FALSE;
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }



    }

    return TRUE;
}

BOOL
CallInitialize9x (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR SourceDirList,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_9X Initialize9x;
    CHAR WorkingDirCopy[MAX_PATH];
    PCSTR p;
    PSTR SourceDirListCopy;
    DWORD rc;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PBYTE Data;
    DWORD ReturnSize;


    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (SourceDirList);

    if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "Initialize9x called before Migration DLL opened."));
            return FALSE;
        }

        Initialize9x = (P_INITIALIZE_9X) GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X);
        if (!Initialize9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for Initialize9x."));
            return FALSE;
        }

        //
        // Call the entry point directly
        //

        SetCurrentDirectory (WorkingDir);

        //
        // Make a copy of all the supplied params, so if the migration DLL changes
        // them, the rest of the upgrade isn't messed up.
        //

        if(strlen(WorkingDir) >= ARRAYSIZE(WorkingDirCopy)){
            return FALSE;
        }
        StringCopyA (WorkingDirCopy, WorkingDir);

        p = SourceDirList;
        while (*p) {
            p = GetEndOfStringA (p) + 1;
        }
        p++;

        SourceDirListCopy = AllocText ((UINT)(p - SourceDirList));
        MYASSERT (SourceDirListCopy);
        if (SourceDirListCopy) {
            CopyMemory (SourceDirListCopy, SourceDirList, p - SourceDirList);
        }

        //
        // Call the entry point
        //

        rc = Initialize9x (WorkingDirCopy, SourceDirListCopy, Reserved);

        FreeText (SourceDirListCopy);

        //
        // If DLL returns ERROR_NOT_INSTALLED, do not call it any further
        // If DLL returns something other than ERROR_SUCCESS, abandon the DLL
        //

        if (rc == ERROR_NOT_INSTALLED) {
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        } else if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            DEBUGMSG ((DBG_MIGDLLS, "DLL failed in Initialize9x with rc=%u", rc));
            return FALSE;
        }
    }
    else {


        //
        // Call the entry point via migisol.exe.
        //

        pFreeGlobalIpcBuffer();

        __try {
            //
            // Send working dir and source dirs
            //
            MultiSzAppendA (&GrowBuf, WorkingDir);

            for (p = SourceDirList ; *p ; p = GetEndOfStringA (p) + 1) {
                MultiSzAppendA (&GrowBuf, p);
            }

            MultiSzAppendA (&GrowBuf, p);
            GrowBufAppendDword (&GrowBuf, ReservedSize);

            if (ReservedSize) {
                Data = GrowBuffer (&GrowBuf, ReservedSize);
                CopyMemory (Data, Reserved, ReservedSize);
            }

            //
            // Send command to migisol
            //

            rc = ERROR_SUCCESS;

            if (!SendIpcCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteInitialize9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return code.
            //
            rc = pFinishHandshake9x();
            SetLastError (rc);

            //
            // The reserved parameter may come back
            //

            if (g_Data) {
                Data = g_Data;
                ReturnSize = *((PDWORD) Data);
                if (ReturnSize && ReturnSize <= ReservedSize) {
                    Data += sizeof (DWORD);
                    CopyMemory (Reserved, Data, ReturnSize);
                } else if (ReservedSize) {
                    ZeroMemory (Reserved, ReservedSize);
                }
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }


        //
        // CopyOfReserved now has the return value.  We don't
        // use it currently.
        //

    }


    return rc == ERROR_SUCCESS;

}


BOOL
CallMigrateUser9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    P_MIGRATE_USER_9X MigrateUser9x;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    HKEY userHandle;


    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateUser9x called before Migration DLL opened."));
            return FALSE;
        }

        MigrateUser9x = (P_MIGRATE_USER_9X) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X);
        if (!MigrateUser9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateUser9x."));
            return FALSE;
        }

        userHandle = OpenRegKeyStr (UserKey);
        if (!userHandle) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        //
        // Call the migration DLL
        //

        rc = MigrateUser9x (
                NULL,
                UnattendTxt,
                userHandle,
                UserName,
                Reserved
                );

        if(userHandle){
            CloseRegKey (userHandle);
        }

    } else {


        //
        // Call the entry point via migisol.exe
        //

        pFreeGlobalIpcBuffer();

        __try {

            MultiSzAppendA (&GrowBuf, TEXT(""));
            GrowBufAppendDword (&GrowBuf, 0);
            MultiSzAppendA (&GrowBuf, UnattendTxt);
            MultiSzAppendA (&GrowBuf, UserKey);
            MultiSzAppendA (&GrowBuf, (NULL == UserName ? "" : UserName));

            if (!SendIpcCommand (
                     IPC_MIGRATEUSER,
                     GrowBuf.Buf,
                     GrowBuf.End
                     )) {

                LOG ((LOG_ERROR, "pRemoteMigrateUser9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Complete the transaction. The caller will interpret the return
            // value.
            //
            rc = pFinishHandshake9x();

            //
            // No data buffer is coming back at this time
            //
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }

    if (rc == ERROR_NOT_INSTALLED) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateUser9x with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
}

BOOL
CallMigrateSystem9x (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UnattendTxt,
    IN      PVOID Reserved,
    IN      DWORD ReservedSize
    )
{
    LONG rc;
    P_MIGRATE_SYSTEM_9X MigrateSystem9x;
    GROWBUFFER GrowBuf = GROWBUF_INIT;


    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateSystem9x called before Migration DLL opened."));
            return FALSE;
        }

        MigrateSystem9x = (P_MIGRATE_SYSTEM_9X) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X);
        if (!MigrateSystem9x) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateSystem9x."));
            return FALSE;
        }



        rc = MigrateSystem9x (
                 NULL,
                 UnattendTxt,
                 Reserved
                 );

    } else {

        pFreeGlobalIpcBuffer();

        __try {
            MultiSzAppendA (&GrowBuf, "");
            GrowBufAppendDword (&GrowBuf, 0);
            MultiSzAppendA (&GrowBuf, UnattendTxt);

            if (!SendIpcCommand (
                    IPC_MIGRATESYSTEM,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR,"pRemoteMigrateSystem9x failed to send command"));
                rc = GetLastError();
                __leave;
            }

            //
            // Finish transaction. Caller will interpret return value.
            //

            rc = pFinishHandshake9x();
            SetLastError (rc);

            //
            // No data buffer is coming back at this time
            //
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }

    if (rc == ERROR_NOT_INSTALLED) {
        SetLastError (ERROR_SUCCESS);
        return FALSE;
    } else if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateSystem9x with rc=%u", rc));
        return FALSE;
    }

    return TRUE;

}


BOOL
CallInitializeNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    P_INITIALIZE_NT InitializeNt;
    INT Count;
    PBYTE BufPtr;
    PDWORD ReservedBytesPtr;
    WCHAR SavedCwd [MAX_WCHAR_PATH];
    PWSTR p;
    GROWBUFFER GrowBuf = GROWBUF_INIT;




    if (!DllData->Isolated) {

        *SavedCwd = 0;
        pSetCwd (
            SavedCwd,       // old
            ARRAYSIZE(SavedCwd), 
            WorkingDir      // new
            );

        __try {
            //
            // Call the entry point directly
            //
            if (!DllData->Library) {
                DEBUGMSG ((DBG_ERROR, "InitializeNt called before Migration DLL opened."));
                return FALSE;
            }

            InitializeNt = (P_INITIALIZE_NT) GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT);
            if (!InitializeNt) {
                DEBUGMSG ((DBG_ERROR, "Could not get address for InitializeNt."));
                return FALSE;
            }

            //
            // Prepare multi-sz directory list
            //


            rc = InitializeNt (WorkingDir, SourceDirArray, Reserved);

        }
        __finally {
            if (*SavedCwd) {
                SetCurrentDirectoryW (SavedCwd);
            }
        }
    }
    else {
        __try {

            MultiSzAppendW (&GrowBuf, WorkingDir);

            //
            // Prepare multi-sz directory list
            //

            p = (PWSTR) SourceDirArray;
            while (p && *p) {
                MultiSzAppendW (&GrowBuf, p);
                p = GetEndOfStringW (p) + 1;
            }

            MultiSzAppendW (&GrowBuf, L"");

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call InitializeNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("InitializeNT"));

            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call InitializeNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }

        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }

    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {

        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in InitializeNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
}


BOOL
CallMigrateUserNt (

    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PCWSTR UserKey,
    IN      PCWSTR Win9xUserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UserProfilePath,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes

    )
{
    DWORD rc = ERROR_SUCCESS;
    P_MIGRATE_USER_NT MigrateUserNt;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    WCHAR SavedCwd [MAX_WCHAR_PATH];
    WCHAR UserBuf[MAX_USER_NAME * 3 * sizeof (WCHAR)];
    PWSTR p;
    WCHAR OrgUserProfilePath[MAX_WCHAR_PATH];
    HKEY userHandle;
    HINF unattendInf = NULL;
    UINT uiCharCount;



    if (!DllData->Isolated) {

        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateUserNt called before Migration DLL opened."));
            return FALSE;
        }

        MigrateUserNt = (P_MIGRATE_USER_NT) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT);
        if (!MigrateUserNt) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateUserNt."));
            return FALSE;
        }


        __try {

            //
            // Transfer user, user domain and fixed name to a buffer
            //
            uiCharCount = 1/*\0*/;
            uiCharCount += Win9xUserName? wcslen(Win9xUserName): 1/*\0*/;
            uiCharCount += UserDomain? wcslen(UserDomain): 1/*\0*/;
            uiCharCount += FixedUserName? wcslen(FixedUserName): 1/*\0*/;

            if(uiCharCount >= ARRAYSIZE(UserBuf)){
                MYASSERT(FALSE);
                rc = ERROR_INVALID_PARAMETER;
                __leave;
            }

            if (Win9xUserName) {
                StringCopyW (UserBuf, Win9xUserName);
            } else {
                UserBuf[0] = 0;
            }

            p = GetEndOfStringW (UserBuf) + 1;

            if (UserDomain) {
                StringCopyW (p, UserDomain);
            } else {
                p[0] = 0;
            }

            p = GetEndOfStringW (p) + 1;

            if (FixedUserName) {
                StringCopyW (p, FixedUserName);
            } else {
                p[0] = 0;
            }

            //unattendInf = SetupOpenInfFileW (UnattendFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
            MYASSERT(UserKey);
            if (!UserKey) {
                UserKey = L"";
            }

            userHandle = OpenRegKeyStrW (UserKey);
            if (!userHandle) {
                DEBUGMSG ((DBG_WHOOPS, "Cannot open %s", UserKey));
                return FALSE;
            }


            //
            // Call the entry point
            //

            rc = MigrateUserNt (
                        unattendInf,
                        userHandle,
                        UserBuf[0] ? UserBuf : NULL,
                        Reserved
                        );

            CloseRegKey (userHandle);
            //SetupCloseInfFile (unattendInf);
        }
        __finally {
           ;//empty.
        }
    } else {

        __try {
            MultiSzAppendW (&GrowBuf, UnattendFile);
            MultiSzAppendW (&GrowBuf, UserKey);
            MultiSzAppendW (&GrowBuf, Win9xUserName);
            MultiSzAppendW (&GrowBuf, UserDomain);
            MultiSzAppendW (&GrowBuf, FixedUserName);
            MultiSzAppendW (&GrowBuf, UserProfilePath);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_MIGRATEUSER,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call MigrateUserNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateUserNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateUserNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }

    SetEnvironmentVariableW (S_USERPROFILEW, OrgUserProfilePath);
    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateUserNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;


}


BOOL
CallMigrateSystemNt (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    P_MIGRATE_SYSTEM_NT MigrateSystemNt;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    HINF infHandle = NULL;


    if (!DllData->Isolated) {
        //
        // Call the entry point directly
        //
        if (!DllData->Library) {
            DEBUGMSG ((DBG_ERROR, "MigrateSystemNt called before Migration DLL opened."));
            return FALSE;
        }

        MigrateSystemNt = (P_MIGRATE_SYSTEM_NT) GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT);
        if (!MigrateSystemNt) {
            DEBUGMSG ((DBG_ERROR, "Could not get address for MigrateSystemNt."));
            return FALSE;
        }

        //infHandle = SetupOpenInfFileW (UnattendFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

        rc = MigrateSystemNt (infHandle, Reserved);

        //SetupCloseInfFile (infHandle);

    }
    else {

        __try {

            MultiSzAppendW (&GrowBuf, UnattendFile);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (IPC_MIGRATESYSTEM, GrowBuf.Buf, GrowBuf.End)) {
                LOG ((LOG_ERROR, "Call MigrateSystemNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateSystemNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateSystemNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }

    }

    SetLastError (rc);

    if (rc != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_MIGDLLS, "DLL failed in MigrateSysetmNt with rc=%u", rc));
        return FALSE;
    }

    return TRUE;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migdlls\src\miglib\miglib.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migdlls.c

Abstract:

    Library interface used to gather, store, query, and call migration dlls during an
    OS upgrade.

Author:

    Marc R. Whitten (marcw) 08-February-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "miglibp.h"



//
// Strings
//


#define PLUGIN_NEW_INITIALIZE_SRCA           "InitializeSrcA"
#define PLUGIN_NEW_GATHER_USER_SETTINGSA     "GatherUserSettingsA"
#define PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA   "GatherSystemSettingsA"
#define PLUGIN_NEW_INITIALIZE_SRCW           "InitializeSrcW"
#define PLUGIN_NEW_GATHER_USER_SETTINGSW     "GatherUserSettingsW"
#define PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW   "GatherSystemSettingsW"
#define PLUGIN_NEW_INITIALIZE_DSTW           "InitializeDstW"
#define PLUGIN_NEW_APPLY_USER_SETTINGSW      "ApplyUserSettingsW"
#define PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW    "ApplySystemSettingsW"
#define PLUGIN_NEW_INITIALIZE_DSTA           "InitializeDstA"
#define PLUGIN_NEW_APPLY_USER_SETTINGSA      "ApplyUserSettingsA"
#define PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA    "ApplySystemSettingsA"
#define PLUGIN_NEW_QUERY_MIGRATION_INFOA     "QueryMigrationInfoA"
#define PLUGIN_NEW_QUERY_MIGRATION_INFOW     "QueryMigrationInfoW"


//
// Constants
//


//
// Macros
//

// None

//
// Types
//


//
// Globals
//
POOLHANDLE g_MigLibPool;
CHAR g_MigIsolPathA[MAX_MBCHAR_PATH];
WCHAR g_MigIsolPathW[MAX_WCHAR_PATH];
HANDLE g_WinTrustLib = NULL;
WINVERIFYTRUST WinVerifyTrustProc = NULL;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//




BOOL
pTestDllA (
    OUT PMIGRATIONDLLA DllData,
    IN  BOOL SourceOs
    )
{
    BOOL valid = FALSE;


    //
    // Check to see if this is an old style Migration DLL.
    //
    if(SourceOs != SOURCEOS_WINNT){
        if (GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION) &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X)                 &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT)
            ) {

            valid = TRUE;
            DllData->OldStyle = TRUE;
            DllData->SrcUnicode = FALSE;
        }
    }
    else {
        if (GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = FALSE;
        }
        else if (GetProcAddress (DllData->Library,PLUGIN_NEW_QUERY_MIGRATION_INFOW) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = TRUE;
        }
    }


    return valid;
}


BOOL
pTestDllW (
    OUT PMIGRATIONDLLW DllData,
    IN  BOOL SourceOs
    )
{
    BOOL valid = FALSE;


    //
    // Check to see if this is an old style Migration DLL.
    //
    if(SourceOs != SOURCEOS_WINNT){
        if (GetProcAddress (DllData->Library, PLUGIN_QUERY_VERSION) &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_9X)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_9X)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_9X)                 &&
            GetProcAddress (DllData->Library, PLUGIN_INITIALIZE_NT)                     &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_USER_NT)                   &&
            GetProcAddress (DllData->Library, PLUGIN_MIGRATE_SYSTEM_NT)
            ) {

            valid = TRUE;
            DllData->OldStyle = TRUE;
            DllData->SrcUnicode = FALSE;
        }
    }
    else {
        if (GetProcAddress (DllData->Library,PLUGIN_NEW_QUERY_MIGRATION_INFOW) &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW)           &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW)     &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW)   &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW)            &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW)       &&
            GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW)
            ) {

            valid = TRUE;
            DllData->OldStyle = FALSE;
            DllData->SrcUnicode = TRUE;
        }
        else if (GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA) &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA)           &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA)     &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA)   &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA)            &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA)       &&
                GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA)
                ) {

                valid = TRUE;
                DllData->OldStyle = FALSE;
                DllData->SrcUnicode = FALSE;
        }
    }


    return valid;
}


VOID
MigDllCloseA (
    IN OUT PMIGRATIONDLLA DllData
    )
{
    MYASSERT (DllData);
    if (DllData->Library != NULL) {
        FreeLibrary (DllData->Library);
        DllData->Library = NULL;
    }
    else if (DllData->Isolated) {
        CloseIpc ();
    }
}


VOID
MigDllCloseW (
    IN OUT PMIGRATIONDLLW DllData
    )
{
    MYASSERT (DllData);
    if (DllData->Library != NULL) {
        FreeLibrary (DllData->Library);
        DllData->Library = NULL;
    }
    else if (DllData->Isolated) {
        CloseIpc ();
    }
}


BOOL
MigDllOpenW (
    OUT PMIGRATIONDLLW DllData,
    IN PCWSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    )
{

    BOOL valid = FALSE;
    PWSTR p;
    MYASSERT (DllData);

    ZeroMemory (DllData, sizeof (MIGRATIONDLL));

    if (SourceOs == SOURCEOS_WINNT && WinVerifyTrustProc) {

        //
        // See if the migration dll is signed.
        //
        if (!IsDllSignedW (WinVerifyTrustProc, DllPath)) {
            return FALSE;
        }
    }

    //
    // Fill in basic bool flags in structure.
    //
    DllData->Isolated = Isolated;
    DllData->MigrationMode = MigrationMode;
    DllData->SourceOs = SourceOs;
    DllData->SrcUnicode = TRUE; // Assume UNICODE until proven false.
    DllData->OldStyle = FALSE; // Assume new migration dll.

    if(wcslen(DllPath) >= ARRAYSIZE(DllData->Properties.DllPath)){
        MYASSERT(FALSE);
        return FALSE;
    }
    StringCopyW (DllData->Properties.DllPath, DllPath);
    p = wcsrchr (DllData->Properties.DllPath, '\\');
    if (p) {
        *p = 0;
        
        MYASSERT(ARRAYSIZE(DllData->Properties.WorkingDirectory) == ARRAYSIZE(DllData->Properties.DllPath));
        MYASSERT(ARRAYSIZE(DllData->Properties.SourceMedia) == ARRAYSIZE(DllData->Properties.DllPath));
        
        StringCopyW (DllData->Properties.WorkingDirectory, DllData->Properties.DllPath);
        StringCopyW (DllData->Properties.SourceMedia, DllData->Properties.DllPath);
        *p = '\\';
    }


    if (!Isolated) {

        DllData->Library = LoadLibraryW (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllW (DllData, SourceOs);

        if (!valid) {

            MigDllCloseW (DllData);
            DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL %s does not contain required entry points.", DllPath));
            return FALSE;
        }
    }
    else {

        //
        // Use MIGISOL for this DLL.
        //
    }

    return TRUE;




}



BOOL
MigDllOpenA (
    OUT PMIGRATIONDLLA DllData,
    IN PCSTR DllPath,
    IN BOOL MigrationMode,
    IN BOOL Isolated,
    IN BOOL SourceOs
    )
{
    BOOL valid = FALSE;
    PSTR p;

    MYASSERT (DllData);

    ZeroMemory (DllData, sizeof (MIGRATIONDLL));

    if (SourceOs == SOURCEOS_WINNT && WinVerifyTrustProc) {

        //
        // See if the migration dll is signed.
        //

        if (!IsDllSignedA (WinVerifyTrustProc, DllPath)) {
            return FALSE;
        }
    }

    //
    // Fill in basic bool flags in structure.
    //
    DllData->Isolated = Isolated;
    DllData->MigrationMode = MigrationMode;
    DllData->SourceOs = SourceOs;
    DllData->SrcUnicode = TRUE; // Assume UNICODE until proven false.
    DllData->OldStyle = FALSE; // Assume new migration dll.


    if(strlen(DllPath) >= ARRAYSIZE(DllData->Properties.DllPath)){
        MYASSERT(FALSE);
        return FALSE;
    }
    StringCopy (DllData->Properties.DllPath, DllPath);
    p = strrchr (DllData->Properties.DllPath, '\\');
    if (p) {
        *p = 0;

        MYASSERT(ARRAYSIZE(DllData->Properties.WorkingDirectory) == ARRAYSIZE(DllData->Properties.DllPath));
        MYASSERT(ARRAYSIZE(DllData->Properties.SourceMedia) == ARRAYSIZE(DllData->Properties.DllPath));

        StringCopy (DllData->Properties.WorkingDirectory, DllData->Properties.DllPath);
        StringCopy (DllData->Properties.SourceMedia, DllData->Properties.DllPath);
        *p = '\\';
    }

    if (!Isolated) {

        DllData->Library = LoadLibraryA (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllA (DllData, SourceOs);

        if (!valid) {

            MigDllClose (DllData);
            DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL %s does not contain required entry points.", DllPath));
            return FALSE;
        }



    }
    else {

        //
        // Still need to test the dll to gather basic state. Open and close.
        //
        DllData->Library = LoadLibraryA (DllPath);
        if (!DllData->Library) {
            return FALSE;
        }

        //
        //  See if this dll contains required entry points and test for various state (old style, srcunicode, etc.)
        //
        valid = pTestDllA (DllData, SourceOs);




        MigDllClose (DllData);
        DllData->Library = NULL;

        if (!valid) {
            return FALSE;
        }


        if (!OpenIpcA (
                MigrationMode == GATHERMODE ? TRUE : FALSE,
                g_MigIsolPathA,
                DllPath,
                DllData->Properties.WorkingDirectory
                )) {

            LOG ((
                LOG_WARNING,
                "Can't establish IPC connection for %s",
                DllPath
                ));

            return FALSE;
        }
    }

    return TRUE;
}


BOOL
MigDllInitializeSrcA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDir,
    IN PCSTR NativeSource,
    IN PCSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_SRC_A InitializeSrc;
    CHAR WorkingDirCopy[MAX_PATH];
    CHAR MediaDirCopy [MAX_PATH];
    PSTR SourceListCopy = NULL;
    BOOL success = FALSE;
    DWORD rc;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectory (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        if(strlen(WorkingDir) >= ARRAYSIZE(WorkingDirCopy) || 
           strlen(MediaDir) >= ARRAYSIZE(MediaDirCopy)){
            return FALSE;
        }
        StringCopyA (WorkingDirCopy, WorkingDir);
        StringCopyA (MediaDirCopy, MediaDir);
        SourceListCopy = DuplicateTextA (NativeSource);
        MYASSERT(SourceListCopy);

        __try {

            if (DllData->OldStyle) {
                success = CallInitialize9x (DllData, WorkingDirCopy, SourceListCopy, (PVOID) MediaDirCopy, SizeOfString (MediaDirCopy));
            }
            else {
                if (!DllData->Library) {
                    DEBUGMSGA ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                InitializeSrc = (P_INITIALIZE_SRC_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA);
                if (!InitializeSrc) {
                    DEBUGMSGA ((DBG_ERROR, "Could not get address for InitializeSrc."));
                    return FALSE;
                }

                rc = InitializeSrc (WorkingDirCopy, SourceListCopy, MediaDirCopy, Reserved);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }

        }
        __finally {
            if(SourceListCopy){
                FreeText (SourceListCopy);
            }
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallInitialize9x (DllData, WorkingDir, NativeSource, (PVOID) MediaDir, SizeOfString (MediaDir));
        }
    }

    return success;
}

BOOL
MigDllInitializeSrcW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN PCWSTR MediaDir,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_SRC_W InitializeSrcW;
    P_INITIALIZE_SRC_A InitializeSrcA;
    WCHAR WorkingDirCopy[MAX_WCHAR_PATH];
    WCHAR MediaDirCopy [MAX_WCHAR_PATH];
    PWSTR SourceListCopy = NULL;
    BOOL success = FALSE;
    DWORD rc;
    PCSTR ansiWorkingDir;
    PCSTR ansiSourceList;
    PCSTR ansiMediaDir;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectoryW (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        if(wcslen(WorkingDir) >= ARRAYSIZE(WorkingDirCopy) || 
           wcslen(MediaDir) >= ARRAYSIZE(MediaDirCopy)){
            return FALSE;
        }
        StringCopyW (WorkingDirCopy, WorkingDir);
        StringCopyW (MediaDirCopy, MediaDir);
        SourceListCopy = DuplicateTextW (NativeSource);
        MYASSERT(SourceListCopy);

        __try {

            if (DllData->OldStyle) {
                return FALSE;
            }
            else {
                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    InitializeSrcW = (P_INITIALIZE_SRC_W) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCW);
                    if (!InitializeSrcW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    __try {
                        rc = InitializeSrcW (WorkingDirCopy, SourceListCopy, MediaDirCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_SRCW
                            ));
                        rc = ERROR_NOT_INSTALLED;
                    }
                }
                else {

                    InitializeSrcA = (P_INITIALIZE_SRC_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_SRCA);
                    if (!InitializeSrcA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    ansiWorkingDir = ConvertWtoA (WorkingDirCopy);
                    ansiSourceList = ConvertWtoA (SourceListCopy);
                    ansiMediaDir = ConvertWtoA (MediaDirCopy);

                    __try {
                        rc = InitializeSrcA (ansiWorkingDir, ansiSourceList, ansiMediaDir, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_SRCA
                            ));
                        rc = ERROR_NOT_INSTALLED;
                    }

                    FreeConvertedStr (ansiWorkingDir);
                    FreeConvertedStr (ansiSourceList);
                    FreeConvertedStr (ansiMediaDir);
                }

                if (rc == ERROR_SUCCESS) {
                    success = TRUE;
                }
                else if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {
            if(SourceListCopy){
                FreeTextW (SourceListCopy);
            }
        }
    }

    return success;
}





BOOL
MigDllGatherUserSettingsA (
    IN      PMIGRATIONDLLA DllData,
    IN      PCSTR UserKey,
    IN      PCSTR UserName,
    IN      PCSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    CHAR userNameBuf[MAX_USER_NAME];
    PSTR userNameCopy = NULL;
    CHAR unattendTxtCopy[MAX_USER_NAME];
    HKEY userHandle = NULL;
    P_GATHER_USER_SETTINGS_A GatherUserSettings;
    DWORD rc;
    BOOL success = FALSE;

    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            if(strlen(UserName) >= ARRAYSIZE(userNameBuf)){
                return FALSE;
            }
            StringCopyA (userNameCopy, UserName);
        }

        if(strlen(UnattendTxt) >= ARRAYSIZE(unattendTxtCopy)){
            return FALSE;
        }
        StringCopyA (unattendTxtCopy, UnattendTxt);

        MYASSERT(UserKey);
        if (!UserKey) {
            UserKey = "";
        }

        userHandle = OpenRegKeyStr (UserKey);
        if (!userHandle) {
            DEBUGMSGA ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        __try {

            //
            // Pass oldstyle migration dlls off to the appropriate function.
            //
            if (DllData->OldStyle) {

                success = CallMigrateUser9x (DllData, UserKey, userNameCopy, unattendTxtCopy, Reserved, ReservedSize);
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGA ((DBG_ERROR, "GatherUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                GatherUserSettings = (P_GATHER_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA);
                if (!GatherUserSettings) {
                    DEBUGMSGA ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                    return FALSE;
                }

                rc = GatherUserSettings (unattendTxtCopy, userHandle, userNameCopy, Reserved);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {
            if(!userHandle){
                CloseRegKey (userHandle);
            }
        }
    }
    else {

        if (DllData->OldStyle) {

            success = CallMigrateUser9x (DllData, UserKey, UserName, UnattendTxt, Reserved, ReservedSize);
        }
    }

    return TRUE;
}

BOOL
MigDllGatherUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UnattendTxt,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    WCHAR userNameBuf[MAX_USER_NAME];
    PWSTR userNameCopy = NULL;
    WCHAR unattendTxtCopy[MAX_USER_NAME];
    HKEY userHandle = NULL;
    P_GATHER_USER_SETTINGS_W GatherUserSettingsW;
    P_GATHER_USER_SETTINGS_A GatherUserSettingsA;
    DWORD rc;
    BOOL success = FALSE;
    PCSTR ansiUserName;
    PCSTR ansiUnattendTxt;

    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            if(wcslen(UserName) >= ARRAYSIZE(userNameBuf)){
                return FALSE;
            }
            StringCopyW (userNameCopy, UserName);
        }

        if(wcslen(UnattendTxt) >= ARRAYSIZE(unattendTxtCopy)){
            return FALSE;
        }
        StringCopyW (unattendTxtCopy, UnattendTxt);

        MYASSERT(UserKey);
        if (!UserKey) {
            UserKey = L"";
        }

        userHandle = OpenRegKeyStrW (UserKey);
        if (!userHandle) {
            DEBUGMSGW ((DBG_WHOOPS, "Cannot open %s", UserKey));
            return FALSE;
        }

        __try {

            //
            // Pass oldstyle migration dlls off to the appropriate function.
            //
            if (DllData->OldStyle) {

                return FALSE;
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "GatherUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    GatherUserSettingsW = (P_GATHER_USER_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSW);
                    if (!GatherUserSettingsW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                        return FALSE;
                    }

                    __try {
                        rc = GatherUserSettingsW (unattendTxtCopy, userHandle, userNameCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_GATHER_USER_SETTINGSW
                            ));
                    }
                }
                else {

                    GatherUserSettingsA = (P_GATHER_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_USER_SETTINGSA);
                    if (!GatherUserSettingsA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherUserSettings."));
                        return FALSE;
                    }

                    ansiUnattendTxt = ConvertWtoA (unattendTxtCopy);
                    ansiUserName = ConvertWtoA (userNameCopy);

                    __try {
                        rc = GatherUserSettingsA (ansiUnattendTxt, userHandle, ansiUserName, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_GATHER_USER_SETTINGSA
                            ));
                    }

                    FreeConvertedStr (ansiUnattendTxt);
                    FreeConvertedStr (ansiUserName);
                }

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                    SetLastError (rc);
                }
            }
        }
        __finally {
            if(!userHandle){
                CloseRegKey (userHandle);
            }
        }
    }

    return TRUE;
}



BOOL
MigDllGatherSystemSettingsA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    CHAR answerFileCopy [MAX_PATH];
    P_GATHER_SYSTEM_SETTINGS_A GatherSystemSettings;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        if(strlen(AnswerFile) >= ARRAYSIZE(answerFileCopy)){
            return FALSE;
        }
        StringCopyA (answerFileCopy, AnswerFile);

        if (DllData->OldStyle) {
            success = CallMigrateSystem9x (DllData, answerFileCopy, Reserved, ReservedSize);
        }
        else {

            if (!DllData->Library) {
                DEBUGMSGA ((DBG_ERROR, "GatherSystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            GatherSystemSettings = (P_GATHER_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA);
            if (!GatherSystemSettings) {
                DEBUGMSGA ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                return FALSE;
            }

            rc = GatherSystemSettings (answerFileCopy, Reserved);

            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
                SetLastError (rc);
            }
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallMigrateSystem9x (DllData, AnswerFile, Reserved, ReservedSize);
        }
    }

    return success;
}


BOOL
MigDllGatherSystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    WCHAR answerFileCopy [MAX_WCHAR_PATH];
    P_GATHER_SYSTEM_SETTINGS_W GatherSystemSettingsW;
    P_GATHER_SYSTEM_SETTINGS_A GatherSystemSettingsA;
    PCSTR ansiAnswerFile;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        if(wcslen(AnswerFile) >= ARRAYSIZE(answerFileCopy)){
            return FALSE;
        }
        StringCopyW (answerFileCopy, AnswerFile);

        if (DllData->OldStyle) {
            return FALSE;
        }
        else {

            if (!DllData->Library) {
                DEBUGMSGW ((DBG_ERROR, "GatherSystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            if (DllData->SrcUnicode) {

                GatherSystemSettingsW = (P_GATHER_SYSTEM_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW);
                if (!GatherSystemSettingsW) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                    return FALSE;
                }

                __try {
                    rc = GatherSystemSettingsW (answerFileCopy, Reserved);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DEBUGMSGW ((
                        DBG_MIGDLLS,
                        "Migration DLL %s threw an exception in %hs",
                        DllData->Properties.DllPath,
                        PLUGIN_NEW_GATHER_SYSTEM_SETTINGSW
                        ));
                    rc = ERROR_NOT_INSTALLED;
                }
            }
            else {

                GatherSystemSettingsA = (P_GATHER_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA);
                if (!GatherSystemSettingsA) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for GatherSystemSettings."));
                    return FALSE;
                }

                ansiAnswerFile = ConvertWtoA (answerFileCopy);

                __try {
                    rc = GatherSystemSettingsA (ansiAnswerFile, Reserved);
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    DEBUGMSGW ((
                        DBG_MIGDLLS,
                        "Migration DLL %s threw an exception in %hs",
                        DllData->Properties.DllPath,
                        PLUGIN_NEW_GATHER_SYSTEM_SETTINGSA
                        ));
                    rc = ERROR_NOT_INSTALLED;
                }

                FreeConvertedStr (ansiAnswerFile);
            }

            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
                SetLastError (rc);
            }
        }
    }

    return success;
}



BOOL
MigDllInitializeDstW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDir,
    IN PCWSTR NativeSource,
    IN OUT PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    P_INITIALIZE_DST_W InitializeDstW;
    P_INITIALIZE_DST_A InitializeDstA;
    WCHAR WorkingDirCopy[MAX_WCHAR_PATH];
    PCWSTR p;
    PWSTR SourceListCopy;
    BOOL success = FALSE;
    DWORD rc;
    PCSTR ansiWorkingDir;
    PCSTR ansiSourceList;



    MYASSERT (DllData);
    MYASSERT (WorkingDir);
    MYASSERT (NativeSource);

    if (!DllData->Isolated) {

        SetCurrentDirectoryW (WorkingDir);

        //
        // Make copies of all the args so malicious dlls can't modify the strings.
        //

        if(wcslen(WorkingDir) >= ARRAYSIZE(WorkingDirCopy)){
            return FALSE;
        }
        StringCopyW (WorkingDirCopy, WorkingDir);

        p = NativeSource;
        while (*p) {
            p = GetEndOfStringW (p) + 1;
        }
        p++;

        SourceListCopy = AllocTextW ((UINT)(p - NativeSource));
        if (SourceListCopy) {
            CopyMemory (SourceListCopy, NativeSource, (p - NativeSource) * sizeof (WCHAR));
        }

        __try {

            if (DllData->OldStyle) {

                success = CallInitializeNt (DllData, WorkingDirCopy, SourceListCopy, Reserved, ReservedSize);
            }
            else {

                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "InitializeSrc called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    InitializeDstW = (P_INITIALIZE_DST_W) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTW);
                    if (!InitializeDstW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }

                    __try {
                        rc = InitializeDstW (WorkingDirCopy, SourceListCopy, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_DSTW
                            ));
                    }
                }
                else {

                    InitializeDstA = (P_INITIALIZE_DST_A) GetProcAddress (DllData->Library, PLUGIN_NEW_INITIALIZE_DSTA);
                    if (!InitializeDstA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for InitializeSrc."));
                        return FALSE;
                    }


                    ansiWorkingDir = ConvertWtoA (WorkingDirCopy);
                    ansiSourceList = ConvertWtoA (SourceListCopy);

                    __try {
                        rc = InitializeDstA (ansiWorkingDir, ansiSourceList, Reserved);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        DEBUGMSGW ((
                            DBG_MIGDLLS,
                            "Migration DLL %s threw an exception in %hs",
                            DllData->Properties.DllPath,
                            PLUGIN_NEW_INITIALIZE_DSTA
                            ));
                    }

                    FreeConvertedStr (ansiWorkingDir);
                    FreeConvertedStr (ansiSourceList);

                }

                SetLastError (rc);

                if (rc != ERROR_SUCCESS) {
                    success = FALSE;
                }
            }
        }
        __finally {
            if(SourceListCopy){
                FreeTextW (SourceListCopy);
            }
        }
    }
    else {

        if (DllData->OldStyle) {

            success = CallInitializeNt (DllData, WorkingDir, NativeSource, Reserved, ReservedSize);
        }
    }


    return success;
}

BOOL
MigDllApplyUserSettingsW (
    IN      PMIGRATIONDLLW DllData,
    IN      PCWSTR WorkingDir,
    IN      PCWSTR UserKey,
    IN      PCWSTR UserName,
    IN      PCWSTR UserDomain,
    IN      PCWSTR FixedUserName,
    IN      PCWSTR UnattendTxt,
    IN      PCWSTR UserProfilePath,
    IN OUT  PVOID Reserved,
    IN      DWORD ReservedSize

    )
{
    WCHAR userNameBuf[MAX_USER_NAME];
    WCHAR fixedUserNameBuf[MAX_USER_NAME];
    WCHAR userDomainBuf[MAX_WCHAR_PATH];
    WCHAR orgUserProfilePath[MAX_WCHAR_PATH];
    PWSTR userDomainCopy = NULL;
    PWSTR userNameCopy = NULL;
    PWSTR fixedUserNameCopy = NULL;
    HINF unattendInf = NULL;
    HKEY userHandle = NULL;
    P_APPLY_USER_SETTINGS_W ApplyUserSettingsW;
    P_APPLY_USER_SETTINGS_A ApplyUserSettingsA;
    DWORD rc;
    BOOL success = FALSE;
    PCSTR ansiUserName;
    PCSTR ansiUserDomainName;
    PCSTR ansiFixedUserName;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //

        if (UserName && *UserName) {
            userNameCopy = userNameBuf;
            if(wcslen(UserName) >= ARRAYSIZE(userNameBuf)){
                return FALSE;
            }
            StringCopyW (userNameCopy, UserName);
        }


        if (FixedUserName && *FixedUserName) {
            fixedUserNameCopy = fixedUserNameBuf;
            if(wcslen(FixedUserName) >= ARRAYSIZE(fixedUserNameCopy)){
                return FALSE;
            }
            StringCopyW (fixedUserNameCopy, FixedUserName);
        }

        if (UserDomain && *UserDomain) {
            userDomainCopy = userDomainBuf;
            if(wcslen(UserDomain) >= ARRAYSIZE(userDomainCopy)){
                return FALSE;
            }
            StringCopyW (userDomainCopy, UserDomain);
        }




        //
        // Pass oldstyle migration dlls off to the appropriate function.
        //
        if (DllData->OldStyle) {

            success = CallMigrateUserNt (
                            DllData,
                            UnattendTxt,
                            UserKey,
                            userNameCopy,
                            userDomainCopy,
                            fixedUserNameCopy,
                            UserProfilePath,
                            Reserved,
                            ReservedSize
                            );
        }
        else {


            MYASSERT(UserKey);
            if (!UserKey) {
                UserKey = L"";
            }

            userHandle = OpenRegKeyStrW (UserKey);
            if (!userHandle) {
                DEBUGMSGW ((DBG_WHOOPS, "Cannot open %s", UserKey));
                return FALSE;
            }

            __try {

                GetEnvironmentVariableW (S_USERPROFILEW, orgUserProfilePath, MAX_WCHAR_PATH);
                SetEnvironmentVariableW (S_USERPROFILEW, UserProfilePath);
                SetCurrentDirectoryW (WorkingDir);


                if (!DllData->Library) {
                    DEBUGMSGW ((DBG_ERROR, "ApplyUserSettings called before Migration DLL opened."));
                    return FALSE;
                }

                if (DllData->SrcUnicode) {

                    ApplyUserSettingsW = (P_APPLY_USER_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSW);
                    if (!ApplyUserSettingsW) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplyUserSettings."));
                        return FALSE;
                    }


                    rc = ApplyUserSettingsW (
                            unattendInf,
                            userHandle,
                            userNameCopy,
                            userDomainCopy,
                            fixedUserNameCopy,
                            Reserved
                            );
                }
                else {


                    ApplyUserSettingsA = (P_APPLY_USER_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_USER_SETTINGSA);
                    if (!ApplyUserSettingsA) {
                        DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplyUserSettings."));
                        return FALSE;
                    }

                    ansiUserName = ConvertWtoA (userNameCopy);
                    ansiUserDomainName = ConvertWtoA (userDomainCopy);
                    ansiFixedUserName = ConvertWtoA (fixedUserNameCopy);

                    rc = ApplyUserSettingsA (
                            unattendInf,
                            userHandle,
                            ansiUserName,
                            ansiUserDomainName,
                            ansiFixedUserName,
                            Reserved
                            );

                    FreeConvertedStr (ansiUserName);
                    FreeConvertedStr (ansiUserDomainName);
                    FreeConvertedStr (ansiFixedUserName);



                }

                SetLastError (rc);

                if (rc == ERROR_NOT_INSTALLED) {
                    success = FALSE;
                    SetLastError (ERROR_SUCCESS);
                }
                else if (rc != ERROR_SUCCESS) {
                    success = FALSE;

                }

                SetEnvironmentVariableW (S_USERPROFILEW, orgUserProfilePath);

            }
            __finally {
                if(userHandle){
                    CloseRegKey (userHandle);
                }
            }
        }
    }
    else {
        if (DllData->OldStyle) {

            success = CallMigrateUserNt (
                            DllData,
                            UnattendTxt,
                            UserKey,
                            UserName,
                            UserDomain,
                            FixedUserName,
                            UserProfilePath,
                            Reserved,
                            ReservedSize
                            );
        }

    }


    return TRUE;
}


BOOL
MigDllApplySystemSettingsW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    IN PCWSTR AnswerFile,
    IN PVOID Reserved,
    IN DWORD ReservedSize
    )
{
    DWORD rc;
    BOOL success = TRUE;
    HINF infHandle = NULL;
    P_APPLY_SYSTEM_SETTINGS_W ApplySystemSettingsW;
    P_APPLY_SYSTEM_SETTINGS_A ApplySystemSettingsA;


    if (!DllData->Isolated) {

        //
        // Prepare copies of the args.
        //
        SetCurrentDirectoryW (WorkingDirectory);


        if (DllData->OldStyle) {
            success = CallMigrateSystemNt (DllData, AnswerFile, Reserved, ReservedSize);
        }
        else {

            //infHandle = SetupOpenInfFileW (AnswerFile, NULL,  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

            if (!DllData->Library) {
                DEBUGMSGW ((DBG_ERROR, "ApplySystemSettings called before Migration DLL opened."));
                return FALSE;
            }

            if (DllData->SrcUnicode) {

                ApplySystemSettingsW = (P_APPLY_SYSTEM_SETTINGS_W) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSW);
                if (!ApplySystemSettingsW) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplySystemSettings."));
                    return FALSE;
                }

                rc = ApplySystemSettingsW (infHandle, Reserved);

            }
            else {

                ApplySystemSettingsA = (P_APPLY_SYSTEM_SETTINGS_A) GetProcAddress (DllData->Library, PLUGIN_NEW_APPLY_SYSTEM_SETTINGSA);
                if (!ApplySystemSettingsA) {
                    DEBUGMSGW ((DBG_ERROR, "Could not get address for ApplySystemSettings."));
                    return FALSE;
                }

                rc = ApplySystemSettingsA (infHandle, Reserved);
            }

            SetLastError (rc);
            if (rc == ERROR_NOT_INSTALLED) {
                success = FALSE;
                SetLastError (ERROR_SUCCESS);
            }
            else if (rc != ERROR_SUCCESS) {
                success = FALSE;
            }

            //SetupCloseInfFile (infHandle);
        }
    }
    else {

        if (DllData->OldStyle) {
            success = CallMigrateSystemNt (DllData, AnswerFile, Reserved, ReservedSize);
        }
    }

    return success;
}



BOOL
MigDllQueryMigrationInfoA (
    IN PMIGRATIONDLLA DllData,
    IN PCSTR WorkingDirectory,
    OUT PMIGRATIONINFOA * MigInfo
    )
{

    BOOL success = TRUE;
    DWORD rc = ERROR_NOT_INSTALLED;
    P_QUERY_MIGRATION_INFO_A QueryMigrationInfo;
    PMIGRATIONINFOA AMigInfo;

    MYASSERT (DllData);
    MYASSERT (WorkingDirectory);
    MYASSERT (MigInfo);


    //
    // Validate parameters.
    //
    if (!DllData || !WorkingDirectory || !MigInfo) {
        return FALSE;
    }

    if (DllData->OldStyle) {
        //
        // Windows 2000 style migration DLL, pass this off to the correct function.
        //

        AMigInfo = MemAllocZeroed (sizeof (MIGRATIONINFOA));
        AMigInfo->Size = sizeof (MIGRATIONINFOA);
        *MigInfo = AMigInfo;


        success =  CallQueryVersion (DllData, WorkingDirectory, AMigInfo);
        rc = GetLastError ();
        if (rc == ERROR_NOT_INSTALLED) {
            success = TRUE;
        }

    }
    else if (!DllData->Isolated) {

        if (!DllData->Library) {
            DEBUGMSGA ((DBG_ERROR, "QueryMigrationInfo called before Migration DLL opened."));
            return FALSE;
        }

        QueryMigrationInfo = (P_QUERY_MIGRATION_INFO_A) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA);
        if (!QueryMigrationInfo) {
            DEBUGMSGA ((DBG_ERROR, "Could not get address for QueryMigrationInfo."));
            return FALSE;
        }

        //
        // Call the function.
        //
        rc = QueryMigrationInfo (MigInfo);

    } else {
        //
        // running in isolated mode not implemented; should never get here
        //
        MYASSERT (FALSE);
    }

    if (rc == ERROR_SUCCESS) {

        success = TRUE;


        //
        // Trim whitespace off of product ID
        //

        if (ValidateNonNullStringA ((*MigInfo)->StaticProductIdentifier)) {
            (*MigInfo)->StaticProductIdentifier = SkipSpace ((*MigInfo)->StaticProductIdentifier);
            if (ValidateBinary ((PBYTE) ((*MigInfo)->StaticProductIdentifier), SizeOfStringA ((*MigInfo)->StaticProductIdentifier), FALSE)) {
                TruncateTrailingSpace ((PSTR) ((*MigInfo)->StaticProductIdentifier));
            }
        }

        //
        // Validate inbound parameters
        //

        if (!ValidateNonNullStringA ((*MigInfo)->StaticProductIdentifier) ||
            !ValidateIntArray ((*MigInfo)->CodePageArray) ||
            !ValidateBinary ((PBYTE) ((*MigInfo)->VendorInfo), sizeof (VENDORINFO), FALSE)
            ) {
            LOG ((LOG_ERROR, "One or more parameters from the DLL are invalid."));
            return FALSE;
        }

        if (!IsCodePageArrayValid ((*MigInfo)->CodePageArray)) {
            return FALSE;
        }

        //
        // Trim the product ID
        //

        if (ByteCountA ((*MigInfo)->StaticProductIdentifier) >= MAX_PATH) {
            ((PSTR) ((*MigInfo)->StaticProductIdentifier)) [MAX_PATH - 1] = 0;
        }

        //
        // Make sure VENDORINFO is valid
        //
        if (!((*MigInfo)->VendorInfo)) {
            LOG ((LOG_ERROR, "DLL %s did not provide a VENDORINFO struct", (*MigInfo)->StaticProductIdentifier));
            return FALSE;
        }

        //
        // Copy in data to DllData structure.
        //
        MYASSERT(sizeof(DllData->Properties.Info) >= sizeof(MIGRATIONINFOA));
        CopyMemory (&DllData->Properties.Info, *MigInfo, sizeof(MIGRATIONINFOA));

        if ((*MigInfo)->StaticProductIdentifier) {
            DllData->Properties.Info.StaticProductIdentifier = (PCSTR) PoolMemDuplicateStringA (g_MigLibPool, (*MigInfo)->StaticProductIdentifier);
        }

        if ((*MigInfo)->VendorInfo) {
            DllData->Properties.Info.VendorInfo = PoolMemGetAlignedMemory (g_MigLibPool, sizeof (VENDORINFO));
            CopyMemory (DllData->Properties.Info.VendorInfo, (*MigInfo)->VendorInfo, sizeof (VENDORINFO));
        }

    }
    else if (rc != ERROR_NOT_INSTALLED) {
        DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL returned rc = %u", rc));
    }

    return success;
}



BOOL
MigDllQueryMigrationInfoW (
    IN PMIGRATIONDLLW DllData,
    IN PCWSTR WorkingDirectory,
    OUT PMIGRATIONINFOW * MigInfo
    )
{

    BOOL success = FALSE;
    DWORD rc = ERROR_NOT_INSTALLED;
    P_QUERY_MIGRATION_INFO_W QueryMigrationInfoW;
    P_QUERY_MIGRATION_INFO_A QueryMigrationInfoA;
    PMIGRATIONINFOA ansiMigInfo;
    PMIGRATIONINFOW unicodeMigInfo;



    //
    // Validate parameters.
    //
    if (!DllData || !WorkingDirectory || !MigInfo) {
        return FALSE;
    }

    if (DllData->OldStyle) {

        return FALSE;

    }
    else if (!DllData->Isolated) {

        if (!DllData->Library) {
            return FALSE;
        }

        if (DllData->SrcUnicode) {

            QueryMigrationInfoW = (P_QUERY_MIGRATION_INFO_W) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOW);
            if (!QueryMigrationInfoW) {
                return FALSE;
            }

            //
            // Call the function.
            //
            __try {
                rc = QueryMigrationInfoW (MigInfo);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGW ((
                    DBG_MIGDLLS,
                    "Migration DLL %s threw an exception in %s",
                    DllData->Properties.DllPath,
                    PLUGIN_NEW_QUERY_MIGRATION_INFOW
                    ));
                rc = ERROR_NOT_INSTALLED;
            }


        }
        else {

            QueryMigrationInfoA = (P_QUERY_MIGRATION_INFO_A) GetProcAddress (DllData->Library, PLUGIN_NEW_QUERY_MIGRATION_INFOA);
            if (!QueryMigrationInfoA) {
                return FALSE;
            }



            //
            // Call the function.
            //
            __try {
                rc = QueryMigrationInfoA (&ansiMigInfo);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGA ((
                    DBG_MIGDLLS,
                    "Migration DLL %s threw an exception in %s",
                    DllData->Properties.DllPath,
                    PLUGIN_NEW_QUERY_MIGRATION_INFOA
                    ));
                rc = ERROR_NOT_INSTALLED;
            }

            __try {
                //
                // convert miginfo over.
                //
                unicodeMigInfo = MemAllocZeroed (sizeof (MIGRATIONINFOW));
                unicodeMigInfo->Size = sizeof (MIGRATIONINFOW);


                if (ValidateNonNullStringA (ansiMigInfo->StaticProductIdentifier)) {
                    unicodeMigInfo->StaticProductIdentifier = ConvertAtoW (ansiMigInfo->StaticProductIdentifier);
                }

                unicodeMigInfo->DllVersion = ansiMigInfo->DllVersion;
                unicodeMigInfo->CodePageArray = ansiMigInfo->CodePageArray;
                unicodeMigInfo->SourceOs = ansiMigInfo->SourceOs;
                unicodeMigInfo->TargetOs = ansiMigInfo->TargetOs;
                unicodeMigInfo->VendorInfo = ansiMigInfo->VendorInfo;

                *MigInfo = unicodeMigInfo;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                DEBUGMSGA ((
                    DBG_MIGDLLS,
                    "MigDllQueryMigrationInfoW: exception while converting data from %s",
                    DllData->Properties.DllPath
                    ));
                rc = ERROR_NOT_INSTALLED;
            }

        }
    } else {
        //
        // running in isolated mode not implemented; should never get here
        //
        MYASSERT (FALSE);
    }

    if (rc == ERROR_SUCCESS) {

        success = TRUE;


        //
        // Trim whitespace off of product ID
        //

        if (ValidateNonNullStringW ((*MigInfo)->StaticProductIdentifier)) {
            (*MigInfo)->StaticProductIdentifier = SkipSpaceW ((*MigInfo)->StaticProductIdentifier);
            if (ValidateBinary ((PBYTE) ((*MigInfo)->StaticProductIdentifier), SizeOfStringW ((*MigInfo)->StaticProductIdentifier), FALSE)) {
                TruncateTrailingSpaceW ((PWSTR) ((*MigInfo)->StaticProductIdentifier));
            }
        }

        //
        // Validate inbound parameters
        //

        if (!ValidateNonNullStringW ((*MigInfo)->StaticProductIdentifier) ||
            !ValidateIntArray ((*MigInfo)->CodePageArray) ||
            !ValidateBinary ((PBYTE) ((*MigInfo)->VendorInfo), sizeof (VENDORINFO), FALSE)
            ) {
            LOG ((LOG_ERROR, "One or more parameters from the DLL are invalid."));
            return FALSE;
        }

        if (!IsCodePageArrayValid ((*MigInfo)->CodePageArray)) {
            return FALSE;
        }

        //
        // Trim the product ID
        //

        if (TcharCountW ((*MigInfo)->StaticProductIdentifier) >= MAX_PATH) {
            ((PWSTR) ((*MigInfo)->StaticProductIdentifier)) [MAX_PATH - 1] = 0;
        }

        //
        // Make sure VENDORINFO is valid
        //
        if (!((*MigInfo)->VendorInfo)) {
            LOG ((LOG_ERROR, "DLL %s did not provide a VENDORINFO struct", (*MigInfo)->StaticProductIdentifier));
            return FALSE;
        }

        //
        // Copy in data to DllData structure.
        //
        MYASSERT(sizeof(DllData->Properties.Info) >= sizeof(MIGRATIONINFOW));
        CopyMemory (&DllData->Properties.Info, *MigInfo, sizeof (MIGRATIONINFOW));

        if ((*MigInfo)->StaticProductIdentifier) {
            DllData->Properties.Info.StaticProductIdentifier = (PCWSTR) PoolMemDuplicateStringW (g_MigLibPool, (*MigInfo)->StaticProductIdentifier);
        }

        if ((*MigInfo)->VendorInfo) {
            DllData->Properties.Info.VendorInfo = PoolMemGetAlignedMemory (g_MigLibPool, sizeof (VENDORINFO));
            CopyMemory (DllData->Properties.Info.VendorInfo, (*MigInfo)->VendorInfo, sizeof (VENDORINFO));
        }

    }
    else if (rc != ERROR_NOT_INSTALLED) {
        DEBUGMSGA ((DBG_MIGDLLS, "Migration DLL returned rc = %u", rc));
    }


    return success;
}


BOOL
MigDllEnumNextA (
    IN OUT PMIGDLLENUMA Enum
    )
{
    if(!Enum){
        return FALSE;
    }

    Enum->Properties = (PMIGDLLPROPERTIESA) GrowListGetItem ((PGROWLIST) Enum->List, Enum->NextItem);
    Enum->NextItem++;

    return Enum->Properties != NULL;
}


BOOL
MigDllEnumNextW (
    IN OUT PMIGDLLENUMW Enum
    )
{
    if(!Enum){
        return FALSE;
    }

    if (GrowListGetSize ((PGROWLIST) Enum->List) == 0) {
        return FALSE;
    }

    Enum->Properties = (PMIGDLLPROPERTIESW) GrowListGetItem ((PGROWLIST) Enum->List, Enum->NextItem);
    Enum->NextItem++;



    return Enum->Properties != NULL;
}



BOOL
MigDllEnumFirstA (
    OUT PMIGDLLENUMA Enum,
    IN DLLLIST List
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    if (!List || !Enum) {
        return FALSE;
    }

    ZeroMemory (Enum, sizeof(MIGDLLENUMA));

    Enum->NextItem = 0;
    Enum->List = List;

    return MigDllEnumNextA (Enum);
}

BOOL
MigDllEnumFirstW (
    OUT PMIGDLLENUMW Enum,
    IN DLLLIST List
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    if (!List || !Enum) {
        return FALSE;
    }

    ZeroMemory (Enum, sizeof(MIGDLLENUMW));

    Enum->NextItem = 0;
    Enum->List = List;

    return MigDllEnumNextW (Enum);
}



DLLLIST
MigDllCreateList (
    VOID
    )
{
    PGROWLIST newList;

    newList = (PGROWLIST) MemAllocZeroed (sizeof (GROWLIST));

    return (DLLLIST) newList;
}


VOID
MigDllFreeList (
    DLLLIST List
    )
{
    if (List) {

        FreeGrowList ((PGROWLIST) List);
        FreeMem (List);
    }
}


BOOL
MigDllAddDllToListA (
    IN DLLLIST List,
    IN PMIGRATIONDLLA MigrationDll
    )
{

    MYASSERT (List);
    MYASSERT (MigrationDll);

    if (!List || !MigrationDll) {
        return FALSE;
    }

    GrowListAppend ((PGROWLIST) List, (PBYTE) &MigrationDll->Properties, sizeof (MIGDLLPROPERTIESA));

    return TRUE;
}


BOOL
MigDllAddDllToListW (
    IN DLLLIST List,
    IN PMIGRATIONDLLW MigrationDll
    )
{

    MYASSERT (List);
    MYASSERT (MigrationDll);

    if (!List || !MigrationDll) {
        return FALSE;
    }

    GrowListAppend ((PGROWLIST) List, (PBYTE) &MigrationDll->Properties, sizeof (MIGDLLPROPERTIESW));

    return TRUE;
}



BOOL
MigDllRemoveDllFromListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    )
{


    int i;
    int size;
    PMIGDLLPROPERTIESA item;

    MYASSERT (ProductId);
    MYASSERT (List);

    if (!List || !ProductId) {
        return FALSE;
    }

    size = GrowListGetSize ((PGROWLIST) List);

    for (i = 0; i < size; i++) {

        item = (PMIGDLLPROPERTIESA) GrowListGetItem ((PGROWLIST) List, i);
        if (StringIMatchA (item->Info.StaticProductIdentifier, ProductId)) {
            GrowListDeleteItem ((PGROWLIST) List, i);
            return TRUE;
        }
    }

    return TRUE;

}

BOOL
MigDllRemoveDllFromListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    )
{


    int i;
    int size;
    PMIGDLLPROPERTIESW item;

    MYASSERT (ProductId);
    MYASSERT (List);

    if (!List || !ProductId) {
        return FALSE;
    }

    size = GrowListGetSize ((PGROWLIST) List);

    for (i = 0; i < size; i++) {

        item = (PMIGDLLPROPERTIESW) GrowListGetItem ((PGROWLIST) List, i);
        if (StringIMatchW (item->Info.StaticProductIdentifier, ProductId)) {
            GrowListDeleteItem ((PGROWLIST) List, i);
            return TRUE;
        }
    }

    return TRUE;

}


BOOL
MigDllRemoveDllInEnumFromListA (
    IN DLLLIST List,
    IN PMIGDLLENUMA Enum
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    Enum->NextItem--;

    return MigDllRemoveDllFromListA (List, Enum->Properties->Info.StaticProductIdentifier);
}

BOOL
MigDllRemoveDllInEnumFromListW (
    IN DLLLIST List,
    IN PMIGDLLENUMW Enum
    )
{
    MYASSERT (List);
    MYASSERT (Enum);

    Enum->NextItem--;

    return MigDllRemoveDllFromListW (List, Enum->Properties->Info.StaticProductIdentifier);
}


INT
MigDllGetDllCountInList (
    IN DLLLIST List
    )
{
    MYASSERT (List);

    return List ? GrowListGetSize ((PGROWLIST) List) : 0;

}


PMIGDLLPROPERTIESA
MigDllFindDllInListA (
    IN DLLLIST List,
    IN PCSTR ProductId
    )
{

    INT i;
    INT size;
    PMIGDLLPROPERTIESA rProp = NULL;

    MYASSERT (List);
    MYASSERT (ProductId);

    if (!List && !ProductId) {
        return NULL;
    }

    size = GrowListGetSize ((PGROWLIST) List);
    for (i = 0; i < size; i++) {
        rProp = (PMIGDLLPROPERTIESA) GrowListGetItem ((PGROWLIST) List, i);
        if (rProp && StringIMatch (rProp->Info.StaticProductIdentifier, ProductId)) {
            break;
        }

        rProp = NULL;
    }

    return rProp;
}


PMIGDLLPROPERTIESW
MigDllFindDllInListW (
    IN DLLLIST List,
    IN PCWSTR ProductId
    )
{

    INT i;
    INT size;
    PMIGDLLPROPERTIESW rProp = NULL;

    MYASSERT (List);
    MYASSERT (ProductId);

    if (!List && !ProductId) {
        return NULL;
    }

    size = GrowListGetSize ((PGROWLIST) List);
    for (i = 0; i < size; i++) {
        rProp = (PMIGDLLPROPERTIESW) GrowListGetItem ((PGROWLIST) List, i);
        if (rProp && StringIMatchW (rProp->Info.StaticProductIdentifier, ProductId)) {
            break;
        }

        rProp = NULL;
    }

    return rProp;
}



VOID
MigDllSetMigIsolPathA (
    IN PCSTR Path
    )
{
    MYASSERT (Path);
    if(strlen(Path) >= ARRAYSIZE(g_MigIsolPathA)){
        MYASSERT(FALSE);
        return;
    }
    StringCopyA (g_MigIsolPathA, Path);
}

VOID
MigDllSetMigIsolPathW (
    IN PCWSTR Path
    )
{
    MYASSERT (Path);
    if(wcslen(Path) >= ARRAYSIZE(g_MigIsolPathW)){
        MYASSERT(FALSE);
        return;
    }
    StringCopyW (g_MigIsolPathW, Path);
}


BOOL
MigDllMoveDllLocallyW (
    IN PMIGRATIONDLLW Dll,
    IN PCWSTR WorkingDir
    )
{
    PWSTR p;
    PWSTR pMigrationDllName;
    BOOL bResult;

    if(wcslen(WorkingDir) >= ARRAYSIZE(Dll->Properties.WorkingDirectory)){
        MYASSERT(FALSE);
        return FALSE;
    }

    RemoveCompleteDirectoryW (WorkingDir);

    if (!CreateDirectoryW (WorkingDir, NULL) && GetLastError() != ERROR_ALREADY_EXISTS) {
        MYASSERT(FALSE);
        return FALSE;
    }

    p = wcsrchr(Dll->Properties.DllPath, '\\');
    if(p){
        pMigrationDllName = DuplicateTextW(p);

        *p = '\0';
        bResult = CopyTreeW (
                        Dll->Properties.DllPath,
                        WorkingDir,
                        0,
                        COPYTREE_DOCOPY | COPYTREE_NOOVERWRITE,
                        ENUM_ALL_LEVELS,
                        FILTER_ALL,
                        NULL,
                        NULL,
                        NULL
                        );

        *p = '\\';
        if(!bResult){
            FreeTextW (pMigrationDllName);
            return FALSE;
        }

        StringCopyW (Dll->Properties.DllPath, WorkingDir);
        StringCatW (Dll->Properties.DllPath, pMigrationDllName);

        FreeTextW (pMigrationDllName);
    }

    StringCopyW (Dll->Properties.WorkingDirectory, WorkingDir);

    return TRUE;
}


BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

BOOL
WINAPI
MemDb_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    );

HINSTANCE g_hInst;
HANDLE g_hHeap;


BOOL
MigDllInit (
    VOID
    )
{
    g_hHeap = GetProcessHeap();

    if (!g_hInst) {
        //
        // If DllMain didn't set this, then set it now
        //

        g_hInst = GetModuleHandle (NULL);
    }

    if (!MigUtil_Entry (g_hInst, DLL_PROCESS_ATTACH, NULL)) {
        return FALSE;
    }

    g_MigLibPool = PoolMemInitPool ();

    if (!MemDb_Entry(g_hInst, DLL_PROCESS_ATTACH, NULL)){
        return FALSE;
    }

    return TRUE;
}


VOID
MigDllShutdown (
    VOID
    )
{
    PoolMemDestroyPool (g_MigLibPool);

    MemDb_Entry(g_hInst, DLL_PROCESS_DETACH, NULL);

    MigUtil_Entry (g_hInst, DLL_PROCESS_DETACH, NULL);

    if (g_WinTrustLib && g_WinTrustLib != INVALID_HANDLE_VALUE) {
        FreeLibrary (g_WinTrustLib);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\fileenum\copyfile.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    File copy functions

    The code in this source file traverses a drive tree and calls
    an external callback function for each file.  An INF can be
    provided to exclude files and/or directories from enumeration.

Author:

    Mike Condra 16-Aug-1996

Revision History:

    calinn   29-Ian-1998   Modified CopyFileCallback to reset directory attributes for delete op.
    jimschm  20-Dec-1996   Modified return codes

--*/

#include "pch.h"
#include "migshared.h"


#ifdef UNICODE


BOOL
CALLBACK
CopyFileCallbackA(
                  LPCSTR szFullFileSpecIn,
                  LPCSTR DontCare,
                  WIN32_FIND_DATAA *pFindData,
                  DWORD dwEnumHandle,
                  LPVOID pVoid,
                  PDWORD CurrentDirData
                  )
/*
    This function is the built-in callback for CopyTree. Its purpose is to
    build the target filespec, give the user-supplied callback a chance to
    veto the copy, then perform the copy and any directory creation it
    requires.  The signature of this function is the generic callback
    used for EnumerateTree.
*/
{
    COPYTREE_PARAMSA *pCopyParams = (COPYTREE_PARAMSA*)pVoid;
    int nCharsInFullFileSpec = ByteCountA (szFullFileSpecIn);
    INT rc;

    // Set return code
    if (COPYTREE_IGNORE_ERRORS & pCopyParams->flags)
        rc = CALLBACK_CONTINUE;
    else
        rc = CALLBACK_FAILED;

    // Build output path
    if (pCopyParams->szEnumRootOutWack)
    {
        StringCopyA(pCopyParams->szFullFileSpecOut, pCopyParams->szEnumRootOutWack);
        StringCatA (pCopyParams->szFullFileSpecOut, szFullFileSpecIn + pCopyParams->nCharsInRootInWack);
    }

    //
    // If a callback was supplied, give it a chance to veto the copy.  This callback is
    // different from the one given to an EnumerateTree function, since the latter can
    // terminate enumeration by returning FALSE.
    //
    if (pCopyParams->pfnCallback)
    {
        if (!pCopyParams->pfnCallback(
                szFullFileSpecIn,
                pCopyParams->szFullFileSpecOut,
                pFindData,
                dwEnumHandle,
                pVoid,
                CurrentDirData
                ))
        {
            return CALLBACK_CONTINUE;
        }
    }

    // Copy, move or delete the file if requested
    if ((COPYTREE_DOCOPY & pCopyParams->flags) ||
        (COPYTREE_DOMOVE & pCopyParams->flags))
    {
        BOOL fNoOverwrite = (0 != (COPYTREE_NOOVERWRITE & pCopyParams->flags));

        //
        // Create the directory. The function we call expects a full filename,
        // and considers the directory to end at the last wack. If this object
        // is a directory, we need to add at least a wack to make sure the last
        // path element is treated as part of the directory, not as a filename.
        //
        {
            CHAR strTemp[MAX_MBCHAR_PATH];
            StringCopyTcharCountA (strTemp, pCopyParams->szFullFileSpecOut, ARRAYSIZE(strTemp) - 1);
            if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                AppendUncWackA(strTemp);
            }

            if (ERROR_SUCCESS != MakeSurePathExistsA(strTemp,FALSE))
            {
                return rc;
            }
        }


        //
        // Copy or move the file
        //
        if (0 == (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (COPYTREE_DOCOPY & pCopyParams->flags)
            {
                if (!CopyFileA(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut,
                    fNoOverwrite
                    ))
                {
                    if (!fNoOverwrite)
                    {
                        return rc;
                    }
                    if (ERROR_FILE_EXISTS != GetLastError())
                    {
                        return rc;
                    }
                }
            }
            else if (COPYTREE_DOMOVE & pCopyParams->flags)
            {
                // If allowed to overwrite, delete the target if it exists
                if (!fNoOverwrite && DoesFileExistA(pCopyParams->szFullFileSpecOut))
                {
                    SetFileAttributesA (pCopyParams->szFullFileSpecOut, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileA(pCopyParams->szFullFileSpecOut))
                    {
                        return rc;
                    }
                }
                // Move the file
                if (!MoveFileA(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut
                    ))
                {
                    return rc;
                }
            }
        }
        //
        // Copy the source file-or-directory's attributes to the target
        //
        SetFileAttributesA(pCopyParams->szFullFileSpecOut,
                pFindData->dwFileAttributes);
    }
    else if (COPYTREE_DODELETE & pCopyParams->flags) {
        SetFileAttributesA (szFullFileSpecIn, FILE_ATTRIBUTE_NORMAL);
        if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            RemoveDirectoryA (szFullFileSpecIn);
        }
        else {
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            DeleteFileA (szFullFileSpecIn);
        }
    }

    return CALLBACK_CONTINUE;
}



BOOL
CALLBACK
CopyFileCallbackW(
                  LPCWSTR szFullFileSpecIn,
                  LPCWSTR DontCare,
                  WIN32_FIND_DATAW *pFindData,
                  DWORD dwEnumHandle,
                  LPVOID pVoid,
                  PDWORD CurrentDirData
                  )
{
    COPYTREE_PARAMSW *pCopyParams = (COPYTREE_PARAMSW*)pVoid;
    int nCharsInFullFileSpec = wcslen (szFullFileSpecIn);
    INT rc;

    // Set return code
    if (COPYTREE_IGNORE_ERRORS & pCopyParams->flags)
        rc = CALLBACK_CONTINUE;
    else
        rc = CALLBACK_FAILED;

    // Build output path
    if (pCopyParams->szEnumRootOutWack)
    {
        StringCopyW (pCopyParams->szFullFileSpecOut, pCopyParams->szEnumRootOutWack);
        StringCatW (pCopyParams->szFullFileSpecOut, szFullFileSpecIn + pCopyParams->nCharsInRootInWack);
    }

    //
    // If a callback was supplied, give it a chance to veto the copy.  This callback is
    // different from the one given to an EnumerateTree function, since the latter can
    // terminate enumeration by returning FALSE.
    //
    if (pCopyParams->pfnCallback)
    {
        if (!pCopyParams->pfnCallback(
                szFullFileSpecIn,
                pCopyParams->szFullFileSpecOut,
                pFindData,
                dwEnumHandle,
                pVoid,
                CurrentDirData
                ))
        {
            return CALLBACK_CONTINUE;
        }
    }

    // Copy or move the file if requested
    if ((COPYTREE_DOCOPY & pCopyParams->flags) ||
        (COPYTREE_DOMOVE & pCopyParams->flags))
    {
        BOOL fNoOverwrite = (0 != (COPYTREE_NOOVERWRITE & pCopyParams->flags));

        //
        // Create the directory. The function we call expects a full filename,
        // and considers the directory to end at the last wack. If this object
        // is a directory, we need to add at least a wack to make sure the last
        // path element is treated as part of the directory, not as a filename.
        //
        {
            WCHAR strTemp[MAX_WCHAR_PATH];
            StringCopyTcharCountW (strTemp, pCopyParams->szFullFileSpecOut, ARRAYSIZE(strTemp) - 1);
            if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                AppendUncWackW(strTemp);
            }

            if (ERROR_SUCCESS != MakeSurePathExistsW(strTemp,FALSE))
            {
                return rc;
            }
        }

        //
        // Copy or move the file
        //
        if (0 == (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (COPYTREE_DOCOPY & pCopyParams->flags)
            {
                DEBUGMSG ((DBG_NAUSEA, "Copying %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                if (!CopyFileW(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut,
                    fNoOverwrite
                    ))
                {
                    if (!fNoOverwrite)
                    {
                        LOG ((LOG_ERROR, "CopyFileW failed.  Could not copy %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                        return rc;
                    }

                    if (ERROR_FILE_EXISTS != GetLastError())
                    {
                        LOG ((LOG_ERROR, "CopyFileW failed.  Could not copy %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                        return rc;
                    }
                }
            }
            else if (COPYTREE_DOMOVE & pCopyParams->flags)
            {
                // If allowed to overwrite, delete the target if it exists
                if (!fNoOverwrite && DoesFileExistW(pCopyParams->szFullFileSpecOut))
                {
                    SetFileAttributesW (pCopyParams->szFullFileSpecOut, FILE_ATTRIBUTE_NORMAL);
                    if (!DeleteFileW(pCopyParams->szFullFileSpecOut))
                    {
                        LOG ((LOG_ERROR, "DeleteFileW failed.  Could remove %s before moving", pCopyParams->szFullFileSpecOut));
                        return rc;
                    }
                }
                // Move the file
                if (!MoveFileW(
                    szFullFileSpecIn,
                    pCopyParams->szFullFileSpecOut
                    ))
                {
                    LOG ((LOG_ERROR, "MoveFileW failed.  Could not move %s to %s", szFullFileSpecIn, pCopyParams->szFullFileSpecOut));
                    return rc;
                }
            }
        }
        //
        // Copy the source file-or-directory's attributes to the target
        //
        SetFileAttributesW(pCopyParams->szFullFileSpecOut,
                pFindData->dwFileAttributes);
    }
    else if (COPYTREE_DODELETE & pCopyParams->flags) {
        SetFileAttributesW (szFullFileSpecIn, FILE_ATTRIBUTE_NORMAL);
        if (pFindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DEBUGMSG ((DBG_NAUSEA, "Delete dir %ls", szFullFileSpecIn));
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            RemoveDirectoryW (szFullFileSpecIn);
        }
        else {
            DEBUGMSG ((DBG_NAUSEA, "Delete file %ls", szFullFileSpecIn));
            //
            // We don't care about the error. We won't stop the enumeration just
            // because we could not delete something.
            //
            DeleteFileW (szFullFileSpecIn);
        }
    }

    return CALLBACK_CONTINUE;
}



BOOL
CopyTreeA(
    IN  LPCSTR szEnumRootIn,
    IN  LPCSTR szEnumRootOut,
    IN  DWORD dwEnumHandle,
    IN  DWORD flags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFA ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCA pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCA pfnFailCallback OPTIONAL
    )

/*
    This function enumerates a subtree of a disk drive, and optionally
    copies it to another location. No check is made to ensure the target
    is not contained within the source tree -- this condition could lead
    to unpredictable results.

    The parameters are a superset of those for EnumerateTree.  The caller-
    supplied optional callback function can veto the copying of individual
    files, but cannot (as of 9/10) end the enumeration.

    Directories will be created as necessary to complete the copy.
*/

{
    COPYTREE_PARAMSA copyParams;
    CHAR szEnumRootInWack[MAX_MBCHAR_PATH];
    CHAR szEnumRootOutWack[MAX_MBCHAR_PATH];

    //
    // Build wacked copies of paths for use in parameter block.
    //

    //
    // Input path
    //
    StringCopyTcharCountA (szEnumRootInWack, szEnumRootIn, ARRAYSIZE(szEnumRootInWack) - 1);
    AppendUncWackA(szEnumRootInWack);
    copyParams.szEnumRootInWack = szEnumRootInWack;
    copyParams.nCharsInRootInWack = ByteCountA(szEnumRootInWack);

    //
    // If output path is NULL, store 0 length and a NULL ptr in param block.
    //
    if (NULL != szEnumRootOut)
    {
        StringCopyA(szEnumRootOutWack, szEnumRootOut);
        AppendUncWackA(szEnumRootOutWack);
        copyParams.szEnumRootOutWack = szEnumRootOutWack;
        copyParams.nCharsInRootOutWack = ByteCountA(szEnumRootOutWack);
    }
    else
    {
        copyParams.szEnumRootOutWack = NULL;
        copyParams.nCharsInRootOutWack = 0;
    }

    copyParams.pfnCallback = pfnCallback;
    copyParams.flags = flags;

    if ((flags & COPYTREE_DOCOPY) &&
        (flags & COPYTREE_DOMOVE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (flags & COPYTREE_DODELETE) {
        AttributeFilter |= FILTER_DIRS_LAST;
    }

    return EnumerateTreeA(
        szEnumRootInWack,
        CopyFileCallbackA,
        pfnFailCallback,
        dwEnumHandle,
        (LPVOID)&copyParams,
        Levels,
        ExcludeInfStruct,
        AttributeFilter);
}

BOOL
CopyTreeW(
    IN  LPCWSTR szEnumRootIn,
    IN  LPCWSTR szEnumRootOut,
    IN  DWORD dwEnumHandle,
    IN  DWORD flags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFW ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCW pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCW pfnFailCallback OPTIONAL
    )

{
    COPYTREE_PARAMSW copyParams;
    WCHAR szEnumRootInWack[MAX_WCHAR_PATH];
    WCHAR szEnumRootOutWack[MAX_WCHAR_PATH];

    //
    // Place wacked copies of paths in parameter block.
    //

    //
    // Input Path
    //
    StringCopyTcharCountW(szEnumRootInWack, szEnumRootIn, ARRAYSIZE(szEnumRootInWack) - 1);
    AppendUncWackW(szEnumRootInWack);
    copyParams.szEnumRootInWack = szEnumRootInWack;
    copyParams.nCharsInRootInWack = wcslen(szEnumRootInWack);

    //
    // If output path is NULL, put 0 length and NULL ptr in param block.
    //
    if (NULL != szEnumRootOut)
    {
        StringCopyW(szEnumRootOutWack, szEnumRootOut);
        AppendUncWackW(szEnumRootOutWack);
        copyParams.szEnumRootOutWack = szEnumRootOutWack;
        copyParams.nCharsInRootOutWack = wcslen(szEnumRootOutWack);
    }
    else
    {
        copyParams.szEnumRootOutWack = NULL;
        copyParams.nCharsInRootOutWack = 0;
    }

    copyParams.pfnCallback = pfnCallback;
    copyParams.flags = flags;

    if ((flags & COPYTREE_DOCOPY) &&
        (flags & COPYTREE_DOMOVE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (flags & COPYTREE_DODELETE) {
        AttributeFilter |= FILTER_DIRS_LAST;
    }

    return EnumerateTreeW(
        szEnumRootInWack,
        CopyFileCallbackW,
        pfnFailCallback,
        dwEnumHandle,
        (LPVOID)&copyParams,
        Levels,
        ExcludeInfStruct,
        AttributeFilter);
}


DWORD
CreateEmptyDirectoryA (
    PCSTR Dir
    )
{
    DWORD rc;

    if (!DeleteDirectoryContentsA (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND)
            return rc;
    }

    if (!RemoveDirectoryA (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND) {
            return rc;
        }
    }

    return MakeSurePathExistsA (Dir, TRUE);
}


DWORD
CreateEmptyDirectoryW (
    PCWSTR Dir
    )
{
    DWORD rc;

    if (!DeleteDirectoryContentsW (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND)
            return rc;
    }

    if (!RemoveDirectoryW (Dir)) {
        rc = GetLastError();
        if (rc != ERROR_PATH_NOT_FOUND) {
            return rc;
        }
    }

    return MakeSurePathExistsW (Dir, TRUE);
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\fileenum\fileenum.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    fileenum.c

Abstract:

    The code in this source file traverses a drive tree and calls
    an external callback function for each file.  An INF can be
    provided to exclude files and/or directories from enumeration.

Author:

    Jim Schmidt (jimschm) 16-Aug-1996

Revision History:

    Marc R. Whitten (marcw) 11-Sep-1997 Tweaked exclusion handling code, removed
                                        obsolete code.

    Mike Condra (mikeco)  02-Jun-1996   Add fns to tap into file/path exclusion

    Jim Schmidt (jimschm) 20-Dec-1996   Added callback levels and made single
                                        source file for both A and W versions
    Jim Schmidt (jimschm) 27-Nov-1996   Added level and filter to EnumTree



--*/

#include "pch.h"
#include "migshared.h"

typedef struct {
    FILEENUMPROCA fnEnumCallback;
    FILEENUMFAILPROCA fnFailCallback;
    DWORD         EnumID;
    LPVOID        pParam;
    DWORD         Levels;
    DWORD         CurrentLevel;
    DWORD         AttributeFilter;
} ENUMSTRUCTA, *PENUMSTRUCTA;

BOOL EnumTreeEngineA (LPCSTR CurrentPath, PENUMSTRUCTA pes);
BOOL IsPathExcludedA (DWORD EnumID, LPCSTR Path);
BOOL IsFileExcludedA (DWORD EnumID, LPCSTR File, BYTE byBitmask[]);
BOOL BuildExclusionsFromInfA (DWORD EnumID, PEXCLUDEINFA ExcludeInfStruct);
void CreateBitmaskA (DWORD EnumID, LPCSTR FindPattern, BYTE byBitmask[]);


typedef struct {
    FILEENUMPROCW     fnEnumCallback;
    FILEENUMFAILPROCW fnFailCallback;
    DWORD             EnumID;
    LPVOID            pParam;
    DWORD             Levels;
    DWORD             CurrentLevel;
    DWORD             AttributeFilter;
} ENUMSTRUCTW, *PENUMSTRUCTW;

BOOL EnumTreeEngineW (LPCWSTR CurrentPath, PENUMSTRUCTW pes);
BOOL IsPathExcludedW (DWORD EnumID, LPCWSTR Path);
BOOL IsFileExcludedW (DWORD EnumID, LPCWSTR File, BYTE byBitmask[]);
BOOL BuildExclusionsFromInfW (DWORD EnumID, PEXCLUDEINFW ExcludeInfStruct);
void CreateBitmaskW (DWORD EnumID, LPCWSTR FindPattern, BYTE byBitmask[]);



#ifdef UNICODE

BOOL
WINAPI
FileEnum_Entry (
        IN HINSTANCE hinstDLL,
        IN DWORD dwReason,
        IN LPVOID lpv)

/*++

Routine Description:

  FileEnum_Entry is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.  For this LIB, it
  does nothing.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        break;


    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


/*++

Routine Description:

    GenerateEnumID maintains a static that is used to generate unique
    enumeration handles for callers.  The enumeration handle is guaranteed to
    be unique for the first 2^32 calls.

Arguments:

    none

Return Value:

    A DWORD enumeration handle that may be used to identify an exclusion
    list.

--*/

DWORD
GenerateEnumID (
    void
    )
{
    static DWORD s_EnumID = 0;

    return ++s_EnumID;
}

#endif

#ifdef UNICODE

#define FILEENUMPROCT               FILEENUMPROCW
#define FILEENUMFAILPROCT           FILEENUMFAILPROCW
#define PEXCLUDEINFT                PEXCLUDEINFW
#define ENUMSTRUCTT                 ENUMSTRUCTW
#define PENUMSTRUCTT                PENUMSTRUCTW
#define EnumerateAllDrivesT         EnumerateAllDrivesW
#define EnumerateTreeT              EnumerateTreeW
#define EnumTreeEngineT             EnumTreeEngineW
#define IsPathExcludedT             IsPathExcludedW
#define CreateBitmaskT              CreateBitmaskW
#define IsFileExcludedT             IsFileExcludedW
#define BuildExclusionsFromInfT     BuildExclusionsFromInfW
#define ClearExclusionsT            ClearExclusionsW
#define ExcludeFileT                ExcludeFileW
#define ExcludePathT                ExcludePathW

#else

#define FILEENUMPROCT               FILEENUMPROCA
#define FILEENUMFAILPROCT           FILEENUMFAILPROCA
#define PEXCLUDEINFT                PEXCLUDEINFA
#define ENUMSTRUCTT                 ENUMSTRUCTA
#define PENUMSTRUCTT                PENUMSTRUCTA
#define EnumerateAllDrivesT         EnumerateAllDrivesA
#define EnumerateTreeT              EnumerateTreeA
#define EnumTreeEngineT             EnumTreeEngineA
#define IsPathExcludedT             IsPathExcludedA
#define CreateBitmaskT              CreateBitmaskA
#define IsFileExcludedT             IsFileExcludedA
#define BuildExclusionsFromInfT     BuildExclusionsFromInfA
#define ClearExclusionsT            ClearExclusionsA
#define ExcludeFileT                ExcludeFileA
#define ExcludePathT                ExcludePathA

#endif

#define MAX_DRIVES  64


BOOL
EnumerateAllDrivesT (
                     IN  FILEENUMPROCT fnEnumCallback,
                     IN  FILEENUMFAILPROCT fnFailCallback,
                     IN  DWORD EnumID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFT ExcludeInfStruct,
                     IN  DWORD AttributeFilter
                     )

/*++

Routine Description:

    EnumerateAllDrives first builds an exclusion list if an exclusion INF path
    is provided, and then enumerates every file on every drive that is not
    excluded.  The callback function is called once per file.  The pParam
    parameter is passed to the callback.

Arguments:

    fnEnumCallback     - A pointer to your callback function
    EnumID         - A caller-defined value used to identify the exclusion list
    pParam             - LPVOID passed to callback function
    ExcludeInfStruct   - Struct containing INF file information for excluding dirs or files
    AttributeFilter    - FILTER_xxx constants

Return Value:

    TRUE if function succeeds.  Call GetLastError for error code if return
    value is FALSE.

--*/

{
    TCHAR   LogicalDrives[MAX_DRIVES];
    DWORD   rc;
    PCTSTR p;
    UINT    driveType;

    rc = GetLogicalDriveStrings (
            MAX_DRIVES,
            LogicalDrives
            );

    if (!rc || rc > MAX_DRIVES) {
        if (rc)
            SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    for (p = LogicalDrives ; *p ; p = GetEndOfString (p) + 1) {

        driveType = GetDriveType(p);
        if (driveType == DRIVE_REMOTE || driveType == DRIVE_CDROM) {
            continue;
        }


        if (!EnumerateTreeT (p,
                             fnEnumCallback,
                             fnFailCallback,
                             EnumID,
                             pParam,
                             ENUM_ALL_LEVELS,
                             ExcludeInfStruct,
                             AttributeFilter
                             ))
            break;
    }

    return (*p == 0);
}




BOOL
EnumerateTreeT (
                IN  PCTSTR EnumRoot,
                IN  FILEENUMPROCT fnEnumCallback,
                IN  FILEENUMFAILPROCT fnFailCallback,   OPTIONAL
                IN  DWORD EnumID,
                IN  LPVOID pParam,
                IN  DWORD Levels,
                IN  PEXCLUDEINFT ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                )

/*++

Routine Description:

    EnumerateTree is similar to EnumerateAllDrives, except it allows you to
    enumerate a specific drive, or a specific subdir on a drive.  Supply the
    drive letter and optional subdirectory in EnumRoot.  Before enumerating,
    EnumerateTree will first build an exclusion list if an exclusion INF path
    is provided.  Then every file below EnumRoot is enumerated, and the
    callback is called once per file, passing pParam unchanged.

Arguments:

    EnumRoot           - Drive and optional path to enumerate
    fnEnumCallback     - A pointer to your callback function
    fnFailCallback     - A pointer to optional fn that logs enumeration errors
    EnumID             - A caller-defined value used to identify the exclusion list
    pParam             - LPVOID passed to callback function
    ExcludeInfStruct   - Struct containing INF file information for excluding dirs or files
    AttributeFilter    - FILTER_xxx constants

Return Value:

    TRUE if function succeeds.  Call GetLastError for error code if return
    value is FALSE.

--*/

{
    ENUMSTRUCTT es;
    BOOL b;

    if (ExcludeInfStruct)
        if (!BuildExclusionsFromInfT (
                EnumID,
                ExcludeInfStruct
            )) {
            DEBUGMSG ((DBG_ERROR, "Error in exclusion file"));
            return FALSE;
        }

    es.fnEnumCallback  = fnEnumCallback;
    es.fnFailCallback  = fnFailCallback;
    es.EnumID          = EnumID;
    es.pParam          = pParam;
    es.Levels          = Levels;
    es.CurrentLevel    = 1;
    es.AttributeFilter = AttributeFilter;

    if (!IsPathLengthOk(EnumRoot))
    {
        if (NULL != fnFailCallback)
        {
            fnFailCallback(EnumRoot);
            return TRUE;
        }
    }

    if (IsPathExcludedT (EnumID, EnumRoot))
        return TRUE;

    b = EnumTreeEngineT (EnumRoot, &es);

    return b;
}


BOOL
EnumTreeEngineT (
    PCTSTR CurrentPath,
    PENUMSTRUCTT pes
    )
{
    WIN32_FIND_DATA fd;                         // A find struct for this subdir
    HANDLE          hFind;                      // A find handle for this subdir
    PTSTR          FullFilePath;               // Buffer used to build file path
    static TCHAR    FindPattern[MAX_TCHAR_PATH * 2]; // Temp buffer used to build pattern
    BYTE            byBitmask[MAX_PATH];        // Bitmask is used to speed exclusion lookup
    static DWORD    Attrib;                     // Temp attribute storage for filter processing
    static INT      rc;                         // Callback return value
    DWORD           PrevLevelCt;                // Storage for parent's max depth setting
    BOOL            RecurseStatus;
    DWORD           CurrentDirData = 0;

    //
    // Do nothing when CurrentPath is at the size limit.
    //
    if (!IsPathLengthOk(CurrentPath))
    {
        if (NULL != pes->fnFailCallback)
        {
            pes->fnFailCallback(CurrentPath);
        }
        return TRUE;
    }

    PrevLevelCt = pes->Levels;


    StringCopy (FindPattern, CurrentPath);

    //
    // Create a bitmask that tells us when subdirectories match partial
    // file patterns.
    //

    ZeroMemory (byBitmask, sizeof (byBitmask));
    CreateBitmaskT (pes->EnumID, FindPattern, byBitmask);

    AppendPathWack (FindPattern);
    StringCat (FindPattern, TEXT("*"));
    hFind = FindFirstFile (FindPattern, &fd);

    if (hFind != INVALID_HANDLE_VALUE) {

        do {

            FullFilePath = JoinPaths (CurrentPath, fd.cFileName);

            __try {
                //
                // Ignore this path if FullFilePath is too long
                // this way fd.cFileName will surely be within limits (since it's shorter)
                //
                if (!IsPathLengthOk (FullFilePath)) {
                    if (NULL != pes->fnFailCallback) {
                        pes->fnFailCallback(FullFilePath);
                    }
                    __leave;
                }

                // Filter directories named ".", "..". Set Attrib symbol.
                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                    if (!StringCompare (fd.cFileName, TEXT(".")) ||
                        !StringCompare (fd.cFileName, TEXT("..")))
                        __leave;

                    Attrib = FILTER_DIRECTORIES;
                } else {
                    Attrib = FILTER_FILES;
                }

                // Call the callback
                if (Attrib & pes->AttributeFilter) {
                    rc = CALLBACK_CONTINUE;

                    switch (Attrib) {
                    case FILTER_DIRECTORIES:
                        // Ignore excluded paths
                        if (IsPathExcludedT (pes->EnumID, FullFilePath)) {
                            break;
                        }

                        // Callback for 'directory first'
                        if (!(pes->AttributeFilter & FILTER_DIRS_LAST)) {
                            rc = pes->fnEnumCallback  (
                                        FullFilePath,
                                        NULL,
                                        &fd,
                                        pes->EnumID,
                                        pes->pParam,
                                        &CurrentDirData
                                        );
                        }

                        if (rc >= CALLBACK_CONTINUE && pes->CurrentLevel != pes -> Levels) {
                            // Recurse on directory
                            pes->CurrentLevel++;
                            RecurseStatus = EnumTreeEngineT (FullFilePath, pes);
                            pes->CurrentLevel--;
                            if (!RecurseStatus) {
                                PushError();
                                FindClose(hFind);
                                PopError();

                                #pragma prefast(suppress:242, "try/finally perf not an issue here")
                                return FALSE;
                            }
                        }

                        // Callback for 'directory last'
                        if (pes->AttributeFilter & FILTER_DIRS_LAST) {
                            rc = pes->fnEnumCallback  (
                                        FullFilePath,
                                        NULL,
                                        &fd,
                                        pes->EnumID,
                                        pes->pParam,
                                        &CurrentDirData
                                        );
                        }

                        break;

                    case FILTER_FILES:
                        if (!IsFileExcludedT (pes->EnumID, FullFilePath, byBitmask)) {
                            rc = pes->fnEnumCallback  (FullFilePath,
                                                       NULL,
                                                       &fd,
                                                       pes->EnumID,
                                                       pes->pParam,
                                                       &CurrentDirData
                                                       );
                        }

                        break;
                    }

                    if (rc == CALLBACK_FAILED) {
                        PushError();
                        FindClose (hFind);
                        PopError();

                        #pragma prefast(suppress:242, "try/finally perf not an issue here")
                        return FALSE;
                    }
                    else if (rc == CALLBACK_SUBDIR_DONE) {
                        #pragma prefast(suppress:242, "try/finally perf not an issue here")
                        break;
                    }
                    else if (rc > 0) {
                        pes->Levels = pes->CurrentLevel + rc;
                    }
                }
                else if (Attrib == FILTER_DIRECTORIES && !IsPathExcludedT (pes->EnumID, FullFilePath)) {
                    // Recurse on directory.
                    if (pes->CurrentLevel != pes -> Levels) {

                        pes->CurrentLevel++;
                        RecurseStatus = EnumTreeEngineT (FullFilePath, pes);
                        pes->CurrentLevel--;
                        if (!RecurseStatus) {
                            PushError();
                            FindClose(hFind);
                            PopError();

                            #pragma prefast(suppress:242, "try/finally perf not an issue here")
                            return FALSE;
                        }
                    }
                }
            }
            __finally {
                FreePathString (FullFilePath);
            }
        } while (FindNextFile (hFind, &fd));

        FindClose (hFind);

        //
        // Test error code returned from FindNextFile
        //
        if (GetLastError() != ERROR_NO_MORE_FILES && GetLastError() != ERROR_SUCCESS)
        {
            //
            // Caller to handle not-ready message
            //
            if (GetLastError() != ERROR_NOT_READY)
            {
                DEBUGMSG((DBG_ERROR,
                    "EnumTreeEngineT: Error from FindNextFile.\n"
                    "  FindPattern:       %s\n"
                    "  Error: %u (%x)",
                        FindPattern,
                        GetLastError(),GetLastError()));
            }
            return FALSE;
        }
        SetLastError(ERROR_SUCCESS);
    }
    else {

        //
        // Test return codes from FindFirstFile
        //
        if (GetLastError () != ERROR_NO_MORE_FILES)
        {
            //
            // Caller to handle not-ready message
            //
            if (GetLastError() != ERROR_NOT_READY)
            {
                DEBUGMSG((DBG_WARNING,
                    "EnumTreeEngineT: Warning from FindFirstFile.\n"
                    "  FindPattern: %s\n",
                        FindPattern));
            }
            // return FALSE;
        }
        SetLastError (ERROR_SUCCESS);
    }

    // If a callback returned a positive, non-zero number, the depth
    // of the subdirectory search was limited for this level.  Now that
    // this level is done, we must restore the depth value of our parent.
    pes->Levels = PrevLevelCt;

    return TRUE;
}


/*++

  A bitmask is used in IsFileExcluded for faster relative directory searches.
  Instead of looking in the MemDb for each part of the path, IsFileExcluded
  skips segments that are known not to match.  We create the bitmask here
  by looking up each portion of FindPattern.  Bit 1 is set if the last
  subdirectory exists in the file exclusion list, Bit 2 is set if the last
  two subdirectories exist in the file exclusion list, and so on.

  For example, assume FindPattern is set to C:\DEV\FOO\BAR.  CreateBitmask
  first looks in the memory database for BAR\*, and if it is found bit 1 is set.
  Then CreateBitmask looks in the memory database for FOO\BAR\*, and sets bit
  2.  Again the function looks up DEV\FOO\BAR\* for bit 3 and finally
  C:\DEV\FOO\BAR\* for bit 4.

  Bit 0 is always set (empty paths always match).

  Once this bitmask is set up, IsFileExcluded can test only the patterns that
  are known to exist.

  --*/

void
CreateBitmaskT (
    DWORD EnumID,
    PCTSTR FindPattern,
    BYTE byBitmask[]
    )
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;
    int nByte;
    int nBitVal;

    // Always set bit 0
    byBitmask[0] |= 1;

    // Build full file spec
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES
        );

    End = GetEndOfString (EnumPath);
    StringCopy (End, FindPattern);
    AppendPathWack (End);
    StringCat (End, TEXT("*"));

    // Start with last subdirectory, and build mask in reverse
    p = _tcsrchr (EnumPath, TEXT('\\'));
    nByte = 0;
    nBitVal = 2;
    do  {
        // Move back to previous backslash
        for (p = _tcsdec (EnumPath, p) ;
             p >= End && *p != TEXT('\\') ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Check if partial file is in the tree
        wsprintf (
            ShortPath,
            TEXT("%s\\%X\\%s%s"),
            MEMDB_CATEGORY_FILEENUM,
            EnumID,
            MEMDB_FIELD_FE_FILES,
            p
            );

        if (MemDbGetPatternValueWithPattern (ShortPath, NULL))
            byBitmask[nByte] |= nBitVal;

        // Inc bit pos
        nBitVal *= 2;
        if (nBitVal == 256) {
            nBitVal = 1;
            nByte++;
        }
    } while (p > End);
}


BOOL
IsPathExcludedT (DWORD EnumID, PCTSTR Path)
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;

    // Try full paths
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_PATHS
        );

    End = GetEndOfString (EnumPath);
    p = _tcsappend (End, Path);

    if (MemDbGetPatternValue (EnumPath, NULL)) {

        return TRUE;
    }

    // Try partial paths
    do  {
        // Move back to previous backslash
        for (p = _tcsdec (EnumPath, p) ;
             p > End && (*p != TEXT('\\')) ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Check if partial path is in the tree
        if (p > End && p[1]) {
            wsprintf (
                ShortPath,
                TEXT("%s\\%X\\%s%s"),
                MEMDB_CATEGORY_FILEENUM,
                EnumID,
                MEMDB_FIELD_FE_PATHS,
                p
                );

            if (MemDbGetPatternValue (ShortPath, NULL)) {
                return TRUE;
            }
        }
    } while (p > End);

    return FALSE;
}


BOOL
IsFileExcludedT (DWORD EnumID, PCTSTR File, BYTE byBitmask[])
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];
    TCHAR ShortPath[MAX_TCHAR_PATH * 2];
    PCTSTR p;
    PTSTR End;
    int nByte;
    int nBit;

    // Build full file spec
    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES
        );

    End = GetEndOfString (EnumPath);
    p = _tcsappend (End, File);

    //
    // Try partial file specs until full spec is reached
    //

    nByte = 0;
    nBit = 1;
    do  {
        //
        // Move back to previous backslash in path
        // (p starts at NULL of EnumPath, End is in the middle of EnumPath)
        //

        for (p = _tcsdec (EnumPath, p) ;
             p >= End && (*p != TEXT('\\')) ;
             p = _tcsdec (EnumPath, p))
        {
        }

        // Bitmask is used to make sure slightly expensive query is necessary
        if (byBitmask[nByte] & nBit) {

            //
            // Check if partial file is in the tree
            //

            wsprintf (
                ShortPath,
                TEXT("%s\\%X\\%s%s"),
                MEMDB_CATEGORY_FILEENUM,
                EnumID,
                MEMDB_FIELD_FE_FILES,
                p
                );

            if (MemDbGetPatternValue (ShortPath, NULL)) {

                return TRUE;
            }
        }

        nBit *= 2;
        if (nBit == 256) {
            nBit = 1;
            nByte++;
        }
    } while (p > End);

    return FALSE;
}


//
// ClearExclusions removes all enumaration exclusions.  It is called
// automatically at the end of enumeration when an exclusion INF file is
// used.  Use it when you need to programmatically build an exclusion list
// with ExcludeDrive, ExcludePath, and ExcludeFile.
//
// You can combine programmatic exclusions with an exclusion INF file, but
// beware that the programmatic exclusions will be cleared after
// EnumarteAllDrives or EnumerateTree completes.
//
// If you do not use an INF, the programmatic exclusions will not
// automatically be cleared.
//
// EnumID  - Caller-defined value to identify enumeration exclusion list
//

VOID
ClearExclusionsT (
    DWORD EnumID
    )
{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (EnumPath, TEXT("%s\\%X"), MEMDB_CATEGORY_FILEENUM, EnumID);

    MemDbDeleteTree (EnumPath);
}



/*++

Routine Description:

    ExcludePath adds a path name to the exclusion list.  There are two
    cases:

     1. A full path spec is supplied, including the drive letter or
        UNC double-backslash.
     2. The path does not start with a drive letter and is a portion of
        a full path.

    The dot and double-dot directories are not supported.  Any part of
    the path may contain wildcard characters, but a wildcard can not
    be used in place of a backslash.

Arguments:

    EnumID   - A caller-defined value that identifies the exclusion list
    Path         - The path specification as described above

Return Value:

    none

--*/

VOID
ExcludePathT (
              IN  DWORD EnumID,
              IN  PCTSTR Path
              )

{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\%s"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_PATHS,
        Path
        );

    MemDbSetValue (EnumPath, 0);
}


/*++

Routine Description:

    ExcludeFile adds a file spec to the exclusion list.  There are two
    cases:

     1. A full path spec is supplied, including the drive letter or
        UNC double-backslash.
     2. The path does not start with a drive letter and is a portion of
        a full path.

    The dot and double-dot directories are not supported.  Any part of
    the path may contain wildcard characters, but a wildcard can not
    be used in place of a backslash.

Arguments:

    EnumID   - A caller-defined value that identifies the exclusion list
    File         - The file specification as described above

Return Value:

    none

--*/

VOID
ExcludeFileT (
    IN  DWORD EnumID,
    IN  PCTSTR File
    )

{
    TCHAR EnumPath[MAX_TCHAR_PATH * 2];

    wsprintf (
        EnumPath,
        TEXT("%s\\%X\\%s\\%s"),
        MEMDB_CATEGORY_FILEENUM,
        EnumID,
        MEMDB_FIELD_FE_FILES,
        File
        );

    MemDbSetValue (EnumPath, 0);
}



BOOL
BuildExclusionsFromInfT (DWORD EnumID,
                         PEXCLUDEINFT ExcludeInfStruct)
{
    HINF hInf;
    INFCONTEXT ic;
    TCHAR Exclude[MAX_TCHAR_PATH * 2];

    // Attempt to open
    hInf = SetupOpenInfFile (ExcludeInfStruct->ExclusionInfPath, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
        return FALSE;

    // Read in path exclusions
    if (ExcludeInfStruct->PathSection) {
        if (SetupFindFirstLine (hInf, ExcludeInfStruct->PathSection, NULL, &ic)) {
            do  {
                if (SetupGetStringField (&ic, 1, Exclude, MAX_TCHAR_PATH, NULL)) {
                    ExcludePathT (EnumID, Exclude);
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
    }

    // Read in file exclusions
    if (ExcludeInfStruct->FileSection) {
        if (SetupFindFirstLine (hInf, ExcludeInfStruct->FileSection, NULL, &ic)) {
            do  {
                if (SetupGetStringField (&ic, 1, Exclude, MAX_TCHAR_PATH, NULL)) {
                    ExcludeFileT (EnumID, Exclude);
                }
            } while (SetupFindNextLine (&ic, &ic));
        }
    }

    // Clean up
    SetupCloseInfFile (hInf);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\fileenum\sources.inc ===
# component
MINORCOMP=fileenum

# target
TARGETTYPE=LIBRARY

SOURCES=\
        fileenum.c    \
        copyfile.c    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migdlls\src\miglib\migcmn.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    migcmn.c

Abstract:

    Repository of functions used between several of the modules in miglib.

Author:

    Marc R. Whitten (marcw) 02-Mar-2000

Revision History:

    <alias> <date> <comments>

--*/

//
// Includes
//

#include "pch.h"
#include "miglibp.h"


//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//
BOOL
IsCodePageArrayValid (
    IN      PDWORD CodePageArray
    )
{
    DWORD CodePage;
    UINT u;

    if (!CodePageArray) {
        return TRUE;
    }

    //
    // Scan system's code pages
    //

    CodePage = GetACP();

    __try {
        for (u = 0 ; CodePageArray[u] != -1 ; u++) {
            if (CodePage == CodePageArray[u]) {
                return TRUE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        LOG ((LOG_ERROR, "Caught an exception while validating array of code pages."));
    }

    return FALSE;
}


BOOL
ValidateBinary (
    IN      PBYTE Data,
    IN      UINT Size,
    IN      BOOL ReadWrite
    )
{
    BYTE Remember;

    if (!Data || !Size) {
        return TRUE;
    }

    __try {
        Remember = Data[0];
        if (ReadWrite) {
            Data[0] = Remember;
        }
        Remember = Data[Size - 1];
        if (ReadWrite) {
            Data[Size - 1] = Remember;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGMSG ((DBG_MIGDLLS, "ValidateBinary failed for %u bytes", Size));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateNonNullStringA (
    IN      PCSTR String
    )
{
    __try {
        SizeOfStringA (String);
        if (*String == 0) {
            return FALSE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateNonNullStringW (
    IN      PCWSTR String
    )
{
    __try {
        SizeOfStringW (String);
        if (*String == 0) {
            return FALSE;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    return TRUE;
}


BOOL
ValidateIntArray (
    IN      PINT Array
    )
{
    PINT End;

    if (!Array) {
        return TRUE;
    }

    __try {
        End = Array;
        while (*End != -1) {
            End++;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGMSG ((DBG_MIGDLLS, "Int Array is invalid (or not terminated with -1)"));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateMultiStringA (
    IN      PCSTR Strings
    )
{
    if (!Strings) {
        return TRUE;
    }

    __try {
        while (*Strings) {
            Strings = GetEndOfStringA (Strings) + 1;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGMSG ((DBG_MIGDLLS, "ValidateMultiString failed"));
        return FALSE;
    }

    return TRUE;
}

BOOL
ValidateMultiStringW (
    IN      PCWSTR Strings
    )
{
    if (!Strings) {
        return TRUE;
    }

    __try {
        while (*Strings) {
            Strings = GetEndOfStringW (Strings) + 1;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGMSGW ((DBG_MIGDLLS, "ValidateMultiString failed"));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\chartype.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    chartype.h

Abstract:

    Declares macros and types for the multi-byte and Unicode
    character environment that the Win9x upgrade code requires.
    The following macros are defined:

    - Make sure UNICODE is defined if _UNICODE is defined
    - Make the type MBCHAR that holds both bytes of a multi-byte char
    - Make CHARTYPE point to wint_t for UNICODE and MBCHAR for not
      UNICODE

Author:

    Jim Schmidt (jimschm) 10-Oct-1996

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#if defined _UNICODE && !defined UNICODE
#define UNICODE
#endif

#ifdef UNICODE

//
// If UNICODE, define _UNICODE for tchar.h, and make
// a type to represent a single character.
//

#ifndef _UNICODE
#define _UNICODE
#endif

#define CHARTYPE wint_t

#pragma message ("UNICODE version being built")

#else       // ifdef UNICODE

//
// If not UNICODE, we must assume multibyte characters.
// Define _MBCS for tchar.h, and make a type that can
// hold a complete multibyte character.
//

#ifndef _MBCS
#define _MBCS
#endif
#define CHARTYPE unsigned int

#pragma message ("MBCS version being built")

#endif      // ifdef UNICODE, else

#define MBCHAR unsigned int

#include <tchar.h>

//
// Constant pointer to a void
//

#ifndef PCVOID
typedef const void * PCVOID;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\coreutil.h ===
#include "migutil.h"
#include "fileenum.h"
#include "memdb.h"
#include "progbar.h"
#include "regops.h"
#include "fileops.h"
#include "win95reg.h"
#include "snapshot.h"
#include "linkpif.h"
#include "safemode.h"
#include "cablib.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

//
// ARRAYSIZE (used to be borrowed from spapip.h)
//
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\cablib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.h

Abstract:

    APIs to manipulate CAB files.

Author:

    20-Oct-1999 Calin Negreanu (calinn)

Revision History:

    <alias> <date> <comments>

--*/

//
// Types
//

typedef BOOL(WINAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(WINAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(WINAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(WINAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID CCABHANDLE;

typedef PVOID OCABHANDLE;

//
// API
//

CCABHANDLE
CabCreateCabinetA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    );

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetA(h)         CabFlushAndCloseCabinetExA(h,NULL,NULL,NULL,NULL)

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

#define CabFlushAndCloseCabinetW(h)         CabFlushAndCloseCabinetExW(h,NULL,NULL,NULL,NULL)

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    );

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    );

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

#define CabExtractAllFilesA(h,p) CabExtractAllFilesExA(h,p,NULL)

BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

#define CabExtractAllFilesW(h,p) CabExtractAllFilesExW(h,p,NULL)

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    );

BOOL
CabVerifyCabinet (
    IN      OCABHANDLE CabHandle
    );

//
// Macros
//

#ifdef UNICODE

#define CABGETCABINETNAMES          CABGETCABINETNAMESW
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESW
#define CABNOTIFICATION             CABNOTIFICATIONA
#define PCABNOTIFICATION            PCABNOTIFICATIONA
#define CabCreateCabinet            CabCreateCabinetW
#define CabCreateCabinetEx          CabCreateCabinetExW
#define CabAddFileToCabinet         CabAddFileToCabinetW
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetW
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExW
#define CabOpenCabinet              CabOpenCabinetW
#define CabExtractAllFilesEx        CabExtractAllFilesExW
#define CabExtractAllFiles          CabExtractAllFilesW
#define CabCloseCabinet             CabCloseCabinetW

#else

#define CABGETCABINETNAMES          CABGETCABINETNAMESA
#define PCABGETCABINETNAMES         PCABGETCABINETNAMESA
#define CABNOTIFICATION             CABNOTIFICATIONW
#define PCABNOTIFICATION            PCABNOTIFICATIONW
#define CabCreateCabinet            CabCreateCabinetA
#define CabCreateCabinetEx          CabCreateCabinetExA
#define CabAddFileToCabinet         CabAddFileToCabinetA
#define CabFlushAndCloseCabinet     CabFlushAndCloseCabinetA
#define CabFlushAndCloseCabinetEx   CabFlushAndCloseCabinetExA
#define CabOpenCabinet              CabOpenCabinetA
#define CabExtractAllFilesEx        CabExtractAllFilesExA
#define CabExtractAllFiles          CabExtractAllFilesA
#define CabCloseCabinet             CabCloseCabinetA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\common.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    common.h

Abstract:

    Declares types and interfaces common between w95upg.dll (the
    Win9x side of the upgrade), and w95upgnt.dll (the NT side of
    the upgrade).

Author:

    Calin Negreanu (calinn) 23-Jun-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

// posible values for Boot16 option
typedef enum {
    BOOT16_AUTOMATIC,
    BOOT16_YES,
    BOOT16_NO
} BOOT16_OPTIONS;

#define PROGID_SUPPRESSED   0
#define PROGID_LOSTDEFAULT  1


#ifdef PRERELEASE

#define AUTOSTRESS_PRIVATE          0x0001
#define AUTOSTRESS_MANUAL_TESTS     0x0002

#endif

#define MAX_GUID        128

typedef struct {
    //
    // Caller-specified members
    //

    PCSTR DetectPattern;
    PCSTR SearchList;           OPTIONAL
    PCSTR ReplaceWith;          OPTIONAL
    BOOL UpdatePath;

    //
    // Work members, caller must zero them
    //

    PVOID DetectPatternStruct;

} TOKENARG, *PTOKENARG;

#pragma warning (disable : 4200)

typedef struct {
    UINT ArgCount;
    PCSTR CharsToIgnore;        OPTIONAL
    BOOL SelfRelative;
    BOOL UrlMode;
    TOKENARG Args[];
} TOKENSET, *PTOKENSET;

#define TOKEN_BASE_OFFSET       1000

//
// Flags for MEMDB_CATEGORY_STATE\MEMDB_ITEM_ADMIN_PASSWORD\<password> = <DWORD>
//
#define PASSWORD_ATTR_DEFAULT                   0x0000
#define PASSWORD_ATTR_RANDOM                    0x0001
#define PASSWORD_ATTR_ENCRYPTED                 0x0002
#define PASSWORD_ATTR_DONT_CHANGE_IF_EXIST      0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\debug.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Implements macros and declares functions for:

    - Resource allocation tracking
    - Logging
    - Definition of DEBUG

Author:

    Jim Schmidt (jimschm) 01-Jan-1997

Revision History:

    Ovidiu Temereanca (ovidiut) 06-Nov-1998
        Took out log related function declarations and put them in log.h file

--*/

#pragma once

#ifdef _cplusplus
extern "C" {
#endif

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG

#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif

//
// Debug-only constants
//

#ifdef DEBUG

// This option makes fat, slow binaries
//#define MEMORY_TRACKING

#include <stdarg.h>

typedef enum {
    MERGE_OBJECT,
    POOLMEM_POINTER,
    POOLMEM_POOL,
    INF_HANDLE
} ALLOCTYPE;


VOID InitAllocationTracking (VOID);
VOID FreeAllocationTracking (VOID);
VOID DebugRegisterAllocation (ALLOCTYPE Type, PVOID Ptr, PCSTR File, UINT Line);
VOID DebugUnregisterAllocation (ALLOCTYPE Type, PVOID Ptr);
#define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
#define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
#define ALLOCATION_INLINE_CALL , File, Line

extern PCSTR g_TrackComment;
extern INT g_UseCount;
extern PCSTR g_TrackFile;
extern UINT g_TrackLine;
DWORD SetTrackComment (PCSTR Msg, PCSTR File, UINT Line);
DWORD ClrTrackComment (VOID);
VOID  DisableTrackComment (VOID);
VOID  EnableTrackComment (VOID);
#define SETTRACKCOMMENT(RetType, Msg,File,Line) ((RetType)(SetTrackComment(Msg,File,Line) | (UINT_PTR) (
#define CLRTRACKCOMMENT                         ) | ClrTrackComment()))

#define SETTRACKCOMMENT_VOID(Msg,File,Line)     SetTrackComment(Msg,File,Line), (
#define CLRTRACKCOMMENT_VOID                    ), ClrTrackComment()

#define DISABLETRACKCOMMENT()                   DisableTrackComment()
#define ENABLETRACKCOMMENT()                    EnableTrackComment()

VOID InitLog (BOOL DeleteLog);

//
// Memory debug option
//

#define MemAlloc(heap,flags,size) DebugHeapAlloc(__FILE__,__LINE__,heap,flags,size)
#define MemReAlloc(heap,flags,ptr,size) DebugHeapReAlloc(__FILE__,__LINE__,heap,flags,ptr,size)
#define MemFree(heap,flags,ptr) DebugHeapFree(__FILE__,__LINE__,heap,flags,ptr)
#define MemCheck(heap) DebugHeapCheck(__FILE__,__LINE__,heap)

PVOID DebugHeapAlloc (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, SIZE_T Size);
PVOID DebugHeapReAlloc (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, PCVOID pMem, SIZE_T Size);
BOOL DebugHeapFree (PCSTR File, DWORD Line, HANDLE hHeap, DWORD dwFlags, PCVOID pMem);
VOID DebugHeapCheck (PCSTR File, DWORD Line, HANDLE hHeap);

void DumpHeapStats ();

#else

//
// No-debug constants
//

#define SETTRACKCOMMENT(RetType,Msg,File,Line)
#define CLRTRACKCOMMENT
#define SETTRACKCOMMENT_VOID(Msg,File,Line)
#define CLRTRACKCOMMENT_VOID
#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define MemAlloc SafeHeapAlloc
#define MemReAlloc SafeHeapReAlloc
#define MemFree(x,y,z) HeapFree(x,y,(LPVOID) z)
#define MemCheck(x)

#define DebugHeapCheck(x,y,z)
#define DumpHeapStats()

#define ALLOCATION_TRACKING_DEF
#define ALLOCATION_TRACKING_CALL
#define ALLOCATION_INLINE_CALL
#define InitAllocationTracking()
#define FreeAllocationTracking()
#define DebugRegisterAllocation(t,p,f,l)
#define DebugUnregisterAllocation(t,p)

#endif

#define MemAllocUninit(size)    MemAlloc(g_hHeap,0,size)
#define MemAllocZeroed(size)    MemAlloc(g_hHeap,HEAP_ZERO_MEMORY,size)
#define FreeMem(ptr)            MemFree(g_hHeap,0,ptr)




#ifdef _cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\fileenum.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fileenum.h

Abstract:

    Declares interface for callback-based file enumeration.  The
    file enumerator has several capabilities, such as directory-
    first or directory-last enumeration, enumeration depth limiting,
    suppression of files or directories, and a global hook ability.

    This is *OLD CODE* changed significantly by MikeCo.  And because
    of the callback interface, it is overly complex.

    ** Do not use these routines in new Win9x upgrade code.
       Instead, see file.h for much better routines.

    There is one handy routine in here: DeleteDirectoryContents

Author:

    Jim Schmidt (jimschm) 03-Dec-1996

Revision History:

    mikeco  ??-???-1997     Ran code through train_wreck.exe

--*/


#ifndef _FILEENUM_H
#define _FILEENUM_H

//
// Callback typedef -> return FALSE if enumeration should stop
//

typedef INT  (CALLBACK * FILEENUMPROCA)(LPCSTR szFullFileSpec,
                                        LPCSTR szDestFileSpec,
                                        WIN32_FIND_DATAA *pFindData,
                                        DWORD EnumTreeID,
                                        LPVOID pParam,
                                        PDWORD CurrentDirData
                                        );

typedef INT  (CALLBACK * FILEENUMPROCW)(LPCWSTR szFullFileSpec,
                                        LPCWSTR szDestFileSpec,
                                        WIN32_FIND_DATAW *pFindData,
                                        DWORD EnumTreeID,
                                        LPVOID pParam,
                                        PDWORD CurrentDirData
                                        );

//
// Failure-reporting callbacks -- sink the names of paths that
// fail for reasons of length or code-page incompatibility
//
typedef VOID (CALLBACK * FILEENUMFAILPROCA) (LPCSTR szFailPath);

typedef VOID (CALLBACK * FILEENUMFAILPROCW) (LPCWSTR szFailPath);

//
// CopyTree flags. If neither COPYTREE_DOCOPY or COPYTREE_DOMOVE is
// passed in, the CopyTree functions will just enumerate.
//

#define COPYTREE_DOCOPY         0x0001
#define COPYTREE_NOOVERWRITE    0x0002
#define COPYTREE_DOMOVE         0x0004
#define COPYTREE_DODELETE       0x0008
#define COPYTREE_IGNORE_ERRORS  0x0010

//
// Level flags
//

#define ENUM_ALL_LEVELS         0
#define ENUM_THIS_DIRECTORY     1
#define ENUM_MAX_LEVELS         MAX_PATH

//
// Filter flags
//

#define FILTER_DIRECTORIES      0x0001
#define FILTER_FILES            0x0002
#define FILTER_DIRS_LAST        0x0004
#define FILTER_ALL              (FILTER_DIRECTORIES|FILTER_FILES)
#define FILTER_ALL_DIRS_LAST    (FILTER_DIRECTORIES|FILTER_FILES|FILTER_DIRS_LAST)

//
// Callback return values
//
#define CALLBACK_DO_NOT_RECURSE_THIS_DIRECTORY (-3)
#define CALLBACK_FAILED             (-2)
#define CALLBACK_SUBDIR_DONE        (-1)
#define CALLBACK_CONTINUE           (0)
#define CALLBACK_THIS_LEVEL_ONLY    (1)

//
// CopyTree parameter block
//

#include <pshpack1.h>
typedef struct COPYTREE_PARAMS_STRUCTA
{
    LPCSTR szEnumRootInWack;            // Root of source tree
    LPCSTR szEnumRootOutWack;           // Root of target tree
    CHAR szFullFileSpecOut[MAX_MBCHAR_PATH];   // Proposed target filespec (callback may change)
    int nCharsInRootInWack;
    int nCharsInRootOutWack;
    DWORD flags;
    FILEENUMPROCA pfnCallback;
} COPYTREE_PARAMSA, *PCOPYTREE_PARAMSA;

typedef struct COPYTREE_PARAMS_STRUCTW
{
    LPCWSTR szEnumRootInWack;
    LPCWSTR szEnumRootOutWack;
    WCHAR szFullFileSpecOut[MAX_WCHAR_PATH * 2];
    int nCharsInRootInWack;
    int nCharsInRootOutWack;
    DWORD flags;
    FILEENUMPROCW pfnCallback;
} COPYTREE_PARAMSW, *PCOPYTREE_PARAMSW;
#include <poppack.h>


//
// Exported functions from FILEENUM.DLL
//

//
// EnumerateAllDrives first builds an exclusion list if an exclusion INF path
// is provided, and then enumerates every file on every drive that is not
// excluded.  The callback function is called once per file.  The pParam
// parameter is passed to the callback.
//
// fnEnumCallback     - A pointer to your callback function
// EnumTreeID         - A value used to identify the exclusion list
//                      (see GenerateEnumID)
// pParam             - LPVOID passed to callback function
// szExclusionInfPath - Path to INF file containing exclusions
// szPathSection      - A string that identifies the path exclusion
//                      section in the INF.
// szFileSection      - A string that identifies the file exclusion
//                      section in the INF.
//

typedef struct {
    LPCSTR ExclusionInfPath;
    LPCSTR PathSection;
    LPCSTR FileSection;
} EXCLUDEINFA, *PEXCLUDEINFA;

typedef struct {
    LPCWSTR ExclusionInfPath;
    LPCWSTR PathSection;
    LPCWSTR FileSection;
} EXCLUDEINFW, *PEXCLUDEINFW;

BOOL
EnumerateAllDrivesA (
                     IN  FILEENUMPROCA fnEnumCallback,
                     IN  FILEENUMFAILPROCA fnFailCallback,  OPTIONAL
                     IN  DWORD EnumTreeID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFA ExcludeInfStruct,     OPTIONAL
                     IN  DWORD AttributeFilter
                     );

BOOL
EnumerateAllDrivesW (
                     IN  FILEENUMPROCW fnEnumCallback,
                     IN  FILEENUMFAILPROCW fnFailCallback,  OPTIONAL
                     IN  DWORD EnumTreeID,
                     IN  LPVOID pParam,
                     IN  PEXCLUDEINFW ExcludeInfStruct,     OPTIONAL
                     IN  DWORD AttributeFilter
                     );

//
// EnumerateTree is similar to EnumarateAllDrives, except it allows you to
// enumerate a specific drive, or a specific subdir on a drive.  Supply the
// drive letter and optional subdirectory in szEnumRoot.  Before enumerating,
// EnumerateTree will first build an exclusion list if an exclusion INF path
// is provided.  Then every file below szEnumRoot is enumerated, and the
// callback is called once per file, passing pParam unchanged.
//
// szEnumRoot         - Drive and optional path to enumerate
// fnEnumCallback     - A pointer to your callback function
// fnFailCallback     - A pointer to optional callback that logs a path
//                      that be enumerated due to length or other reason.
// EnumTreeID         - A value used to identify the exclusion list
//                      (see GenerateEnumID)
// pParam             - LPVOID passed to callback function
// szExclusionInfPath - Path to INF file containing exclusions
// szPathSection      - A string that identifies the path exclusion
//                      section in the INF.
// szFileSection      - A string that identifies the file exclusion
//                      section in the INF.
//

BOOL
EnumerateTreeA (
                IN  LPCSTR szEnumRoot,
                IN  FILEENUMPROCA fnEnumCallback,
                IN  FILEENUMFAILPROCA fnFailCallback,
                IN  DWORD EnumTreeID,
                IN  LPVOID pParam,
                IN  DWORD  Level,
                IN  PEXCLUDEINFA ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                );

BOOL
EnumerateTreeW (
                IN  LPCWSTR szEnumRoot,
                IN  FILEENUMPROCW fnEnumCallback,
                IN  FILEENUMFAILPROCW fnFailCallback,
                IN  DWORD EnumTreeID,
                IN  LPVOID pParam,
                IN  DWORD  Level,
                IN  PEXCLUDEINFW ExcludeInfStruct,      OPTIONAL
                IN  DWORD AttributeFilter
                );


//
// ClearExclusions removes all enumaration exclusions.  It is called
// automatically at the end of enumeration when an exclusion INF file is
// used.  Use it when you need to programmatically build an exclusion list
// with ExcludePath and ExcludeFile.
//
// You can combine programmatic exclusions with an exclusion INF file, but
// beware that the programmatic exclusions will be cleared after
// EnumarteAllDrives or EnumerateTree completes.
//
// If you do not use an INF, the programmatic exclusions will NOT
// automatically be cleared.  This allows you to build exclusions and
// enumerate multiple times without having to rebuild the exclusion
// list.
//
// EnumTreeID    - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
//

void
ClearExclusionsA (DWORD EnumTreeID);

void
ClearExclusionsW (DWORD EnumTreeID);



//
// ExcludePath adds a path name to the exclusion list.  There are two
// cases:
//
//  1. If a drive letter is supplied, the exclusion will apply only to
//     that drive letter and path.  (Path may be only a drive letter,
//     colon and backslash to exclude an entire drive.)
//  2. If the path does not begin with a drive letter, it is considered
//     relative, and any occurance of the path will be excluded, regardless
//     of drive letter and parent directory.
//
// The dot and double-dot directories are not supported.  The entire path
// specification may contain wildcard characters.  (For example, ?:\ indicates
// any drive letter.)
//
// EnumTreeID  - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
// szPath        - The path specification as described above
//

void
ExcludePathA (
              IN  DWORD EnumTreeID,
              IN  LPCSTR szPath
              );

void
ExcludePathW (
              IN  DWORD EnumTreeID,
              IN  LPCWSTR szPath
              );

//
// ExcludeFile adds a file name to the exclusion list.  There are two
// cases:
//
// 1. If a drive letter is supplied, the exclusion will only apply to that
//    drive letter, path and file.
// 2. If the path does not begin with a drive letter, any occurance of the file
//    or path/file will be excluded, regardless of drive letter and
//    parent directory.
//
// Both the path and file name may contain wildcard characters.
//
// EnumTreeID    - The value that identifies the enumeration exclusion list
//                 (See GenerateEnumID)
// szFile        - The file specification as described above
//

void
ExcludeFileA (
              IN  DWORD EnumTreeID,
              IN  LPCSTR szFile
              );

void
ExcludeFileW (
              IN  DWORD EnumTreeID,
              IN  LPCWSTR szFile
              );


BOOL
IsPathExcludedA (
    DWORD EnumID,
    PCSTR Path
    );

BOOL
IsPathExcludedW (
    DWORD EnumID,
    PCWSTR Path
    );


//
//
// BuildExclusionsFromInf adds all of the files and paths in the specified exclude.inf into
// the memdb under the specified EnumId.
//
//

BOOL
BuildExclusionsFromInfW (
    IN DWORD EnumID,
    IN PEXCLUDEINFW ExcludeInfStruct
    );

BOOL
BuildExclusionsFromInfA (
    IN DWORD EnumID,
    IN PEXCLUDEINFA ExcludeInfStruct
    );



//
// GenerateEnumID returns a unique DWORD that an application may use to
// build an exclusion list.  While use of this function is not technically
// required, it is provided to allow multiple threads to obtain a unique
// value.  If one caller uses this function, all callers must as well.
//

DWORD
GenerateEnumID ();


//
// CopyTree enumerates a tree and optionally copies or moves its files
// to another location.  The caller is responsible to see that the source
// and target trees are disjoint. (If not, the results could be uncool.)
//
// The callback function can veto a copy or move by returning FALSE,
// or change the target destination by modifying the szFullFileSpecOut
// string in the COPY_PARAMS block, and returning TRUE.
//

BOOL
CopyTreeA(
    IN  LPCSTR szEnumRootIn,
    IN  LPCSTR szEnumRootOut,
    IN  DWORD EnumTreeID,
    IN  DWORD dwFlags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFA ExcludeInfStruct,      OPTIONAL
    IN  FILEENUMPROCA pfnCallback,          OPTIONAL
    IN  FILEENUMFAILPROCA pfnFailCallback   OPTIONAL
    );

BOOL
CopyTreeW(
    IN  LPCWSTR szEnumRootIn,
    IN  LPCWSTR szEnumRootOut,
    IN  DWORD EnumTreeID,
    IN  DWORD dwFlags,
    IN  DWORD Levels,
    IN  DWORD AttributeFilter,
    IN  PEXCLUDEINFW ExcludeInfStruct,    OPTIONAL
    IN  FILEENUMPROCW pfnCallback,        OPTIONAL
    IN  FILEENUMFAILPROCW pfnFailCallback OPTIONAL
    );


#define DeleteDirectoryContentsA(dir) CopyTreeA(dir,NULL,0,COPYTREE_DODELETE,\
                                                ENUM_ALL_LEVELS,FILTER_ALL_DIRS_LAST,\
                                                NULL,NULL,NULL)

#define DeleteDirectoryContentsW(dir) CopyTreeW(dir,NULL,0,COPYTREE_DODELETE,\
                                                ENUM_ALL_LEVELS,FILTER_ALL_DIRS_LAST,\
                                                NULL,NULL,NULL)


DWORD
GetShellLinkPath(
                IN  HWND hwnd,
                IN  LPCTSTR tszLinkFile,
                OUT LPTSTR tszPath);

HRESULT
SetShellLinkPath(
                IN  HWND hwnd,
                IN  LPCTSTR tszLinkFile,
                IN  LPCTSTR tszPath);

DWORD
CreateEmptyDirectoryA (
    PCSTR Dir
    );


DWORD
CreateEmptyDirectoryW (
    PCWSTR Dir
    );

#ifdef UNICODE

#define EnumerateAllDrives EnumerateAllDrivesW
#define EnumerateTree EnumerateTreeW
#define ExcludePath ExcludePathW
#define ExcludeFile ExcludeFileW
#define BuildExclusionsFromInf BuildExclusionsFromInfW
#define CopyTree CopyTreeW
#define IsPathExcluded IsPathExcludedW
#define ClearExclusions ClearExclusionsW
#define COPYTREE_PARAMS COPYTREE_PARAMSW
#define PCOPYTREE_PARAMS PCOPYTREE_PARAMSW
#define FILEENUMPROC FILEENUMPROCW
#define FILEENUMFAILPROC FILEENUMFAILPROCW
#define EXCLUDEINF EXCLUDEINFW
#define PEXCLUDEINF PEXCLUDEINFW
#define DeleteDirectoryContents DeleteDirectoryContentsW
#define CreateEmptyDirectory CreateEmptyDirectoryW

#else

#define EnumerateAllDrives EnumerateAllDrivesA
#define EnumerateTree EnumerateTreeA
#define ExcludePath ExcludePathA
#define ExcludeFile ExcludeFileA
#define IsPathExcluded IsPathExcludedA
#define BuildExclusionsFromInf BuildExclusionsFromInfA
#define CopyTree CopyTreeA
#define ClearExclusions ClearExclusionsA
#define COPYTREE_PARAMS COPYTREE_PARAMSA
#define PCOPYTREE_PARAMS PCOPYTREE_PARAMSA
#define FILEENUMPROC FILEENUMPROCA
#define FILEENUMFAILPROC FILEENUMFAILPROCA
#define EXCLUDEINF EXCLUDEINFA
#define PEXCLUDEINF PEXCLUDEINFA
#define DeleteDirectoryContents DeleteDirectoryContentsA
#define CreateEmptyDirectory CreateEmptyDirectoryA

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\fileops.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    fileops.h

Abstract:

    Declares the file operation data structures and macros that access
    the file operations.  Every operation on a file is recorded using
    routines declared here.  The file op code keeps conflicting operations
    from being set on a file.

    See common\memdb\fileops.c for implementation details.

Author:

    Jim Schmidt (jimschm) 23-Sep-1998   (complete redesign)

Revision History:

    mvander     26-Map-1999 Added MODULESTATUS defines

--*/

#pragma once

/*++

Macro Expansion List Description:

   PATH_OPERATIONS defines a list of characteristics for operations that
   can be performed on a file.

   Some operation combinations are prohibited.  See the code in fileops.c
   for a list of prohibited combinations.

   NOTES: - THERE CAN ONLY BE A MAX OF 16 DEFINITIONS!!
          - THE BITS MUST BE SORTED!!
          - CANNOT HAVE UNUSED BITS INBETWEEN OPERATIONS!!

Line Syntax:

   DEFMAC(Bit, Name, CooperativeOperations, MaxProperties)

Arguments:

    Bit - Specifies the single bit (MUST FIT IN 24 BITS), in sorted order

    Name - Specifies the name of the operation constant (will appear in
           OPERATION enum type)

    MemDbName - Specifies the name as stored in memdb

    MaxProperties - Specifies 0, 1 or UNLIMITED, indicating the number of
                    properties that can be applied to the operation

Variables and Types Generated From List:

   OPERATION
   g_OperationFlags

--*/

#define PATH_OPERATIONS        \
        DEFMAC(0x0001, OPERATION_FILE_DELETE, Op01, 0)                \
        DEFMAC(0x0002, OPERATION_FILE_DELETE_EXTERNAL, Op02, 0)       \
        DEFMAC(0x0004, OPERATION_FILE_MOVE, Op03, 1)                  \
        DEFMAC(0x0008, OPERATION_FILE_COPY, Op04, UNLIMITED)          \
        DEFMAC(0x0010, OPERATION_FILE_MOVE_EXTERNAL, Op05, 1)         \
        DEFMAC(0x0020, OPERATION_CLEANUP, Op06, 0)                    \
        DEFMAC(0x0040, OPERATION_MIGDLL_HANDLED, Op07, 0)             \
        DEFMAC(0x0080, OPERATION_CREATE_FILE, Op08, 0)                \
        DEFMAC(0x0100, OPERATION_SHORT_FILE_NAME, Op09, 1)            \
        DEFMAC(0x0200, OPERATION_LINK_EDIT, Op10, UNLIMITED)          \
        DEFMAC(0x0400, OPERATION_SHELL_FOLDER, Op11, UNLIMITED)       \
        DEFMAC(0x0800, OPERATION_TEMP_PATH, Op12, 2)                  \
        DEFMAC(0x1000, OPERATION_FILE_MOVE_BY_NT, Op13, 1)            \
        DEFMAC(0x2000, OPERATION_FILE_MOVE_SHELL_FOLDER, Op14, 1)     \
        DEFMAC(0x4000, OPERATION_PRESERVED_DIR, Op15, 0)              \
        DEFMAC(0x8000, OPERATION_OS_FILE, Op16, 0)                    \
        DEFMAC(0x010000, OPERATION_FILE_DISABLED, Op17, 0)            \
        DEFMAC(0x020000, OPERATION_LINK_STUB, Op18, UNLIMITED)        \
        DEFMAC(0x040000, OPERATION_LONG_FILE_NAME, Op19, 0)           \
        DEFMAC(0x080000, OPERATION_CHANGE_EXTERNAL, Op20, 0)          \
        DEFMAC(0x100000, OPERATION_NUL_3, Opn3, 0)                    \
        DEFMAC(0x200000, OPERATION_NUL_2, Opn2, 0)                    \
        DEFMAC(0x400000, OPERATION_NUL_1, Opn1, 0)                    \


//
// Combined constants
//

#define ALL_MOVE_OPERATIONS             (OPERATION_FILE_MOVE|OPERATION_FILE_MOVE_EXTERNAL|OPERATION_FILE_MOVE_BY_NT|OPERATION_FILE_MOVE_SHELL_FOLDER)
#define ALL_COPY_OPERATIONS             (OPERATION_FILE_COPY)
#define ALL_DELETE_OPERATIONS           (OPERATION_FILE_DELETE|OPERATION_CLEANUP|OPERATION_FILE_DELETE_EXTERNAL)
#define ALL_OPERATIONS                  (0xffffff)
#define ALL_DEST_CHANGE_OPERATIONS      (ALL_MOVE_OPERATIONS|ALL_COPY_OPERATIONS)
#define ALL_CHANGE_OPERATIONS           (OPERATION_FILE_DISABLED|OPERATION_LINK_EDIT|OPERATION_LINK_STUB|OPERATION_CREATE_FILE|ALL_DEST_CHANGE_OPERATIONS|ALL_DELETE_OPERATIONS|OPERATION_CHANGE_EXTERNAL)
#define ALL_CONTENT_CHANGE_OPERATIONS   (ALL_DELETE_OPERATIONS|OPERATION_MIGDLL_HANDLED|OPERATION_CREATE_FILE|OPERATION_LINK_EDIT|OPERATION_LINK_STUB|OPERATION_FILE_DISABLED|OPERATION_CHANGE_EXTERNAL)

//
// Declare OPERATION type
//

#define DEFMAC(bit,name,memdbname,maxattribs)   name = bit,

typedef enum {
    PATH_OPERATIONS
    LAST_OPERATION
} OPERATION;

#undef DEFMAC

#define INVALID_SEQUENCER       0

//
// File status flags returned by GetFileInfoOnNt and GetFileStatusOnNt
//

#define FILESTATUS_UNCHANGED        0x00
#define FILESTATUS_DELETED          0x01
#define FILESTATUS_MOVED            0x02
#define FILESTATUS_REPLACED         0x04
#define FILESTATUS_NTINSTALLED      0x08
#define FILESTATUS_BACKUP           0x10

//
// Backup flags (for CleanOut memdb category)
//

#define BACKUP_FILE                 0
#define BACKUP_SUBDIRECTORY_FILES   1
#define BACKUP_SUBDIRECTORY_TREE    2
#define BACKUP_AND_CLEAN_TREE       3
#define BACKUP_AND_CLEAN_SUBDIR     4


//
// When a file is announced, it can be announced with one of the following.
//
#define ACT_UNKNOWN             0
#define ACT_REINSTALL           1           // application that needs to be reinstalled
#define ACT_MINORPROBLEMS       2           // application with minor problems
#define ACT_INCOMPATIBLE        3           // incompatible application - migdb based
#define ACT_INC_SAFETY          4           // items removed for safety
#define ACT_INC_NOBADAPPS       5           // incompatible application - no CheckBadApps entry
#define ACT_REINSTALL_BLOCK     6           // application that needs to be reinstalled (highly suggested)
#define ACT_INC_PREINSTUTIL     7           // incompatible preinstalled utility
#define ACT_INC_SIMILAROSFUNC   8           // incompatible utility but NT has similar functionality
#define ACT_INC_IHVUTIL         9           // incompatible hardware accessory


#define USF_9X      TEXT("9X")
#define USF_9XA     "9X"
#define USF_9XW     L"9X"

#define USF_NT      TEXT("NT")
#define USF_NTA     "NT"
#define USF_NTW     L"NT"

//
// Module status for use with MEMDB_CATEGORY_MODULE_CHECK
//

#define MODULESTATUS_NT_MODULE    0
#define MODULESTATUS_CHECKED      1
#define MODULESTATUS_CHECKING     2
#define MODULESTATUS_UNCHECKED    3
#define MODULESTATUS_BAD          4
#define MODULESTATUS_FILENOTFOUND 5





//
// Enum types
//

typedef struct {
    // External members
    CHAR Path[MAX_MBCHAR_PATH];
    UINT Sequencer;

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_ENUMA, *PFILEOP_ENUMA;

typedef struct {
    // External members
    WCHAR Path[MAX_WCHAR_PATH];
    UINT Sequencer;

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_ENUMW, *PFILEOP_ENUMW;

typedef struct {
    // External members
    CHAR Property[MEMDB_MAX * 2];
    CHAR PropertyName[MEMDB_MAX * 2];

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_PROP_ENUMA, *PFILEOP_PROP_ENUMA;

typedef struct {
    // External members
    WCHAR Property[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    // Internal members
    MEMDB_ENUMW MemDbEnum;
} FILEOP_PROP_ENUMW, *PFILEOP_PROP_ENUMW;


typedef struct {
    // External
    PCWSTR Path;
    UINT Sequencer;
    PCWSTR Property;
    UINT PropertyNum;
    OPERATION CurrentOperation;
    BOOL PropertyValid;

    // Internal
    UINT State;
    DWORD Operations;
    UINT OperationNum;
    WCHAR FileSpec[MAX_WCHAR_PATH];
    FILEOP_ENUMW OpEnum;
    FILEOP_PROP_ENUMW PropEnum;
} ALL_FILEOPS_ENUMW, *PALL_FILEOPS_ENUMW;

typedef struct {
    // External
    CHAR Path[MAX_MBCHAR_PATH];
    UINT Sequencer;
    CHAR Property[MEMDB_MAX * 2];
    UINT PropertyNum;
    OPERATION CurrentOperation;
    BOOL PropertyValid;

    // Internal
    ALL_FILEOPS_ENUMW Enum;
} ALL_FILEOPS_ENUMA, *PALL_FILEOPS_ENUMA;

typedef struct _SHELLFOLDER_ENUMA {
    CHAR  ShellFolder[MEMDB_MAX];
    PCSTR UserFixedName;
    PCSTR Side;
    MEMDB_ENUMA e;
} SHELLFOLDER_ENUMA, *PSHELLFOLDER_ENUMA;

typedef struct _SHELLFOLDER_ENUMW {
    WCHAR  ShellFolder[MEMDB_MAX];
    PCWSTR UserFixedName;
    PCWSTR Side;
    MEMDB_ENUMW e;
} SHELLFOLDER_ENUMW, *PSHELLFOLDER_ENUMW;

typedef struct {
    CHAR SrcFile[MAX_MBCHAR_PATH];
    CHAR DestFile[MAX_MBCHAR_PATH];

    ALL_FILEOPS_ENUMA e;
} FILERELOC_ENUMA, *PFILERELOC_ENUMA;

//
// Generalized file operations
//

VOID
InitOperationTable (
    VOID
    );

UINT
AddOperationToPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

UINT
AddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );


BOOL
AddPropertyToPathExA (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCSTR Property,
    IN      PCSTR AlternateDataSection      OPTIONAL
    );

#define AddPropertyToPathA(seq,op,attr)        AddPropertyToPathExA(seq,op,attr,NULL)

BOOL
AddPropertyToPathExW (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      PCWSTR AlternateDataSection     OPTIONAL
    );

#define AddPropertyToPathW(seq,op,attr)        AddPropertyToPathExW(seq,op,attr,NULL)


BOOL
AssociatePropertyWithPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCSTR Property
    );

BOOL
AssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property
    );


UINT
GetSequencerFromPathA (
    IN      PCSTR FileSpec
    );

UINT
GetSequencerFromPathW (
    IN      PCWSTR FileSpec
    );


BOOL
GetPathFromSequencerA (
    IN      UINT Sequencer,
    OUT     PSTR PathBuf
    );

BOOL
GetPathFromSequencerW (
    IN      UINT Sequencer,
    OUT     PWSTR PathBuf
    );


DWORD
GetOperationsOnPathA (
    IN      PCSTR FileSpec
    );

DWORD
GetOperationsOnPathW (
    IN      PCWSTR FileSpec
    );


VOID
RemoveOperationsFromSequencer (
    IN      UINT Sequencer,
    IN      DWORD Operations
    );

VOID
RemoveOperationsFromPathA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    );

#define RemoveAllOperationsFromPathA(file)      RemoveOperationsFromPathA(file,ALL_OPERATIONS)

VOID
RemoveOperationsFromPathW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );

#define RemoveAllOperationsFromPathW(file)      RemoveOperationsFromPathW(file,ALL_OPERATIONS)


UINT
ForceOperationOnPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

UINT
ForceOperationOnPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );


BOOL
IsFileMarkedForOperationA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    );

BOOL
IsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );


BOOL
IsFileMarkedInDataA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedInDataW (
    IN      PCWSTR FileSpec
    );


DWORD
GetPathPropertyOffset (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      DWORD Property
    );


BOOL
GetPathPropertyA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PSTR PropertyBuf           OPTIONAL        // MEMDB_MAX
    );

BOOL
GetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL        // MEMDB_MAX
    );


BOOL
EnumFirstPathInOperationA (
    OUT     PFILEOP_ENUMA EnumPtr,
    IN      OPERATION Operation
    );

BOOL
EnumFirstPathInOperationW (
    OUT     PFILEOP_ENUMW EnumPtr,
    IN      OPERATION Operation
    );


BOOL
EnumNextPathInOperationA (
    IN OUT  PFILEOP_ENUMA EnumPtr
    );

BOOL
EnumNextPathInOperationW (
    IN OUT  PFILEOP_ENUMW EnumPtr
    );


BOOL
EnumFirstFileOpPropertyA (
    OUT     PFILEOP_PROP_ENUMA EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    );

BOOL
EnumFirstFileOpPropertyW (
    OUT     PFILEOP_PROP_ENUMW EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    );


BOOL
EnumNextFileOpPropertyA (
    IN OUT  PFILEOP_PROP_ENUMA EnumPtr
    );

BOOL
EnumNextFileOpPropertyW (
    IN OUT  PFILEOP_PROP_ENUMW EnumPtr
    );


BOOL
EnumFirstFileOpA (
    OUT     PALL_FILEOPS_ENUMA EnumPtr,
    IN      DWORD Operations,
    IN      PCSTR FileSpec                      OPTIONAL
    );

BOOL
EnumFirstFileOpW (
    OUT     PALL_FILEOPS_ENUMW EnumPtr,
    IN      DWORD Operations,
    IN      PCWSTR FileSpec                     OPTIONAL
    );


BOOL
EnumNextFileOpA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    );

BOOL
EnumNextFileOpW (
    IN OUT  PALL_FILEOPS_ENUMW EnumPtr
    );


BOOL
TestPathsForOperationsA (
    IN      PCSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    );

BOOL
TestPathsForOperationsW (
    IN      PCWSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    );


BOOL
IsFileMarkedForAnnounceA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedAsKnownGoodA (
    IN      PCSTR FileSpec
    );

BOOL
IsFileMarkedForAnnounceW (
    IN      PCWSTR FileSpec
    );

DWORD
GetFileAnnouncementA (
    IN      PCSTR FileSpec
    );

DWORD
GetFileAnnouncementW (
    IN      PCWSTR FileSpec
    );

DWORD
GetFileAnnouncementContextA (
    IN      PCSTR FileSpec
    );

DWORD
GetFileAnnouncementContextW (
    IN      PCWSTR FileSpec
    );


BOOL
IsFileProvidedByNtA (
    IN      PCSTR FileName
    );

BOOL
IsFileProvidedByNtW (
    IN      PCWSTR FileName
    );


BOOL
GetNewPathForFileA (
    IN      PCSTR SrcFileSpec,
    OUT     PSTR NewPath
    );

BOOL
GetNewPathForFileW (
    IN      PCWSTR SrcFileSpec,
    OUT     PWSTR NewPath
    );


BOOL
AnnounceFileInReportA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr,
    IN      DWORD  Action
    );

BOOL
MarkFileAsKnownGoodA (
    IN      PCSTR SrcFileSpec
    );


BOOL
AddCompatibleShellA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddCompatibleRunKeyA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddCompatibleDosA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
AddControlPanelAppletA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr,               OPTIONAL
    IN      DWORD Action
    );

BOOL
AddCompatibleHlpA (
    IN      PCSTR SrcFileSpec,
    IN      DWORD ContextPtr
    );


BOOL
MarkFileForTemporaryMoveExA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile
    );

#define MarkFileForTemporaryMoveA(s,d,t) MarkFileForTemporaryMoveExA(s,d,t,FALSE)


PCSTR
GetTemporaryLocationForFileA (
    IN      PCSTR SourceFile
    );


PCWSTR
GetTemporaryLocationForFileW (
    IN      PCWSTR SourceFile
    );


BOOL
MarkHiveForTemporaryMoveA (
    IN      PCSTR HivePath,
    IN      PCSTR TempDir,
    IN      PCSTR UserName,
    IN      BOOL DefaultHives,
    IN      BOOL CreateOnly
    );


VOID
ComputeTemporaryPathA (
    IN      PCSTR SourcePath,
    IN      PCSTR SourcePrefix,     OPTIONAL
    IN      PCSTR TempPrefix,       OPTIONAL
    IN      PCSTR SetupTempDir,
    OUT     PSTR TempPath
    );

VOID
MarkShellFolderForMoveA (
    IN      PCSTR SrcPath,
    IN      PCSTR TempPath
    );


BOOL
FileIsProvidedByNtA (
    IN      PCSTR FullPath,
    IN      PCSTR FileName,
    IN      DWORD UserFlags
    );


BOOL
DeclareTemporaryFileA (
    IN      PCSTR FileSpec
    );

BOOL
DeclareTemporaryFileW (
    IN      PCWSTR FileSpec
    );


BOOL
EnumFirstFileRelocA (
    OUT     PFILERELOC_ENUMA EnumPtr,
    IN      PCSTR FileSpec              OPTIONAL
    );

BOOL
EnumNextFileRelocA (
    IN OUT  PFILERELOC_ENUMA EnumPtr
    );


BOOL
GetNtFilePathA (
    IN      PCSTR FileName,
    OUT     PSTR FullPath
    );

BOOL
GetNtFilePathW (
    IN      PCWSTR FileName,
    OUT     PWSTR FullPath
    );


DWORD
GetFileInfoOnNtA (
    IN      PCSTR FileName,
    OUT     PSTR  NewFileName,  // optional
    IN      UINT  BufferSize    // required if NewFileName is specified, buffer size in chars
    );

DWORD
GetFileInfoOnNtW (
    IN      PCWSTR FileName,
    OUT     PWSTR  NewFileName,  // optional
    IN      UINT   BufferSize    // required if NewFileName is specified, buffer size in chars
    );


DWORD
GetFileStatusOnNtA (
    IN      PCSTR FileName
    );

DWORD
GetFileStatusOnNtW (
    IN      PCWSTR FileName
    );


PSTR
GetPathStringOnNtA (
    IN      PCSTR FileName
    );

PWSTR
GetPathStringOnNtW (
    IN      PCWSTR FileName
    );


PCWSTR
SetCurrentUserW (
    IN      PCWSTR User
    );


PCSTR
ExtractArgZeroExA (
    IN      PCSTR CmdLine,
    OUT     PSTR Buffer,
    IN      PCSTR TerminatingChars,         OPTIONAL
    IN      BOOL KeepQuotes
    );

#define ExtractArgZeroA(cmdline,buf)        ExtractArgZeroExA(cmdline,buf,NULL,TRUE)

PCWSTR
ExtractArgZeroExW (
    IN      PCWSTR CmdLine,
    OUT     PWSTR Buffer,
    IN      PCWSTR TerminatingChars,        OPTIONAL
    IN      BOOL KeepQuotes
    );

#define ExtractArgZeroW(cmdline,buf)        ExtractArgZeroExW(cmdline,buf,NULL,TRUE)

BOOL
CanSetOperationA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    );

BOOL
CanSetOperationW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    );

PCSTR
GetSourceFileLongNameA (
    IN      PCSTR ShortName
    );

PCWSTR
GetSourceFileLongNameW (
    IN      PCWSTR ShortName
    );

BOOL
WriteBackupFilesA (
    IN      BOOL Win9xSide,
    IN      PCSTR TempDir,
    OUT     ULARGE_INTEGER * OutAmountOfSpaceIfCompressed,  OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpace,              OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceForDelFiles,   OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceClusterAligned OPTIONAL
    );

BOOL
WriteHashTableToFileW (
    IN HANDLE File,
    IN HASHTABLE FileTable
    );

BOOL
IsDirEmptyW(
     IN      PCWSTR DirPathPtr
     );

BOOL
IsDirEmptyA(
     IN      PCSTR DirPathPtr
     );

VOID
AddDirPathToEmptyDirsCategoryA(
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    );

VOID
AddDirPathToEmptyDirsCategoryW(
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    );
//
// Wrapper macros
//

#define IsFileMarkedForPreDeleteA(file)             IsFileMarkedForOperationA(file, OPERATION_FILE_DELETE)
#define IsFileMarkedForPreDeleteW(file)             IsFileMarkedForOperationW(file, OPERATION_FILE_DELETE)

#define IsFileMarkedForPostDeleteA(file)            IsFileMarkedForOperationA(file, OPERATION_CLEANUP)
#define IsFileMarkedForPostDeleteW(file)            IsFileMarkedForOperationW(file, OPERATION_CLEANUP)

#define IsFileMarkedForDeleteA(file)                IsFileMarkedForOperationA(file, ALL_DELETE_OPERATIONS)
#define IsFileMarkedForDeleteW(file)                IsFileMarkedForOperationW(file, ALL_DELETE_OPERATIONS)

#define IsFileMarkedAsDestA(file)                   IsFileMarkedInDataA(file)
#define IsFileMarkedAsDestW(file)                   IsFileMarkedInDataW(file)

#define IsFileMarkedAsCopyA(file)                   IsFileMarkedForOperationA(file, OPERATION_FILE_COPY)
#define IsFileMarkedAsCopyW(file)                   IsFileMarkedForOperationW(file, OPERATION_FILE_COPY)

#define IsFileMarkedForMoveA(file)                  IsFileMarkedForOperationA(file, ALL_MOVE_OPERATIONS)
#define IsFileMarkedForMoveW(file)                  IsFileMarkedForOperationW(file, ALL_MOVE_OPERATIONS)

#define IsFileMarkedAsHandledA(file)                IsFileMarkedForOperationA(file, OPERATION_MIGDLL_HANDLED)
#define IsFileMarkedAsHandledW(file)                IsFileMarkedForOperationW(file, OPERATION_MIGDLL_HANDLED)

#define IsFileMarkedForChangeA(file)                IsFileMarkedForOperationA(file, ALL_OPERATIONS)
#define IsFileMarkedForChangeW(file)                IsFileMarkedForOperationW(file, ALL_OPERATIONS)

#define IsFileMarkedForCreationA(file)              IsFileMarkedForOperationA(file, OPERATION_CREATE_FILE)
#define IsFileMarkedForCreationW(file)              IsFileMarkedForOperationW(file, OPERATION_CREATE_FILE)

#define IsDirectoryMarkedAsEmptyA(file)             IsFileMarkedForOperationA(file, OPERATION_PRESERVED_DIR)
#define IsDirectoryMarkedAsEmptyW(file)             IsFileMarkedForOperationW(file, OPERATION_PRESERVED_DIR)

#define IsFileMarkedAsOsFileA(file)                 IsFileMarkedForOperationA(file, OPERATION_OS_FILE)
#define IsFileMarkedAsOsFileW(file)                 IsFileMarkedForOperationW(file, OPERATION_OS_FILE)

#define IsFileDisabledA(file)                       IsFileMarkedForOperationA(file, OPERATION_FILE_DISABLED)
#define IsFileDisabledW(file)                       IsFileMarkedForOperationW(file, OPERATION_FILE_DISABLED)

#define IsFileMarkedForBackupA(file)                IsFileMarkedForOperationA(file, OPERATION_CHANGE_EXTERNAL)
#define IsFileMarkedForBackupW(file)                IsFileMarkedForOperationW(file, OPERATION_CHANGE_EXTERNAL)

#define MarkFileForDeleteA(file)                    (AddOperationToPathA(file, OPERATION_FILE_DELETE) != INVALID_SEQUENCER)
#define MarkFileForExternalDeleteA(file)            (AddOperationToPathA(file, OPERATION_FILE_DELETE_EXTERNAL) != INVALID_SEQUENCER)
#define MarkFileForMoveA(source,dest)               AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE, dest)
#define MarkFileForCopyA(source,dest)               AssociatePropertyWithPathA(source, OPERATION_FILE_COPY, dest)
#define MarkFileForMoveExternalA(source,dest)       AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_EXTERNAL, dest)
#define MarkFileForShellFolderMoveA(source,dest)    AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_SHELL_FOLDER, dest)
#define MarkFileForMoveByNtA(source,dest)           AssociatePropertyWithPathA(source, OPERATION_FILE_MOVE_BY_NT, dest)
#define MarkFileForCleanUpA(file)                   (AddOperationToPathA(file, OPERATION_CLEANUP) != INVALID_SEQUENCER)
#define MarkPathAsHandledA(path)                    (AddOperationToPathA(path, OPERATION_MIGDLL_HANDLED) != INVALID_SEQUENCER)
#define MarkFileForCreationA(path)                  (AddOperationToPathA(path, OPERATION_CREATE_FILE) != INVALID_SEQUENCER)
#define MarkDirectoryAsPreservedA(file)             (AddOperationToPathA(file, OPERATION_PRESERVED_DIR) != INVALID_SEQUENCER)
#define MarkFileAsOsFileA(file)                     (AddOperationToPathA(file, OPERATION_OS_FILE) != INVALID_SEQUENCER)
#define MarkFileForBackupA(file)                    (AddOperationToPathA(file, OPERATION_CHANGE_EXTERNAL) != INVALID_SEQUENCER)
#define DisableFileA(file)                          (AddOperationToPathA(file, OPERATION_FILE_DISABLED) != INVALID_SEQUENCER)

#define MarkFileForDeleteW(file)                    (AddOperationToPathW(file, OPERATION_FILE_DELETE) != INVALID_SEQUENCER)
#define MarkFileForExternalDeleteW(file)            (AddOperationToPathW(file, OPERATION_FILE_DELETE_EXTERNAL) != INVALID_SEQUENCER)
#define MarkFileForMoveW(source,dest)               AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE, dest)
#define MarkFileForCopyW(source,dest)               AssociatePropertyWithPathW(source, OPERATION_FILE_COPY, dest)
#define MarkFileForMoveExternalW(source,dest)       AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_EXTERNAL, dest)
#define MarkFileForShellFolderMoveW(source,dest)    AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_SHELL_FOLDER, dest)
#define MarkFileForMoveByNtW(source,dest)           AssociatePropertyWithPathW(source, OPERATION_FILE_MOVE_BY_NT, dest)
#define MarkFileForCleanUpW(file)                   (AddOperationToPathW(file, OPERATION_CLEANUP) != INVALID_SEQUENCER)
#define MarkPathAsHandledW(path)                    (AddOperationToPathW(path, OPERATION_MIGDLL_HANDLED) != INVALID_SEQUENCER)
#define MarkFileForCreationW(path)                  (AddOperationToPathW(path, OPERATION_CREATE_FILE) != INVALID_SEQUENCER)
#define MarkDirectoryAsPreservedW(file)             (AddOperationToPathW(file, OPERATION_PRESERVED_DIR) != INVALID_SEQUENCER)
#define MarkFileAsOsFileW(file)                     (AddOperationToPathW(file, OPERATION_OS_FILE) != INVALID_SEQUENCER)
#define MarkFileForBackupW(file)                    (AddOperationToPathW(file, OPERATION_CHANGE_EXTERNAL) != INVALID_SEQUENCER)
#define DisableFileW(file)                          (AddOperationToPathW(file, OPERATION_FILE_DISABLED) != INVALID_SEQUENCER)


#ifndef UNICODE

#define FILEOP_ENUM                             FILEOP_ENUMA
#define FILEOP_PROP_ENUM                        FILEOP_PROP_ENUMA
#define ALL_FILEOPS_ENUM                        ALL_FILEOPS_ENUMA
#define SHELLFOLDER_ENUM                        SHELLFOLDER_ENUMA
#define FILERELOC_ENUM                          FILERELOC_ENUMA

#define AddOperationToPath                      AddOperationToPathA
#define AddPropertyToPathEx                     AddPropertyToPathExA
#define AssociatePropertyWithPath               AssociatePropertyWithPathA
#define GetSequencerFromPath                    GetSequencerFromPathA
#define GetPathFromSequencer                    GetPathFromSequencerA
#define GetOperationsOnPath                     GetOperationsOnPathA
#define RemoveOperationsFromPath                RemoveOperationsFromPathA
#define IsFileMarkedForOperation                IsFileMarkedForOperationA
#define IsFileMarkedInData                      IsFileMarkedInDataA
#define GetPathProperty                         GetPathPropertyA
#define EnumFirstPathInOperation                EnumFirstPathInOperationA
#define EnumNextPathInOperation                 EnumNextPathInOperationA
#define EnumFirstFileOpProperty                 EnumFirstFileOpPropertyA
#define EnumNextFileOpProperty                  EnumNextFileOpPropertyA
#define EnumFirstFileOp                         EnumFirstFileOpA
#define EnumNextFileOp                          EnumNextFileOpA
#define TestPathsForOperations                  TestPathsForOperationsA
#define IsFileMarkedForAnnounce                 IsFileMarkedForAnnounceA
#define GetFileAnnouncement                     GetFileAnnouncementA
#define GetFileAnnouncementContext              GetFileAnnouncementContextA
#define IsFileMarkedAsKnownGood                 IsFileMarkedAsKnownGoodA
#define IsFileProvidedByNt                      IsFileProvidedByNtA
#define GetNewPathForFile                       GetNewPathForFileA
#define AnnounceFileInReport                    AnnounceFileInReportA
#define MarkFileAsKnownGood                     MarkFileAsKnownGoodA
#define AddCompatibleShell                      AddCompatibleShellA
#define AddCompatibleRunKey                     AddCompatibleRunKeyA
#define AddCompatibleDos                        AddCompatibleDosA
#define AddControlPanelApplet                   AddControlPanelAppletA
#define AddCompatibleHlp                        AddCompatibleHlpA
#define MarkFileForTemporaryMove                MarkFileForTemporaryMoveA
#define MarkFileForTemporaryMoveEx              MarkFileForTemporaryMoveExA
#define GetTemporaryLocationForFile             GetTemporaryLocationForFileA
#define MarkHiveForTemporaryMove                MarkHiveForTemporaryMoveA
#define ComputeTemporaryPath                    ComputeTemporaryPathA
#define MarkShellFolderForMove                  MarkShellFolderForMoveA
#define FileIsProvidedByNt                      FileIsProvidedByNtA
#define DeclareTemporaryFile                    DeclareTemporaryFileA
#define EnumFirstFileReloc                      EnumFirstFileRelocA
#define EnumNextFileReloc                       EnumNextFileRelocA
#define GetNtFilePath                           GetNtFilePathA
#define GetFileInfoOnNt                         GetFileInfoOnNtA
#define GetFileStatusOnNt                       GetFileStatusOnNtA
#define GetPathStringOnNt                       GetPathStringOnNtA
#define ExtractArgZeroEx                        ExtractArgZeroExA
#define IsFileMarkedForPreDelete                IsFileMarkedForPreDeleteA
#define IsFileMarkedForPostDelete               IsFileMarkedForPostDeleteA
#define IsFileMarkedForDelete                   IsFileMarkedForDeleteA
#define IsFileMarkedAsDest                      IsFileMarkedAsDestA
#define IsFileMarkedAsCopy                      IsFileMarkedAsCopyA
#define IsFileMarkedForMove                     IsFileMarkedForMoveA
#define IsFileMarkedAsHandled                   IsFileMarkedAsHandledA
#define IsFileMarkedForChange                   IsFileMarkedForChangeA
#define IsFileMarkedForCreation                 IsFileMarkedForCreationA
#define IsDirectoryMarkedAsEmpty                IsDirectoryMarkedAsEmptyA
#define MarkFileForDelete                       MarkFileForDeleteA
#define MarkFileForExternalDelete               MarkFileForExternalDeleteA
#define MarkFileForMove                         MarkFileForMoveA
#define MarkFileForCopy                         MarkFileForCopyA
#define MarkFileForMoveExternal                 MarkFileForMoveExternalA
#define MarkFileForShellFolderMove              MarkFileForShellFolderMoveA
#define MarkFileForMoveByNt                     MarkFileForMoveByNtA
#define MarkFileForCleanUp                      MarkFileForCleanUpA
#define MarkPathAsHandled                       MarkPathAsHandledA
#define MarkFileForCreation                     MarkFileForCreationA
#define MarkDirectoryAsPreserved                MarkDirectoryAsPreservedA
#define ExtractArgZero                          ExtractArgZeroA
#define AddPropertyToPath                       AddPropertyToPathA
#define RemoveAllOperationsFromPath             RemoveAllOperationsFromPathA
#define ForceOperationOnPath                    ForceOperationOnPathA
#define MarkFileAsOsFile                        MarkFileAsOsFileA
#define MarkFileForBackup                       MarkFileForBackupA
#define IsFileMarkedAsOsFile                    IsFileMarkedAsOsFileA
#define DisableFile                             DisableFileA
#define IsFileDisabled                          IsFileDisabledA
#define IsFileMarkedForBackup                   IsFileMarkedForBackupA
#define CanSetOperation                         CanSetOperationA
#define GetSourceFileLongName                   GetSourceFileLongNameA
#define IsDirEmpty                              IsDirEmptyA
#define AddDirPathToEmptyDirsCategory           AddDirPathToEmptyDirsCategoryA

#else

#define FILEOP_ENUM                             FILEOP_ENUMW
#define FILEOP_PROP_ENUM                        FILEOP_PROP_ENUMW
#define ALL_FILEOPS_ENUM                        ALL_FILEOPS_ENUMW
#define SHELLFOLDER_ENUM                        SHELLFOLDER_ENUMW
#define FILERELOC_ENUM                          FILERELOC_ENUMW

#define AddOperationToPath                      AddOperationToPathW
#define AddPropertyToPathEx                     AddPropertyToPathExW
#define AssociatePropertyWithPath               AssociatePropertyWithPathW
#define GetSequencerFromPath                    GetSequencerFromPathW
#define GetPathFromSequencer                    GetPathFromSequencerW
#define GetOperationsOnPath                     GetOperationsOnPathW
#define RemoveOperationsFromPath                RemoveOperationsFromPathW
#define IsFileMarkedForOperation                IsFileMarkedForOperationW
#define IsFileMarkedInData                      IsFileMarkedInDataW
#define GetPathProperty                         GetPathPropertyW
#define EnumFirstPathInOperation                EnumFirstPathInOperationW
#define EnumNextPathInOperation                 EnumNextPathInOperationW
#define EnumFirstFileOpProperty                 EnumFirstFileOpPropertyW
#define EnumNextFileOpProperty                  EnumNextFileOpPropertyW
#define EnumFirstFileOp                         EnumFirstFileOpW
#define EnumNextFileOp                          EnumNextFileOpW
#define TestPathsForOperations                  TestPathsForOperationsW
#define IsFileMarkedForAnnounce                 IsFileMarkedForAnnounceW
#define GetFileAnnouncement                     GetFileAnnouncementW
#define GetFileAnnouncementContext              GetFileAnnouncementContextW
#define IsFileProvidedByNt                      IsFileProvidedByNtW
#define GetNewPathForFile                       GetNewPathForFileW
#define GetTemporaryLocationForFile             GetTemporaryLocationForFileW
#define DeclareTemporaryFile                    DeclareTemporaryFileW
#define GetNtFilePath                           GetNtFilePathW
#define GetFileInfoOnNt                         GetFileInfoOnNtW
#define GetFileStatusOnNt                       GetFileStatusOnNtW
#define GetPathStringOnNt                       GetPathStringOnNtW
#define ExtractArgZeroEx                        ExtractArgZeroExW
#define IsFileMarkedForPreDelete                IsFileMarkedForPreDeleteW
#define IsFileMarkedForPostDelete               IsFileMarkedForPostDeleteW
#define IsFileMarkedForDelete                   IsFileMarkedForDeleteW
#define IsFileMarkedAsDest                      IsFileMarkedAsDestW
#define IsFileMarkedAsCopy                      IsFileMarkedAsCopyW
#define IsFileMarkedForMove                     IsFileMarkedForMoveW
#define IsFileMarkedAsHandled                   IsFileMarkedAsHandledW
#define IsFileMarkedForChange                   IsFileMarkedForChangeW
#define IsFileMarkedForCreation                 IsFileMarkedForCreationW
#define IsDirectoryMarkedAsEmpty                IsDirectoryMarkedAsEmptyW
#define MarkFileForDelete                       MarkFileForDeleteW
#define MarkFileForExternalDelete               MarkFileForExternalDeleteW
#define MarkFileForMove                         MarkFileForMoveW
#define MarkFileForCopy                         MarkFileForCopyW
#define MarkFileForMoveExternal                 MarkFileForMoveExternalW
#define MarkFileForShellFolderMove              MarkFileForShellFolderMoveW
#define MarkFileForMoveByNt                     MarkFileForMoveByNtW
#define MarkFileForCleanUp                      MarkFileForCleanUpW
#define MarkPathAsHandled                       MarkPathAsHandledW
#define MarkFileForCreation                     MarkFileForCreationW
#define MarkDirectoryAsPreserved                MarkDirectoryAsPreservedW
#define RecordSrcFromDest                       RecordSrcFromDestW
#define ExtractArgZero                          ExtractArgZeroW
#define AddPropertyToPath                       AddPropertyToPathW
#define RemoveAllOperationsFromPath             RemoveAllOperationsFromPathW
#define ForceOperationOnPath                    ForceOperationOnPathW
#define MarkFileAsOsFile                        MarkFileAsOsFileW
#define MarkFileForBackup                       MarkFileForBackupW
#define IsFileMarkedAsOsFile                    IsFileMarkedAsOsFileW
#define DisableFile                             DisableFileW
#define IsFileDisabled                          IsFileDisabledW
#define IsFileMarkedForBackup                   IsFileMarkedForBackupW
#define CanSetOperation                         CanSetOperationW
#define GetSourceFileLongName                   GetSourceFileLongNameW
#define IsDirEmpty                              IsDirEmptyW
#define AddDirPathToEmptyDirsCategory           AddDirPathToEmptyDirsCategoryW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\file.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    file.h

Abstract:

    Declares interfaces for routines that simplify access to the
    file system.  These include:

    - Dealing with short/long file names on both Win9x and NT in a
      single binary
    - Checking for file existance
    - Forcing creation of a path
    - Packing files on a floppy (for research and data gathering purposes)
    - WriteFileString wrapper to simplify WriteFile of a string

Author:

    Jim Schmidt (jimschm) 13-Feb-1997

Revision History:

    jimschm 21-Jan-1999     Centralized cmd line parser
    marcw   15-May-1998     Packed file enum

--*/


#pragma once

#define INVALID_ATTRIBUTES      0xffffffff

BOOL
IsPathLengthOkA (
    IN      PCSTR FileSpec
    );

BOOL
IsPathLengthOkW (
    IN      PCWSTR FileSpec
    );

BOOL
OurGetLongPathNameA (
    IN      PCSTR ShortPath,
    OUT     PSTR Buffer,
    IN      INT BufferSizeInBytes
    );

BOOL
OurGetLongPathNameW (
    IN      PCWSTR ShortPath,
    OUT     PWSTR Buffer,
    IN      INT BufferSizeInChars
    );

DWORD
OurGetShortPathNameW (
    PCWSTR LongPath,
    PWSTR ShortPath,
    DWORD Size
    );

#define OurGetShortPathNameA    GetShortPathNameA

DWORD
OurGetFullPathNameW (
    PCWSTR FileName,
    DWORD Size,
    PWSTR FullPath,
    PWSTR *FilePtr
    );

#define OurGetFullPathNameA    GetFullPathNameA

BOOL
CopyFileSpecToLongA(
    IN      PCSTR FullFileSpecIn,
    OUT     PSTR OutPath
    );

BOOL
CopyFileSpecToLongW(
    IN      PCWSTR FullFileSpecIn,
    OUT     PWSTR OutPath
    );

BOOL
DoesFileExistExA(
    IN      PCSTR Path,
    OUT     PWIN32_FIND_DATAA FindData  OPTIONAL
    );

#define DoesFileExistA(x) DoesFileExistExA (x, NULL)

BOOL
DoesFileExistExW(
    IN      PCWSTR Path,
    OUT     PWIN32_FIND_DATAW FindData  OPTIONAL
    );

#define DoesFileExistW(x) DoesFileExistExW (x, NULL)

DWORD
MakeSurePathExistsA(
    IN LPCSTR szPath,
    IN BOOL   PathOnly
    );

DWORD
MakeSurePathExistsW(
    IN LPCWSTR szPath,
    IN BOOL    PathOnly
    );


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    );

BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    );


typedef struct {
    HANDLE FindHandle;
    WIN32_FIND_DATAA FindData;
    PSTR SavedEndOfFileBuffer;
    PSTR SavedEndOfPattern;
} FIND_DATAA, *PFIND_DATAA;

typedef struct {
    HANDLE FindHandle;
    WIN32_FIND_DATAW FindData;
    PWSTR SavedEndOfFileBuffer;
    PWSTR SavedEndOfPattern;
} FIND_DATAW, *PFIND_DATAW;

#define FILE_ENUM_ALL_LEVELS     0
#define FILE_ENUM_THIS_LEVEL     1

typedef enum {
    TREE_ENUM_INIT,
    TREE_ENUM_BEGIN,
    TREE_ENUM_FILES_BEGIN,
    TREE_ENUM_RETURN_ITEM,
    TREE_ENUM_FILES_NEXT,
    TREE_ENUM_DIRS_BEGIN,
    TREE_ENUM_DIRS_NEXT,
    TREE_ENUM_DIRS_FILTER,
    TREE_ENUM_PUSH,
    TREE_ENUM_POP,
    TREE_ENUM_DONE,
    TREE_ENUM_FAILED,
    TREE_ENUM_CLEANED_UP
} TREE_ENUM_STATE;

typedef struct {
    //
    // Enumerated items
    //

    PCSTR Name;
    PCSTR SubPath;
    PCSTR FullPath;
    PWIN32_FIND_DATAA FindData;
    BOOL Directory;
    UINT Level;
    UINT MaxLevel;

    //
    // Enumeration state -- private
    //

    BOOL EnumDirsFirst;
    BOOL EnumDepthFirst;
    CHAR RootPath[MAX_MBCHAR_PATH];
    UINT RootPathSize;
    CHAR Pattern[MAX_MBCHAR_PATH];
    PSTR EndOfPattern;
    CHAR FilePattern[MAX_MBCHAR_PATH];
    UINT FilePatternSize;
    CHAR FileBuffer[MAX_MBCHAR_PATH];
    PSTR EndOfFileBuffer;
    TREE_ENUM_STATE State;
    GROWBUFFER FindDataArray;
    PFIND_DATAA Current;
} TREE_ENUMA, *PTREE_ENUMA;

typedef struct {
    //
    // Enumerated items
    //

    PCWSTR Name;
    PCWSTR SubPath;
    PCWSTR FullPath;
    PWIN32_FIND_DATAW FindData;
    BOOL Directory;
    UINT Level;
    UINT MaxLevel;

    //
    // Enumeration state -- private
    //

    BOOL EnumDirsFirst;
    BOOL EnumDepthFirst;
    WCHAR RootPath[MAX_PATH * 2];
    UINT RootPathSize;
    WCHAR Pattern[MAX_PATH * 2];
    PWSTR EndOfPattern;
    WCHAR FilePattern[MAX_PATH * 2];
    UINT FilePatternSize;
    WCHAR FileBuffer[MAX_PATH * 2];
    PWSTR EndOfFileBuffer;
    TREE_ENUM_STATE State;
    GROWBUFFER FindDataArray;
    PFIND_DATAW Current;
} TREE_ENUMW, *PTREE_ENUMW;

BOOL
EnumFirstFileInTreeExA (
    OUT     PTREE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    );

BOOL
EnumNextFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

VOID
AbortEnumFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

#define EnumFirstFileInTreeA(ptr, path, pattern, dirfirst)  EnumFirstFileInTreeExA((ptr), (path), (pattern), (dirfirst), FALSE, FILE_ENUM_ALL_LEVELS)


BOOL
EnumFirstFileInTreeExW (
    OUT     PTREE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    );

BOOL
EnumNextFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    );

VOID
AbortEnumFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    );

#define EnumFirstFileInTreeW(ptr, path, pattern, dirfirst)  EnumFirstFileInTreeExW((ptr), (path), (pattern), (dirfirst), FALSE, FILE_ENUM_ALL_LEVELS)

VOID
AbortEnumCurrentDirA (
    IN OUT  PTREE_ENUMA EnumPtr
    );

VOID
AbortEnumCurrentDirW (
    IN OUT  PTREE_ENUMW EnumPtr
    );


typedef struct {
    PCSTR FileName;
    PCSTR FullPath;
    BOOL Directory;

    HANDLE Handle;
    CHAR RootPath[MAX_MBCHAR_PATH];
    PSTR EndOfRoot;
    HANDLE Enum;
    WIN32_FIND_DATAA fd;
} FILE_ENUMA, *PFILE_ENUMA;

typedef struct {
    PCWSTR FileName;
    PCWSTR FullPath;
    BOOL Directory;

    HANDLE Handle;
    WCHAR RootPath[MAX_WCHAR_PATH];
    PWSTR EndOfRoot;
    HANDLE Enum;
    WIN32_FIND_DATAW fd;
} FILE_ENUMW, *PFILE_ENUMW;

BOOL
EnumFirstFileA (
    OUT     PFILE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern           OPTIONAL
    );

BOOL
EnumFirstFileW (
    OUT     PFILE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern           OPTIONAL
    );

BOOL
EnumNextFileA (
    IN OUT  PFILE_ENUMA EnumPtr
    );

BOOL
EnumNextFileW (
    IN OUT  PFILE_ENUMW EnumPtr
    );

VOID
AbortFileEnumA (
    IN OUT  PFILE_ENUMA EnumPtr
    );

VOID
AbortFileEnumW (
    IN OUT  PFILE_ENUMW EnumPtr
    );


BOOL
ExtractIconImageFromFileA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,          // OPTIONAL if file is an ICO file
    IN OUT  PGROWBUFFER Buffer
    );

BOOL
ExtractIconImageFromFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,          // OPTIONAL if file is an ICO file
    IN OUT  PGROWBUFFER Buffer
    );


BOOL
ExtractIconImageFromFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    );

BOOL
ExtractIconImageFromFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    );


BOOL
WriteIconImageArrayToIcoFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    );

BOOL
WriteIconImageArrayToIcoFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    );


BOOL
WriteIconImageArrayToPeFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId
    );

BOOL
WriteIconImageArrayToPeFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId
    );


BOOL
WriteIconImageArrayToPeFileExA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER IconImageArray,
    IN      PCSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    );

BOOL
WriteIconImageArrayToPeFileExW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER IconImageArray,
    IN      PCWSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    );


BOOL
WriteIconImageArrayToIcoFileEx (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File
    );


PCSTR
ExtractIconNamesFromFileA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    );

PCWSTR
ExtractIconNamesFromFileW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    );


PCSTR
ExtractIconNamesFromFileExA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    );

PCWSTR
ExtractIconNamesFromFileExW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    );


BOOL
IsFileAnIcoA (
    IN      PCSTR FileInQuestion
    );

BOOL
IsFileAnIcoW (
    IN      PCWSTR FileInQuestion
    );


typedef struct {
    WORD GroupId;
    WORD IconId;
    GROWBUFFER IconImages;
    GROWBUFFER IconList;
    CHAR DestFile[MAX_MBCHAR_PATH];
    HANDLE Module;
    HANDLE Module16;
    CHAR ModuleName[MAX_MBCHAR_PATH];
    HANDLE IcoFile;
    CHAR IcoFileName[MAX_MBCHAR_PATH];
    HANDLE Update;
    CHAR IconImageFileName[MAX_MBCHAR_PATH];
    HANDLE IconImageFile;
    BOOL SaveMode;
    BOOL Error;
} ICON_EXTRACT_CONTEXTA, *PICON_EXTRACT_CONTEXTA;

typedef struct {
    WORD GroupId;
    WORD IconId;
    GROWBUFFER IconImages;
    GROWBUFFER IconList;
    WCHAR DestFile[MAX_WCHAR_PATH];
    HANDLE Module;
    HANDLE Module16;
    WCHAR ModuleName[MAX_WCHAR_PATH];
    HANDLE IcoFile;
    WCHAR IcoFileName[MAX_WCHAR_PATH];
    HANDLE Update;
    WCHAR IconImageFileName[MAX_WCHAR_PATH];
    HANDLE IconImageFile;
    BOOL SaveMode;
    BOOL Error;
} ICON_EXTRACT_CONTEXTW, *PICON_EXTRACT_CONTEXTW;


BOOL
BeginIconExtractionA (
    OUT     PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR DestFile                      OPTIONAL
    );

BOOL
BeginIconExtractionW (
    OUT     PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR DestFile                     OPTIONAL
    );


BOOL
OpenIconImageFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileName,
    IN      BOOL SaveMode
    );

BOOL
OpenIconImageFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileName,
    IN      BOOL SaveMode
    );

BOOL
CopyIconA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,           OPTIONAL
    IN      PCSTR IconId,                       OPTIONAL
    IN      INT IconIndex                       OPTIONAL
    );

BOOL
CopyIconW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,          OPTIONAL
    IN      PCWSTR IconId,                      OPTIONAL
    IN      INT IconIndex                       OPTIONAL
    );


BOOL
CopyAllIconsA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcons
    );

BOOL
CopyAllIconsW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcons
    );


BOOL
EndIconExtractionA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context
    );

BOOL
EndIconExtractionW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context
    );



//
// New Executable resource access
//

HANDLE
OpenNeFileA (
    PCSTR FileName
    );

HANDLE
OpenNeFileW (
    PCWSTR FileName
    );

VOID
CloseNeFile (
    HANDLE Handle
    );

//
// Once upon a time ENUMRESTYPEPROC was defined as a TCHAR prototype,
// which was broken.  If ENUMRESTYPEPROCA isn't defined, we'll define
// it.  (NOTE: The current winbase.h has these typedefs.)
//

#ifndef ENUMRESTYPEPROCA

#if 0
typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam);

#endif

//
//          to be consistent with winbase.h, the second arg is non-const.  But that's
//          actually a bug in winbase.h.
//

typedef BOOL (CALLBACK* ENUMRESTYPEPROCA)(HMODULE hModule, PSTR lpType, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCW)(HMODULE hModule, PWSTR lpType, LONG_PTR lParam);

//
// These two prototypes are OK
//

typedef BOOL (CALLBACK* ENUMRESNAMEPROCA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam);

#endif

BOOL
EnumNeResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
EnumNeResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );


BOOL
EnumNeResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    );

BOOL
EnumNeResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    );




DWORD
SizeofNeResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

DWORD
SizeofNeResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );

PBYTE
FindNeResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    );

PBYTE
FindNeResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    );


#define FindNeResourceA(h,n,t) FindNeResourceExA(h,t,n)
#define FindNeResourceW(h,n,t) FindNeResourceExW(h,t,n)


#pragma pack(push, 1)

#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_NE_SIGNATURE              0x454E      // NE
#define IMAGE_PE_SIGNATURE              0x00004550l // PE00

typedef struct _DOS_HEADER {  // DOS .EXE header
    WORD e_magic;           // Magic number
    WORD e_cblp;            // Bytes on last page of file
    WORD e_cp;              // Pages in file
    WORD e_crlc;            // Relocations
    WORD e_cparhdr;         // Size of header in paragraphs
    WORD e_minalloc;        // Minimum extra paragraphs needed
    WORD e_maxalloc;        // Maximum extra paragraphs needed
    WORD e_ss;              // Initial (relative) SS value
    WORD e_sp;              // Initial SP value
    WORD e_csum;            // Checksum
    WORD e_ip;              // Initial IP value
    WORD e_cs;              // Initial (relative) CS value
    WORD e_lfarlc;          // File address of relocation table
    WORD e_ovno;            // Overlay number
    WORD e_res[4];          // Reserved words
    WORD e_oemid;           // OEM identifier (for e_oeminfo)
    WORD e_oeminfo;         // OEM information; e_oemid specific
    WORD e_res2[10];        // Reserved words
    LONG e_lfanew;          // File address of new exe header
} DOS_HEADER, *PDOS_HEADER;

typedef struct {
    WORD Signature;                             // 00h
    BYTE LinkerVersion;                         // 02h
    BYTE LinkerRevision;                        // 03h
    WORD OffsetToEntryTable;                    // 04h
    WORD LengthOfEntryTable;                    // 06h
    DWORD Reserved;                             // 08h
    WORD Flags;                                 // 0ch
    WORD AutoDataSegment;                       // 0eh
    WORD LocalHeapSize;                         // 10h
    WORD StackSize;                             // 12h
    DWORD EntryAddress;                         // 14h
    DWORD StackAddress;                         // 18h
    WORD SegmentTableEntries;                   // 1ch
    WORD ModuleReferenceTableEntries;           // 1eh
    WORD NonResidentTableSize;                  // 20h
    WORD OffsetToSegmentTable;                  // 22h
    WORD OffsetToResourceTable;                 // 24h
    WORD OffsetToResidentNameTable;             // 26h
    WORD OffsetToModuleReferenceTable;          // 28h
    WORD OffsetToImportedNameTable;             // 2ah
    WORD OffsetToNonResidentNameTable;          // 2ch
    WORD Unused;                                // 2eh
    WORD MovableEntryPoints;                    // 30h
    WORD LogicalSectorShiftCount;               // 32h
    WORD ResourceSegments;                      // 34h
    BYTE TargetOS;                              // 36h
    BYTE AdditionalFlags;                       // 37h
    WORD FastLoadOffset;                        // 38h
    WORD SectorsInFastLoad;                     // 3ah
    WORD Reserved2;                             // 3ch
    WORD WindowsVersion;                        // 3eh
} NE_INFO_BLOCK, *PNE_INFO_BLOCK;


typedef struct {
    WORD Offset;
    WORD Length;
    WORD Flags;
    WORD Id;
    WORD Handle;
    WORD Usage;
} NE_RES_NAMEINFO, *PNE_RES_NAMEINFO;

#pragma warning(push)
#pragma warning(disable:4200) 

typedef struct {
    WORD TypeId;
    WORD ResourceCount;
    DWORD Reserved;
    NE_RES_NAMEINFO NameInfo[];
} NE_RES_TYPEINFO, *PNE_RES_TYPEINFO;

#pragma warning(pop)

#pragma pack(pop)

typedef struct {
    WORD AlignShift;
    GROWLIST TypeInfoArray;
    GROWLIST ResourceNames;
} NE_RESOURCES, *PNE_RESOURCES;


BOOL
LoadNeHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    );

BOOL
LoadNeResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    );

VOID
FreeNeResources (
    PNE_RESOURCES Resources
    );

PVOID
MapFileIntoMemoryExA (
    IN      PCSTR   FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR  FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL    WriteAccess
    );

#define MapFileIntoMemoryA(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExA(FileName,FileHandle,MapHandle,FALSE)
#define MapFileIntoMemoryW(FileName,FileHandle,MapHandle)   MapFileIntoMemoryExW(FileName,FileHandle,MapHandle,FALSE)

BOOL
UnmapFile (
    IN PVOID  FileImage,
    IN HANDLE MapHandle,
    IN HANDLE FileHandle
    );


BOOL
RemoveCompleteDirectoryA (
    IN      PCSTR Dir
    );

BOOL
RemoveCompleteDirectoryW (
    IN      PCWSTR Dir
    );

typedef struct {
    PCSTR OriginalArg;
    PCSTR CleanedUpArg;
    DWORD Attributes;
    BOOL Quoted;
} CMDLINEARGA, *PCMDLINEARGA;

#pragma warning(push)
#pragma warning(disable:4200) 

typedef struct {
    PCSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGA Args[];
} CMDLINEA, *PCMDLINEA;

typedef struct {
    PCWSTR OriginalArg;
    PCWSTR CleanedUpArg;
    DWORD Attributes;
    BOOL Quoted;
} CMDLINEARGW, *PCMDLINEARGW;

typedef struct {
    PCWSTR CmdLine;
    UINT ArgCount;
    CMDLINEARGW Args[];
} CMDLINEW, *PCMDLINEW;

#pragma warning(pop)


PCMDLINEA
ParseCmdLineA (
    IN      PCSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    );

PCMDLINEW
ParseCmdLineW (
    IN      PCWSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    );

BOOL GetFileSizeFromFilePathA(
    IN  PCSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    );

BOOL GetFileSizeFromFilePathW(
    IN  PCWSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    );


#define NUMDRIVELETTERS      26
#define UNKNOWN_DRIVE        '?'

typedef struct {

    CHAR Letter[NUMDRIVELETTERS];
    BOOL ExistsOnSystem[NUMDRIVELETTERS];
    DWORD Type[NUMDRIVELETTERS];                        // Returned from GetDriveType:
                                                        // DRIVE_FIXED, DRIVE_CDROM or DRIVE_REMOVABLE
    CHAR IdentifierString[NUMDRIVELETTERS][MAX_PATH];   // For caller use

} DRIVELETTERSA, *PDRIVELETTERSA;

typedef struct {

    WCHAR Letter[NUMDRIVELETTERS];
    BOOL ExistsOnSystem[NUMDRIVELETTERS];
    DWORD Type[NUMDRIVELETTERS];                        // Returned from GetDriveType:
                                                        // DRIVE_FIXED, DRIVE_CDROM or DRIVE_REMOVABLE
    WCHAR IdentifierString[NUMDRIVELETTERS][MAX_PATH];  // For caller use

} DRIVELETTERSW, *PDRIVELETTERSW;

VOID
InitializeDriveLetterStructureA (
    OUT     PDRIVELETTERSA DriveLetters
    );

VOID
InitializeDriveLetterStructureW (
    OUT     PDRIVELETTERSW DriveLetters
    );

BOOL
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

BOOL
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    );

DWORD
QuietGetFileAttributesA (
    IN      PCSTR FilePath
    );

DWORD
QuietGetFileAttributesW (
    IN      PCWSTR FilePath
    );

BOOL
IsPathOnFixedDriveA (
    IN      PCSTR FileSpec          OPTIONAL
    );

BOOL
IsPathOnFixedDriveW (
    IN      PCWSTR FileSpec         OPTIONAL
    );

DWORD
MakeSureLongPathExistsW (
    IN      PCWSTR Path,
    IN      BOOL PathOnly
    );

DWORD
SetLongPathAttributesW (
    IN      PCWSTR Path,
    IN      DWORD Attributes
    );

DWORD
GetLongPathAttributesW (
    IN      PCWSTR Path
    );

BOOL
DeleteLongPathW (
    IN      PCWSTR Path
    );


BOOL
RemoveLongDirectoryPathW (
    IN      PCWSTR Path
    );


#ifdef UNICODE

#define MakeSureLongPathExists          MakeSureLongPathExistsW
#define SetLongPathAttributes           SetLongPathAttributesW
#define GetLongPathAttributes           GetLongPathAttributesW
#define DeleteLongPath                  DeleteLongPathW
#define RemoveLongDirectoryPath         RemoveLongDirectoryPathW

#define IsPathLengthOk                  IsPathLengthOkW
#define IsPathLengthOkT                 IsPathLengthOkW
#define OurGetLongPathName              OurGetLongPathNameW
#define OurGetShortPathName             OurGetShortPathNameW
#define OurGetFullPathName              OurGetFullPathNameW
#define CopyFileSpecToLong              CopyFileSpecToLongW
#define DoesFileExist                   DoesFileExistW
#define DoesFileExistEx                 DoesFileExistExW
#define MakeSurePathExists              MakeSurePathExistsW
#define PACKFILEENUM                    PACKFILEENUMW
#define PackedFile_ExtractFileUsingEnum PackedFile_ExtractFileUsingEnumW
#define PackedFile_AddFile              PackedFile_AddFileW
#define PackedFile_ExtractFile          PackedFile_ExtractFileW
#define PackedFile_EnumFirst            PackedFile_EnumFirstW
#define PackedFile_EnumNext             PackedFile_EnumNextW
#define WriteFileString                 WriteFileStringW
#define TREE_ENUM                       TREE_ENUMW
#define PTREE_ENUM                      PTREE_ENUMW
#define FILE_ENUM                       FILE_ENUMW
#define PFILE_ENUM                      PFILE_ENUMW
#define EnumFirstFileInTreeEx           EnumFirstFileInTreeExW
#define EnumFirstFileInTree             EnumFirstFileInTreeW
#define EnumNextFileInTree              EnumNextFileInTreeW
#define AbortEnumFileInTree             AbortEnumFileInTreeW
#define AbortEnumCurrentDir             AbortEnumCurrentDirW
#define EnumFirstFile                   EnumFirstFileW
#define EnumNextFile                    EnumNextFileW
#define AbortFileEnum                   AbortFileEnumW

#define ExtractIconImageFromFile        ExtractIconImageFromFileW
#define ExtractIconImageFromFileEx      ExtractIconImageFromFileExW
#define WriteIconImageArrayToIcoFile    WriteIconImageArrayToIcoFileW
#define WriteIconImageArrayToIcoFileEx  WriteIconImageArrayToIcoFileExW
#define WriteIconImageArrayToPeFile     WriteIconImageArrayToPeFileW
#define WriteIconImageArrayToPeFileEx   WriteIconImageArrayToPeFileExW
#define ExtractIconNamesFromFile        ExtractIconNamesFromFileW
#define ExtractIconNamesFromFileEx      ExtractIconNamesFromFileExW
#define IsFileAnIco                     IsFileAnIcoW
#define ICON_EXTRACT_CONTEXT            ICON_EXTRACT_CONTEXTW
#define PICON_EXTRACT_CONTEXT           PICON_EXTRACT_CONTEXTW
#define BeginIconExtraction             BeginIconExtractionW
#define OpenIconImageFile               OpenIconImageFileW
#define CopyIcon                        CopyIconW
#define CopyAllIcons                    CopyAllIconsW
#define EndIconExtraction               EndIconExtractionW

#define OpenNeFile                      OpenNeFileW
#define EnumNeResourceTypes             EnumNeResourceTypesW
#define EnumNeResourceNames             EnumNeResourceNamesW
#define SizeofNeResource                SizeofNeResourceW
#define FindNeResource                  FindNeResourceW
#define FindNeResourceEx                FindNeResourceExW

#define MapFileIntoMemory               MapFileIntoMemoryW
#define MapFileIntoMemoryEx             MapFileIntoMemoryExW

#define RemoveCompleteDirectory         RemoveCompleteDirectoryW

#define CMDLINE                         CMDLINEW
#define CMDLINEARG                      CMDLINEARGW
#define PCMDLINE                        PCMDLINEW
#define PCMDLINEARG                     PCMDLINEARGW
#define ParseCmdLine                    ParseCmdLineW

#define GetFileSizeFromFilePath         GetFileSizeFromFilePathW

#define GetDiskInfo                     GetDiskInfoW
#define GetIntegrityInfo                GetIntegrityInfoW

#define DRIVELETTERS                    DRIVELETTERSW
#define PDRIVELETTERS                   PDRIVELETTERSW
#define InitializeDriveLetterStructure  InitializeDriveLetterStructureW

#define GetDiskFreeSpaceNew             GetDiskFreeSpaceNewW
#define QuietGetFileAttributes          QuietGetFileAttributesW
#define IsPathOnFixedDrive              IsPathOnFixedDriveW

#else

#define IsPathLengthOk                  IsPathLengthOkA
#define IsPathLengthOkT                 IsPathLengthOkA
#define OurGetLongPathName              OurGetLongPathNameA
#define OurGetShortPathName             OurGetShortPathNameA
#define OurGetFullPathName              OurGetFullPathNameA
#define MakeSurePathExists              MakeSurePathExistsA
#define DoesFileExist                   DoesFileExistA
#define DoesFileExistEx                 DoesFileExistExA
#define CopyFileSpecToLong              CopyFileSpecToLongA
#define PACKFILEENUM                    PACKFILEENUMA
#define PackedFile_ExtractFileUsingEnum PackedFile_ExtractFileUsingEnumA
#define PackedFile_AddFile              PackedFile_AddFileA
#define PackedFile_ExtractFile          PackedFile_ExtractFileA
#define PackedFile_EnumFirst            PackedFile_EnumFirstA
#define PackedFile_EnumNext             PackedFile_EnumNextA
#define WriteFileString                 WriteFileStringA
#define TREE_ENUM                       TREE_ENUMA
#define PTREE_ENUM                      PTREE_ENUMA
#define FILE_ENUM                       FILE_ENUMA
#define PFILE_ENUM                      PFILE_ENUMA
#define EnumFirstFileInTreeEx           EnumFirstFileInTreeExA
#define EnumFirstFileInTree             EnumFirstFileInTreeA
#define EnumNextFileInTree              EnumNextFileInTreeA
#define AbortEnumFileInTree             AbortEnumFileInTreeA
#define AbortEnumCurrentDir             AbortEnumCurrentDirA
#define EnumFirstFile                   EnumFirstFileA
#define EnumNextFile                    EnumNextFileA
#define AbortFileEnum                   AbortFileEnumA

#define ExtractIconImageFromFile        ExtractIconImageFromFileA
#define ExtractIconImageFromFileEx      ExtractIconImageFromFileExA
#define WriteIconImageArrayToIcoFile    WriteIconImageArrayToIcoFileA
#define WriteIconImageArrayToIcoFileEx  WriteIconImageArrayToIcoFileExA
#define WriteIconImageArrayToPeFile     WriteIconImageArrayToPeFileA
#define WriteIconImageArrayToPeFileEx   WriteIconImageArrayToPeFileExA
#define ExtractIconNamesFromFile        ExtractIconNamesFromFileA
#define ExtractIconNamesFromFileEx      ExtractIconNamesFromFileExA
#define IsFileAnIco                     IsFileAnIcoA
#define ICON_EXTRACT_CONTEXT            ICON_EXTRACT_CONTEXTA
#define PICON_EXTRACT_CONTEXT           PICON_EXTRACT_CONTEXTA
#define BeginIconExtraction             BeginIconExtractionA
#define OpenIconImageFile               OpenIconImageFileA
#define CopyIcon                        CopyIconA
#define CopyAllIcons                    CopyAllIconsA
#define EndIconExtraction               EndIconExtractionA

#define OpenNeFile                      OpenNeFileA
#define EnumNeResourceTypes             EnumNeResourceTypesA
#define EnumNeResourceNames             EnumNeResourceNamesA
#define SizeofNeResource                SizeofNeResourceA
#define FindNeResource                  FindNeResourceA
#define FindNeResourceEx                FindNeResourceExA

#define MapFileIntoMemory               MapFileIntoMemoryA
#define MapFileIntoMemoryEx             MapFileIntoMemoryExA

#define RemoveCompleteDirectory         RemoveCompleteDirectoryA

#define CMDLINE                         CMDLINEA
#define CMDLINEARG                      CMDLINEARGA
#define PCMDLINE                        PCMDLINEA
#define PCMDLINEARG                     PCMDLINEARGA
#define ParseCmdLine                    ParseCmdLineA

#define GetFileSizeFromFilePath         GetFileSizeFromFilePathA

#define DRIVELETTERS                    DRIVELETTERSA
#define PDRIVELETTERS                   PDRIVELETTERSA
#define InitializeDriveLetterStructure  InitializeDriveLetterStructureA

#define GetDiskFreeSpaceNew             GetDiskFreeSpaceNewA
#define QuietGetFileAttributes          QuietGetFileAttributesA
#define IsPathOnFixedDrive              IsPathOnFixedDriveA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/



typedef struct {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
} GROWBUFFER, *PGROWBUFFER;

#define GROWBUF_INIT {NULL,0,0,0,0}

PBYTE
RealGrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    );

#define GrowBuffer(buf,size)    SETTRACKCOMMENT(PBYTE,"GrowBuffer",__FILE__,__LINE__)\
                                RealGrowBuffer(buf,size)\
                                CLRTRACKCOMMENT

VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    );


PBYTE
RealGrowBufferReserve (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    );

#define GrowBufferReserve(buf,size)     SETTRACKCOMMENT(PBYTE,"GrowBufferReserve",__FILE__,__LINE__)\
                                        RealGrowBufferReserve(buf,size)\
                                        CLRTRACKCOMMENT
BOOL
RealMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define MultiSzAppendA(buf,str) SETTRACKCOMMENT(BOOL,"MultiSzAppendA",__FILE__,__LINE__)\
                                RealMultiSzAppendA(buf,str)\
                                CLRTRACKCOMMENT

BOOL
RealMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define MultiSzAppendW(buf,str) SETTRACKCOMMENT(BOOL,"MultiSzAppendW",__FILE__,__LINE__)\
                                RealMultiSzAppendW(buf,str)\
                                CLRTRACKCOMMENT

BOOL
RealMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define MultiSzAppendValA(buf,k,v)  SETTRACKCOMMENT(BOOL,"MultiSzAppendValA",__FILE__,__LINE__)\
                                    RealMultiSzAppendValA(buf,k,v)\
                                    CLRTRACKCOMMENT

BOOL
RealMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define MultiSzAppendValW(buf,k,v)  SETTRACKCOMMENT(BOOL,"MultiSzAppendValW",__FILE__,__LINE__)\
                                    RealMultiSzAppendValW(buf,k,v)\
                                    CLRTRACKCOMMENT

BOOL
RealMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define MultiSzAppendStringA(buf,k,v)   SETTRACKCOMMENT(BOOL,"MultiSzAppendStringA",__FILE__,__LINE__)\
                                        RealMultiSzAppendStringA(buf,k,v)\
                                        CLRTRACKCOMMENT

BOOL
RealMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define MultiSzAppendStringW(buf,k,v)   SETTRACKCOMMENT(BOOL,"MultiSzAppendStringW",__FILE__,__LINE__)\
                                        RealMultiSzAppendStringW(buf,k,v)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GrowBufAppendDword(buf,d)   SETTRACKCOMMENT(BOOL,"GrowBufAppendDword",__FILE__,__LINE__)\
                                    RealGrowBufAppendDword(buf,d)\
                                    CLRTRACKCOMMENT


BOOL
RealGrowBufAppendUintPtr (
    PGROWBUFFER GrowBuf,
    UINT_PTR d
    );

#define GrowBufAppendUintPtr(buf,d) SETTRACKCOMMENT(BOOL,"GrowBufAppendUintPtr",__FILE__,__LINE__)\
                                    RealGrowBufAppendUintPtr(buf,d)\
                                    CLRTRACKCOMMENT


BOOL
RealGrowBufAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GrowBufAppendStringA(buf,str)   SETTRACKCOMMENT(BOOL,"GrowBufAppendStringA",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringA(buf,str)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GrowBufAppendStringW(buf,str)   SETTRACKCOMMENT(BOOL,"GrowBufAppendStringW",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringW(buf,str)\
                                        CLRTRACKCOMMENT


BOOL
RealGrowBufAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GrowBufAppendStringABA(buf,a,b) SETTRACKCOMMENT(BOOL,"GrowBufAppendStringABA",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringABA(buf,a,b)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GrowBufAppendStringABW(buf,a,b) SETTRACKCOMMENT(BOOL,"GrowBufAppendStringABW",__FILE__,__LINE__)\
                                        RealGrowBufAppendStringABW(buf,a,b)\
                                        CLRTRACKCOMMENT



BOOL
RealGrowBufCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GrowBufCopyStringA(buf,str)     SETTRACKCOMMENT(BOOL,"GrowBufCopyStringA",__FILE__,__LINE__)\
                                        RealGrowBufCopyStringA(buf,str)\
                                        CLRTRACKCOMMENT

BOOL
RealGrowBufCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GrowBufCopyStringW(buf,str)     SETTRACKCOMMENT(BOOL,"GrowBufCopyStringW",__FILE__,__LINE__)\
                                        RealGrowBufCopyStringW(buf,str)\
                                        CLRTRACKCOMMENT

#ifdef UNICODE

#define MultiSzAppend           MultiSzAppendW
#define MultiSzAppendVal        MultiSzAppendValW
#define MultiSzAppendString     MultiSzAppendStringW
#define GrowBufAppendString     GrowBufAppendStringW
#define GrowBufAppendStringAB   GrowBufAppendStringABW
#define GrowBufCopyString       GrowBufCopyStringW

#else

#define MultiSzAppend           MultiSzAppendA
#define MultiSzAppendVal        MultiSzAppendValA
#define MultiSzAppendString     MultiSzAppendStringA
#define GrowBufAppendString     GrowBufAppendStringA
#define GrowBufAppendStringAB   GrowBufAppendStringABA
#define GrowBufCopyString       GrowBufCopyStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct {
    GROWBUFFER ListArray;
    POOLHANDLE ListData;
} GROWLIST, *PGROWLIST;

#define GROWLIST_INIT {GROWBUF_INIT, NULL}

#define GrowListGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GrowListGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GrowListGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListAppend(list,data,size)  SETTRACKCOMMENT(PBYTE,"GrowListAppend",__FILE__,__LINE__)\
                                        RealGrowListAppend (list,data,size)\
                                        CLRTRACKCOMMENT

PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListAppendAddNul(list,data,size)    SETTRACKCOMMENT(PBYTE,"GrowListAppendAddNul",__FILE__,__LINE__)\
                                                RealGrowListAppendAddNul (list,data,size)\
                                                CLRTRACKCOMMENT

VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    );

PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGrowListInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListInsert(list,index,data,size)    SETTRACKCOMMENT(PBYTE,"GrowListInsert",__FILE__,__LINE__)\
                                                RealGrowListInsert (list,index,data,size)\
                                                CLRTRACKCOMMENT


PBYTE
RealGrowListInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListInsertAddNul(list,index,data,size)  SETTRACKCOMMENT(PBYTE,"GrowListInsertAddNul",__FILE__,__LINE__)\
                                                    RealGrowListInsertAddNul (list,index,data,size)\
                                                    CLRTRACKCOMMENT


BOOL
GrowListDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GrowListResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGrowListSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToSet,            OPTIONAL
    IN      UINT SizeOfData
    );

#define GrowListSetItem(list,index,data,size)   SETTRACKCOMMENT(PBYTE,"GrowListSetItem",__FILE__,__LINE__)\
                                                RealGrowListSetItem (list,index,data,size)\
                                                CLRTRACKCOMMENT


__inline
PCSTR
RealGrowListAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABA"));

    return (PCSTR) GrowListAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? (UINT) (UINT_PTR) ((PBYTE) End - (PBYTE) String) : 0
                        );
}

__inline
PCWSTR
RealGrowListAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListAppendStringABW"));

    return (PCWSTR) GrowListAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? (UINT) (UINT_PTR) ((PBYTE) End - (PBYTE) String) : 0
                        );
}

__inline
PCSTR
RealGrowListInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABA"));

    return (PCSTR) GrowListInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? (UINT) (UINT_PTR) ((PBYTE) End - (PBYTE) String) : 0
                        );
}

__inline
PCWSTR
RealGrowListInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    DEBUGMSG_IF ((String > End, DBG_WHOOPS, "Start is greater than End in GrowListInsertStringABW"));

    return (PCWSTR) GrowListInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? (UINT) (UINT_PTR) ((PBYTE) End - (PBYTE) String) : 0
                        );
}

#define GrowListAppendStringABA(list,a,b) SETTRACKCOMMENT(PCSTR,"GrowListAppendStringABA", __FILE__, __LINE__)\
                                          RealGrowListAppendStringABA(list,a,b)\
                                          CLRTRACKCOMMENT

#define GrowListAppendStringABW(list,a,b) SETTRACKCOMMENT(PCWSTR,"GrowListAppendStringABW", __FILE__, __LINE__)\
                                          RealGrowListAppendStringABW(list,a,b)\
                                          CLRTRACKCOMMENT

#define GrowListInsertStringABA(list,index,a,b) SETTRACKCOMMENT(PCSTR,"GrowListInsertStringABA", __FILE__, __LINE__)\
                                                RealGrowListInsertStringABA(list,index,a,b)\
                                                CLRTRACKCOMMENT

#define GrowListInsertStringABW(list,index,a,b) SETTRACKCOMMENT(PCWSTR,"GrowListInsertStringABW", __FILE__, __LINE__)\
                                                RealGrowListInsertStringABW(list,index,a,b)\
                                                CLRTRACKCOMMENT



#define GrowListAppendStringA(list,str) GrowListAppendStringABA(list,str,GetEndOfStringA(str))
#define GrowListAppendStringW(list,str) GrowListAppendStringABW(list,str,GetEndOfStringW(str))

#define GrowListInsertStringA(list,index,str) GrowListInsertStringABA(list,index,str,GetEndOfStringA(str))
#define GrowListInsertStringW(list,index,str) GrowListInsertStringABW(list,index,str,GetEndOfStringW(str))

#define GrowListAppendStringNA(list,str,len) GrowListAppendStringABA(list,str,CharCountToPointerA(str,len))
#define GrowListAppendStringNW(list,str,len) GrowListAppendStringABW(list,str,CharCountToPointerW(str,len))

#define GrowListInsertStringNA(list,index,str,len) GrowListInsertStringABA(list,index,str,CharCountToPointerA(str,len))
#define GrowListInsertStringNW(list,index,str,len) GrowListInsertStringABW(list,index,str,CharCountToPointerW(str,len))

#define GrowListGetStringA(list,index) (PCSTR)(GrowListGetItem(list,index))
#define GrowListGetStringW(list,index) (PCWSTR)(GrowListGetItem(list,index))

#define GrowListAppendEmptyItem(list)           GrowListAppend (list,NULL,0)
#define GrowListInsertEmptyItem(list,index)     GrowListInsert (list,index,NULL,0)

#ifdef UNICODE

#define GrowListAppendString GrowListAppendStringW
#define GrowListInsertString GrowListInsertStringW
#define GrowListAppendStringAB GrowListAppendStringABW
#define GrowListInsertStringAB GrowListInsertStringABW
#define GrowListAppendStringN GrowListAppendStringNW
#define GrowListInsertStringN GrowListInsertStringNW
#define GrowListGetString GrowListGetStringW
#define GrowListGetStringPtrArray GrowListGetStringPtrArrayW

#else

#define GrowListAppendString GrowListAppendStringA
#define GrowListInsertString GrowListInsertStringA
#define GrowListAppendStringAB GrowListAppendStringABA
#define GrowListInsertStringAB GrowListInsertStringABA
#define GrowListAppendStringN GrowListAppendStringNA
#define GrowListInsertStringN GrowListInsertStringNA
#define GrowListGetString GrowListGetStringA
#define GrowListGetStringPtrArray GrowListGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

//
// Includes
//

// None

//
// Strings
//

// None

//
// Constants
//

// None

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

#define UNKNOWN_LETTER_CASE FALSE
#define ALREADY_LOWERCASE   TRUE

#define DEFAULT_BUCKET_SIZE 0

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

typedef enum {
    WRITE_UNICODE_HEADER    = 0x0001,
    REVERSE_ORDER           = 0x0002
} HASHTABLEOUTPUTFLAGS;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Function prototypes and wrapper macros
//

HASHTABLE
HtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

#define HtAllocA()                                  HtAllocExAW(FALSE,FALSE,FALSE,0,0)
#define HtAllocW()                                  HtAllocExAW(FALSE,TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                      HtAllocExAW(FALSE,FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                      HtAllocExAW(FALSE,TRUE,FALSE,size,0)

#define HtAllocExA(cs,datasize,bucketcount)         HtAllocExAW(cs,FALSE,FALSE,datasize,bucketcount)
#define HtAllocExW(cs,datasize,bucketcount)         HtAllocExAW(cs,TRUE,FALSE,datasize,bucketcount)

#define HtAllocExternStrA()                         HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrW()                         HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)             HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)             HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrExA(cs,size,bucketcount)    HtAllocExAW(cs,FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(cs,size,bucketcount)    HtAllocExAW(cs,TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringA(table,string)              HtAddStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataA(table,string,data)  HtAddStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringW(table,string)              HtAddStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataW(table,string,data)  HtAddStringExW(table,string,data,UNKNOWN_LETTER_CASE)

BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    );

BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    );

BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    );


HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringA(table,string)             HtFindStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataA(table,string,data) HtFindStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringW(table,string)             HtFindStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataW(table,string,data) HtFindStringExW(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,UNKNOWN_LETTER_CASE)

BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Index
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Index
    );

BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

BOOL
HtIsEmpty (
    IN      HASHTABLE HashTable
    );


BOOL
HtWriteToFile (
    IN      HASHTABLE HashTable,
    IN      HANDLE OutputFile,
    IN      HASHTABLEOUTPUTFLAGS Flags
    );


//
// Macro expansion definition
//

// None

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringAndData          HtAddStringAndDataW
#define HtAddStringEx               HtAddStringExW
#define HtRemoveString              HtRemoveStringW
#define HtFindString                HtFindStringW
#define HtFindStringAndData         HtFindStringAndDataW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define EnumFirstHashTableString    EnumFirstHashTableStringW
#define EnumNextHashTableString     EnumNextHashTableStringW
#define EnumHashTableWithCallback   EnumHashTableWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringAndData          HtAddStringAndDataA
#define HtAddStringEx               HtAddStringExA
#define HtRemoveString              HtRemoveStringA
#define HtFindString                HtFindStringA
#define HtFindStringAndData         HtFindStringAndDataA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define EnumFirstHashTableString    EnumFirstHashTableStringA
#define EnumNextHashTableString     EnumNextHashTableStringA
#define EnumHashTableWithCallback   EnumHashTableWithCallbackA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\ipc.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ipc.h

Abstract:

    Implements IPC interface to allow setup to talk with migisol.exe,
    in order to run migration DLLs in separate processes.

Author:

    Jim Schmidt (jimschm)   28-Mar-1997

Revision History:

    jimschm 23-Sep-1998     Changed from mailslots to memory mapped files

--*/


#pragma once

BOOL
OpenIpcW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR MigrationDllPath,        OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    );

BOOL
OpenIpcA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR MigrationDllPath,         OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    );

DWORD
CheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    );

BOOL
IsIpcProcessAlive (
    VOID
    );

VOID
KillIpcProcess (
    VOID
    );

BOOL
SendIpcCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

BOOL
GetIpcCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    );

BOOL
GetIpcCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    );

BOOL
SendIpcCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    );

#define IPC_GET_RESULTS_WIN9X       1000
#define IPC_GET_RESULTS_NT          7500
#define IPC_GET_COMMAND_WIN9X       10000
#define IPC_GET_COMMAND_NT          10000




#ifdef UNICODE
#define OpenIpc OpenIpcW
#else
#define OpenIpc OpenIpcA
#endif

VOID
CloseIpc (
    VOID
    );

typedef LONG (WINAPI WINVERIFYTRUST_PROTOTYPE)(HWND hwnd, GUID *ActionId, PVOID Data);
typedef WINVERIFYTRUST_PROTOTYPE * WINVERIFYTRUST;

BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    );

BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    );

#ifdef UNICODE
#define IsDllSigned IsDllSignedW
#else
#define IsDllSigned IsDllSignedA
#endif


//
// Remote commands
//

#define IPC_QUERY           1
#define IPC_INITIALIZE      2
#define IPC_MIGRATEUSER     3
#define IPC_MIGRATESYSTEM   4
#define IPC_TERMINATE       5
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\linkpif.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    linkpif.h

Abstract:

    Implements routines to manage .LNK and .PIF files.  This
    is a complete redesign from the work that MikeCo did.

Author:

    Calin Negreanu (calinn)     23-Sep-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef struct _LNK_EXTRA_DATAA {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    CHAR    FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAA, *PLNK_EXTRA_DATAA;

typedef struct _LNK_EXTRA_DATAW {
    BOOL    FullScreen;
    DWORD   xSize;
    DWORD   ySize;
    BOOL    QuickEdit;
    WCHAR   FontName [LF_FACESIZE];
    DWORD   xFontSize;
    DWORD   yFontSize;
    DWORD   FontWeight;
    DWORD   FontFamily;
    WORD    CurrentCodePage;
} LNK_EXTRA_DATAW, *PLNK_EXTRA_DATAW;

BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    );

BOOL
ExtractPifInfoA(
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     BOOL  *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      PCSTR FileName
    );

BOOL
ExtractPifInfoW(
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     BOOL   *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      PCWSTR FileName
    );

BOOL
ExtractShellLinkInfoA (
    OUT     PSTR   Target,
    OUT     PSTR   Params,
    OUT     PSTR   WorkDir,
    OUT     PSTR   IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,                  OPTIONAL
    IN      PCSTR  FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShellLinkInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,                  OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoA (
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL  *DosApp,
    OUT     BOOL  *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAA ExtraData,     OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    );

BOOL
ExtractShortcutInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     BOOL   *DosApp,
    OUT     BOOL   *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAW ExtraData,     OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    );

PVOID
FindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    );

#ifdef UNICODE

#define InitCOMLink             InitCOMLinkW
#define FreeCOMLink             FreeCOMLinkW
#define ExtractPifInfo          ExtractPifInfoW
#define ExtractShellLinkInfo    ExtractShellLinkInfoW
#define ExtractShortcutInfo     ExtractShortcutInfoW
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAW
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAW

#else

#define InitCOMLink             InitCOMLinkA
#define FreeCOMLink             FreeCOMLinkA
#define ExtractPifInfo          ExtractPifInfoA
#define ExtractShellLinkInfo    ExtractShellLinkInfoA
#define ExtractShortcutInfo     ExtractShortcutInfoA
#define LNK_EXTRA_DATA          LNK_EXTRA_DATAA
#define PLNK_EXTRA_DATA         PLNK_EXTRA_DATAA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\inf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    inf.h

Abstract:

    Declares interface for INF wrapper routines.  These routines simplify
    access of INFs by wrapping the setup APIs with routines that use
    pools or grow buffers.

    The INF wrapper routines also implement append and replace capabilities,
    so any INF used by the Win9x upgrade can be appended in the future, or
    completely replaced.

Author:

    Marc R. Whitten (marcw) 20-Oct-1997

Revision History:

    jimschm     05-Jan-1999     INF parser moved to migutil
    marcw       28-Oct-1998     Append/Replace capability
    marcw       08-Aug-1997     Pool/Growbuf routines

--*/


typedef enum {
    INF_USE_POOLHANDLE,
    INF_USE_GROWBUFFER,
    INF_USE_PRIVATE_GROWBUFFER,
    INF_USE_PRIVATE_POOLHANDLE
} ALLOCATORTYPES;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    POOLHANDLE      PoolHandle;
    ALLOCATORTYPES  Allocator;
    PCSTR           KeyName;
} INFSTRUCTA, *PINFSTRUCTA;

typedef struct {
    INFCONTEXT      Context;
    GROWBUFFER      GrowBuffer;
    POOLHANDLE      PoolHandle;
    ALLOCATORTYPES  Allocator;
    PCWSTR          KeyName;
} INFSTRUCTW, *PINFSTRUCTW;

#define INFCONTEXT_INIT {NULL,NULL,0,0}
#define INITINFSTRUCT_GROWBUFFER {INFCONTEXT_INIT,GROWBUF_INIT,NULL,INF_USE_PRIVATE_GROWBUFFER,NULL}
#define INITINFSTRUCT_POOLHANDLE {INFCONTEXT_INIT,GROWBUF_INIT,NULL,INF_USE_PRIVATE_POOLHANDLE,NULL}
#define InfOpenAppendInfFile    SetupOpenAppendInfFile


BOOL
InitInfReplaceTableA (
    IN      PCSTR UpginfsDir        OPTIONAL
    );

BOOL
InitInfReplaceTableW (
    IN      PCWSTR UpginfsDir        OPTIONAL
    );

VOID
InfCleanUpInfStructA (
    PINFSTRUCTA Context
    );

VOID
InfCleanUpInfStructW (
    PINFSTRUCTW Context
    );

VOID
InitInfStructA (
    OUT PINFSTRUCTA Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle  OPTIONAL
    );

VOID
InitInfStructW (
    OUT PINFSTRUCTW Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle  OPTIONAL
    );



#define InfOpenInfFileA(f)              SETTRACKCOMMENT(HINF,"InfOpenInfFile",__FILE__,__LINE__)\
                                        RealInfOpenInfFileA((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define InfOpenInfFileW(f)              SETTRACKCOMMENT(HINF,"InfOpenInfFile",__FILE__,__LINE__)\
                                        RealInfOpenInfFileW((f)/*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT



HINF
RealInfOpenInfFileA (
    IN PCSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

HINF
RealInfOpenInfFileW (
    IN PCWSTR FileName /*,*/
    ALLOCATION_TRACKING_DEF
    );

VOID
InfCloseInfFile (HINF Inf);

//
// See the macros below before calling InfOpenInfInAllSourcesA or W.
//
HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    );

HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    );

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCTA
    );


PWSTR
InfGetLineTextW (
    IN OUT  PINFSTRUCTW
    );

PSTR
InfGetStringFieldA (
    IN OUT PINFSTRUCTA  Context,
    IN     UINT         FieldIndex
    );

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCTW  Context,
    IN     UINT         FieldIndex
    );

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCTA     Context,
    IN     UINT            FieldIndex
    ) ;

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCTW     Context,
    IN     UINT            FieldIndex
    ) ;


BOOL
InfGetIntFieldA (
    IN PINFSTRUCTA     Context,
    IN UINT            FieldIndex,
    IN PINT            Value
    );

BOOL
InfGetIntFieldW (
    IN PINFSTRUCTW     Context,
    IN UINT            FieldIndex,
    IN PINT            Value
    );

PBYTE
InfGetBinaryFieldA (
    IN  PINFSTRUCTA    Context,
    IN  UINT           FieldIndex
    );

PBYTE
InfGetBinaryFieldW (
    IN  PINFSTRUCTW    Context,
    IN  UINT           FieldIndex
    );

BOOL
InfGetLineByIndexA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN DWORD            Index,
    OUT PINFSTRUCTA     Context
);

BOOL
InfGetLineByIndexW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN DWORD            Index,
    OUT PINFSTRUCTW     Context
);

BOOL
InfFindFirstLineA (
    IN HINF             InfHandle,
    IN PCSTR            Section,
    IN PCSTR            Key,
    OUT PINFSTRUCTA     Context
    );

BOOL
InfFindFirstLineW (
    IN HINF             InfHandle,
    IN PCWSTR           Section,
    IN PCWSTR           Key,
    OUT PINFSTRUCTW     Context
    );

BOOL
InfFindNextLineA (
    IN OUT PINFSTRUCTA  Context
    );

BOOL
InfFindNextLineW (
    IN OUT PINFSTRUCTW  Context
    );

UINT
InfGetFieldCountA (
    IN PINFSTRUCTA      Context
    );

UINT
InfGetFieldCountW (
    IN PINFSTRUCTW      Context
    );


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCTA Context,
    IN      UINT Field
    );

BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize
    );

VOID
InfResetInfStructA (
    IN OUT PINFSTRUCTA Context
    );

VOID
InfResetInfStructW (
    IN OUT PINFSTRUCTW Context
    );



//
// INF parser
//

typedef struct _tagINFLINE {
    PCWSTR Key;             OPTIONAL
    PCWSTR Data;
    DWORD LineFlags;
    struct _tagINFLINE *Next, *Prev;
    struct _tagINFSECTION *Section;
} INFLINE, *PINFLINE;

#define LINEFLAG_KEY_QUOTED         0x0001
#define LINEFLAG_ALL_COMMENTS       0x0002
#define LINEFLAG_TRAILING_COMMENTS  0x0004


typedef struct _tagINFSECTION {
    PCWSTR Name;
    PINFLINE FirstLine;
    PINFLINE LastLine;
    UINT LineCount;
    struct _tagINFSECTION *Next, *Prev;
} INFSECTION, *PINFSECTION;

PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    );

PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    );

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    );


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    );

PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    );

PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    );

PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    );

PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    );

PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    );

PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    );

PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    );

UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    );

BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    );

BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    );

HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileA(Path) OpenInfFileExA (Path, NULL, TRUE)

HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    );

#define OpenInfFileW(Path) OpenInfFileExW (Path, NULL, TRUE)

VOID
CloseInfFile (
    HINF InfFile
    );

BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    );

BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    );

VOID
InitInfReplaceTable (
    VOID
    );

//
// ANSI/UNICODE mappings.
//
#ifdef UNICODE

#   define INFSTRUCT                        INFSTRUCTW
#   define PINFSTRUCT                       PINFSTRUCTW
#   define InfCleanUpInfStruct              InfCleanUpInfStructW
#   define InitInfStruct                    InitInfStructW
#   define InfResetInfStruct                InfResetInfStructW
#   define InfFindFirstLine                 InfFindFirstLineW
#   define InfFindNextLine                  InfFindNextLineW
#   define InfGetLineByIndex                InfGetLineByIndexW
#   define InfGetStringField                InfGetStringFieldW
#   define InfGetMultiSzField               InfGetMultiSzFieldW
#   define InfGetLineText                   InfGetLineTextW
#   define InfOpenInfFile                   InfOpenInfFileW
#   define InfGetOemStringField             InfGetStringFieldW
#   define InfGetIntField                   InfGetIntFieldW
#   define InfGetBinaryField                InfGetBinaryFieldW
#   define InfGetFieldCount                 InfGetFieldCountW
#   define SetupGetOemStringField           SetupGetStringFieldW
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesW((x),1,&g_SourceDirectory);
#   define AddInfSectionToTable             AddInfSectionToTableW
#   define FindInfSectionInTable            FindInfSectionInTableW
#   define AddInfLineToTable                AddInfLineToTableW
#   define FindLineInInfSection             FindLineInInfSectionW
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrW
#   define OpenInfFileEx                    OpenInfFileExW
#   define OpenInfFile                      OpenInfFileW
#   define SaveInfFile                      SaveInfFileW
#   define InitInfReplaceTable              InitInfReplaceTableW

#else

#   define INFSTRUCT                        INFSTRUCTA
#   define PINFSTRUCT                       PINFSTRUCTA
#   define InfCleanUpInfStruct              InfCleanUpInfStructA
#   define InitInfStruct                    InitInfStructA
#   define InfResetInfStruct                InfResetInfStructA
#   define InfFindFirstLine                 InfFindFirstLineA
#   define InfFindNextLine                  InfFindNextLineA
#   define InfGetLineByIndex                InfGetLineByIndexA
#   define InfGetStringField                InfGetStringFieldA
#   define InfGetMultiSzField               InfGetMultiSzFieldA
#   define InfGetLineText                   InfGetLineTextA
#   define InfOpenInfFile                   InfOpenInfFileA
#   define InfGetOemStringField             InfGetOemStringFieldA
#   define InfGetIntField                   InfGetIntFieldA
#   define InfGetBinaryField                InfGetBinaryFieldA
#   define InfGetFieldCount                 InfGetFieldCountA
#   define SetupGetOemStringField           SetupGetOemStringFieldA
#   define InfOpenInfInAllSources(x)        InfOpenInfInAllSourcesA((x),g_SourceDirectoryCount,g_SourceDirectories);
#   define AddInfSectionToTable             AddInfSectionToTableA
#   define FindInfSectionInTable            FindInfSectionInTableA
#   define AddInfLineToTable                AddInfLineToTableA
#   define FindLineInInfSection             FindLineInInfSectionA
#   define GetFirstLineInSectionStr         GetFirstLineInSectionStrA
#   define OpenInfFileEx                    OpenInfFileExA
#   define OpenInfFile                      OpenInfFileA
#   define SaveInfFile                      SaveInfFileA
#   define InitInfReplaceTable              InitInfReplaceTableA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\migshared.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migshared.h

Abstract:

    Includes the headers for the Win9x upgrade utilities.

Author:

    Jim Schmidt (jimschm) 06-Jan-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifndef MAXDWORD
#define MAXDWORD    0xffffffff
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\log.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    log.h

Abstract:

    Implements routines that simplify the writing to setupact.log
    and setuperr.log.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    mikeco      23-May-1997     Ran code through train_wreck.exe
    Ovidiu Temereanca (ovidiut) 23-Oct-1998
        Added new logging capabilities

*/


//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef DEBUG
#ifndef DBG
#define DBG
#endif
#endif

//
// Redefine MYASSERT
//

#ifdef DEBUG

#ifdef MYASSERT
#undef MYASSERT
#endif

#define DBG_ASSERT          "Assert"

#define MYASSERT(expr)      LogIfA(                                     \
                                !(expr),                                \
                                DBG_ASSERT,                             \
                                "Assert Failure\n\n%s\n\n%s line %u",   \
                                #expr,                                  \
                                __FILE__,                               \
                                __LINE__                                \
                                );

#else

#ifndef MYASSERT
#define MYASSERT(x)
#endif

#endif

#define LOG_FATAL_ERROR   "Fatal Error"
#define LOG_ERROR         "Error"
#define LOG_WARNING       "Warning"
#define LOG_INFORMATION   "Info"
#define LOG_ACCOUNTS      "Accounts"
#define LOG_CONFIG        "Configuration"

BOOL
LogInit (
    IN      HWND LogPopupParentWnd
    );

BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    );


VOID
LogExit (
    VOID
    );

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    );

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title
    );

VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title
    );

VOID
LogLineA (
    IN      PCSTR Line
    );

VOID
LogLineW (
    IN      PCWSTR Line
    );

VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    );

VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    );

VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    );

#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    );

#endif

// Define W symbols

#define LOGW(x) LogW x
#define LOGW_IF(x) LogIfW x
#define ELSE_LOGW(x) else{LogW x;}
#define ELSE_LOGW_IF(x) else{LogIfW x;}
#define LOGTITLEW(type,title) LogTitleW (type,title)
#define LOGLINEW(title) LogLineW (title)
#define LOGDIRECTW(type,text) LogDirectW (type,text)

// Define A symbols

#define LOGA(x) LogA x
#define LOGA_IF(x) LogIfA x
#define ELSE_LOGA(x) else{LogA x;}
#define ELSE_LOGA_IF(x) else{LogIfA x;}
#define LOGTITLEA(type,title) LogTitleA (type,title)
#define LOGLINEA(line) LogLineA (line)
#define LOGDIRECTA(type,text) LogDirectA (type,text)

// Define generic symbols

#ifdef UNICODE

#define LOG(x) LOGW(x)
#define LOG_IF(x) LOGW_IF(x)
#define ELSE_LOG(x) ELSE_LOGW(x)
#define ELSE_LOG_IF(x) ELSE_LOGW_IF(x)
#define LOGTITLE(type,title) LOGTITLEW(type,title)
#define LOGLINE(title) LOGLINEW(title)
#define LOGDIRECT(type,text) LOGDIRECTW(type,text)

#else

#define LOG(x) LOGA(x)
#define LOG_IF(x) LOGA_IF(x)
#define ELSE_LOG(x) ELSE_LOGA(x)
#define ELSE_LOG_IF(x) ELSE_LOGA_IF(x)
#define LOGTITLE(type,title) LOGTITLEA(type,title)
#define LOGLINE(title) LOGLINEA(title)
#define LOGDIRECT(type,text) LOGDIRECTA(type,text)

#endif // UNICODE


#ifdef DEBUG

#define DBG_NAUSEA      "Nausea"
#define DBG_VERBOSE     "Verbose"
#define DBG_STATS       "Stats"
#define DBG_WARNING     "Warning"
#define DBG_ERROR       "Error"
#define DBG_WHOOPS      "Whoops"
#define DBG_TRACK       "Track"
#define DBG_TIME        "Time"

extern CHAR g_DebugInfPathBufA[];
extern WCHAR g_DebugInfPathBufW[];
#define g_DebugInfPath  g_DebugInfPathBufA
#define g_DebugInfPathA g_DebugInfPathBufA
#define g_DebugInfPathW g_DebugInfPathBufW

extern BOOL g_ResetLog;             // Defined in log.c
#define SET_RESETLOG()   g_ResetLog = TRUE
#define CLR_RESETLOG()   g_ResetLog = FALSE
#define RESETLOG()       (g_ResetLog)

extern BOOL g_DoLog;                // Defined in log.c
#define SET_DOLOG()     g_DoLog = TRUE
#define CLR_DOLOG()     g_DoLog = FALSE
#define DOLOG()         (g_DoLog)


#ifndef PROGRESS_BAR

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    );

#endif


// Define W symbols

#define DEBUGMSGW(x) LogW x
#define DEBUGMSGW_IF(x) LogIfW x
#define ELSE_DEBUGMSGW(x) else LogW x
#define ELSE_DEBUGMSGW_IF(x) else LogW x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEW(x) LogTime x
#else
#define DEBUGLOGTIMEW(x) DebugLogTimeW x
#endif


// Define A symbols

#define DEBUGMSGA(x) LogA x
#define DEBUGMSGA_IF(x) LogIfA x
#define ELSE_DEBUGMSGA(x) else LogA x
#define ELSE_DEBUGMSGA_IF(x) else LogIfA x
#ifdef PROGRESS_BAR
#define DEBUGLOGTIMEA(x) LogTime x
#else
#define DEBUGLOGTIMEA(x) DebugLogTimeA x
#endif

// Define generic symbols

#ifdef UNICODE

#define DEBUGMSG(x) DEBUGMSGW(x)
#define DEBUGMSG_IF(x) DEBUGMSGW_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGW(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGW_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEW(x)

#else

#define DEBUGMSG(x) DEBUGMSGA(x)
#define DEBUGMSG_IF(x) DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSG(x) ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSG_IF(x) ELSE_DEBUGMSGA_IF(x)
#define DEBUGLOGTIME(x) DEBUGLOGTIMEA(x)

#endif // UNICODE

#else // !defined(DEBUG)

//
// No-debug constants
//

#define SET_RESETLOG()
#define CLR_RESETLOG()
#define RESETLOG()

#define SET_DOLOG()
#define CLR_DOLOG()
#define DOLOG()

#define SETTRACKCOMMENT(RetType,Msg,File,Line)
#define CLRTRACKCOMMENT
#define SETTRACKCOMMENT_VOID(Msg,File,Line)
#define CLRTRACKCOMMENT_VOID
#define DISABLETRACKCOMMENT()
#define ENABLETRACKCOMMENT()

#define DEBUGMSG(x)
#define DEBUGMSGA(x)
#define DEBUGMSGW(x)

#define DEBUGMSG_IF(x)
#define DEBUGMSGA_IF(x)
#define DEBUGMSGW_IF(x)

#define ELSE_DEBUGMSG(x)
#define ELSE_DEBUGMSGA(x)
#define ELSE_DEBUGMSGW(x)

#define ELSE_DEBUGMSG_IF(x)
#define ELSE_DEBUGMSGA_IF(x)
#define ELSE_DEBUGMSGW_IF(x)

#ifdef PROGRESS_BAR
#define DEBUGLOGTIME(x) LogTime x
#else
#define DEBUGLOGTIME(x)
#endif

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\memdbdef.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdbdef.h

Abstract:

    Defines the memdb categories for the Win9x upgrade project.
    All information that is transferred to the NT side of setup
    is placed in a memdb category.  The comments below document
    each category used.

Authors:

    Jim Schmidt (jimschm) 16-Dec-1996

Revision History:

    Many changes - see SLM log

--*/

#pragma once

/*

  MemDb Structure

  MemDb is a binary tree structure that the migration code uses to save
  instructions, lists, account information, and so on.  The stored information
  is combined into a path form, and the path can have an optional DWORD
  associated with it.

  A generalized structure of all data that we store in memdb can be
  expressed as:

  <category>\<item>\<field>\<data>=<val>

  category  - A hard-coded category, a MEMDB_CATEGORY constant

  item      - An item may be:

              1. A runtime-defined string
              2. A runtime-generated enumeration string
              3. A hard-coded string (rare)
              4. Unused

  field     - Usually a hard-coded field related to item.  The field
              is used to match several lines of data with a single item.
              In some cases, field is not used.

  data      - The string-based data that needs to be stored.

  val       - A DWORD associated with <data>.  Often this value is
              not used and is zero.


  In general, if a field for an item is missing, the field is considered
  empty.

  Because memdb is internally a binary tree, all pieces of a path are sorted.
  A frequent use of this characteristic is to make enumerators that are numeric
  strings with zero leaders (001, 002, etc).  Such enumerators maintain order
  of items.

  -----

  The following categories are defined:

  HKR\<regpath> = <flags>

        HKR is used to suppress migration of a registry key in a user's hive.
        This is used primarily by usermig.inf's SuppressValue rule.

        regpath  - The path to a registry key, and an optional value appended
                   in brackets (HKR\key [val]).

        flags - Specifies the merge flags for the key.  See regops.h.

  HKLM\<regpath> = <flags>

        HKLM is used to suppress migration of a registry key in a the system's hive.
        This is used primarily by wkstamig.inf's SuppressValue rule.

        regpath  - The path to a registry key, and an optional value appended
                   in brackets (HKR\key [val]).

        flags - Specifies the merge flags for the key.  See regops.h.

  FileEnumExcl\<hex-val>\<Paths|Files>\<path>

        FileEnumExcl is used to exclude files or paths from file enumeration
        in fileenum.lib.

        hex-val     - The hex representation of the exclusion group DWORD
        Paths|Files - Paths if <path> represents a path pattern to exclude
                      Files if <path> represents a file pattern to exclude

       See FileEnum source for more information.

  LinkEdit

        OPERATION_LINK_EDIT holds all info for editing a LNK or PIF file
        on NT side (or for creating a new LNK file as special case for
        converting PIFs to command.com)

  LinkStrings\<path>

        LinkStrings holds a list of link files that have command lines with
        GUID arguments.  See LinkGuids below.

        path - Specifies the .LNK path in long format

  LinkGuids\<guid>\<seq> = <offset>

        LinkGuids holds a list of GUIDs which is used in one or more .LNK
        command line arguments.

        guid - Specifies the GUID extracted from the .LNK command line arguments

        seq - A numerical sequencer used to allow a one-to-many mapping

        offset - The offset of a LinkStrings entry

  AdministratorInfo\account\<name>

        AdministratorInfo holds information describing the details necessary to
        migrate the NT administrator account.

        account - This item designates the Win9x account for the administrator.
                  If the account item is missing, the default Win9x account is used.
                  The account name is the fixed user name.

  UserDatLoc\<user>\<path> = <create only>

        UserDatLoc is used to track the location of each user's user.dat
        file.  It is used by migmain to load up a user's hive, and also
        to suppress processing of a user.  If an entry is not given for
        a particular user (including Administrator and the default user),
        the user will not be migrated.

        user - The fixed user name matched with the path

        path - The full RELOCATED path to user.dat for the user, in
               %windir%\setup\temp

        create only - Specifies 1 if this account is only for creation
                      (i.e., Administrator), or 0 for full migration.

  FixedUserNames\<orgname-encoded>\<newname>

        FixedUserNames maps the original name of a user to the new name,
        if the original name was incompatible with NT.

        orgname-encoded - Specifies the original user name, encoded with
                          MemDbMakeNonPrintableKey

        newname - Specifies the new user name that is compatible with
                  NT

  UserProfileExt\<user>\<ext>

        If a Win9x profile path has an extension on it, the extension
        is written to UserProfileExt.  Setup preserves the extension
        by appending it to the new profile path it creates.

        user - The fixed Win9x user name matched with the extension

        ext - The exact name of the user's profile folder, such as
              joeblow.001

        If an entry does not exist, then the fixed user name is used as
        the profile directory name.

  FileRename\<srcname>\<newname>

        FileRename holds a master list of all files on Win9x that are renamed
        during upgrade.  This list can only contain file names that can
        be located by the SearchPath API on Win9x.  During the upgrade,
        all registry references to the specific file are updated to use
        the new name.

        srcname - Specifies the file name that exists on Win9x

        newname - Specifies the new name of the file that has the same
                  functionality on Win9x but has a different name.


  MigDll\<item>\<field>\<path>

        MigDll is used to pass a list of migration DLLs from Win95 to NT.
        All DLLs in the MigDll category are loaded and executed in GUI
        mode setup.

        item   - A numeric enumerator

        field  - DLL:  <path> gives the path to the migration DLL
                 WD:   <path> gives the working directory for the DLL
                 DESC: <path> gives a text description, truncated to MAX_PATH
                       characters.

        path   - The DLL path, working directory or description.

  SIF Restrictions\section\pattern

        This section describes the sections and keys in the unattend file
        that migration dlls are not allowed to use. It is pattern based so,
        for example, MassStorageDrivers=* would indicate that no migration
        dll can create any key in the MassStorageDrivers section of the
        unattend file.

        section - a section. May not contain a pattern.
        pattern - a key pattern.

  SIF Values\value

        The values used by buildinf.


  SIF Sections\Section\Key Sequence\Value Sequence

        This section holds all of the sections and keys of an answer file.

        section      - the section within an answer file
        Key sequence - a stringified 7 digit number that maintains order between keys
                       in a section. The associated value with this key is the offset
                       into the keys section where the key text is located.
        Value sequence - a stringified 7 digit number that maintains order between values in
                        a section. The associated value with this okey is the offset
                        into the Answer File Values section where the value is located.

  Ras Migration Data for <User>\Entry\Item\Data

        This section holds information for migrating phone book entrys of users.

        User - the fixed user name of the user this refers to..

        Entry - The Phone book entry name

        Item  - The win95 item name

        data  - the data of that item.

  NetShares\<share>\<field>\<data>

        NetShares is used to hold all Win95 share information as extracted
        by NetShareEnum.  All details are specified for the share, although
        not all of them may be supported.

        share     - The share name as configured in Win95

        field     - Path:   <data> specifies the path to share
                    Remark: <data> specifies a user-defined remark
                    ACL:    <data> specifies one or more users, and the
                            entire key's value is set to the permission
                            flags for the user.
                    ROP:    <data> specifies a read-only password
                    RWP:    <data> specifies a full-access password

        data      - The path, remark, ACL user list, or password

        Note that NetShares\<share> is also used.  The value of this key
        is set to the type of access permitted (ACL-defined, password-
        defined, etc.) with a special flag of SHI50F_ACLS (defined
        in memdb.h).

  UserPassword\<user>\<password>

        If <user> is a local account, The account will be created with <password>.

        user - Specifies the fixed Win9x user name

        password - Specifies the password, which may contain a backslash, asterisk or
                   question mark.

  DOSMIG SUMMARY\<item>\<field>\<data>

        Dosmig Summary is used to maintain summary information about the progress of
        migrating the dos configuration files config.sys and autoexec.bat.

        Item is either BAD, IGNORE, MIGRATE, USE, or UNKNOWN (referring to the type of
        classifications dosmig95 uses as it reads through the DOS configuration files) or
        LINES (referring to the total line count found.)

        The only currently supported field under this category is COUNT

        data contains a count of whatever the item field was, as a string.

  DOSMIG LINES\<item>\<field>\<data>

        The Dosmig lines category is used to hold information about the actual lines of
        the configuration fields.

        Item is a 5 digit enumerator string.

        Fields are one of the following:

        TYPE -- The type of the line
        TEXT -- The actual text of the line.
        DESC -- A description associated with the line by dosmig95's parse rules
        FILE -- either autoexec.bat or config.sys depending on where the line originated.

        The data is the type,text,description or file, as necessary.

  GUIDS\<guid>

        The GUIDS category holds a list of all suppressed GUIDs for OLE.  Each
        GUID in the list exists in the Win95 registry.  The actual list of
        suppressed GUIDs (both those that are in the registry and those that
        are not) is kept in win95upg.inf.

  AutosearchDomain\<user>

        The AutosearchDomain category holds a list of users who are marked for
        automatic domain lookup during GUI mode.  If one or more users are listed
        in AutosearchDomain, Setup checks all trusted domains for the specified
        user accounts, resolving them automatically.

        user - Specifies the fixed user name, without a domain

  KnownDomain\<domain>\<user>

        The KnownDomain category holds a list of users whos domain is known but
        needs to be verified.  This domain comes from network shares, the most
        recent logged on user, and the UI.

        domain - Specifies the domain name, such as REDMOND

        user - Specifies the fixed user name

  State\<data>=value

        A category used for misc state passing.  Data is one of the following:

            MSNP32  - If exists, the Microsoft Networking Client was installed
            PlatformName\<name> - Specifies the display name of Win95 or Win98
            MajorVersion = <DWORD> - Specifies Win9x major version
            MinorVersion = <DWORD> - Specifies Win9x minor version
            BuildNumber = <DWORD> - Specifies Win9x build number
            PlatformId = <DWORD> - Specifies platform ID flags
            VersionText - Specifies arbitrary version text
            CodePage = <DWORD> - Specifies Win9x code page
            Locale = <DWORD> - Specifies Win9x locale id
            AP\<password> = <DWORD> - Specifies the admin password and if it was
                                      randomly generated or not

  NtFiles\<filename> = <pathoffset>

        The NtFiles category is used to hold a list of filenames that are
        installed by standard NT installation.  This list comes from txtsetup.sif
        and does not have a directory spec.

        filename - The file that will be installed, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  NtFilesExcept\<filename>

        These are files installed by NT that don't have no overwrite restriction

        filename - The file name, in long filename format

  MyDocsMoveWarning\<user>\<path>

        Specifies paths to copy the shell "where are my documents"
        warning file.

        user - Specifies the fixed user name

        path - Specifies the path. On 9x, this is the symbolic shell
               folder location. On NT, this is fixed up to be the
               actual path.

  NtFilesRemoved\<filename> = <pathoffset>

        These are files removed by NT

        filename - The file name, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  NtPaths\<path>

        Specifies the path for a file listed in NtFiles.

        path - The path specification in long filename format

  NtFilesBad\<filename> = <pathoffset>

        This category is used to hold the files that are supposed to be installed by
        NT but never made it.

        filename - The file that should have been installed, in long filename format

        pathoffset - Specifies offset to NtPaths key for file

  Stf\<path>

        Specifies the name of a setup table file that needs to be converted.
        .STF files are used by the old Microsoft ACME setup.  We convert any
        path that has been moved.

        path - The path specification in long filename format

  StfTemp\<path> = <inf pointer>

        Used during STF processing in the migraiton phase to organize data.

        path - The path specification in long filename format, taken from the
               STF/INF pair

        inf pointer - A pointer to an INFLINE structure (see migmain\stf.c)

  StfSections\<path> = <section number>

        Used during STF processing in the migraiton phase to organize sections.

        path - The dir portion of an STF path; files in the STF section must all
               be in this directory.

        section number - The 32-bit section number.  When combined with win9xupg,
                         this number gives a unique section name.

  HelpFilesDll\<dllname>

        Specifies the extension DLL needed by a certain help file. Used to
        verify if the help file and the DLL are going to be loaded in
        the same subsystem in NT.

  Report\<category> = Item      (temporary category)

        category - Specifies the category, which may contain backslashes.  This
                   is the same category that is stored in msgmgr.

        Item - Specifies a pointer to the incompatibility message item

  UserSuppliedDrivers\<infname>\<local_driver_path>

        Specifies the INF of user-supplied hardware drivers and the
        location of the associated driver files.

        infname - Specifies INF to be installed

        local_driver_path - Specifies local path containing all driver files

  DisabledMigDlls\<productid>

        Specifies that a registry-specified migration DLL is disabled and
        will not be processed.

        productid - The migration DLL's product ID; the value name stored in
                    the registry and used for display.

  MissingImports\<missing import sample>
        Specifies a sample of a missing import for a certain module.


        MissingImports = the full path for the module
        missing import sample = is a sample for a missing import

  ModuleCheck\<full path module name>=<status value>
        Specifies a list of modules and their status.


        full path module name = self explanatory
        status value = MODULESTATUS_xxx constant defined in fileops.h

  HardwareIdList\<enum key entry>\<hardware Id list>

        Specifies a list of hardware Id's and compatible id's for specified enum key entry

  NewNames\<name group>\<field>\<name> = <value>  (**intended to be used on the Win9x-side only)

        Specifies a name collision resolution, used to correct names that are
        incompatible with NT.

        name group - Specifies the type of name, such as Computer Name, User Names, etc...

        field - Old: <name> specifies the Win9x name
                New: <name> specifies the NT-compatible name, either generated by Setup
                     or specified by the user

        name - Specifies the name text

        value - If <field> is Old, specifies offset to new name (i.e, the New field's data)

  InUseNames\<name group>\<name>  (**intended to be used on the Win9x-side only)

        Specifies names that are in use.  Used to make sure the user doesn't try to name
        two things to the same name.

        name group - Specifies the type of name, such as Computer Name, User Names, etc...

        name - Specifies the name that is in use

  DeferredAnnounce\<full path module name> = Offset
        If any of the files listed here have a link or pif pointing to them then we will
        announce the file using implicit values or MigDbContext (Offset is a pointer to this).
        UserFlags are used to identify the type of the file that can be one of the following:
            Reinstall
            MinorProblems
            Incompatible

  KnownGood\<full path module name>
        We record here all known good files found in the system.


  CompatibleShellModules\<full path module name> = Offset
        We list here all known good modules for Shell= line in Win.ini.
        When we will process this line we will check to see if modules listed there are
        "known good". If not we will either delete the entry or replace the module with a
        compatible one. Offset points to a MigDbContext or is NULL.

  CompatibleShellModulesNT\<full path module name>
        This is the part from CompatibleShellModules that actually goes to NT.

  CompatibleRunKeyModules\<full path module name> = Offset
        We list here all known good modules for Run key.
        When we will process this key we will check to see if modules listed there are
        "known good". If not we will either delete the entry or replace the module with a
        compatible one. Offset points to a MigDbContext or is NULL.

  CompatibleRunKeyModulesNT\<value name>
        This is the part from CompatibleRunKeyModules that actually goes to NT.

  IncompatibleRunKeyModulesNT\<value name>
        This lists the Run key value names that are known bad.

  CompatibleDosModules\<full path module name> = Offset
        We list here all known good Dos modules.

  CompatibleDosModulesNT\<full path module name>
        This is the part from CompatibleDosModules that actually goes to NT.

  CompatibleHlpFiles\<full path module name> = Offset
        We list here all known good HLP files.

  CompatibleHlpExtensions\<extension module>
        We list here HLP files extension modules that we know are going to work

  Shortcuts\<full path shortcut file name>
        Shortcuts stored here for further processing

  UninstallSection\<migdb section>

        Specifies a section name that needs to be processed.  This key is temporary and
        is generated during the file scan and deleted at the end of the file scan during
        the report phase.

        migdb section - Specifies the section name text, as specified by an arg in migdb.inf

  CleanUpDir\<path>

        Specifies a directory that should be deleted if it is empty

        path - Specifies the root path.  The subdirs are scaned as well.

  Win9x APIs\<DLL>\<api>

        Lists APIs that are supported only on Win9x.

        DLL - Specifies the DLL file name, such as kernel32.dll

        api - Specifies the API in the DLL


  Network Adapters\<Adapter Section>\<Protocol>= <NetTransOffset>
  Network Adapters\<Adapter Section>\<PnPId>
  NetTransKeys\<NetTransKey>

    Lists all Net Adapters on the system and the associated protocol bindings.

    Adapter Section - Specifies the Adapter Section that will be created in the answer file for
        this item (such as [Adapter1])

    Protocol - Under each adapter, each bound protocol is listed.

    PnPId - The base PNPID for the device.

    NetTransOffset An Offset into the NetTransKeys section.

  Icons\<path>\<seq> = offset, seq

        Lists extracted icons.

        <path> - Specifies the Win9x source file path (c:\windows\notepad.exe for example)
        <seq> - Specifies the sequential icon index in <path>, zero-based
        offset - Specifies the file position within the icon data file where the image is
        seq - Specifies the sequential icon index in migicons.exe, zero-based

  IconsMoved\<path>\<seq> = offset, seq

        Lists moved icons.

        <path> - Specifies the Win9x source file path (c:\windows\notepad.exe for example)
        <seq> - Specifies the sequential icon index in <path>, zero-based
        offset - Specifies the memdb key offset to the new OS file (Win9x path)
        seq - Specifies the sequential icon index in the new OS file, zero-based

  NicePaths\<path>=MessageId

        Lists paths that should be translated in user report using the message ID.

        path      - Specifies the path

        MessageId - Specifies the message ID

  MigrationPaths\<path>

        Lists paths that are considered "ours". The deal is that if we find OSFiles in these paths, we delete them, otherwise
        we just mark them for external deletion.

        path      - Specifies the path

  ReportLinks\<ReportEntry>\<Category>

  SuppressIniMappings\<suppressed path>

        Lists all INI settings that are not going to be mapped into registry

        suppressed path = <INI file>\<section name>\<key name>
        <section name> and <key name> may have wild characters

  NoOverwriteIniMappings\<no overwrite path>

        Lists all INI settings that are going to be mapped into registry,
        unless NT supplies a value, in which the registry value is mapped
        to the INI file.

        no overwrite path - Specifies <INI file>\<section name>\<key name>,
                            where <section name> and <key name> may have
                            wild characters.

  IniConv\<9xPath>

        Causes path conversion on a file (INI processing). Conversion is done
        in-place. The NT side code converts the 9x path to the NT path via
        GetPathStringOnNt.

  PnpIds\<pnp id>       (temporary -- Win9x side only)

        Lists all PNP IDs on the Win9x machine

  UserFileMoveDest\<path>

        Lists the destination for user files for a particular user. Used to
        easy record one to many copy

        path - Specifies the destination path

  UserFileMoveSrc\<path>\<user>

        Lists the source file for user files for a particular user. Used to
        easy record one to many copy

        path - Specifies the source path

        user - Specifies the user name

  NT TimeZones\<index>\<description>

        Lists nt timezones. Used for mapping timezones and to resolve ambigious timezone cases.

        <index>         - The index used by syssetup to specify the nt timezone.
        <description>   - The displayable description of the timezone.

  9x TimeZones\<description>\<index>

        Lists 9x timezones and the nt timezones that can possibly map to them.

        <description>   - The description of the timezone


  SfPaths\<path>

        Holds the paths for other categories (ShellFolders for example).  Used to
        consolidate the paths.

        path - Specifies the shell folder path (either an NT or Win9x location),
               in either long or short format.

  SfTemp\<path> = <offset> (temporary category)

        Specifies the path of the temporary location for a shell folder.  This is
        used only on the Win9x side to queue up a list of things to move.  The
        code in buildinf.c then transfers these paths into the win9xmov.txt file.

        path - Specifies the Win9x file or directory to move

        offset - Specifies the offset to the destination path (in SfPaths)

  SfOrderNameSrc\<identifier>\<path>\<sequencer> = <shell folder ptr>  (temporary category)

        Specifies the shell folder list, sorted by the shell folder identifier.
        This category is only for work purposes, do not rely on it for data
        transfer during the upgrade.

        identifier - Specifies the shell folder identifier (i.e., Desktop)

        path - Specifies the Win9x path

        sequencer - Random value that is used to make multiple instances of
                    identifier/path pairs unique

        shell folder ptr - Specifies the pointer to a Win9x-side SHELLFOLDER
                           struct

  SfOrderSrc\<path>\<sequencer> = <shell folder ptr>  (temporary category)

        Specifies the shell folder list, sorted by the path.  This category is
        only for work purposes, do not rely on it for data transfer during the
        upgrade.

        path - Specifies the Win9x shell folder path

        sequencer - Random value that is used to make multiple instances of
                    path unique

        shell folder ptr - Specifies the pointer to a Win9x-side SHELLFOLDER
                           struct

  SfMoved\<path>

        Specifies a path that has been processed.  This category is used only
        for work purposes, do not rely on it for data transfer during the
        upgrade.

        path - Specifies Win9x shell folder that was moved

  System32ForcedMove\<file pattern>
        Lists all patterns for files that should be moved from System to System32 no matter what.

        file pattern - pattern for files to be moved

  UserRegData\<value>

        This category lists REG_SZs for UserRegLoc.

        value - Specifies the REG_SZ

  UserRegData\<user>\<encoded key>=<offset to REG_SZ>

        This category holds a list of encoded reg key/value pairs for a pariticular
        user.  The data listed in this category is saved to the user's registry
        at the beginning of the migration of the user registry.

        user - Specifies the fixed, domain-less user name

        encoded key - Specifies the registry key and value, encoded with
                      CreateEncodedRegistryStringEx(key,value,FALSE)

        offset to REG_SZ - Specifies offset to a node in UserRegData

  SFFilesDest\<path>

        Destinations for files inside shell folders. We record this only to help
        the collision detection filter on 9x side. If two shell folders are going
        to be moved to the same location there is a potential of collision there.
        We need to see that and to add the proper move operation.

  NewLinks\<sequencer>\<various data>

        This is used for recording new links that need to be created on NT side. For now
        we do this only to convert PIFs pointing to command.com to LNKs to cmd.exe

  Mapi32Locations\<filename>

        This is used to store all mapi32.dll files on the system. At the end we look to see
        if they are all handled by a migration DLL. If not, we add a general message to report.

  StartupSF\<path>

        This will list all startup shell folders found on the system

  Good Imes\<imefile>

        This lists ime files that may be merged into the keybouard layout registry during NT
        side processing.

  Keyboard Layouts\<sequencer>\<layoutid>

        This lists preloads during NT side processing.

  DirsCollision\<src path>

        Files that need to be renamed because they are colliding with some NT dirs.

  MMedia\System\<System Settings>

        Multimedia-related system settings

  MMedia\Users\<UserName>\<User Settings>

        Multimedia-related user settings

  IgnoredCollisions\<pattern>

        These are files for which the collision with NT files (in shell folders merge) is ignored.

  Suppress Answer File Settings\<section>\<key>

        These are suppresed answer file settings from migration dlls.

  ChangedFileProps\<original file path>\<new file name>

        This is the set of files that were renamed on Win9x side (special files like
        %windir%\system32 cannot be renamed in textmode setup because the dir is created
        as setup starts, before the file is actually renamed)
        If user cancels Setup, all files in this set are restored to their previous state.

  Full Directory Deletes\<Path>

        Set of directories that are added to w9xddir.txt. These directories are deleted along
        with all of there contents during textmode.

  IniAct\First\<OrigIniPath>\<TempFileLocation>

        Set of INI files on which some actions will be performed before any other INI files
        processing is done and before shell folders are migrated; they are stored as original
        path followed by the temporary path where they are copied (so they don't get replaced
        by NT versions); the starting point of TempFileLocation is recognized by the : symbol
        after a drive letter.

  IniAct\Last\<OrigIniPath>\<TempFileLocation>

        Same semantics as above, except INI files stored here are processed last,
         after users are migrated and registries are merged.

  FileEdit\<path> (has optional binary value)

        This category lists files that are to be edited in GUI mode.  The
        optional binary value contains a TOKENSET.  The reader of the binary
        value must convert the offsets in TOKENSET into pointers.

  CleanOut\<path> = <type>

        This category is used to support uninstall. Files, directories and
        trees listed here are evaluated during GUI mode and are put in the delete
        txt file used by uninstall.

        <path> - Specifies the full file path or full subdirectory path
        <type> - Specifies 0 for file, 1 for directory, 2 for tree or 3 for a
                 tree that can't have user files

  EmptyDirs\<path>

        This category tells the uninstall algorithm to write files to mkdir.txt.

        <path> - Specifies the path to the directory that is empty on Win9x

  ShellFolderPerUser\<name> = <common offset>

        This category maps a per-user shell folder name to its common version

  ShellFolderCommon\<name> = <per-user offset>

        This category maps a common shell folder name to its per-user version

*/


//
// FileEnum exclude groups
//

#define MEMDB_CATEGORY_FILEENUM            TEXT("FileEnumExcl")
#define MEMDB_FIELD_FE_PATHS               TEXT("Paths")
#define MEMDB_FIELD_FE_FILES               TEXT("Files")

#define MEMDB_PROFILE_EXCLUSIONS    1
#define MEMDB_FILEDEL_EXCLUSIONS    4

//
// LinkEdit
//

#define MEMDB_CATEGORY_DEFAULT_PIF           TEXT("DefaultPif")
#define MEMDB_CATEGORY_DEFAULT_PIFA          "DefaultPif"
#define MEMDB_CATEGORY_DEFAULT_PIFW          L"DefaultPif"

#define MEMDB_CATEGORY_LINKEDIT              TEXT("LinkEdit")
#define MEMDB_CATEGORY_LINKEDITA             "LinkEdit"

#define MEMDB_CATEGORY_LINKEDIT_TARGET       TEXT("Target")
#define MEMDB_CATEGORY_LINKEDIT_ARGS         TEXT("Arguments")
#define MEMDB_CATEGORY_LINKEDIT_WORKDIR      TEXT("WorkDir")
#define MEMDB_CATEGORY_LINKEDIT_ICONPATH     TEXT("IconPath")
#define MEMDB_CATEGORY_LINKEDIT_ICONNUMBER   TEXT("IconNumber")
#define MEMDB_CATEGORY_LINKEDIT_FULLSCREEN   TEXT("FullScreen")
#define MEMDB_CATEGORY_LINKEDIT_XSIZE        TEXT("xSize")
#define MEMDB_CATEGORY_LINKEDIT_YSIZE        TEXT("ySize")
#define MEMDB_CATEGORY_LINKEDIT_QUICKEDIT    TEXT("QuickEdit")
#define MEMDB_CATEGORY_LINKEDIT_FONTNAME     TEXT("FontName")
#define MEMDB_CATEGORY_LINKEDIT_XFONTSIZE    TEXT("xFontSize")
#define MEMDB_CATEGORY_LINKEDIT_YFONTSIZE    TEXT("yFontSize")
#define MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT   TEXT("FontWeight")
#define MEMDB_CATEGORY_LINKEDIT_FONTFAMILY   TEXT("FontFamily")
#define MEMDB_CATEGORY_LINKEDIT_CODEPAGE     TEXT("CodePage")
#define MEMDB_CATEGORY_LINKEDIT_SHOWNORMAL   TEXT("ShowNormal")

#define MEMDB_CATEGORY_LINKSTUB_TARGET       TEXT("StubTarget")
#define MEMDB_CATEGORY_LINKSTUB_ARGS         TEXT("StubArguments")
#define MEMDB_CATEGORY_LINKSTUB_WORKDIR      TEXT("StubWorkDir")
#define MEMDB_CATEGORY_LINKSTUB_ICONPATH     TEXT("StubIconPath")
#define MEMDB_CATEGORY_LINKSTUB_ICONNUMBER   TEXT("StubIconNumber")
#define MEMDB_CATEGORY_LINKSTUB_SEQUENCER    TEXT("StubSequencer")
#define MEMDB_CATEGORY_LINKSTUB_MAXSEQUENCE  TEXT("StubMaxSequence")
#define MEMDB_CATEGORY_LINKSTUB_ANNOUNCEMENT TEXT("StubAnnouncement")
#define MEMDB_CATEGORY_LINKSTUB_REQFILE      TEXT("StubReqFile")
#define MEMDB_CATEGORY_LINKSTUB_REPORTAVAIL  TEXT("PresentInReport")
#define MEMDB_CATEGORY_LINKSTUB_SHOWMODE     TEXT("ShowMode")

#define MEMDB_CATEGORY_REQFILES_MAIN         TEXT("TMP_HIVE\\ReqFilesMain")
#define MEMDB_CATEGORY_REQFILES_ADDNL        TEXT("TMP_HIVE\\ReqFilesAddnl")

// LinkStrings\<path>
#define MEMDB_CATEGORY_LINK_STRINGS         TEXT("LinkStrings")

// LinkGuids\<guid>\<seq> = <offset to LinkStrings>
#define MEMDB_CATEGORY_LINK_GUIDS           TEXT("LinkGUIDs")

// AdministratorInfo\account\<name>
#define MEMDB_CATEGORY_ADMINISTRATOR_INFO   TEXT("AdministratorInfo")
#define MEMDB_ITEM_AI_ACCOUNT               TEXT("Account")
#define MEMDB_ITEM_AI_USER_DOING_MIG        TEXT("UserDoingMig")

// UserDatLoc\<username>\location  (no fields)
#define MEMDB_CATEGORY_USER_DAT_LOC         TEXT("UserDatLoc")
#define MEMDB_CATEGORY_USER_DAT_LOCA        "UserDatLoc"

// FixedUserNames\<orguser_encoded>\<newuser>
#define MEMDB_CATEGORY_FIXEDUSERNAMES       TEXT("FixedUserNames")
#define MEMDB_CATEGORY_FIXEDUSERNAMESA      "FixedUserNames"
#define MEMDB_CATEGORY_FIXEDUSERNAMESW      L"FixedUserNames"

// UserProfileExt\<username>\location  (no fields)
#define MEMDB_CATEGORY_USER_PROFILE_EXT     TEXT("UserProfileExt")

// Paths\<pathitem>\<path>  (no fields)
#define MEMDB_CATEGORY_PATHS                TEXT("Paths")
#define MEMDB_CATEGORY_PATHSA               "Paths"
#define MEMDB_ITEM_RELOC_WINDIR             TEXT("RelocWinDir")
#define MEMDB_ITEM_RELOC_WINDIRA            "RelocWinDir"

// CancelFileDel\<path>
#define MEMDB_CATEGORY_CANCELFILEDEL        TEXT("CancelFileDel")
#define MEMDB_CATEGORY_CANCELFILEDELA       "CancelFileDel"
#define MEMDB_CATEGORY_CANCELFILEDELW       L"CancelFileDel"

// Answer File Restrictions\section\key pattern
#define MEMDB_CATEGORY_UNATTENDRESTRICTRIONS TEXT("SIF Restrictions")

// Answer File Values\<Id>\<Sequence>\Value
#define MEMDB_CATEGORY_AF_VALUES             TEXT("SIF Values")

// Answer File Sections And Keys\Section\<Key Sequence>\<Value sequence>

#define MEMDB_CATEGORY_AF_SECTIONS           TEXT("SIF Sections")


// Ras Migration Data\<user>\<entry>\<item>=<bindata>
#define MEMDB_CATEGORY_RAS_MIGRATION         TEXT("Ras Migration for ")
#define MEMDB_CATEGORY_RAS_INFO              TEXT("RAS Info")
#define MEMDB_CATEGORY_RAS_DATA              TEXT("Ras Data")
#define MEMDB_FIELD_USER_SETTINGS            TEXT("User Settings")

// LogSaveTo\<path>
#define MEMDB_CATEGORY_LOGSAVETO         TEXT("LogSaveTo")

// Pattern for Plug-In DLL list (used in enumeration)
#define MEMDB_CATEGORY_MIGRATION_DLL        TEXT("MigDll")
#define MEMDB_FIELD_DLL                     TEXT("dll")
#define MEMDB_FIELD_WD                      TEXT("wd")
#define MEMDB_FIELD_DESC                    TEXT("desc")
#define MEMDB_FIELD_COMPANY_NAME            TEXT("company")
#define MEMDB_FIELD_SUPPORT_PHONE           TEXT("phone")
#define MEMDB_FIELD_SUPPORT_URL             TEXT("url")
#define MEMDB_FIELD_SUPPORT_INSTRUCTIONS    TEXT("instructions")

// FileRename\<src>\<new>
#define MEMDB_CATEGORY_FILERENAME           TEXT("FileRename")
#define MEMDB_CATEGORY_FILERENAMEA          "FileRename"
#define MEMDB_CATEGORY_FILERENAMEW          L"FileRename"

// Network share conversion (NetShares\<share>\<field>\<data>)
#define MEMDB_CATEGORY_NETSHARES        TEXT("NetShares")
#define MEMDB_FIELD_PATH                TEXT("Path")
#define MEMDB_FIELD_TYPE                TEXT("Type")
#define MEMDB_FIELD_REMARK              TEXT("Remark")
#define MEMDB_FIELD_ACCESS_LIST         TEXT("ACL")
#define MEMDB_FIELD_RO_PASSWORD         TEXT("ROP")
#define MEMDB_FIELD_RW_PASSWORD         TEXT("RWP")

// DOSMIG Categories
#define MEMDB_CATEGORY_DM_LINES         TEXT("DOSMIG LINES")
#define MEMDB_CATEGORY_DM_FILES         TEXT("DOSMIG FILES")

// Registry Suppression
#define MEMDB_CATEGORY_HKR              TEXT("HKR")
#define MEMDB_CATEGORY_HKLM             TEXT("HKLM")

// OLE object suppression
#define MEMDB_CATEGORY_GUIDS            TEXT("GUIDs")
#define MEMDB_CATEGORY_UNSUP_GUIDS      TEXT("UGUIDs")
#define MEMDB_CATEGORY_PROGIDS          TEXT("ProgIDs")

// Domain categories
#define MEMDB_CATEGORY_AUTOSEARCH       TEXT("AutosearchDomain")
#define MEMDB_CATEGORY_KNOWNDOMAIN      TEXT("KnownDomain")


// User passwords
#define MEMDB_CATEGORY_USERPASSWORD     TEXT("UserPassword")

// State category
#define MEMDB_CATEGORY_STATE            TEXT("State")
#define MEMDB_ITEM_MSNP32               TEXT("MSNP32")
#define MEMDB_ITEM_PLATFORM_NAME        TEXT("PlatformName")
#define MEMDB_ITEM_MAJOR_VERSION        TEXT("MajorVersion")
#define MEMDB_ITEM_MINOR_VERSION        TEXT("MinorVersion")
#define MEMDB_ITEM_BUILD_NUMBER         TEXT("BuildNumber")
#define MEMDB_ITEM_PLATFORM_ID          TEXT("PlatformId")
#define MEMDB_ITEM_VERSION_TEXT         TEXT("VersionText")
#define MEMDB_ITEM_CODE_PAGE            TEXT("CodePage")
#define MEMDB_ITEM_LOCALE               TEXT("Locale")
#define MEMDB_ITEM_ADMIN_PASSWORD       TEXT("AP")
#define MEMDB_ITEM_ROLLBACK_SPACE       TEXT("DiskSpaceForRollback")
#define MEMDB_ITEM_MASTER_SEQUENCER     TEXT("MasterSequencer")

// MyDocsMoveWarning\<user>\<path>
#define MEMDB_CATEGORY_MYDOCS_WARNING   TEXT("MyDocsMoveWarning")

// NtFilesRemoved\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_DEL_FILES     TEXT("NtFilesRemoved")
#define MEMDB_CATEGORY_NT_DEL_FILESA    "NtFilesRemoved"
#define MEMDB_CATEGORY_NT_DEL_FILESW    L"NtFilesRemoved"

// NtFiles\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_FILES         TEXT("NtFiles")
#define MEMDB_CATEGORY_NT_FILESA        "NtFiles"
#define MEMDB_CATEGORY_NT_FILESW        L"NtFiles"
#define MEMDB_CATEGORY_NT_FILES_EXCEPT  TEXT("NtFilesExcept")
#define MEMDB_CATEGORY_NT_FILES_EXCEPTA "NtFilesExcept"
#define MEMDB_CATEGORY_NT_FILES_EXCEPTW L"NtFilesExcept"

// NtDirs\<path>
#define MEMDB_CATEGORY_NT_DIRS          TEXT("NtDirs")
#define MEMDB_CATEGORY_NT_DIRSA         "NtDirs"
#define MEMDB_CATEGORY_NT_DIRSW         L"NtDirs"

// NtFilesBad\<filename> = <offset to NtDirs>
#define MEMDB_CATEGORY_NT_FILES_BAD     TEXT("NtFilesBad")
#define MEMDB_CATEGORY_NT_FILES_BADA    "NtFilesBad"
#define MEMDB_CATEGORY_NT_FILES_BADW    L"NtFilesBad"

// ChangedFileProps\<original file path>\<new file name only>
#define MEMDB_CATEGORY_CHG_FILE_PROPS   TEXT("ChangedFileProps")
#define MEMDB_CATEGORY_CHG_FILE_PROPSA  "ChangedFileProps"
#define MEMDB_CATEGORY_CHG_FILE_PROPSW  L"ChangedFileProps"

// Stf\<path>
#define MEMDB_CATEGORY_STF              TEXT("Stf")

// StfTemp\<path>=<infptr>
#define MEMDB_CATEGORY_STF_TEMP         TEXT("StfTemp")

// StfSections\<path>=<section number>
#define MEMDB_CATEGORY_STF_SECTIONS     TEXT("StfSections")

// HelpFilesDll\<dllname>
#define MEMDB_CATEGORY_HELP_FILES_DLL   TEXT("HelpFilesDll")
#define MEMDB_CATEGORY_HELP_FILES_DLLA  "HelpFilesDll"
#define MEMDB_CATEGORY_HELP_FILES_DLLW  L"HelpFilesDll"

// \<dllname>
#define MEMDB_CATEGORY_REPORT           TEXT("Report")

// UserSuppliedDrivers\<infname>\<local_path>
#define MEMDB_CATEGORY_USER_SUPPLIED_DRIVERS    TEXT("UserSuppliedDrivers")

// DisabledMigDlls\<product id>
#define MEMDB_CATEGORY_DISABLED_MIGDLLS TEXT("DisabledMigDlls")

// MissingImports\<missing import sample>
#define MEMDB_CATEGORY_MISSING_IMPORTS   TEXT("MissingImports")
#define MEMDB_CATEGORY_MISSING_IMPORTSA  "MissingImports"
#define MEMDB_CATEGORY_MISSING_IMPORTSW  L"MissingImports"

#define MEMDB_TMP_HIVE                  TEXT("TMP_HIVE")
#define MEMDB_TMP_HIVEA                 "TMP_HIVE"
#define MEMDB_TMP_HIVEW                 L"TMP_HIVE"

// ModuleCheck\<full path module name>=<status value>
#define MEMDB_CATEGORY_MODULE_CHECK     TEXT("TMP_HIVE\\ModuleCheck")
#define MEMDB_CATEGORY_MODULE_CHECKA    "TMP_HIVE\\ModuleCheck"
#define MEMDB_CATEGORY_MODULE_CHECKW    L"TMP_HIVE\\ModuleCheck"

// NewNames\<name group>\<field>\<name>
#define MEMDB_CATEGORY_NEWNAMES             TEXT("NewNames")
#define MEMDB_FIELD_NEW                     TEXT("New")
#define MEMDB_FIELD_OLD                     TEXT("Old")

// InUseNames\<name group>\<name>
#define MEMDB_CATEGORY_INUSENAMES           TEXT("InUseNames")

// DeferredAnnounce\<full path module name> = Offset
#define MEMDB_CATEGORY_DEFERREDANNOUNCE  TEXT("TMP_HIVE\\DeferredAnnounce")
#define MEMDB_CATEGORY_DEFERREDANNOUNCEA "TMP_HIVE\\DeferredAnnounce"
#define MEMDB_CATEGORY_DEFERREDANNOUNCEW L"TMP_HIVE\\DeferredAnnounce"

// KnonwnGood\<full path module name>
#define MEMDB_CATEGORY_KNOWN_GOOD        TEXT("TMP_HIVE\\KnownGood")
#define MEMDB_CATEGORY_KNOWN_GOODA       "TMP_HIVE\\KnownGood"
#define MEMDB_CATEGORY_KNOWN_GOODW       L"TMP_HIVE\\KnownGood"

// CompatibleShellModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_SHELL  TEXT("TMP_HIVE\\CompatibleShellModules")
#define MEMDB_CATEGORY_COMPATIBLE_SHELLA "TMP_HIVE\\CompatibleShellModules"
#define MEMDB_CATEGORY_COMPATIBLE_SHELLW L"TMP_HIVE\\CompatibleShellModules"

// CompatibleShellModulesNT\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NT  TEXT("CompatibleShellModules")
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NTA "CompatibleShellModules"
#define MEMDB_CATEGORY_COMPATIBLE_SHELL_NTW L"CompatibleShellModules"

// CompatibleRunKeyModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY  TEXT("TMP_HIVE\\CompatibleRunKeyModules")
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEYA "TMP_HIVE\\CompatibleRunKeyModules"
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEYW L"TMP_HIVE\\CompatibleRunKeyModules"

// CompatibleRunKeyModulesNT\<value name>
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NT  TEXT("CompatibleRunKeyModules")
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NTA "CompatibleRunKeyModules"
#define MEMDB_CATEGORY_COMPATIBLE_RUNKEY_NTW L"CompatibleRunKeyModules"

// IncompatibleRunKeyModulesNT\<value name>
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NT  TEXT("IncompatibleRunKeyModules")
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NTA "IncompatibleRunKeyModules"
#define MEMDB_CATEGORY_INCOMPATIBLE_RUNKEY_NTW L"IncompatibleRunKeyModules"

// CompatibleDosModules\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_DOS  TEXT("TMP_HIVE\\CompatibleDosModules")
#define MEMDB_CATEGORY_COMPATIBLE_DOSA "TMP_HIVE\\CompatibleDosModules"
#define MEMDB_CATEGORY_COMPATIBLE_DOSW L"TMP_HIVE\\CompatibleDosModules"

// CompatibleDosModulesNT\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NT  TEXT("CompatibleDosModules")
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NTA "CompatibleDosModules"
#define MEMDB_CATEGORY_COMPATIBLE_DOS_NTW L"CompatibleDosModules"

// CompatibleHlpExtensions\<extension module>
#define MEMDB_CATEGORY_GOOD_HLP_EXTENSIONS  TEXT("TMP_HIVE\\GoodHlpExtensions")

// CompatibleHlpFiles\<full path module name>
#define MEMDB_CATEGORY_COMPATIBLE_HLP  TEXT("TMP_HIVE\\CompatibleHlpFiles")
#define MEMDB_CATEGORY_COMPATIBLE_HLPA "TMP_HIVE\\CompatibleHlpFiles"
#define MEMDB_CATEGORY_COMPATIBLE_HLPW L"TMP_HIVE\\CompatibleHlpFiles"

// Shortcuts\<full path shortcut name>
#define MEMDB_CATEGORY_SHORTCUTS        TEXT("TMP_HIVE\\Shortcuts")
#define MEMDB_CATEGORY_SHORTCUTSA       "TMP_HIVE\\Shortcuts"
#define MEMDB_CATEGORY_SHORTCUTSW       L"TMP_HIVE\\Shortcuts"

// BackupDirs\<full path backup dir>
#define MEMDB_CATEGORY_BACKUPDIRS       TEXT("TMP_HIVE\\BackupDirs")
#define MEMDB_CATEGORY_BACKUPDIRSA      "TMP_HIVE\\BackupDirs"
#define MEMDB_CATEGORY_BACKUPDIRSW      L"TMP_HIVE\\BackupDirs"

// ProcessSection\<migdb section>
#define MEMDB_CATEGORY_MIGRATION_SECTION  TEXT("MigrationSection")

// CleanUpDir\<path>
#define MEMDB_CATEGORY_CLEAN_UP_DIR         TEXT("CleanUpDir")

// Win9x APIs
#define MEMDB_CATEGORY_WIN9X_APIS           TEXT("TMP_HIVE\\Win9x APIs")

//
//  Network Adapters and NetTransKeys
//
#define MEMDB_CATEGORY_NETTRANSKEYS     TEXT("NetTransKeys")
#define MEMDB_CATEGORY_NETADAPTERS      TEXT("Network Adapters")
#define MEMDB_FIELD_PNPID               TEXT("PNPID")
#define MEMDB_FIELD_DRIVER              TEXT("Driver")

// Icons\<path>\<index> = offset inside icon data file, flags give new seq
#define MEMDB_CATEGORY_ICONS                TEXT("Icons")

// MovedIcons\<path>\<index> = offset to new path, flags give new seq
#define MEMDB_CATEGORY_ICONS_MOVED          TEXT("IconsMoved")

// NicePaths\<path> = MessageId
#define MEMDB_CATEGORY_NICE_PATHS           TEXT("NicePaths")

// MigrationPaths\<path>
#define MEMDB_CATEGORY_MIGRATION_PATHS      TEXT("MigrationPaths")

// ReportLinks\<ReportEntry>\<Category>
#define MEMDB_CATEGORY_REPORT_LINKS         TEXT("ReportLinks")

// SuppressIniMappings\<suppressed path>
#define MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGS        TEXT("SuppressIniMappings")
#define MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW       L"SuppressIniMappings"

// NoOverwriteIniMappings\<no overwrite path>
#define MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGS        TEXT("NoOverwriteIniMappings")
#define MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW       L"NoOverwriteIniMappings"

// IniConv\<9xIniPath>
#define MEMDB_CATEGORY_INIFILES_CONVERT     TEXT("IniConv")

// TMP_HIVE\ActFirst\<IniPattern>
#define MEMDB_CATEGORY_INIFILES_ACT_FIRST   TEXT("TMP_HIVE\\ActFirst")
// TMP_HIVE\ActLast\<IniPattern>
#define MEMDB_CATEGORY_INIFILES_ACT_LAST    TEXT("TMP_HIVE\\ActLast")

// IniAct\First\<OrigIniPath>\<TempFileLocation>
#define MEMDB_CATEGORY_INIACT_FIRST         TEXT("IniAct\\First")
// IniAct\Last\<OrigIniPath>\<TempFileLocation>
#define MEMDB_CATEGORY_INIACT_LAST          TEXT("IniAct\\Last")

// TMP_HIVE\IgnoreInis\<ignored INI filename>
#define MEMDB_CATEGORY_INIFILES_IGNORE      TEXT("TMP_HIVE\\IgnoreInis")

// PNPIDs\<pnpid>
#define MEMDB_CATEGORY_PNPIDS   TEXT("TMP_HIVE\\PnpIDs")


// UserFileMoveDest\<path>
#define MEMDB_CATEGORY_USERFILEMOVE_DEST    TEXT("UserFileMoveDest")
#define MEMDB_CATEGORY_USERFILEMOVE_DESTA   "UserFileMoveDest"
#define MEMDB_CATEGORY_USERFILEMOVE_DESTW   L"UserFileMoveDest"

// UserFileMoveSrc\<path>\<user>
#define MEMDB_CATEGORY_USERFILEMOVE_SRC    TEXT("UserFileMoveSrc")
#define MEMDB_CATEGORY_USERFILEMOVE_SRCA   "UserFileMoveSrc"
#define MEMDB_CATEGORY_USERFILEMOVE_SRCW   L"UserFileMoveSrc"


// NT Time Zones\<index>\<display>
#define MEMDB_CATEGORY_NT_TIMEZONES         TEXT("TMP_HIVE\\NT Time Zones")

// 9x Time Zones\<display>\<index>
#define MEMDB_CATEGORY_9X_TIMEZONES         TEXT("TMP_HIVE\\9x Time Zones")
#define MEMDB_FIELD_COUNT                   TEXT("Count")
#define MEMDB_FIELD_INDEX                   TEXT("Index")


// SfPath\<path>
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATH       TEXT("SfPath")
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATHA      "SfPath"
#define MEMDB_CATEGORY_SHELL_FOLDERS_PATHW      L"SfPath"

// SfTemp\<path> = <offset> (temporary category)
#define MEMDB_CATEGORY_SF_TEMP                  TEXT("TMP_HIVE\\SfTemp")
#define MEMDB_CATEGORY_SF_TEMPA                 "TMP_HIVE\\SfTemp"
#define MEMDB_CATEGORY_SF_TEMPW                 L"TMP_HIVE\\SfTemp"

// SfOrderNameSrc\<identifier>\<path>\<sequencer> = <shell folder ptr>
#define MEMDB_CATEGORY_SF_ORDER_NAME_SRC    TEXT("TMP_HIVE\\SfOrderNameSrc")

// SfOrderSrc\<path>\<sequencer> = <shell folder ptr>
#define MEMDB_CATEGORY_SF_ORDER_SRC         TEXT("TMP_HIVE\\SfOrderSrc")

// SfMoved\<path>
#define MEMDB_CATEGORY_SHELL_FOLDERS_MOVED  TEXT("TMP_HIVE\\SfMoved")

// ShellFoldersDest
#define MEMDB_CATEGORY_SHELLFOLDERS_DEST            TEXT("ShellFoldersDest")
#define MEMDB_CATEGORY_SHELLFOLDERS_SRC             TEXT("ShellFoldersSrc")
#define MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC    TEXT("ShellFoldersOriginalSrc")


// System32ForcedMove\<file pattern>
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVE     TEXT("TMP_HIVE\\System32ForcedMove")
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVEA    "TMP_HIVE\\System32ForcedMove"
#define MEMDB_CATEGORY_SYSTEM32_FORCED_MOVEW    L"TMP_HIVE\\System32ForcedMove"

// PathRoot\<path>=<sequencer>,<operations>
#define MEMDB_CATEGORY_PATHROOT             TEXT("PathRoot")
#define MEMDB_CATEGORY_PATHROOTA            "PathRoot"
#define MEMDB_CATEGORY_PATHROOTW            L"PathRoot"

// Data\<data>
// OPTIMIZATION: Overlap with PathRoot
#define MEMDB_CATEGORY_DATA                 TEXT("PathRoot")    //TEXT("Data")
#define MEMDB_CATEGORY_DATAA                "PathRoot"          //"Data"
#define MEMDB_CATEGORY_DATAW                L"PathRoot"         //L"Data"

// UserRegData\<value>
#define MEMDB_CATEGORY_USER_REGISTRY_VALUE      TEXT("UserRegData")

// UserRegLoc\<user>\<encoded key>=<offset to REG_SZ>
#define MEMDB_CATEGORY_SET_USER_REGISTRY        TEXT("UserRegLoc")


// SFFilesDest\<path>
#define MEMDB_CATEGORY_SF_FILES_DEST        TEXT("TMP_HIVE\\SFFilesDest")

// SFMigDirs\<SFName>\<Subdir>=<Levels>
#define MEMDB_CATEGORY_SFMIGDIRS            TEXT("TMP_HIVE\\SFMigDirs")

// Mapi32Locations\<filename>
#define MEMDB_CATEGORY_MAPI32_LOCATIONS     TEXT("TMP_HIVE\\Mapi32Locations")

// StartupSF\<path>
#define MEMDB_CATEGORY_SF_STARTUP           TEXT("TMP_HIVE\\StartupSF")
// Keyboard Layouts\<sequencer>\<layoutid>
#define MEMDB_CATEGORY_KEYBOARD_LAYOUTS TEXT("Keyboard Layouts")

// Good Imes\<layoutid>
#define MEMDB_CATEGORY_GOOD_IMES TEXT("Good Imes")

// DirsCollision\<src path>
#define MEMDB_CATEGORY_DIRS_COLLISION       TEXT("DirsCollision")
#define MEMDB_CATEGORY_DIRS_COLLISIONA      "DirsCollision"
#define MEMDB_CATEGORY_DIRS_COLLISIONW      L"DirsCollision"

// IgnoredCollisions\<pattern>
#define MEMDB_CATEGORY_IGNORED_COLLISIONS   TEXT("IgnoredCollisions")
#define MEMDB_CATEGORY_IGNORED_COLLISIONSA  "IgnoredCollisions"
#define MEMDB_CATEGORY_IGNORED_COLLISIONSW  L"IgnoredCollisions"

// Dun Files\full path
#define MEMDB_CATEGORY_DUN_FILES  TEXT("TMP_HIVE\\DUN Files")

// MMedia\System\<System Settings>
#define MEMDB_CATEGORY_MMEDIA_SYSTEM        TEXT("MMedia\\System")
#define MEMDB_CATEGORY_MMEDIA_SYSTEMA       "MMedia\\System"
#define MEMDB_CATEGORY_MMEDIA_SYSTEMW       L"MMedia\\System"

// MMedia\Users\<UserName>\<User Settings>
#define MEMDB_CATEGORY_MMEDIA_USERS         TEXT("MMedia\\Users")
#define MEMDB_CATEGORY_MMEDIA_USERSA        "MMedia\\Users"
#define MEMDB_CATEGORY_MMEDIA_USERSW        L"MMedia\\Users"

//
// Suppress Answer File Setting\<section>\<key>
//
#define MEMDB_CATEGORY_SUPPRESS_ANSWER_FILE_SETTINGS TEXT("Suppress Answer File Setting")

//
// Delete directories and all there contents in textmode.
//
#define MEMDB_CATEGORY_FULL_DIR_DELETES TEXT("Full Directory Deletes")
#define MEMDB_CATEGORY_FULL_DIR_DELETESA "Full Directory Deletes"
#define MEMDB_CATEGORY_FULL_DIR_DELETESW L"Full Directory Deletes"

// Briefcases\<BriefcasePath>
#define MEMDB_CATEGORY_BRIEFCASES       TEXT("Briefcases")

// FileEdit\<path> = <optional binary value>
#define MEMDB_CATEGORY_FILEEDIT             TEXT("FileEdit")
#define MEMDB_CATEGORY_FILEEDITA            "FileEdit"

// CleanOut\<path> = <type>
#define MEMDB_CATEGORY_CLEAN_OUT            TEXT("CleanOut")
#define MEMDB_CATEGORY_CLEAN_OUTW           L"CleanOut"

// EmptyDirs\<path> = <type>
#define MEMDB_CATEGORY_EMPTY_DIRS           TEXT("EmptyDirs")
#define MEMDB_CATEGORY_EMPTY_DIRSA          "EmptyDirs"
#define MEMDB_CATEGORY_EMPTY_DIRSW          L"EmptyDirs"

// CPLs\<CPL name>
#define MEMDB_CATEGORY_CPLS         TEXT("TMP_HIVE\\CPLs")
#define MEMDB_CATEGORY_CPLSA        "TMP_HIVE\\CPLs"
#define MEMDB_CATEGORY_CPLSW        L"TMP_HIVE\\CPLs"

// TMP_HIVE\BadFusion\ComponentName\<AppPath>
#define MEMDB_CATEGORY_BAD_FUSION       TEXT("TMP_HIVE\\BadFusion")

// UseNtFiles\<Win9xName>\<NTName>
#define MEMDB_CATEGORY_USE_NT_FILES     TEXT("UseNtFiles")

// Autologon = <TRUE if should remain on, FALSE if migpwd should run>
#define MEMDB_CATEGORY_AUTOLOGON        TEXT("Autologon")

// ForceCopy section holds win9x keys that are dynamically added to the [Force Win9x Settings]
// section in wkstamig.inx and usermig.inx
// ForceCopy\<Source> = offset
// ForceCopy\<Destination>
#define MEMDB_CATEGORY_FORCECOPY        TEXT("ForceCopy")
#define MEMDB_CATEGORY_FORCECOPYA       "ForceCopy"
#define MEMDB_CATEGORY_FORCECOPYW       L"ForceCopy"

// TMP_HIVE\\CompatReport\Components = <Compatibility Report Component>
// TMP_HIVE\\CompatReport\Objects = <Component pointer>
#define MEMDB_CATEGORY_COMPATREPORT     TEXT("TMP_HIVE\\CompatReport")
#define MEMDB_ITEM_OBJECTS              TEXT("Objects")
#define MEMDB_ITEM_COMPONENTS           TEXT("Components")

// SfPerUser\<shell folder tag> = <offset to common>
#define MEMDB_CATEGORY_SF_PERUSER       TEXT("SfPerUser")

// SfCommon\<shell folder tag> = <offset to per-user>
#define MEMDB_CATEGORY_SF_COMMON        TEXT("SfCommon")

// TMP_HIVE\\UserSfCollisions\<ShellFolderId>\<ShellFolderPath>
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONS       TEXT("TMP_HIVE\\ProfilesSfCollisions")
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONSA      "TMP_HIVE\\ProfilesSfCollisions"
#define MEMDB_CATEGORY_PROFILES_SF_COLLISIONSW      L"TMP_HIVE\\ProfilesSfCollisions"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\memdb.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memdb.h

Abstract:

    Declares interfaces for memdb, the memory database.  MemDb is
    used throughout the Win9x upgrade project to record OS state
    and to track operations on files and the registry.

    See common\memdb for implementation details.

Author:

    Jim Schmidt (jimschm) 15-Nov-1996

Revision History:

    jimschm     05-Apr-1999     MemDbGetStoredEndPatternValue
    jimschm     18-Jan-1999     Version APIs
    jimschm     23-Sep-1998     Proxy node capability
    jimschm     24-Jun-1998     MemDbMove capability
    jimschm     30-Oct-1997     Temporary hive capability
    jimschm     31-Jul-1997     Hashing for faster access
    jimschm     19-Mar-1997     Binary node capability
    jimschm     28-Feb-1997     Offset access capabilities
    jimschm     20-Dec-1996     Ex routines

--*/

#pragma once

#define INVALID_OFFSET 0xffffffff

#include "memdbdef.h"

#define MEMDB_MAX 2048

//
// My net share flag, used to distinguish user-level security and
// password-level security.  When it is specified, user-level
// security is enabled, and NetShares\<share>\ACL\<list> exists.
//

#define SHI50F_ACLS         0x1000

typedef BYTE const * PCBYTE;


//
// Enumerator struct
//

#define MAX_ENUM_POS (MEMDB_MAX/2)

typedef struct {
    // Outbound key and value
    WCHAR szName[MEMDB_MAX];

    BOOL bEndpoint;
    BOOL bBinary;
    BOOL bProxy;
    DWORD UserFlags;

    // if !bBinary
    DWORD dwValue;

    // if bBinary
    PCBYTE BinaryPtr;
    DWORD BinarySize;

    DWORD Offset;

    // Internally maintained members
    WCHAR PatternStr[MEMDB_MAX];
    PWSTR PatPos;
    DWORD LastPos[MAX_ENUM_POS];
    int PosCount;
    int Depth;
    int Start;
    DWORD Flags;
} MEMDB_ENUMW, *PMEMDB_ENUMW;

typedef struct {
    // Outbound key and value
    CHAR szName[MEMDB_MAX * sizeof (WCHAR)];

    BOOL bEndpoint;
    BOOL bBinary;
    BOOL bProxy;
    DWORD UserFlags;

    // if !bBinary
    DWORD dwValue;

    // if bBinary
    PCBYTE BinaryPtr;
    DWORD BinarySize;

    DWORD Offset;

    // Internally maintained members
    WCHAR PatternStr[MEMDB_MAX];
    PWSTR PatPos;
    DWORD LastPos[MAX_ENUM_POS];
    int PosCount;
    int Depth;
    int Start;
    DWORD Flags;
} MEMDB_ENUMA, *PMEMDB_ENUMA;

// enumeration flags
#define NO_FLAGS                0x00000000
#define MEMDB_ALL_MATCHES       0
#define MEMDB_ENDPOINTS_ONLY    1
#define MEMDB_BINARY_NODES_ONLY 2
#define MEMDB_PROXY_NODES_ONLY  3
#define MEMDB_ALL_BUT_PROXY     4

// enumeration level
#define MEMDB_ALL_SUBLEVELS     0
#define MEMDB_THIS_LEVEL_ONLY   1

typedef struct {
    BOOL Valid;
    BOOL Debug;
    UINT Version;
    BOOL CurrentVersion;
} MEMDB_VERSION, *PMEMDB_VERSION;

//
// Function prototypes
//

BOOL MemDbSetValueA (PCSTR szKeyName, DWORD dwValue);
BOOL MemDbSetValueW (PCWSTR szKeyName, DWORD dwValue);

BOOL MemDbSetValueAndFlagsA (PCSTR szKeyName, DWORD dwValue, DWORD SetFlags, DWORD ClearFlags);
BOOL MemDbSetValueAndFlagsW (PCWSTR szKeyName, DWORD dwValue, DWORD SetFlags, DWORD ClearFlags);

BOOL MemDbSetBinaryValueA (PCSTR szKeyName, PCBYTE Data, DWORD DataSize);
BOOL MemDbSetBinaryValueW (PCWSTR szKeyName, PCBYTE Data, DWORD DataSize);

BOOL MemDbGetValueA (PCSTR szKeyName, PDWORD lpdwValue);
BOOL MemDbGetValueW (PCWSTR szKeyName, PDWORD lpdwValue);

BOOL MemDbGetValueAndFlagsA (PCSTR szKeyName, PDWORD lpdwValue, PDWORD UserFlagsPtr);
BOOL MemDbGetValueAndFlagsW (PCWSTR szKeyName, PDWORD lpdwValue, PDWORD UserFlagsPtr);

PCBYTE MemDbGetBinaryValueA (PCSTR szKeyName, PDWORD DataSize);
PCBYTE MemDbGetBinaryValueW (PCWSTR szKeyName, PDWORD DataSize);

BOOL MemDbGetPatternValueA (PCSTR szKey, PDWORD lpdwValue);
BOOL MemDbGetPatternValueW (PCWSTR szKey, PDWORD lpdwValue);

BOOL MemDbGetStoredEndPatternValueA (PCSTR Key, PDWORD Value);
BOOL MemDbGetStoredEndPatternValueW (PCWSTR Key, PDWORD Value);

BOOL MemDbGetValueWithPatternA (PCSTR szKeyPattern, PDWORD lpdwValue);
BOOL MemDbGetValueWithPatternW (PCWSTR szKeyPattern, PDWORD lpdwValue);

BOOL MemDbGetPatternValueWithPatternA (PCSTR szKeyPattern, PDWORD lpdwValue);
BOOL MemDbGetPatternValueWithPatternW (PCWSTR szKeyPattern, PDWORD lpdwValue);

void MemDbDeleteValueA (PCSTR szKey);
void MemDbDeleteValueW (PCWSTR szKey);

void MemDbDeleteTreeA (PCSTR szKey);
void MemDbDeleteTreeW (PCWSTR szKey);

BOOL MemDbEnumFirstValueA (PMEMDB_ENUMA pEnum, PCSTR szPattern, int Depth, DWORD Flags);
BOOL MemDbEnumFirstValueW (PMEMDB_ENUMW pEnum, PCWSTR szPattern, int Depth, DWORD Flags);

BOOL MemDbEnumNextValueA (PMEMDB_ENUMA pEnum);
BOOL MemDbEnumNextValueW (PMEMDB_ENUMW pEnum);

BOOL MemDbSaveA (PCSTR szFile);
BOOL MemDbSaveW (PCWSTR szFile);

BOOL MemDbLoadA (PCSTR szFile);
BOOL MemDbLoadW (PCWSTR szFile);

VOID MemDbBuildKeyA (PSTR Buffer, PCSTR Category,  PCSTR Item,  PCSTR Field,  PCSTR Data);
VOID MemDbBuildKeyW (PWSTR Buffer, PCWSTR Category, PCWSTR Item, PCWSTR Field, PCWSTR Data);

BOOL MemDbSetValueExA (PCSTR Category,  PCSTR Item,  PCSTR Field,
                       PCSTR Data, DWORD Val, PDWORD Offset);

BOOL MemDbSetValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field,
                       PCWSTR Data, DWORD Val, PDWORD Offset);

BOOL MemDbSetBinaryValueExA (PCSTR Category,  PCSTR Item,  PCSTR Field,
                             PCBYTE Data, DWORD DataSize, PDWORD Offset);

BOOL MemDbSetBinaryValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field,
                             PCBYTE Data, DWORD DataSize, PDWORD Offset);

BOOL MemDbBuildKeyFromOffsetA (DWORD Offset, PSTR Buffer, DWORD StartLevel, PDWORD Val);
BOOL MemDbBuildKeyFromOffsetW (DWORD Offset, PWSTR Buffer, DWORD StartLevel, PDWORD Val);

BOOL MemDbBuildKeyFromOffsetExA (DWORD Offset, PSTR Buffer, PDWORD BufferLen, DWORD StartLevel, PDWORD Val, PDWORD UserFlags);
BOOL MemDbBuildKeyFromOffsetExW (DWORD Offset, PWSTR Buffer, PDWORD BufferLen, DWORD StartLevel, PDWORD Val, PDWORD UserFlags);

BOOL MemDbGetOffsetA(PCSTR Key,PDWORD Offset);
BOOL MemDbGetOffsetW(PCWSTR Key,PDWORD Offset);

BOOL MemDbGetOffsetExA(PCSTR Category, PCSTR Item, PCSTR Field, PCSTR Data, PDWORD Offset);
BOOL MemDbGetOffsetExW(PCWSTR Category, PCWSTR Item, PCWSTR Field, PCWSTR Data, PDWORD Offset);

BOOL MemDbEnumItemsA  (PMEMDB_ENUMA pEnum, PCSTR  Category);
BOOL MemDbEnumItemsW  (PMEMDB_ENUMW pEnum, PCWSTR Category);

BOOL MemDbEnumFieldsA (PMEMDB_ENUMA pEnum, PCSTR  Category, PCSTR  Item);
BOOL MemDbEnumFieldsW (PMEMDB_ENUMW pEnum, PCWSTR Category, PCWSTR Item);

BOOL MemDbGetValueExA (PMEMDB_ENUMA pEnum, PCSTR  Category, PCSTR  Item,  PCSTR Field);
BOOL MemDbGetValueExW (PMEMDB_ENUMW pEnum, PCWSTR Category, PCWSTR Item, PCWSTR Field);

BOOL MemDbGetEndpointValueA (PCSTR Pattern, PCSTR Item, PSTR Buffer);
BOOL MemDbGetEndpointValueW (PCWSTR Pattern, PCWSTR Item, PWSTR Buffer);

BOOL MemDbGetEndpointValueExA (PCSTR Category, PCSTR Item, PCSTR Field, PSTR Buffer);
BOOL MemDbGetEndpointValueExW (PCWSTR Category, PCWSTR Item, PCWSTR Field, PWSTR Buffer);

BOOL MemDbValidateDatabase (VOID);

BOOL MemDbQueryVersionA (PCSTR FileName, PMEMDB_VERSION Version);
BOOL MemDbQueryVersionW (PCWSTR FileName, PMEMDB_VERSION Version);

BOOL MemDbCreateTemporaryKeyA (PCSTR KeyName);
BOOL MemDbCreateTemporaryKeyW (PCWSTR KeyName);

BOOL
MemDbMoveTreeA (
    IN      PCSTR RootNode,
    IN      PCSTR NewRoot
    );

BOOL
MemDbMoveTreeW (
    IN      PCWSTR RootNode,
    IN      PCWSTR NewRoot
    );

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    );

BOOL
MemDbImportA (
    IN      PCSTR FileName
    );

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    );



#define MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1            0x0001
#define MEMDB_CONVERT_WILD_STAR_TO_ASCII_2              0x0002
#define MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3             0x0002
// other conversion to be implemented when needed

VOID MemDbMakeNonPrintableKeyA (PSTR KeyName, DWORD Flags);
VOID MemDbMakeNonPrintableKeyW (PWSTR KeyName, DWORD Flags);

VOID MemDbMakePrintableKeyA (PSTR KeyName, DWORD Flags);
VOID MemDbMakePrintableKeyW (PWSTR KeyName, DWORD Flags);

VOID GetFixedUserNameA (PSTR UserName);
VOID GetFixedUserNameW (PWSTR UserName);

//
// Internal routines for memdbt
//

typedef struct {
    UINT NextItem : 28;
    UINT Hive : 4;
} HASHINFO;

typedef struct _tagHASHSTRUCT {
    DWORD Offset;
    HASHINFO Info;
} BUCKETSTRUCT, *PBUCKETSTRUCT;

typedef struct {
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    UINT Bucket;
    DWORD LastOffset;
} HASHENUM, *PHASHENUM;


BOOL
EnumFirstHashEntry (
    OUT     PHASHENUM HashEnum
    );

BOOL
EnumNextHashEntry (
    IN OUT  PHASHENUM HashEnum
    );

//
// A & W
//

#ifdef UNICODE

#define MEMDB_ENUM MEMDB_ENUMW
#define PMEMDB_ENUM PMEMDB_ENUMW

#define MemDbSetValue MemDbSetValueW
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsW
#define MemDbSetBinaryValue MemDbSetBinaryValueW
#define MemDbGetValue MemDbGetValueW
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsW
#define MemDbGetBinaryValue MemDbGetBinaryValueW
#define MemDbGetPatternValue MemDbGetPatternValueW
#define MemDbGetValueWithPattern MemDbGetValueWithPatternW
#define MemDbGetPatternValueWithPattern MemDbGetPatternValueWithPatternW
#define MemDbGetStoredEndPatternValue MemDbGetStoredEndPatternValueW
#define MemDbDeleteValue MemDbDeleteValueW
#define MemDbDeleteTree MemDbDeleteTreeW
#define MemDbEnumFirstValue MemDbEnumFirstValueW
#define MemDbEnumNextValue MemDbEnumNextValueW
#define MemDbSave MemDbSaveW
#define MemDbLoad MemDbLoadW
#define MemDbBuildKey MemDbBuildKeyW
#define MemDbSetValueEx MemDbSetValueExW
#define MemDbSetBinaryValueEx MemDbSetBinaryValueExW
#define MemDbBuildKeyFromOffset MemDbBuildKeyFromOffsetW
#define MemDbBuildKeyFromOffsetEx MemDbBuildKeyFromOffsetExW
#define MemDbGetOffset MemDbGetOffsetW
#define MemDbGetOffsetEx MemDbGetOffsetExW
#define MemDbEnumItems MemDbEnumItemsW
#define MemDbEnumFields MemDbEnumFieldsW
#define MemDbGetValueEx MemDbGetValueExW
#define MemDbGetEndpointValue MemDbGetEndpointValueW
#define MemDbGetEndpointValueEx MemDbGetEndpointValueExW
#define MemDbQueryVersion MemDbQueryVersionW
#define MemDbCreateTemporaryKey MemDbCreateTemporaryKeyW
#define MemDbMoveTree MemDbMoveTreeW
#define MemDbExport MemDbExportW
#define MemDbImport MemDbImportW
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyW
#define MemDbMakePrintableKey MemDbMakePrintableKeyW
#define GetFixedUserName GetFixedUserNameW

#else

#define MEMDB_ENUM MEMDB_ENUMA
#define PMEMDB_ENUM PMEMDB_ENUMA

#define MemDbSetValue MemDbSetValueA
#define MemDbSetValueAndFlags MemDbSetValueAndFlagsA
#define MemDbSetBinaryValue MemDbSetBinaryValueA
#define MemDbGetValue MemDbGetValueA
#define MemDbGetValueAndFlags MemDbGetValueAndFlagsA
#define MemDbGetBinaryValue MemDbGetBinaryValueA
#define MemDbGetPatternValue MemDbGetPatternValueA
#define MemDbGetValueWithPattern MemDbGetValueWithPatternA
#define MemDbGetPatternValueWithPattern MemDbGetPatternValueWithPatternA
#define MemDbGetStoredEndPatternValue MemDbGetStoredEndPatternValueA
#define MemDbDeleteValue MemDbDeleteValueA
#define MemDbDeleteTree MemDbDeleteTreeA
#define MemDbEnumFirstValue MemDbEnumFirstValueA
#define MemDbEnumNextValue MemDbEnumNextValueA
#define MemDbSave MemDbSaveA
#define MemDbLoad MemDbLoadA
#define MemDbBuildKey MemDbBuildKeyA
#define MemDbSetValueEx MemDbSetValueExA
#define MemDbSetBinaryValueEx MemDbSetBinaryValueExA
#define MemDbBuildKeyFromOffset MemDbBuildKeyFromOffsetA
#define MemDbBuildKeyFromOffsetEx MemDbBuildKeyFromOffsetExA
#define MemDbGetOffset MemDbGetOffsetA
#define MemDbGetOffsetEx MemDbGetOffsetExA
#define MemDbEnumItems MemDbEnumItemsA
#define MemDbEnumFields MemDbEnumFieldsA
#define MemDbGetValueEx MemDbGetValueExA
#define MemDbGetEndpointValue MemDbGetEndpointValueA
#define MemDbGetEndpointValueEx MemDbGetEndpointValueExA
#define MemDbQueryVersion MemDbQueryVersionA
#define MemDbCreateTemporaryKey MemDbCreateTemporaryKeyA
#define MemDbMoveTree MemDbMoveTreeA
#define MemDbExport MemDbExportA
#define MemDbImport MemDbImportA
#define MemDbMakeNonPrintableKey MemDbMakeNonPrintableKeyA
#define MemDbMakePrintableKey MemDbMakePrintableKeyA
#define GetFixedUserName GetFixedUserNameA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\migutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migutil.h

Abstract:

    Includes all header files necessary to use the lib generated by
    common\migutil.  Declares a bunch of utility functions and macros.
    Declares project-wide MAX constants.

Author:

    Jim Schmidt (jimschm) 23-Aug-1996

Revision History:

    Many changes, see SLM log for details.

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// MAX constants
//

#define MAX_PATH_PLUS_NUL           (MAX_PATH+1)
#define MAX_MBCHAR_PATH             (MAX_PATH_PLUS_NUL*2)
#define MAX_WCHAR_PATH              MAX_PATH_PLUS_NUL
#define MAX_MBCHAR_PRINTABLE_PATH   (MAX_PATH*2)
#define MAX_WCHAR_PRINTABLE_PATH    MAX_PATH

#define MAX_SERVER_NAMEA            (64*2)
#define MAX_USER_NAMEA              (MAX_PATH)
#define MAX_REGISTRY_KEYA           (1024 * 2)
#define MAX_REGISTRY_VALUE_NAMEA    (260 * 2)
#define MAX_COMPONENT_NAMEA         (256 * 2)
#define MAX_COMPUTER_NAMEA          (64 * 2)
#define MAX_CMDLINEA                (1024 * 2)     // maximum number of chars in a Win95 command line
#define MAX_TRANSLATION             32
#define MAX_KEYBOARDLAYOUT          64
#define MAX_INF_SECTION_NAME        128
#define MAX_INF_KEY_NAME            128

#define MAX_SERVER_NAMEW            64
#define MAX_USER_NAMEW              (MAX_PATH)
#define MAX_REGISTRY_KEYW           1024
#define MAX_REGISTRY_VALUE_NAMEW    260
#define MAX_COMPONENT_NAMEW         256
#define MAX_COMPUTER_NAMEW          64

#define MAX_CMDLINEW	            1024            // maximum number of chars in a Win95 command line

#ifdef UNICODE

#define MAX_SERVER_NAME             MAX_SERVER_NAMEW
#define MAX_USER_NAME               MAX_USER_NAMEW
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYW
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEW
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEW
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEW
#define MAX_CMDLINE	                MAX_CMDLINEW

#define MAX_TCHAR_PATH              MAX_WCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_WCHAR_PRINTABLE_PATH

#else

#define MAX_SERVER_NAME             MAX_SERVER_NAMEA
#define MAX_USER_NAME               MAX_USER_NAMEA
#define MAX_REGISTRY_KEY            MAX_REGISTRY_KEYA
#define MAX_REGISTRY_VALUE_NAME     MAX_REGISTRY_VALUE_NAMEA
#define MAX_COMPONENT_NAME          MAX_COMPONENT_NAMEA
#define MAX_COMPUTER_NAME           MAX_COMPUTER_NAMEA
#define MAX_CMDLINE	                MAX_CMDLINEA

#define MAX_TCHAR_PATH              MAX_MBCHAR_PATH
#define MAX_TCHAR_PRINTABLE_PATH    MAX_MBCHAR_PRINTABLE_PATH

#endif



//
// Critical Section APIs, implemented because TryEnterCriticalSection is
// supported only on NT, and we need it on Win9x.
//

typedef struct {
    HANDLE EventHandle;
} OUR_CRITICAL_SECTION, *POUR_CRITICAL_SECTION;

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    );

PSTR
UnicodeToCcs (
    PCWSTR Source
    );

//
// Fail-proof memory allocators
//

PVOID
SafeHeapAlloc (
    HANDLE g_hHeap,
    DWORD Flags,
    SIZE_T Size
    );

PVOID
SafeHeapReAlloc (
    HANDLE g_hHeap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    );

//
// Includes of util modules
//

extern HINSTANCE g_hInst;
extern HANDLE g_hHeap;
extern OSVERSIONINFOA g_OsInfo;
extern BOOL g_IsMbcp;

#include "debug.h"
#include "log.h"
#include "staticsz.h"
#include "growbuf.h"        // must appear before strings.h and file.h
#include "strings.h"
#include "poolmem.h"
#include "growlist.h"
#include "file.h"
#include "reg.h"
#include "ipc.h"
#include "fileenum.h"
#include "inf.h"
#include "unicode.h"
#include "hash.h"
#include "persist.h"


VOID
CenterWindow (
    HWND Wnd,
    HWND Parent     OPTIONAL
    );

VOID
TurnOnWaitCursor (
    VOID
    );

VOID
TurnOffWaitCursor (
    VOID
    );


//
// Version APIs
//

typedef struct {
    WORD CodePage;
    WORD Language;
} TRANSLATION, *PTRANSLATION;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    CHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCSTR FileSpec;
    PCSTR VersionField;
} VERSION_STRUCTA, *PVERSION_STRUCTA;

typedef struct {
    GROWBUFFER GrowBuf;
    PBYTE VersionBuffer;
    PTRANSLATION Translations;
    PBYTE StringBuffer;
    UINT Size;
    DWORD Handle;
    VS_FIXEDFILEINFO *FixedInfo;
    UINT FixedInfoSize;
    WCHAR TranslationStr[MAX_TRANSLATION];
    UINT MaxTranslations;
    UINT CurrentTranslation;
    UINT CurrentDefaultTranslation;
    PCWSTR FileSpec;
    PCWSTR VersionField;
} VERSION_STRUCTW, *PVERSION_STRUCTW;

BOOL
CreateVersionStructA (
    OUT     PVERSION_STRUCTA VersionStruct,
    IN      PCSTR FileSpec
    );

VOID
DestroyVersionStructA (
    IN      PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumFirstVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumNextVersionTranslationA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

PCSTR
EnumFirstVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct,
    IN      PCSTR VersionField
    );

PCSTR
EnumNextVersionValueA (
    IN OUT  PVERSION_STRUCTA VersionStruct
    );

BOOL
CreateVersionStructW (
    OUT     PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR FileSpec
    );

VOID
DestroyVersionStructW (
    IN      PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumFirstVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumNextVersionTranslationW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

PCWSTR
EnumFirstVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct,
    IN      PCWSTR VersionField
    );

PCWSTR
EnumNextVersionValueW (
    IN OUT  PVERSION_STRUCTW VersionStruct
    );

ULONGLONG
VerGetFileVer (
    IN      PVERSION_STRUCTA VersionStruct
    );

ULONGLONG
VerGetProductVer (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileDateLo (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileDateHi (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileVerOs (
    IN      PVERSION_STRUCTA VersionStruct
    );

DWORD
VerGetFileVerType (
    IN      PVERSION_STRUCTA VersionStruct
    );

//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple
//

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    SIZE_T SizeNeeded
    );

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    );


VOID
OutOfMemory_Terminate (
    VOID
    );


VOID
SetOutOfMemoryParent (
    HWND hwnd
    );




//
// Error condition tags.
//
// These tags should be used for all error conditions.
//

#define ERROR_CRITICAL
#define ERROR_NONCRITICAL
#define ERROR_TRIVIAL
#define ERROR_ABNORMAL_CONDITION

//
// OSVERSION macros...
//
#define BUILDNUMBER()       (LOWORD(g_OsInfo.dwBuildNumber))
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && BUILDNUMBER() <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && BUILDNUMBER() > 1000)
#define ISWIN95()           (ISWIN9X() && !ISATLEASTWIN98())
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define ISMILLENNIUM()      (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==90)
#define ISATLEASTOSR2()     (ISWIN9X() && g_OsInfo.dwMajorVersion>=4 && BUILDNUMBER()>1000)
#define ISATLEASTWIN98()    (ISWIN9X() && g_OsInfo.dwMajorVersion>=4 && g_OsInfo.dwMinorVersion>=10)

//
// Platform macros...
//

extern BOOL g_IsPc98;
#define ISPC98()            (g_IsPc98)

//
// Boot drive letter
//

extern PCSTR g_BootDrivePathA;
extern PCWSTR g_BootDrivePathW;
extern PCSTR g_BootDriveA;
extern PCWSTR g_BootDriveW;
extern CHAR g_BootDriveLetterA;
extern WCHAR g_BootDriveLetterW;

//
// String Mapping
//

#define STRMAP_ANY_MATCH                            0
#define STRMAP_COMPLETE_MATCH_ONLY                  0x0001
#define STRMAP_FIRST_CHAR_MUST_MATCH                0x0002
#define STRMAP_RETURN_AFTER_FIRST_REPLACE           0x0004
#define STRMAP_REQUIRE_WACK_OR_NUL                  0x0008

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR BeginningOfMatch;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR BeginningOfMatch;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} REG_REPLACE_DATA, *PREG_REPLACE_DATA;

typedef BOOL(REG_REPLACE_FILTER_PROTOTYPE)(PREG_REPLACE_DATA Data);
typedef REG_REPLACE_FILTER_PROTOTYPE * REG_REPLACE_FILTER;

typedef struct TAG_CHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;

    struct TAG_CHARNODE *NextLevel;
    struct TAG_CHARNODE *NextPeer;

} CHARNODE, *PCHARNODE;

typedef struct {
    CHARNODE Node;
    REG_REPLACE_FILTER Filter;
    ULONG_PTR ExtraData;
} CHARNODEEX, *PCHARNODEEX;


typedef struct {
    POOLHANDLE Pool;
    PCHARNODE FirstLevelRoot;
    BOOL UsesExNode;
    BOOL UsesFilter;
    BOOL UsesExtraData;
} MAPSTRUCT, *PMAPSTRUCT;

//
// APIs
//

PMAPSTRUCT
CreateStringMappingEx (
    IN      BOOL UsesFilter,
    IN      BOOL UsesExtraData
    );

#define CreateStringMapping()   CreateStringMappingEx(FALSE,FALSE)

VOID
DestroyStringMapping (
    IN      PMAPSTRUCT Map
    );

VOID
AddStringMappingPairExA (
    IN OUT  PMAPSTRUCT Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairA(Map,Old,New) AddStringMappingPairExA(Map,Old,New,NULL,0,0)

VOID
AddStringMappingPairExW (
    IN OUT  PMAPSTRUCT Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      REG_REPLACE_FILTER Filter,      OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define AddStringMappingPairW(Map,Old,New) AddStringMappingPairExW(Map,Old,New,NULL,0,0)

BOOL
MappingSearchAndReplaceExA (
    IN      PMAPSTRUCT Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingSearchAndReplaceA(map,buffer,maxbytes)   MappingSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingSearchAndReplaceExW (
    IN      PMAPSTRUCT Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingSearchAndReplaceW(map,buffer,maxbytes)   MappingSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExA (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceA(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExA(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
MappingMultiTableSearchAndReplaceExW (
    IN      PMAPSTRUCT *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define MappingMultiTableSearchAndReplaceW(array,count,buffer,maxbytes)   \
        MappingMultiTableSearchAndReplaceExW(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    );



typedef struct {
    WCHAR DisplayName[80];
    ULONGLONG Checksum;

    WCHAR Version[80];
    WCHAR Publisher[80];
    WCHAR ProductID[80];
    WCHAR RegisteredOwner[80];
    WCHAR RegisteredCompany[80];
    WCHAR Language[80];
    WCHAR SupportUrl[80];
    WCHAR SupportTelephone[80];
    WCHAR HelpLink[80];
    WCHAR InstallLocation[80];
    WCHAR InstallSource[80];
    WCHAR InstallDate[80];
    WCHAR Contact[80];
    WCHAR Comments[80];
    WCHAR Image[80];
    WCHAR ReadmeUrl[80];
    WCHAR UpdateInfoUrl[80];
} INSTALLEDAPPW, *PINSTALLEDAPPW;

PINSTALLEDAPPW
GetInstalledAppsW (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT Count             OPTIONAL
    );

typedef PVOID MOVELISTW;


MOVELISTW
AllocateMoveListW (
    IN      POOLHANDLE PoolHandle
    );

//
// Free move list by destrying the pool it was allocated from
//

BOOL
InsertMoveIntoListW (
    IN      MOVELISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    );

MOVELISTW
RemoveMoveListOverlapW (
    IN      MOVELISTW List
    );

BOOL
OutputMoveListW (
    IN      HANDLE File,
    IN      MOVELISTW List,         OPTIONAL
    IN      BOOL AddNestedMoves
    );


BOOL
BuildSystemDirectoryPathA (
    OUT     PSTR Buffer,
    IN      UINT BufferSizeInTchars,
    IN      PCSTR SubPath               OPTIONAL
    );

BOOL
BuildSystemDirectoryPathW (
    OUT     PWSTR Buffer,
    IN      UINT BufferSizeInTchars,
    IN      PCWSTR SubPath              OPTIONAL
    );

HMODULE
LoadSystemLibraryA (
    IN      PCSTR DllFileName
    );

HMODULE
LoadSystemLibraryW (
    IN      PCWSTR DllFileName
    );

DWORD
OurGetModuleFileNameA (
    IN      HMODULE Module,
    OUT     PSTR Buffer,
    IN      INT BufferChars
    );

DWORD
OurGetModuleFileNameW (
    IN      HMODULE Module,
    OUT     PWSTR Buffer,
    IN      INT BufferChars
    );

//
// by default, everybody should use OurGetModuleFileName which makes sure
// the output buffer is nul-terminated; this also helps keeping code prefast-clean
//
#undef GetModuleFileName
#define GetModuleFileNameA              OurGetModuleFileNameA
#define GetModuleFileNameW              OurGetModuleFileNameW


#ifdef UNICODE

#define g_BootDrivePath     g_BootDrivePathW
#define g_BootDrive         g_BootDriveW
#define g_BootDriveLetter   g_BootDriveLetterW

#define MOVELIST                        MOVELISTW
#define AllocateMoveList                AllocateMoveListW
#define InsertMoveIntoList              InsertMoveIntoListW
#define RemoveMoveListOverlap           RemoveMoveListOverlapW
#define OutputMoveList                  OutputMoveListW

#define VERSION_STRUCT                  VERSION_STRUCTW
#define PVERSION_STRUCT                 PVERSION_STRUCTW
#define CreateVersionStruct             CreateVersionStructW
#define DestroyVersionStruct            DestroyVersionStructW
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationW
#define EnumNextVersionTranslation      EnumNextVersionTranslationW
#define EnumFirstVersionValue           EnumFirstVersionValueW
#define EnumNextVersionValue            EnumNextVersionValueW

#define PINSTALLEDAPP                   PINSTALLEDAPPW
#define GetInstalledApps                GetInstalledAppsW

#define AddStringMappingPairEx                  AddStringMappingPairExW
#define AddStringMappingPair                    AddStringMappingPairW
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExW
#define MappingSearchAndReplace                 MappingSearchAndReplaceW
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExW
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceW

#define BuildSystemDirectoryPath        BuildSystemDirectoryPathW
#define LoadSystemLibrary               LoadSystemLibraryW
#define OurGetModuleFileName            OurGetModuleFileNameW
#define GetModuleFileName               OurGetModuleFileNameW

#else

#define g_BootDrivePath     g_BootDrivePathA
#define g_BootDrive         g_BootDriveA
#define g_BootDriveLetter   g_BootDriveLetterA

#define VERSION_STRUCT                  VERSION_STRUCTA
#define PVERSION_STRUCT                 PVERSION_STRUCTA
#define CreateVersionStruct             CreateVersionStructA
#define DestroyVersionStruct            DestroyVersionStructA
#define EnumFirstVersionTranslation     EnumFirstVersionTranslationA
#define EnumNextVersionTranslation      EnumNextVersionTranslationA
#define EnumFirstVersionValue           EnumFirstVersionValueA
#define EnumNextVersionValue            EnumNextVersionValueA

#define AddStringMappingPairEx                  AddStringMappingPairExA
#define AddStringMappingPair                    AddStringMappingPairA
#define MappingSearchAndReplaceEx               MappingSearchAndReplaceExA
#define MappingSearchAndReplace                 MappingSearchAndReplaceA
#define MappingMultiTableSearchAndReplaceEx     MappingMultiTableSearchAndReplaceExA
#define MappingMultiTableSearchAndReplace       MappingMultiTableSearchAndReplaceA

#define BuildSystemDirectoryPath        BuildSystemDirectoryPathA
#define LoadSystemLibrary               LoadSystemLibraryA
#define OurGetModuleFileName            OurGetModuleFileNameA
#define GetModuleFileName               OurGetModuleFileNameA

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\poolmem.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    poolmem.h

Abstract:

    Declares the pool memory interface.  A pool of memory is a set of
    blocks (typically 8K each) that are used for several allocations,
    and then freed at the end of processing.  See below for routines.

Author:

    Marc R. Whitten (marcw)     02-Feb-1997

Revision History:

    jimschm     04-Feb-1998     Named pools for tracking

--*/

#pragma once

typedef PVOID POOLHANDLE;


/*++

  Create and destroy routines:

    POOLHANDLE
    PoolMemInitPool (
        VOID
        );

    POOLHANDLE
    PoolMemInitNamedPool (
        IN      PCSTR Name
        );

    VOID
    PoolMemDestroyPool (
        IN      POOLHANDLE Handle
        );

  Primitive routines:

    PVOID
    PoolMemGetMemory (
        IN      POOLHANDLE Handle,
        IN      SIZE_T Size
        );

    PVOID
    PoolMemGetAlignedMemory (
        IN      POOLHANDLE Handle,
        IN      SIZE_T Size
        );

    VOID
    PoolMemReleaseMemory (
        IN      POOLHANDLE Handle,
        IN      PVOID Memory
        );

  Performance and debugging control:

    VOID
    PoolMemSetMinimumGrowthSize (
        IN      POOLHANDLE Handle,
        IN      SIZE_T GrowthSize
        );

    VOID
    PoolMemEmptyPool (
        IN      POOLHANDLE Handle
        );

    VOID
    PoolMemDisableTracking (
        IN      POOLHANDLE Handle
        );

  Allocation and duplication of data types:

    PCTSTR
    PoolMemCreateString (
        IN      POOLHANDLE Handle,
        IN      UINT TcharCount
        );

    PCTSTR
    PoolMemCreateDword (
        IN      POOLHANDLE Handle
        );

    PBYTE
    PoolMemDuplicateMemory (
        IN      POOLHANDLE Handle,
        IN      PBYTE Data,
        IN      UINT DataSize
        );

    PDWORD
    PoolMemDuplciateDword (
        IN      POOLHANDLE Handle,
        IN      DWORD Data
        );

    PTSTR
    PoolMemDuplicateString (
        IN      POOLHANDLE Handle,
        IN      PCTSTR String
        );

    PTSTR
    PoolMemDuplicateMultiSz (
        IN      POOLHANDLE Handle,
        IN      PCTSTR MultiSz
        );


--*/


//
// Default size of memory pool blocks. This can be changed on a per-pool basis
// by calling PoolMemSetMinimumGrowthSize().
//

#define POOLMEMORYBLOCKSIZE 8192

//
// if DEBUG is defined, poolmem keeps a tally of common statistics on all
// pools. These include number of alloc and free requests, number of
// actual allocations and frees, and various size measures.
//
// PoolMem also checks each PoolMemReleaseMemory() call to ensure that the
// address passed is a valid poolmem address that has not yet been freed.
//

#ifdef DEBUG

#define POOLMEMTRACKDEF  LPCSTR File, DWORD Line,
#define POOLMEMTRACKCALL g_TrackFile,g_TrackLine,

#else

#define POOLMEMTRACKDEF
#define POOLMEMTRACKCALL

#endif


POOLHANDLE
PoolMemInitPool (
    VOID
    );

#ifdef DEBUG

POOLHANDLE
PoolMemInitNamedPool (
    IN      PCSTR Name
    );

#else

#define PoolMemInitNamedPool(x) PoolMemInitPool()

#endif

VOID
PoolMemDestroyPool (
    IN POOLHANDLE Handle
    );


//
// Callers should use PoolMemGetMemory or PoolMemGetAlignedMemory. These each decay into
// PoolMemRealGetMemory.
//
#define PoolMemGetMemory(h,s)           SETTRACKCOMMENT(PVOID,"PoolMemGetMemory",__FILE__,__LINE__)\
                                        PoolMemRealGetMemory((h),(s),0 /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define PoolMemGetAlignedMemory(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemGetAlignedMemory",__FILE__,__LINE__)\
                                        PoolMemRealGetMemory((h),(s),sizeof(UINT_PTR) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

PVOID PoolMemRealGetMemory(IN POOLHANDLE Handle, IN SIZE_T Size, IN SIZE_T AlignSize /*,*/ ALLOCATION_TRACKING_DEF);

VOID PoolMemReleaseMemory (IN POOLHANDLE Handle, IN PVOID Memory);
VOID PoolMemSetMinimumGrowthSize(IN POOLHANDLE Handle, IN SIZE_T Size);


VOID
PoolMemEmptyPool (
    IN      POOLHANDLE Handle
    );


//
// PoolMem created strings are always aligned on DWORD boundaries.
//
#define PoolMemCreateString(h,x) ((LPTSTR) PoolMemGetAlignedMemory((h),(x)*sizeof(TCHAR)))
#define PoolMemCreateDword(h)    ((PDWORD) PoolMemGetMemory((h),sizeof(DWORD)))


__inline
PBYTE
PoolMemDuplicateMemory (
    IN POOLHANDLE Handle,
    IN PBYTE DataToCopy,
    IN SIZE_T SizeOfData
    )
{
    PBYTE Data;
    PVOID p;

    p = PoolMemGetAlignedMemory ((PVOID) Handle, SizeOfData);

    Data = (PBYTE) p;
    if (Data) {
        CopyMemory (Data, DataToCopy, SizeOfData);
    }

    return Data;
}


__inline
PDWORD PoolMemDuplicateDword (
    IN POOLHANDLE Handle,
    IN DWORD ValueToCopy
    )
{
    PDWORD rWord;

    rWord = (PDWORD) PoolMemGetMemory (Handle, sizeof (ValueToCopy));
    if (rWord) {
        *rWord = ValueToCopy;
    }

    return rWord;
}


__inline
PSTR
RealPoolMemDuplicateStringA (
    IN POOLHANDLE    Handle,
    IN PCSTR         StringToCopy /*,*/
       ALLOCATION_TRACKING_DEF
    )

{
    PSTR rString = (PSTR) PoolMemRealGetMemory(Handle,SizeOfStringA(StringToCopy),sizeof(WCHAR) /*,*/ ALLOCATION_INLINE_CALL);

    if (rString) {

        StringCopyA(rString, StringToCopy);
    }

    return rString;
}


__inline
PWSTR
RealPoolMemDuplicateStringW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        StringToCopy /*,*/
       ALLOCATION_TRACKING_DEF
    )

{
    PWSTR rString = (PWSTR) PoolMemRealGetMemory(Handle,SizeOfStringW(StringToCopy),sizeof(WCHAR) /*,*/ ALLOCATION_INLINE_CALL);

    if (rString) {

        StringCopyW(rString,StringToCopy);
    }

    return rString;
}


#define PoolMemDuplicateStringA(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringA",__FILE__,__LINE__)\
                                        RealPoolMemDuplicateStringA((h),(s) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

#define PoolMemDuplicateStringW(h,s)    SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringW",__FILE__,__LINE__)\
                                        RealPoolMemDuplicateStringW((h),(s) /*,*/ ALLOCATION_TRACKING_CALL)\
                                        CLRTRACKCOMMENT

__inline
PSTR
RealPoolMemDuplicateStringABA (
    IN      POOLHANDLE Handle,
    IN      PCSTR StringStart,
    IN      PCSTR End /*,*/
            ALLOCATION_TRACKING_DEF
    )

{
    PSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = (PSTR) PoolMemRealGetMemory (
                        Handle,
                        (PBYTE) End - (PBYTE) StringStart + sizeof (CHAR),
                        sizeof(WCHAR) /*,*/
                        ALLOCATION_INLINE_CALL
                        );

    if (rString) {

        StringCopyABA(rString,StringStart,End);
    }

    return rString;
}


__inline
PWSTR
RealPoolMemDuplicateStringABW (
    IN      POOLHANDLE Handle,
    IN      PCWSTR StringStart,
    IN      PCWSTR End /*,*/
            ALLOCATION_TRACKING_DEF
    )

{
    PWSTR rString;

    MYASSERT (StringStart);
    MYASSERT (End);
    MYASSERT (StringStart <= End);

    rString = (PWSTR) PoolMemRealGetMemory (
                            Handle,
                            (PBYTE) End - (PBYTE) StringStart + sizeof (WCHAR),
                            sizeof(WCHAR) /*,*/
                            ALLOCATION_INLINE_CALL
                            );

    if (rString) {

        StringCopyABW(rString,StringStart,End);
    }

    return rString;
}

#define PoolMemDuplicateStringABA(h,s,e) SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringABA",__FILE__,__LINE__)\
                                         RealPoolMemDuplicateStringABA((h),(s),(e) /*,*/ ALLOCATION_TRACKING_CALL)\
                                         CLRTRACKCOMMENT

#define PoolMemDuplicateStringABW(h,s,e) SETTRACKCOMMENT(PVOID,"PoolMemDuplicateStringABW",__FILE__,__LINE__)\
                                         RealPoolMemDuplicateStringABW((h),(s),(e) /*,*/ ALLOCATION_TRACKING_CALL)\
                                         CLRTRACKCOMMENT



PSTR
PoolMemDuplicateMultiSzA (
    IN POOLHANDLE    Handle,
    IN PCSTR         MultiSzToCopy
    );

PWSTR
PoolMemDuplicateMultiSzW (
    IN POOLHANDLE    Handle,
    IN PCWSTR        MultiSzToCopy
    );

#ifdef UNICODE
#define PoolMemDuplicateString  PoolMemDuplicateStringW
#define PoolMemDuplicateMultiSz PoolMemDuplicateMultiSzW
#else
#define PoolMemDuplicateString  PoolMemDuplicateStringA
#define PoolMemDuplicateMultiSz PoolMemDuplicateMultiSzA
#endif

#ifdef DEBUG

VOID
PoolMemDisableTracking (
    IN POOLHANDLE Handle
    );

#else

#define PoolMemDisableTracking(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\progbar.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    progbar.h

Abstract:

    Declares the functions, variables and macros for the progress
    bar utilities.  The progress bar utilities manage a single
    progress bar by dividing it into slices.  Each slice has
    an initial static size.  The count for each slice is scaled
    independently, so code can dynamically change the slice
    count as an aid to help tick the progress bar more smoothly.

Author:

    Marc R. Whitten (marcw)     14-Apr-1997

Revision History:

    jimschm 01-Jul-1998     Rewrite

--*/

#pragma once

//
// Variables for macros
//
extern HWND    g_Component;
extern HWND    g_SubComponent;
extern HANDLE  g_ComponentCancelEvent;
extern HANDLE  g_SubComponentCancelEvent;

//
// Initialization and termination
//

VOID
InitializeProgressBar (
    IN      HWND ProgressBar,
    IN      HWND Component,             OPTIONAL
    IN      HWND SubComponent,          OPTIONAL
    IN      BOOL *CancelFlagPtr         OPTIONAL
    );


VOID
TerminateProgressBar (
    VOID
    );

//
// Registration, estimate revision and ticking
//

UINT
RegisterProgressBarSlice (
    IN      UINT InitialEstimate
    );

VOID
ReviseSliceEstimate (
    IN      UINT SliceId,
    IN      UINT RevisedEstimate
    );

VOID
BeginSliceProcessing (
    IN      UINT SliceId
    );

BOOL
TickProgressBarDelta (
    IN      UINT Ticks
    );

BOOL
TickProgressBar (
    VOID
    );

VOID
EndSliceProcessing (
    VOID
    );


//
// Delayed titles
//

BOOL
ProgressBar_SetWindowStringA (
    IN HWND     Window,
    IN HANDLE   CancelEvent,
    IN LPCSTR   Message,            OPTIONAL
    IN DWORD    MessageId           OPTIONAL
    );

BOOL
ProgressBar_SetDelayedMessageA (
    IN HWND             Window,
    IN HANDLE           CancelEvent,
    IN LPCSTR           Message,
    IN DWORD            MessageId,
    IN DWORD            Delay
    );

VOID
ProgressBar_CancelDelayedMessage (
    IN HANDLE           CancelEvent
    );

#if 0

BOOL
ProgressBar_CreateTickThread (
    IN      HANDLE CancelEvent,
    IN      DWORD TickCount
    );

BOOL
ProgressBar_CancelTickThread (
    IN HANDLE CancelEvent
    );

#endif

//
// Macros
//

#define ProgressBar_CancelDelayedComponent() ProgressBar_CancelDelayedMessage(g_ComponentCancelEvent);
#define ProgressBar_CancelDelayedSubComponent() ProgressBar_CancelDelayedMessage(g_SubComponentCancelEvent);

#ifndef UNICODE

#define ProgressBar_SetComponent(s)                  ProgressBar_SetWindowStringA(g_Component,g_ComponentCancelEvent,(s),0)

#if !defined PRERELEASE || !defined DEBUG

#define ProgressBar_SetSubComponent(s)               ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define ProgressBar_SetFnName(s)
#define ProgressBar_ClearFnName()

#else

#define ProgressBar_SetSubComponent(s)               ((s) == NULL ? 1 : ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0))
#define ProgressBar_SetFnName(s)                     ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,(s),0)
#define ProgressBar_ClearFnName()                    ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,0)

#endif

#define ProgressBar_SetComponentById(n)              ProgressBar_SetWindowStringA(g_Component,g_ComponentCancelEvent,NULL,(n))
#define ProgressBar_SetSubComponentById(n)           ProgressBar_SetWindowStringA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n))
#define ProgressBar_SetDelayedComponent(s,d)         ProgressBar_SetDelayedMessageA(g_Component,g_ComponentCancelEvent,(s),0,(d))
#define ProgressBar_SetDelayedSubComponent(s,d)      ProgressBar_SetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,(s),0,(d))
#define ProgressBar_SetDelayedComponentById(n,d)     ProgressBar_SetDelayedMessageA(g_Component,g_ComponentCancelEvent,NULL,(n),(d))
#define ProgressBar_SetDelayedSubComponentById(n,d)  ProgressBar_SetDelayedMessageA(g_SubComponent,g_SubComponentCancelEvent,NULL,(n),(d))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\persist.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    persist.h

Abstract:

    General structure persistence functions, structure and definitions.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

--*/

#ifndef _PERSIST_H_
#define _PERSIST_H_

#define BYVALUE TRUE
#define BYREF   FALSE

#define END_OF_STRUCT   ((PBYTE) -1)

typedef enum tagPersistResultsEnum{
    Persist_Success = 0,
    Persist_BadParameters,
    Persist_Fail,
    Persist_WrongSignature,
    Persist_WrongVersion
} PERSISTRESULTSENUM;

typedef struct {
    DWORD dwSignature;
    DWORD dwVersion;
    DWORD dwReserved;
} PERSIST_HEADER, * PPERSIST_HEADER;

typedef enum tagStringType{
    NoStr,
    AnsiStr,
    UnicodeStr
}StringType;

typedef struct tagFIELD_DESCRIPTION{
    BYTE * Offset;
    StringType  IsString;
    SIZE_T Size;
    BOOL   byValue;
    UINT * ArraySizeFieldOffset;
    struct tagFIELD_DESCRIPTION * FieldDescription;
    //
    //For structures with variable size
    //struct VariableSizeStruct{
    //    ......
    //    UINT    uiNumberOfItem;
    //    ITEM    items[1];
    //};
    //Where InitialNumberOfItemInArrayForVariableStructMember is
    //number of element in items array initialy
    //
    UINT   InitialNumberOfItem;
}FIELD_DESCRIPTION, *PFIELD_DESCRIPTION;


typedef struct tagSTRUCT_DEFINITION{
    DWORD   dwVersion;
    DWORD   dwReserved;
    PFIELD_DESCRIPTION  FieldDescriptions;
}STRUCT_DEFINITION, *PSTRUCT_DEFINITION;


#define GET_STRUCT_MEMBER_OFFSET(structname, fieldname) ((PBYTE) &((structname *)NULL)->fieldname)
#define GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(type, structptr, offset) ((type)((PBYTE)(structptr) + (UINT_PTR) (offset)))
#define GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(type, structptr, offset) ((type) *((UINT_PTR *)((PBYTE)(structptr) + (UINT_PTR) (offset))))
#define GET_TYPE_DEFINITION_FROM_NAME(name, version)     g_DefinitionOf_##name##_##version
#define GET_TYPE_DESCRIPTION_FROM_NAME(name, version)    g_DescriptionOf_##name##_##version

#define PERSIST_BEGIN_DECLARE_STRUCT(name, version) FIELD_DESCRIPTION GET_TYPE_DESCRIPTION_FROM_NAME(name, version)[] = {
#define PERSIST_END_DECLARE_STRUCT(name, version)   {END_OF_STRUCT, NoStr, 0, 0, 0, 0}};\
                                                    STRUCT_DEFINITION GET_TYPE_DEFINITION_FROM_NAME(name, version) = {version, 0, GET_TYPE_DESCRIPTION_FROM_NAME(name, version)};
#define PERSISTENCE_IMPLEMENTATION(name) name;

#define PERSIST_FIELD(structname, type, version, fieldname, isString, byValue, arraySizeVar) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        (isString), \
        sizeof(type), \
        (byValue), \
        GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }

#define PERSIST_FIELD_BY_VALUE(structname, type, fieldname) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        TRUE, \
        NULL, \
        NULL, \
        0, \
    }

#define PERSIST_FIELD_STRINGW(structname, fieldname) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        UnicodeStr, \
        0, \
        BYREF, \
        NULL, \
        NULL, \
        0, \
    }

#define PERSIST_STRUCT_BY_VALUE_VARIABLE_LENGTH(structname, type, fieldname, arraySizeVar, InitialNumberOfItem) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        TRUE, \
        (UINT *)GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        NULL, \
        InitialNumberOfItem, \
    }

#define PERSIST_FIELD_NESTED_TYPE(structname, type, version, fieldname, byValue) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        (byValue), \
        NULL, \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }

#define PERSIST_FIELD_NESTED_TYPE_CYCLE(structname, type, version, fieldname, byValue, arraySizeVar) \
    {\
        GET_STRUCT_MEMBER_OFFSET(structname, fieldname), \
        NoStr, \
        sizeof(type), \
        (byValue), \
        (UINT *)GET_STRUCT_MEMBER_OFFSET(structname, arraySizeVar), \
        GET_TYPE_DESCRIPTION_FROM_NAME(type, version), \
        0, \
    }


PERSISTRESULTSENUM
PersistStore(
    IN      BYTE ** pBuffer,
    IN      SIZE_T *Size,
    IN      BYTE * pStructure,
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    );

PERSISTRESULTSENUM
PersistLoad(
    IN      BYTE * pBuffer,
    IN      SIZE_T Size,
    IN      BYTE * pStructure,
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    );

VOID
PersistReleaseMemory(
    IN      BYTE * pStructure,
    IN      PFIELD_DESCRIPTION pFieldsDescription
    );

BOOL
CompareStructures(
    IN      BYTE * pStructure1,
    IN      BYTE * pStructure2,
    IN      PFIELD_DESCRIPTION pFieldsDescription
    );

#define PERSIST_STORE(pBufferPtr, SizePtr, structname, version, pStructurePtr) PersistStore(pBufferPtr, SizePtr, (BYTE*)pStructurePtr, &(GET_TYPE_DEFINITION_FROM_NAME(structname, version)))
#define PERSIST_LOAD(pBufferPtr, Size, structname, version, pStructurePtr)     PersistLoad(pBufferPtr, Size, (BYTE*)pStructurePtr, &(GET_TYPE_DEFINITION_FROM_NAME(structname, version)))

#define PERSIST_RELEASE_STRUCT_MEMORY(structname, version, pStructurePtr)   PersistReleaseMemory((BYTE*)pStructurePtr, GET_TYPE_DEFINITION_FROM_NAME(structname, version).FieldDescriptions)
#define PERSIST_RELEASE_BUFFER(pBuffer) FreeMem(pBuffer)

#define PERSIST_COMPARE_STRUCTURES(structname, version, pStructurePtr1, pStructurePtr2) CompareStructures((BYTE*)pStructurePtr1, (BYTE*)pStructurePtr2, GET_TYPE_DEFINITION_FROM_NAME(structname, version).FieldDescriptions)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\reg.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg.h

Abstract:

    Implements macros to simplify the registry APIs and to track
    the resource allocations.

Author:

    Jim Schmidt (jimschm) 24-Mar-1997

Revision History:

    jimschm 09-Apr-1997     Expanded Get functionality

--*/

#pragma once

#define HKEY_ROOT   ((HKEY) 0X7FFFFFFF)

BOOL
RegInitialize (
    VOID
    );

VOID
RegTerminate (
    VOID
    );


VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    );

VOID
RegTerminateCache (
    VOID
    );

//
// APIs to set access mode
//

REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    );

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    );

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    );

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Our* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys()

#define TrackedRegOpenKey             RegOpenKey
#define TrackedRegCreateKey           RegCreateKey
#define TrackedRegOpenKeyEx           RegOpenKeyEx
#define TrackedRegCreateKeyEx         RegCreateKeyEx

#define TrackedRegOpenKeyA            RegOpenKeyA
#define TrackedRegCreateKeyA          RegCreateKeyA
#define TrackedRegOpenKeyExA          RegOpenKeyExA
#define TrackedRegCreateKeyExA        RegCreateKeyExA

#define TrackedRegOpenKeyW            RegOpenKeyW
#define TrackedRegCreateKeyW          RegCreateKeyW
#define TrackedRegOpenKeyExW          RegOpenKeyExW
#define TrackedRegCreateKeyExW        RegCreateKeyExW

#define OurRegOpenKeyExA            RegOpenKeyExA
#define OurRegCreateKeyExA          RegCreateKeyExA

#define OurRegOpenRootKeyA(a,b)
#define OurRegOpenRootKeyW(a,b)

#define OurRegOpenKeyExW            RegOpenKeyExW
#define OurRegCreateKeyExW          RegCreateKeyExW

#define CloseRegKey                 RealCloseRegKey

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys (
    VOID
    );

LONG
OurRegOpenKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegOpenKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExA (
    HKEY Key,
    PCSTR SubKey,
    DWORD Reserved,
    PSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );

LONG
OurRegCreateKeyExW (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Reserved,
    PWSTR Class,
    DWORD Options,
    REGSAM SamMask,
    PSECURITY_ATTRIBUTES SecurityAttribs,
    PHKEY ResultPtr,
    PDWORD DispositionPtr,
    PCSTR File,
    DWORD Line
    );


VOID
OurRegOpenRootKeyA (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
OurRegOpenRootKeyW (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define OurRegOpenRootKey OurRegOpenRootKeyW
#else
#define OurRegOpenRootKey OurRegOpenRootKeyA
#endif


LONG
OurCloseRegKey (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey(k) OurCloseRegKey(k,__FILE__,__LINE__)


#define TrackedRegOpenKeyEx(key,subkey,u,sam,res) OurRegOpenKeyEx(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyEx(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKey(k,sk,rp) OurRegOpenKeyEx(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKey(k,sk,rp) OurRegCreateKeyEx(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExA(key,subkey,u,sam,res) OurRegOpenKeyExA(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExA(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyA(k,sk,rp) OurRegOpenKeyExA(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyA(k,sk,rp) OurRegCreateKeyExA(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

#define TrackedRegOpenKeyExW(key,subkey,u,sam,res) OurRegOpenKeyExW(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp) OurRegCreateKeyExW(key,subkey,r,cls,options,sam,security,res,disp,__FILE__,__LINE__)
#define TrackedRegOpenKeyW(k,sk,rp) OurRegOpenKeyExW(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)
#define TrackedRegCreateKeyW(K,sk,rp) OurRegCreateKeyExW(k,sk,0,TEXT(""),0,KEY_ALL_ACCESS,NULL,rp,&g_DontCare,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef RegOpenKey
#undef RegCreateKey
#undef RegOpenKeyEx
#undef RegCreateKeyEx

#define RegCloseKey USE_CloseRegKey
#define RegOpenKeyA USE_TrackedRegOpenKeyA
#define RegCreateKeyA USE_TrackedRegCreateKeyA
#define RegOpenKeyExA USE_TrackedRegOpenKeyExA
#define RegCreateKeyExA USE_TrackedRegCreateKeyExA
#define RegOpenKeyW USE_TrackedRegOpenKeyw
#define RegCreateKeyW USE_TrackedRegCreateKeyW
#define RegOpenKeyExW USE_TrackedRegOpenKeyExW
#define RegCreateKeyExW USE_TrackedRegCreateKeyExW

#endif


#ifdef UNICODE
#define OurRegOpenKeyEx         OurRegOpenKeyExW
#define OurRegCreateKeyEx       OurRegCreateKeyExW
#else
#define OurRegOpenKeyEx         OurRegOpenKeyExA
#define OurRegCreateKeyEx       OurRegCreateKeyExA
#endif

//
// Reg API simplification routines
//

typedef struct {
    HKEY KeyHandle;
    BOOL OpenedByEnum;
    DWORD Index;
    CHAR SubKeyName[MAX_REGISTRY_KEYA];
} REGKEY_ENUMA, *PREGKEY_ENUMA;

typedef struct {
    HKEY KeyHandle;
    BOOL OpenedByEnum;
    DWORD Index;
    WCHAR SubKeyName[MAX_REGISTRY_KEYW];
} REGKEY_ENUMW, *PREGKEY_ENUMW;

typedef struct {
    HKEY KeyHandle;
    DWORD Index;
    CHAR ValueName[MAX_REGISTRY_VALUE_NAMEA];
    DWORD Type;
    DWORD DataSize;
} REGVALUE_ENUMA, *PREGVALUE_ENUMA;

typedef struct {
    HKEY KeyHandle;
    DWORD Index;
    WCHAR ValueName[MAX_REGISTRY_VALUE_NAMEW];
    DWORD Type;
    DWORD DataSize;
} REGVALUE_ENUMW, *PREGVALUE_ENUMW;

typedef struct _tagREGKEYINFOA {
    CHAR KeyName[MAX_REGISTRY_KEYA];
    HKEY KeyHandle;
    REGKEY_ENUMA KeyEnum;
    UINT BaseKeyBytes;
    struct _tagREGKEYINFOA *Parent, *Child;
} REGKEYINFOA, *PREGKEYINFOA;

typedef struct _tagREGKEYINFOW {
    WCHAR KeyName[MAX_REGISTRY_KEYW];
    HKEY KeyHandle;
    REGKEY_ENUMW KeyEnum;
    UINT BaseKeyBytes;
    struct _tagREGKEYINFOW *Parent, *Child;
} REGKEYINFOW, *PREGKEYINFOW;

typedef enum {
    ENUMERATE_SUBKEY_BEGIN,
    ENUMERATE_SUBKEY_RETURN,
    ENUMERATE_SUBKEY_NEXT,
    ENUMERATE_SUBKEY_DONE,
    NO_MORE_ITEMS
} REGTREESTATE;

typedef struct {
    CHAR FullKeyName[MAX_REGISTRY_KEYA];
    UINT FullKeyNameBytes;
    UINT EnumBaseBytes;
    PREGKEYINFOA CurrentKey;
    POOLHANDLE EnumPool;
    REGTREESTATE State;
    BOOL FirstEnumerated;
} REGTREE_ENUMA, *PREGTREE_ENUMA;

typedef struct {
    WCHAR FullKeyName[MAX_REGISTRY_KEYW];
    UINT FullKeyNameBytes;
    UINT EnumBaseBytes;
    PREGKEYINFOW CurrentKey;
    POOLHANDLE EnumPool;
    REGTREESTATE State;
    BOOL FirstEnumerated;
} REGTREE_ENUMW, *PREGTREE_ENUMW;


//
// Enum functions
//

BOOL
EnumFirstRegKeyA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegKeyW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
RealEnumFirstRegKeyStrA (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

BOOL
RealEnumFirstRegKeyStrW (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

#ifdef DEBUG

#define EnumFirstRegKeyStrA(a,b) RealEnumFirstRegKeyStrA(a,b,__FILE__,__LINE__)
#define EnumFirstRegKeyStrW(a,b) RealEnumFirstRegKeyStrW(a,b,__FILE__,__LINE__)

#else

#define EnumFirstRegKeyStrA RealEnumFirstRegKeyStrA
#define EnumFirstRegKeyStrW RealEnumFirstRegKeyStrW

#endif



BOOL
EnumNextRegKeyA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

BOOL
EnumNextRegKeyW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

VOID
AbortRegKeyEnumA (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

VOID
AbortRegKeyEnumW (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

BOOL
RealEnumFirstRegKeyInTreeA (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTreeA(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTreeA",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTreeA(e,base)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumFirstRegKeyInTreeW (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTreeW(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTreeW",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTreeW(e,base)\
                                        CLRTRACKCOMMENT


BOOL
RealEnumNextRegKeyInTreeA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

#define EnumNextRegKeyInTreeA(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTreeA",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTreeA(e)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumNextRegKeyInTreeW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );

#define EnumNextRegKeyInTreeW(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTreeW",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTreeW(e)\
                                        CLRTRACKCOMMENT

VOID
AbortRegKeyTreeEnumA (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

VOID
AbortRegKeyTreeEnumW (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );


BOOL
EnumFirstRegValueA (
    OUT     PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegValueW (
    OUT     PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumNextRegValueA (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    );

BOOL
EnumNextRegValueW (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    );

PCSTR
CreateEncodedRegistryStringExA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree
    );

PCWSTR
CreateEncodedRegistryStringExW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree
    );

#define CreateEncodedRegistryStringA(k,v) CreateEncodedRegistryStringExA(k,v,TRUE)
#define CreateEncodedRegistryStringW(k,v) CreateEncodedRegistryStringExW(k,v,TRUE)

VOID
FreeEncodedRegistryStringA (
    IN OUT PCSTR RegString
    );

VOID
FreeEncodedRegistryStringW (
    IN OUT PCWSTR RegString
    );


BOOL
DecodeRegistryStringA (
    IN      PCSTR RegString,
    OUT     PSTR KeyBuf,            OPTIONAL
    OUT     PSTR ValueBuf,          OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );

BOOL
DecodeRegistryStringW (
    IN      PCWSTR RegString,
    OUT     PWSTR KeyBuf,           OPTIONAL
    OUT     PWSTR ValueBuf,         OPTIONAL
    OUT     PBOOL TreeFlag          OPTIONAL
    );


//
// Versions that allow caller to specify allocator, and macro that uses
// MemAllocWrapper
//

typedef PVOID (ALLOCATOR_PROTOTYPE)(DWORD Size);
typedef ALLOCATOR_PROTOTYPE * ALLOCATOR;

ALLOCATOR_PROTOTYPE MemAllocWrapper;

typedef VOID (DEALLOCATOR_PROTOTYPE)(PCVOID Mem);
typedef DEALLOCATOR_PROTOTYPE * DEALLOCATOR;

DEALLOCATOR_PROTOTYPE MemFreeWrapper;

BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD Size             OPTIONAL
    );

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataA(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueDataA",__FILE__, __LINE__)\
                                        GetRegValueData2A((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        CLRTRACKCOMMENT


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataW(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueDataW",__FILE__, __LINE__)\
                                        GetRegValueData2W((key),(valuename),MemAllocWrapper,MemFreeWrapper)\
                                        CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeA(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfTypeA",__FILE__,__LINE__)\
                                                    GetRegValueDataOfType2A((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfTypeW(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfTypeW",__FILE__,__LINE__)\
                                                    GetRegValueDataOfType2W((key),(valuename),(type),MemAllocWrapper,MemFreeWrapper)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyData2A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataA(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyDataA",__FILE__,__LINE__)\
                                    GetRegKeyData2A((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyData2W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyDataW(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyDataW",__FILE__,__LINE__)\
                                    GetRegKeyData2W((key),(subkey),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataA(keystr,value) SETTRACKCOMMENT(PBYTE, "GetRegDataA",__FILE__,__LINE__)\
                                  GetRegData2A((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                  CLRTRACKCOMMENT

PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegDataW(keystr,value)   SETTRACKCOMMENT(PBYTE, "GetRegDataW",__FILE__,__LINE__)\
                                    GetRegData2W((keystr),(value),MemAllocWrapper,MemFreeWrapper)\
                                    CLRTRACKCOMMENT

BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    );


//
// Reg key create & open
//

HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrA (
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealCreateRegKeyStrW (
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey (
    IN      HKEY Key
    );

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    );

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    );

#ifdef DEBUG

#define CreateRegKeyA(a,b) RealCreateRegKeyA(a,b,__FILE__,__LINE__)
#define CreateRegKeyW(a,b) RealCreateRegKeyW(a,b,__FILE__,__LINE__)
#define CreateRegKeyStrA(a) RealCreateRegKeyStrA(a,__FILE__,__LINE__)
#define CreateRegKeyStrW(a) RealCreateRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyStrA(a) RealOpenRegKeyStrA(a,__FILE__,__LINE__)
#define OpenRegKeyStrW(a) RealOpenRegKeyStrW(a,__FILE__,__LINE__)
#define OpenRegKeyA(a,b) RealOpenRegKeyA(a,b,__FILE__,__LINE__)
#define OpenRegKeyW(a,b) RealOpenRegKeyW(a,b,__FILE__,__LINE__)

#else

#define CreateRegKeyA RealCreateRegKeyA
#define CreateRegKeyW RealCreateRegKeyW
#define CreateRegKeyStrA RealCreateRegKeyStrA
#define CreateRegKeyStrW RealCreateRegKeyStrW
#define OpenRegKeyStrA RealOpenRegKeyStrA
#define OpenRegKeyStrW RealOpenRegKeyStrW
#define OpenRegKeyA RealOpenRegKeyA
#define OpenRegKeyW RealOpenRegKeyW

#endif


//
// Registry root functions
//

VOID
SetRegRoot (
    IN      HKEY Root
    );

HKEY
GetRegRoot (
    VOID
    );


// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootStringA (PCSTR RootString, PDWORD LengthPtr OPTIONAL);
INT GetOffsetOfRootStringW (PCWSTR RootString, PDWORD LengthPtr OPTIONAL);

// Returns non-zero array offset to root, or zero if no root matches
INT GetOffsetOfRootKey (HKEY RootKey);

// Given non-zero array offset to root, returns string or NULL if element
// is out of bounds
PCSTR GetRootStringFromOffsetA (INT i);
PCWSTR GetRootStringFromOffsetW (INT i);

// Given non-zero array offset to root, returns registry handle or NULL if
// element is out of bounds
HKEY GetRootKeyFromOffset (INT i);

// Converts the root at the head of RegPath to an HKEY and gives the number
// of characters occupied by the root string (including optional wack)
HKEY ConvertRootStringToKeyA (PCSTR RegPath, PDWORD LengthPtr OPTIONAL);
HKEY ConvertRootStringToKeyW (PCWSTR RegPath, PDWORD LengthPtr OPTIONAL);

// Returns a pointer to a static string for the matching root, or NULL if
// RegRoot does not point to a valid root
PCSTR ConvertKeyToRootStringA (HKEY RegRoot);
PCWSTR ConvertKeyToRootStringW (HKEY RegRoot);



//
// Macros
//

#define GetRegValueStringA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_SZ)
#define GetRegValueBinaryA(key,valuename) (PBYTE) GetRegValueDataOfTypeA((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzA(key,valuename) (PSTR) GetRegValueDataOfTypeA((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordA(key,valuename) (PDWORD) GetRegValueDataOfTypeA((key),(valuename),REG_DWORD)

#define GetRegValueStringW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_SZ)
#define GetRegValueBinaryW(key,valuename) (PBYTE) GetRegValueDataOfTypeW((key),(valuename),REG_BINARY)
#define GetRegValueMultiSzW(key,valuename) (PWSTR) GetRegValueDataOfTypeW((key),(valuename),REG_MULTISZ)
#define GetRegValueDwordW(key,valuename) (PDWORD) GetRegValueDataOfTypeW((key),(valuename),REG_DWORD)

#define GetRegValueString2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2A(key,valuename,alloc,free) GetRegValueDataOfType2A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueString2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinary2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSz2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDword2W(key,valuename,alloc,free) GetRegValueDataOfType2W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define REGKEY_ENUM                     REGKEY_ENUMW
#define PREGKEY_ENUM                    PREGKEY_ENUMW
#define REGVALUE_ENUM                   REGVALUE_ENUMW
#define PREGVALUE_ENUM                  PREGVALUE_ENUMW
#define REGTREE_ENUM                    REGTREE_ENUMW
#define PREGTREE_ENUM                   PREGTREE_ENUMW

#define EnumFirstRegKey                 EnumFirstRegKeyW
#define EnumFirstRegKeyStr              EnumFirstRegKeyStrW
#define EnumNextRegKey                  EnumNextRegKeyW
#define AbortRegKeyEnum                 AbortRegKeyEnumW
#define EnumFirstRegKeyInTree           EnumFirstRegKeyInTreeW
#define EnumNextRegKeyInTree            EnumNextRegKeyInTreeW
#define AbortRegKeyTreeEnum             AbortRegKeyTreeEnumW
#define EnumFirstRegValue               EnumFirstRegValueW
#define EnumNextRegValue                EnumNextRegValueW

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeW
#define GetRegValueData                 GetRegValueDataW
#define GetRegValueDataOfType           GetRegValueDataOfTypeW
#define GetRegKeyData                   GetRegKeyDataW
#define GetRegValueData2                GetRegValueData2W
#define GetRegValueDataOfType2          GetRegValueDataOfType2W
#define GetRegKeyData2                  GetRegKeyData2W
#define GetRegValueString               GetRegValueStringW
#define GetRegValueBinary               GetRegValueBinaryW
#define GetRegValueMultiSz              GetRegValueMultiSzW
#define GetRegValueDword                GetRegValueDwordW
#define GetRegValueString2              GetRegValueString2W
#define GetRegValueBinary2              GetRegValueBinary2W
#define GetRegValueMultiSz2             GetRegValueMultiSz2W
#define GetRegValueDword2               GetRegValueDword2W
#define GetRegData2                     GetRegData2W
#define GetRegData                      GetRegDataW

#define CreateRegKey                    CreateRegKeyW
#define CreateRegKeyStr                 CreateRegKeyStrW
#define OpenRegKey                      OpenRegKeyW
#define OpenRegKeyStr                   OpenRegKeyStrW
#define DeleteRegKeyStr                 DeleteRegKeyStrW
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrW
#define GetOffsetOfRootString           GetOffsetOfRootStringW
#define GetRootStringFromOffset         GetRootStringFromOffsetW
#define ConvertRootStringToKey          ConvertRootStringToKeyW
#define ConvertKeyToRootString          ConvertKeyToRootStringW
#define CreateEncodedRegistryString     CreateEncodedRegistryStringW
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExW
#define FreeEncodedRegistryString       FreeEncodedRegistryStringW
#define DecodeRegistryString            DecodeRegistryStringW


#else

#define REGKEY_ENUM                     REGKEY_ENUMA
#define PREGKEY_ENUM                    PREGKEY_ENUMA
#define REGVALUE_ENUM                   REGVALUE_ENUMA
#define PREGVALUE_ENUM                  PREGVALUE_ENUMA
#define REGTREE_ENUM                    REGTREE_ENUMA
#define PREGTREE_ENUM                   PREGTREE_ENUMA

#define EnumFirstRegKey                 EnumFirstRegKeyA
#define EnumFirstRegKeyStr              EnumFirstRegKeyStrA
#define EnumNextRegKey                  EnumNextRegKeyA
#define AbortRegKeyEnum                 AbortRegKeyEnumA
#define EnumFirstRegKeyInTree           EnumFirstRegKeyInTreeA
#define EnumNextRegKeyInTree            EnumNextRegKeyInTreeA
#define AbortRegKeyTreeEnum             AbortRegKeyTreeEnumA
#define EnumFirstRegValue               EnumFirstRegValueA
#define EnumNextRegValue                EnumNextRegValueA

#define GetRegValueTypeAndSize          GetRegValueTypeAndSizeA
#define GetRegValueData                 GetRegValueDataA
#define GetRegValueDataOfType           GetRegValueDataOfTypeA
#define GetRegKeyData                   GetRegKeyDataA
#define GetRegValueData2                GetRegValueData2A
#define GetRegValueDataOfType2          GetRegValueDataOfType2A
#define GetRegKeyData2                  GetRegKeyData2A
#define GetRegValueString               GetRegValueStringA
#define GetRegValueBinary               GetRegValueBinaryA
#define GetRegValueMultiSz              GetRegValueMultiSzA
#define GetRegValueDword                GetRegValueDwordA
#define GetRegValueString2              GetRegValueString2A
#define GetRegValueBinary2              GetRegValueBinary2A
#define GetRegValueMultiSz2             GetRegValueMultiSz2A
#define GetRegValueDword2               GetRegValueDword2A
#define GetRegData2                     GetRegData2A
#define GetRegData                      GetRegDataA

#define CreateRegKey                    CreateRegKeyA
#define CreateRegKeyStr                 CreateRegKeyStrA
#define OpenRegKey                      OpenRegKeyA
#define OpenRegKeyStr                   OpenRegKeyStrA
#define DeleteRegKeyStr                 DeleteRegKeyStrA
#define DeleteEmptyRegKeyStr            DeleteEmptyRegKeyStrA
#define GetOffsetOfRootString           GetOffsetOfRootStringA
#define GetRootStringFromOffset         GetRootStringFromOffsetA
#define ConvertRootStringToKey          ConvertRootStringToKeyA
#define ConvertKeyToRootString          ConvertKeyToRootStringA
#define CreateEncodedRegistryString     CreateEncodedRegistryStringA
#define CreateEncodedRegistryStringEx   CreateEncodedRegistryStringExA
#define FreeEncodedRegistryString       FreeEncodedRegistryStringA
#define DecodeRegistryString            DecodeRegistryStringA


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\regops.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    regops.h

Abstract:

    This file declares routines to mark operations on the registry.
    During the Win9x side of processing, registry operations are
    recorded in memdb to suppress Win9x settings, or to overwrite
    NT settings.  The memdb entries are queried during the registry
    merge in GUI mode.

    Use the macros at the bottom of this file.

Author:

    Marc R. Whitten (marcw)   18-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/



#pragma once

#define REGMERGE_95_SUPPRESS        0x00000001
#define REGMERGE_95_RENAME_SUPPRESS 0x00000002
#define REGMERGE_95_RENAME          0x00000004

#define REGMERGE_NT_MASK            0x0000ff00
#define REGMERGE_NT_SUPPRESS        0x00000100
#define REGMERGE_NT_IGNORE_DEFAULTS 0x00000200
#define REGMERGE_NT_PRIORITY_NT     0x00000400



typedef enum {
    KEY_ONLY,
    KEY_TREE,
    TREE_OPTIONAL
} TREE_STATE;

BOOL
IsRegObjectMarkedForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,                OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    );

BOOL
IsRegObjectMarkedForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,               OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    );

BOOL
MarkRegObjectForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    );

BOOL
MarkRegObjectForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    );

BOOL
MarkObjectForOperationA (
    IN      PCSTR Object,
    IN      DWORD OperationMask
    );

BOOL
MarkObjectForOperationW (
    IN      PCWSTR Object,
    IN      DWORD OperationMask
    );

BOOL
ForceWin9xSettingA (
    IN      PCSTR SourceKey,
    IN      PCSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCSTR DestinationKey,
    IN      PCSTR DestinationValue,
    IN      BOOL DestinationTree
    );

BOOL
ForceWin9xSettingW (
    IN      PCWSTR SourceKey,
    IN      PCWSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCWSTR DestinationKey,
    IN      PCWSTR DestinationValue,
    IN      BOOL DestinationTree
    );

#ifdef UNICODE
#define IsRegObjectMarkedForOperation       IsRegObjectMarkedForOperationW
#define MarkRegObjectForOperation           MarkRegObjectForOperationW
#define Suppress95RegSetting(k,v)           MarkRegObjectForOperationW(k,v,TRUE,REGMERGE_95_SUPPRESS)
#define SuppressNtRegSetting(k,v)           MarkRegObjectForOperationW(k,v,TRUE,REG_NT_SUPPRESS)
#define Is95RegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationW(k,v,TREE_OPTIONAL,REGMERGE_95_SUPPRESS)
#define IsNtRegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationW(k,v,TREE_OPTIONAL,REGMERGE_NT_SUPPRESS)
#define Is95RegKeySuppressed(k)             IsRegObjectMarkedForOperationW(k,NULL,KEY_ONLY,REGMERGE_95_SUPPRESS)
#define IsNtRegKeySuppressed(k)             IsRegObjectMarkedForOperationW(k,NULL,KEY_ONLY,REGMERGE_NT_SUPPRESS)
#define Is95RegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationW(k,NULL,KEY_TREE,REGMERGE_95_SUPPRESS)
#define IsNtRegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationW(k,NULL,KEY_TREE,REGMERGE_NT_SUPPRESS)
#define IsRegObjectInMemdb(k,v)             IsRegObjectMarkedForOperationW(k,v,0xffffffff)
#define MarkObjectForOperation              MarkObjectForOperationW
#define Suppress95Object(x)                 MarkObjectForOperationW(x,REGMERGE_95_SUPPRESS)
#define SuppressNtObject(x)                 MarkObjectForOperationW(x,REGMERGE_NT_SUPPRESS)
#define ForceWin9xSetting                   ForceWin9xSettingW

#else

#define IsRegObjectMarkedForOperation       IsRegObjectMarkedForOperationA
#define MarkRegObjectForOperation           MarkRegObjectForOperationA
#define Suppress95RegSetting(k,v)           MarkRegObjectForOperationA(k,v,TRUE,REGMERGE_95_SUPPRESS)
#define SuppressNtRegSetting(k,v)           MarkRegObjectForOperationA(k,v,TRUE,REGMERGE_NT_SUPPRESS)
#define Is95RegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationA(k,v,TREE_OPTIONAL,REGMERGE_95_SUPPRESS)
#define IsNtRegObjectSuppressed(k,v)        IsRegObjectMarkedForOperationA(k,v,TREE_OPTIONAL,REGMERGE_NT_SUPPRESS)
#define Is95RegKeySuppressed(k)             IsRegObjectMarkedForOperationA(k,NULL,KEY_ONLY,REGMERGE_95_SUPPRESS)
#define IsNtRegKeySuppressed(k)             IsRegObjectMarkedForOperationA(k,NULL,KEY_ONLY,REGMERGE_NT_SUPPRESS)
#define Is95RegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationA(k,NULL,KEY_TREE,REGMERGE_95_SUPPRESS)
#define IsNtRegKeyTreeSuppressed(k)         IsRegObjectMarkedForOperationA(k,NULL,KEY_TREE,REGMERGE_NT_SUPPRESS)
#define IsRegObjectInMemdb(k,v)             IsRegObjectMarkedForOperationA(k,v,0xffffffff)
#define MarkObjectForOperation              MarkObjectForOperationA
#define Suppress95Object(x)                 MarkObjectForOperationA(x,REGMERGE_95_SUPPRESS)
#define SuppressNtObject(x)                 MarkObjectForOperationA(x,REGMERGE_NT_SUPPRESS)
#define ForceWin9xSetting                   ForceWin9xSettingA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\regapix.h ===
//
//  REGAPIX.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Public definitions for the VMM registry library (all modes).
//

#ifndef _REGAPIX_
#define _REGAPIX_

/*XLATOFF*/
#ifdef __cplusplus
extern "C" {
#endif
/*XLATON*/

/*XLATOFF*/
#if defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
#define REGAPI                      WINAPI
#else
#if defined(IS_32)
#ifndef FAR
#define FAR
#endif
#define REGAPI                      __cdecl
#else
#ifndef FAR
#define FAR                         _far
#endif 
#define REGAPI                      _far _cdecl
#endif // defined(IS_32)
#endif // defined(_INC_WINDOWS) && !defined(VXD) && !defined(REALMODE)
/*XLATON*/

#ifndef _REGPRIV_
#ifndef _INC_WINDOWS
typedef DWORD HKEY;
#endif
#endif
typedef HKEY FAR* LPHKEY;

//
//  Predefined key handles.
//

#ifndef HKEY_LOCAL_MACHINE
#define HKEY_CLASSES_ROOT           ((HKEY) 0x80000000)
#define HKEY_CURRENT_USER           ((HKEY) 0x80000001)
#define HKEY_LOCAL_MACHINE          ((HKEY) 0x80000002)
#define HKEY_USERS                  ((HKEY) 0x80000003)
#define HKEY_PERFORMANCE_DATA       ((HKEY) 0x80000004)
#define HKEY_CURRENT_CONFIG         ((HKEY) 0x80000005)
#define HKEY_DYN_DATA               ((HKEY) 0x80000006)
#define HKEY_PREDEF_KEYS            7
#endif

//
//  Maximum size of registry data elements.
//

#define MAXIMUM_SUB_KEY_LENGTH      256
#define MAXIMUM_VALUE_NAME_LENGTH   256
#define MAXIMUM_DATA_LENGTH         16384

//
//  Standard data types.
//

#ifndef REG_SZ
#define REG_SZ                      1
#endif

#ifndef REG_BINARY
#define REG_BINARY                  3
#endif

#ifndef REG_DWORD
#define REG_DWORD                   4
#endif

//
//  Registry error codes.
//
#ifndef NOREGERRORDEFS
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS               0
#endif

#ifndef ERROR_INVALID_FUNCTION
#define ERROR_INVALID_FUNCTION      1
#endif

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND        2
#endif

#ifndef ERROR_ACCESS_DENIED
#define ERROR_ACCESS_DENIED         5
#endif

#ifndef ERROR_INVALID_HANDLE
#define ERROR_INVALID_HANDLE        6
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY           14
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER     87
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED           167
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA             234
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS         259
#endif

#ifndef ERROR_IO_PENDING
#define ERROR_IO_PENDING            997
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                 1009
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY                1010
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN              1011
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD              1012
#endif

#ifndef ERROR_CANTWRITE
#define ERROR_CANTWRITE             1013
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED    1016
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED           1018
#endif

//  Internal registry error codes.  Not exposed to most clients.
#if defined(VXD)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ((ERROR_CANTOPEN << 16) | ERROR_FILE_NOT_FOUND)
#define ERROR_CANTREAD16_FILENOTFOUND32 ((ERROR_CANTREAD << 16) | ERROR_FILE_NOT_FOUND)
#else
#if defined(WIN32)
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_FILE_NOT_FOUND
#else
#define ERROR_CANTOPEN16_FILENOTFOUND32 ERROR_CANTOPEN
#define ERROR_CANTREAD16_FILENOTFOUND32 ERROR_CANTREAD
#endif
#endif

#endif 

//
//  Registry application interfaces.
//

/*XLATOFF*/

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    );

VOID
REGAPI
VMMRegLibDetach(
    VOID
    );

/*XLATON*/
#define GRFT_SYSTEM                 0       //  SYSTEM.DAT
#define GRFT_USER                   1       //  USER.DAT
/*XLATOFF*/

BOOL
REGAPI
VMMRegGetRegistryFile(
    char FAR* lpBuffer,
    UINT BufferSize,
    UINT FileType
    );

//  Creates a new registry file.  Fails if the specified file already exists.
#define MPKF_CREATENEW              0x0001

//  If MPKF_VERSION20 is specified, create the file using compact keynodes.
//  Such a file will only be readable by users of this library, not Win95
//  clients.  Use only for system registries (SYSTEM.DAT, USER.DAT).
#define MPKF_VERSION20              0x0002

LONG
REGAPI
VMMRegMapPredefKeyToFile(
    HKEY hKey,
    const char FAR* lpFileName,
    UINT Flags
    );

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hSourceKey,
    HKEY hPredefKey
    );

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    LPHKEY lphSubKey
    );

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    );

LONG
REGAPI
VMMRegQueryValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    void FAR* val_list,
    DWORD num_vals,
    char FAR* lpValueBuffer,
    DWORD FAR* lpdwTotalSize
    );

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    const char FAR* lpSubKey,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    const char FAR* lpValueName,
    DWORD Reserved,
    DWORD Type,
    BYTE FAR* lpData,
    DWORD cbData
    );

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    const char FAR* lpValueName
    );

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    char FAR* lpKeyName,
    DWORD cbKeyName
    );

LONG
REGAPI
VMMRegEnumValue(
    HKEY hKey,
    DWORD Index,
    char FAR* lpValueName,
    DWORD FAR* lpcbValueName,
    DWORD FAR* lpReserved,
    DWORD FAR* lpType,
    BYTE FAR* lpData,
    DWORD FAR* lpcbData
    );

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData
    );
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    char FAR* lpClass,
    DWORD FAR* lpcbClass,
    DWORD FAR* lpReserved,
    DWORD FAR* lpcSubKeys,
    DWORD FAR* lpcbMaxSubKeyLen,
    DWORD FAR* lpcbMaxClassLen,
    DWORD FAR* lpcValues,
    DWORD FAR* lpcbMaxValueName,
    DWORD FAR* lpcbMaxValueData,
    void FAR* lpcbSecurityDescriptor,
    void FAR* lpftLastWriteTime
    );
#endif

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpFileName
    );

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    const char FAR* lpSubKey
    );

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    const char FAR* lpFileName,
    void FAR* lpSecurityAttributes
    );

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    const char FAR* lpSubKey,
    const char FAR* lpNewFileName,
    const char FAR* lpOldFileName
    );

//
//  Optional macros for callers (typically 16-bit) that map the registry APIs
//  to the equivalent Win32 API name.
//

#if defined(IS_16) || defined(WANTREGAPIMACROS)
#if !defined(NOREGAPIMACROS) && !defined(SETUPX_INC)
#define RegCreateKey                VMMRegCreateKey
#define RegOpenKey                  VMMRegOpenKey
#define RegCloseKey                 VMMRegCloseKey
#define RegFlushKey                 VMMRegFlushKey
#define RegQueryValue               VMMRegQueryValue
#define RegQueryValueEx             VMMRegQueryValueEx
#define RegQueryMultipleValues      VMMRegQueryMultipleValues
#define RegSetValue                 VMMRegSetValue
#define RegSetValueEx               VMMRegSetValueEx
#define RegDeleteKey                VMMRegDeleteKey
#define RegDeleteValue              VMMRegDeleteValue
#define RegEnumKey                  VMMRegEnumKey
#define RegEnumValue                VMMRegEnumValue
#define RegQueryInfoKey             VMMRegQueryInfoKey
#define RegLoadKey                  VMMRegLoadKey
#define RegUnLoadKey                VMMRegUnLoadKey
#define RegSaveKey                  VMMRegSaveKey
#define RegReplaceKey               VMMRegReplaceKey
#endif
#endif

/*XLATON*/


//
//  Registry services available via VMM's interrupt 2Fh handler.
//

#ifndef RegOpenKey_Idx
#define RegOpenKey_Idx              0x0100
#define RegCreateKey_Idx            0x0101
#define RegCloseKey_Idx             0x0102
#define RegDeleteKey_Idx            0x0103
#define RegSetValue_Idx             0x0104
#define RegQueryValue_Idx           0x0105
#define RegEnumKey_Idx              0x0106
#define RegDeleteValue_Idx          0x0107
#define RegEnumValue_Idx            0x0108
#define RegQueryValueEx_Idx         0x0109
#define RegSetValueEx_Idx           0x010A
#define RegFlushKey_Idx             0x010B
#define RegLoadKey_Idx              0x010C
#define RegUnLoadKey_Idx            0x010D
#define RegSaveKey_Idx              0x010E
#define RegRestore_Idx              0x010F
#define RegRemapPreDefKey_Idx       0x0110
#endif

/*XLATOFF*/
#ifdef __cplusplus
}
#endif
/*XLATON*/

#endif // _REGAPIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\safemode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    recovery.h

Abstract:

    A number of utilities for safe/recovery mode

Author:

    Calin Negreanu (calinn) 6-Aug-1999

Revision History:

--*/


#pragma once

// posible values for safe mode identifiers
typedef enum {
    SAFEMODEID_FIRST,
    SAFEMODEID_DRIVE,
    SAFEMODEID_FILES,
    SAFEMODEID_LNK9X,
    SAFEMODEID_LAST
} SAFEMODE_OPTIONS;

BOOL
SafeModeInitializeA (
    BOOL Forced
    );

BOOL
SafeModeInitializeW (
    BOOL Forced
    );

BOOL
SafeModeShutDownA (
    VOID
    );

BOOL
SafeModeShutDownW (
    VOID
    );

BOOL
SafeModeRegisterActionA (
    IN      ULONG Id,
    IN      PCSTR String
    );

BOOL
SafeModeRegisterActionW (
    IN      ULONG Id,
    IN      PCWSTR String
    );

BOOL
SafeModeUnregisterActionA (
    VOID
    );

BOOL
SafeModeUnregisterActionW (
    VOID
    );

BOOL
SafeModeActionCrashedA (
    IN      ULONG Id,
    IN      PCSTR String
    );

BOOL
SafeModeActionCrashedW (
    IN      ULONG Id,
    IN      PCWSTR String
    );

VOID
SafeModeExceptionOccured (
    VOID
    );

#ifdef UNICODE

#define SafeModeInitialize          SafeModeInitializeW
#define SafeModeShutDown            SafeModeShutDownW
#define SafeModeRegisterAction      SafeModeRegisterActionW
#define SafeModeUnregisterAction    SafeModeUnregisterActionW
#define SafeModeActionCrashed       SafeModeActionCrashedW

#else

#define SafeModeInitialize          SafeModeInitializeA
#define SafeModeShutDown            SafeModeShutDownA
#define SafeModeRegisterAction      SafeModeRegisterActionA
#define SafeModeUnregisterAction    SafeModeUnregisterActionA
#define SafeModeActionCrashed       SafeModeActionCrashedA

#endif

#define SAFEMODE_GUARD(id,str)      if(!SafeModeActionCrashed(id,str)){SafeModeRegisterAction(id,str);
#define END_SAFEMODE_GUARD          SafeModeUnregisterAction();}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\reg95.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    reg95.h

Abstract:

    Implements wrappers to the Win95Reg APIs.

Author:

    Jim Schmidt (jimschm) 04-Feb-1998

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Tracking of registry calls.  These functions are completely
// turned off for non-debug builds and are mapped to the standard
// Win32 APIs via macro definitions.
//

//
// The Track* API take the same params as the Reg* equivalents.
// The Debug* API also take the same params as the Reg* equivalents, but
// the debug versions have two extra parameters, File and Line.
//

//
// Use the Track* API set instead of the Reg* API set.
//

#ifndef DEBUG

#define DumpOpenKeys95()
#define RegTrackTerminate95()

#define TrackedRegOpenKey95             Win95RegOpenKey
#define TrackedRegOpenKeyEx95           Win95RegOpenKeyEx

#define TrackedRegOpenKey95A            Win95RegOpenKeyA
#define TrackedRegOpenKeyEx95A          Win95RegOpenKeyExA

#define TrackedRegOpenKey95W            Win95RegOpenKeyW
#define TrackedRegOpenKeyEx95W          Win95RegOpenKeyExW

#define OurRegOpenKeyEx95A              Win95RegOpenKeyExA

#define OurRegOpenRootKey95A(a,b)
#define OurRegOpenRootKey95W(a,b)

#define OurRegOpenKeyEx95W              Win95RegOpenKeyExW

#define CloseRegKey95                   RealCloseRegKey95

#define DEBUG_TRACKING_PARAMS
#define DEBUG_TRACKING_ARGS

#else

extern DWORD g_DontCare95;

#define DEBUG_TRACKING_PARAMS       ,PCSTR File,DWORD Line
#define DEBUG_TRACKING_ARGS         , File, Line

VOID
DumpOpenKeys95 (
    VOID
    );

VOID
RegTrackTerminate95 (
    VOID
    );


LONG
DebugRegOpenKeyEx95A (
    HKEY Key,
    PCSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

LONG
DebugRegOpenKeyEx95W (
    HKEY Key,
    PCWSTR SubKey,
    DWORD Unused,
    REGSAM SamMask,
    PHKEY ResultPtr,
    PCSTR File,
    DWORD Line
    );

VOID
DebugRegOpenRootKey95A (
    HKEY Key,
    PCSTR SubKey,
    PCSTR File,
    DWORD Line
    );

VOID
DebugRegOpenRootKey95W (
    HKEY Key,
    PCWSTR SubKey,
    PCSTR File,
    DWORD Line
    );

#ifdef UNICODE
#define DebugRegOpenRootKey95 DebugRegOpenRootKey95W
#else
#define DebugRegOpenRootKey95 DebugRegOpenRootKey95A
#endif


LONG
DebugCloseRegKey95 (
    HKEY Key,
    PCSTR File,
    DWORD Line
    );

#define CloseRegKey95(k) DebugCloseRegKey95(k,__FILE__,__LINE__)


#define OurRegOpenKeyEx95A              DebugRegOpenKeyEx95A
#define OurRegOpenRootKey95A            DebugRegOpenRootKey95A
#define OurRegOpenRootKey95W            DebugRegOpenRootKey95W
#define OurRegOpenKeyEx95W              DebugRegOpenKeyEx95W


#define TrackedRegOpenKeyEx95(key,subkey,u,sam,res) DebugRegOpenKeyEx95(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95(k,sk,rp) DebugRegOpenKeyEx95(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

#define TrackedRegOpenKeyEx95A(key,subkey,u,sam,res) DebugRegOpenKeyEx95A(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95A(k,sk,rp) DebugRegOpenKeyEx95A(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

#define TrackedRegOpenKeyEx95W(key,subkey,u,sam,res) DebugRegOpenKeyEx95W(key,subkey,u,sam,res,__FILE__,__LINE__)
#define TrackedRegOpenKey95W(k,sk,rp) DebugRegOpenKeyEx95W(k,sk,0,KEY_ALL_ACCESS,rp,__FILE__,__LINE__)

//
// Undefine the real registry APIs -- using them will throw off the tracking
//

#undef Win95RegOpenKey
#undef Win95RegOpenKeyEx

#define Win95RegCloseKey    USE_CloseRegKey95
#define Win95RegOpenKeyA    USE_TrackedRegOpenKey95A
#define Win95RegOpenKeyExA  USE_TrackedRegOpenKeyExA
#define Win95RegOpenKeyW    USE_TrackedRegOpenKey95W
#define Win95RegOpenKeyExW  USE_TrackedRegOpenKeyEx95W
#define Win95RegOpenKey     USE_TrackedRegOpenKey95
#define Win95RegOpenKeyEx   USE_TrackedRegOpenKeyEx95

#endif


#ifdef UNICODE
#define DebugRegOpenKeyEx95         DebugRegOpenKeyEx95W
#else
#define DebugRegOpenKeyEx95         DebugRegOpenKeyEx95A
#endif


//
// Enum functions
//

BOOL
EnumFirstRegKey95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegKey95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
RealEnumFirstRegKeyStr95A (
    OUT     PREGKEY_ENUMA EnumPtr,
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

BOOL
RealEnumFirstRegKeyStr95W (
    OUT     PREGKEY_ENUMW EnumPtr,
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

#ifdef DEBUG

#define EnumFirstRegKeyStr95A(a,b) RealEnumFirstRegKeyStr95A(a,b,__FILE__,__LINE__)
#define EnumFirstRegKeyStr95W(a,b) RealEnumFirstRegKeyStr95W(a,b,__FILE__,__LINE__)

#else

#define EnumFirstRegKeyStr95A RealEnumFirstRegKeyStr95A
#define EnumFirstRegKeyStr95W RealEnumFirstRegKeyStr95W

#endif



BOOL
EnumNextRegKey95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

BOOL
EnumNextRegKey95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

VOID
AbortRegKeyEnum95A (
    IN OUT  PREGKEY_ENUMA EnumPtr
    );

VOID
AbortRegKeyEnum95W (
    IN OUT  PREGKEY_ENUMW EnumPtr
    );

BOOL
RealEnumFirstRegKeyInTree95A (
    OUT     PREGTREE_ENUMA EnumPtr,
    IN      PCSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTree95A(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTree95A",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTree95A(e,base)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumFirstRegKeyInTree95W (
    OUT     PREGTREE_ENUMW EnumPtr,
    IN      PCWSTR BaseKeyStr
    );

#define EnumFirstRegKeyInTree95W(e,base)  SETTRACKCOMMENT(BOOL,"EnumFirstRegKeyInTree95W",__FILE__,__LINE__)\
                                        RealEnumFirstRegKeyInTree95W(e,base)\
                                        CLRTRACKCOMMENT


BOOL
RealEnumNextRegKeyInTree95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

#define EnumNextRegKeyInTree95A(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTree95A",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTree95A(e)\
                                        CLRTRACKCOMMENT

BOOL
RealEnumNextRegKeyInTree95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );

#define EnumNextRegKeyInTree95W(e)        SETTRACKCOMMENT(BOOL,"EnumNextRegKeyInTree95W",__FILE__,__LINE__)\
                                        RealEnumNextRegKeyInTree95W(e)\
                                        CLRTRACKCOMMENT

VOID
AbortRegKeyTreeEnum95A (
    IN OUT  PREGTREE_ENUMA EnumPtr
    );

VOID
AbortRegKeyTreeEnum95W (
    IN OUT  PREGTREE_ENUMW EnumPtr
    );


BOOL
EnumFirstRegValue95A (
    OUT     PREGVALUE_ENUMA EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumFirstRegValue95W (
    OUT     PREGVALUE_ENUMW EnumPtr,
    IN      HKEY hKey
    );

BOOL
EnumNextRegValue95A (
    IN OUT  PREGVALUE_ENUMA EnumPtr
    );

BOOL
EnumNextRegValue95W (
    IN OUT  PREGVALUE_ENUMW EnumPtr
    );

//
// Versions that allow caller to specify allocator, and macro that uses
// pMemAllocWrapper95
//

ALLOCATOR_PROTOTYPE pMemAllocWrapper95;
DEALLOCATOR_PROTOTYPE pMemFreeWrapper95;

PBYTE
GetRegValueDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueData95A(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueData95A",__FILE__, __LINE__)\
                                        GetRegValueDataEx95A((key),(valuename),pMemAllocWrapper95,pMemFreeWrapper95)\
                                        CLRTRACKCOMMENT


PBYTE
GetRegValueDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueData95W(key,valuename) SETTRACKCOMMENT(PBYTE, "GetRegValueData95W",__FILE__, __LINE__)\
                                        GetRegValueDataEx95W((key),(valuename),pMemAllocWrapper95,pMemFreeWrapper95)\
                                        CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfTypeEx95A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfType95A(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfType95A",__FILE__,__LINE__)\
                                                    GetRegValueDataOfTypeEx95A((key),(valuename),(type),pMemAllocWrapper95,pMemFreeWrapper95)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegValueDataOfTypeEx95W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegValueDataOfType95W(key,valuename,type)  SETTRACKCOMMENT(PBYTE, "GetRegValueDataOfType95W",__FILE__,__LINE__)\
                                                    GetRegValueDataOfTypeEx95W((key),(valuename),(type),pMemAllocWrapper95,pMemFreeWrapper95)\
                                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyDataEx95A (
    IN      HKEY hKey,
    IN      PCSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyData95A(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyData95A",__FILE__,__LINE__)\
                                    GetRegKeyDataEx95A((key),(subkey),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegKeyDataEx95W (
    IN      HKEY hKey,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegKeyData95W(key,subkey)  SETTRACKCOMMENT(PBYTE, "GetRegKeyData95W",__FILE__,__LINE__)\
                                    GetRegKeyDataEx95W((key),(subkey),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

PBYTE
GetRegDataEx95A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegData95A(keystr,value) SETTRACKCOMMENT(PBYTE, "GetRegData95A",__FILE__,__LINE__)\
                                  GetRegDataEx95A((keystr),(value),pMemAllocWrapper95,pMemFreeWrapper95)\
                                  CLRTRACKCOMMENT

PBYTE
GetRegDataEx95W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR Allocator,
    IN      DEALLOCATOR Deallocator
    );

#define GetRegData95W(keystr,value)   SETTRACKCOMMENT(PBYTE, "GetRegData95W",__FILE__,__LINE__)\
                                    GetRegDataEx95W((keystr),(value),pMemAllocWrapper95,pMemFreeWrapper95)\
                                    CLRTRACKCOMMENT

//
// Win95Reg key open
//

HKEY
RealOpenRegKeyStr95A (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKeyStr95W (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKey95A (
    IN      HKEY ParentKey,
    IN      PCSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

HKEY
RealOpenRegKey95W (
    IN      HKEY ParentKey,
    IN      PCWSTR KeyToOpen
            DEBUG_TRACKING_PARAMS
    );

LONG
RealCloseRegKey95 (
    IN      HKEY Key
    );


#ifdef DEBUG

#define OpenRegKeyStr95A(a)      RealOpenRegKeyStr95A(a,__FILE__,__LINE__)
#define OpenRegKeyStr95W(a)      RealOpenRegKeyStr95W(a,__FILE__,__LINE__)
#define OpenRegKey95A(a,b)       RealOpenRegKey95A(a,b,__FILE__,__LINE__)
#define OpenRegKey95W(a,b)       RealOpenRegKey95W(a,b,__FILE__,__LINE__)

#else

#define OpenRegKeyStr95A RealOpenRegKeyStr95A
#define OpenRegKeyStr95W RealOpenRegKeyStr95W
#define OpenRegKey95A RealOpenRegKey95A
#define OpenRegKey95W RealOpenRegKey95W

#endif


//
// Macros
//

#define GetRegValueString95A(key,valuename) (PCSTR) GetRegValueDataOfType95A((key),(valuename),REG_SZ)
#define GetRegValueBinary95A(key,valuename) (PBYTE) GetRegValueDataOfType95A((key),(valuename),REG_BINARY)
#define GetRegValueMultiSz95A(key,valuename) (PCSTR) GetRegValueDataOfType95A((key),(valuename),REG_MULTISZ)
#define GetRegValueDword95A(key,valuename) (PDWORD) GetRegValueDataOfType95A((key),(valuename),REG_DWORD)

#define GetRegValueString95W(key,valuename) (PCWSTR) GetRegValueDataOfType95W((key),(valuename),REG_SZ)
#define GetRegValueBinary95W(key,valuename) (PBYTE) GetRegValueDataOfType95W((key),(valuename),REG_BINARY)
#define GetRegValueMultiSz95W(key,valuename) (PCWSTR) GetRegValueDataOfType95W((key),(valuename),REG_MULTISZ)
#define GetRegValueDword95W(key,valuename) (PDWORD) GetRegValueDataOfType95W((key),(valuename),REG_DWORD)

#define GetRegValueStringEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinaryEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSzEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDwordEx95A(key,valuename,alloc,free) GetRegValueDataOfTypeEx95A((key),(valuename),REG_DWORD,alloc,free)

#define GetRegValueStringEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_SZ,alloc,free)
#define GetRegValueBinaryEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_BINARY,alloc,free)
#define GetRegValueMultiSzEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_MULTISZ,alloc,free)
#define GetRegValueDwordEx95W(key,valuename,alloc,free) GetRegValueDataOfTypeEx95W((key),(valuename),REG_DWORD,alloc,free)

#ifdef UNICODE

#define EnumFirstRegKey95           EnumFirstRegKey95W
#define EnumFirstRegKeyStr95        EnumFirstRegKeyStr95W
#define EnumNextRegKey95            EnumNextRegKey95W
#define AbortRegKeyEnum95           AbortRegKeyEnum95W
#define EnumFirstRegKeyInTree95     EnumFirstRegKeyInTree95W
#define EnumNextRegKeyInTree95      EnumNextRegKeyInTree95W
#define AbortRegKeyTreeEnum95       AbortRegKeyTreeEnum95W
#define EnumFirstRegValue95         EnumFirstRegValue95W
#define EnumNextRegValue95          EnumNextRegValue95W

#define GetRegValueData95           GetRegValueData95W
#define GetRegValueDataOfType95     GetRegValueDataOfType95W
#define GetRegKeyData95             GetRegKeyData95W
#define GetRegValueDataEx95         GetRegValueDataEx95W
#define GetRegValueDataOfTypeEx95   GetRegValueDataOfTypeEx95W
#define GetRegKeyDataEx95           GetRegKeyDataEx95W
#define GetRegValueString95         GetRegValueString95W
#define GetRegValueBinary95         GetRegValueBinary95W
#define GetRegValueMultiSz95        GetRegValueMultiSz95W
#define GetRegValueDword95          GetRegValueDword95W
#define GetRegValueStringEx95       GetRegValueStringEx95W
#define GetRegValueBinaryEx95       GetRegValueBinaryEx95W
#define GetRegValueMultiSzEx95      GetRegValueMultiSzEx95W
#define GetRegValueDwordEx95        GetRegValueDwordEx95W
#define GetRegDataEx95              GetRegDataEx95W
#define GetRegData95                GetRegData95W

#define OpenRegKey95                OpenRegKey95W
#define OpenRegKeyStr95             OpenRegKeyStr95W


#else

#define EnumFirstRegKey95           EnumFirstRegKey95A
#define EnumFirstRegKeyStr95        EnumFirstRegKeyStr95A
#define EnumNextRegKey95            EnumNextRegKey95A
#define AbortRegKeyEnum95           AbortRegKeyEnum95A
#define EnumFirstRegKeyInTree95     EnumFirstRegKeyInTree95A
#define EnumNextRegKeyInTree95      EnumNextRegKeyInTree95A
#define AbortRegKeyTreeEnum95       AbortRegKeyTreeEnum95A
#define EnumFirstRegValue95         EnumFirstRegValue95A
#define EnumNextRegValue95          EnumNextRegValue95A

#define GetRegValueData95           GetRegValueData95A
#define GetRegValueDataOfType95     GetRegValueDataOfType95A
#define GetRegKeyData95             GetRegKeyData95A
#define GetRegValueDataEx95         GetRegValueDataEx95A
#define GetRegValueDataOfTypeEx95   GetRegValueDataOfTypeEx95A
#define GetRegKeyDataEx95           GetRegKeyDataEx95A
#define GetRegValueString95         GetRegValueString95A
#define GetRegValueBinary95         GetRegValueBinary95A
#define GetRegValueMultiSz95        GetRegValueMultiSz95A
#define GetRegValueDword95          GetRegValueDword95A
#define GetRegValueStringEx95       GetRegValueStringEx95A
#define GetRegValueBinaryEx95       GetRegValueBinaryEx95A
#define GetRegValueMultiSzEx95      GetRegValueMultiSzEx95A
#define GetRegValueDwordEx95        GetRegValueDwordEx95A
#define GetRegDataEx95              GetRegDataEx95A
#define GetRegData95                GetRegData95A

#define OpenRegKey95                OpenRegKey95A
#define OpenRegKeyStr95             OpenRegKeyStr95A


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\snapshot.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    snapshot.h

Abstract:

    Declares the interface to common\snapshot.  The snapshot code uses
    memdb to capture and compare the system state.

Author:

    Jim Schmidt (jimschm)   26-Mar-1998

Revision History:

    calinn  15-Oct-1998     Extensions and improvements

--*/

#pragma once

#define SNAP_RESULT_DELETED    1
#define SNAP_RESULT_UNCHANGED  2
#define SNAP_RESULT_CHANGED    4
#define SNAP_RESULT_ADDED      8

#define SNAP_FILES      1
#define SNAP_REGISTRY   2

VOID
TakeSnapShotEx (
    IN      DWORD SnapFlags
    );

BOOL
GenerateDiffOutputExA (
    IN      PCSTR FileName,
    IN      PCSTR Comment,      OPTIONAL
    IN      BOOL Append,
    IN      DWORD SnapFlags
    );

typedef struct _SNAP_FILE_ENUMA {
    CHAR FileName [MEMDB_MAX];
    PCSTR FilePattern;
    DWORD SnapStatus;
    BOOL FirstCall;
    MEMDB_ENUMA mEnum;
} SNAP_FILE_ENUMA, *PSNAP_FILE_ENUMA;

BOOL
EnumNextSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e
    );

BOOL
EnumFirstSnapFileA (
    IN OUT  PSNAP_FILE_ENUMA e,
    IN      PCSTR FilePattern,   OPTIONAL
    IN      DWORD SnapStatus
    );


#define TakeSnapShot()              TakeSnapShotEx(SNAP_FILES|SNAP_REGISTRY)
#define GenerateDiffOutputA(f,c,a)  GenerateDiffOutputExA(f,c,a,SNAP_FILES|SNAP_REGISTRY)

#ifndef UNICODE
#define GenerateDiffOutputEx        GenerateDiffOutputExA
#define GenerateDiffOutput          GenerateDiffOutputA
#define SNAP_FILE_ENUM              SNAP_FILE_ENUMA
#define PSNAP_FILE_ENUM             PSNAP_FILE_ENUMA
#define EnumFirstSnapFile           EnumFirstSnapFileA
#define EnumNextSnapFile            EnumNextSnapFileA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#include <mbstring.h>
#include <wchar.h>

typedef PVOID POOLHANDLE;

#pragma once

#define MAX_ENCODED_RULE   (256*6)


//
// String sizing routines and unit conversion
//

#define LcharCountA     _mbslen
#define LcharCountW      wcslen

#define _ISMBCP     (g_IsMbcp)
#define _ISNOTMBCP  (!g_IsMbcp)


unsigned char * __cdecl our_mbsinc(
    const unsigned char *current
    );

unsigned char * __cdecl our_mbsdec(
    const unsigned char *string,
    const unsigned char *current
    );

unsigned int __cdecl our_mbsnextc (
    const unsigned char *s
    );

size_t __cdecl our_mbclen (
    const unsigned char *c
    );

unsigned char * __cdecl our_mbsstr (
    const unsigned char *str1,
    const unsigned char *str2
    );

__inline
PSTR
LcharCountToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        //
        // this is a bogus assert since the function can be used with multi-sz as well
        //
        //MYASSERT (*String != 0);
        Char--;
        String = (PCSTR) _mbsinc ((const unsigned char *) String);
    }

    return (PSTR) String;
}

__inline
PWSTR
LcharCountToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
LcharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT Count;

    Count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        Count++;
        Start = (PCSTR) _mbsinc ((const unsigned char *) Start);
    }

    return Count;
}

__inline
UINT
LcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
LcharCountInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT Count;
    PCSTR EndPlusOne = (PCSTR) ((PBYTE) Start + Bytes);

    Count = 0;
    while (Start < EndPlusOne) {
        Count++;
        Start = (PCSTR) _mbsinc ((const unsigned char *) Start);
    }

    return Count;
}

__inline
UINT
LcharCountInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR EndPlusOne = (PCWSTR) ((PBYTE) Start + Bytes);

    if (Start < EndPlusOne) {
        return (UINT) (UINT_PTR) (EndPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
LcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT LcharCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = LcharCountToPointerA (Start, LcharCount);
    return (UINT) (UINT_PTR) (EndPlusOne - Start);
}

__inline
UINT
LcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT LcharCount
    )
{
    return LcharCount * sizeof (WCHAR);
}

#define LcharCountToTcharsA   LcharCountToBytesA

__inline
UINT
LcharCountToTcharsW (
    IN      PCWSTR Start,
    IN      UINT LcharCount
    )
{
    return LcharCount;
}


#define ByteCountA          strlen
#define ByteCountW(x)       (wcslen(x)*sizeof(WCHAR))

#define SizeOfStringA(str)  (ByteCountA(str) + sizeof (CHAR))
#define SizeOfStringW(str)  (ByteCountW(str) + sizeof (WCHAR))

__inline
PSTR
ByteCountToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((PBYTE) String + BytePos);
}

__inline
PWSTR
ByteCountToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((PBYTE) String + BytePos);
}


__inline
UINT
ByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
ByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * sizeof (WCHAR) : 0;
}

__inline
UINT
ByteCountToCharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR EndPlusOne;

    EndPlusOne = Start + ByteCount;
    return LcharCountABA (Start, EndPlusOne);
}

__inline
UINT
ByteCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = (PCWSTR) ((PBYTE) Start + ByteCount);

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / sizeof (WCHAR);
}

__inline
UINT
ByteCountToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + ByteCount;

    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define ByteCountToTcharsW  ByteCountToCharsW


#define TcharCountA     strlen
#define TcharCountW     wcslen

__inline
PSTR
TcharCountToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
TcharCountToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = String + Tchars;

    for (p = String ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define TcharCountABA       ByteCountABA

__inline
UINT
TcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define TcharCountToCharsA      ByteCountToCharsA

__inline
UINT
TcharCountToCharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p = (PCSTR) _mbsinc ((const unsigned char *) p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
TcharCountToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR EndPlusOne;
    EndPlusOne = Start + Tchars;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * sizeof (WCHAR);
}

INT
StringICompareByteCountA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    );

INT
StringCompareByteCountA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    );

BOOL
StringMemMatchA (
    IN      PCSTR Buffer1,
    IN      PCSTR Buffer2,
    IN      SIZE_T ByteCount
    );

BOOL
StringMemMatchW (
    IN      PCWSTR Buffer1,
    IN      PCWSTR Buffer2,
    IN      SIZE_T ByteCount
    );

#define StackStringCopyA(stackbuf,src)                  _mbssafecpy(stackbuf,src,sizeof(stackbuf))
#define StackStringCopyW(stackbuf,src)                  _wcssafecpy(stackbuf,src,sizeof(stackbuf))


//
// String comparison routines
//

#define StringCompareA                                  _mbscmp
#define StringCompareW                                  wcscmp

#define StringMatchA(str1,str2)                         (_mbscmp(str1,str2)==0)
#define StringMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define StringICompareA                                 _mbsicmp
#define StringICompareW                                 _wcsicmp

#define StringIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define StringIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

#define StringCompareByteCountW(str1,str2,bytes)        wcsncmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringMatchByteCountA(str1,str2,bytes)          (StringMemMatchA(str1,str2,bytes))
#define StringMatchByteCountW(str1,str2,bytes)          (StringMemMatchW(str1,str2,bytes))

#define StringICompareByteCountW(str1,str2,bytes)       _wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))

#define StringIMatchByteCountA(str1,str2,bytes)         (StringICompareByteCountA(str1,str2,bytes)==0)
#define StringIMatchByteCountW(str1,str2,bytes)         (_wcsnicmp(str1,str2,ByteCountToCharsW(str1,bytes))==0)

#define StringCompareLcharCountA(str1,str2,chars)       _mbsncmp(str1,str2,chars)
#define StringCompareLcharCountW(str1,str2,chars)       wcsncmp(str1,str2,chars)

#define StringMatchLcharCountA(str1,str2,chars)         (_mbsncmp(str1,str2,chars)==0)
#define StringMatchLcharCountW(str1,str2,chars)         (wcsncmp(str1,str2,chars)==0)

#define StringICompareLcharCountA(str1,str2,chars)      _mbsnicmp(str1,str2,chars)
#define StringICompareLcharCountW(str1,str2,chars)      _wcsnicmp(str1,str2,chars)

#define StringIMatchLcharCountA(str1,str2,chars)        (_mbsnicmp(str1,str2,chars)==0)
#define StringIMatchLcharCountW(str1,str2,chars)        (_wcsnicmp(str1,str2,chars)==0)

#define StringCompareTcharCountA(str1,str2,tchars)      StringCompareByteCountA(str1,str2,tchars)
#define StringCompareTcharCountW(str1,str2,tchars)      wcsncmp(str1,str2,tchars)

#define StringMatchTcharCountA(str1,str2,tchars)        (strncmp(str1,str2,tchars)==0)
#define StringMatchTcharCountW(str1,str2,tchars)        (wcsncmp(str1,str2,tchars)==0)

#define StringICompareTcharCountA(str1,str2,tchars)     StringICompareByteCountA (str1, str2, tchars)
#define StringICompareTcharCountW(str1,str2,tchars)     _wcsnicmp(str1,str2,tchars)

#define StringIMatchTcharCountA(str1,str2,tchars)       (StringICompareByteCountA(str1,str2,tchars)==0)
#define StringIMatchTcharCountW(str1,str2,tchars)       (_wcsnicmp(str1,str2,tchars)==0)


INT
StringCompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringCompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

#define StringMatchABA(String,Start,End)                (StringCompareABA(String,Start,End)==0)
#define StringMatchABW(String,Start,End)                (StringCompareABW(String,Start,End)==0)


// stricmp that takes an end pointer instead of a length
INT
StringICompareABA (
    IN      PCSTR String,
    IN      PCSTR Start,
    IN      PCSTR End
    );

INT
StringICompareABW (
    IN      PCWSTR String,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PWSTR
our_lstrcpynW (
    OUT     PWSTR Dest,
    IN      PCWSTR Src,
    IN      INT NumChars
    );


#define StringIMatchABA(String,Start,End)               (StringICompareABA(String,Start,End)==0)
#define StringIMatchABW(String,Start,End)               (StringICompareABW(String,Start,End)==0)



//
// String copy routines
//

#define StringCopyA             strcpy
#define StringCopyW             wcscpy

// bytes
#define StringCopyByteCountA(str1,str2,bytes)        lstrcpynA(str1,str2,bytes)
#define StringCopyByteCountW(str1,str2,bytes)        our_lstrcpynW(str1,str2,(bytes)/sizeof(WCHAR))

// logical characters (IMPORTANT: logical chars != TcharCount)
#define StringCopyLcharCountA(str1,str2,mbchars)     lstrcpynA(str1,str2,LcharCountToBytesA(str2,mbchars))
#define StringCopyLcharCountW(str1,str2,wchars)      our_lstrcpynW(str1,str2,wchars)

// CHARs (A version) or WCHARs (W version)
#define StringCopyTcharCountA(str1,str2,tchars)      lstrcpynA(str1,str2,tchars)
#define StringCopyTcharCountW(str1,str2,tchars)      our_lstrcpynW(str1,str2,tchars)

#define StringCopyABA(dest,stra,strb)                StringCopyByteCountA((dest),(stra),(UINT) (UINT_PTR) ((PBYTE)(strb)-(PBYTE)(stra)+(INT)sizeof(CHAR)))
#define StringCopyABW(dest,stra,strb)                StringCopyByteCountW((dest),(stra),(UINT) (UINT_PTR) ((PBYTE)(strb)-(PBYTE)(stra)+(INT)sizeof(WCHAR)))

//
// String cat routines
//

#define StringCatA              _mbsappend
#define StringCatW              _wcsappend

//
// Character search routines
//

#define GetEndOfStringA(s)      strchr(s,0)
#define GetEndOfStringW(s)      wcschr(s,0)

__inline
UINT
SizeOfMultiSzA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT) (UINT_PTR) ((PBYTE) MultiSz - (PBYTE) Base);
}


__inline
UINT
SizeOfMultiSzW (
    PCWSTR MultiSz
    )
{
    PCWSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = GetEndOfStringW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT) (UINT_PTR) ((PBYTE) MultiSz - (PBYTE) Base);
}


__inline
UINT
MultiSzSizeInCharsA (
    PCSTR MultiSz
    )
{
    UINT Chars = 0;

    while (*MultiSz) {

        do {
            Chars++;
            MultiSz = (PCSTR) _mbsinc ((const unsigned char *) MultiSz);
        } while (*MultiSz);

        Chars++;
        MultiSz++;
    }

    Chars++;

    return Chars;
}


#define MultiSzSizeInCharsW(msz)  (SizeOfMultiSzW(msz)/sizeof(WCHAR))

PSTR
GetPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      CHARTYPE SearchChar
    );

PWSTR
GetPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

//
// Pool allocation routines
//

PSTR
RealAllocTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      UINT ByteSize
    );

PWSTR
RealAllocTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      UINT WcharSize
    );

#define AllocTextExA(p,s)   SETTRACKCOMMENT(PSTR,"AllocTextExA",__FILE__,__LINE__)\
                            RealAllocTextExA(p,s)\
                            CLRTRACKCOMMENT

#define AllocTextExW(p,s)   SETTRACKCOMMENT(PWSTR,"AllocTextExW",__FILE__,__LINE__)\
                            RealAllocTextExW(p,s)\
                            CLRTRACKCOMMENT

#define AllocTextA(s)       AllocTextExA(NULL,(s))
#define AllocTextW(s)       AllocTextExW(NULL,(s))



VOID
FreeTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text          OPTIONAL
    );

VOID
FreeTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text         OPTIONAL
    );

#define FreeTextA(t)    FreeTextExA(NULL,t)
#define FreeTextW(t)    FreeTextExW(NULL,t)

PSTR
RealDuplicateTextExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Text,
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar       OPTIONAL
    );

PWSTR
RealDuplicateTextExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Text,
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar      OPTIONAL
    );

#define DuplicateTextExA(p,t,c,n)   SETTRACKCOMMENT(PSTR,"DuplicateTextExA",__FILE__,__LINE__)\
                                    RealDuplicateTextExA(p,t,c,n)\
                                    CLRTRACKCOMMENT

#define DuplicateTextExW(p,t,c,n)   SETTRACKCOMMENT(PWSTR,"DuplicateTextExW",__FILE__,__LINE__)\
                                    RealDuplicateTextExW(p,t,c,n)\
                                    CLRTRACKCOMMENT

#define DuplicateTextA(text) DuplicateTextExA(NULL,text,0,NULL)
#define DuplicateTextW(text) DuplicateTextExW(NULL,text,0,NULL)

PSTR
RealJoinTextExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      PCSTR DelimeterString,  OPTIONAL
    IN      UINT ExtraChars,
    OUT     PSTR *NulChar           OPTIONAL
    );

PWSTR
RealJoinTextExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR String1,
    IN      PCWSTR String2,
    IN      PCWSTR CenterString,    OPTIONAL
    IN      UINT ExtraChars,
    OUT     PWSTR *NulChar          OPTIONAL
    );

#define JoinTextExA(p,s1,s2,cs,ec,nc)   SETTRACKCOMMENT(PSTR,"JoinTextExA",__FILE__,__LINE__)\
                                        RealJoinTextExA(p,s1,s2,cs,ec,nc)\
                                        CLRTRACKCOMMENT

#define JoinTextExW(p,s1,s2,cs,ec,nc)   SETTRACKCOMMENT(PWSTR,"JoinTextExW",__FILE__,__LINE__)\
                                        RealJoinTextExW(p,s1,s2,cs,ec,nc)\
                                        CLRTRACKCOMMENT

#define JoinTextA(str1,str2) JoinTextExA(NULL,str1,str2,NULL,0,NULL)
#define JoinTextW(str1,str2) JoinTextExW(NULL,str1,str2,NULL,0,NULL)


PSTR
RealExpandEnvironmentTextExA (
    IN PCSTR   InString,
    IN PCSTR * ExtraEnvironmentVariables OPTIONAL
    );

PWSTR
RealExpandEnvironmentTextExW (
    IN PCWSTR   InString,
    IN PCWSTR * ExtraEnvironmentVariables OPTIONAL
    );

#define ExpandEnvironmentTextExA(str,ev)    SETTRACKCOMMENT(PSTR,"ExpandEnvironmentTextExA",__FILE__,__LINE__)\
                                            RealExpandEnvironmentTextExA(str,ev)\
                                            CLRTRACKCOMMENT

#define ExpandEnvironmentTextExW(str,ev)    SETTRACKCOMMENT(PWSTR,"ExpandEnvironmentTextExW",__FILE__,__LINE__)\
                                            RealExpandEnvironmentTextExW(str,ev)\
                                            CLRTRACKCOMMENT

#define ExpandEnvironmentTextA(string) ExpandEnvironmentTextExA(string,NULL)
#define ExpandEnvironmentTextW(string) ExpandEnvironmentTextExW(string,NULL)


//
// NOTE: IsLeadByte routine now takes a (const CHAR*) to be able to test for a
// "naked lead byte" combination (LeadByte + NULL combination)
// Thus, if it returns TRUE, it's safe to assume there is a trail byte after the lead
// Function wraps IsDBCSLeadByte(), which tests ACP. Do not use
// isleadbyte().
//

__inline
BOOL
IsLeadByte (
    IN      PCSTR BytePtr
    )
{
    return (!_ISNOTMBCP && BytePtr[0] && IsDBCSLeadByte (BytePtr[0])) ? BytePtr[1] != 0 : FALSE;
}


//
// Command line routines
//

// Converts ANSI command line to array of args
PSTR *
CommandLineToArgvA (
    IN      PCSTR CmdLine,
    OUT     INT *NumArgs
    );


//
// Need both MBCS and UNICODE versions
//

// an atoi that supports decimal or hex
DWORD   _mbsnum (IN PCSTR szNum);
DWORD   _wcsnum (IN PCWSTR szNum);

// a strcat that returns a pointer to the end of the string
PSTR   _mbsappend (OUT PSTR szDest, IN PCSTR szSrc);
PWSTR  _wcsappend (OUT PWSTR szDest, IN PCWSTR szSrc);

// determines if an entire string is printable chars
int     _mbsisprint (PCSTR szStr);
int     _wcsisprint (PCWSTR szStr);

// case-insensitive strstr
PCSTR  _mbsistr (PCSTR szStr, PCSTR szSubStr);
PCWSTR _wcsistr (PCWSTR szStr, PCWSTR szSubStr);

// copies the first character of str2 to str
void    _copymbchar (PSTR str1, PCSTR str2);
#define _copywchar(dest,src)    (*(dest)=*(src))

// replaces a character in a multi-byte char string and maintains
// the string integrity (may grow string by one byte)
void    _setmbchar  (PSTR str, MBCHAR c);
#define _setwchar(str,c)        (*(str)=(c))

// removes specified character from the end of a string, if it exists
BOOL    _mbsctrim (PSTR str, MBCHAR c);
BOOL    _wcsctrim (PWSTR str, WCHAR c);

// Always adds a backslash, returns ptr to nul terminator
PSTR    AppendWackA (IN PSTR str);
PWSTR   AppendWackW (IN PWSTR str);

// Calls AppendWack only if there is enough buffer space in str
//  buflen = size in bytes
PSTR    StringCbAppendWackA (IN PSTR str, IN UINT buflen);
PWSTR   StringCbAppendWackW (IN PWSTR str, IN UINT buflen);

// Adds a backslash to the end of a DOS path (unless str is empty
// or is only a drive letter)
PSTR    AppendDosWackA (IN PSTR str);
PWSTR   AppendDosWackW (IN PWSTR str);

// Adds a backslash unless str is empty
PSTR    AppendUncWackA (IN PSTR str);
PWSTR   AppendUncWackW (IN PWSTR str);

// Adds a backslash and identifies the correct naming convention (DOS,
// or UNC)
PSTR    AppendPathWackA (IN PSTR str);
PWSTR   AppendPathWackW (IN PWSTR str);

// Joins two paths together, allocates string in g_PathsPool
PSTR
RealJoinPathsExA (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCSTR PathA,
    IN      PCSTR PathB
    );

PWSTR
RealJoinPathsExW (
    IN      POOLHANDLE Pool,        OPTIONAL
    IN      PCWSTR PathA,
    IN      PCWSTR PathB
    );

#define JoinPathsExA(pool,p1,p2)    SETTRACKCOMMENT(PSTR,"JoinPathsA",__FILE__,__LINE__)\
                                    RealJoinPathsExA(pool,p1,p2)\
                                    CLRTRACKCOMMENT

#define JoinPathsExW(pool,p1,p2)    SETTRACKCOMMENT(PWSTR,"JoinPathsW",__FILE__,__LINE__)\
                                    RealJoinPathsExW(pool,p1,p2)\
                                    CLRTRACKCOMMENT

#define JoinPathsA(p1,p2)           JoinPathsExA(NULL,p1,p2)
#define JoinPathsW(p1,p2)           JoinPathsExW(NULL,p1,p2)


// Routine to allocate a 1K buffer for path manipulation, allocated in g_PathsPool
PSTR    RealAllocPathStringA (IN DWORD Chars);
PWSTR   RealAllocPathStringW (IN DWORD Chars);
#define DEFSIZE 0

#define AllocPathStringA(chars)     SETTRACKCOMMENT(PSTR,"AllocPathStringA",__FILE__,__LINE__)\
                                    RealAllocPathStringA(chars)\
                                    CLRTRACKCOMMENT

#define AllocPathStringW(chars)     SETTRACKCOMMENT(PWSTR,"AllocPathStringW",__FILE__,__LINE__)\
                                    RealAllocPathStringW(chars)\
                                    CLRTRACKCOMMENT

// Routine to divide path into separate strings, each allocated in g_PathsPool
VOID    RealSplitPathA (IN PCSTR Path, OUT PSTR *Drive, OUT PSTR *Dir, OUT PSTR *File, OUT PSTR *Ext);
VOID    RealSplitPathW (IN PCWSTR Path, OUT PWSTR *Drive, OUT PWSTR *Dir, OUT PWSTR *File, OUT PWSTR *Ext);

#define SplitPathA(path,dv,dir,f,e) SETTRACKCOMMENT_VOID ("SplitPathA",__FILE__,__LINE__)\
                                    RealSplitPathA(path,dv,dir,f,e)\
                                    CLRTRACKCOMMENT_VOID

#define SplitPathW(path,dv,dir,f,e) SETTRACKCOMMENT_VOID ("SplitPathW",__FILE__,__LINE__)\
                                    RealSplitPathW(path,dv,dir,f,e)\
                                    CLRTRACKCOMMENT_VOID

// Routine to extract the file from a path
PCSTR  GetFileNameFromPathA (IN PCSTR Path);
PCWSTR GetFileNameFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path
PCSTR  GetFileExtensionFromPathA (IN PCSTR Path);
PCWSTR GetFileExtensionFromPathW (IN PCWSTR Path);

// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
PCSTR  GetDotExtensionFromPathA (IN PCSTR Path);
PCWSTR GetDotExtensionFromPathW (IN PCWSTR Path);

// Routine to duplicate a path and allocate space for cat processing
PSTR    RealDuplicatePathStringA (IN PCSTR Path, IN DWORD ExtraBytes);
PWSTR   RealDuplicatePathStringW (IN PCWSTR Path, IN DWORD ExtraBytes);

#define DuplicatePathStringA(path,eb)   SETTRACKCOMMENT(PSTR,"DuplicatePathStringA",__FILE__,__LINE__)\
                                        RealDuplicatePathStringA(path,eb)\
                                        CLRTRACKCOMMENT

#define DuplicatePathStringW(path,eb)   SETTRACKCOMMENT(PWSTR,"DuplicatePathStringW",__FILE__,__LINE__)\
                                        RealDuplicatePathStringW(path,eb)\
                                        CLRTRACKCOMMENT

// Routines to enumerate the PATH variable
typedef struct _PATH_ENUMA {
    PSTR  BufferPtr;
    PSTR  PtrNextPath;
    PSTR  PtrCurrPath;
} PATH_ENUMA, *PPATH_ENUMA;

BOOL
EnumFirstPathExA (
    OUT     PPATH_ENUMA PathEnum,
    IN      PCSTR AdditionalPath,
    IN      PCSTR WinDir,
    IN      PCSTR SysDir,
    IN      BOOL IncludeEnvPath
    );

#define EnumFirstPathA(e,a,w,s) EnumFirstPathExA(e,a,w,s,TRUE)

BOOL
EnumNextPathA (
    IN OUT  PPATH_ENUMA PathEnum
    );

BOOL
EnumPathAbortA (
    IN OUT  PPATH_ENUMA PathEnum
    );



// Frees a string allocated in g_PathsPool
VOID
FreePathStringExA (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCSTR Path          OPTIONAL
    );

VOID
FreePathStringExW (
    IN      POOLHANDLE Pool,    OPTIONAL
    IN      PCWSTR Path         OPTIONAL
    );

#define FreePathStringA(p) FreePathStringExA(NULL,p)
#define FreePathStringW(p) FreePathStringExW(NULL,p)

// Removes a trailing backslash, if it exists
#define RemoveWackAtEndA(str)  _mbsctrim(str,'\\')
#define RemoveWackAtEndW(str)  _wcsctrim(str,L'\\')

// Rule encoding functions used to encode a number of syntax-related
// characters (backslash, brackets, asterisk, etc)
PSTR   EncodeRuleCharsA (PSTR szEncRule, DWORD mbstrEncRuleChars, PCSTR szRule);
PWSTR  EncodeRuleCharsW (PWSTR szEncRule, DWORD wstrEncRuleChars, PCWSTR szRule);

// Rule decoding functions used to restore an encoded string
MBCHAR  GetNextRuleCharA (PCSTR *p_szRule, BOOL *p_bFromHex);
WCHAR   GetNextRuleCharW (PCWSTR *p_szRule, BOOL *p_bFromHex);
PSTR   DecodeRuleCharsA (PSTR szRule, DWORD mbstrRuleBufferChars, PCSTR szEncRule);
PWSTR  DecodeRuleCharsW (PWSTR szRule, DWORD wstrRuleBufferChars, PCWSTR szEncRule);
PSTR   DecodeRuleCharsABA (PSTR szRule, DWORD mbstrRuleBufferChars, PCSTR szEncRuleStart, PCSTR End);
PWSTR  DecodeRuleCharsABW (PWSTR szRule, DWORD wstrRuleBufferChars, PCWSTR szEncRuleStart, PCWSTR End);

// Returns a pointer to the next non-space character (uses isspace)
PCSTR  SkipSpaceA (PCSTR szStr);
PCWSTR SkipSpaceW (PCWSTR szStr);

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR  SkipSpaceRA (PCSTR szBaseStr, PCSTR szStr);
PCWSTR SkipSpaceRW (PCWSTR szBaseStr, PCWSTR szStr);

// Truncates a string after the last non-whitepace character
VOID TruncateTrailingSpaceA (IN OUT  PSTR Str);
VOID TruncateTrailingSpaceW (IN OUT  PWSTR Str);


// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchA (PCSTR wstrPattern, PCSTR wstrStr);
BOOL IsPatternMatchW (PCWSTR wstrPattern, PCWSTR wstrStr);

// Returns TRUE if str matches wstrPattern.  Case-sensitive, supports
// multiple asterisks and question marks.
BOOL IsPatternMatchABA (PCSTR Pattern, PCSTR Start, PCSTR End);
BOOL IsPatternMatchABW (PCWSTR Pattern, PCWSTR Start, PCWSTR End);

//
// More powerful pattern matching
//

#define SEGMENTTYPE_UNKNOWN         0
#define SEGMENTTYPE_EXACTMATCH      1
#define SEGMENTTYPE_OPTIONAL        2
#define SEGMENTTYPE_REQUIRED        3

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // optional
        struct {
            UINT MaxLen;                // zero if any length
            PCSTR IncludeSet;           OPTIONAL
            PCSTR ExcludeSet;           OPTIONAL
        } Wildcard;
    };
} SEGMENTA, *PSEGMENTA;

typedef struct {
    UINT SegmentCount;
    PSEGMENTA Segment;
} PATTERNPROPSA, *PPATTERNPROPSA;

typedef struct {
    UINT PatternCount;
    POOLHANDLE Pool;
    PPATTERNPROPSA Pattern;
} PARSEDPATTERNA, *PPARSEDPATTERNA;

typedef struct {
    UINT Type;

    union {

        // exact match
        struct {
            PCWSTR LowerCasePhrase;
            UINT PhraseBytes;
        } Exact;

        // wildcard
        struct {
            UINT MaxLen;                // zero if any length
            PCWSTR IncludeSet;          OPTIONAL
            PCWSTR ExcludeSet;          OPTIONAL
        } Wildcard;
    };
} SEGMENTW, *PSEGMENTW;

typedef struct {
    UINT SegmentCount;
    PSEGMENTW Segment;
} PATTERNPROPSW, *PPATTERNPROPSW;

typedef struct {
    UINT PatternCount;
    POOLHANDLE Pool;
    PPATTERNPROPSW Pattern;
} PARSEDPATTERNW, *PPARSEDPATTERNW;


BOOL
IsPatternMatchExA (
    IN      PCSTR Pattern,
    IN      PCSTR Start,
    IN      PCSTR End
    );

BOOL
IsPatternMatchExW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Start,
    IN      PCWSTR End
    );

PPARSEDPATTERNA
CreateParsedPatternA (
    IN      PCSTR Pattern
    );

PPARSEDPATTERNW
CreateParsedPatternW (
    IN      PCWSTR Pattern
    );

BOOL
TestParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest
    );

BOOL
TestParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest
    );

BOOL
TestParsedPatternABA (
    IN      PPARSEDPATTERNA ParsedPattern,
    IN      PCSTR StringToTest,
    IN      PCSTR EndPlusOne
    );

BOOL
TestParsedPatternABW (
    IN      PPARSEDPATTERNW ParsedPattern,
    IN      PCWSTR StringToTest,
    IN      PCWSTR EndPlusOne
    );

VOID
PrintPattern (
    PCSTR Pattern,
    PPARSEDPATTERNA Struct
    );

VOID
DestroyParsedPatternA (
    IN      PPARSEDPATTERNA ParsedPattern
    );

VOID
DestroyParsedPatternW (
    IN      PPARSEDPATTERNW ParsedPattern
    );





// Character counters
UINT CountInstancesOfCharA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharW (PCWSTR String, WCHAR Char);

UINT CountInstancesOfCharIA (PCSTR String, MBCHAR Char);
UINT CountInstancesOfCharIW (PCWSTR String, WCHAR Char);


//
// Message Functions
//
// An AllocTable is an array of HLOCAL pointers that the message routines
// return.  This table is maintained to allow a single function to clean up
// all strings at once.
//
// All "Ex" functions (ParseMessageEx, GetStringResourceEx, and so on)
// require a valid AllocTable pointer.  A caller obtains this pointer by
// calling CreateAllocTable before processing any message.  The caller
// cleans up the entire table by calling DestroyAllocTable.
//
// A set of macros can be used for short-term strings.  ParseMessage and
// GetStringResource work the same as their Ex counterparts, but operate
// on the process-wide g_ShortTermAllocTable.  Short-term strings are
// freed with FreeStringResource.
//
// A routine that calls ParseMessage and/or GetStringResource several times
// in the same function wrap the calls between BeginMessageProcessing and
// EndMessageProcessing.  Only one thread in the process can do this at a
// time, and when EndMessageProcessing is called, all strings allocated
// by ParseMessage or GetResourceString in the processing section are
// automatically freed.
//

// AllocTable creation/deletion
PGROWBUFFER CreateAllocTable (VOID);
VOID DestroyAllocTable (PGROWBUFFER AllocTable);

// The "Ex" functions
// ParseMessageEx retrieves the string resource via FormatMessage
PCSTR ParseMessageExA (PGROWBUFFER AllocTable, PCSTR Template, PCSTR ArgArray[]);
PCWSTR ParseMessageExW (PGROWBUFFER AllocTable, PCWSTR Template, PCWSTR ArgArray[]);

// GetStringResourceEx retrives an argument-less string resource
PCSTR GetStringResourceExA (PGROWBUFFER AllocTable, UINT ID);
PCWSTR GetStringResourceExW (PGROWBUFFER AllocTable, UINT ID);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros
VOID FreeStringResourceExA (PGROWBUFFER AllocTable, PCSTR String);
VOID FreeStringResourceExW (PGROWBUFFER AllocTable, PCWSTR String);

// Frees resources allocated by ParseMessageEx, GetStringResourceEx and all macros.
// Tests String first; nulls when freed.
VOID FreeStringResourcePtrExA (PGROWBUFFER AllocTable, PCSTR * String);
VOID FreeStringResourcePtrExW (PGROWBUFFER AllocTable, PCWSTR * String);

// Macros
extern PGROWBUFFER g_ShortTermAllocTable;
#define ParseMessageA(strid,args) ParseMessageExA(g_ShortTermAllocTable, strid, args)
#define ParseMessageW(strid,args) ParseMessageExW(g_ShortTermAllocTable, strid, args)
#define ParseMessageIDA(id,args) ParseMessageExA(g_ShortTermAllocTable, (PCSTR) (id), args)
#define ParseMessageIDW(id,args) ParseMessageExW(g_ShortTermAllocTable, (PCWSTR) (id), args)
#define ParseMessageIDExA(table,id,args) ParseMessageExA(table, (PCSTR) (id), args)
#define ParseMessageIDExW(table,id,args) ParseMessageExW(table, (PCWSTR) (id), args)
#define GetStringResourceA(id) GetStringResourceExA(g_ShortTermAllocTable, id)
#define GetStringResourceW(id) GetStringResourceExW(g_ShortTermAllocTable, id)
#define FreeStringResourceA(str) FreeStringResourceExA(g_ShortTermAllocTable, str)
#define FreeStringResourceW(str) FreeStringResourceExW(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrA(str) FreeStringResourcePtrExA(g_ShortTermAllocTable, str)
#define FreeStringResourcePtrW(str) FreeStringResourcePtrExW(g_ShortTermAllocTable, str)

// Functions for single-threaded message-intensive processing loops
BOOL BeginMessageProcessing (VOID);
VOID EndMessageProcessing (VOID);


//
// The following message functions do not return strings, so they do not
// need cleanup.
//

// An odd variant--obtains message ID from a window's text and replaces
// it with the actual message.  Useful in dialog box initialization.
VOID ParseMessageInWndA (HWND hwnd, PCSTR ArgArray[]);
VOID ParseMessageInWndW (HWND hwnd, PCWSTR ArgArray[]);

// Displays a message box using a message string
INT ResourceMessageBoxA (HWND hwndOwner, UINT ID, UINT Flags, PCSTR ArgArray[]);
INT ResourceMessageBoxW (HWND hwndOwner, UINT ID, UINT Flags, PCWSTR ArgArray[]);


//
// Functions that don't care about UNICODE or MBCS
// and realy shouldn't be in strings.h/.c
//

// Pushes dwError on a global error stack
void    PushNewError (DWORD dwError);

// Pushes the return of GetLastError() on a global error stack
void    PushError (void);

// Pops the last error from the global error stack, calls SetLastError
// and returns the popped error code.
DWORD   PopError (void);

// Returns an int value for chars 0-9, a-f, A-F, and -1 for all others
int     GetHexDigit (IN  int c);


//
// Inline functions
//

// Returns the character at str[pos]
__inline MBCHAR _mbsgetc(PCSTR str, DWORD pos) {
    return (MBCHAR) our_mbsnextc((const unsigned char *) LcharCountToPointerA ((PSTR) str, pos));
}

__inline WCHAR _wcsgetc(PCWSTR str, DWORD pos) {
    return *LcharCountToPointerW ((PWSTR) str, pos);
}

// Sets the character at str[pos]
// Multibyte version may grow string by one byte.
__inline void _mbssetc(PSTR str, DWORD pos, MBCHAR c) {
    _setmbchar (LcharCountToPointerA (str, pos), c);
}

__inline void _wcssetc(PWSTR str, DWORD pos, WCHAR c) {
    *LcharCountToPointerW (str, pos) = c;
}

// Bug fix for C Runtime _tcsdec
__inline PWSTR _wcsdec2(PCWSTR base, PCWSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PWSTR) (p-1);
}

// Bug fix for C Runtime _tcsdec
__inline PSTR _mbsdec2(PCSTR base, PCSTR p) {
    if (base >= p) {
        return NULL;
    }
    return (PSTR) _mbsdec((const unsigned char *) base, (const unsigned char *) p);
}


// A handy strncpy with forced termination
PSTR _mbsnzcpy (PSTR dest, PCSTR src, int count);
PWSTR _wcsnzcpy (PWSTR dest, PCWSTR src, int count);

// A handy strncpy used for buffer overrun containment
#define _mbssafecpy(dest,src,bufsize) _mbsnzcpy(dest,src,(bufsize)-sizeof(CHAR))
#define _wcssafecpy(dest,src,bufsize) _wcsnzcpy(dest,src,(bufsize)-sizeof(WCHAR))

// strcpyab with forced termination and termination guard
PSTR _mbsnzcpyab (PSTR Dest, PCSTR Start, PCSTR End, int count);
PWSTR _wcsnzcpyab (PWSTR Dest, PCWSTR Start, PCWSTR End, int count);

// A handy strncpyab used for buffer overrun containment
#define _mbssafecpyab(dest,start,end,bufsize) _mbsnzcpyab(dest,start,end,(bufsize)-sizeof(CHAR))
#define _wcssafecpyab(dest,start,end,bufsize) _wcsnzcpyab(dest,start,end,(bufsize)-sizeof(WCHAR))

// Routine that checks string for a prefix
#define StringPrefixA(str,prefix) StringMatchLcharCountA(str,prefix,LcharCountA(prefix))
#define StringIPrefixA(str,prefix) StringIMatchLcharCountA(str,prefix,LcharCountA(prefix))
#define StringPrefixW(str,prefix) StringMatchLcharCountW(str,prefix,LcharCountW(prefix))
#define StringIPrefixW(str,prefix) StringIMatchLcharCountW(str,prefix,LcharCountW(prefix))

//
// Sub String Replacement functions.
//
BOOL StringReplaceW (PWSTR Buffer,DWORD MaxSize,PWSTR ReplaceStartPos,PWSTR ReplaceEndPos,PCWSTR NewString);
BOOL StringReplaceA (PSTR Buffer,DWORD MaxSize,PSTR ReplaceStartPos,PSTR ReplaceEndPos,PCSTR NewString);

//
// String table population from INF section
//

typedef enum {
    CALLBACK_CONTINUE,
    CALLBACK_SKIP,
    CALLBACK_STOP
} CALLBACK_RESULT;

typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEA)(PCSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef CALLBACK_RESULT(ADDINFSECTION_PROTOTYPEW)(PCWSTR String, PVOID * DataPtr,
                                                  UINT * DataSizePtr, PVOID CallbackData);
typedef ADDINFSECTION_PROTOTYPEA * ADDINFSECTION_PROCA;
typedef ADDINFSECTION_PROTOTYPEW * ADDINFSECTION_PROCW;

#if 0
BOOL AddInfSectionToStringTableA (PVOID, HINF, PCSTR, INT, ADDINFSECTION_PROCA, PVOID);
BOOL AddInfSectionToStringTableW (PVOID, HINF, PCWSTR, INT, ADDINFSECTION_PROCW, PVOID);
#endif

UINT
CountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

PCSTR
StringSearchAndReplaceA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString,
    IN      PCSTR ReplaceString
    );

PCWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString
    );

typedef struct _MULTISZ_ENUMA {
    PCSTR   Buffer;
    PCSTR   CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct _MULTISZ_ENUMW {
    PCWSTR  Buffer;
    PCWSTR  CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
EnumNextMultiSzA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
EnumNextMultiSzW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
EnumFirstMultiSzA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
EnumFirstMultiSzW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );


VOID
ToggleWacksW (
    IN OUT PWSTR String,
    IN BOOL Operation
    );

VOID
ToggleWacksA (
    IN OUT PSTR String,
    IN BOOL Operation
    );


PCSTR
SanitizePathA (
    IN      PCSTR FileSpec
    );

PCWSTR
SanitizePathW (
    IN      PCWSTR FileSpec
    );

PCSTR
ConvertSBtoDB (
    PCSTR RootPath,
    PCSTR FullPath,
    PCSTR Limit
    );

//
// TCHAR mappings
//

#ifdef UNICODE

#define LcharCount                  LcharCountW
#define LcharCountToPointer         LcharCountToPointerW
#define LcharCountAB                LcharCountABW
#define LcharCountInByteRange       LcharCountInByteRangeW
#define LcharCountToBytes           LcharCountToBytesW
#define LcharCountToTchars          LcharCountToTcharsW
#define ByteCount                   ByteCountW
#define SizeOfString                SizeOfStringW
#define SizeOfMultiSz               SizeOfMultiSzW
#define MultiSzSizeInChars          MultiSzSizeInCharsW
#define ByteCountToPointer          ByteCountToPointerW
#define ByteCountAB                 ByteCountABW
#define ByteCountToChars            ByteCountToCharsW
#define ByteCountToTchars           ByteCountToTcharsW
#define TcharCount                  TcharCountW
#define TcharCountToPointer         TcharCountToPointerW
#define TcharCountAB                TcharCountABW
#define TcharCountToChars           TcharCountToCharsW
#define TcharCountToBytes           TcharCountToBytesW
#define StackStringCopy             StackStringCopyW
#define StringCompare               StringCompareW
#define StringMatch                 StringMatchW
#define StringICompare              StringICompareW
#define StringIMatch                StringIMatchW
#define StringCompareByteCount      StringCompareByteCountW
#define StringMatchByteCount        StringMatchByteCountW
#define StringICompareByteCount     StringICompareByteCountW
#define StringIMatchByteCount       StringIMatchByteCountW
#define StringCompareLcharCount     StringCompareLcharCountW
#define StringMatchLcharCount       StringMatchLcharCountW
#define StringICompareLcharCount    StringICompareLcharCountW
#define StringIMatchLcharCount      StringIMatchLcharCountW
#define StringCompareTcharCount     StringCompareTcharCountW
#define StringMatchTcharCount       StringMatchTcharCountW
#define StringICompareTcharCount    StringICompareTcharCountW
#define StringIMatchTcharCount      StringIMatchTcharCountW
#define StringCompareAB             StringCompareABW
#define StringMatchAB               StringMatchABW
#define StringICompareAB            StringICompareABW
#define StringIMatchAB              StringIMatchABW
#define StringCopy                  StringCopyW
#define StringCopyByteCount         StringCopyByteCountW
#define StringCopyLcharCount        StringCopyLcharCountW
#define StringCopyTcharCount        StringCopyTcharCountW
#define StringCopyAB                StringCopyABW
#define StringCat                   StringCatW
#define GetEndOfString              GetEndOfStringW
#define GetPrevChar                 GetPrevCharW
#define StringMemMatch              StringMemMatchW

#define AllocTextEx                 AllocTextExW
#define AllocText                   AllocTextW
#define FreeTextEx                  FreeTextExW
#define FreeText                    FreeTextW
#define DuplicateText               DuplicateTextW
#define DuplicateTextEx             DuplicateTextExW
#define JoinTextEx                  JoinTextExW
#define JoinText                    JoinTextW
#define ExpandEnvironmentText       ExpandEnvironmentTextW
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExW
#define CommandLineToArgv           CommandLineToArgvW

#define _tcsdec2                    _wcsdec2
#define _copytchar                  _copywchar
#define _settchar                   _setwchar
#define _tcsgetc                    _wcsgetc
#define _tcssetc                    _wcssetc
#define _tcsnum                     _wcsnum
#define _tcsappend                  _wcsappend
#define _tcsistr                    _wcsistr
#define _tcsisprint                 _wcsisprint
#define _tcsnzcpy                   _wcsnzcpy
#define _tcssafecpy                 _wcssafecpy
#define _tcsnzcpyab                 _wcsnzcpyab
#define _tcssafecpyab               _wcssafecpyab
#define StringPrefix                StringPrefixW
#define StringIPrefix               StringIPrefixW
#define _tcsctrim                   _wcsctrim

#define StringCbAppendWack          StringCbAppendWackW
#define AppendWack                  AppendWackW
#define AppendDosWack               AppendDosWackW
#define AppendUncWack               AppendUncWackW
#define AppendPathWack              AppendPathWackW
#define RemoveWackAtEnd             RemoveWackAtEndW
#define JoinPathsEx                 JoinPathsExW
#define JoinPaths                   JoinPathsW
#define AllocPathString             AllocPathStringW
#define SplitPath                   SplitPathW
#define GetFileNameFromPath         GetFileNameFromPathW
#define GetFileExtensionFromPath    GetFileExtensionFromPathW
#define GetDotExtensionFromPath     GetDotExtensionFromPathW
#define DuplicatePathString         DuplicatePathStringW
#define FreePathStringEx            FreePathStringExW
#define FreePathString              FreePathStringW

#define GetNextRuleChar             GetNextRuleCharW
#define DecodeRuleChars             DecodeRuleCharsW
#define DecodeRuleCharsAB           DecodeRuleCharsABW
#define EncodeRuleChars             EncodeRuleCharsW

#define SkipSpace                   SkipSpaceW
#define SkipSpaceR                  SkipSpaceRW
#define TruncateTrailingSpace       TruncateTrailingSpaceW
#define IsPatternMatch              IsPatternMatchW
#define IsPatternMatchAB            IsPatternMatchABW

#define PPARSEDPATTERN              PPARSEDPATTERNW
#define PARSEDPATTERN               PARSEDPATTERNW
#define CreateParsedPattern         CreateParsedPatternW
#define IsPatternMatchEx            IsPatternMatchExW
#define TestParsedPattern           TestParsedPatternW
#define TestParsedPatternAB         TestParsedPatternABW
#define DestroyParsedPattern        DestroyParsedPatternW

#define CountInstancesOfChar        CountInstancesOfCharW
#define CountInstancesOfCharI       CountInstancesOfCharIW
#define StringReplace               StringReplaceW
#define CountInstancesOfSubString   CountInstancesOfSubStringW
#define StringSearchAndReplace      StringSearchAndReplaceW
#define MULTISZ_ENUM                MULTISZ_ENUMW
#define EnumFirstMultiSz            EnumFirstMultiSzW
#define EnumNextMultiSz             EnumNextMultiSzW

#define ParseMessage                ParseMessageW
#define ParseMessageEx              ParseMessageExW
#define ParseMessageID              ParseMessageIDW
#define ParseMessageIDEx            ParseMessageIDExW
#define GetStringResource           GetStringResourceW
#define GetStringResourceEx         GetStringResourceExW
#define FreeStringResource          FreeStringResourceW
#define ParseMessageInWnd           ParseMessageInWndW
#define ResourceMessageBox          ResourceMessageBoxW

#if 0
#define AddInfSectionToStringTable  AddInfSectionToStringTableW
#endif
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCW

#define ReplaceWacks(f)             ToggleWacksW(f,FALSE)
#define RestoreWacks(f)             ToggleWacksW(f,TRUE)

#define SanitizePath                SanitizePathW

#else

#define LcharCount                  LcharCountA
#define LcharCountToPointer         LcharCountToPointerA
#define LcharCountAB                LcharCountABA
#define LcharCountInByteRange       LcharCountInByteRangeA
#define LcharCountToBytes           LcharCountToBytesA
#define LcharCountToTchars          LcharCountToTcharsA
#define ByteCount                   ByteCountA
#define SizeOfString                SizeOfStringA
#define SizeOfMultiSz               SizeOfMultiSzA
#define MultiSzSizeInChars          MultiSzSizeInCharsA
#define ByteCountToPointer          ByteCountToPointerA
#define ByteCountAB                 ByteCountABA
#define ByteCountToChars            ByteCountToCharsA
#define ByteCountToTchars           ByteCountToTcharsA
#define TcharCount                  TcharCountA
#define TcharCountToPointer         TcharCountToPointerA
#define TcharCountAB                TcharCountABA
#define TcharCountToChars           TcharCountToCharsA
#define TcharCountToBytes           TcharCountToBytesA
#define StackStringCopy             StackStringCopyA
#define StringCompare               StringCompareA
#define StringMatch                 StringMatchA
#define StringICompare              StringICompareA
#define StringIMatch                StringIMatchA
#define StringCompareByteCount      StringCompareByteCountA
#define StringMatchByteCount        StringMatchByteCountA
#define StringICompareByteCount     StringICompareByteCountA
#define StringIMatchByteCount       StringIMatchByteCountA
#define StringCompareLcharCount     StringCompareLcharCountA
#define StringMatchLcharCount       StringMatchLcharCountA
#define StringICompareLcharCount    StringICompareLcharCountA
#define StringIMatchLcharCount      StringIMatchLcharCountA
#define StringCompareTcharCount     StringCompareTcharCountA
#define StringMatchTcharCount       StringMatchTcharCountA
#define StringICompareTcharCount    StringICompareTcharCountA
#define StringIMatchTcharCount      StringIMatchTcharCountA
#define StringCompareAB             StringCompareABA
#define StringMatchAB               StringMatchABA
#define StringICompareAB            StringICompareABA
#define StringIMatchAB              StringIMatchABA

#define StringCopy                  StringCopyA
#define StringCopyByteCount         StringCopyByteCountA
#define StringCopyLcharCount        StringCopyLcharCountA
#define StringCopyTcharCount        StringCopyTcharCountA
#define StringCopyAB                StringCopyABA
#define StringCat                   StringCatA
#define GetEndOfString              GetEndOfStringA
#define GetPrevChar                 GetPrevCharA
#define StringMemMatch              StringMemMatchA

#define AllocTextEx                 AllocTextExA
#define AllocText                   AllocTextA
#define FreeTextEx                  FreeTextExA
#define FreeText                    FreeTextA
#define DuplicateText               DuplicateTextA
#define DuplicateTextEx             DuplicateTextExA
#define JoinTextEx                  JoinTextExA
#define JoinText                    JoinTextA
#define ExpandEnvironmentText       ExpandEnvironmentTextA
#define ExpandEnvironmentTextEx     ExpandEnvironmentTextExA
#define CommandLineToArgv           CommandLineToArgvA

#define _tcsdec2                    our_mbsdec
#define _copytchar                  _copymbchar
#define _settchar                   _setchar
#define _tcsgetc                    _mbsgetc
#define _tcssetc                    _mbssetc
#define _tcsnum                     _mbsnum
#define _tcsappend                  _mbsappend
#define _tcsistr                    _mbsistr
#define _tcsisprint                 _mbsisprint
#define _tcsnzcpy                   _mbsnzcpy
#define _tcssafecpy                 _mbssafecpy
#define _tcsnzcpyab                 _mbsnzcpyab
#define _tcssafecpyab               _mbssafecpyab
#define StringPrefix                StringPrefixA
#define StringIPrefix               StringIPrefixA
#define _tcsctrim                   _mbsctrim

#define StringCbAppendWack          StringCbAppendWackA
#define AppendWack                  AppendWackA
#define AppendDosWack               AppendDosWackA
#define AppendUncWack               AppendUncWackA
#define AppendPathWack              AppendPathWackA
#define RemoveWackAtEnd             RemoveWackAtEndA
#define JoinPathsEx                 JoinPathsExA
#define JoinPaths                   JoinPathsA
#define AllocPathString             AllocPathStringA
#define SplitPath                   SplitPathA
#define GetFileNameFromPath         GetFileNameFromPathA
#define GetFileExtensionFromPath    GetFileExtensionFromPathA
#define GetDotExtensionFromPath     GetDotExtensionFromPathA
#define DuplicatePathString         DuplicatePathStringA

#define PATH_ENUM                   PATH_ENUMA
#define PPATH_ENUM                  PPATH_ENUMA
#define EnumFirstPathEx             EnumFirstPathExA
#define EnumFirstPath               EnumFirstPathA
#define EnumNextPath                EnumNextPathA
#define EnumPathAbort               EnumPathAbortA
#define FreePathStringEx            FreePathStringExA
#define FreePathString              FreePathStringA

#define GetNextRuleChar             GetNextRuleCharA
#define DecodeRuleChars             DecodeRuleCharsA
#define DecodeRuleCharsAB           DecodeRuleCharsABA
#define EncodeRuleChars             EncodeRuleCharsA

#define SkipSpace                   SkipSpaceA
#define SkipSpaceR                  SkipSpaceRA
#define TruncateTrailingSpace       TruncateTrailingSpaceA
#define IsPatternMatch              IsPatternMatchA
#define IsPatternMatchAB            IsPatternMatchABA

#define PPARSEDPATTERN              PPARSEDPATTERNA
#define PARSEDPATTERN               PARSEDPATTERNA
#define CreateParsedPattern         CreateParsedPatternA
#define IsPatternMatchEx            IsPatternMatchExA
#define TestParsedPattern           TestParsedPatternA
#define TestParsedPatternAB         TestParsedPatternABA
#define DestroyParsedPattern        DestroyParsedPatternA

#define CountInstancesOfChar        CountInstancesOfCharA
#define CountInstancesOfCharI       CountInstancesOfCharIA
#define StringReplace               StringReplaceA
#define CountInstancesOfSubString   CountInstancesOfSubStringA
#define StringSearchAndReplace      StringSearchAndReplaceA
#define MULTISZ_ENUM                MULTISZ_ENUMA
#define EnumFirstMultiSz            EnumFirstMultiSzA
#define EnumNextMultiSz             EnumNextMultiSzA

#define ParseMessage                ParseMessageA
#define ParseMessageEx              ParseMessageExA
#define ParseMessageID              ParseMessageIDA
#define ParseMessageIDEx            ParseMessageIDExA
#define GetStringResource           GetStringResourceA
#define GetStringResourceEx         GetStringResourceExA
#define FreeStringResource          FreeStringResourceA
#define ParseMessageInWnd           ParseMessageInWndA
#define ResourceMessageBox          ResourceMessageBoxA

#if 0
#define AddInfSectionToStringTable  AddInfSectionToStringTableA
#endif
#define ADDINFSECTION_PROC          ADDINFSECTION_PROCA

#define ReplaceWacks(f)             ToggleWacksA(f,FALSE)
#define RestoreWacks(f)             ToggleWacksA(f,TRUE)

#define SanitizePath                SanitizePathA

#endif

//
// MessageBox macros
//

#define YesNoBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define YesNoCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_YESNOCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define OkBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OK|MB_ICONINFORMATION|MB_SETFOREGROUND,NULL)
#define OkCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
#define RetryCancelBox(hwnd,ID) ResourceMessageBox(hwnd,ID,MB_RETRYCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND,NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\staticsz.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    staticsz.h

Abstract:

    staticsz serves as a central repository for all string constants across the
    win9x upgrade project.

Author:

    Marc R. Whitten (marcw) 24-Mar-1997

Revision History:

--*/


#ifndef STATICSZ_H
#define STATICSZ_H

//
// staticsz naming standard:
// All names begin with S_ this indicates that they came from this file.
//
// Example:
//  #define S_UNATTENDED                 TEXT("Unattended")
//
// Each section in this file should begin with the following header:

//
// STRING SECTION <name if desired>
// Used By: <list of files using these strings>
//

//
// STRING SECTION (MigIsol)
// Used By: migisol, migapp\plugin.c, migmain\migdlls.c
//

#define S_MIGISOL_EXE                   TEXT("migisol.exe")
#define S_MIGICONS_DAT                  TEXT("migicons.dat")

//
// STRING SECTION (MigApp's Migration DLL Processing)
// Used By: migapp\plugin.c
//

#define S_FILE                          TEXT("File")
#define S_DIRECTORY                     TEXT("Directory")
#define S_REGISTRY                      TEXT("Registry")

#define S_PREINSTALLED_MIGRATION_DLLS   TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Migration DLLs")

// On-CD location for migration DLLs. A subdirectory of g_SourceDirWack.
#define S_WIN9XMIG                      TEXT("win9xmig")

// MIGRATE.INF section names
#define S_MIGRATE_INF                   TEXT("migrate.inf")
#define S_INCOMPATIBLE_MSGS             TEXT("Incompatible Messages")
#define S_HANDLED                       TEXT("Handled")
#define S_MOVED                         TEXT("Moved")

#define S_TEMP_INF                      TEXT("temp.inf")

#define S_MIGRATION_DEFAULT_KEY         TEXT("HKLM\\Migration\\.Default")
#define S_MIGRATION_KEY                 TEXT("HKLM\\Migration")



//
// STRING SECTION (Project File Names)
// Used By: dllentry.c,config.c,init9x.c
//
#define S_DEBUG9XLOG                    TEXT("debug9x.log")
#define S_SYSTEMDAT                     TEXT("system.dat")
#define S_USERDAT                       TEXT("user.dat")
#define S_CLASSESDAT                    TEXT("classes.dat")
#define S_WINNTSIF                      TEXT("winnt.sif")
#define S_NTSETUPDAT                    TEXT("ntsetup.dat")
#define S_USERMIG_INF                   TEXT("usermig.inf")
#define S_WKSTAMIG_INF                  TEXT("wkstamig.inf")
#define S_OPTIONS_INF                   TEXT("domain.inf")
#define S_E95ONLY_DAT                   TEXT("e95only.dat")
#define S_WIN9XUPGUSEROPTIONS           WINNT_D_WIN9XUPG_USEROPTIONS
#define S_UPGRADETXT                    TEXT("upgrade.txt")
#define S_UPGRADEHTM                    TEXT("upgrade.htm")
#define S_STATIC_MOVE_FILES             TEXT("StaticMoveFiles")
#define S_STATIC_COPY_FILES             TEXT("StaticCopyFiles")
#define S_STATIC_INSTALLED_FILES        TEXT("StaticInstalledFiles")
#define S_EXTERNAL_PROCESSES            TEXT("External Processes")
#define S_UNINSTALL_PROFILE_CLEAN_OUT TEXT("Uninstall.UserProfileCleanup")

//
// STRING SECTION (MigApp)
// Used By: migapp\*.c
//
#define S_DEFAULT_PASSWORD              TEXT("")
#define S_TEMP_USER_KEY                 TEXT("$$$")
#define S_MAPPED_DEFAULT_USER_KEY       TEXT("MappedDefaultUser")
#define S_FULL_TEMP_USER_KEY            (TEXT("HKCC\\") S_TEMP_USER_KEY)
#define S_HIVE_TEMP                     TEXT("$hive$")
#define S_DOT_DEFAULT                   TEXT(".Default")
#define S_DOT_ALLUSERS                  TEXT(".AllUsers")
#define S_DOT_DEFAULTA                  ".Default"
#define S_ALL_USERS                     TEXT("All Users")
#define S_DEFAULT_USER                  TEXT("Default User")
#define S_LOCALSERVICE_USER             TEXT("LocalService")
#define S_NETWORKSERVICE_USER           TEXT("NetworkService")

#define S_WINLOGON_REGKEY               TEXT("HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_AUTOADMIN_LOGON_VALUE         TEXT("AutoAdminLogon")
#define S_DEFAULT_PASSWORD_VALUE        TEXT("DefaultPassword")
#define S_DEFAULT_USER_NAME_VALUE       TEXT("DefaultUserName")
#define S_DEFAULT_DOMAIN_NAME_VALUE     TEXT("DefaultDomainName")

#define S_SOFTWARE_PROFILELIST          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define S_WIN9XUPG_FLAG_VALNAME         TEXT("Win9xUpg")
#define S_DEFAULT_USER_KEY              TEXT("HKU\\.Default")
#define S_PROFILESDIRECTORY             TEXT("ProfilesDirectory")

#define S_SETUPDATA         TEXT("SetupData")
#define S_PRODUCTTYPE       TEXT("ProductType")
#define S_WORKSTATIONA      "Workstation"
#define S_PERSONALA         "Personal"
#define S_PROFESSIONALA     "Professional"
#define S_SERVERA           "Server"
#define S_STRINGS           "Strings"
#define S_SKEY_APP_PATHS    "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths"

#define S_HKLM                  "HKLM"
#define S_CHECK_BAD_APPS        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps"
#define S_CHECK_BAD_APPS_400    "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\CheckBadApps400"

#define S_COMMAND_PIF           TEXT("COMMAND.PIF")
#define S_CMDATTRIB_KEY         TEXT("Console\\%SystemRoot%_System32_cmd.exe")
#define S_CMD_FULLSCREEN        TEXT("FullScreen")
#define S_CMD_WINDOWSIZE        TEXT("WindowSize")
#define S_CMD_QUICKEDIT         TEXT("QuickEdit")
#define S_CMD_FACENAME          TEXT("FaceName")
#define S_CMD_FONTSIZE          TEXT("FontSize")
#define S_CMD_FONTWEIGHT        TEXT("FontWeight")
#define S_CMD_FONTFAMILY        TEXT("FontFamily")
#define S_CMD_EXE               TEXT("CMD.EXE")
#define S_COMMAND_COM           TEXT("COMMAND.COM")

//
// STRING SECTION (SysMig Strings)
// Used By: sysmig.c
//

#define S_LOGON_KEY                     TEXT("HKLM\\Network\\Logon")
#define S_LM_LOGON                      TEXT("LMLogon")
#define S_USERNAME_VALUE                TEXT("username")
#define S_PRIMARY_PROVIDER              TEXT("PrimaryProvider")
#define S_LANMAN                        TEXT("Microsoft Network")
#define S_MSNP32                        TEXT("HKLM\\System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider")
#define S_AUTHENTICATING_AGENT          TEXT("AuthenticatingAgent")
#define S_VNETSUP                       TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define S_WORKGROUP                     TEXT("Workgroup")
#define S_FILELIST_UNCOMPRESSED         TEXT("FILELIST.DAT")
#define S_FILELIST_COMPRESSED           TEXT("FILELIST.DA_")
#define S_WINNTDIRECTORIES              TEXT("WinntDirectories")
#define S_INI_FILES_IGNORE              TEXT("INI Files.Ignore")
#define S_INBOX_CFG                     TEXT("HKCU\\Software\\Microsoft\\Windows Messaging Subsystem\\Profiles")

//
// STRING SECTION (NT system environment variable names)
// Used By: userloop.c
//

#define S_USERPROFILE_ENV               TEXT("%USERPROFILE%")
#define S_ALLUSERSPROFILE_ENV           TEXT("%ALLUSERSPROFILE%")
#define S_SYSTEMROOT_ENV                TEXT("%SYSTEMROOT%")
#define S_SYSTEMDRIVE_ENV               TEXT("%SYSTEMDRIVE%")
#define S_BOOTDRIVE_ENV                 TEXT("%BOOTDRIVE%")
#define S_USERPROFILE                   TEXT("USERPROFILE")
#define S_USERPROFILEW                  L"USERPROFILE"
#define S_WINDIR_ENV                    TEXT("%WINDIR%")
#define S_SYSTEMDIR_ENV                 TEXT("%SYSTEMDIR%")
#define S_SYSTEM32DIR_ENV               TEXT("%SYSTEM32DIR%")
#define S_PROGRAMFILES_ENV              TEXT("%PROGRAMFILES%")
#define S_COMMONPROGRAMFILES_ENV        TEXT("%COMMONPROGRAMFILES%")
#define S_APPDIR_ENV                    TEXT("%APPDIR%")

//
// STRING SECTION (INF Section Names)
// Used By:
//
#define S_WIN9XUPGRADE                  TEXT("Win9xUpg")
#define S_WIN9XUPGRADEINTERNALUNATTEND  TEXT("Win9x.Upgrade.Internal")
#define S_ATTENDED                      TEXT("Attended")
#define S_REPORTONLY                    TEXT("ReportOnly")
#define S_APPENDCOMPUTERNAMETOPATHS     TEXT("AppendComputerNameToPaths")
#define S_PNP_DESCRIPTIONS              TEXT("Better PNP Descriptions")
#define S_REINSTALL_PNP_IDS             TEXT("Reinstall PNP IDs")
#define S_STANDARD_PNP_IDS              TEXT("Standard PNP IDs")
#define S_COMPATIBLE_PNP_IDS            TEXT("Compatible PNP IDs")
#define S_UNINSTALL                     TEXT("Uninstall")

#define S_PATHDEFAULT                   TEXT("")
#define S_SAVEREPORTTO                  TEXT("SaveReportTo")
#define S_MIGRATIONDLLPATH              TEXT("MigrationDllPath")
#define S_EXCLUDEDMIGRATIONDLLS         TEXT("ExcludedMigrationDlls")
#define S_EXCLUDEDMIGDLLSBYATTR         TEXT("ExcludedMigDllsByAttr")
#define S_CD_MIGRATION_DLLS             TEXT("MigrationDllPaths")
#define S_SAVELOGTO                     TEXT("SaveLogTo")
#define S_SAVEPROFILETO                 TEXT("SaveProfileTo")
#define S_SAVEREGISTRYTO                TEXT("SaveRegistryTo")
#define S_SAVEWINNTSIFTO                TEXT("SaveWinntSifTo")
#define S_SAVENTSETUPDATTO              TEXT("SaveNtSetupDatTo")
#define S_COMPRESSFILES                 TEXT("CompressFiles")
#define S_DEBUG_MIGRATION_DLLS          TEXT("DebugMigrationDlls")
#define S_GOODDRIVE                     TEXT("GOODDRIVE")
#define S_NOFEAR                        TEXT("NOFEAR")
#define S_DOLOG                         TEXT("DOLOG")
#define S_COMPRESSCOMMAND               TEXT("MSTOOLS\\COMPRESS.EXE")
#define S_MEGAGROVEL                    TEXT("MegaGrovel")
#define S_MEGAGROVELFILE                TEXT("setup.pck")
#define S_MEGAGROVELTMP                 TEXT("temp.pck")
#define S_MEGAGROVELTMPCOMPRESSED       TEXT("tempc.pck")
#define S_HARDWARETXT                   TEXT("hardware.txt")
#define S_SOFTWARETXT                   TEXT("software.txt")
#define S_FILELST                       TEXT("allfile.lst")
#define S_DOTDAT                        TEXT(".dat")
#define S_DOTLNK                        TEXT(".lnk")
#define S_PROFILE                       TEXT("profiles")
#define S_DIRRENAMESECT                 TEXT("Profiles.Rename")
#define S_INIFILES_ACTIONS_FIRST        TEXT("INI Files Actions.First")
#define S_INIFILES_ACTIONS_LAST         TEXT("INI Files Actions.Last")
#define S_PROFILES_SF_COLLISIONS        TEXT("Profiles.SFCollisions")

//
// STRING SECTION (sysmig strings)
// Used By: w95upg\sysmig\*.c
//

#define S_WIN9XSIF                   TEXT("win9x.sif")
#define S_UNATTENDED                 TEXT("Unattended")
#define S_FILESYSTEM                 TEXT("FileSystem")
#define S_PROFILEDIR                 TEXT("ProfileDir")
#define S_NOWAITAFTERTEXTMODE        TEXT("NoWaitAfterTextMode")
#define S_NOWAITAFTERGUIMODE         TEXT("NoWaitAfterGuiMode")
#define S_ZERO                       TEXT("0")
#define S_ONE                        TEXT("1")
#define S_TWO                        TEXT("2")
#define S_CONFIRMHARDWARE            TEXT("ConfirmHardware")
#define S_REQUIRED                   TEXT("Required")
#define S_YES                        TEXT("Yes")
#define S_NO                         TEXT("No")
#define S_AUTO                       TEXT("Auto")
#define S_TRUE                       TEXT("True")
#define S_STR_FALSE                  TEXT("False")
#define S_ALL                        TEXT("ALL")
#define S_ENABLED                    TEXT("Enabled")
#define S_DHCP                       TEXT("DHCP")
#define S_KEYBOARDLAYOUT             TEXT("KeyboardLayout")
#define S_KEYBOARDHARDWARE           TEXT("KeyboardHardware")
#define S_QUOTEDKEYBOARDLAYOUT       TEXT("\"Keyboard Layout\"")

#define S_GUIUNATTENDED              TEXT("GuiUnattended")
#define S_TIMEZONE                   TEXT("TimeZone")
#define S_SERVERTYPE                 TEXT("AdvServerType")
#define S_STANDALONE                 TEXT("SERVERNT")
#define S_INDEX                      TEXT("Index")

#define S_USERDATA                   TEXT("UserData")
#define S_FULLNAME                   TEXT("FullName")
#define S_ORGNAME                    TEXT("OrgName")
#define S_COMPUTERNAME               TEXT("ComputerName")

#define S_DISPLAY                    TEXT("Display")
#define S_AUTOCONFIRM                TEXT("AutoConfirm")
#define S_BITSPERPEL                 TEXT("BitsPerPel")
#define S_XRESOLUTION                TEXT("Xresolution")
#define S_YRESOLUTION                TEXT("Yresolution")
#define S_VREFRESH                   TEXT("VRefresh")

#define S_NETWORK                    TEXT("Network")
#define S_JOINWORKGROUP              TEXT("JoinWorkgroup")
#define S_JOINDOMAIN                 TEXT("JoinDomain")
#define S_USERDOMAIN                 TEXT("UserDomain")
#define S_DETECTADAPTERS             TEXT("DetectAdapters")
#define S_INSTALLPROTOCOLS           TEXT("InstallProtocols")
#define S_INSTALLSERVICES            TEXT("InstallServices")
#define S_ONLYONERROR                TEXT("OnlyOnError")

#define S_ENABLE_BACKUP              TEXT("EnableBackup")
#define S_PATH_FOR_BACKUP            TEXT("PathForBackup")
#define S_ROLLBACK_MK_DIRS           TEXT("RollbackMkDirs")
#define S_UNINSTALL_TEMP_DIR         TEXT("uninstall")
#define S_ROLLBACK_MOVED_TXT         TEXT("moved.txt")
#define S_ROLLBACK_DELFILES_TXT      TEXT("delfiles.txt")
#define S_ROLLBACK_DELDIRS_TXT       TEXT("deldirs.txt")
#define S_ROLLBACK_MKDIRS_TXT        TEXT("mkdirs.txt")
#define S_UNINSTALL_DISP_STR         TEXT("ProgressText")

#define S_DETECTADAPTERS             TEXT("DetectAdapters")
#define S_DETECTCOUNT                TEXT("DetectCount")

#define S_PROTOCOLS                  TEXT("Protocols")
#define S_NBF                        TEXT("NBF")
#define S_NWLNKIPX                   TEXT("NWLNKIPX")
#define S_TC                         TEXT("TC")

#define S_NETBEUIPARAMETERS          TEXT("NetBeui")
#define S_STUBKEY                    TEXT("NoParamsNeeded")
#define S_STUBVAL                    TEXT("1")

#define S_IPXPARAMETERS              TEXT("IPX")

#define S_TCPIPPARAMETERS            TEXT("TCPIP")
#define S_SCOPEID                    TEXT("ScopeID")
#define S_WINS                       TEXT("WINS")
#define S_IPADDRESS                  TEXT("IPAddress")
#define S_SUBNET                     TEXT("Subnet")
#define S_TCPIP_ADAPTER              TEXT("TCPIP.Adapter")
#define S_IPX_ADAPTER                TEXT("IPC.Adapter")
#define S_SPECIFICTO                 TEXT("SpecificTo")
#define S_ADAPTERSECTIONS            TEXT("AdapterSections")
#define S_DEFAULTGATEWAY             TEXT("DefaultGateway")
#define S_DNSSERVER                  TEXT("DNSServer")
#define S_WINSPRIMARY                TEXT("WINSPrimary")
#define S_WINSSECONDARY              TEXT("WINSSecondary")
#define S_WINSSERVERLIST             TEXT("WinsServerList")
#define S_DNSNAME                    TEXT("DNSName")
#define S_DNSHOSTNAME                TEXT("DNSHostName")
#define S_SEARCHLIST                 TEXT("SearchList")
#define S_LMHOSTS                    TEXT("LMHostFile")
#define S_PKTTYPE                    TEXT("PktType")
#define S_NETWORKNUMBER              TEXT("NetworkNumber")
#define S_NETWORK_ID                 TEXT("Network_Id")
#define S_NETBIOSOPTION              TEXT("NetBiosOption")

//--------------------------------------------------------------
//Those strings are used in winntsif.c to upgrade ICS settings
#define S_ICSHARE                       TEXT("ICSHARE")
#define S_HOMENET                       TEXT("Homenet")
#define S_ICS_KEY                       TEXT("HKLM\\System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General")
#define S_INET_SETTINGS                 TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define S_NET_DRIVER_KEY                TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Net")
#define S_REMOTEACCESS_KEY              TEXT("HKEY_CURRENT_USER\\RemoteAccess")
#define S_RAS_DEFAULT                   TEXT("Default")
#define S_EXTERNAL_ADAPTER              TEXT("ExternalAdapter")
#define S_EXTERNAL_CONNECTION_NAME      TEXT("ExternalConnectionName")
#define S_INTERNAL_IS_BRIDGE            TEXT("InternalIsBridge")
#define S_INTERNAL_ADAPTER              TEXT("InternalAdapter")
#define S_INTERNAL_ADAPTER2             TEXT("InternalAdapter2")
#define S_BRIDGE                        TEXT("Bridge")
#define S_ENABLE_AUTODIAL               TEXT("EnableAutodial")
#define S_DIAL_ON_DEMAND                TEXT("DialOnDemand")
#define S_ENABLEICS                     TEXT("EnableICS")
#define S_SHOW_TRAY_ICON                TEXT("ShowTrayIcon")
#define S_ISW9XUPGRADE                  TEXT("IsW9xUpgrade")
#define S_NET_PREFIX                    TEXT("Net\\")
//---------------------------------------------------------------

#define S_DEVICE_DRIVERS                TEXT("DeviceDrivers")
#define S_MODEM                         TEXT("Modem")
#define S_MODEMMODEL                    TEXT("Model")
#define S_COM                           TEXT("COM")
#define S_NICIDMAP                      TEXT("NIC ID Map")
#define S_MODEM_UI_OPTIONS              TEXT("__UiOptions")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_MODEM_SPEED                   TEXT("__Speed")
#define S_MODEM_SPEAKER_VOLUME          TEXT("__SpeakerVolume")
#define S_MODEM_IDLE_DISCONNECT_SECONDS TEXT("__IdleDisconnect")
#define S_MODEM_CANCEL_SECONDS          TEXT("__CancelSeconds")
#define S_MODEM_CFG_OPTIONS             TEXT("__CfgOptions")
#define S_DEVICECOUNT                   TEXT("__DeviceCount")
#define S_SERVICESSECTION               TEXT("Services")
#define S_RAS                           TEXT("RAS")
#define S_MSRASCLI                      TEXT("MS_RasCli")
#define S_PARAMSSECTION                 TEXT("ParamsSection")
#define S_PARAMSRASCLI                  TEXT("Params.RasCli")
#define S_PORTSECTIONS                  TEXT("PortSections")
#define S_DIALOUTPROTOCOLS              TEXT("DialoutProtocols")
#define S_PORTNAME                      TEXT("PortName")
#define S_DEVICETYPE                    TEXT("DeviceType")
#define S_PORTUSAGE                     TEXT("PortUsage")
#define S_DIALINOUT                     TEXT("DialInOut")
#define S_DIALOUT                       TEXT("DialOut")
#define S_INSTALLMODEM                  TEXT("InstallModem")

#define S_MERGE_FORCECOPY            TEXT("Force Win9x Settings")
#define S_MERGE_RENAME               TEXT("Map Win9x to WinNT")
#define S_MERGE_WIN9X_CONVERSION     TEXT("Win9x Data Conversion")
#define S_MERGE_WINNT_CONVERSION     TEXT("WinNT Data Conversion")
#define S_MERGE_WIN9X_SUPPRESS       TEXT("Suppress Win9x Settings")
#define S_MERGE_WIN9X_SUPPRESS_DU    TEXT("Suppress Win9x Settings.Default User")
#define S_MERGE_WIN9X_SUPPRESS_LU    TEXT("Suppress Win9x Settings.Logon Account")
#define S_MERGE_WIN9X_SUPPRESS_HW    TEXT("Suppress Win9x Hardware Profile")
#define S_MERGE_WIN9X_SUPPRESS_SFT_D TEXT("Default Software Keys Of Win9x Hardware Profile")

#define S_MERGE_WINNT_SUPPRESS       TEXT("Suppress WinNT Settings")
#define S_MERGE_DONT_COMBINE_WITH_DEFAULT TEXT("Dont Merge WinNT with Win9x")
#define S_MERGE_FORCE_NT_DEFAULTS    TEXT("Force WinNT Settings")
#define S_MIGRATION_INF_CLASS        TEXT("Migration")
#define S_MERGE_HKCC_SUPPRESS        TEXT("Suppress HKCC Settings")
#define S_WKSTAMIG_REDIR_MAPPING     TEXT("Redirector Name Mapping")
#define S_WKSTAMIG_HIVE_FILES        TEXT("HiveFilesToConvert")

#define S_WIN95_DIRECTORIES          TEXT("Win95.Directories")
#define S_WIN95_INSTALL              TEXT("Win95.Install")
#define S_MEMDB_TEMP_RUNTIME_DLLS    TEXT("Temp: Runtime Dlls")

#define S_SYSTEM32                   TEXT("system32")
#define S_CTL3D32DLL                 TEXT("ctl3d32.dll")
#define S_MOVEBEFOREMIGRATION        TEXT("Files.MoveBeforeMigration")
#define S_DELETEBEFOREMIGRATION      TEXT("Files.DeleteBeforeMigration")
#define S_INF                        TEXT("inf")
#define S_WINDOWS_CURRENTVERSION     TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion")
#define S_USER_LIST_KEY              TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg\\Users")
#define S_WINLOGON_USER_LIST_KEY     TEXT("HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon\\LocalUsers")
#define S_WIN9XUPG_KEY               TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg")
#define S_USERS_SUBKEY               TEXT("Users")
#define S_CURRENT_USER_VALUENAME     TEXT("CurrentUser")
#define S_RUN_KEY                    TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCE_KEY                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_AUTOSTRESS_KEY             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\Win9xUpg\\AutoStress")
#define S_REG_SHARED_DLLS            TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs")
#define S_DEVICEPATH                 TEXT("DevicePath")
#define S_REGKEY_DARWIN_COMPONENTS   S_WINDOWS_CURRENTVERSION TEXT("\\Installer\\Components")
#define S_REG_KEY_UNDO_PATH          TEXT("Win9xUndoDirPath")
#define S_REG_KEY_UNDO_INTEGRITY     TEXT("Win9xUndoIntegrityInfo")
#define S_REG_KEY_UNDO_APP_LIST      TEXT("PreviousOsAppList")
#define S_REGKEY_WIN_SETUP           TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup")
#define S_AUTOSTRESS_USER            TEXT("User")
#define S_AUTOSTRESS_PASSWORD        TEXT("Password")
#define S_AUTOSTRESS_OFFICE          TEXT("Office")
#define S_AUTOSTRESS_DBG             TEXT("DbgMachine")
#define S_AUTOSTRESS_FLAGS           TEXT("Flags")

#define S_NETWORKING                 TEXT("Networking")
#define S_PROCESSPAGESECTIONS        TEXT("ProcessPageSections")
#define S_DIALUP_ADAPTER_DESC        TEXT("Dial-Up Adapter")
#define S_DIALUP_PNP                 TEXT("*PNP8387")
#define S_NETWORK_BRANCH             TEXT("HKLM\\Enum\\Network")
#define S_BINDINGS                   TEXT("Bindings")

#define S_PAGE_IDENTIFICATION        TEXT("Identification")
#define S_DOMAIN_ACCT_CREATE         TEXT("CreateComputerAccountInDomain")
#define S_DOMAIN_ADMIN               TEXT("DomainAdmin")
#define S_DOMAIN_ADMIN_PW            TEXT("DomainAdminPassword")
#define S_ENCRYPTED_DOMAIN_ADMIN_PW  TEXT("EncryptedDomainAdminPassword")
#define S_COMPUTERNAME               TEXT("ComputerName")
#define S_MODEM_COM_PORT             TEXT("ComPort")
#define S_BUILDNUMBER                TEXT("BuildNumber")

#define S_SVRAPI_DLL                 TEXT("svrapi.dll")
#define S_ANSI_NETSHAREENUM          "NetShareEnum"
#define S_ANSI_NETACCESSENUM         "NetAccessEnum"

#define S_SHELL_FOLDERS_KEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_USER_SHELL_FOLDERS_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_SYSTEM_STARTUP             TEXT("Common Startup")
#define S_USER_STARTUP               TEXT("Startup")
#define S_SENDTO                     TEXT("SendTo")
#define S_SENDTO_SUPPRESS            TEXT("SendTo.SuppressFiles")
#define S_ADDREG                     TEXT("AddReg")
#define S_SHELL_FOLDERS_KEY_SYSTEM   TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_SHELL_FOLDERS_KEY_USER     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define S_USHELL_FOLDERS_KEY_SYSTEM  TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_USHELL_FOLDERS_KEY_USER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")
#define S_HIVEDEF_INF                TEXT("HIVEDEF.INF")
#define S_HIVESFT_INF                TEXT("HIVESFT.INF")
#define S_HIVESYS_INF                TEXT("HIVESYS.INF")
#define S_TXTSETUP_SIF               TEXT("TXTSETUP.SIF")
#define S_HDC                        TEXT("HDC")
#define S_REGISTEREDOWNER            TEXT("RegisteredOwner")
#define S_REGISTEREDORGANIZATION     TEXT("RegisteredOrganization")
#define S_DISPLAYSETTINGS            TEXT("HKCC\\Display\\Settings")
#define S_BITSPERPIXEL               TEXT("BitsPerPixel")
#define S_RESOLUTION                 TEXT("Resolution")
#define S_FRAME_TYPE                 TEXT("frame_type")
#define S_PKTTYPE                    TEXT("PktType")
#define S_IPX_SUFFIX                 TEXT(".ipx")
#define S_TCPIP_SUFFIX               TEXT(".tcpip")
#define S_STD                        TEXT("std")
#define S_DLT                        TEXT("dlt")

#define S_VIRTUAL_FILES              TEXT("Win95.VirtualFiles")


//
// UI
//

#define S_TEXTVIEW_CLASS                TEXT("TextView")


//
// Registry value names
//

#define S_DRIVERVAL                  TEXT("Driver")
#define S_IPADDRVAL                  TEXT("IPAddress")
#define S_SUBNETVAL                  TEXT("IPMask")
#define S_DEFGATEWAYVAL              TEXT("DefaultGateway")
#define S_HOSTNAMEVAL                TEXT("HostName")
#define S_NAMESERVERVAL              TEXT("NameServer")
#define S_NAMESERVER1VAL             TEXT("NameServer1")
#define S_NAMESERVER2VAL             TEXT("NameServer2")
#define S_DOMAINVAL                  TEXT("Domain")
#define S_DAYLIGHTNAME               TEXT("DaylightName")
#define S_STANDARDNAME               TEXT("StandardName")
#define S_DAYLIGHTFLAG               TEXT("DaylightFlag")
#define S_ORDER                      TEXT("Order")

//
// Registry key locations and value names
//

#define S_KEYBOARDLAYOUTNUM          TEXT("HKCU\\keyboard layout\\preload\\1")
#define S_TIMEZONEINFORMATION        TEXT("HKLM\\System\\CurrentControlSet\\control\\TimeZoneInformation")
#define S_TIMEZONES                  TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Time Zones")
#define S_NETWORKMSTCP               TEXT("HKLM\\Enum\\Network\\MSTCP")
#define S_MSTCP_KEY                  TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\MSTCP")
#define S_SERVICECLASS               TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class")
#define S_SERVICEREMOTEACCESS        TEXT("HKLM\\System\\CurrentControlSet\\Services\\RemoteAccess")
#define S_MODEMS                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class\\Modem")
#define S_PERSISTENT_CONNECTIONS     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections")
#define S_SAGE                       TEXT("HKLM\\SOFTWARE\\Microsoft\\Plus!\\System Agent\\SAGE")
#define S_SAGE_FRIENDLY_NAME         TEXT("Friendly Name")
#define S_SAGE_PROGRAM               TEXT("Program")
#define S_SHELL_ICONS_REG_KEY        TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Shell Icons")
#define S_MIGRATION                  TEXT("Migration")
#define S_SOFTWARE                   TEXT("\\Software")



//
// STRING SECTION (NT 5 network unattend strings)
// Used By: unattend.c
//

#define S_PAGE_NETADAPTERS              TEXT("NetAdapters")
#define S_DETECT                        TEXT("Detect")
#define S_BUSTYPE                       TEXT("BusType")
#define S_IOADDR                        TEXT("IoAddr")
#define S_IRQ                           TEXT("IRQ")
#define S_DMA                           TEXT("DMA")
#define S_MEM                           TEXT("MEM")
#define S_TRANSCIEVERTYPE               TEXT("TranscieverType")
#define S_IOCHANNELREADY                TEXT("IoChannelReady")

#define S_PREFERREDSERVER               TEXT("PreferredServer")
#define S_AUTHENTICATINGAGENT           TEXT("AuthenticatingAgent")
#define S_AUTHAGENTREG                  TEXT("HKLM\\System\\CurrentControlSet\\Services\\NWNP32\\NetworkProvider")
#define S_NWREDIRREG                    TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\NWReDir")
#define S_NETWORKLOGON                  TEXT("HKLM\\Network\\Logon")
#define S_PROCESSLOGINSCRIPT            TEXT("ProcessLoginScript")
#define S_LOGONSCRIPT                   TEXT("LogonScript")
#define S_DEFAULTCONTEXT                TEXT("DefaultContext")
#define S_DEFAULTTREE                   TEXT("DefaultTree")
#define S_DEFAULTNAMECONTEXT            TEXT("DefaultNameContext")
#define S_PREFERREDTREE                 TEXT("PreferredTree")
#define S_PREFERREDNDSTREE              TEXT("PreferredNDSTree")
#define S_FIRSTNETWORKDRIVE             TEXT("FirstNetworkDrive")
#define S_PRESERVECASE                  TEXT("PreserveCase")
#define S_MS_NWLINK                     TEXT("MS_NWLINK")


#define S_NETBEUI                       TEXT("NETBEUI")
#define S_MSDLC                         TEXT("MSDLC")
#define S_MSDLC32                       TEXT("MSDLC32")
#define S_MSTCP                         TEXT("MSTCP")
#define S_NWLINK                        TEXT("NWLINK")
#define S_NWLINKREG                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\VxD\\NWLink")
#define S_CACHESIZE                     TEXT("cachesize")
#define S_NWREDIR                       TEXT("NWREDIR")
#define S_VREDIR                        TEXT("VREDIR")
#define S_VSERVER                       TEXT("VSERVER")
#define S_BROWSER                       TEXT("Browser")
#define S_SERVICESTARTTYPES             TEXT("ServiceStartTypes")
#define S_MS_TCPIP                      TEXT("MS_TCPIP")
#define S_MS_NWIPX                      TEXT("MS_NWIPX")
#define S_MS_DLC                        TEXT("MS_DLC")
#define S_MS_NETBEUI                    TEXT("MS_NETBEUI")
#define S_PAGE_NETPROTOCOLS             TEXT("NetProtocols")
#define S_NETBINDINGS                   TEXT("NetBindings")
#define S_DISABLED                      TEXT("Disable")
#define S_SUBNETMASK                    TEXT("SubnetMask")
#define S_DNSSERVERSEARCHORDER          TEXT("DNSServerSearchOrder")
#define S_DNSSUFFIXSEARCHORDER          TEXT("DNSSuffixSearchOrder")
#define S_DNS                           TEXT("DNS")
#define S_DNSHOST                       TEXT("DNSHostName")
#define S_DNSDOMAIN                     TEXT("DNSDomain")
#define S_IMPORTLMHOSTSFILE             TEXT("ImportLMHostsFile")
#define S_PAGE_NETSERVICES              TEXT("NetServices")
#define S_MS_NETCLIENT                  TEXT("MS_MSClient")
#define S_PAGE_NETCLIENTS               TEXT("NetClients")
#define S_MS_RASCLI                     TEXT("MS_RasCli")
#define S_CLIENT                        TEXT("Client")
#define S_MS_NETBT                      TEXT("MS_NetBT")
#define S_MS_SERVER                     TEXT("MS_Server")
#define S_MS_NWCLIENT                   TEXT("MS_NWClient")
#define S_ENUM_NETWORK_KEY              TEXT("HKLM\\Enum\\Network")
#define S_MS_NBT                        TEXT("MS_NBT")
#define S_UPGRADEFROMPRODUCT            TEXT("UpgradeFromProduct")
#define S_WINDOWS95                     TEXT("Windows95")
#define S_SOURCEROUTING                 TEXT("SourceRouting")
#define S_INFID                         TEXT("InfID")
#define S_DISPLAY_SETTINGS              TEXT("HKCC\\Display\\Settings")
#define S_BITSPERPIXEL                  TEXT("BitsPerPixel")
#define S_RESOLUTION                    TEXT("Resolution")
#define S_ENABLEDNS                     TEXT("EnableDns")
#define S_SCOPEID                       TEXT("ScopeID")
#define S_NODEVAL                       TEXT("NodeType")
#define S_SNMP                          TEXT("SNMP")
#define S_UPNP                          TEXT("UPNP")
#define S_REGKEY_UPNP                   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UPnP")
#define S_NETOPTIONALCOMPONENTS         TEXT("NetOptionalComponents")




//
// Win95upg.inf sections
//

#define S_TIMEZONEMAPPINGS                  TEXT("TimeZoneMappings")
#define S_CONDITIONAL_INCOMPATIBILITIES     TEXT("Conditional Incompatibilities")
#define S_SUPPORTED_PROTOCOLS               TEXT("Supported Protocols")
#define S_SUPPORTED_PASSWORD_PROVIDERS      TEXT("Supported Password Providers")
#define S_SAGE_EXCLUSIONS                   TEXT("Standard System Agents")
#define S_SHELL_FOLDERS_PRESERVED           TEXT("ShellFolders.Preserved")
#define S_SHELL_FOLDERS_SKIPPED             TEXT("ShellFolders.Skipped")
#define S_SHELL_FOLDERS_DEFAULT             TEXT("ShellFolders.Default")
#define S_SHELL_FOLDERS_ALT_DEFAULT         TEXT("ShellFolders.AlternateDefault")
#define S_SHELL_FOLDERS_PERUSER_TO_COMMON   TEXT("ShellFolders.PerUserToCommon")
#define S_SHELL_FOLDERS_NTINSTALLED_USER    TEXT("ShellFolders.NtInstalled_User")
#define S_SHELL_FOLDERS_NTINSTALLED_COMMON  TEXT("ShellFolders.NtInstalled_Common")
#define S_SHELL_FOLDERS_MASSIVE             TEXT("ShellFolders.DontMove")
#define S_SHELL_FOLDERS_DONT_COLLAPSE       TEXT("ShellFolders.KeepPerUser")
#define S_SHELL_FOLDERS_SHORT               TEXT("ShellFolders.ShortNames")
#define S_SHELL_FOLDERS_RENAMED             TEXT("ShellFolders.Renamed")
#define S_SHELL_FOLDERS_DISK_SPACE          TEXT("ShellFolders.SpaceRequirements")
#define S_VIRTUAL_SF                        TEXT("ShellFolders.VirtualSF")
#define S_ONE_USER_SHELL_FOLDERS            TEXT("ShellFolders.ForcePerUser")
#define S_SHELL_FOLDER_PRIORITY             TEXT("ShellFolders.Priority")
#define S_FILES_TO_REMOVE                   TEXT("Delete Files")
#define S_MOVED_ICONS                       TEXT("Moved Icons")
#define S_SUPPRESSED_GUIDS                  TEXT("Suppressed GUIDs")
#define S_FORCED_GUIDS                      TEXT("Forced GUIDs")
#define S_ANSWER_FILE_DETECTION             TEXT("Answer File Detection")
#define S_KNOWN_GOOD_ICON_MODULES           TEXT("Compatible Icon Indexes")
#define S_SHELLFOLDERSMIGRATIONDIRS         TEXT("ShellFolders.MigrationDirs")
#define S_APPROVED_GUID_LAUNCHER            TEXT("ApprovedGUIDLauncher")
#define S_STRINGMAP                         TEXT("String Map")
#define S_UNINSTALL_DISKSPACEESTIMATION     TEXT("Uninstall.DiskSpaceEstimation")

//
// STRING SECTION (Hardware Strings)
// Used By: hwcomp.c, online.c, hwdisk.c
//

#define S_ISA       TEXT("ISA")
#define S_EISA      TEXT("EISA")
#define S_MCA       TEXT("MCA")
#define S_PCI       TEXT("PCI")
#define S_PNPISA    TEXT("PNPISA")
#define S_PCMCIA    TEXT("PCMCIA")
#define S_ROOT      TEXT("ROOT")

#define S_NET       TEXT("net")
#define S_IOADDR    TEXT("IoAddr")
#define S_IRQ       TEXT("IRQ")
#define S_DMA       TEXT("DMA")
#define S_MEMRANGE  TEXT("Memory")

#define S_LAYOUT_INF TEXT("layout.inf")

#define S_IGNORE_REG_KEY    TEXT("Ignore PNP Key")

#define S_FORCEDCONFIG      TEXT("ForcedConfig")
#define S_BOOTCONFIG        TEXT("BootConfig")
#define S_ALLOCATION        TEXT("Allocation")

#define S_CONFIG_MANAGER        TEXT("Config Manager\\Enum")
#define S_HARDWAREKEY_VALUENAME TEXT("HardWareKey")
#define S_ENUM_BRANCH           TEXT("Enum")
#define S_CLASS_VALUENAME       TEXT("Class")

#define S_KEYBOARD_CLASS        TEXT("keyboard")
#define S_KEYBOARD_IN_          TEXT("keyboard.in_")
#define S_KEYBOARD_INF          TEXT("keyboard.inf")
#define S_LEGACY_XLATE_DEVID    TEXT("LegacyXlate.DevId")

#define S_MANUFACTURER              TEXT("Manufacturer")
#define S_DOLLAR_WINDOWS_NT_DOLLAR  TEXT("$WINDOWS NT$")
#define S_VERSION                   TEXT("Version")
#define S_SIGNATURE                 TEXT("Signature")
#define S_COPYFILES                 TEXT("CopyFiles")
#define S_CATALOGFILE               TEXT("CatalogFile")
#define S_SOURCEDISKSFILES          TEXT("SourceDisksFiles")
#define S_LAYOUTFILES               TEXT("LayoutFiles")

//
// STRING SECTION (Drive Letter preservation strings)
// Used By: drvlettr.c
//

#define S_CLASS                     TEXT("Class")
#define S_CDROM                     TEXT("CDROM")
#define S_SCSITARGETID              TEXT("SCSITargetId")
#define S_SCSILUN                   TEXT("SCSILUN")
#define S_CURRENTDRIVELETTER        TEXT("CurrentDriveLetterAssignment")
#define S_ENUMSCSI                  TEXT("Enum\\SCSI")


//
// STRING SECTION (migmain strings)
// Used By: w95upgnt\migmain\filemig.c, w95upgnt\migmain\migmain.c, w95upgnt\migmain\iniact.c
//
#define S_DEFAULTUSER               TEXT(".default")
#define S_PROFILES                  TEXT("Profiles")
#define S_SETUP                     TEXT("setup")
#define S_EMPTY                     TEXT("")
#define S_WINLOGON_KEY                      TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_INIFILEMAPPING_KEY                TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping")
#define S_SUPPRESS_INI_FILE_MAPPINGS        TEXT("INI File Mapping.Suppress")
#define S_NO_OVERWRITE_INI_FILE_MAPPINGS    TEXT("INI File Mapping.Preserve Fresh Install")
#define S_MOVEINISETTINGS           TEXT("MoveIniSettings")
#define S_SHELL_KEY                 TEXT("SYSTEM.INI\\BOOT\\SHELL")
#define S_SF_PROFILES               TEXT("Profiles")
#define S_SF_COMMON_PROFILES        TEXT("Common Profiles")
#define S_SHELLEXT_APPROVED         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define S_DEFAULT                   TEXT("Default")


//
// STRING SECTION (migmain strings)
// Used By: w95upgnt\migmain\acctlist.c
//
#define S_UNKNOWN_DOMAIN            TEXT("\\unknown")
#define S_FAILED_DOMAIN             TEXT("\\failed")
#define S_LOCAL_DOMAIN              TEXT("\\local")

//
// STRING SECTION (Dos Migration strings)
// Used By: dosmig95.c dosmignt.c
//

#define S_CONSOLEKEY                    TEXT("console")
#define S_INSERTMODEVALUE               TEXT("insertmode")
#define S_ENVIRONMENTKEY                TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define S_WINLOGONKEY                   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define S_AUTOPARSEVALUE                TEXT("ParseAutoexec")
#define S_COMSPEC_PATTERN               TEXT("comspec*")

//
// STRING SECTION (Hardware Profile Registry Strings)
// Used By: w95upgnt\merge
//

#define S_HW_ID_0001                    TEXT("0001")
#define S_HW_DEFAULT                    TEXT("Default")
#define S_TREE                          TEXT("\\*")

#define S_BASE_IDCONFIGDB_KEY           TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_IDCONFIGDB_HW_KEY             S_BASE_IDCONFIGDB_KEY TEXT("\\Hardware Profiles")
#define S_NT_HW_ID_MASK                 S_IDCONFIGDB_HW_KEY TEXT("\\%04u")
#define S_CURRENT_CONFIG                S_BASE_IDCONFIGDB_KEY TEXT("\\[CurrentConfig]")

#define S_9X_CONFIG_KEY                 TEXT("HKLM\\Config")
#define S_9X_CONFIG_MASK                S_9X_CONFIG_KEY TEXT("\\%04u")
#define S_NT_CONFIG_KEY                 TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles")
#define S_NT_CONFIG_MASK                S_NT_CONFIG_KEY TEXT("\\%04u")

#define S_NT_DEFAULT_HW_ID_KEY          S_IDCONFIGDB_HW_KEY TEXT("\\") S_HW_DEFAULT
#define S_NT_DEFAULT_HW_KEY             S_NT_CONFIG_KEY TEXT("\\") S_HW_DEFAULT

#define S_FRIENDLYNAME                  TEXT("FriendlyName")
#define S_PREFERENCEORDER               TEXT("PreferenceOrder")


#define S_NT_HARDWARE_PROFILE_SPRINTF   TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles\\%04u\\*")
#define S_9X_HARDWARE_PROFILE_NAMES     TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_NT_HARDWARE_PROFILE_TREE      TEXT("HKLM\\System\\CurrentControlSet\\Hardware Profiles\\*")
#define S_NT_HWPROFILE_NAME_REGVAL      TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\%04u\\[FriendlyName]")
#define S_NT_HWPROFILE_NAME_REGKEY      TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\%04u\\*")
#define S_NT_HWPROFILE_NAME_ENUM        TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Control\\IDConfigDB\\Hardware Profiles\\*")


//
// Conditional messages section (of sysmig)
//

#define S_NET_FILTER                    TEXT("Net")
#define S_HARDWAREID_VALUENAME          TEXT("HardwareID")
#define S_PNP8387                       TEXT("*PNP8387")
#define S_HKCUEUDC                      TEXT("HKLM\\System\\CurrentControlSet\\Control\\NLS\\CodePage\\EUDCCodeRange")
#define S_HKLMEUDC                      TEXT("HKCU\\EUDC")
#define S_PASSWORDPROVIDER              TEXT("HKLM\\System\\CurrentControlSet\\Control\\PwdProvider")
#define S_PASSWORDPROVIDER_DESCRIPTION  TEXT("Description")
#define S_CONFIG_KEY                    TEXT("HKLM\\Config")
#define S_ENUM_SUBKEY                   TEXT("Enum")
#define S_FRIENDLYNAME_SPRINTF          TEXT("FriendlyName%04u")
#define S_FRIENDLYNAME_KEY              TEXT("HKLM\\System\\CurrentControlSet\\Control\\IDConfigDB")
#define S_DRIVER                        TEXT("Driver")
#define S_CLASS_KEY                     TEXT("HKLM\\System\\CurrentControlSet\\Services\\Class")
#define S_DRIVERDESC                    TEXT("DriverDesc")
#define S_MFG                           TEXT("Mfg")
#define S_ATTACHEDTO                    TEXT("AttachedTo")
#define S_MODEL                         TEXT("Model")
#define S_PARENTDEVNODE                 TEXT("ParentDevNode")
#define S_ENUM                          TEXT("HKLM\\Enum")

//
// Common strings
//

#define S_DEVICE                  TEXT("Device")
#define S_DEVICEHIGH              TEXT("DeviceHigh")
#define S_INSTALL                 TEXT("Install")
#define S_MENU                    TEXT("MENU")
#define S_DOSCOMPINFNAME          TEXT("doscomp.inf")
#define S_DOSMIGBADBLOCK          TEXT("Incompatible")
#define S_DOSMIGUSEBLOCK          TEXT("Use")
#define S_DOSMIGIGNOREBLOCK       TEXT("Ignore")
#define S_DOSMIGCONDITIONALBLOCK  TEXT("Conditional Compatibility")
#define S_ENVVARS                 TEXT("@@ENVVARS@@")
#define S_SUPPRESSED_ENV_VARS     TEXT("SuppressedEnvSettings")

#define S_DOSMIGBAD               TEXT("incompatible")
#define S_DOSMIGRULEFILESIZE      TEXT("filesize")
#define S_DOSMIGRULEFILEDATE      TEXT("filedate")
#define S_DOSMIGRULECOMMANDLINE   TEXT("commandline")
#define S_DOSMIGIGNORE            TEXT("ignoreable")
#define S_DOSMIGUSE               TEXT("use")
#define S_DOSMIGMIGRATE           TEXT("migrate")
#define S_DOSMIGUNKNOWN           TEXT("unknown")
#define S_CONFIGSYSPATH           TEXT("c:\\config.sys")
#define S_AUTOEXECPATH            TEXT("c:\\autoexec.bat")
#define S_CONFIGSYS               TEXT("config.sys")
#define S_AUTOEXECBAT             TEXT("autoexec.bat")
#define S_DOSMIGRULEFILESPEC      TEXT("filespec")
#define S_DOSMIGCOMPATIBILITY     TEXT("compatibility")
#define S_PROMPT                  TEXT("PROMPT")
#define S_COMPATIBLE              TEXT("COMPATIBLE")
#define S_MIGRATION_DIRS          TEXT("MigrationDirs")
#define S_OEM_MIGRATION_DIRS      TEXT("OemMigrationDirs")
#define S_OBSOLETE_LINKS          TEXT("ObsoleteLinks")
#define S_KNOWN_NT_LINKS          TEXT("KnownNTLinks")
#define S_UPGINFSDIR              TEXT("UpgInfs")
#define S_TARGETINF               TEXT("TargetInf")
#define S_LANGUAGE                TEXT("Language")
#define S_LANGUAGEGROUP           TEXT("LanguageGroup")
#define S_SYSTEMLOCALEREG         TEXT("HKLM\\System\\CurrentControlSet\\control\\Nls\\Locale")
#define S_LOCALES                 TEXT("Locales")
#define S_LANGUAGEGROUPS          TEXT("LanguageGroups")
#define S_INTLINF                 TEXT("Intl.Inf")
#define S_IGNORED_COLLISIONS      TEXT("IgnoredCollisions")
#define S_BACKUPFILESIGNORE       TEXT("BackupFiles.IgnoreInReport")


//
// STRING SECTION (RAS strings)
// Used By: ras.c
//
#define S_DBG_RAS                      "Ras Migrate"
#define S_DUN_ENTRY_SECTION            TEXT("Entry")
#define S_DUN_ENTRYNAME                TEXT("Entry_Name")
#define S_DUN_MULTILINK                TEXT("MultiLink")
#define S_DUN_TCPIP_SECTION            TEXT("TCP/IP")
#define S_DUN_IP_ADDRESS               TEXT("IP_Address")
#define S_DUN_DNS_ADDRESS              TEXT("DNS_Address")
#define S_DUN_DNS_ALT_ADDRESS          TEXT("DNS_Alt_Address")
#define S_DUN_WINS_ADDRESS             TEXT("Wins_Address")
#define S_DUN_WINS_ALT_ADDRESS         TEXT("Wins_Alt_Address")
#define S_DUN_IP_HEADER_COMPRESS       TEXT("Ip_Header_Compress")
#define S_DUN_GATEWAY_ON_REMOTE        TEXT("Gateway_On_Remote")
#define S_DUN_SPECIFY_IP_ADDRESS       TEXT("Specify_Ip_Address")
#define S_DUN_SPECIFY_SERVER_ADDRESS   TEXT("Specify_Ip_Address")
#define S_DUN_SERVER_SECTION           TEXT("Server")
#define S_DUN_TYPE                     TEXT("Type")
#define S_DUN_SW_COMPRESS              TEXT("Sw_Compress")
#define S_DUN_PW_ENCRYPT               TEXT("Pw_Encrypt")
#define S_DUN_NETWORK_LOGIN            TEXT("Network_Login")
#define S_DUN_SW_ENCRYPT               TEXT("Sw_Encrypt")
#define S_DUN_NETBEUI                  TEXT("Negotiable_NetBeui")
#define S_DUN_IPXSPX                   TEXT("Negotiable_Ipx/Spx")
#define S_DUN_TCPIP                    TEXT("Negotiable_Tcp/Ip")
#define S_DUN_SCRIPTFILE_SECTION       TEXT("Script_File")
#define S_DUN_NAME                     TEXT("Name")
#define S_DUN_PHONE_SECTION            TEXT("Phone")
#define S_DUN_PHONE_NUMBER             TEXT("Phone_Number")
#define S_DUN_AREA_CODE                TEXT("Area_Code")
#define S_DUN_COUNTRY_CODE             TEXT("Country_Code")
#define S_DUN_COUNTRY_ID               TEXT("Country_Id")
#define S_AE_PHONE                     TEXT("PhoneNumber")
#define S_AE_AREACODE                  TEXT("AreaCode")
#define S_AE_COUNTRYCODE               TEXT("CountryCode")
#define S_AE_COUNTRYID                 TEXT("CountryID")
#define S_IP_FTCPIP                    TEXT("_IP_FTCPIP")
#define S_IP_IPADDR                    TEXT("IpAddress")
#define S_IP_DNSADDR                   TEXT("IpDnsAddress")
#define S_IP_DNSADDR2                  TEXT("IpDns2Address")
#define S_IP_WINSADDR                  TEXT("IpWinsAddress")
#define S_IP_WINSADDR2                 TEXT("IpWins2Address")
#define S_DOMAIN                       TEXT("Domain")
#define S_CALLBACK                     TEXT("Number"))
#define S_PBE_DESCRIPTION              TEXT("Description")
#define S_PBE_AREACODE                 TEXT("AreaCode")
#define S_PBE_COUNTRYID                TEXT("CountryID")
#define S_PBE_COUNTRYCODE              TEXT("CountryCode")
#define S_PBE_USECOUNTRYANDAREACODES   TEXT("UseCountryAndAreaCodes")
#define S_PBE_DIALMODE                 TEXT("DialMode")
#define S_PBE_DIALPERCENT              TEXT("DialPercent")
#define S_PBE_DIALSECONDS              TEXT("DialSeconds")
#define S_PBE_HANGUPPERCENT            TEXT("HangUpPercent")
#define S_PBE_HANGUPSECONDS            TEXT("HangUpSeconds")
#define S_PBE_IPPRIORITIZEREMOTE       TEXT("IpPrioritizeRemote")
#define S_PBE_IPHEADERCOMPRESSION      TEXT("IpHeaderCompression")
#define S_PBE_IPADDRESS                TEXT("IpAddress")
#define S_PBE_IPDNSADDRESS             TEXT("IpDnsAddress")
#define S_PBE_IPDNSADDRESS2            TEXT("IpDns2Address")
#define S_PBE_IPWINSADDRESS            TEXT("IpWinsAddress")
#define S_PBE_IPWINSADDRESS2           TEXT("IpWins2Address")
#define S_PBE_IPASSIGN                 TEXT("IpAssign")
#define S_PBE_IPNAMEASSIGN             TEXT("IpNameAssign")
#define S_PBE_IPFRAMESIZE              TEXT("IpFrameSize")
#define S_PBE_AUTHRESTRICTIONS         TEXT("AuthRestrictions")
#define S_PBE_AUTHENTICATESERVER       TEXT("AuthenticateServer")
#define S_PBE_DATAENCRYPTION           TEXT("DataEncryption")
#define S_PBE_AUTOLOGON                TEXT("AutoLogon")
#define S_PBE_SECURELOCALFILES         TEXT("SecureLocalFiles")
#define S_PBE_OVERRIDEPREF             TEXT("OverridePref")
#define S_PBE_REDIALATTEMPTS           TEXT("RedialAttempts")
#define S_PBE_REDIALSECONDS            TEXT("RedialSeconds")
#define S_PBE_IDLEDISCONNECTSECONDS    TEXT("IdleDisconnectSeconds")
#define S_PBE_REDIALONLINKFAILURE      TEXT("RedialOnLinkFailure")
#define S_PBE_POPUPONTOPWHENREDIALIING TEXT("PopupOnTopWhenRedialing")
#define S_PBE_CALLBACKMODE             TEXT("CallbackMode")
#define S_PBE_CUSTOMDIALDLL            TEXT("CustomDialDll")
#define S_PBE_CUSTOMDIALFUNC           TEXT("CustomDialFunc")
#define S_PBE_USEPWFORNETWORK          TEXT("USePwForNetwork")
#define S_PBE_DIALPARAMSUID            TEXT("DialParamsUID")
#define S_PBE_BASEPROTOCOL             TEXT("BaseProtocol")
#define S_PBE_EXCLUDEDPROTOCOLS        TEXT("ExcludedProtocols")
#define S_PBE_LCPEXTENSIONS            TEXT("LcpExtensions")
#define S_PBE_AUTHENTICATION           TEXT("Authentication")
#define S_PBE_SKIPNWCWARNING           TEXT("SkipNwcWarning")
#define S_PBE_SKIPDOWNLEVELDIALOG      TEXT("SkipDownLevelDialog")
#define S_PBE_SWCOMPRESSION            TEXT("SwCompression")
#define S_RASMANSLIB                   TEXT("rasmans.dll")
#define S_SETENTRYDIALPARAMS           "SetEntryDialParams"
#define S_RASAPI32LIB                  TEXT("rasapi32.dll")
#define S_RNAGETDEFAUTODIALCON         TEXT("RnaGetDefaultAutodialConnection")
#define S_PROFILEMASK                  TEXT("HKU\\%s\\RemoteAccess\\Profile")
#define S_PROFILEENTRYMASK             TEXT("HKU\\%s\\RemoteAccess\\Profile\\%s")
#define S_ADDRESSESMASK                TEXT("HKU\\%s\\RemoteAccess\\Addresses")
#define S_ADDRESSENTRY                 TEXT("_ADDRESSESENTRY")
#define S_PASSWORD                     TEXT("_PASSWORD")
#define S_RESOURCEMASK                 TEXT("*Rna\\%s\\%s")
#define S_RNAPWL                       TEXT("*Rna")
#define S_NULL                         TEXT("")
#define S_USER                         TEXT("User")
#define S_HKU                          TEXT("HKU")
#define S_IPINFO                       TEXT("IP")
#define S_ZEROIPADDR                   TEXT("0.0.0.0")
#define S_SERIAL                       TEXT("serial")
#define S_LOCATIONS_REGKEY             TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations")
#define S_NAME                         TEXT("Name")
#define S_AREACODE                     TEXT("AreaCode")
#define S_COUNTRY                      TEXT("Country")
#define S_DISABLECALLWAITING           TEXT("DisableCallWaiting")
#define S_LONGDISTANCEACCESS           TEXT("LongDistanceAccess")
#define S_OUTSIDEACCESS                TEXT("OutsideAccess")
#define S_FLAGS                        TEXT("Flags")
#define S_ID                           TEXT("ID")
#define S_TELEPHON_INI                 TEXT("telephon.ini")
#define S_LOCATIONS                    TEXT("Locations")
#define S_CURRENTLOCATION              TEXT("CurrentLocation")
#define S_CURRENTID                    TEXT("CurrentID")
#define S_NEXTID                       TEXT("NextID")
#define S_NUMENTRIES                   TEXT("NumEntries")
#define S_RASPHONE_SUBPATH             TEXT("system32\\ras\\rasphone.pbk")
#define S_PPP                          TEXT("PPP")
#define S_SLIP                         TEXT("Slip")
#define S_CSLIP                        TEXT("CSlip")
#define S_REMOTE_ACCESS_KEY            TEXT("RemoteAccess")
#define S_PROFILE_KEY                  TEXT("RemoteAccess\\Profile")
#define S_ADDRESSES_KEY                TEXT("RemoteAccess\\Addresses")
#define S_AUTODIAL_KEY                 TEXT("Software\\Microsoft\\RAS AutoDial\\Default")
#define S_DIALUI                       TEXT("DialUI")
#define S_ENABLE_REDIAL                TEXT("EnableRedial")
#define S_REDIAL_WAIT                  TEXT("RedialWait")
#define S_REDIAL_TRY                   TEXT("RedialTry")
#define S_ENABLE_IMPLICIT              TEXT("EnableImplicit")
#define S_TERMINAL                     TEXT("Terminal")
#define S_MODE                         TEXT("Mode")
#define S_MULTILINK                    TEXT("MultiLink")
#define S_PHONE_NUMBER                 TEXT("Phone Number")
#define S_AREA_CODE                    TEXT("Area Code")
#define S_SMM                          TEXT("SMM")
#define S_COUNTRY_CODE                 TEXT("Country Code")
#define S_COUNTRY_ID                   TEXT("Country Id")
#define S_DEVICE_NAME                  TEXT("Device Name")
#define S_DEVICE_TYPE                  TEXT("Device Type")
#define S_DEVICE_ID                    TEXT("Device Id")
#define S_SMM_OPTIONS                  TEXT("SMM Options")
#define S_SUBENTRIES                   TEXT("SubEntries")
#define S_DEFINTERNETCON               TEXT("DefaultInternet")
#define S_PPPSCRIPT                    TEXT("PPPSCRIPT")
#define S_SPEED_DIAL_SETTINGS          TEXT("Speed Dial Settings")
#define S_SPEEDDIALKEY                 TEXT("Software\\Microsoft\\Dialer\\Speeddial")
#define S_MODEMREG                     TEXT("HKLM\\System\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}")
#define S_DIALER_INI                   TEXT("dialer.ini")

//
// STRING SECTION (Network Migration Strings)
// Used By: migmain\wkstamig.c
//

#define S_SHELL32_DLL                   TEXT("shell32.dll")
#define S_ANSI_SHUPDATERECYCLEBINICON   "SHUpdateRecycleBinIcon"
#define S_NONE_GROUP                    TEXT("none")
#define S_FONTS                         TEXT("Fonts")
#define S_MMFONTS                       TEXT("MMFonts")
#define S_TRANSFER_HIVE                 TEXT("$$temp$$")

//
// STRINGSECTION (User Migration Strings)
// Used By: w95upgnt\migmain\usermig.c

#define S_DESKTOP_KEY           TEXT("Control Panel\\desktop")
#define S_INTERNATIONAL_KEY     TEXT("Control Panel\\International")
#define S_WALLPAPER             TEXT("Wallpaper")
#define S_WALLPAPER_STYLE       TEXT("WallpaperStyle")
#define S_TILE_WALLPAPER        TEXT("TileWallpaper")
#define S_HKR                   TEXT("HKR")
#define S_SHORT_DATE_VALUE      TEXT("sShortDate")


//
// STRINGSECTION (common strings)
// Used By: w95upg\common

//
// ipc.c strings..
//
#define S_ONLINE_EVENT      TEXT("IsolIsOnline")
#define S_ACK_EVENT         TEXT("SetupAck")

//
// buildinf strings..
//
#define S_ANSWERFILE_SECTIONMASK    TEXT("SIF %s Keys")


//
// win95reg strings..
//
#define S_WIN95REG_NAME TEXT("Win95reg")
#define S_SYSDAT        TEXT("system.dat")
#define S_USERDAT       TEXT("user.dat")
#define S_WACK_USERDAT  TEXT("\\user.dat")

#define S_HKLM_PROFILELIST_KEY  TEXT("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList")
#define S_HKLM_PROFILELIST_KEYA "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList"
#define S_PROFILELIST_KEYA      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList"
#define S_PROFILEIMAGEPATH      TEXT("ProfileImagePath")
#define S_HKU_DEFAULT           TEXT("HKU\\.Default")

// These two refer to the same key!!  Please keep in sync.
#define S_MIGRATION         TEXT("Migration")
#define S_HKLM_MIGRATION    TEXT("HKLM\\Migration")

// FreeCell fixup
#define S_FREECELL_PLAYED   TEXT("AlreadyPlayed")

//
// 16 bit environment boot strings..
//
#define S_BOOT16_DOS_DIR            TEXT("MSDOS7")
#define S_BOOT16_SECTION            TEXT("Win95-DOS files")
#define S_BOOT16_AUTOEXEC_SECTION   TEXT("Boot16 AutoExec")
#define S_BOOT16_CONFIGSYS_SECTION  TEXT("Boot16 ConfigSys")
#define S_BOOT16_COMMAND_DIR        TEXT("\\COMMAND")
#define S_BOOT16_SYSMAIN_FILE       TEXT("IO.SYS")
#define S_BOOT16_BOOTSECT_FILE      TEXT("BOOTSECT.DOS")
#define S_BOOT16_CONFIG_FILE        TEXT("CONFIG.SYS")
#define S_BOOT16_CONFIGUPG_FILE     TEXT("CONFIG.UPG")
#define S_BOOT16_STARTUP_FILE       TEXT("AUTOEXEC.BAT")
#define S_BOOT16_STARTUPUPG_FILE    TEXT("AUTOEXEC.UPG")
#define S_BOOT16_DOSINI_FILE        TEXT("MSDOS.SYS")
#define S_BOOT16_BOOTINI_FILE       TEXT("BOOT.INI")
#define S_BOOT16_BOOTDOS_FILE       TEXT("BOOT.DOS")
#define S_BOOT16_OS_SECTION         TEXT("OPERATING SYSTEMS")
#define S_BOOT16_OS_ENTRY           TEXT("MS-DOS")
#define S_BOOT16_UNSPECIFIED        TEXT("Unspecified")
#define S_BOOT16_AUTOMATIC          TEXT("Automatic")

//
// Run key enumeration
//
#define S_RUNKEY                    TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY                TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY              TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNSERVICESKEY            TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices")
#define S_RUNSERVICESONCEKEY        TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce")
#define S_RUNKEY_USER               TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY_USER           TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY_USER         TEXT("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNKEY_DEFAULTUSER        TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define S_RUNONCEKEY_DEFAULTUSER    TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce")
#define S_RUNONCEEXKEY_DEFAULTUSER  TEXT("HKU\\.Default\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")
#define S_RUNKEYFOLDER              TEXT("RunKey")

//
// NT various directory names
//
#define S_DRIVERSDIR       TEXT("drivers")
#define S_INFDIR           TEXT("INF")
#define S_HELPDIR          TEXT("Help")
#define S_CATROOTDIR       TEXT("CatRoot")
#define S_FONTSDIR         TEXT("Fonts")
#define S_VIEWERSDIR       TEXT("viewers")
#define S_SPOOLDIR         TEXT("spool")
#define S_SPOOLDRIVERSDIR  TEXT("drivers")
#define S_COLORDIR         TEXT("color")
#define S_COMMONDIR        TEXT("common")
#define S_PRINTPROCDIR     TEXT("prtprocs")

//
// MigPwd.exe
//

#define S_MIGPWD            TEXT("MigPwd")
#define S_MIGPWD_EXE        TEXT("migpwd.exe")


//
// lnkstub.exe
//

#define S_LNKSTUB           TEXT("LnkStub")
#define S_LNKSTUB_EXE       TEXT("LnkStub.exe")
#define S_LNKSTUB_DAT       TEXT("LnkStub.dat")


//
// These are used only NEC98
//
#define S_C98PNP            TEXT("C98PNP")

#define WINNT_D_WIN9XBOOTDRIVE_A     "Win9xBootDrive"
#define WINNT_D_WIN9XBOOTDRIVE_W    L"Win9xBootDrive"
#ifdef UNICODE
#define WINNT_D_WIN9XBOOTDRIVE    WINNT_D_WIN9XBOOTDRIVE_W
#else
#define WINNT_D_WIN9XBOOTDRIVE    WINNT_D_WIN9XBOOTDRIVE_A
#endif


//
// STRING SECTION (mmedia strings)
// Used By: w95upgnt\migmain\mmedia.c, w95upg\sysmig\mmedia.c
//

// keys under HKLM
#define S_SKEY_MEDIARESOURCES   TEXT("System\\CurrentControlSet\\Control\\MediaResources")
#define S_SKEY_WAVEDEVICES      S_SKEY_MEDIARESOURCES TEXT("\\wave")
#define S_SKEY_CDAUDIO          S_SKEY_MEDIARESOURCES TEXT("\\mci\\cdaudio")
#define S_SKEY_CDUNIT           S_SKEY_CDAUDIO TEXT("\\unit %d")

// keys under HKCU
#define S_SKEY_SCHEMES          TEXT("AppEvents\\Schemes")
#define S_SKEY_NAMES            TEXT("Names")
#define S_SKEY_APPS             TEXT("Apps")
#define S_SKEY_APPLETS          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets")
#define S_SKEY_SYSTRAY          S_SKEY_APPLETS TEXT("\\SysTray")
#define S_SKEY_DELUXECDSETTINGS S_SKEY_APPLETS TEXT("\\DeluxeCD\\Settings")
#define S_SKEY_VOLUMECONTROL    S_SKEY_APPLETS TEXT("\\Volume Control")
#define S_SKEY_VOLCTL_OPTIONS   S_SKEY_VOLUMECONTROL TEXT("\\Options")
#define S_SKEY_MMEDIA           TEXT("Software\\Microsoft\\Multimedia")
#define S_SKEY_SOUNDMAPPER      S_SKEY_MMEDIA TEXT("\\Sound Mapper")
#define S_SKEY_VIDEOUSER        S_SKEY_MMEDIA TEXT("\\Video For Windows\\MCIAVI")
#define S_SKEY_CPANEL_SOUNDS    TEXT("Control Panel\\Sounds")

// WinNT specific
#define S_SKEY_WINNT_MCI        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\MCI32")

// DSound library name
#define S_DSOUNDLIB             TEXT("DSOUND.DLL")
// System.ini file name
#define S_SYSTEM_INI            TEXT("SYSTEM.INI")

#define S_BOOTINI               TEXT("BOOT.INI")
#define S_BOOTINI_BACKUP        TEXT("bootini.bak")
#define S_BOOTSECT_BACKUP       TEXT("bootsect.bak")
#define S_BOOTFONT_BIN          TEXT("bootfont.bin")
#define S_BOOTFONT_BACKUP       TEXT("bootfont.bak")
#define S_NTLDR                 TEXT("NTLDR")
#define S_NTLDR_BACKUP          TEXT("NTLDR.bak")
#define S_NTDETECT              TEXT("NTDETECT.COM")
#define S_NTDETECT_BACKUP       TEXT("NTDETECT.bak")

// value and subkey names
#define S_MIXERDEFAULTS         TEXT("Mixer Defaults")
#define S_SPEAKERCONFIG         TEXT("Speaker Configuration")
#define S_SPEAKERTYPE           TEXT("Speaker Type")
#define S_ACCELERATION          TEXT("Acceleration")
#define S_SRCQUALITY            TEXT("SRC Quality")
#define S_DIRECTSOUND           TEXT("DirectSound")
#define S_DSMIXERDEFAULTS       S_DIRECTSOUND TEXT("\\") S_MIXERDEFAULTS
#define S_DSSPEAKERCONFIG       S_DIRECTSOUND TEXT("\\") S_SPEAKERCONFIG
#define S_DSSPEAKERTYPE         S_DIRECTSOUND TEXT("\\") S_SPEAKERTYPE
#define S_DIRECTSOUNDCAPTURE    TEXT("DirectSoundCapture")
#define S_DSCMIXERDEFAULTS      S_DIRECTSOUNDCAPTURE TEXT("\\") S_MIXERDEFAULTS
#define S_SOFTWAREKEY           TEXT("SOFTWAREKEY")
#define S_DEFAULTDRIVE          TEXT("Default Drive")
#define S_VOLUMESETTINGS        TEXT("Volume Settings")
#define S_SERVICES              TEXT("Services")
#define S_DEFAULTOPTIONS        TEXT("DefaultOptions")
#define S_USERPLAYBACK          TEXT("UserPlayback")
#define S_USERRECORD            TEXT("UserRecord")
#define S_MIXERNUMDEVS          TEXT("MixerNumDevs")
#define S_MIXERID               TEXT("Mixer%u")
#define S_NUMLINES              TEXT("NumLines")
#define S_LINEID                TEXT("Line%u")
#define S_NUMSOURCES            TEXT("NumSources")
#define S_NUMCONTROLS           TEXT("NumCtls")
#define S_SRCID                 TEXT("Src%u")
#define S_WAVENUMDEVS           TEXT("WaveNumDevs")
#define S_WAVEID                TEXT("Wave%u")
#define S_MCI                   TEXT("MCI")
#define S_WAVEAUDIO             TEXT("waveaudio")
#define S_CDROM                 TEXT("CDROM")
#define S_AUDIO                 TEXT("Audio")
#define S_SHOWVOLUME            TEXT("ShowVolOnTaskbar")
#define S_PREFERREDONLY         TEXT("PreferredOnly")
#define S_WAVEOUTNUMDEVS        TEXT("WaveOutNumDevs")
#define S_WAVEINNUMDEVS         TEXT("WaveInNumDevs")
#define S_PREFERREDPLAY         TEXT("PrefPlay")
#define S_PREFERREDREC          TEXT("PrefRec")
#define S_PLAYBACK              TEXT("Playback")
#define S_RECORD                TEXT("Record")
#define S_USERPLAYBACK          TEXT("UserPlayback")
#define S_USERRECORD            TEXT("UserRecord")
#define S_VIDEO                 TEXT("Video")
#define S_VIDEOSETTINGS         TEXT("VideoSettings")
#define S_SNDVOL32              TEXT("SndVol32")
#define S_SHOWADVANCED          TEXT("ShowAdvanced")
#define S_STYLE                 TEXT("Style")
#define S_X                     TEXT("X")
#define S_Y                     TEXT("Y")
#define S_SYSTEMDEFAULT         TEXT("SystemDefault")
#define S_DUMMYVALUE            TEXT(",")

// Flags used by various services/apps
#define SERVICE_SHOWVOLUME      0x00000004
#define STYLE_SHOWADVANCED      0x00000800

//
// Multimedia preservation - stop
//


//
// Accessibility registry values
//

#define S_ACCESS_AVAILABLE              TEXT("Available")
#define S_ACCESS_CLICKON                TEXT("ClickOn")
#define S_ACCESS_CONFIRMHOTKEY          TEXT("ConfirmHotKey")
#define S_ACCESS_HOTKEYACTIVE           TEXT("HotKeyActive")
#define S_ACCESS_HOTKEYSOUND            TEXT("HotKeySound")
#define S_ACCESS_ON                     TEXT("On")
#define S_ACCESS_ONOFFFEEDBACK          TEXT("OnOffFeedback")
#define S_ACCESS_SHOWSTATUSINDICATOR    TEXT("ShowStatusIndicator")
#define S_ACCESS_MODIFIERS              TEXT("Modifiers")
#define S_ACCESS_REPLACENUMBERS         TEXT("ReplaceNumbers")
#define S_ACCESS_AUDIBLEFEEDBACK        TEXT("AudibleFeedback")
#define S_ACCESS_TRISTATE               TEXT("TriState")
#define S_ACCESS_TWOKEYSOFF             TEXT("TwoKeysOff")
#define S_ACCESS_HOTKEYAVAILABLE        TEXT("HotKeyAvailable")


//
// Keyboard layout registry values.
//
#define S_LAYOUT_FILE TEXT("Layout File")
#define S_KBDJPDOTKBD TEXT("KBDJP.KBD")
#define S_KBDJPNDOTDLL TEXT("KBDJPN.DLL")
#define S_DLL           TEXT(".dll")
#define S_KEYBOARD_LAYOUT_REG TEXT("HKLM\\System\\CurrentControlSet\\Control\\Keyboard Layouts")
#define S_KEYBOARD_PRELOADS_REG TEXT("HKR\\keyboard layout\\preload")


#define S_OPERATING_SYSTEMS TEXT("Operating Systems")

#define S_MAKELOCALSOURCEDEVICES TEXT("MakeLSDevices")

#define S_JPN_USB_KEYBOARDS TEXT("Japanese USB Keyboards")

#define S_ALLOWEDCODEPAGEOVERRIDES TEXT("Allowed Code Page Overrides")
#define S_CODEPAGESTOIGNORE TEXT("Code Pages To Ignore")

//
// migdb.inf section names
//
#define S_USENTFILES                TEXT("UseNtFiles")

//
// Safe mode / Recovery mode
//
#define S_SAFE_MODE_FILEA           "win9xupg.sfm"
#define S_SAFE_MODE_FILEW           L"win9xupg.sfm"

//
// Shell folder temp dir
//

#define S_SHELL_TEMP_NORMALA        "user~tmp.@01"
#define S_SHELL_TEMP_NORMALW        L"user~tmp.@01"

#define S_SHELL_TEMP_LONGA          "user~tmp.@02"
#define S_SHELL_TEMP_LONGW          L"user~tmp.@02"

#define S_SHELL_TEMP_NORMAL_PATHA   "?:\\" S_SHELL_TEMP_NORMALA
#define S_SHELL_TEMP_NORMAL_PATHW   L"?:\\" S_SHELL_TEMP_NORMALW

#define S_SHELL_TEMP_LONG_PATHA     "?:\\" S_SHELL_TEMP_LONGA
#define S_SHELL_TEMP_LONG_PATHW     L"?:\\" S_SHELL_TEMP_LONGW

#ifdef UNICODE
#define S_SHELL_TEMP_NORMAL         S_SHELL_TEMP_NORMALW
#define S_SHELL_TEMP_LONG           S_SHELL_TEMP_LONGW
#define S_SHELL_TEMP_NORMAL_PATH    S_SHELL_TEMP_NORMAL_PATHW
#define S_SHELL_TEMP_LONG_PATH      S_SHELL_TEMP_LONG_PATHW
#else
#define S_SHELL_TEMP_NORMAL         S_SHELL_TEMP_NORMALA
#define S_SHELL_TEMP_LONG           S_SHELL_TEMP_LONGA
#define S_SHELL_TEMP_NORMAL_PATH    S_SHELL_TEMP_NORMAL_PATHA
#define S_SHELL_TEMP_LONG_PATH      S_SHELL_TEMP_LONG_PATHA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\win95reg.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    win95reg.h

Abstract:

    Public interface to win95reg.dll

    Externally exposed routines:

        (Many; list to follow)

Author:

    8-Jul-1996 Mike Condra (mikeco)

Revision History:

    11-Feb-1999 jimschm     Rewrote significant portions to fix major bugs

--*/


//
// Prototypes of all the VMMREG routines Win95Reg supports
//

typedef LONG (REG_FLUSH_KEY)(HKEY hKey);
typedef REG_FLUSH_KEY WINAPI * PREG_FLUSH_KEY;

typedef LONG (REG_ENUM_KEY_A)(
            HKEY Key,
            DWORD Index,
            PSTR KeyName,
            DWORD KeyNameSize
            );
typedef REG_ENUM_KEY_A WINAPI * PREG_ENUM_KEY_A;

typedef LONG (REG_ENUM_KEY_W)(
            HKEY Key,
            DWORD Index,
            PWSTR KeyName,
            DWORD KeyNameSize
            );
typedef REG_ENUM_KEY_W WINAPI * PREG_ENUM_KEY_W;

typedef LONG (REG_ENUM_KEY_EX_A)(
            HKEY Key,
            DWORD Index,
            PSTR KeyName,
            PDWORD KeyNameSize,
            PDWORD Reserved,
            PSTR Class,
            PDWORD ClassSize,
            PFILETIME LastWriteTime
            );
typedef REG_ENUM_KEY_EX_A WINAPI * PREG_ENUM_KEY_EX_A;

typedef LONG (REG_ENUM_KEY_EX_W)(
            HKEY Key,
            DWORD Index,
            PWSTR KeyName,
            PDWORD KeyNameSize,
            PDWORD Reserved,
            PWSTR Class,
            PDWORD ClassSize,
            PFILETIME LastWriteTime
            );
typedef REG_ENUM_KEY_EX_W WINAPI * PREG_ENUM_KEY_EX_W;

typedef LONG (REG_ENUM_VALUE_A)(
            HKEY Key,
            DWORD Index,
            PSTR ValueName,
            PDWORD ValueNameSize,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_ENUM_VALUE_A WINAPI * PREG_ENUM_VALUE_A;

typedef LONG (REG_ENUM_VALUE_W)(
            HKEY Key,
            DWORD Index,
            PWSTR ValueName,
            PDWORD ValueNameSize,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_ENUM_VALUE_W WINAPI * PREG_ENUM_VALUE_W;

typedef LONG (REG_LOAD_KEY_A)(
            HKEY Key,
            PCSTR SubKey,
            PCSTR FileName
            );
typedef REG_LOAD_KEY_A WINAPI * PREG_LOAD_KEY_A;

typedef LONG (REG_LOAD_KEY_W)(
            HKEY Key,
            PCWSTR SubKey,
            PCWSTR FileName
            );
typedef REG_LOAD_KEY_W WINAPI * PREG_LOAD_KEY_W;

typedef LONG (REG_UNLOAD_KEY_A)(
            HKEY Key,
            PCSTR SubKey
            );
typedef REG_UNLOAD_KEY_A WINAPI * PREG_UNLOAD_KEY_A;

typedef LONG (REG_UNLOAD_KEY_W)(
            HKEY Key,
            PCWSTR SubKey
            );
typedef REG_UNLOAD_KEY_W WINAPI * PREG_UNLOAD_KEY_W;

typedef LONG (REG_OPEN_KEY_EX_A)(
            HKEY Key,
            PCSTR SubKey,
            DWORD Options,
            REGSAM SamDesired,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_EX_A WINAPI * PREG_OPEN_KEY_EX_A;

typedef LONG (REG_OPEN_KEY_EX_W)(
            HKEY Key,
            PCWSTR SubKey,
            DWORD Options,
            REGSAM SamDesired,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_EX_W WINAPI * PREG_OPEN_KEY_EX_W;

typedef LONG (REG_OPEN_KEY_A)(
            HKEY Key,
            PCSTR SubKey,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_A WINAPI * PREG_OPEN_KEY_A;

typedef LONG (REG_OPEN_KEY_W)(
            HKEY Key,
            PCWSTR SubKey,
            HKEY *KeyPtr
            );
typedef REG_OPEN_KEY_W WINAPI * PREG_OPEN_KEY_W;

typedef LONG (REG_CLOSE_KEY)(HKEY Key);
typedef REG_CLOSE_KEY WINAPI * PREG_CLOSE_KEY;

typedef LONG (REG_QUERY_INFO_KEY_A)(
            HKEY Key,
            PSTR Class,
            PDWORD ClassSize,
            PDWORD Reserved,
            PDWORD SubKeys,
            PDWORD MaxSubKeyLen,
            PDWORD MaxClassLen,
            PDWORD Values,
            PDWORD MaxValueName,
            PDWORD MaxValueData,
            PVOID SecurityDescriptor,
            PVOID LastWriteTime
            );
typedef REG_QUERY_INFO_KEY_A WINAPI * PREG_QUERY_INFO_KEY_A;

typedef LONG (REG_QUERY_INFO_KEY_W)(
            HKEY Key,
            PWSTR Class,
            PDWORD ClassSize,
            PDWORD Reserved,
            PDWORD SubKeys,
            PDWORD MaxSubKeyLen,
            PDWORD MaxClassLen,
            PDWORD Values,
            PDWORD MaxValueName,
            PDWORD MaxValueData,
            PVOID SecurityDescriptor,
            PVOID LastWriteTime
            );
typedef REG_QUERY_INFO_KEY_W WINAPI * PREG_QUERY_INFO_KEY_W;

typedef LONG (REG_QUERY_VALUE_A)(
            HKEY Key,
            PCSTR SubKey,
            PSTR Data,
            PLONG DataSize
            );
typedef REG_QUERY_VALUE_A WINAPI * PREG_QUERY_VALUE_A;

typedef LONG (REG_QUERY_VALUE_W)(
            HKEY Key,
            PCWSTR SubKey,
            PWSTR Data,
            PLONG DataSize
            );
typedef REG_QUERY_VALUE_W WINAPI * PREG_QUERY_VALUE_W;

typedef LONG (REG_QUERY_VALUE_EX_A)(
            HKEY Key,
            PCSTR ValueName,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_QUERY_VALUE_EX_A WINAPI * PREG_QUERY_VALUE_EX_A;

typedef LONG (REG_QUERY_VALUE_EX_W)(
            HKEY Key,
            PCWSTR ValueName,
            PDWORD Reserved,
            PDWORD Type,
            PBYTE Data,
            PDWORD DataSize
            );
typedef REG_QUERY_VALUE_EX_W WINAPI * PREG_QUERY_VALUE_EX_W;


//
// USERPOSITION -- for user enumeration
//

typedef struct {
    BOOL UseProfile;
    UINT NumPos;
    UINT CurPos;
    WORD Valid;
    BOOL IsLastLoggedOnUserName;
    BOOL LastLoggedOnUserNameExists;
    HKEY Win9xUserKey;
    // Private structure member
    CHAR LastLoggedOnUserName[MAX_MBCHAR_PATH]; // not TCHAR, WCHAR
} USERPOSITION, *PUSERPOSITION;


//
// Macro expansion list of all the wrappers
//

#define REGWRAPPERS         \
    DEFMAC(REG_FLUSH_KEY, RegFlushKey)                          \
    DEFMAC(REG_ENUM_KEY_A, RegEnumKeyA)                         \
    DEFMAC(REG_ENUM_KEY_W, RegEnumKeyW)                         \
    DEFMAC(REG_ENUM_KEY_EX_A, RegEnumKeyExA)                    \
    DEFMAC(REG_ENUM_KEY_EX_W, RegEnumKeyExW)                    \
    DEFMAC(REG_ENUM_VALUE_A, RegEnumValueA)                     \
    DEFMAC(REG_ENUM_VALUE_W, RegEnumValueW)                     \
    DEFMAC(REG_LOAD_KEY_A, RegLoadKeyA)                         \
    DEFMAC(REG_LOAD_KEY_W, RegLoadKeyW)                         \
    DEFMAC(REG_UNLOAD_KEY_A, RegUnLoadKeyA)                     \
    DEFMAC(REG_UNLOAD_KEY_W, RegUnLoadKeyW)                     \
    DEFMAC(REG_OPEN_KEY_EX_A, RegOpenKeyExA)                    \
    DEFMAC(REG_OPEN_KEY_EX_W, RegOpenKeyExW)                    \
    DEFMAC(REG_OPEN_KEY_A, RegOpenKeyA)                         \
    DEFMAC(REG_OPEN_KEY_W, RegOpenKeyW)                         \
    DEFMAC(REG_CLOSE_KEY, RegCloseKey)                          \
    DEFMAC(REG_QUERY_INFO_KEY_A, RegQueryInfoKeyA)              \
    DEFMAC(REG_QUERY_INFO_KEY_W, RegQueryInfoKeyW)              \
    DEFMAC(REG_QUERY_VALUE_A, RegQueryValueA)                   \
    DEFMAC(REG_QUERY_VALUE_W, RegQueryValueW)                   \
    DEFMAC(REG_QUERY_VALUE_EX_A, RegQueryValueExA)              \
    DEFMAC(REG_QUERY_VALUE_EX_W, RegQueryValueExW)              \

//
// Declare globals for Win95 registry wrappers
//

#define DEFMAC(fn,name)     extern P##fn Win95##name;

REGWRAPPERS

#undef DEFMAC

//
// Extension routines
//

VOID
InitWin95RegFnPointers (
    VOID
    );

LONG
Win95RegInitA (
    IN      PCSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    );

LONG
Win95RegInitW (
    IN      PCWSTR SystemHiveDir,
    IN      BOOL UseClassesRootHive
    );

LONG
Win95RegSetCurrentUserA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,        OPTIONAL
    OUT     PSTR UserDatOut             OPTIONAL
    );

LONG
Win95RegSetCurrentUserW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR SystemHiveDir,       OPTIONAL
    OUT     PWSTR UserDatOut            OPTIONAL
    );

LONG
Win95RegSetCurrentUserNtA (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR UserDat
    );

LONG
Win95RegSetCurrentUserNtW (
    IN OUT  PUSERPOSITION Pos,
    IN      PCWSTR UserDat
    );

DWORD
FindAndLoadHive (
    IN OUT  PUSERPOSITION Pos,
    IN      PCSTR SystemHiveDir,            OPTIONAL
    IN      PCSTR UserDatFromCaller,        OPTIONAL
    OUT     PSTR UserDatToCaller,           OPTIONAL
    IN      BOOL MapTheHive
    );

extern PCSTR g_UserKey;
extern CHAR g_SystemHiveDir[MAX_MBCHAR_PATH];

LONG
Win95RegGetFirstUserA (
    PUSERPOSITION Pos,
    PSTR UserName
    );

LONG
Win95RegGetFirstUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    );

LONG
Win95RegGetNextUserA (
    PUSERPOSITION Pos,
    PSTR UserName
    );

LONG
Win95RegGetNextUserW (
    PUSERPOSITION Pos,
    PWSTR UserName
    );

#define Win95RegHaveUser(Pos) ((Pos)->NumPos > 0)


BOOL
Win95RegIsValidUser (
    HKEY ProfileListKey,        OPTIONAL
    PSTR UserNameAnsi
    );



//
// A & W macros
//

#ifdef UNICODE

#define Win95RegEnumKey             Win95RegEnumKeyW
#define Win95RegEnumKeyEx           Win95RegEnumKeyExW
#define Win95RegEnumValue           Win95RegEnumValueW
#define Win95RegLoadKey             Win95RegLoadKeyW
#define Win95RegUnLoadKey           Win95RegUnLoadKeyW
#define Win95RegOpenKeyEx           Win95RegOpenKeyExW
#define Win95RegOpenKey             Win95RegOpenKeyW
#define Win95RegQueryInfoKey        Win95RegQueryInfoKeyW
#define Win95RegQueryValue          Win95RegQueryValueW
#define Win95RegQueryValueEx        Win95RegQueryValueExW

#define Win95RegInit                Win95RegInitW
#define Win95RegSetCurrentUser      Win95RegSetCurrentUserW
#define Win95RegSetCurrentUserNt    Win95RegSetCurrentUserNtW
#define Win95RegGetFirstUser        Win95RegGetFirstUserW
#define Win95RegGetNextUser         Win95RegGetNextUserW

#else

#define Win95RegEnumKey             Win95RegEnumKeyA
#define Win95RegEnumKeyEx           Win95RegEnumKeyExA
#define Win95RegEnumValue           Win95RegEnumValueA
#define Win95RegLoadKey             Win95RegLoadKeyA
#define Win95RegUnLoadKey           Win95RegUnLoadKeyA
#define Win95RegOpenKeyEx           Win95RegOpenKeyExA
#define Win95RegOpenKey             Win95RegOpenKeyA
#define Win95RegQueryInfoKey        Win95RegQueryInfoKeyA
#define Win95RegQueryValue          Win95RegQueryValueA
#define Win95RegQueryValueEx        Win95RegQueryValueExA

#define Win95RegInit                Win95RegInitA
#define Win95RegSetCurrentUser      Win95RegSetCurrentUserA
#define Win95RegSetCurrentUserNt    Win95RegSetCurrentUserNtA
#define Win95RegGetFirstUser        Win95RegGetFirstUserA
#define Win95RegGetNextUser         Win95RegGetNextUserA

#endif

//
// Now include registry wrapper APIs in reg95.h; it redefines Win95RegOpenKeyExA,
// Win95RegOpenKeyExW and Win95RegCloseKey for tracking purposes.
//

#include "reg95.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\winntreg.h ===
#ifndef WinNTRegOpenKey
#define WinNTRegOpenKey RegOpenKey
#endif

#ifndef WinNTRegOpenKeyEx
#define WinNTRegOpenKeyEx RegOpenKeyEx
#endif

#ifndef WinNTRegCloseKey
#define WinNTRegCloseKey RegCloseKey
#endif

#ifndef WinNTRegQueryValue
#define WinNTRegQueryValue RegQueryValue
#endif

#ifndef WinNTRegQueryValueEx
#define WinNTRegQueryValueEx RegQueryValueEx
#endif

#ifndef WinNTRegEnumKey
#define WinNTRegEnumKey RegEnumKey
#endif

#ifndef WinNTRegEnumKeyEx
#define WinNTRegEnumKeyEx RegEnumKeyEx
#endif

#ifndef WinNTRegDeleteKey
#define WinNTRegDeleteKey RegDeleteKey
#endif

#ifndef WinNTRegDeleteValue
#define WinNTRegDeleteValue RegDeleteValue
#endif

#ifndef WinNTRegEnumValue
#define WinNTRegEnumValue RegEnumValue
#endif

#ifndef WinNTRegFlushKey
#define WinNTRegFlushKey RegFlushKey
#endif

#ifndef WinNTRegQueryInfoKey
#define WinNTRegQueryInfoKey RegQueryInfoKey
#endif

#ifndef WinNTRegQueryMultipleValues
#define WinNTRegQueryMultipleValues RegQueryMultipleValues
#endif

#ifndef WinNTRegReplaceKey
#define WinNTRegReplaceKey RegReplaceKey
#endif

#ifndef WinNTRegSetValue
#define WinNTRegSetValue RegSetValue
#endif

#ifndef WinNTRegSetValueEx
#define WinNTRegSetValueEx RegSetValueEx
#endif

#ifndef WinNTRegCreateKey
#define WinNTRegCreateKey RegCreateKey
#endif

#ifndef WinNTRegCreateKeyEx
#define WinNTRegCreateKeyEx RegCreateKeyEx
#endif

#ifndef WinNTRegSaveKey
#define WinNTRegSaveKey RegSaveKey
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    When specific conversion is needed, use:

        unicode = ConvertAtoW (ansi) / FreeConvertedStr (unicode)
        ansi = ConvertWtoA (unicode) / FreeConvertedStr (ansi)

        KnownSizeAtoW (unicode,ansi)
        KnownSizeWtoA (ansi,unicode)

    When TCHAR conversion is needed, use:

        ansi = CreateDbcs (tchar) / DestroyDbcs (ansi)
        unicode = CreateUnicode (tchar) / DestroyUnicode (unicode)
        tchar = ConvertAtoT (ansi) / FreeAtoT (tchar)
        tchar = ConvertWtoT (ansi) / FreeWtoT (tchar)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

extern WORD g_GlobalCodePage;

#define OurGetACP() (g_GlobalCodePage)

VOID
SetGlobalCodePage (
    IN      WORD CodePage,
    IN      LCID Locale
    );


VOID
GetGlobalCodePage (
    OUT     PWORD CodePage,             OPTIONAL
    OUT     PLCID Locale                OPTIONAL
    );


#define INVALID_CHAR_COUNT      0xffffffff

//
// Explicit conversions, pool-based, unlimited size
//

PCSTR
RealUnicodeToDbcsN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCWSTR StrIn,
    IN      DWORD LcharCount
    );

PCWSTR
RealDbcsToUnicodeN (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PCSTR StrIn,
    IN      DWORD LcharCount
    );

#define UnicodeToDbcsN(p,s,c)       SETTRACKCOMMENT(PCSTR,"UnicodeToDbcsN",__FILE__,__LINE__)\
                                    RealUnicodeToDbcsN(p,s,c)\
                                    CLRTRACKCOMMENT

#define DbcsToUnicodeN(p,s,c)       SETTRACKCOMMENT(PCWSTR,"DbcsToUnicodeN",__FILE__,__LINE__)\
                                    RealDbcsToUnicodeN(p,s,c)\
                                    CLRTRACKCOMMENT

#define UnicodeToDbcs(pool,str) UnicodeToDbcsN(pool,str,wcslen(str))
#define DbcsToUnicode(pool,str) DbcsToUnicodeN(pool,str,LcharCountA(str))

#define ConvertWtoA(unicode_str) UnicodeToDbcsN(NULL,unicode_str,wcslen(unicode_str))
#define ConvertAtoW(dbcs_str) DbcsToUnicodeN(NULL,dbcs_str,LcharCountA(dbcs_str))

VOID
FreeConvertedPoolStr (
    IN      POOLHANDLE Pool,            OPTIONAL
    IN      PVOID StrIn
    );

#define FreeConvertedStr(str) FreeConvertedPoolStr(NULL,(PVOID)(str))

//
// In-place explicit conversions, caller handles buffer sizing
//

PSTR
KnownSizeUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD LcharCount
    );

PWSTR
KnownSizeDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD LcharCount
    );

#define KnownSizeUnicodeToDbcs(out,in)      KnownSizeUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define KnownSizeDbcsToUnicode(out,in)      KnownSizeDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define KnownSizeWtoA                       KnownSizeUnicodeToDbcs
#define KnownSizeAtoW                       KnownSizeDbcsToUnicode

PSTR
DirectUnicodeToDbcsN (
    OUT     PSTR StrOut,
    IN      PCWSTR StrIn,
    IN      DWORD Bytes
    );

PWSTR
DirectDbcsToUnicodeN (
    OUT     PWSTR StrOut,
    IN      PCSTR StrIn,
    IN      DWORD Bytes
    );

#define DirectUnicodeToDbcs(out,in)         DirectUnicodeToDbcsN(out,in,INVALID_CHAR_COUNT)
#define DirectDbcsToUnicode(out,in)         DirectDbcsToUnicodeN(out,in,INVALID_CHAR_COUNT)

#define DirectWtoA                          DirectUnicodeToDbcs
#define DirectAtoW                          DirectDbcsToUnicode




//
// TCHAR conversions -- do not call A & W versions directly
//

#define CreateDbcsW(unicode_str)            ConvertWtoA(unicode_str)
#define DestroyDbcsW(unicode_str)           FreeConvertedStr(unicode_str)
#define CreateUnicodeW(unicode_str)         (unicode_str)
#define DestroyUnicodeW(unicode_str)
#define CreateDbcsA(dbcs_str)               (dbcs_str)
#define DestroyDbcsA(dbcs_str)
#define CreateUnicodeA(dbcs_str)            ConvertAtoW(dbcs_str)
#define DestroyUnicodeA(dbcs_str)           FreeConvertedStr(dbcs_str)

#ifdef UNICODE

#define CreateDbcs          CreateDbcsW
#define CreateUnicode       CreateUnicodeW
#define DestroyDbcs         DestroyDbcsW
#define DestroyUnicode      DestroyUnicodeW
#define ConvertAtoT         ConvertAtoW
#define ConvertWtoT(x)      (x)
#define FreeAtoT            FreeConvertedStr
#define FreeWtoT(x)

#define KnownSizeAtoT           KnownSizeAtoW
#define KnownSizeWtoT(out,in)   (in)

#define DirectAtoT              DirectAtoW
#define DirectWtoT(out,in)      (in)

#else

#define CreateDbcs          CreateDbcsA
#define CreateUnicode       CreateUnicodeA
#define DestroyDbcs         DestroyDbcsA
#define DestroyUnicode      DestroyUnicodeA
#define ConvertAtoT(x)      (x)
#define ConvertWtoT         ConvertWtoA
#define FreeAtoT(x)
#define FreeWtoT            FreeConvertedStr

#define KnownSizeAtoT(out,in)   (in)
#define KnownSizeWtoT           KnownSizeWtoA

#define DirectAtoT(out,in)      (in)
#define DirectWtoT              DirectWtoA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\inc\sysmig.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    sysmig.h

Abstract:

    This file declares the functions for the main Win9x side lib.
    See w95upg\sysmig for implementation details.

Author:

    Jim Schmidt (jimschm) 11-Nov-1996

Revision History:

    mvander     27-May-1999     Added OBJECTTYPEs and DEAD_FILE
    ovidiut     09-Mar-1999     UndoChangedFileProps
    jimschm     01-Oct-1998     TWAIN support
    calinn      10-Jul-1998     Reorganization
    jimschm     01-Jul-1998     Progress bar changes
    jimschm     05-May-1998     Icon extraction
    jimschm     10-Mar-1998     ExpandNtEnvVars
    calinn      05-Mar-1998     MapFileIntoMemory
    jimschm     22-Jan-1998     Domain enumeration
    jimschm     06-Jan-1998     Name fix routines
    jimschm     31-Jul-1997     User profile enumeration

--*/

#pragma once


#define DEAD_FILE   TEXT("dead.ini")
#define OBJECTTYPE_COUNT         5
#define OBJECTTYPE_UNKNOWN       0
#define OBJECTTYPE_APP           1
#define OBJECTTYPE_CPL           2
#define OBJECTTYPE_RUNKEY        3
#define OBJECTTYPE_LINK          4


VOID
ExpandNtEnvVars (
    IN OUT  PTSTR PathBuf,
    IN      PCTSTR UserProfileDir
    );

BOOL
ExtractIconIntoDatFile (
    IN      PCTSTR LongPath,
    IN      INT IconIndex,
    IN OUT  PICON_EXTRACT_CONTEXT Context,
    OUT     PINT NewIconIndex                   OPTIONAL
    );

#define REQUEST_QUERYTICKS          1
#define REQUEST_RUN                 2
#define REQUEST_BEGINUSERPROCESSING 3
#define REQUEST_ENDUSERPROCESSING   4


VOID
PrepareProcessingProgressBar (
    VOID
    );

DWORD
RunSysFirstMigrationRoutines (
    VOID
    );

DWORD
RunUserMigrationRoutines (
    VOID
    );

DWORD
RunSysLastMigrationRoutines (
    VOID
    );



//
// compacct.c
//

#define MAX_NETENUM_DEPTH       2

typedef enum {
    NETRES_INIT,
    NETRES_OPEN_ENUM,
    NETRES_ENUM_BLOCK,
    NETRES_ENUM_BLOCK_NEXT,
    NETRES_RETURN_ITEM,
    NETRES_CLOSE_ENUM,
    NETRES_DONE
} NETRESSTATE;

typedef struct {
    //
    // Members returned to the caller
    //

    BOOL Connected:1;
    BOOL GlobalNet:1;
    BOOL Persistent:1;
    BOOL DiskResource:1;
    BOOL PrintResource:1;
    BOOL TypeUnknown:1;
    BOOL Domain:1;
    BOOL Generic:1;
    BOOL Server:1;
    BOOL Share:1;
    BOOL Connectable:1;
    BOOL Container:1;
    PCTSTR RemoteName;
    PCTSTR LocalName;
    PCTSTR Comment;
    PCTSTR Provider;

    //
    // Private enumeration members
    //

    DWORD EnumScope;
    DWORD EnumType;
    DWORD EnumUsage;
    NETRESSTATE State;
    HANDLE HandleStack[MAX_NETENUM_DEPTH];
    UINT StackPos;
    PBYTE ResStack[MAX_NETENUM_DEPTH];
    UINT Entries[MAX_NETENUM_DEPTH];
    UINT Pos[MAX_NETENUM_DEPTH];
} NETRESOURCE_ENUM, *PNETRESOURCE_ENUM;


LONG
DoesComputerAccountExistOnDomain (
    IN      PCTSTR DomainName,
    IN      PCTSTR LookUpName,
    IN      BOOL WaitCursorEnable
    );

BOOL
EnumFirstNetResource (
    OUT     PNETRESOURCE_ENUM EnumPtr,
    IN      DWORD WNetScope,                OPTIONAL
    IN      DWORD WNetType,                 OPTIONAL
    IN      DWORD WNetUsage                 OPTIONAL
    );

BOOL
EnumNextNetResource (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    );

VOID
AbortNetResourceEnum (
    IN OUT  PNETRESOURCE_ENUM EnumPtr
    );

BOOL
ReadNtFilesEx (
    IN      PCSTR FileListName,    //optional, if null default is opened
    IN      BOOL ConvertPath
    );

BOOL
UndoChangedFileProps (
    VOID
    );

//
// Beta only!!
//

//VOID
//SaveConfigurationForBeta (
//    VOID
//    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\binvals.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    binvals.c

Abstract:

    Routines to manage binary blocks associated with memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif


static PBINARYBLOCK g_FirstBlockPtr = NULL;

//
// Implementation
//

PBYTE
pGetBinaryData (
    IN      PBINARYBLOCK BlockPtr
    )

/*++

Routine Description:

  pGetBinaryData returns a pointer to the data portion of a
  BINARYBLOCK struct.

Arguments:

  BlockPtr - A pointer to a BINARYBLOCK struct.

Return Value:

  A pointer to the binary data of BlockPtr, or NULL if BlockPtr
  is invalid.

--*/

{
#ifdef DEBUG

    // Verify checked block is valid
    if (BlockPtr && BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((
            DBG_ERROR,
            "Signature of %x is invalid, can't get binary data",
            g_FirstBlockPtr
            ));
        return NULL;
    }
#endif

    if (!BlockPtr) {
        return NULL;
    }

    return BlockPtr->Data;
}


DWORD
pGetBinaryDataSize (
    IN      PBINARYBLOCK BlockPtr
    )
{
#ifdef DEBUG
    // Verify checked block is valid
    if (BlockPtr && BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((
            DBG_ERROR,
            "Signature of %x is invalid, can't get binary data",
            g_FirstBlockPtr
            ));
        return 0;
    }
#endif

    if (!BlockPtr) {
        return 0;
    }

    return BlockPtr->Size - sizeof (BINARYBLOCK);
}


PCBYTE
GetKeyStructBinaryData (
    PKEYSTRUCT KeyStruct
    )
{
    if (!KeyStruct || !(KeyStruct->Flags & KSF_BINARY)) {
        return NULL;
    }

    return pGetBinaryData (KeyStruct->BinaryPtr);
}


DWORD
GetKeyStructBinarySize (
    PKEYSTRUCT KeyStruct
    )
{
    if (!KeyStruct || !(KeyStruct->Flags & KSF_BINARY)) {
        return 0;
    }

    return pGetBinaryDataSize (KeyStruct->BinaryPtr);
}


PBINARYBLOCK
pGetFirstBinaryBlock (
    VOID
    )

/*++

Routine Description:

  pGetFristBinaryBlock returns a pointer to the first allocated
  BINARYBLOCK struct, or NULL if no structs are allocated.  This
  routine is used with pGetNextBinaryBlock to walk all allocated
  blocks.

Arguments:

  none

Return Value:

  A pointer to the the first allocated BINARYBLOCK struct, or NULL
  if there are no structs allocated.

--*/

{
#ifdef DEBUG
    // Verify checked block is valid
    if (g_FirstBlockPtr && g_FirstBlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "First binary block %x signature is invalid", g_FirstBlockPtr));
        return NULL;
    }
#endif

    return g_FirstBlockPtr;
}


PBINARYBLOCK
pGetNextBinaryBlock (
    IN      PBINARYBLOCK BlockPtr
    )

/*++

Routine Description:

  pGetNextBinaryBlock returns a pointer to the next allocated
  BINARYBLOCK struct, or NULL if no more blocks are allocated.

Arguments:

  BlockPtr - The non-NULL return value of pGetFirstBinaryBlock or
             pGetNextBinaryBlock

Return Value:

  A pointer to the next BINARYBLOCK struct, or NULL if no more blocks
  are allocated.

--*/

{
    if (!BlockPtr) {
        return NULL;
    }

#ifdef DEBUG
    // Verify checked block is valid
    if (BlockPtr->NextPtr && BlockPtr->NextPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Binary block %x signature is invalid", BlockPtr->NextPtr));
        return NULL;
    }
#endif

    return BlockPtr->NextPtr;
}


PBINARYBLOCK
AllocBinaryBlock (
    IN      PCBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD OwningKey
    )

/*++

Routine Description:

  AllocBinaryBlock returns a pointer to an initialized BINARYBLOCK
  structure, or NULL if the structure could not be allocated.  If
  the structure is allocated, Data is copied to the newly allocated
  block.  Call pFreeBinaryBlock to clean up this allocation.

Arguments:

  Data      - A pointer to a block of binary data to be copied into
              the newly allocated structure
  DataSize  - The number of bytes to copy (may be zero)
  OwningKey - The offset of the key who owns the data block

Return Value:

  A pointer to the binary block structure, or NULL if it could not
  be allocated.

--*/

{
    PBINARYBLOCK BlockPtr;
    DWORD AllocSize;

    AllocSize = DataSize + sizeof (BINARYBLOCK);

    BlockPtr = (PBINARYBLOCK) MemAlloc (g_hHeap, 0, AllocSize);
    if (!BlockPtr) {
        return NULL;
    }

    //
    // Initialize block struct
    //

    if (DataSize) {
        CopyMemory (BlockPtr->Data, Data, DataSize);
    }

    BlockPtr->Size = AllocSize;
    BlockPtr->OwningKey = OwningKey;

#ifdef DEBUG
    BlockPtr->Signature = SIGNATURE;
#endif

    //
    // Link block to list of allocated blocks
    //

    BlockPtr->NextPtr = g_FirstBlockPtr;
    if (g_FirstBlockPtr) {
        g_FirstBlockPtr->PrevPtr = BlockPtr;
    }
    g_FirstBlockPtr = BlockPtr;

    BlockPtr->PrevPtr = NULL;

    //
    // Return
    //

    return BlockPtr;
}


VOID
pFreeBinaryBlock (
    PBINARYBLOCK BlockPtr,
    BOOL Delink
    )

/*++

Routine Description:

  pFreeBinaryBlock frees memory allocated for a binary block and optionally
  delinks it from the allocation list.

Arguments:

  BlockPtr  - A pointer to the block to delete
  Delink    - TRUE if structure should be delinked from allocation list,
              or FALSE if the allocation list does not need to be maintained

Return Value:

  none

--*/

{
    if (!BlockPtr) {
        return;
    }

#ifdef DEBUG
    if (BlockPtr->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Can't free block %x because signature is invalid", BlockPtr));
        return;
    }
#endif

    if (Delink) {

#ifdef DEBUG

        if (BlockPtr->PrevPtr && BlockPtr->PrevPtr->Signature != SIGNATURE) {
            DEBUGMSG ((DBG_ERROR, "Can't free block %x because prev block (%x) signature is invalid", BlockPtr, BlockPtr->PrevPtr));
            return;
        }

        if (BlockPtr->NextPtr && BlockPtr->NextPtr->Signature != SIGNATURE) {
            DEBUGMSG ((DBG_ERROR, "Can't free block %x because next block (%x) signature is invalid", BlockPtr, BlockPtr->NextPtr));
            return;
        }

#endif

        if (BlockPtr->PrevPtr) {
            BlockPtr->PrevPtr->NextPtr = BlockPtr->NextPtr;
        } else {
            g_FirstBlockPtr = BlockPtr->NextPtr;
        }

        if (BlockPtr->NextPtr) {
            BlockPtr->NextPtr->PrevPtr = BlockPtr->PrevPtr;
        }
    }

    MemFree (g_hHeap, 0, BlockPtr);
}


VOID
FreeKeyStructBinaryBlock (
    PKEYSTRUCT KeyStruct
    )

/*++

Routine Description:

  FreeKeyStructBinaryBlock frees a binary block and resets the
  KSF_BINARY flag, if the key struct has a binary block allocated.

Arguments:

  none

Return Value:

  none

--*/

{
    if (KeyStruct->Flags & KSF_BINARY) {
        pFreeBinaryBlock (KeyStruct->BinaryPtr, TRUE);
        KeyStruct->BinaryPtr = NULL;
        KeyStruct->Flags &= ~KSF_BINARY;
    }
}


VOID
FreeAllBinaryBlocks (
    VOID
    )

/*++

Routine Description:

  FreeAllBinaryBlocks removes all memory associated with binary
  blocks.  This function is used for final cleanup.

Arguments:

  none

Return Value:

  none

--*/

{
    PBINARYBLOCK NextBlockPtr;

    while (g_FirstBlockPtr) {
        NextBlockPtr = g_FirstBlockPtr->NextPtr;
        pFreeBinaryBlock (g_FirstBlockPtr, FALSE);
        g_FirstBlockPtr = NextBlockPtr;
    }
}


BOOL
LoadBinaryBlocks (
    HANDLE File
    )
{
    BOOL b;
    DWORD Count;
    DWORD Owner = 0;
    DWORD Size;
    DWORD Read;
    DWORD d;
    PBYTE TempBuf = NULL;
    PBINARYBLOCK NewBlock;

    b = ReadFile (File, &Count, sizeof (DWORD), &Read, NULL);

    if (b && Count) {
        //
        // Alloc binary objects
        //

        for (d = 0 ; b && d < Count ; d++) {
            // Get Size and Owner
            b = ReadFile (File, &Size, sizeof (DWORD), &Read, NULL);
            if (Size > BLOCK_SIZE * 32) {
                b = FALSE;
            }
            if (b) {
                b = ReadFile (File, &Owner, sizeof (DWORD), &Read, NULL);
            }

            // Alloc a temporary buffer to read in data
            if (b) {
                TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, Size);

                b = ReadFile (File, TempBuf, Size, &Read, NULL);

                // If data read OK, create binary block object
                if (b) {
                    NewBlock = AllocBinaryBlock (TempBuf, Size, Owner);
                    if (!NewBlock) {
                        b = FALSE;
                    } else {
                        // Link owner to new memory location
                        MYASSERT (GetKeyStruct (Owner)->Flags & KSF_BINARY);
                        GetKeyStruct(Owner)->BinaryPtr = NewBlock;
                    }
                }

                MemFree (g_hHeap, 0, TempBuf);
                TempBuf = NULL;
            }
        }
    }

    if (TempBuf) {
        MemFree (g_hHeap, 0, TempBuf);
    }

    return b;
}


BOOL
SaveBinaryBlocks (
    HANDLE File
    )
{
    BOOL b;
    DWORD Count;
    DWORD Size;
    PBINARYBLOCK BinaryPtr;
    DWORD Written;

    //
    // Count the binary objects
    //

    BinaryPtr = pGetFirstBinaryBlock();
    Count = 0;

    while (BinaryPtr) {
        Count++;
        BinaryPtr = pGetNextBinaryBlock (BinaryPtr);
    }

    //
    // Write count to disk
    //
    b = WriteFile (File, &Count, sizeof (DWORD), &Written, NULL);

    if (b) {
        //
        // Write the binary objects
        //

        BinaryPtr = pGetFirstBinaryBlock();

        while (b && BinaryPtr) {
            //
            // Format per object:
            //
            //  Size    (DWORD)
            //  Owner   (DWORD)
            //  Data    (Size)
            //

            Size = pGetBinaryDataSize (BinaryPtr);
            b = WriteFile (File, &Size, sizeof (DWORD), &Written, NULL);

            if (b) {
                b = WriteFile (File, &BinaryPtr->OwningKey, sizeof (DWORD), &Written, NULL);
            }

            if (b && Size) {
                b = WriteFile (File, pGetBinaryData (BinaryPtr), Size, &Written, NULL);
                if (Written != Size) {
                    b = FALSE;
                }
            }

            BinaryPtr = pGetNextBinaryBlock(BinaryPtr);
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\bintree.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    bintree.c

Abstract:

    Routines that manage the memdb binary tree structures.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     30-Dec-1998  Hacked in AVL balancing
    jimschm     23-Sep-1998  Proxy nodes, so MemDbMoveTree can replace end nodes too
    jimschm     29-May-1998  Ability to replace center nodes in key strings
    jimschm     21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif

#define MAX_MEMDB_SIZE  0x08000000  //128 MB
#define KSF_FLAGS_TO_COPY       (KSF_USERFLAG_MASK|KSF_ENDPOINT|KSF_BINARY|KSF_PROXY_NODE)

DWORD
pNewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive,
    IN  BOOL Endpoint
    );

DWORD
pAllocKeyToken (
    IN      PCWSTR KeyName,
    OUT     PINT AdjustFactor
    );

VOID
pDeallocToken (
    IN      DWORD Token
    );

DWORD
pFindPatternKeyWorker (
    IN      PCWSTR SubKey,
    IN      PCWSTR End,
    IN      DWORD RootOffset,
    IN      BOOL EndPatternAllowed
    );

#ifdef DEBUG
VOID
pDumpTree (
    IN      DWORD Root,
    IN      PCSTR Title         OPTIONAL
    );

VOID
pCheckBalanceFactors (
    IN      DWORD Root
    );

DWORD g_SingleRotations = 0;
DWORD g_DoubleRotations = 0;
DWORD g_Deletions = 0;
DWORD g_Insertions = 0;

#define INCSTAT(x)      (x++)

#else

#define pDumpTree(arg1,arg2)
#define INCSTAT(x)

#endif


#define ANTIDIRECTION(x)        ((x)^KSF_BALANCE_MASK)
#define FLAGS_TO_INT(x)         ((INT) ((x)==KSF_LEFT_HEAVY ? -1 : (x)==KSF_RIGHT_HEAVY ? 1 : 0))
#define INT_TO_FLAGS(x)         ((DWORD) ((x)==-1 ? KSF_LEFT_HEAVY : (x)==1 ? KSF_RIGHT_HEAVY : 0))

//
// Implementation
//


DWORD
pRotateOnce (
    OUT     PDWORD RootPtr,
    IN      DWORD ParentOffset,
    IN      DWORD PivotOffset,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT GrandParent;
    PKEYSTRUCT Parent;
    PKEYSTRUCT Pivot;
    PKEYSTRUCT TempKey;
    DWORD Temp;
    INT OldRootBalance;
    INT NewRootBalance;
    DWORD OldDir, NewDir;

    INCSTAT(g_SingleRotations);

    MYASSERT (ParentOffset != INVALID_OFFSET);
    MYASSERT (PivotOffset != INVALID_OFFSET);

    Parent = GetKeyStruct (ParentOffset);
    Pivot = GetKeyStruct (PivotOffset);

    if (Direction == KSF_LEFT_HEAVY) {
        //
        // Perform LL rotation
        //

        Temp = Pivot->Right;

        Pivot->Right = ParentOffset;
        Pivot->Parent = Parent->Parent;
        Parent->Parent = PivotOffset;

        Parent->Left = Temp;

    } else {
        //
        // Preform RR rotation
        //

        Temp = Pivot->Left;

        Pivot->Left = ParentOffset;
        Pivot->Parent = Parent->Parent;
        Parent->Parent = PivotOffset;

        Parent->Right = Temp;
    }

    if (Temp != INVALID_OFFSET) {

        TempKey = GetKeyStruct (Temp);
        TempKey->Parent = ParentOffset;

    }

    OldDir = Parent->Flags & KSF_BALANCE_MASK;
    NewDir = Pivot->Flags & KSF_BALANCE_MASK;

    OldRootBalance  = FLAGS_TO_INT (OldDir);
    NewRootBalance  = FLAGS_TO_INT (NewDir);

    if (Direction == KSF_LEFT_HEAVY) {
        OldRootBalance = -(++NewRootBalance);
    } else {
        OldRootBalance = -(--NewRootBalance);
    }

    Pivot->Flags = (Pivot->Flags & (~KSF_BALANCE_MASK)) | INT_TO_FLAGS(NewRootBalance);
    Parent->Flags = (Parent->Flags & (~KSF_BALANCE_MASK)) | INT_TO_FLAGS(OldRootBalance);

    //
    // Fix grandparent/root to parent linkage
    //

    if (Pivot->Parent != INVALID_OFFSET) {
        GrandParent = GetKeyStruct (Pivot->Parent);

        if (GrandParent->Left == ParentOffset) {
            GrandParent->Left = PivotOffset;
        } else {
            GrandParent->Right = PivotOffset;
        }

    } else {
        *RootPtr = PivotOffset;
    }

    return PivotOffset;
}


DWORD
pRotateTwice (
    OUT     PDWORD RootPtr,
    IN      DWORD ParentOffset,
    IN      DWORD PivotOffset,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT GrandParent;
    PKEYSTRUCT Parent;
    PKEYSTRUCT Pivot;
    PKEYSTRUCT Child;
    DWORD ChildOffset;
    PKEYSTRUCT GrandChildLeft;
    PKEYSTRUCT GrandChildRight;
    DWORD AntiDirection;
    DWORD Flag;
    INT ParentDir;
    INT PivotDir;
    INT ChildDir;

    INCSTAT(g_DoubleRotations);

    //
    // Initialize pointers
    //

    MYASSERT (ParentOffset != INVALID_OFFSET);
    MYASSERT (PivotOffset != INVALID_OFFSET);

    Parent = GetKeyStruct (ParentOffset);
    Pivot = GetKeyStruct (PivotOffset);

    if (Direction == KSF_LEFT_HEAVY) {
        AntiDirection = KSF_RIGHT_HEAVY;
        ChildOffset = Pivot->Right;
    } else {
        AntiDirection = KSF_LEFT_HEAVY;
        ChildOffset = Pivot->Left;
    }

    MYASSERT (ChildOffset != INVALID_OFFSET);
    Child = GetKeyStruct (ChildOffset);

    if (Child->Left != INVALID_OFFSET) {
        GrandChildLeft = GetKeyStruct (Child->Left);
    } else {
        GrandChildLeft = NULL;
    }

    if (Child->Right != INVALID_OFFSET) {
        GrandChildRight = GetKeyStruct (Child->Right);
    } else {
        GrandChildRight = NULL;
    }

    //
    // Perform the rotation
    //

    if (Direction == KSF_LEFT_HEAVY) {
        //
        // Perform LR rotation
        //

        Child->Parent = Parent->Parent;

        Parent->Left = Child->Right;
        if (GrandChildRight) {
            GrandChildRight->Parent = ParentOffset;
        }

        Pivot->Right = Child->Left;
        if (GrandChildLeft) {
            GrandChildLeft->Parent = PivotOffset;
        }

        Child->Left = PivotOffset;
        Pivot->Parent = ChildOffset;

        Child->Right = ParentOffset;
        Parent->Parent = ChildOffset;

    } else {
        //
        // Preform RL rotation
        //

        Child->Parent = Parent->Parent;

        Parent->Right = Child->Left;
        if (GrandChildLeft) {
            GrandChildLeft->Parent = ParentOffset;
        }

        Pivot->Left = Child->Right;
        if (GrandChildRight) {
            GrandChildRight->Parent = PivotOffset;
        }

        Child->Right = PivotOffset;
        Pivot->Parent = ChildOffset;

        Child->Left = ParentOffset;
        Parent->Parent = ChildOffset;


    }

    //
    // Fix balance factors
    //

    Flag = Child->Flags & KSF_BALANCE_MASK;
    ChildDir = FLAGS_TO_INT (Flag);

    if (Direction == KSF_RIGHT_HEAVY) {
        ParentDir = -max (ChildDir, 0);
        PivotDir  = -min (ChildDir, 0);
    } else {
        ParentDir = -min (ChildDir, 0);
        PivotDir  = -max (ChildDir, 0);
    }

    Parent->Flags = Parent->Flags & (~KSF_BALANCE_MASK) | INT_TO_FLAGS(ParentDir);
    Pivot->Flags  = Pivot->Flags & (~KSF_BALANCE_MASK) | INT_TO_FLAGS(PivotDir);
    Child->Flags  = Child->Flags & (~KSF_BALANCE_MASK);

    //
    // Fix grandparent/root to parent linkage
    //

    if (Child->Parent != INVALID_OFFSET) {
        GrandParent = GetKeyStruct (Child->Parent);

        if (GrandParent->Left == ParentOffset) {
            GrandParent->Left = ChildOffset;
        } else {
            GrandParent->Right = ChildOffset;
        }

    } else {
        *RootPtr = ChildOffset;
    }

    return ChildOffset;
}


VOID
pBalanceInsertion (
    OUT     PDWORD RootPtr,
    IN      DWORD ChangedNode,
    IN      DWORD PivotEnd
    )
{
    DWORD PrevPivot;
    DWORD PivotNode;
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD BalanceFlags;

    PivotNode = ChangedNode;
    MYASSERT (PivotNode != INVALID_OFFSET);

    //
    // Initialize previous pivot to be the changed node,
    // and begin balancing at its parent
    //

    PrevPivot = PivotNode;
    KeyStruct = GetKeyStruct (PivotNode);
    PivotNode = KeyStruct->Parent;

    //
    // Balance the tree starting at the changed node and going
    // up until PivotEnd is reached.  PivotEnd is the offset to
    // the deepest node with a balance of non-zero.
    //

    MYASSERT (PivotNode != INVALID_OFFSET || PivotNode == PivotEnd);

    while (PivotNode != INVALID_OFFSET) {

        KeyParent = GetKeyStruct (PivotNode);

        BalanceFlags = KeyParent->Flags & KSF_BALANCE_MASK;

        if (BalanceFlags == KSF_LEFT_HEAVY) {

            if (KeyParent->Left == PrevPivot) {

                MYASSERT (KeyStruct == GetKeyStruct (PrevPivot));

                if (KeyStruct->Flags & KSF_LEFT_HEAVY) {
                    //
                    // LL rotation
                    //

                    pRotateOnce (RootPtr, PivotNode, PrevPivot, KSF_LEFT_HEAVY);

                } else if (KeyStruct->Flags & KSF_RIGHT_HEAVY) {
                    //
                    // LR rotation
                    //

                    pRotateTwice (RootPtr, PivotNode, PrevPivot, KSF_LEFT_HEAVY);

                }

            } else {
                KeyParent->Flags = KeyParent->Flags & (~KSF_BALANCE_MASK);
            }

        } else if (BalanceFlags == KSF_RIGHT_HEAVY) {

            if (KeyParent->Right == PrevPivot) {

                MYASSERT (KeyStruct == GetKeyStruct (PrevPivot));

                if (KeyStruct->Flags & KSF_RIGHT_HEAVY) {
                    //
                    // RR rotation
                    //

                    pRotateOnce (RootPtr, PivotNode, PrevPivot, KSF_RIGHT_HEAVY);

                } else if (KeyStruct->Flags & KSF_LEFT_HEAVY) {
                    //
                    // RL rotation
                    //

                    pRotateTwice (RootPtr, PivotNode, PrevPivot, KSF_RIGHT_HEAVY);

                }

            } else {
                KeyParent->Flags = KeyParent->Flags & (~KSF_BALANCE_MASK);
            }

        } else {
            if (KeyParent->Right == PrevPivot) {
                KeyParent->Flags = (KeyParent->Flags & (~KSF_BALANCE_MASK)) | KSF_RIGHT_HEAVY;
            } else {
                KeyParent->Flags = (KeyParent->Flags & (~KSF_BALANCE_MASK)) | KSF_LEFT_HEAVY;
            }
        }

        if (PivotNode == PivotEnd) {
            break;
        }

        PrevPivot = PivotNode;
        PivotNode = KeyParent->Parent;
        KeyStruct = KeyParent;
    }
}


VOID
pBalanceDeletion (
    OUT     PDWORD RootPtr,
    IN      DWORD NodeNeedingAdjustment,
    IN      DWORD Direction
    )
{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT ChildStruct;
    DWORD ChildOffset;
    DWORD Node;
    DWORD AntiDirection;
    DWORD OldNode;
    DWORD OrgParent;

    Node = NodeNeedingAdjustment;
    MYASSERT (Node != INVALID_OFFSET);

    KeyStruct = GetKeyStruct (Node);

    for (;;) {

        MYASSERT (KeyStruct == GetKeyStruct (Node));
        AntiDirection = ANTIDIRECTION (Direction);
        OrgParent = KeyStruct->Parent;

        //
        // Case 1 - parent was initially balanced (terminates balancing)
        //

        if (!(KeyStruct->Flags & KSF_BALANCE_MASK)) {
            KeyStruct->Flags |= AntiDirection;
            break;
        }

        //
        // Case 2 - parent was heavy on side that was deleted
        //

        if (KeyStruct->Flags & Direction) {
            KeyStruct->Flags = KeyStruct->Flags & (~KSF_BALANCE_MASK);
        }

        //
        // Cases 3, 4 and 5 - deletion caused imbalance in parent
        //

        else {
            MYASSERT (KeyStruct->Flags & AntiDirection);

            ChildOffset = Direction == KSF_LEFT_HEAVY ?
                                KeyStruct->Right :
                                KeyStruct->Left;

            MYASSERT (ChildOffset != INVALID_OFFSET);

            ChildStruct = GetKeyStruct (ChildOffset);

            if (!(ChildStruct->Flags & KSF_BALANCE_MASK)) {
                //
                // Case 3 - single rotation needed (terminates balancing).  We
                //          don't care that Node changes during rotation.
                //

                pRotateOnce (RootPtr, Node, ChildOffset, AntiDirection);
                break;

            } else if (ChildStruct->Flags & Direction) {
                //
                // Case 4 - double rotation needed, Node is changed during rotation
                //

                Node = pRotateTwice (RootPtr, Node, ChildOffset, AntiDirection);

            } else {
                //
                // Case 5 - single rotation needed, Node is changed during rotation
                //

                Node = pRotateOnce (RootPtr, Node, ChildOffset, AntiDirection);
            }
        }

        //
        // Continue climbing the tree
        //

        OldNode = Node;
        Node = OrgParent;

        if (Node != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Node);

            if (KeyStruct->Left == OldNode) {
                Direction = KSF_LEFT_HEAVY;
            } else {
                Direction = KSF_RIGHT_HEAVY;
            }
        } else {
            break;
        }
    }


}


#ifdef DEBUG

VOID
DumpBinTreeStats (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "MemDb Binary Tree Stats:\n\n"
            "  Insertions: %u\n"
            "  Deletions: %u\n"
            "  Single Rotations: %u\n"
            "  Double Rotations: %u\n",
        g_Insertions,
        g_Deletions,
        g_SingleRotations,
        g_DoubleRotations
        ));
}


INT
pComputeHeight (
    IN      DWORD Offset
    )
{
    PKEYSTRUCT KeyStruct;
    INT Left, Right;

    if (Offset == INVALID_OFFSET) {
        return 0;
    }

    KeyStruct = GetKeyStruct (Offset);

    Left = pComputeHeight (KeyStruct->Left);
    Right = pComputeHeight (KeyStruct->Right);

    return 1 + max (Left, Right);
}


VOID
pMakeNum (
    OUT     PTSTR Msg,
    IN      DWORD Offset,
    IN      TCHAR LeftChar,
    IN      TCHAR RightChar
    )
{
    TCHAR Num[32];
    INT Len;
    PTSTR OrgMsg;
    INT i;

    _stprintf (Num, TEXT("%u"), Offset);
    Len = (6 - TcharCount (Num)) / 2;

    OrgMsg = Msg;

    for (i = 0 ; i < Len ; i++) {
        *Msg++ = LeftChar;
    }

    for (i = 0 ; Num[i] ; i++) {
        *Msg++ = Num[i];
    }

    OrgMsg += 6;
    while (Msg < OrgMsg) {
        *Msg++ = RightChar;
    }

    *Msg = 0;
}


VOID
pDumpTree (
    IN      DWORD Root,
    IN      PCSTR Title         OPTIONAL
    )
{
    DWORD Offset;
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD MaxLevel;
    DWORD Spaces;
    UINT u;
    TCHAR Msg[16384];
    UINT Pos;
    INT Pass;
    GROWBUFFER NodesA = GROWBUF_INIT;
    GROWBUFFER NodesB = GROWBUF_INIT;
    PGROWBUFFER Nodes;
    PGROWBUFFER NextNodes;
    PDWORD OffsetPtr;
    PDWORD EndOfList;
    INT HalfWidth;
    TCHAR LeftChar, RightChar;

    if (Root == INVALID_OFFSET) {
        return;
    }

    if (Title) {
        LOGDIRECTA (DBG_VERBOSE, "\r\n");
        LOGDIRECTA (DBG_VERBOSE, Title);
        LOGDIRECTA (DBG_VERBOSE, "\r\n\r\n");
    }

    for (Pass = 0 ; Pass < 2 ; Pass++) {

        MaxLevel = (DWORD) pComputeHeight (Root);
        MaxLevel = min (MaxLevel, 10);

        if (Pass == 0) {
            HalfWidth = 3;
            Spaces = 6;
        } else {
            HalfWidth = 1;
            Spaces = 2;
        }

        for (u = 1 ; u < MaxLevel ; u++) {
            Spaces *= 2;
        }

        NodesB.End = 0;
        Nodes = &NodesA;
        NextNodes = &NodesB;

        GrowBufAppendDword (NextNodes, Root);

        for (u = 0 ; u < MaxLevel ; u++) {

            //
            // Swap growbufs
            //

            if (Nodes == &NodesA) {
                Nodes = &NodesB;
                NextNodes = &NodesA;
            } else {
                Nodes = &NodesA;
                NextNodes = &NodesB;
            }

            NextNodes->End = 0;

            //
            // Process all nodes
            //

            EndOfList = (PDWORD) (Nodes->Buf + Nodes->End);

            for (OffsetPtr = (PDWORD) (Nodes->Buf) ; OffsetPtr < EndOfList ; OffsetPtr++) {

                //
                // Add all children as next nodes
                //

                Offset = *OffsetPtr;

                if (Offset == INVALID_OFFSET) {
                    GrowBufAppendDword (NextNodes, INVALID_OFFSET);
                    GrowBufAppendDword (NextNodes, INVALID_OFFSET);
                } else {
                    KeyStruct = GetKeyStruct (Offset);
                    GrowBufAppendDword (NextNodes, KeyStruct->Left);
                    GrowBufAppendDword (NextNodes, KeyStruct->Right);
                }

                //
                // Print current node
                //

                Pos = 0;

                LeftChar = TEXT(' ');
                RightChar = TEXT(' ');

                if (Offset != INVALID_OFFSET) {
                    KeyStruct = GetKeyStruct (Offset);

                    if (KeyStruct->Parent != INVALID_OFFSET) {

                        KeyParent = GetKeyStruct (KeyStruct->Parent);

                        if (KeyParent->Right == Offset) {
                            LeftChar = TEXT('\'');
                        } else if (KeyParent->Left == Offset) {
                            RightChar = TEXT('\'');
                        }
                    }

                    for ( ; Pos < (Spaces - HalfWidth) ; Pos++) {
                        Msg[Pos] = LeftChar;
                    }

                    if (Pass == 0) {
                        pMakeNum (Msg + Pos, Offset, LeftChar, RightChar);
                    } else {
                        _stprintf (Msg + Pos, TEXT("%2i"), FLAGS_TO_INT (KeyStruct->Flags & KSF_BALANCE_MASK));
                    }

                    Pos += TcharCount (Msg + Pos);
                }

                while (Pos < Spaces * 2) {
                    Msg[Pos] = RightChar;
                    Pos++;
                }

                Msg[Pos] = 0;

                LOGDIRECT (DBG_VERBOSE, Msg);

            }

            LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));

            for (OffsetPtr = (PDWORD) (Nodes->Buf) ; OffsetPtr < EndOfList ; OffsetPtr++) {

                Offset = *OffsetPtr;

                for (Pos = 0 ; Pos < Spaces ; Pos++) {
                    Msg[Pos] = TEXT(' ');
                }

                if (Offset != INVALID_OFFSET) {
                    KeyStruct = GetKeyStruct (*OffsetPtr);
                    if (KeyStruct->Left != INVALID_OFFSET ||
                        KeyStruct->Right != INVALID_OFFSET
                        ) {
                        Msg[Pos] = '|';
                        Pos++;
                    }
                }

                while (Pos < Spaces * 2) {
                    Msg[Pos] = TEXT(' ');
                    Pos++;
                }

                Msg[Pos] = 0;

                LOGDIRECT (DBG_VERBOSE, Msg);
            }

            Spaces /= 2;
            LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));

            Spaces = max (Spaces, 1);
        }

        LOGDIRECT (DBG_VERBOSE, TEXT("\r\n"));
    }

    FreeGrowBuffer (&NodesA);
    FreeGrowBuffer (&NodesB);
}


BOOL
pCheckTreeBalance (
    IN      DWORD Root,
    IN      BOOL Force
    )
{
    DWORD NextOffset;
    DWORD PrevOffset;
    DWORD Offset;
    PKEYSTRUCT KeyStruct;
    DWORD MinLevel = 0xFFFFFFFF;
    DWORD MaxLevel = 0;
    DWORD Level = 0;
    DWORD Nodes = 0;
    static DWORD SpotCheck = 0;

    //
    // Don't perform this check every single time
    //

    if (!Force) {
        SpotCheck++;
        if (SpotCheck == 10000) {
            SpotCheck = 0;
        } else {
            return FALSE;
        }
    }

    if (Root == INVALID_OFFSET) {
        return FALSE;
    }

    pCheckBalanceFactors (Root);

    NextOffset = Root;

    //
    // Get leftmost node
    //

    do {
        Offset = NextOffset;
        Level++;
        KeyStruct = GetKeyStruct (Offset);
        NextOffset = KeyStruct->Left;
    } while (NextOffset != INVALID_OFFSET);

    //
    // Recurse through entire tree
    //

    PrevOffset = INVALID_OFFSET;

    do {
        //
        // Visit node at Offset
        //

        Nodes++;
        KeyStruct = GetKeyStruct (Offset);

        if (KeyStruct->Left == INVALID_OFFSET ||
            KeyStruct->Right == INVALID_OFFSET
            ) {

            MinLevel = min (MinLevel, Level);
            MaxLevel = max (MaxLevel, Level);
        }

        //
        // Go to the next node
        //

        if (KeyStruct->Right != INVALID_OFFSET) {

            //
            // Go to left-most node of right
            //

            KeyStruct = GetKeyStruct (Offset);
            NextOffset = KeyStruct->Right;

            while (NextOffset != INVALID_OFFSET) {
                Offset = NextOffset;
                Level++;
                KeyStruct = GetKeyStruct (Offset);
                NextOffset = KeyStruct->Left;
            }
        }

        else {

            //
            // Go to parent, looping if its right child is the
            // previous node.
            //

            do {
                PrevOffset = Offset;
                Offset = KeyStruct->Parent;
                Level--;

                if (Offset == INVALID_OFFSET) {
                    break;
                }

                KeyStruct = GetKeyStruct (Offset);

            } while (KeyStruct->Right == PrevOffset);
        }

    } while (Offset != INVALID_OFFSET);

    DEBUGMSG_IF ((
        (MaxLevel - MinLevel) > 3,
        DBG_NAUSEA,
        "Binary tree imbalance detected: MinLevel=%u, MaxLevel=%u, Nodes=%u",
        MinLevel,
        MaxLevel,
        Nodes
        ));

    return TRUE;
}


INT
pComputeBalanceFactor (
    IN      DWORD Offset
    )
{
    PKEYSTRUCT KeyStruct;

    KeyStruct = GetKeyStruct (Offset);

    return pComputeHeight (KeyStruct->Right) - pComputeHeight (KeyStruct->Left);
}


VOID
pCheckBalanceFactors (
    IN      DWORD Root
    )
{
    DWORD Offset;
    INT Factor;
    PKEYSTRUCT KeyStruct;

    Offset = GetFirstOffset (Root);

    while (Offset != INVALID_OFFSET) {

        KeyStruct = GetKeyStruct (Offset);
        Factor = pComputeBalanceFactor (Offset);

        if ((Factor == -1 && !(KeyStruct->Flags & KSF_LEFT_HEAVY)) ||
            (Factor == 1  && !(KeyStruct->Flags & KSF_RIGHT_HEAVY)) ||
            (!Factor      &&  (KeyStruct->Flags & KSF_BALANCE_MASK))
            ) {

            pDumpTree (Root, "Tree Balance Factor Error");
            DEBUGMSG ((DBG_WHOOPS, "Tree balance factors are wrong!"));
            break;
        }

        if (Factor < -1 || Factor > 1) {

            pDumpTree (Root, "Balance Factor Out of Bounds.");
            DEBUGMSG ((DBG_WHOOPS, "Balance factors out of bounds!"));
            break;
       }



        Offset = GetNextOffset (Offset);
    }
}

#endif

PBYTE
pAllocMemoryFromDb (
    IN      UINT RequestSize,
    OUT     PDWORD Offset,
    OUT     PINT AdjustFactor
    )
{
    PBYTE result;
    PBYTE newBuf;

    //
    // Grow heap if necessary
    //

    *AdjustFactor = 0;

    if (RequestSize + g_db->End > g_db->AllocSize) {
        if (g_db->AllocSize < 0x100000) {
            g_db->AllocSize += BLOCK_SIZE;
        } else {
            g_db->AllocSize *= 2;
        }

        if (g_db->AllocSize >= MAX_MEMDB_SIZE) {
            OutOfMemory_Terminate ();
        }

        if (g_db->Buf) {
            newBuf = (PBYTE) MemReAlloc (g_hHeap, 0, g_db->Buf, g_db->AllocSize);
        } else {
            newBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_db->AllocSize);
        }

        if (!newBuf) {
            // g_db->AllocSize must be bigger than 2G
            OutOfMemory_Terminate();
        }

        //
        // provide relocation difference to caller
        //

        if (g_db->Buf) {
            *AdjustFactor = (INT) ((PBYTE) newBuf - (PBYTE) g_db->Buf);
        }

        g_db->Buf = newBuf;
    }

    result = g_db->Buf + g_db->End;
    *Offset = g_db->End;
    g_db->End += RequestSize;

    return result;
}

PKEYSTRUCT
pAllocKeyStructBlock (
    OUT     PDWORD Offset,
    OUT     PINT AdjustFactor
    )
{
    DWORD delOffset;
    DWORD prevDel;
    PKEYSTRUCT keyStruct = NULL;

    //
    // Look for free block
    //

    *AdjustFactor = 0;

    prevDel = INVALID_OFFSET;
    delOffset = g_db->FirstDeleted;

    while (delOffset != INVALID_OFFSET) {
        keyStruct = GetKeyStruct (delOffset);
        prevDel = delOffset;
        delOffset = keyStruct->NextDeleted;
    }

    //
    // Alloc new block if no free space
    //

    if (delOffset == INVALID_OFFSET) {

        //
        // Calc position in block
        //

        keyStruct = (PKEYSTRUCT) pAllocMemoryFromDb (sizeof (KEYSTRUCT), Offset, AdjustFactor);

    } else {
        //
        // Delink free block if recovering free space
        //

        *Offset = delOffset;

        if (prevDel != INVALID_OFFSET) {
            GetKeyStruct (prevDel)->NextDeleted = keyStruct->NextDeleted;
        } else {
            g_db->FirstDeleted = keyStruct->NextDeleted;
        }
    }

    return keyStruct;
}


DWORD
pAllocKeyStruct (
    IN OUT PDWORD ParentOffsetPtr,
    IN     PCWSTR KeyName,
    IN     DWORD PrevLevelNode
    )

/*++

Routine Description:

  pAllocKeyStruct allocates a block of memory in the single
  heap, expanding it if necessary.

  The KeyName must not already be in the tree, and
  ParentOffsetPtr must point to a valid DWORD offset
  variable.  ParentOffsetPtr, or one of the children
  of ParentOffsetPtr, will be linked to the new struct.

Arguments:

  ParentOffsetPtr  - Address of a DWORD that holds the offset to
                     the root.  Within the function, the variable
                     will change to point to the parent of the
                     new struct.

  KeyName - The string identifying the key.  It cannot
            contain backslashes.  The new struct will
            be initialized and this name will be copied
            into the struct.

  PrevLevelNode - Specifies the previous level root offset

Return Value:

  An offset to the new structure.

--*/

{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    DWORD Offset;
    DWORD NodeOffsetParent;
    INT cmp;
    DWORD PivotEnd;
    PDWORD RootPtr;
    INT adjustFactor;
    DWORD newToken;

    INCSTAT(g_Insertions);

#ifdef DEBUG
    pCheckTreeBalance (*ParentOffsetPtr, FALSE);
#endif

    KeyStruct = pAllocKeyStructBlock (
                    &Offset,
                    &adjustFactor
                    );

    //
    // Database might have moved. Relocate any pointers within the database now.
    //

    if (ParentOffsetPtr != &g_db->FirstLevelRoot) {
        ParentOffsetPtr = (PDWORD) ((PBYTE) ParentOffsetPtr + adjustFactor);
    }

    //
    // Init new block
    //

    KeyStruct->NextLevelRoot = INVALID_OFFSET;
    KeyStruct->PrevLevelNode = PrevLevelNode;
    KeyStruct->Left = INVALID_OFFSET;
    KeyStruct->Right = INVALID_OFFSET;
    KeyStruct->dwValue = 0;
    KeyStruct->Flags = 0;
#ifdef DEBUG
    KeyStruct->Signature = SIGNATURE;
#endif

    newToken = pAllocKeyToken (KeyName, &adjustFactor);

    //
    // Again the database might have moved
    //

    KeyStruct = (PKEYSTRUCT) ((PBYTE) KeyStruct + adjustFactor);

    if (ParentOffsetPtr != &g_db->FirstLevelRoot) {
        ParentOffsetPtr = (PDWORD) ((PBYTE) ParentOffsetPtr + adjustFactor);
    }

    //
    // finish updating keystruct
    //

    KeyStruct->KeyToken = newToken;

    //
    // Put it in the tree
    //

    NodeOffsetParent = INVALID_OFFSET;
    PivotEnd = INVALID_OFFSET;
    RootPtr = ParentOffsetPtr;

    while (*ParentOffsetPtr != INVALID_OFFSET) {

        NodeOffsetParent = *ParentOffsetPtr;

        KeyParent = GetKeyStruct (*ParentOffsetPtr);

        if (KeyParent->Flags & KSF_BALANCE_MASK) {
            PivotEnd = *ParentOffsetPtr;
        }

        cmp = StringICompareW (KeyName, GetKeyToken (KeyParent->KeyToken));

        if (cmp < 0) {
            ParentOffsetPtr = &KeyParent->Left;
        } else if (cmp > 0) {
            ParentOffsetPtr = &KeyParent->Right;
        } else {
            MYASSERT (FALSE);
        }
    }

    KeyStruct->Parent = NodeOffsetParent;
    *ParentOffsetPtr = Offset;

#ifdef DEBUG
    // If using retail structs, delete Signature from BlockPtr
    if (!g_UseDebugStructs) {
        MoveMemory (
            KeyStruct,
            (PCBYTE) KeyStruct + (sizeof (KEYSTRUCT_DEBUG) - sizeof (KEYSTRUCT_RETAIL)),
            sizeof (KEYSTRUCT_RETAIL)
            );
    }
#endif

    //
    // Balance the tree
    //

    pBalanceInsertion (RootPtr, Offset, PivotEnd);

#ifdef DEBUG
    pCheckTreeBalance (*RootPtr, FALSE);
#endif

    return Offset;
}


VOID
pDeallocKeyStruct (
    IN      DWORD Offset,
    IN OUT  PDWORD RootPtr,
    IN      BOOL DelinkFlag,
    IN      BOOL ClearFlag
    )

/*++

Routine Description:

  pDeallocKeyStruct first deletes all structures pointed to by
  NextLevelRoot.  After all items are deleted from the next
  level, pDeallocKeyStruct optionally delinks the struct from
  the binary tree.  Before exiting, the struct is given to the
  deleted block chain.

Arguments:

  Offset      - An offset to the item as provided by pAllocKeyStruct
                or any of the Find functions.
  RootPtr     - A pointer to the level tree root variable.  This value
                will be updated if delinking is involved.
  DelinkFlag  - A flag indicating TRUE to delink the struct from
                the binary tree it is in, or FALSE if the struct is
                only to be added to the deleted block chain.
  ClearFlag   - Specifies FALSE if the key struct's children are to
                be deleted, or TRUE if the current key struct should
                simply be cleaned up but left allocated.

Return Value:

  none

--*/

{
    PKEYSTRUCT KeyStruct;
    PKEYSTRUCT KeyParent;
    PKEYSTRUCT KeyChild;
    PKEYSTRUCT KeyLeftmost;
    PKEYSTRUCT KeyLeftChild;
    PKEYSTRUCT KeyRightChild;
    DWORD Leftmost;
    DWORD NodeOffset;
    PDWORD ParentOffsetPtr;
    WCHAR TempStr[MEMDB_MAX];
    DWORD Direction = 0;
    DWORD RebalanceOffset;

    KeyStruct = GetKeyStruct (Offset);

    //
    // Remove endpoints from hash table
    //

    if (KeyStruct->Flags & KSF_ENDPOINT) {
        PrivateBuildKeyFromOffset (0, Offset, TempStr, NULL, NULL, NULL);
        RemoveHashTableEntry (TempStr);

        //
        // Free binary value on key
        //

        FreeKeyStructBinaryBlock (KeyStruct);
        KeyStruct->Flags &= ~KSF_ENDPOINT;
    }

    //
    // Call recursively if there are sublevels to this key
    //

    if (!ClearFlag) {
        if (KeyStruct->NextLevelRoot != INVALID_OFFSET) {

            NodeOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

            while (NodeOffset != INVALID_OFFSET) {
                pDeallocKeyStruct (NodeOffset, &KeyStruct->NextLevelRoot, FALSE, FALSE);
                NodeOffset = GetNextOffset (NodeOffset);
            }
        }

        //
        // Remove the item from its binary tree
        //

        if (DelinkFlag) {
            //
            // Find parent-to-child pointer
            //

            if (KeyStruct->Parent != INVALID_OFFSET) {

                KeyParent = GetKeyStruct (KeyStruct->Parent);

                if (KeyParent->Left == Offset) {
                    ParentOffsetPtr = &KeyParent->Left;
                    Direction = KSF_LEFT_HEAVY;
                } else {
                    ParentOffsetPtr = &KeyParent->Right;
                    Direction = KSF_RIGHT_HEAVY;
                }

            } else {
                ParentOffsetPtr = RootPtr;
            }

            if (KeyStruct->Left == INVALID_OFFSET &&
                KeyStruct->Right == INVALID_OFFSET
                ) {
                //
                // No children; reset parent, then rebalance tree
                //

                *ParentOffsetPtr = INVALID_OFFSET;
                RebalanceOffset = KeyStruct->Parent;

            } else if (KeyStruct->Left == INVALID_OFFSET) {
                //
                // Only a right child; bring it up a level and rebalance
                //

                *ParentOffsetPtr = KeyStruct->Right;
                KeyChild = GetKeyStruct (*ParentOffsetPtr);
                KeyChild->Parent = KeyStruct->Parent;

                //
                // The moved node's balance factor must be set the same as the
                // node we are deleting.  The rebalancing will correct it.
                //

                KeyChild->Flags = (KeyChild->Flags & (~KSF_BALANCE_MASK)) |
                                  (KeyStruct->Flags & KSF_BALANCE_MASK);

                Direction = KSF_RIGHT_HEAVY;
                RebalanceOffset = KeyStruct->Right;

            } else if (KeyStruct->Right == INVALID_OFFSET) {

                //
                // Only a left child; bring it up a level and rebalance
                //

                *ParentOffsetPtr = KeyStruct->Left;
                KeyChild = GetKeyStruct (*ParentOffsetPtr);
                KeyChild->Parent = KeyStruct->Parent;

                //
                // The moved node's balance factor must be set the same as the
                // node we are deleting.  The rebalancing will correct it.
                //

                KeyChild->Flags = (KeyChild->Flags & (~KSF_BALANCE_MASK)) |
                                  (KeyStruct->Flags & KSF_BALANCE_MASK);

                Direction = KSF_LEFT_HEAVY;
                RebalanceOffset = KeyStruct->Left;

            } else {

                //
                // Two children - find min val of right subtree (the leftmost node
                // of the right child).
                //

                Leftmost = KeyStruct->Right;

                KeyLeftmost = GetKeyStruct (Leftmost);

                while (KeyLeftmost->Left != INVALID_OFFSET) {
                    Leftmost = KeyLeftmost->Left;
                    KeyLeftmost = GetKeyStruct (Leftmost);
                }

                //
                // If Leftmost has right children, and it is not the
                // right child of the node we are deleting, then
                // hook right subtree to parent.
                //
                // If Leftmost does not have right children, then
                // remove its parent's linkage
                //

                if (Leftmost != KeyStruct->Right) {

                    KeyParent = GetKeyStruct (KeyLeftmost->Parent);

                    if (KeyLeftmost->Right != INVALID_OFFSET) {

                        //
                        // Because of the balance properties, we know that
                        // we have a single leaf node to the right.  Its
                        // balance factor is zero, and we move it to a
                        // position where it remains zero.
                        //

                        KeyRightChild = GetKeyStruct (KeyLeftmost->Right);
                        MYASSERT (KeyRightChild->Left == INVALID_OFFSET);
                        MYASSERT (KeyRightChild->Right == INVALID_OFFSET);

                        KeyParent->Left = KeyLeftmost->Right;
                        KeyRightChild->Parent = KeyLeftmost->Parent;

                    } else {

                        KeyParent->Left = INVALID_OFFSET;
                    }

                    //
                    // We are affecting the balance factor of the
                    // parent.  Rebalancing must start at the leftmost
                    // node's parent.
                    //

                    RebalanceOffset = KeyLeftmost->Parent;
                    Direction = KSF_LEFT_HEAVY;     // we deleted from the left side

                } else {
                    //
                    // In this case there is no leftmost node of the right child.
                    // Therefore, we reduced the height of the right side.
                    //

                    RebalanceOffset = Leftmost;
                    Direction = KSF_RIGHT_HEAVY;
                }

                //
                // Now leftmost is available to replace the deleted
                // node
                //

                KeyLeftmost->Parent = KeyStruct->Parent;
                *ParentOffsetPtr = Leftmost;

                KeyLeftmost->Left = KeyStruct->Left;
                KeyLeftChild = GetKeyStruct (KeyStruct->Left);
                KeyLeftChild->Parent = Leftmost;

                if (Leftmost != KeyStruct->Right) {

                    KeyLeftmost->Right = KeyStruct->Right;
                    MYASSERT (KeyStruct->Right != INVALID_OFFSET);

                    KeyRightChild = GetKeyStruct (KeyStruct->Right);
                    KeyRightChild->Parent = Leftmost;
                }

                //
                // We need to copy the balance factor of what we are deleting to the
                // replacement node.
                //

                KeyLeftmost->Flags = (KeyLeftmost->Flags & (~KSF_BALANCE_MASK)) |
                                     (KeyStruct->Flags & KSF_BALANCE_MASK);

            }

            //
            // Rebalance the tree
            //

            if (RebalanceOffset != INVALID_OFFSET) {
                MYASSERT (Direction);

                if (Direction) {
                    //pDumpTree (*RootPtr, "Before rebalance");
                    pBalanceDeletion (RootPtr, RebalanceOffset, Direction);
                    //pDumpTree (*RootPtr, "Final tree");
                }
            }

#ifdef DEBUG
            pCheckTreeBalance (*RootPtr, FALSE);
#endif

        }

        //
        // Donate block to free space unless caller does not
        // want child structs freed.
        //

        pDeallocToken (KeyStruct->KeyToken);
        KeyStruct->NextDeleted = g_db->FirstDeleted;

        g_db->FirstDeleted = Offset;
    }
}


VOID
pRemoveHashEntriesForNode (
    IN      PCWSTR Root,
    IN      DWORD Offset
    )

/*++

Routine Description:

  pRemoveHashEntriesFromNode removes all hash table entries from all children
  of the specified node.  This function is called recursively.

Arguments:

  Root   - Specifies the root string that corresponds with Offset.  This must
           also contain the temporary hive root.
  Offset - Specifies the offset of the node to process.  The node and all of
           its children will be removed from the hash table.

Return Value:

  None.

--*/

{
    DWORD ChildOffset;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;

    //
    // Remove hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Offset);

    if (KeyStruct->Flags & KSF_ENDPOINT) {
        RemoveHashTableEntry (Root);

#ifdef DEBUG
        {
            DWORD HashOffset;

            HashOffset = FindStringInHashTable (Root, NULL);
            if (HashOffset != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb move duplicate: %s", Root));
            }
        }
#endif
    }

    //
    // Recurse for all children, removing hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

    while (ChildOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildOffset);
        StringCopyW (End, GetKeyToken (KeyStruct->KeyToken));
        pRemoveHashEntriesForNode (ChildRoot, ChildOffset);

        ChildOffset = GetNextOffset (ChildOffset);
    }
}


VOID
pAddHashEntriesForNode (
    IN      PCWSTR Root,
    IN      DWORD Offset,
    IN      BOOL AddRoot
    )

/*++

Routine Description:

  pAddHashEntriesForNode adds hash table entries for the specified root and
  all of its children.

Arguments:

  Root    - Specifies the root string that corresponds to Offset.  This string
            must also include the temporary hive root.
  Offset  - Specifies the node offset to begin processing.  The node and all
            of its children are added to the hash table.
  AddRoot - Specifies TRUE if the root should be added to the hash table,
            FALSE otherwise.


Return Value:

  None.

--*/

{
    DWORD ChildOffset;
    PKEYSTRUCT KeyStruct;
    WCHAR ChildRoot[MEMDB_MAX];
    PWSTR End;
    DWORD HashOffset;

    //
    // Add hash entry if this root is an endpoint
    //

    KeyStruct = GetKeyStruct (Offset);

    if (AddRoot && KeyStruct->Flags & KSF_ENDPOINT) {

        HashOffset = FindStringInHashTable (Root, NULL);

        if (HashOffset != Offset) {

#ifdef DEBUG
            if (HashOffset != INVALID_OFFSET) {
                DEBUGMSG ((DBG_WARNING, "Memdb duplicate: %s", Root));
            }
#endif

            AddHashTableEntry (Root, Offset);
        }
    }

    //
    // Recurse for all children, adding hash entries for all endpoints found
    //

    StringCopyW (ChildRoot, Root);
    End = GetEndOfStringW (ChildRoot);
    *End = L'\\';
    End++;
    *End = 0;

    ChildOffset = GetFirstOffset (KeyStruct->NextLevelRoot);

    while (ChildOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (ChildOffset);
        StringCopyW (End, GetKeyToken (KeyStruct->KeyToken));
        pAddHashEntriesForNode (ChildRoot, ChildOffset, TRUE);

        ChildOffset = GetNextOffset (ChildOffset);
    }
}


BOOL
pFindPlaceForNewNode (
    IN      PKEYSTRUCT InsertNode,
    IN      PDWORD TreeRootPtr,
    OUT     PDWORD ParentOffsetPtr,
    OUT     PDWORD *ParentToChildOffsetPtr,
    OUT     PDWORD PivotEnd
    )

/*++

Routine Description:

  pFindPlaceForNewNode searches a level for the position within the tree.
  This is used to insert new unique keys in the tree.

Arguments:

  InsertNode             - Specifies the allocated but unlinked node.  Its
                           Key member must be valid.
  TreeRootPtr            - Specifies a pointer to the memory that holds the
                           root offset.  This is used to walk the tree.  It
                           can be INVALID_OFFSET.
  ParentOffsetPtr        - Receives the offset to the parent node
  ParentToChildOffsetPtr - Recieves the address of the left or right child
                           pointer within the parent struct
  PivotEnd               - Receives the offset of the tree node that should
                           stop balancing

Return Value:

  TRUE if a spot was found in the tree for InsertNode, or FALSE if a spot was
  not found (because the key name is already in the tree).

--*/

{
    PDWORD ParentPtr;
    PKEYSTRUCT Parent;
    INT cmp;

    ParentPtr = TreeRootPtr;
    *ParentOffsetPtr = INVALID_OFFSET;
    *PivotEnd = INVALID_OFFSET;

    while (*ParentPtr != INVALID_OFFSET) {

        *ParentOffsetPtr = *ParentPtr;
        Parent = GetKeyStruct (*ParentPtr);

        if (Parent->Flags & KSF_BALANCE_MASK) {
            *PivotEnd = *ParentPtr;
        }

        cmp = StringICompareW (GetKeyToken (InsertNode->KeyToken), GetKeyToken (Parent->KeyToken));

        if (cmp < 0) {
            ParentPtr = &Parent->Left;
        } else if (cmp > 0) {
            ParentPtr = &Parent->Right;
        } else {
            return FALSE;
        }
    }

    *ParentToChildOffsetPtr = ParentPtr;

    return TRUE;
}


VOID
pMergeFamilies (
    IN      PDWORD DestTreeRootPtr,
    IN      DWORD MergeSrcOffset,
    IN      DWORD MergeDestPrevLevelOffset
    )

/*++

Routine Description:

  pMergeFamilies takes two tree families and merges them together.  When
  duplicates are found, their linkage is abandoned, but they are not
  deallocated.  This allows MemDbBuildKeyFromOffset to continue to work.

Arguments:

  DestTreeRootPtr          - Specifies the address of the destination level's
                             root variable.  This is potentially altered with
                             insertion and balancing.
  MergeSrcOffset           - Specifies the offset to the source tree family
                             (STF).  The STF is merged into the destination
                             tree indicated by DestTreeRootPtr.
  MergeDestPrevLevelOffset - Specifies the offset to the previous level node.
                             This value cannot be INVALID_OFFSET.

Return Value:

  None.

--*/

{
    PKEYSTRUCT MergeSrc;
    PKEYSTRUCT MergeDest;
    PDWORD ParentToChildOffsetPtr;
    DWORD ParentOffset;
    DWORD DestCollisionOffset;
    DWORD PivotEnd;
    GROWBUFFER NextLevelMerge = GROWBUF_INIT;
    DWORD NodeOffset;
    PDWORD NextLevelOffsetPtr;
    UINT Pos;
    BOOL FoundPlaceForNode;

    //
    // Look for a place within the tree indicated by the offset
    // stored in DestTreeRootPtr.  If one is found, we can simply
    // relink the node at MergeSrcOffset.  Otherwise, we have to
    // recursively merge the next level of MergeSrcOffset, and
    // we have to abandon MergeSrcOffset.
    //

    MergeSrc = GetKeyStruct (MergeSrcOffset);
    MYASSERT (MergeSrc);

    FoundPlaceForNode = pFindPlaceForNewNode (
                            MergeSrc,
                            DestTreeRootPtr,
                            &ParentOffset,
                            &ParentToChildOffsetPtr,
                            &PivotEnd
                            );

    if (FoundPlaceForNode) {
        //
        // Since we found a place to put the src family, it is
        // easy to hook it and its next level into the dest
        // family.
        //

        MergeSrc->Parent = ParentOffset;
        *ParentToChildOffsetPtr = MergeSrcOffset;

        MergeSrc->Flags = MergeSrc->Flags & (~KSF_BALANCE_MASK);
        MergeSrc->Left = INVALID_OFFSET;
        MergeSrc->Right = INVALID_OFFSET;
        MergeSrc->PrevLevelNode = MergeDestPrevLevelOffset;

        pBalanceInsertion (DestTreeRootPtr, MergeSrcOffset, PivotEnd);

#ifdef DEBUG
        pCheckTreeBalance (*DestTreeRootPtr, FALSE);
#endif

    } else {
        //
        // We found a collision, then we have to abandon MergeSrc,
        // removing linkage to the parent and children -- but preserving
        // the linkage to the previous level.  Finally, we have to call
        // this function recursively to hook up all the next level nodes.
        //

        DestCollisionOffset = ParentOffset;      // renamed to be more accurate

        MergeDest = GetKeyStruct (DestCollisionOffset);
        MYASSERT (MergeDest);

        MergeSrc->Parent = INVALID_OFFSET;
        MergeSrc->Left = INVALID_OFFSET;
        MergeSrc->Right = INVALID_OFFSET;
        MergeSrc->PrevLevelNode = MergeDestPrevLevelOffset;

        //
        // If this is an end point, then try to preserve value and flags
        //

        if (MergeSrc->Flags & KSF_ENDPOINT) {

            if (MergeDest->Flags & KSF_ENDPOINT) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "MemDb: Loss of value and flags in %s",
                    GetKeyToken (MergeSrc->KeyToken)
                    ));

            } else {
                MergeDest->Flags = MergeDest->Flags & ~KSF_FLAGS_TO_COPY;
                MergeDest->Flags |= MergeSrc->Flags & KSF_FLAGS_TO_COPY;
                MergeDest->dwValue = MergeSrc->dwValue;
            }
        }

        //
        // Save away all entries in the next src level into a grow buffer,
        // then call pMergeFamilies recursively.
        //

        NodeOffset = GetFirstOffset (MergeSrc->NextLevelRoot);

        while (NodeOffset != INVALID_OFFSET) {

            NextLevelOffsetPtr = (PDWORD) GrowBuffer (&NextLevelMerge, sizeof (DWORD));
            MYASSERT (NextLevelOffsetPtr);

            *NextLevelOffsetPtr = NodeOffset;
            NodeOffset = GetNextOffset (NodeOffset);
        }

        NextLevelOffsetPtr = (PDWORD) NextLevelMerge.Buf;

        for (Pos = 0 ; Pos < NextLevelMerge.End ; Pos += sizeof (DWORD)) {

            pMergeFamilies (
                &MergeDest->NextLevelRoot,
                *NextLevelOffsetPtr,
                DestCollisionOffset
                );

            NextLevelOffsetPtr++;

        }

        FreeGrowBuffer (&NextLevelMerge);
    }
}


DWORD
pMoveKey (
    IN      DWORD OriginalKey,
    IN      PCWSTR NewKeyRoot,
    IN      PCWSTR NewKeyRootWithHive
    )

/*++

Routine Description:

  pMoveKey moves a key (and all of its children) to a new root.  If the
  caller specifies a source key that has no children, a proxy node is created
  to maintain offsets.  The proxy node is not listed in the hash table.

Arguments:

  OriginalKey        - Specifies the offset to the original key that needs to
                       be moved.  It does not need to be an endpoint, and may
                       have children.
  NewKeyRoot         - Specifies the new root for OriginalKey.  It may have
                       multiple levels (separated by backslashes).
  NewKeyRootWithHive - Different from NewKeyRoot only when the node is in a
                       temporary hive.  This is used for the hash table only.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    DWORD ReplacementKey;
    PKEYSTRUCT SrcKey, DestKey, ChildKey;
    PKEYSTRUCT KeyParent;
    DWORD NodeOffset;
    GROWBUFFER Children = GROWBUF_INIT;
    PDWORD ChildOffsetPtr;
    DWORD Pos;
    WCHAR OriginalRoot[MEMDB_MAX];
    BOOL Endpoint;

    //
    // Check requirements
    //

    SrcKey = GetKeyStruct (OriginalKey);
    if (!SrcKey) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: pMoveKey can't find original key %s", OriginalKey));
        return INVALID_OFFSET;
    }

    if (SrcKey->Flags & KSF_PROXY_NODE) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: pMoveKey can't move proxy node %s", OriginalKey));
        return INVALID_OFFSET;
    }

    Endpoint = SrcKey->Flags & KSF_ENDPOINT;

    if (!PrivateBuildKeyFromOffset (0, OriginalKey, OriginalRoot, NULL, NULL, NULL)) {
        return INVALID_OFFSET;
    }

    //
    // Allocate new key
    //

    ReplacementKey = pNewKey (NewKeyRoot, NewKeyRootWithHive, FALSE);

    if (ReplacementKey == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    SrcKey = GetKeyStruct (OriginalKey);
    DestKey = GetKeyStruct (ReplacementKey);

    if (!SrcKey || !DestKey) {
        return INVALID_OFFSET;
    }

    DEBUGMSG ((DBG_NAUSEA, "Moving %s to %s", OriginalRoot, NewKeyRootWithHive));

    //
    // Remove all hash entries for all children
    //

    pRemoveHashEntriesForNode (OriginalRoot, OriginalKey);

    //
    // Record all children in an array
    //

    NodeOffset = GetFirstOffset (SrcKey->NextLevelRoot);

    while (NodeOffset != INVALID_OFFSET) {
        ChildOffsetPtr = (PDWORD) GrowBuffer (&Children, sizeof (DWORD));
        if (!ChildOffsetPtr) {
            return INVALID_OFFSET;
        }

        *ChildOffsetPtr = NodeOffset;

        NodeOffset = GetNextOffset (NodeOffset);
    }

    //
    // Move next level pointer to new node.  There are two cases
    // to handle:
    //
    //  1. Destination exists and has children.  Here the source
    //     needs to be merged into the destination.
    //
    //  2. Destination is brand new and has no children.  Here we
    //     simply move the source children to the destination.
    //
    // During this process, the hash table is updated accordingly.
    //

    if (DestKey->NextLevelRoot != INVALID_OFFSET) {
        //
        // Hard case, merge children to new parent's family
        //

        ChildOffsetPtr = (PDWORD) Children.Buf;

        for (Pos = 0 ; Pos < Children.End ; Pos += sizeof (DWORD)) {

            pMergeFamilies (
                &DestKey->NextLevelRoot,
                *ChildOffsetPtr,
                ReplacementKey
                );

            ChildOffsetPtr++;

        }

    } else {
        //
        // Easy case, link children to new parent
        //

        DestKey->NextLevelRoot = SrcKey->NextLevelRoot;
        SrcKey->NextLevelRoot = INVALID_OFFSET;

        if (DestKey->Flags & KSF_ENDPOINT) {
            DEBUGMSG ((
                DBG_WARNING,
                "MemDb: Loss of value and flags in %s",
                GetKeyToken (SrcKey->KeyToken)
                ));

        } else {
            DestKey->Flags = DestKey->Flags & ~KSF_FLAGS_TO_COPY;
            DestKey->Flags |= SrcKey->Flags & KSF_FLAGS_TO_COPY;
            DestKey->dwValue = SrcKey->dwValue;
        }

        ChildOffsetPtr = (PDWORD) Children.Buf;

        for (Pos = 0 ; Pos < Children.End ; Pos += sizeof (DWORD)) {
            NodeOffset = *ChildOffsetPtr;
            ChildOffsetPtr++;

            ChildKey = GetKeyStruct (NodeOffset);
            ChildKey->PrevLevelNode = ReplacementKey;
        }
    }

    //
    // Add all new entries to hash table
    //

    pAddHashEntriesForNode (NewKeyRootWithHive, ReplacementKey, FALSE);

    //
    // Free the original key node, or if an endpoint, make the
    // node a proxy to the new node (to maintain offsets).
    //

    if (!Endpoint) {

        SrcKey->NextLevelRoot = INVALID_OFFSET;
        KeyParent = GetKeyStruct (SrcKey->PrevLevelNode);
        pDeallocKeyStruct (OriginalKey, &KeyParent->NextLevelRoot, TRUE, FALSE);

    } else {

        DestKey->Flags   = (DestKey->Flags & KSF_BALANCE_MASK) | (SrcKey->Flags & (~KSF_BALANCE_MASK));
        DestKey->dwValue = SrcKey->dwValue;

        SrcKey->Flags = KSF_PROXY_NODE | (SrcKey->Flags & KSF_BALANCE_MASK);
        SrcKey->dwValue = ReplacementKey;
        SrcKey->NextLevelRoot = INVALID_OFFSET;
    }

    FreeGrowBuffer (&Children);

    return ReplacementKey;
}


BOOL
MemDbMoveTreeA (
    IN      PCSTR RootNode,
    IN      PCSTR NewRoot
    )

/*++

Routine Description:

  MemDbMoveTree is the external interface to pMoveKey.  See description in
  pMoveKey for details.

Arguments:

  RootNode - Specifies the node to move.

  NewRoot - Specifies the new root for RootNode.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PCWSTR UnicodeRootNode;
    PCWSTR UnicodeNewRoot;
    BOOL b = FALSE;

    UnicodeRootNode = ConvertAtoW (RootNode);
    UnicodeNewRoot = ConvertAtoW (NewRoot);

    if (UnicodeRootNode && UnicodeNewRoot) {
        b = MemDbMoveTreeW (UnicodeRootNode, UnicodeNewRoot);
    }

    FreeConvertedStr (UnicodeRootNode);
    FreeConvertedStr (UnicodeNewRoot);

    return b;
}


BOOL
MemDbMoveTreeW (
    IN      PCWSTR RootNode,
    IN      PCWSTR NewRoot
    )
{
    DWORD Offset;
    WCHAR Temp[MEMDB_MAX];
    WCHAR NewRootWithHive[MEMDB_MAX];
    PWSTR p, q;
    PCWSTR SubKey;
    BOOL b = FALSE;
    INT HiveLen;

    if (StringIMatch (RootNode, NewRoot)) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot move tree because source and dest are the same"));
        return FALSE;
    }

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (RootNode);

        //
        // Copy key to temp buffer
        //

        StringCopyW (Temp, SubKey);

        if (*Temp == 0) {
            DEBUGMSG ((DBG_WHOOPS, "MemDbMoveTree requires a root"));
            __leave;
        }

        //
        // Compute the new root with the original hive
        //

        if (StringIMatchW (Temp, RootNode)) {
            // no hive case
            StringCopyW (NewRootWithHive, NewRoot);
        } else {
            HiveLen = wcslen (RootNode) - wcslen (SubKey);
            StringCopyTcharCountW (NewRootWithHive, RootNode, HiveLen);
            StringCopyW (AppendWackW (NewRootWithHive), NewRoot);
        }

        //
        // Find the last offset of the root key
        //

        q = Temp;
        Offset = INVALID_OFFSET;

        do {

            if (Offset == INVALID_OFFSET) {
                Offset = g_db->FirstLevelRoot;
            } else {
                Offset = GetKeyStruct (Offset)->NextLevelRoot;
            }

            if (Offset == INVALID_OFFSET) {
                DEBUGMSGW ((DBG_VERBOSE, "MemDbMoveTree root %s not found", RootNode));
                __leave;
            }

            p = wcschr (q, L'\\');
            if (p) {
                *p = 0;
            }

            Offset = FindKeyStruct (Offset, q);

            if (Offset == INVALID_OFFSET) {
                DEBUGMSGW ((DBG_VERBOSE, "MemDbMoveTree root %s not found", RootNode));
                __leave;
            }

            q = p + 1;

        } while (p);

        //
        // Now move the key
        //

        Offset = pMoveKey (Offset, NewRoot, NewRootWithHive);

        if (Offset != INVALID_OFFSET) {
            b = TRUE;
        } else {
            DEBUGMSGW ((DBG_WHOOPS, "Can't move %s to %s", RootNode, NewRoot));
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


PKEYSTRUCT
pGetKeyStructWithProxy (
    IN DWORD Offset
    )

/*++

Routine Description:

  pGetKeyStructWithProxy returns a pointer given an offset.  It also implements proxy
  nodes, transparent to the rest of memdb.  The debug version checks the
  signature and validity of each offset.  It is assumed that Offset is always
  valid.

Arguments:

  Offset - Specifies the offset to the node

Return Value:

  The pointer to the node.

--*/

{
    PKEYSTRUCT KeyStruct;

#ifdef DEBUG

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in pGetKeyStructWithProxy at offset %u", Offset));
        return NULL;
    }

    if (!g_db->Buf) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }

    if (Offset > g_db->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in pGetKeyStructWithProxy (offset %u)", Offset));
        return NULL;
    }
#endif

    KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset);


#ifdef DEBUG

    if (!g_UseDebugStructs) {

        KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset - sizeof (DWORD));

    } else if (KeyStruct->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in pGetKeyStructWithProxy at offset %u!", Offset));
        return NULL;
    }

#endif

    if (KeyStruct->Flags & KSF_PROXY_NODE) {
        return pGetKeyStructWithProxy (KeyStruct->dwValue);
    }

    return KeyStruct;
}


PKEYSTRUCT
GetKeyStruct (
    IN DWORD Offset
    )

/*++

Routine Description:

  GetKeyStruct returns a pointer given an offset.  It does not support proxy
  nodes, so the rest of memdb accesses the unaltered tree.  The debug version
  checks the signature and validity of each offset.  It is assumed that Offset
  is always valid.

Arguments:

  Offset - Specifies the offset to the node

Return Value:

  The pointer to the node.

--*/

{
    PKEYSTRUCT KeyStruct;

#ifdef DEBUG

    if (Offset == INVALID_OFFSET) {
        DEBUGMSG ((DBG_ERROR, "Invalid root accessed in GetKeyStruct at offset %u", Offset));
        return NULL;
    }

    if (!g_db->Buf) {
        DEBUGMSG ((DBG_ERROR, "Attempt to access non-existent buffer at %u", Offset));
        return NULL;
    }

    if (Offset > g_db->End) {
        DEBUGMSG ((DBG_ERROR, "Access beyond length of buffer in GetKeyStruct (offset %u)", Offset));
        return NULL;
    }
#endif

    KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset);


#ifdef DEBUG

    if (!g_UseDebugStructs) {

        KeyStruct = (PKEYSTRUCT) (g_db->Buf + Offset - sizeof (DWORD));

    } else if (KeyStruct->Signature != SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "Signature does not match in GetKeyStruct at offset %u!", Offset));
        return NULL;
    }

#endif

    return KeyStruct;
}


DWORD
FindKeyStruct (
    IN DWORD RootOffset,
    IN PCWSTR KeyName
    )

/*++

Routine Description:

  FindKeyStruct takes a key name and looks for the
  offset in the tree specified by RootOffset.  The key
  name must not contain backslashes.

Arguments:

  RootOffset - An offset to the root of the level

  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;
    int cmp;

    //
    // Walk the binary tree looking for KeyName
    //

    while (RootOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (RootOffset);
        cmp = StringICompareW (KeyName, GetKeyToken (KeyStruct->KeyToken));
        if (!cmp) {
            break;
        }

        if (cmp < 0) {
            RootOffset = KeyStruct->Left;
        } else {
            RootOffset = KeyStruct->Right;
        }
    }

    return RootOffset;
}


DWORD
GetFirstOffset (
    IN  DWORD RootOffset
    )

/*++

Routine Description:

  GetFirstOffset walks down the left side of the binary tree
  pointed to by RootOffset, and returns the left-most node.

Arguments:

  RootOffset    - An offset to the root of the level

Return Value:

  An offset to the leftmost structure, or INVALID_OFFSET if the
  root was invalid.

--*/


{
    PKEYSTRUCT KeyStruct;

    if (RootOffset == INVALID_OFFSET) {
        return INVALID_OFFSET;
    }

    //
    // Go to leftmost node of root
    //

    KeyStruct = GetKeyStruct (RootOffset);
    while (KeyStruct->Left != INVALID_OFFSET) {
        RootOffset = KeyStruct->Left;
        KeyStruct = GetKeyStruct (RootOffset);
    }

    return RootOffset;
}


DWORD
GetNextOffset (
    IN  DWORD NodeOffset
    )

/*++

Routine Description:

  GetNextOffset traverses the binary tree in order.  This
  technique relies on parent links to traverse without a
  stack or recursion.

Arguments:

  NodeOffset  - Offset to a node in the tree, usually the
            return value from GetFirstOffset or GetNextOffset.

Return Value:

  An offset to the next structure, or INVALID_OFFSET if the
  end is reached.

--*/

{
    PKEYSTRUCT KeyStruct;
    DWORD Last;

    KeyStruct = GetKeyStruct (NodeOffset);

    //
    // If right child exist, go to leftmost node of right child
    //

    if (KeyStruct->Right != INVALID_OFFSET) {

        //
        // Go to right child
        //

        NodeOffset = KeyStruct->Right;

        //
        // Go to left-most of right child
        //

        KeyStruct = GetKeyStruct (NodeOffset);
        while (KeyStruct->Left != INVALID_OFFSET) {
            NodeOffset = KeyStruct->Left;
            KeyStruct = GetKeyStruct (NodeOffset);
        }
    }

    //
    // Else move up to parent
    //

    else {
        //
        // Climb to top of processed nodes
        //

        do {
            Last = NodeOffset;
            NodeOffset = KeyStruct->Parent;

            if (NodeOffset != INVALID_OFFSET) {
                KeyStruct = GetKeyStruct (NodeOffset);
            } else {
                break;  // reached the root of tree
            }
        } while (Last == KeyStruct->Right);
    }

    return NodeOffset;
}


DWORD
pFindPatternKeyStruct (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR KeyName
    )

/*++

Routine Description:

  pFindPatternKeyStruct takes a key name and looks for the
  offset in the tree specified by RootOffset.  The key name must
  not contain backslashes, and the stored key name is
  treated as a pattern.

Arguments:

  RootOffset - An offset to the root of the level
  NodeOffset - The previous return value from pFindPatternKeyStruct
               (for enumeration) or INVALID_OFFSET for the first
               call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    //
    // if NodeOffset is invalid, this is the first search item
    //

    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    //
    // otherwise advance NodeOffset
    //

    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }


    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key (string in KeyStruct->KeyToken is the pattern)
        if (IsPatternMatchW (GetKeyToken (KeyStruct->KeyToken), KeyName)) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
pFindKeyStructUsingPattern (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR PatternStr
    )

/*++

Routine Description:

  pFindKeyStructUsingPattern takes a key pattern and looks
  for the offset in the tree specified by RootOffset.  The key
  name must not contain backslashes, but can contain wildcards.

Arguments:

  RootOffset - An offset to the root of the level

  NodeOffset - The previous return value from pFindPatternKeyStruct
               (for enumeration) or INVALID_OFFSET for the first
               call.

  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    // if NodeOffset is invalid, this is the first search item
    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    // otherwise advance NodeOffset
    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }

    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key
        if (IsPatternMatchW (PatternStr, GetKeyToken (KeyStruct->KeyToken))) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
pFindPatternKeyStructUsingPattern (
    IN  DWORD RootOffset,
    IN  DWORD NodeOffset,
    IN  PCWSTR PatternStr
    )

/*++

Routine Description:

  pFindPatternKeyStructUsingPattern takes a key pattern and looks
  for the offset in the tree specified by RootOffset.  The key name
  must not contain backslashes, but can contain wildcards.  The
  wildcards in the stored key are processed as well.

Arguments:

  RootOffset      - An offset to the root of the level
  NodeOffset      - The previous return value from pFindPatternKeyStruct
                (for enumeration) or INVALID_OFFSET for the first
                call.
  KeyName - The name of the key to find in the binary tree

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    PKEYSTRUCT KeyStruct;

    // if NodeOffset is invalid, this is the first search item
    if (NodeOffset == INVALID_OFFSET) {
        NodeOffset = GetFirstOffset (RootOffset);
    }

    // otherwise advance NodeOffset
    else {
        NodeOffset = GetNextOffset (NodeOffset);
    }


    //
    // Examine key as a pattern, then go to next node
    //

    while (NodeOffset != INVALID_OFFSET) {
        KeyStruct = GetKeyStruct (NodeOffset);

        // Compare key (PatternStr is the pattern)
        if (IsPatternMatchW (PatternStr, GetKeyToken (KeyStruct->KeyToken))) {
            return NodeOffset;
        }

        // Compare key (string in KeyStruct->KeyToken is the pattern)
        if (IsPatternMatchW (GetKeyToken (KeyStruct->KeyToken), PatternStr)) {
            return NodeOffset;
        }

        // No match yet - go to next node
        NodeOffset = GetNextOffset (NodeOffset);
    }

    return INVALID_OFFSET;
}


DWORD
FindKey (
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKey locates a complete key string and returns
  the offset to the KEYSTRUCT, or INVALID_OFFSET if
  the key path does not exist.  The FullKeyPath
  must supply the complete path to the KEYSTRUCT.

Arguments:

  FullKeyPath - A backslash-delimited key path to a value

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    return FindStringInHashTable (FullKeyPath, NULL);
}


DWORD
FindPatternKey (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath,
    IN  BOOL EndPatternAllowed
    )

/*++

Routine Description:

  FindPatternKey locates a complete key string and returns
  the offset to the KEYSTRUCT, or INVALID_OFFSET if the
  key path does not exist.  Each stored part of the key is
  treated as a pattern, and FullKeyPath must supply the
  complete path to the KEYSTRUCT without wildcards.

Arguments:

  RootOffset        - An offset to the level's binary tree root
  FullKeyPath       - A backslash-delimited key path to a value
                      without wildcards.
  EndPatternAllowed - Specifies TRUE if the stored pattern can
                      have an asterisk at the end, to indicate
                      any subkeys, or FALSE if the pattern matches
                      on the same level only.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PCWSTR End;

    //
    // Divide the string into a multi-sz
    //

    StackStringCopyW (Path, FullKeyPath);

    for (p = Path ; *p ; p++) {
        if (*p == L'\\') {
            *p = 0;
        }
    }

    End = p;
    if (End > Path && *(End - 1) == 0) {
        //
        // Special case: the wack was at the end of the string.
        // Therefore, inc End so we test that final empty value.
        //

        End++;
    }

    if (End == Path) {
        DEBUGMSG ((DBG_ERROR, "FindPatternKey: Empty key not allowed"));
        return INVALID_OFFSET;
    }

    //
    // Now test the key against all stored patterns
    //

    return pFindPatternKeyWorker (Path, End, RootOffset, EndPatternAllowed);
}


DWORD
pFindPatternKeyWorker (
    IN      PCWSTR SubKey,
    IN      PCWSTR End,
    IN      DWORD RootOffset,
    IN      BOOL EndPatternAllowed
    )
{
    DWORD Offset;
    PCWSTR NextSubKey;
    DWORD MatchOffset;
    PKEYSTRUCT KeyStruct;

    NextSubKey = GetEndOfString (SubKey) + 1;

    // Begin an enumeration of the matches
    Offset = pFindPatternKeyStruct (RootOffset, INVALID_OFFSET, SubKey);

    while (Offset != INVALID_OFFSET) {
        //
        // Is there more in the caller's key string to test?
        //

        if (NextSubKey < End) {
            //
            // Yes, call pFindPatternKeyWorker recursively
            //

            MatchOffset = pFindPatternKeyWorker (
                                NextSubKey,
                                End,
                                GetKeyStruct (Offset)->NextLevelRoot,
                                EndPatternAllowed
                                );

            if (MatchOffset != INVALID_OFFSET) {
                //
                // We found one match.  There may be others, but
                // we return this one.
                //

                return MatchOffset;
            }

        } else {
            //
            // No, if this is an endpoint, return the match.
            //

            KeyStruct = GetKeyStruct (Offset);

            if (KeyStruct->Flags & KSF_ENDPOINT) {
                return Offset;
            }
        }

        // Continue enumeration
        Offset = pFindPatternKeyStruct (RootOffset, Offset, SubKey);
    }

    //
    // The normal search failed.  Now we test for an endpoint that has
    // just an asterisk.  If we find one, we return it as our match.
    // This only applies when we have more subkeys, and EndPatternAllowed
    // is TRUE.
    //

    if (NextSubKey < End && EndPatternAllowed) {
        // Begin another enumeration of the matches
        Offset = pFindPatternKeyStruct (RootOffset, INVALID_OFFSET, SubKey);

        while (Offset != INVALID_OFFSET) {
            //
            // If EndPatternAllowed is TRUE, then test this offset
            // for an exact match with an asterisk.
            //

            KeyStruct = GetKeyStruct (Offset);

            if (KeyStruct->Flags & KSF_ENDPOINT) {
                if (StringMatchW (GetKeyToken (KeyStruct->KeyToken), L"*")) {
                    return Offset;
                }
            }

            // Continue enumeration
            Offset = pFindPatternKeyStruct (RootOffset, Offset, SubKey);
        }
    }


    //
    // No match was found
    //

    return INVALID_OFFSET;
}



DWORD
FindKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  FindKeyUsingPattern locates a key string using a pattern
  and returns the offset to the KEYSTRUCT, or INVALID_OFFSET
  if the key path does not exist.  Each part of the stored key
  is treated as a literal string.

Arguments:

  RootOffset  - An offset to the level's binary tree root

  FullKeyPath - A backslash-delimited key path to a value
                with optional wildcards.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, NextLevelOffset;

    StackStringCopyW (Path, FullKeyPath);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, '\\');
    if (p) {
        End = _wcsinc (p);
        *p = 0;
    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Offset = pFindKeyStructUsingPattern (RootOffset, INVALID_OFFSET, Start);

    //
    // If this is the last level, we may have found the key!
    //

    if (!End) {
        while (Offset != INVALID_OFFSET) {
            if (GetKeyStruct (Offset)->Flags & KSF_ENDPOINT) {
                return Offset;
            }

            Offset = pFindKeyStructUsingPattern (RootOffset, Offset, Start);
        }
    }

    //
    // Otherwise recursively examine next level
    //

    while (Offset != INVALID_OFFSET) {

        //
        // Look at all subkeys for a match
        //

        NextLevelOffset = GetKeyStruct (Offset)->NextLevelRoot;
        NextLevelOffset = FindKeyUsingPattern (NextLevelOffset, End);

        //
        // When the recursive search succeeded, propagate the return value
        //

        if (NextLevelOffset != INVALID_OFFSET) {
            return NextLevelOffset;
        }

        //
        // No match, continue looking in this level for another match
        //

        Offset = pFindKeyStructUsingPattern (RootOffset, Offset, Start);
    }

    return INVALID_OFFSET;
}


DWORD
FindPatternKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    )

/*++

Routine Description:

  pFindPatternKeyUsingPattern locates a patterned key string
  using a pattern and returns the offset to the KEYSTRUCT,
  or INVALID_OFFSET if the key path does not exist.  Each
  part of the key is treated as a pattern.

Arguments:

  RootOffset          - An offset to the level's binary tree root
  FullKeyPath - A backslash-delimited key path to a value
                    with optional wildcards.

Return Value:

  An offset to the structure, or INVALID_OFFSET if the key
  was not found.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, NextLevelOffset;

    StackStringCopyW (Path, FullKeyPath);
    End = Path;

    // Split string at backslash
    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = p + 1;
        *p = 0;
    }
    else
        End = NULL;

    // Look at this level for the very first key
    Offset = pFindPatternKeyStructUsingPattern (RootOffset, INVALID_OFFSET, Start);

    // If this is the last level, we may have found the key!
    if (!End) {
        while (Offset != INVALID_OFFSET) {
            if (GetKeyStruct (Offset)->Flags & KSF_ENDPOINT)
                return Offset;

            Offset = pFindPatternKeyStructUsingPattern (RootOffset, Offset, Start);
        }
    }

    // Otherwise recursively examine next level
    while (Offset != INVALID_OFFSET) {

        // Look at all subkeys for a match
        NextLevelOffset = GetKeyStruct (Offset)->NextLevelRoot;
        NextLevelOffset = FindPatternKeyUsingPattern (NextLevelOffset, End);

        // When the recursive search succeeded, propagate the return value
        if (NextLevelOffset != INVALID_OFFSET)
            return NextLevelOffset;

        // No match, continue looking in this level for another match
        Offset = pFindPatternKeyStructUsingPattern (RootOffset, Offset, Start);
    }

    return INVALID_OFFSET;
}


DWORD
pNewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive,
    IN  BOOL Endpoint
    )

/*++

Routine Description:

  NewKey allocates a key struct off our heap, and links it into the binary
  tree.  KeyStr must be a full key path, and any part of the path that does
  not exist will be created.  KeyStr must not already exist (though parts
  of it can exist).

Arguments:

  KeyStr - The full path to the value, separated by backslashes.
           Each string between backslashes will cause a key
           struct to be allocated and linked.  Some of the
           structs may already have been allocated.

  KeyStrWithHive - The full path to the value, plus the hive
                   prefix (if any).  Can be the same as KeyStr
                   if there is no hive prefix.

  Endpoint - Specifies TRUE if new node is an endpoint, or FALSE if
             it is not.

Return Value:

  An offset to the last node of the new structure, or
  INVALID_OFFSET if the key could not be allocated.

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset, ThisLevelRoot;
    PDWORD ParentOffsetPtr;
    PKEYSTRUCT KeyStruct;
    DWORD LastLevel;
    BOOL NewNodeCreated = FALSE;

    StackStringCopyW (Path, KeyStr);
    End = Path;
    ThisLevelRoot = g_db->FirstLevelRoot;
    ParentOffsetPtr = &g_db->FirstLevelRoot;
    LastLevel = INVALID_OFFSET;

    do  {
        // Split string at backslash
        Start = End;
        p = wcschr (End, L'\\');
        if (p) {
            End = p + 1;
            *p = 0;
        }
        else
            End = NULL;

        // Look in tree for key
        if (!NewNodeCreated) {
            Offset = FindKeyStruct (ThisLevelRoot, Start);
        } else {
            Offset = INVALID_OFFSET;
        }

        if (Offset == INVALID_OFFSET) {
            // Add a new key if it was not found
            Offset = pAllocKeyStruct (ParentOffsetPtr, Start, LastLevel);
            if (Offset == INVALID_OFFSET) {
                return Offset;
            }

            NewNodeCreated = TRUE;
        }

        // Continue to next level
        KeyStruct = GetKeyStruct (Offset);
        LastLevel = Offset;
        ThisLevelRoot = KeyStruct->NextLevelRoot;
        ParentOffsetPtr = &KeyStruct->NextLevelRoot;
    } while (End);

    if (Endpoint) {
        if (!(KeyStruct->Flags & KSF_ENDPOINT)) {
            NewNodeCreated = TRUE;
        }

        KeyStruct->Flags |= KSF_ENDPOINT;

        if (NewNodeCreated) {
            AddHashTableEntry (KeyStr, Offset);
        }
    }

    return Offset;
}


DWORD
NewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive
    )
{
    return pNewKey (KeyStr, KeyStrWithHive, TRUE);
}


VOID
DeleteKey (
    IN      PCWSTR KeyStr,
    IN OUT  PDWORD RootPtr,
    IN      BOOL MustMatch
    )

/*++

Routine Description:

  DeleteKey takes a key path and puts the key struct in the deleted
  block chain.  Any sub-levels are deleted as well.  Optionally,
  the binary tree in which the key participates in may be updated.

Arguments:

  KeyStr     - The full path to the value, separated by backslashes.
  RootPtr    - A pointer to the level's binary tree root variable.
               If necessary, the variable is updated.
  MustMatch  - A flag indicating if the delete only applies to
               end points or if any matching struct is to be deleted.
               TRUE indicates only endpoints can be deleted.

Return Value:

  none

--*/

{
    WCHAR Path[MEMDB_MAX];
    PWSTR p;
    PWSTR Start, End;
    DWORD Offset;
    DWORD NextOffset;
    PKEYSTRUCT KeyStruct;

    INCSTAT(g_Deletions);

    StackStringCopyW (Path, KeyStr);
    End = Path;

    //
    // Split string at backslash
    //

    Start = End;
    p = wcschr (End, L'\\');
    if (p) {
        End = _wcsinc (p);
        *p = 0;

    } else {
        End = NULL;
    }

    //
    // Look at this level for the very first key
    //

    Offset = pFindKeyStructUsingPattern (*RootPtr, INVALID_OFFSET, Start);

    //
    // If this is the last level, delete the matching keys
    // (may need to be endpoints if MustMatch is TRUE)
    //

    if (!End) {
        while (Offset != INVALID_OFFSET) {
            KeyStruct = GetKeyStruct (Offset);
            NextOffset = pFindKeyStructUsingPattern (*RootPtr, Offset, Start);

            //
            // If must match and lower levels exist, don't delete, just turn
            // off the endpoint flag
            //

            if (MustMatch && KeyStruct->NextLevelRoot != INVALID_OFFSET) {
                // Call to clean up, not to delink or recurse
                pDeallocKeyStruct (Offset, RootPtr, FALSE, TRUE);
            }

            //
            // Else delete the struct if an endpoint or don't care about
            // endpoints
            //

            else if (!MustMatch || (KeyStruct->Flags & KSF_ENDPOINT)) {
                // Call to free the entire key struct and all children
                pDeallocKeyStruct (Offset, RootPtr, TRUE, FALSE);
            }

            Offset = NextOffset;
        }
    }

    //
    // Otherwise recursively examine next level for each match
    //

    else {
        while (Offset != INVALID_OFFSET) {
            //
            // Delete all matching subkeys
            //

            NextOffset = pFindKeyStructUsingPattern (*RootPtr, Offset, Start);
            DeleteKey (End, &GetKeyStruct (Offset)->NextLevelRoot, MustMatch);

            //
            // If this is not an endpoint and has no children, delete it
            //

            KeyStruct = GetKeyStruct (Offset);
            if (KeyStruct->NextLevelRoot == INVALID_OFFSET &&
                !(KeyStruct->Flags & KSF_ENDPOINT)
                ) {
                // Call to free the entire key struct
                pDeallocKeyStruct (Offset, RootPtr, TRUE, FALSE);
            }

            //
            // Continue looking in this level for another match
            //

            Offset = NextOffset;
        }
    }
}


VOID
CopyValToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    )
{
    if (ValPtr) {
        if (!(KeyStruct->Flags & KSF_BINARY)) {
            *ValPtr = KeyStruct->dwValue;
        } else {
            *ValPtr = 0;
        }
    }
}


VOID
CopyFlagsToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    )
{
    if (ValPtr) {
        *ValPtr = KeyStruct->Flags & KSF_USERFLAG_MASK;
    }
}


BOOL
PrivateBuildKeyFromOffset (
    IN      DWORD StartLevel,               // zero-based
    IN      DWORD TailOffset,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PDWORD ValPtr,                  OPTIONAL
    OUT     PDWORD UserFlagsPtr,            OPTIONAL
    OUT     PDWORD Chars                    OPTIONAL
    )

/*++

Routine Description:

  PrivateBuildKeyFromOffset generates the key string given an offset.  The
  caller can specify the start level to skip root nodes.  It is assumed that
  TailOffset is always valid.

Arguments:

  StartLevel   - Specifies the zero-based level to begin building the key
                 string.  This is used to skip the root portion of the key
                 string.
  TailOffset   - Specifies the offset to the last level of the key string.
  Buffer       - Receives the key string, must be able to hold MEMDB_MAX
                 characters.
  ValPtr       - Receives the key's value
  UserFlagsPtr - Receives the user flags
  Chars        - Receives the number of characters in Buffer

Return Value:

  TRUE if the key was build properly, FALSE otherwise.

--*/

{
    static DWORD Offsets[MEMDB_MAX];
    PKEYSTRUCT KeyStruct;
    DWORD CurrentOffset;
    DWORD OffsetEnd;
    DWORD OffsetStart;
    register PWSTR p;
    register PCWSTR s;

    //
    // Build string
    //

    OffsetEnd = MEMDB_MAX;
    OffsetStart = OffsetEnd;

    CurrentOffset = TailOffset;
    while (CurrentOffset != INVALID_OFFSET) {
        //
        // Record offset
        //
        OffsetStart--;
        Offsets[OffsetStart] = CurrentOffset;

        //
        // Dec for start level and go to parent
        //
        CurrentOffset = pGetKeyStructWithProxy (CurrentOffset)->PrevLevelNode;
    }

    //
    // Filter for "string is not long enough"
    //
    OffsetStart += StartLevel;
    if (OffsetStart >= OffsetEnd) {
        return FALSE;
    }

    //
    // Transfer node's value and flags to caller's variables
    //
    CopyValToPtr (pGetKeyStructWithProxy (TailOffset), ValPtr);
    CopyFlagsToPtr (pGetKeyStructWithProxy (TailOffset), UserFlagsPtr);

    //
    // Copy each piece of the string to Buffer and calculate character count
    //
    if (Buffer) {
        p = Buffer;
        for (CurrentOffset = OffsetStart ; CurrentOffset < OffsetEnd ; CurrentOffset++) {
            KeyStruct = pGetKeyStructWithProxy (Offsets[CurrentOffset]);
            s = GetKeyToken (KeyStruct->KeyToken);
            while (*s) {
                *p++ = *s++;
            }
            *p++ = L'\\';
        }
        p--;
        *p = 0;

        if (Chars) {
            *Chars = (p - Buffer) / sizeof (WCHAR);
        }

    } else if (Chars) {
        *Chars = 0;

        for (CurrentOffset = OffsetStart ; CurrentOffset < OffsetEnd ; CurrentOffset++) {
            KeyStruct = pGetKeyStructWithProxy (Offsets[CurrentOffset]);
            *Chars += wcslen(GetKeyToken (KeyStruct->KeyToken)) + 1;
        }

        *Chars -= 1;
    }

    return TRUE;
}


UINT
pComputeTokenHash (
    IN      PCWSTR KeyName
    )
{
    UINT hash;

    hash = 0;
    while (*KeyName) {
        hash = (hash << 1) ^ (*KeyName++);
    }

    return hash % TOKENBUCKETS;
}


DWORD
pFindKeyToken (
    IN      PCWSTR KeyName,
    OUT     PUINT Hash
    )
{
    DWORD offset;
    PTOKENSTRUCT tokenStruct;
    INT cmp;

    *Hash = pComputeTokenHash (KeyName);

    offset = g_db->TokenBuckets[*Hash];

    while (offset != INVALID_OFFSET) {
        tokenStruct = (PTOKENSTRUCT) (g_db->Buf + offset);
        if (StringMatchW (tokenStruct->String, KeyName)) {
            break;
        }

        offset = tokenStruct->Right;
    }

    return offset;
}


DWORD
pAllocKeyToken (
    IN      PCWSTR KeyName,
    OUT     PINT AdjustFactor
    )
{
    PTOKENSTRUCT tokenStruct;
    PTOKENSTRUCT tokenParent;
    DWORD tokenOffset;
    UINT size;
    PDWORD parentToChildLink;
    DWORD newNodeParentOffset;
    DWORD pivotPoint;
    INT cmp;
    UINT hash;

    //
    // Use existing token first
    //

    tokenOffset = pFindKeyToken (KeyName, &hash);
    if (tokenOffset != INVALID_OFFSET) {
        *AdjustFactor = 0;
        return tokenOffset;
    }

    //
    // Existing token does not exist -- allocate a new one
    //

    size = sizeof (TOKENSTRUCT) + SizeOfStringW (KeyName);

    tokenStruct = (PTOKENSTRUCT) pAllocMemoryFromDb (
                                        size,
                                        &tokenOffset,
                                        AdjustFactor
                                        );

    tokenStruct->Right = g_db->TokenBuckets[hash];
    StringCopyW (tokenStruct->String, KeyName);
    g_db->TokenBuckets[hash] = tokenOffset;

    return tokenOffset;
}


VOID
pDeallocToken (
    IN      DWORD Token
    )
{
    return;
}


PCWSTR
GetKeyToken (
    IN      DWORD Token
    )
{
    PTOKENSTRUCT tokenStruct;

    tokenStruct = (PTOKENSTRUCT) (g_db->Buf + Token);
    return tokenStruct->String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\fileops.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  fileops.c

Abstract:

  This file implements routines that manage the operations on files.  Callers
  can set and remove operations on any path.  The operations can have optional
  properties.  The operation combinations and the number of properties are
  well-defined, so that potential collisions can be found during testing.

Author:

  Jim Schmidt (jimschm) 18-Jul-1997

Revision History:

  jimschm   26-Aug-1998   Redesigned!!  Consolidated functionality into generic
                          linkage: path<->operation(s)->attrib(s)
  jimschm   24-Aug-1998   Added shell folder support
  jimschm   01-May-1998   Added handled directory to GetFileStatusOnNt
  calinn    21-Apr-1998   added AddCompatibleShell, AddCompatibleRunKey and AddCompatibleDos
  calinn    02-Apr-1998   added DeclareTemporaryFile
  calinn    18-Jan-1998   added MigrationPhase_AddCompatibleFile
                          turned off warning in MigrationPhase_CreateFile
                          modified MigrationPhase_DeleteFile and MigrationPhase_MoveFile
                          modified GetFileInfoOnNt for short file names
  calinn    05-Jan-1998   added IsFileMarkedForAnnounce, AnnounceFileInReport,
                          GetFileInfoOnNt, GetFileStatusOnNt, GetPathStringOnNt

--*/

#include "pch.h"
#include "memdbp.h"

#define DBG_MEMDB       "MemDb"

#define FO_ENUM_BEGIN               0
#define FO_ENUM_BEGIN_PATH_ENUM     1
#define FO_ENUM_BEGIN_PROP_ENUM     2
#define FO_ENUM_RETURN_PATH         3
#define FO_ENUM_RETURN_DATA         4
#define FO_ENUM_NEXT_PROP           5
#define FO_ENUM_NEXT_PATH           6
#define FO_ENUM_END                 7

//
//140 - header for compresion file, 10 + 2 timestamp +
//MAX_PATH file name in Unicode
//
#define STARTUP_INFORMATION_BYTES_NUMBER    (140 + (sizeof(WCHAR) * MAX_PATH) + 26)
#define COMPRESSION_RATE_DEFAULT            70
#define BACKUP_DISK_SPACE_PADDING_DEFAULT   ((ULONGLONG) 5 << (ULONGLONG) 20)
#define UNKNOWN_DRIVE                       '?'



PCWSTR g_CurrentUser = NULL;

BOOL
pGetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    );

BOOL
pIsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    );

UINT
pAddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      BOOL Force,
    IN      BOOL AlreadyLong
    );

VOID
pFileOpsSetPathTypeW (
    IN      PCWSTR LongFileSpec
    )
{
    WCHAR ShortFileSpec[MAX_WCHAR_PATH];
    WCHAR LongFileSpecCopy[MAX_WCHAR_PATH];
    WCHAR MixedFileSpec[MAX_WCHAR_PATH];
    PWSTR p;
    PWSTR LongStart, LongEnd;
    PWSTR ShortStart, ShortEnd;
    PWSTR MixedFileName;
    WCHAR ch;

    //
    // Make sure the file spec is marked as a long path
    //

    if (!pIsFileMarkedForOperationW (LongFileSpec, OPERATION_LONG_FILE_NAME)) {
        pAddOperationToPathW (LongFileSpec, OPERATION_LONG_FILE_NAME, FALSE, TRUE);

        //
        // Obtain the short path, and if it is different than the
        // long path, add an operation for it.
        //

        if (OurGetShortPathNameW (LongFileSpec, ShortFileSpec, MAX_WCHAR_PATH)) {

            if (!StringIMatchW (LongFileSpec, ShortFileSpec)) {
                //
                // The short and long paths differ, so record the short path.
                //

                if (!pIsFileMarkedForOperationW (ShortFileSpec, OPERATION_SHORT_FILE_NAME)) {
                    AssociatePropertyWithPathW (
                        ShortFileSpec,
                        OPERATION_SHORT_FILE_NAME,
                        LongFileSpec
                        );
                }

                //
                // Make sure each short piece of the file spec is added.  This
                // allows us to support mixed short and long paths.  It is
                // critical that we have the long path with a short file name.
                //

                _wcssafecpy (LongFileSpecCopy, LongFileSpec, sizeof (LongFileSpecCopy));

                LongStart = LongFileSpecCopy;
                ShortStart = ShortFileSpec;
                MixedFileName = MixedFileSpec;

                while (*LongStart && *ShortStart) {

                    LongEnd = wcschr (LongStart, L'\\');
                    if (!LongEnd) {
                        LongEnd = GetEndOfStringW (LongStart);
                    }

                    ShortEnd = wcschr (ShortStart, L'\\');
                    if (!ShortEnd) {
                        ShortEnd = GetEndOfStringW (ShortStart);
                    }

                    StringCopyABW (MixedFileName, ShortStart, ShortEnd);

                    if (!StringIMatchABW (MixedFileName, LongStart, LongEnd)) {

                        if (!pIsFileMarkedForOperationW (MixedFileSpec, OPERATION_SHORT_FILE_NAME)) {
                            ch = *LongEnd;
                            *LongEnd = 0;

                            AssociatePropertyWithPathW (
                                MixedFileSpec,
                                OPERATION_SHORT_FILE_NAME,
                                LongFileSpecCopy
                                );

                            *LongEnd = ch;
                        }

                        StringCopyABW (MixedFileName, LongStart, LongEnd);
                    }

                    p = MixedFileName + (LongEnd - LongStart);
                    *p = L'\\';
                    MixedFileName = p + 1;

                    LongStart = LongEnd;
                    if (*LongStart) {
                        LongStart++;
                    }

                    // skip paths that have double-wacks
                    while (*LongStart == L'\\') {
                        LongStart++;
                    }

                    ShortStart = ShortEnd;
                    if (*ShortStart) {
                        ShortStart++;
                    }
                }

                MYASSERT (!*LongStart && !*ShortStart);
            }
        }
    }
}


VOID
pFileOpsGetLongPathW (
    IN      PCWSTR FileSpec,
    OUT     PWSTR LongFileSpec
    )
{
    WCHAR Replacement[MEMDB_MAX];
    PCWSTR MixedStart, MixedEnd;
    PWSTR OutStr;
    UINT u;

    //
    // Get the short property from the long property
    //

    if (!pIsFileMarkedForOperationW (FileSpec, OPERATION_LONG_FILE_NAME)) {

        if (!pGetPathPropertyW (FileSpec, OPERATION_SHORT_FILE_NAME, 0, LongFileSpec)) {

            //
            // The short and long properties aren't there.  Try each piece.
            //

            MixedStart = FileSpec;
            OutStr = LongFileSpec;

            while (*MixedStart) {

                MixedEnd = wcschr (MixedStart, L'\\');
                if (!MixedEnd) {
                    MixedEnd = GetEndOfStringW (MixedStart);
                }

                if (OutStr != LongFileSpec) {
                    *OutStr++ = L'\\';
                }

                StringCopyABW (OutStr, MixedStart, MixedEnd);

                if (pGetPathPropertyW (LongFileSpec, OPERATION_SHORT_FILE_NAME, 0, Replacement)) {

                    u = (UINT) (UINT_PTR) (OutStr - LongFileSpec);
                    MYASSERT (StringIMatchTcharCountW (LongFileSpec, Replacement, u));

                    StringCopyW (LongFileSpec + u, Replacement + u);
                }

                OutStr = GetEndOfStringW (OutStr);

                MixedStart = MixedEnd;
                if (*MixedStart) {
                    MixedStart++;
                }
            }

            *OutStr = 0;
        }

    } else {
        StringCopyW (LongFileSpec, FileSpec);
    }
}

PCSTR
GetSourceFileLongNameA (
    IN      PCSTR ShortName
    )
{
    PCWSTR UShortName;
    PCWSTR ULongName;
    PCSTR ALongName;
    PCSTR LongName;

    UShortName = ConvertAtoW (ShortName);
    ULongName = GetSourceFileLongNameW (UShortName);
    ALongName = ConvertWtoA (ULongName);
    LongName = DuplicatePathStringA (ALongName, 0);
    FreeConvertedStr (ALongName);
    FreePathString (ULongName);
    FreeConvertedStr (UShortName);

    return LongName;
}

PCWSTR
GetSourceFileLongNameW (
    IN      PCWSTR ShortName
    )
{
    WCHAR LongName[MEMDB_MAX];
    pFileOpsGetLongPathW (ShortName, LongName);
    return (DuplicatePathStringW (LongName, 0));
}

PCWSTR
SetCurrentUserW (
    PCWSTR User
    )
{
    PCWSTR tempUser = g_CurrentUser;
    g_CurrentUser = User;
    return tempUser;
}




DWORD g_MasterSequencer = 0;


#define ONEBITSET(x)    ((x) && !((x) & ((x) - 1)))



typedef struct {
    DWORD Bit;
    PCSTR Name;
    DWORD SharedOps;
    UINT MaxProps;
} OPERATIONFLAGS, *POPERATIONFLAGS;

#define UNLIMITED   0xffffffff

#define DEFMAC(bit,name,memdbname,maxattribs)   {bit,#memdbname,0,maxattribs},

OPERATIONFLAGS g_OperationFlags[] = {
    PATH_OPERATIONS /* , */
    {0, NULL, 0, 0}
};

#undef DEFMAC



UINT
pWhichBitIsSet (
    OPERATION Value
    )
{
    UINT Bit = 0;

    MYASSERT (ONEBITSET(Value));

    while (Value /= 2) {
        Bit++;
    }

    MYASSERT (Bit < 24);

    return Bit;
}


VOID
pProhibitOperationCombination (
    IN      DWORD SourceOperations,
    IN      DWORD ProhibitedOperations
    )
{
    DWORD w1, w2;
    OPERATION OperationA;
    OPERATION OperationB;

    for (w1 = SourceOperations ; w1 ; w1 ^= OperationA) {
        OperationA = w1 & (~(w1 - 1));

        g_OperationFlags[pWhichBitIsSet (OperationA)].SharedOps &= ~ProhibitedOperations;

        for (w2 = ProhibitedOperations ; w2 ; w2 ^= OperationB) {
            OperationB = w2 & (~(w2 - 1));
            g_OperationFlags[pWhichBitIsSet (OperationB)].SharedOps &= ~OperationA;
        }
    }
}


VOID
InitOperationTable (
    VOID
    )

/*++

Routine Description:

  InitOperationsTable sets the prohibited operation mask for each operation.
  When an operation combination is prohibited, both operations involved have
  the corresponding bit cleared.

Arguments:

  None.

Return Value:

  None.

--*/

{
    POPERATIONFLAGS p;

    for (p = g_OperationFlags ; p->Name ; p++) {
        p->SharedOps = ALL_OPERATIONS;
    }

    //
    // Please try to keep this in the same order as the
    // macro expansion list in fileops.h.  The list of
    // prohibited operations should get smaller as
    // we go.
    //

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE,
        OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_COPY|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_FILE_DELETE_EXTERNAL,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_COPY|
            OPERATION_CLEANUP|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE,
        OPERATION_FILE_MOVE|
            OPERATION_FILE_COPY|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_COPY,
            OPERATION_FILE_COPY|
            OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_EXTERNAL,
        OPERATION_FILE_MOVE_EXTERNAL|
            OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_SHELL_FOLDER,
        OPERATION_FILE_MOVE_SHELL_FOLDER|
            OPERATION_FILE_MOVE_BY_NT|
            OPERATION_CLEANUP|
            OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_TEMP_PATH
        );

    pProhibitOperationCombination (
        OPERATION_FILE_MOVE_BY_NT,
        OPERATION_FILE_MOVE_BY_NT
        );

    pProhibitOperationCombination (
        OPERATION_CLEANUP,
        OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_MIGDLL_HANDLED,
        OPERATION_MIGDLL_HANDLED|
            OPERATION_CREATE_FILE|
            OPERATION_LINK_EDIT|
            OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_LINK_EDIT,
        OPERATION_LINK_EDIT
        );

    pProhibitOperationCombination (
        OPERATION_LINK_STUB,
        OPERATION_LINK_STUB
        );

    pProhibitOperationCombination (
        OPERATION_SHELL_FOLDER,
        OPERATION_SHELL_FOLDER
        );

    pProhibitOperationCombination (
        OPERATION_SHORT_FILE_NAME,
        OPERATION_SHORT_FILE_NAME
        );

}


VOID
pBuildOperationCategory (
    IN      PWSTR Node,
    IN      UINT OperationNum
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    #pragma prefast(suppress:69, "intentional use of swprintf")
    swprintf (Node, L"%hs", g_OperationFlags[OperationNum].Name);
}


VOID
pBuildOperationKey (
    IN      PWSTR Node,
    IN      UINT OperationNum,
    IN      UINT Sequencer
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    #pragma prefast(suppress:69, "intentional use of swprintf")
    swprintf (Node, L"%hs\\%x", g_OperationFlags[OperationNum].Name, Sequencer);
}


VOID
pBuildPropertyKey (
    IN      PWSTR Node,
    IN      UINT OperationNum,
    IN      UINT Sequencer,
    IN      DWORD Property
    )
{
    // IMPORTANT: wsprintfW is buggy and does not always work with %hs, the use of
    // swprintf is intentional
    swprintf (Node, L"%hs\\%x\\%x", g_OperationFlags[OperationNum].Name, Sequencer, Property);
}

BOOL
CanSetOperationA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL result;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    result = CanSetOperationW (UnicodeFileSpec, Operation);

    FreeConvertedStr (UnicodeFileSpec);

    return result;
}

BOOL
CanSetOperationW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )
{
    WCHAR LongFileSpec[MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    DWORD Flags;
    UINT SetBitNum;

    MYASSERT (ONEBITSET (Operation));

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    //
    // Get existing sequencer and flags, if they exist
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (!MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return TRUE;
    }

    SetBitNum = pWhichBitIsSet (Operation);

    return ((Flags & g_OperationFlags[SetBitNum].SharedOps) == Flags);
}

BOOL
pSetPathOperationW (
    IN      PCWSTR FileSpec,
    OUT     PDWORD Offset,
    OUT     PUINT SequencerPtr,
    IN      OPERATION SetBit,
    IN      OPERATION ClrBit,
    IN      BOOL Force
    )

/*++

Routine Description:

  pSetPathOperation adds the operation bit to the specified path.  It also
  verifies that the operation combination is legal.

Arguments:

  FileSpec    - Specifies the path the operation applies to.
  Offset      - Receives the offset of the memdb key created for the path.
  SequencePtr - Receives the operation sequence number, used for property
                linkage.
  SetBit      - Specifies one operation bit to set.
  ClrBit      - Specifies one operation bit to clear.  Either SetBit or
                ClrBit can be used, but not both.

Return Value:

  TRUE if the operation was set, FALSE otherwise.

--*/

{
    DWORD Sequencer;
    WCHAR Node[MEMDB_MAX];
    DWORD Flags;
    UINT SetBitNum;

    MYASSERT ((SetBit && !ClrBit) || (ClrBit && !SetBit));
    MYASSERT (ONEBITSET (SetBit | ClrBit));

    //
    // Get existing sequencer and flags, if they exist
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);

    if (!MemDbGetValueAndFlagsW (Node, &Sequencer, &Flags) || !Flags) {
        Flags = 0;
        if (!g_MasterSequencer && ISNT()) {
            if (!MemDbGetValue (
                    MEMDB_CATEGORY_STATE TEXT("\\") MEMDB_ITEM_MASTER_SEQUENCER,
                    &g_MasterSequencer
                    )) {
                g_MasterSequencer = 1 << 24;
            }
        }
        g_MasterSequencer++;
        Sequencer = g_MasterSequencer;

        MYASSERT (Sequencer);
    }

    //
    // Is bit adjustment legal?
    //

    if (SetBit) {

        SetBitNum = pWhichBitIsSet (SetBit);

#ifdef DEBUG

        {
            PSTR p;
            PCSTR DebugInfPath;
            CHAR DbgBuf[32];
            BOOL Break = FALSE;
            PCSTR AnsiFileSpec;

            DebugInfPath = JoinPathsA (g_BootDrivePathA, "debug.inf");

            AnsiFileSpec = ConvertWtoA (FileSpec);
            p = _mbsrchr (AnsiFileSpec, L'\\');
            p++;

            if (GetPrivateProfileStringA ("FileOps", AnsiFileSpec, "", DbgBuf, 32, DebugInfPath)) {
                Break = TRUE;
            } else if (GetPrivateProfileStringA ("FileOps", p, "", DbgBuf, 32, DebugInfPath)) {
                Break = TRUE;
            }

            if (Break) {
                if ((SetBit & strtoul (DbgBuf, NULL, 16)) == 0) {
                    Break = FALSE;
                }
            }

            if (Break) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "File %ls now being marked for operation %hs",
                    FileSpec,
                    g_OperationFlags[SetBitNum].Name
                    ));
            }

            FreePathStringA (DebugInfPath);
            FreeConvertedStr (AnsiFileSpec);
        }

#endif

        if (!Force) {
            if ((Flags & g_OperationFlags[SetBitNum].SharedOps) != Flags) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "File %ls already marked, %hs cannot be combined with 0x%04X",
                    FileSpec,
                    g_OperationFlags[SetBitNum].Name,
                    Flags
                    ));

                return FALSE;
            }
        }
    }

    //
    // Adjust the bits
    //

    Flags |= SetBit;
    Flags &= ~ClrBit;

    //
    // Save
    //

    MemDbSetValueAndFlagsW (Node, Sequencer, Flags, 0);

    MemDbGetOffsetW (Node, Offset);
    *SequencerPtr = Sequencer;

    return TRUE;
}


UINT
pAddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      BOOL Force,
    IN      BOOL AlreadyLong
    )

/*++

Routine Description:

  pAddOperationToPath adds an operation to a path.  The caller receives a
  sequencer so additional properties can be added.

Arguments:

  FileSpec    - Specifies the path to add the operation to
  Operation   - Specifies the operation to add
  Force       - Specifies TRUE if the operation combinations should be
                ignored.  This is only for special-case use.
  AlreadyLong - Specifies TRUE if FileSpec is a long path, FALSE otherwise.

Return Value:

  A sequencer that can be used to add properties, or INVALID_SEQUENCER if an
  error occured.

--*/

{
    UINT OperationNum;
    UINT Sequencer;
    WCHAR Node[MEMDB_MAX];
    DWORD Offset;
    WCHAR LongFileSpec[MAX_WCHAR_PATH];

    if (!FileSpec || FileSpec[0] == 0) {
        return INVALID_SEQUENCER;
    }

    //
    // Make sure FileSpec is in long format and is recorded in memdb
    //

    if (Operation != OPERATION_SHORT_FILE_NAME &&
        Operation != OPERATION_LONG_FILE_NAME
        ) {
        if (!AlreadyLong) {
            MYASSERT (ISNT());

            if (FileSpec[0] && (FileSpec[1]==L':')) {
                if (OurGetLongPathNameW (FileSpec, LongFileSpec, MAX_WCHAR_PATH)) {

                    FileSpec = LongFileSpec;
                }
            }
        }

        pFileOpsSetPathTypeW (FileSpec);
    }

    //
    // Create the path sequencer and set the operation bit
    //

    MYASSERT (ONEBITSET(Operation));

#ifdef DEBUG
    Offset = INVALID_OFFSET;
#endif

    if (!pSetPathOperationW (FileSpec, &Offset, &Sequencer, Operation, 0, Force)) {
        return INVALID_SEQUENCER;
    }

    MYASSERT (Offset != INVALID_OFFSET);

    //
    // Add the opereration
    //

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);

    if (!MemDbGetValueW (Node, NULL)) {
        MemDbSetValueW (Node, Offset);
    }

    return Sequencer;
}


UINT
AddOperationToPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);
    UnicodeFileSpec = ConvertAtoW (longFileSpec);

    u = pAddOperationToPathW (UnicodeFileSpec, Operation, FALSE, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    return u;
}


UINT
AddOperationToPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )
{
    if (!ISNT()) {

#ifdef DEBUG
        //
        // If we are calling the W version on Win9x, then we know
        // that the path is long. Otherwise the caller must call
        // the A version.
        //

        {
            PCSTR ansiFileSpec;
            CHAR longFileSpec[MAX_MBCHAR_PATH];
            PCWSTR unicodeFileSpec;

            ansiFileSpec = ConvertWtoA (FileSpec);
            CopyFileSpecToLongA (ansiFileSpec, longFileSpec);
            FreeConvertedStr (ansiFileSpec);

            unicodeFileSpec = ConvertAtoW (longFileSpec);
            MYASSERT (StringIMatchW (FileSpec, unicodeFileSpec));
            FreeConvertedStr (unicodeFileSpec);
        }
#endif

        return pAddOperationToPathW (FileSpec, Operation, FALSE, TRUE);
    }

    return pAddOperationToPathW (FileSpec, Operation, FALSE, FALSE);
}


UINT
ForceOperationOnPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);
    UnicodeFileSpec = ConvertAtoW (longFileSpec);

    u = pAddOperationToPathW (UnicodeFileSpec, Operation, TRUE, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    return u;
}


UINT
ForceOperationOnPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  ForceOperationOnPath is used only in special cases where the caller knows
  that a normally prohibited operation combination is OK.  This is usually
  because Path was somehow changed from its original state, yet the
  operations cannot be removed via RemoveOperationsFromPath.

  This function should only be used if absolutely necessary.

Arguments:

  FileSpec  - Specifies the path to add the operation to.
  Operation - Specifies the single operation to add to the path.

Return Value:

  A sequencer that can be used to add properties to the path.

--*/

{
    return pAddOperationToPathW (FileSpec, Operation, TRUE, FALSE);
}


BOOL
AddPropertyToPathExA (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCSTR Property,
    IN      PCSTR AlternateDataSection      OPTIONAL
    )
{
    PCWSTR UnicodeProperty;
    PCWSTR UnicodeAlternateDataSection;
    BOOL b;

    UnicodeProperty = ConvertAtoW (Property);
    UnicodeAlternateDataSection = ConvertAtoW (AlternateDataSection);

    b = AddPropertyToPathExW (
            Sequencer,
            Operation,
            UnicodeProperty,
            UnicodeAlternateDataSection
            );

    FreeConvertedStr (UnicodeProperty);
    FreeConvertedStr (UnicodeAlternateDataSection);

    return b;
}


BOOL
AddPropertyToPathExW (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      PCWSTR AlternateDataSection     OPTIONAL
    )
{

/*++

Routine Description:

  AddPropertyToPathEx adds an operation to a path, and then adds a property.
  The caller can also specify an alternate data section (for special-case
  uses).

Arguments:

  Sequencer            - Specifies the sequencer of the path to add
                         operations and properties to
  Operation            - Specifies the operation to add
  Property             - Specfieis the property data to add
  AlternateDataSection - Specifies an alternate memdb root for the property
                         data

Return Value:

  TRUE if the operation was added, FALSE otherwise.

--*/

    DWORD DataOffset;
    WCHAR Node[MEMDB_MAX];
    UINT OperationNum;
    DWORD UniqueId;
    DWORD PathOffset;
    DWORD DataValue;
    DWORD DataFlags;

    //
    // Verify the sequencer and operation are valid
    //

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);

    if (!MemDbGetValueAndFlagsW (Node, &PathOffset, &UniqueId)) {
        DEBUGMSG ((DBG_WHOOPS, "Can't set property on non-existent operation"));
        return FALSE;
    }

    //
    // Can this operation have another property?
    //

    if (UniqueId == g_OperationFlags[OperationNum].MaxProps) {
        DEBUGMSG ((
            DBG_WHOOPS,
            "Maximum properties specified for %hs (property %ls)",
            g_OperationFlags[OperationNum].Name,
            Property
            ));

        return FALSE;
    }

    //
    // Increment the unique ID
    //

    MemDbSetValueAndFlagsW (Node, PathOffset, (DWORD) (UniqueId + 1), 0);

    //
    // Get the existing data value and flags, preserving them
    // if they exist
    //

    if (!AlternateDataSection) {
        AlternateDataSection = MEMDB_CATEGORY_DATAW;
    }

    swprintf (Node, L"%s\\%s", AlternateDataSection, Property);

    if (!MemDbGetValueAndFlagsW (Node, &DataValue, &DataFlags)) {
        DataValue = 0;
        DataFlags = 0;
    }

    //
    // Write the data section node and get the offset
    //

    MemDbSetValueAndFlagsW (Node, DataValue, DataFlags, 0);
    MemDbGetOffsetW (Node, &DataOffset);

    //
    // Write the operation node
    //

    pBuildPropertyKey (Node, OperationNum, Sequencer, UniqueId);
    MemDbSetValueW (Node, DataOffset);

    return TRUE;
}


BOOL
pAssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property,
    IN      BOOL AlreadyLong
    )

/*++

Routine Description:

  AssociatePropertyWithPath adds a property to a path operation.  The maximum
  property count is enforced.

Arguments:

  FileSpec    - Specifies the path to add an operation and property
  Operation   - Specifies the operation to add
  Property    - Specifies the property data to associate with FileSpec
  AlreadyLong - Specifies TRUE if FileSpec is a long path name, FALSE otherwise

Return Value:

  TRUE if the operation and property was added, FALSE otherwise.  It is possible
  that the operation will be added but the property will not.

--*/

{
    UINT Sequencer;

    Sequencer = pAddOperationToPathW (FileSpec, Operation, FALSE, AlreadyLong);
    if (Sequencer == INVALID_SEQUENCER) {
        DEBUGMSG ((DBG_WHOOPS, "Can't associate %s with %s", Property, FileSpec));
        return FALSE;
    }

    //
    // BUGBUG - When the below fails, we need to reverse the pAddOperationToPathW
    //          call above
    //

    return AddPropertyToPathExW (Sequencer, Operation, Property, NULL);
}


BOOL
AssociatePropertyWithPathA (
    IN      PCSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCSTR Property
    )
{
    PCWSTR UnicodeFileSpec;
    PCWSTR UnicodeProperty;
    BOOL b;
    CHAR longFileSpec[MAX_MBCHAR_PATH];

    CopyFileSpecToLongA (FileSpec, longFileSpec);

    UnicodeFileSpec = ConvertAtoW (longFileSpec);
    UnicodeProperty = ConvertAtoW (Property);

    b = pAssociatePropertyWithPathW (UnicodeFileSpec, Operation, UnicodeProperty, TRUE);

    FreeConvertedStr (UnicodeFileSpec);
    FreeConvertedStr (UnicodeProperty);

    return b;
}


BOOL
AssociatePropertyWithPathW (
    IN      PCWSTR FileSpec,
    IN      OPERATION Operation,
    IN      PCWSTR Property
    )
{
    return pAssociatePropertyWithPathW (FileSpec, Operation, Property, FALSE);
}


UINT
GetSequencerFromPathA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    UINT u;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    u = GetSequencerFromPathW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return u;
}


UINT
GetSequencerFromPathW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  GetSequencerFromPath returns the sequencer for a particular path.  The path
  must have at least one operation.

Arguments:

  FileSpec - Specifies the path to get the sequencer for.

Return Value:

  The sequencer for the path, or INVALID_SEQUENCER if there are no operationf
  for the path.

--*/

{
    WCHAR LongFileSpec[MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    DWORD Sequencer;

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (!MemDbGetValueW (Node, &Sequencer)) {
        return INVALID_SEQUENCER;
    }

    return (UINT) Sequencer;
}


BOOL
GetPathFromSequencerA (
    IN      UINT Sequencer,
    OUT     PSTR PathBuf
    )
{
    WCHAR UnicodePathBuf[MAX_WCHAR_PATH];
    BOOL b;

    b = GetPathFromSequencerW (Sequencer, UnicodePathBuf);

    if (b) {
        KnownSizeWtoA (PathBuf, UnicodePathBuf);
    }

    return b;

}


BOOL
GetPathFromSequencerW (
    IN      UINT Sequencer,
    OUT     PWSTR PathBuf
    )

/*++

Routine Description:

  GetPathFromSequencer returns the path from the specified sequencer.

Arguments:

  Sequencer - Specifies the sequencer of the path.
  PathBuf   - Receives the path.  The caller must make sure the buffer is big
              enough for the path.

Return Value:

  TRUE if the path was copied to PathBuf, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD PathOffset = 0;
    DWORD w;
    UINT u;
    BOOL b = FALSE;

    //
    // Search all operations for sequencer
    //

    for (w = 1, u = 0 ; g_OperationFlags[u].Name ; w <<= 1, u++) {
        pBuildOperationKey (Node, u, Sequencer);
        if (MemDbGetValueW (Node, &PathOffset)) {
            break;
        }
    }

    //
    // For the first match found, use the offset to find the path
    //

    if (w) {
        b = MemDbBuildKeyFromOffsetW (PathOffset, PathBuf, 1, NULL);
    }

    return b;
}


VOID
RemoveOperationsFromSequencer (
    IN      UINT Sequencer,
    IN      DWORD Operations
    )

/*++

Routine Description:

  RemoveOperationsFromSequencer removes all operation bits from the specified
  path.  It does not however remove the properties; they become abandoned.

Arguments:

  Sequencer  - Specifies the sequencer for the path to remove operations from
  Operations - Specifies one or more operations to remove

Return Value:

  None.

--*/

{
    WCHAR Node[MEMDB_MAX];
    UINT u;
    DWORD PathOffset;
    DWORD PathSequencer;

    for (u = 0 ; g_OperationFlags[u].Name ; u++) {

        if (!(Operations & g_OperationFlags[u].Bit)) {
            continue;
        }

        pBuildOperationKey (Node, u, Sequencer);

        if (MemDbGetValueW (Node, &PathOffset)) {
            //
            // Delete linkage from operation to properties
            //

            MemDbDeleteTreeW (Node);

            //
            // Remove operation bits
            //

            MemDbBuildKeyFromOffsetExW (
                PathOffset,
                Node,
                NULL,
                0,
                &PathSequencer,
                NULL
                );

            MYASSERT (PathSequencer == Sequencer);

            MemDbSetValueAndFlagsW (Node, PathSequencer, 0, Operations);
        }
    }
}


VOID
RemoveOperationsFromPathA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    )
{
    PCWSTR UnicodeFileSpec;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    RemoveOperationsFromPathW (UnicodeFileSpec, Operations);

    FreeConvertedStr (UnicodeFileSpec);
}


VOID
RemoveOperationsFromPathW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )
{
    UINT Sequencer;

    Sequencer = GetSequencerFromPathW (FileSpec);

    if (Sequencer != INVALID_SEQUENCER) {
        RemoveOperationsFromSequencer (Sequencer, Operations);
    }
}


BOOL
IsFileMarkedForOperationA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = IsFileMarkedForOperationW (UnicodeFileSpec, Operations);

    FreeConvertedStr (UnicodeFileSpec);

    return b;
}


BOOL
IsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )

/*++

Routine Description:

  IsFileMarkedForOperation tests a path for one or more operations.

Arguments:

  FileSpec   - Specifies the path to test
  Operations - Specifies one or more operations to test for.

Return Value:

  TRUE if at least one operation from Operations is set on FileSpec, FALSE
  otherwise.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    DWORD Flags;
    WCHAR Node[MEMDB_MAX];

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return (Flags & Operations) != 0;
    }

    return FALSE;
}


BOOL
pIsFileMarkedForOperationW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations
    )

/*++

Routine Description:

  pIsFileMarkedForOperation tests a path for one or more operations.
  It does not convert short paths to long paths

Arguments:

  FileSpec   - Specifies the path to test
  Operations - Specifies one or more operations to test for.

Return Value:

  TRUE if at least one operation from Operations is set on FileSpec, FALSE
  otherwise.

--*/

{
    DWORD Flags;
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Flags)) {
        return (Flags & Operations) != 0;
    }

    return FALSE;
}


BOOL
IsFileMarkedInDataA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = IsFileMarkedInDataW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return b;
}


BOOL
IsFileMarkedInDataW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  IsFileMarkedInData tests the common property data section for FileSpec.

Arguments:

  FileSpec - Specifies the path to test.  This may also be any arbitrary
             property value.

Return Value:

  TRUE if FileSpec is a property of some operation, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_DATAW, FileSpec, NULL, NULL);

    return MemDbGetValueW (Node, NULL);
}


DWORD
GetPathPropertyOffset (
    IN      UINT Sequencer,
    IN      OPERATION Operation,
    IN      DWORD Property
    )

/*++

Routine Description:

  GetPathPropertyOffset returns the MemDb offset to the specified property.

Arguments:

  Sequencer - Specifies the path sequencer
  Operation - Specifies the operation the property is associated with
  Property  - Specifies the property index

Return Value:

  The MemDb offset to the property data, or INVALID_OFFSET.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD Offset;
    UINT OperationNum;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildPropertyKey (Node, OperationNum, Sequencer, Property);

    if (MemDbGetValueW (Node, &Offset)) {
        return Offset;
    }

    return INVALID_OFFSET;
}


DWORD
GetOperationsOnPathA (
    IN      PCSTR FileSpec
    )
{
    PCWSTR UnicodeFileSpec;
    DWORD w;

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    w = GetOperationsOnPathW (UnicodeFileSpec);

    FreeConvertedStr (UnicodeFileSpec);

    return w;
}


DWORD
GetOperationsOnPathW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  GetOperationsOnPath returns the operation flags for a path.

Arguments:

  FileSpec - Specifies the path to return operations for

Return Value:

  The operation bits for FileSpec

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    DWORD Operations;
    WCHAR Node[MEMDB_MAX];

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, LongFileSpec, NULL, NULL);

    if (MemDbGetValueAndFlagsW (Node, NULL, &Operations)) {
        return Operations;
    }

    return 0;
}


BOOL
GetPathPropertyA (
    IN      PCSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PSTR PropertyBuf           OPTIONAL
    )
{
    PCWSTR UnicodeFileSpec;
    BOOL b;
    WCHAR UnicodeProperty[MEMDB_MAX];

    UnicodeFileSpec = ConvertAtoW (FileSpec);

    b = GetPathPropertyW (
            UnicodeFileSpec,
            Operations,
            Property,
            PropertyBuf ? UnicodeProperty : NULL
            );

    FreeConvertedStr (UnicodeFileSpec);

    if (b && PropertyBuf) {
        KnownSizeWtoA (PropertyBuf, UnicodeProperty);
    }

    return b;
}


BOOL
pGetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    )

/*++

Routine Description:

  pGetPathProperty obtains a specific property for a path.

Arguments:

  FileSpec   - Specifies the path the property is associated with
  Operations - Specifies the operation flags to search.  The function will
               return the first property to match.
  Property   - Specifies the property index
  ProperyBuf - Receives the property data

Return Value:

  TRUE if a property was copied to PropertyBuf, FALSE otherwise.

--*/

{
    WCHAR Node[MEMDB_MAX];
    DWORD Sequencer;
    DWORD Flags;
    DWORD Operation;
    DWORD PropertyOffset;
    BOOL b = FALSE;

    //
    // Make sure operation is specified for FileSpec, then return
    // the property requested.
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, FileSpec, NULL, NULL);
    if (MemDbGetValueAndFlagsW (Node, &Sequencer, &Flags)) {
        Flags &= Operations;

        if (Flags) {
            Operation = Flags & (~(Flags - 1));

            MYASSERT (ONEBITSET (Operation));

            PropertyOffset = GetPathPropertyOffset (Sequencer, Operation, Property);

            if (PropertyOffset != INVALID_OFFSET) {
                if (PropertyBuf) {
                    b = MemDbBuildKeyFromOffsetW (PropertyOffset, PropertyBuf, 1, NULL);
                } else {
                    b = TRUE;
                }
            }
        }
    }

    return b;
}


BOOL
GetPathPropertyW (
    IN      PCWSTR FileSpec,
    IN      DWORD Operations,
    IN      DWORD Property,
    OUT     PWSTR PropertyBuf          OPTIONAL
    )

/*++

Routine Description:

  GetPathProperty obtains a specific property for a path.

Arguments:

  FileSpec   - Specifies the path the property is associated with
  Operations - Specifies the operation flags to search.  The function will
               return the first property to match.
  Property   - Specifies the property index
  ProperyBuf - Receives the property data

Return Value:

  TRUE if a property was copied to PropertyBuf, FALSE otherwise.

--*/

{
    WCHAR LongFileSpec[MEMDB_MAX];

    MYASSERT (!(Operations & OPERATION_SHORT_FILE_NAME));

    pFileOpsGetLongPathW (FileSpec, LongFileSpec);

    return pGetPathPropertyW (LongFileSpec, Operations, Property, PropertyBuf);
}


BOOL
pEnumFirstPathInOperationWorker (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumPath,
    OUT     PDWORD Sequencer,
    IN      OPERATION Operation
    )
{
    WCHAR Node[MEMDB_MAX];
    UINT OperationNum;
    BOOL b;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationCategory (Node, OperationNum);
    StringCopyW (AppendWack (Node), L"*");

    b = MemDbEnumFirstValueW (EnumPtr, Node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY);

    if (b) {
        MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, EnumPath, 1, Sequencer);
    }

    return b;
}


BOOL
pEnumNextFileOpOrProperty (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumPathOrData,
    OUT     PWSTR PropertyName,         OPTIONAL
    OUT     PDWORD Sequencer            OPTIONAL
    )
{
    BOOL b;
    WCHAR Temp[MEMDB_MAX];
    PWSTR p;

    b = MemDbEnumNextValueW (EnumPtr);

    if (b) {
        if (PropertyName) {
            MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, Temp, 0, Sequencer);

            p = wcschr (Temp, L'\\');
            if (!p) {
                p = GetEndOfStringW (Temp);
            }

            StringCopyABW (PropertyName, Temp, p);

            if (*p) {
                p++;
            }

            StringCopyW (EnumPathOrData, p);

        } else {
            MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, EnumPathOrData, 1, Sequencer);
        }
    }

    return b;
}



BOOL
EnumFirstPathInOperationA (
    OUT     PFILEOP_ENUMA EnumPtr,
    IN      OPERATION Operation
    )
{
    BOOL b;
    WCHAR EnumPath[MAX_WCHAR_PATH];

    ZeroMemory (EnumPtr, sizeof (FILEOP_ENUMA));

    b = pEnumFirstPathInOperationWorker (
            &EnumPtr->MemDbEnum,
            EnumPath,
            &EnumPtr->Sequencer,
            Operation
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Path, EnumPath);
    }

    return b;
}


BOOL
EnumFirstPathInOperationW (
    OUT     PFILEOP_ENUMW EnumPtr,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  EnumFirstPathInOperation begins an enumeration of all paths for a
  particular operation.

Arguments:

  EnumPtr   - Receives the first enumerated item.
  Operation - Specifies the operation to enumerate.

Return Value:

  TRUE if a path was enumerated, or FALSE if the operation is not applied to
  any path.

--*/

{
    ZeroMemory (EnumPtr, sizeof (FILEOP_ENUMW));

    return pEnumFirstPathInOperationWorker (
                &EnumPtr->MemDbEnum,
                EnumPtr->Path,
                &EnumPtr->Sequencer,
                Operation
                );
}


BOOL
EnumNextPathInOperationA (
    IN OUT  PFILEOP_ENUMA EnumPtr
    )
{
    BOOL b;
    WCHAR EnumPath[MAX_WCHAR_PATH];

    b = pEnumNextFileOpOrProperty (
            &EnumPtr->MemDbEnum,
            EnumPath,
            NULL,
            &EnumPtr->Sequencer
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Path, EnumPath);
    }

    return b;
}


BOOL
EnumNextPathInOperationW (
    IN OUT  PFILEOP_ENUMW EnumPtr
    )
{
    return pEnumNextFileOpOrProperty (
                &EnumPtr->MemDbEnum,
                EnumPtr->Path,
                NULL,
                &EnumPtr->Sequencer
                );
}


BOOL
pEnumFirstPropertyWorker (
    IN OUT  PMEMDB_ENUMW EnumPtr,
    OUT     PWSTR EnumData,
    OUT     PWSTR PropertyName,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )
{
    WCHAR Node[MEMDB_MAX];
    PWSTR p;
    UINT OperationNum;
    BOOL b;

    OperationNum = pWhichBitIsSet (Operation);

    pBuildOperationKey (Node, OperationNum, Sequencer);
    StringCopyW (AppendWack (Node), L"*");

    b = MemDbEnumFirstValueW (EnumPtr, Node, MEMDB_THIS_LEVEL_ONLY, MEMDB_ENDPOINTS_ONLY);

    if (b) {
        MemDbBuildKeyFromOffsetW (EnumPtr->dwValue, Node, 0, NULL);

        p = wcschr (Node, L'\\');
        if (!p) {
            p = GetEndOfStringW (Node);
        }

        StringCopyABW (PropertyName, Node, p);

        if (*p) {
            p++;
        }

        StringCopyW (EnumData, p);
    }

    return b;
}


BOOL
EnumFirstFileOpPropertyA (
    OUT     PFILEOP_PROP_ENUMA EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )
{
    BOOL b;
    WCHAR EnumData[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    ZeroMemory (EnumPtr, sizeof (FILEOP_PROP_ENUMA));

    b = pEnumFirstPropertyWorker (
            &EnumPtr->MemDbEnum,
            EnumData,
            PropertyName,
            Sequencer,
            Operation
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Property, EnumData);
        KnownSizeWtoA (EnumPtr->PropertyName, PropertyName);
    }

    return b;
}


BOOL
EnumFirstFileOpPropertyW (
    OUT     PFILEOP_PROP_ENUMW EnumPtr,
    IN      UINT Sequencer,
    IN      OPERATION Operation
    )

/*++

Routine Description:

  EnumFirstFileOpProperty enumerates the first property associated with an
  operation on a specific path.

Arguments:

  EnumPtr   - Receives the enumerated item data
  Sequencer - Specifies the sequencer of the path to enumerate
  Operation - Specifies the operation to enumerate

Return Value:

  TRUE if a property was enumerated, or FALSE if the path and operation does
  not have any properties.

--*/

{
    ZeroMemory (EnumPtr, sizeof (FILEOP_PROP_ENUMW));

    return pEnumFirstPropertyWorker (
                &EnumPtr->MemDbEnum,
                EnumPtr->Property,
                EnumPtr->PropertyName,
                Sequencer,
                Operation
                );
}


BOOL
EnumNextFileOpPropertyA (
    IN OUT  PFILEOP_PROP_ENUMA EnumPtr
    )
{
    BOOL b;
    WCHAR EnumData[MEMDB_MAX];
    WCHAR PropertyName[MEMDB_MAX];

    b = pEnumNextFileOpOrProperty (
            &EnumPtr->MemDbEnum,
            EnumData,
            PropertyName,
            NULL
            );

    if (b) {
        KnownSizeWtoA (EnumPtr->Property, EnumData);
        KnownSizeWtoA (EnumPtr->PropertyName, PropertyName);
    }

    return b;
}


BOOL
EnumNextFileOpPropertyW (
    IN OUT  PFILEOP_PROP_ENUMW EnumPtr
    )
{

    return pEnumNextFileOpOrProperty (
                &EnumPtr->MemDbEnum,
                EnumPtr->Property,
                EnumPtr->PropertyName,
                NULL
                );
}


BOOL
pEnumFileOpWorkerA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    )
{
    //
    // Transfer UNICODE results to enum struct
    //

    KnownSizeWtoA (EnumPtr->Path, EnumPtr->Enum.Path);
    KnownSizeWtoA (EnumPtr->Property, EnumPtr->Enum.Property);

    EnumPtr->Sequencer = EnumPtr->Enum.Sequencer;
    EnumPtr->PropertyNum = EnumPtr->Enum.PropertyNum;
    EnumPtr->CurrentOperation = EnumPtr->Enum.CurrentOperation;
    EnumPtr->PropertyValid = EnumPtr->Enum.PropertyValid;

    return TRUE;
}


BOOL
EnumFirstFileOpA (
    OUT     PALL_FILEOPS_ENUMA EnumPtr,
    IN      DWORD Operations,
    IN      PCSTR FileSpec                      OPTIONAL
    )
{
    BOOL b;
    PCWSTR UnicodeFileSpec;

    if (FileSpec) {
        UnicodeFileSpec = ConvertAtoW (FileSpec);
    } else {
        UnicodeFileSpec = NULL;
    }

    b = EnumFirstFileOpW (&EnumPtr->Enum, Operations, UnicodeFileSpec);

    if (UnicodeFileSpec) {
        FreeConvertedStr (UnicodeFileSpec);
    }

    if (b) {
        return pEnumFileOpWorkerA (EnumPtr);
    }

    return FALSE;
}


BOOL
EnumFirstFileOpW (
    OUT     PALL_FILEOPS_ENUMW EnumPtr,
    IN      DWORD Operations,
    IN      PCWSTR FileSpec                     OPTIONAL
    )

/*++

Routine Description:

  EnumFirstFileOp is a general-purpose enumerator.  It enumerates the paths
  and all properties from a set of operations.

Arguments:

  EnumPtr    - Receives the enumerated item data
  Operations - Specifies one or more operations to enumerate
  FileSpec   - Specifies a specific path to enumerate, or NULL to enumerate
               all paths that have the specified operation(s)

Return Value:

  TRUE if data was enuemrated, or FALSE if no data matches the specified
  operations and file spec.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];

    ZeroMemory (EnumPtr, sizeof (ALL_FILEOPS_ENUMW));

    EnumPtr->State = FO_ENUM_BEGIN;
    EnumPtr->Operations = Operations;
    EnumPtr->Path = EnumPtr->OpEnum.Path;
    EnumPtr->Property = EnumPtr->PropEnum.Property;

    if (FileSpec) {

        pFileOpsGetLongPathW (FileSpec, LongFileSpec);

        _wcssafecpy (EnumPtr->FileSpec, LongFileSpec, MAX_WCHAR_PATH);

    } else {
        StringCopyW (EnumPtr->FileSpec, L"*");
    }

    return EnumNextFileOpW (EnumPtr);
}


BOOL
EnumNextFileOpA (
    IN OUT  PALL_FILEOPS_ENUMA EnumPtr
    )
{
    BOOL b;

    b = EnumNextFileOpW (&EnumPtr->Enum);

    if (b) {
        return pEnumFileOpWorkerA (EnumPtr);
    }

    return FALSE;
}


BOOL
EnumNextFileOpW (
    IN OUT  PALL_FILEOPS_ENUMW EnumPtr
    )
{
    DWORD w;

    while (EnumPtr->State != FO_ENUM_END) {

        switch (EnumPtr->State) {

        case FO_ENUM_BEGIN:
            //
            // Find the next operation
            //

            if (!EnumPtr->Operations) {
                EnumPtr->State = FO_ENUM_END;
                break;
            }

            w = EnumPtr->Operations & (~(EnumPtr->Operations - 1));
            MYASSERT (ONEBITSET (w));

            EnumPtr->CurrentOperation = w;
            EnumPtr->OperationNum = pWhichBitIsSet (w);
            EnumPtr->Operations ^= w;

            EnumPtr->State = FO_ENUM_BEGIN_PATH_ENUM;
            break;

        case FO_ENUM_BEGIN_PATH_ENUM:
            if (EnumFirstPathInOperationW (&EnumPtr->OpEnum, EnumPtr->CurrentOperation)) {
                EnumPtr->State = FO_ENUM_BEGIN_PROP_ENUM;
            } else {
                EnumPtr->State = FO_ENUM_BEGIN;
            }

            break;

        case FO_ENUM_BEGIN_PROP_ENUM:
            if (!IsPatternMatchW (EnumPtr->FileSpec, EnumPtr->Path)) {
                EnumPtr->State = FO_ENUM_NEXT_PATH;
                break;
            }

            EnumPtr->Sequencer = EnumPtr->OpEnum.Sequencer;
            EnumPtr->PropertyNum = 0;

            if (EnumFirstFileOpPropertyW (
                    &EnumPtr->PropEnum,
                    EnumPtr->Sequencer,
                    EnumPtr->CurrentOperation
                    )) {
                EnumPtr->State = FO_ENUM_RETURN_DATA;
                break;
            }

            EnumPtr->State = FO_ENUM_RETURN_PATH;
            break;

        case FO_ENUM_RETURN_PATH:
            EnumPtr->State = FO_ENUM_NEXT_PATH;
            EnumPtr->PropertyValid = FALSE;
            return TRUE;

        case FO_ENUM_RETURN_DATA:
            EnumPtr->State = FO_ENUM_NEXT_PROP;
            EnumPtr->PropertyValid = TRUE;
            return TRUE;

        case FO_ENUM_NEXT_PROP:
            EnumPtr->PropertyNum++;

            if (EnumNextFileOpPropertyW (&EnumPtr->PropEnum)) {
                EnumPtr->State = FO_ENUM_RETURN_DATA;
            } else {
                EnumPtr->State = FO_ENUM_NEXT_PATH;
            }

            break;

        case FO_ENUM_NEXT_PATH:
            if (EnumNextPathInOperationW (&EnumPtr->OpEnum)) {
                EnumPtr->State = FO_ENUM_BEGIN_PROP_ENUM;
            } else {
                EnumPtr->State = FO_ENUM_BEGIN;
            }

            break;
        }
    }

    return FALSE;
}


BOOL
TestPathsForOperationsA (
    IN      PCSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    )
{
    BOOL b;
    PCWSTR UnicodeBaseFileSpec;

    UnicodeBaseFileSpec = ConvertAtoW (BaseFileSpec);

    b = TestPathsForOperationsW (UnicodeBaseFileSpec, OperationsToFind);

    FreeConvertedStr (UnicodeBaseFileSpec);

    return b;
}


BOOL
TestPathsForOperationsW (
    IN      PCWSTR BaseFileSpec,
    IN      DWORD OperationsToFind
    )

/*++

Routine Description:

  TestPathsForOperations scans all subpaths of the given base for a specific
  operation.  This function is typically used to test a directory for an
  operation on one of its files or subdirectories.

Arguments:

  BaseFileSpec     - Specifies the base path to scan
  OperationsToFind - Specifies one or more operations to look for

Return Value:

  TRUE if one of the operations was found within BaseFileSpec, or FALSE if no
  subpath of BaseFileSpec has one of the operations.

--*/

{
    WCHAR LongFileSpec [MEMDB_MAX];
    WCHAR Node[MEMDB_MAX];
    MEMDB_ENUMW e;
    DWORD Operation;

    if (MemDbGetValueAndFlagsW (BaseFileSpec, NULL, &Operation)) {
        if (Operation & OperationsToFind) {
            return TRUE;
        }
    }

    pFileOpsGetLongPathW (BaseFileSpec, LongFileSpec);

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_PATHROOTW,
        LongFileSpec,
        L"*",
        NULL
        );

    if (MemDbEnumFirstValueW (&e, Node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            if (e.Flags & OperationsToFind) {
                return TRUE;
            }
        } while (MemDbEnumNextValueW (&e));
    }

    return FALSE;
}


BOOL
IsFileMarkedAsKnownGoodA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_KNOWN_GOODA,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueA (Node, NULL);
}



/*++

Routine Description:

  IsFileMarkedForAnnounce determines if a file is listed in DeferredAnnounce category.

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  TRUE if the file is listed or FALSE if it is not.

--*/

BOOL
IsFileMarkedForAnnounceA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueA (Node, NULL);
}

BOOL
IsFileMarkedForAnnounceW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);

    return MemDbGetValueW (Node, NULL);
}

/*++

Routine Description:

  GetFileAnnouncement returnes the announcement value for a particular file.
  The possible values are ACT_... values in fileops.h

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  The announcement value.

--*/

DWORD
GetFileAnnouncementA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];
    DWORD result = ACT_UNKNOWN;

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsA (Node, NULL, &result);
    return result;
}

DWORD
GetFileAnnouncementW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD result = ACT_UNKNOWN;

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsW (Node, NULL, &result);
    return result;
}

/*++

Routine Description:

  GetFileAnnouncementContext returnes the context of a file that is
  marked for announcement.

Arguments:

  FileSpec - Specifies the file to query in long filename format

Return Value:

  The announcement context.

--*/

DWORD
GetFileAnnouncementContextA (
    IN      PCSTR FileSpec
    )
{
    CHAR Node[MEMDB_MAX];
    DWORD result = 0;

    MemDbBuildKeyA (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEA,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsA (Node, &result, NULL);
    return result;
}

DWORD
GetFileAnnouncementContextW (
    IN      PCWSTR FileSpec
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD result = 0;

    MemDbBuildKeyW (
        Node,
        MEMDB_CATEGORY_DEFERREDANNOUNCEW,
        FileSpec,
        NULL,
        NULL);
    MemDbGetValueAndFlagsW (Node, &result, NULL);
    return result;
}

/*++

Routine Description:

  IsFileProvidedByNt checks to see if a specific file is going to
  be installed by standard NT setup.  This list was generated from
  calls to FileIsProviedByNt.

Arguments:

  FileName - Specifies the name of the file in long filename format

Return Value:

  TRUE if the file will be installed by standard NT installation, or
  FALSE if it will not.

--*/

BOOL
IsFileProvidedByNtA (
    IN      PCSTR FileName
    )
{
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (Node, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
    return MemDbGetValueA (Node, NULL);
}

BOOL
IsFileProvidedByNtW (
    IN      PCWSTR FileName
    )
{
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_NT_FILESW, FileName, NULL, NULL);
    return MemDbGetValueW (Node, NULL);
}




/*++

Routine Description:

  GetNewPathForFile copies the move path to the caller-supplied buffer
  if the file is marked to be moved.

Arguments:

  SrcFileSpec - Specifies the src file to query in long filename format

  NewPath - Receives a copy of the new location, or if the file is not
            being moved, receives a copy of the original file.

Return Value:

  TRUE if the file is marked to be moved and the destination was copied
  to NewPath, or FALSE if the file is not makred to be moved and
  SrcFileSpec was copied to NewPath.

--*/

BOOL
GetNewPathForFileA (
    IN      PCSTR SrcFileSpec,
    OUT     PSTR NewPath
    )
{
    BOOL b;
    PCWSTR UnicodeSrcFileSpec;
    WCHAR UnicodeNewPath[MAX_WCHAR_PATH];

    UnicodeSrcFileSpec = ConvertAtoW (SrcFileSpec);

    b = GetNewPathForFileW (UnicodeSrcFileSpec, UnicodeNewPath);

    FreeConvertedStr (UnicodeSrcFileSpec);

    if (b) {
        KnownSizeWtoA (NewPath, UnicodeNewPath);
    }

    return b;
}

BOOL
GetNewPathForFileW (
    IN      PCWSTR SrcFileSpec,
    OUT     PWSTR NewPath
    )
{
    DWORD Offset = INVALID_OFFSET;
    DWORD w;
    OPERATION Operation;
    UINT Sequencer;

    Sequencer = GetSequencerFromPathW (SrcFileSpec);

    StringCopyW (NewPath, SrcFileSpec);

    w = ALL_MOVE_OPERATIONS;
    while (w && Offset == INVALID_OFFSET) {
        Operation = w & (~(w - 1));
        w ^= Operation;
        Offset = GetPathPropertyOffset (Sequencer, Operation, 0);
    }

    if (Offset != INVALID_OFFSET) {
        return MemDbBuildKeyFromOffsetW (Offset, NewPath, 1, NULL);
    }

    return FALSE;
}


BOOL
AnnounceFileInReportA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr,
    IN      DWORD Action
    )

/*++

Routine Description:

  Adds a file to the memdb DeferredAnnounce category.

Arguments:

  FileSpec - Specifies the file to delete in long name format

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_DEFERREDANNOUNCEA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, Action, 0);

}


BOOL
MarkFileAsKnownGoodA (
    IN      PCSTR FileSpec
    )

/*++

Routine Description:

  Adds a file to the memdb KnownGood category.

Arguments:

  FileSpec - Specifies the file name

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    return MemDbSetValueExA (MEMDB_CATEGORY_KNOWN_GOODA, FileSpec, NULL, NULL, 0, NULL);
}


BOOL
AddCompatibleShellA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr                OPTIONAL
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleShell category.

Arguments:

  FileSpec - Specifies the file to delete in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_SHELLA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleRunKeyA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleRunKey category.

Arguments:

  FileSpec - Specifies the file to delete in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_RUNKEYA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleDosA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr                OPTIONAL
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleDos category.

Arguments:

  FileSpec - Specifies the file in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_DOSA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


BOOL
AddCompatibleHlpA (
    IN      PCSTR FileSpec,
    IN      DWORD ContextPtr
    )

/*++

Routine Description:

  Adds a file to the memdb CompatibleHlp category.

Arguments:

  FileSpec - Specifies the file in long name format
  ContextPtr - Specifies the MigDb context, cast as a DWORD (can be 0 if no context
               is available)

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, MEMDB_CATEGORY_COMPATIBLE_HLPA, FileSpec, NULL, NULL);

    return MemDbSetValueAndFlagsA (Key, ContextPtr, 0, 0);

}


//
// Compute the number of CHARs allowed for the normal and long temp
// locations. MAX_PATH includes the nul terminator, and we subtract
// that terminator via sizeof.
//
// NORMAL_MAX is the number of chars left after the subdir c:\user~tmp.@01\,
// including the nul
//
// LONG_MAX is the number of chars left after the subdir
// c:\user~tmp.@02\12345\, including the nul. 12345 is a %05X sequencer.
//

#define NORMAL_MAX      (MAX_PATH - (sizeof(S_SHELL_TEMP_NORMAL_PATHA)/sizeof(CHAR)) + 2)
#define LONG_MAX        (MAX_PATH - (sizeof(S_SHELL_TEMP_LONG_PATHA)/sizeof(CHAR)) - 6)

VOID
ComputeTemporaryPathA (
    IN      PCSTR SourcePath,
    IN      PCSTR SourcePrefix,     OPTIONAL
    IN      PCSTR TempPrefix,       OPTIONAL
    IN      PCSTR SetupTempDir,
    OUT     PSTR TempPath
    )

/*++

Routine Description:

  ComputeTemporaryPath builds a temporary path rooted in
  S_SHELL_TEMP_NORMAL_PATH for a path that fits within MAX_PATH, or
  S_SHELL_TEMP_LONG_PATH for a longer path. It attempts to use the original
  subpath name in the "normal" path subdirectory. If that doesn't fit, then a
  unique "long" subdirectory is created, and a subpath is computed by taking
  the longest possible subpath (the right side).

Arguments:

  SourcePath - Specifies the full file or directory path of the source

  SourcePrefix - Specifies a prefix that will be stripped from SourcePath

  TempPrefix - Specifies a prefix that will be inserted at the start of
               TempPath

  SetupTempDir - Specifies the setup temp dir, typically %windir%\setup,
                 to be used when no suitable path can be computed. (Unlikely
                 case.)

  TempPath - Receives the temp path string. This buffer will receive up to
             MAX_PATH characters (includes the nul).

Return Value:

  None.

--*/

{
    PCSTR subPath = NULL;
    PCSTR smallerSubPath;
    PSTR pathCopy = NULL;
    PSTR lastWack;
    static UINT dirSequencer = 0;
    UINT prefixLen;
    MBCHAR ch;
    UINT normalMax = NORMAL_MAX;

    //
    // Build a temporary file name using the inbound file as a suggestion.
    //

    StringCopyA (TempPath, S_SHELL_TEMP_NORMAL_PATHA);
    TempPath[0] = SourcePath[0];

    if (SourcePrefix) {
        prefixLen = TcharCountA (SourcePrefix);
        if (StringIMatchTcharCountA (SourcePath, SourcePrefix, prefixLen)) {
            ch = _mbsnextc (SourcePath + prefixLen);
            if (!ch || ch == '\\') {
                subPath = SourcePath + prefixLen;
                if (*subPath) {
                    subPath++;
                }
            }
        }
    }

    if (!subPath) {
        subPath = _mbschr (SourcePath, '\\');
        if (!subPath) {
            subPath = SourcePath;
        } else {
            subPath++;
        }
    }

    DEBUGMSGA_IF ((_mbschr (subPath, ':') != NULL, DBG_WHOOPS, "Bad temp path: %s", SourcePath));

    if (TempPrefix) {
        StringCopyA (AppendWackA (TempPath), TempPrefix);
        normalMax = MAX_PATH - TcharCountA (TempPath);
    }

    if (TcharCountA (subPath) < normalMax) {
        //
        // typical case: source path fits within MAX_PATH; use it
        //
        if (*subPath) {
            StringCopyA (AppendWackA (TempPath), subPath);
        }

    } else {
        //
        // subpath is too big, just take the right side of the src
        //

        dirSequencer++;
        wsprintfA (TempPath, S_SHELL_TEMP_LONG_PATHA "\\%05x", dirSequencer);
        TempPath[0] = SourcePath[0];

        // compute end of string + nul terminator - backslash - (MAX_PATH - TcharCount of TempPath)
        subPath = GetEndOfStringA (SourcePath) - LONG_MAX;

        //
        // try to eliminate a truncated subdirectory on the left
        //

        smallerSubPath = _mbschr (subPath, '\\');
        if (smallerSubPath && smallerSubPath[1]) {
            subPath = smallerSubPath + 1;
        } else {

            //
            // still no subpath, try just the file name
            //

            subPath = _mbsrchr (subPath, '\\');
            if (subPath) {
                subPath++;
                if (!(*subPath)) {
                    //
                    // file spec ends in backslash
                    //
                    pathCopy = DuplicateTextA (SourcePath);
                    if (!pathCopy) {
                        subPath = NULL;
                    } else {

                        for (;;) {
                            lastWack = _mbsrchr (pathCopy, '\\');
                            if (!lastWack || lastWack[1]) {
                                break;
                            }

                            *lastWack = 0;
                        }

                        subPath = lastWack;
                    }

                } else if (TcharCountA (subPath) > LONG_MAX) {
                    //
                    // very long file name; truncate it
                    //
                    subPath = GetEndOfStringA (subPath) - LONG_MAX;
                }
            }
        }

        if (subPath) {
            StringCopyA (AppendWackA (TempPath), subPath);
        } else {
            dirSequencer++;
            wsprintfA (TempPath, "%s\\tmp%05x", SetupTempDir, dirSequencer);
        }

        if (pathCopy) {
            FreeTextA (pathCopy);
        }
    }

}


BOOL
pMarkFileForTemporaryMoveA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile,
    IN      PCSTR TempFileIn,           OPTIONAL
    OUT     PSTR TempFileOut            OPTIONAL
    )

/*++

Routine Description:

  This routine adds operations to move a file to a temporary location in
  text mode, and optionally move it to a final destination.

Arguments:

  SrcFileSpec   - Specifies the file that is to be moved to a safe place (out
                  of the way of normal NT installation), and then moved back
                  after NT is installed.

  FinalDest     - Specifies the final destination for FileSpec.  If NULL, file
                  is moved to a temporary location but is not copied to a final
                  location in GUI mode.

  TempSpec      - Specifies the temp dir or file to relocate the file to.  The temp dir
                  must be on the same drive as SrcFileSpec.

  TempSpecIsFile - Specifies TRUE if the prev param is a file

  TempFileIn    - If non-NULL, specifies the temporary file to use instead of
                  automatically generated name.  Provided only for
                  MarkHiveForTemporaryMove.

  TempFileOut   - If non-NULL, receives the path to the temporary file location.

Return Value:

  TRUE if the operation was recorded, or FALSE otherwise.

--*/

{
    BOOL b = TRUE;
    CHAR TempFileSpec[MAX_MBCHAR_PATH];
    static DWORD FileSequencer = 0;

    //
    // Move the file from source to temporary location
    //

    if (!CanSetOperationA (SrcFileSpec, OPERATION_TEMP_PATH)) {
        return FALSE;
    }

    if (TempFileIn) {
        MYASSERT (!TempSpecIsFile);
        wsprintfA (TempFileSpec, "%s\\%s", TempSpec, TempFileIn);
    } else if (TempSpecIsFile) {
        StringCopyA (TempFileSpec, TempSpec);
    } else {
        FileSequencer++;
        wsprintfA (TempFileSpec, "%s\\tmp%05x", TempSpec, FileSequencer);
    }

    DEBUGMSGA ((DBG_MEMDB, "MarkFileForTemporaryMove: %s -> %s", SrcFileSpec, TempFileSpec));

    if (TempFileOut) {
        StringCopyA (TempFileOut, TempFileSpec);
    }

    RemoveOperationsFromPathA (SrcFileSpec, OPERATION_TEMP_PATH | OPERATION_FILE_DELETE_EXTERNAL | OPERATION_FILE_MOVE_EXTERNAL);

    b = AssociatePropertyWithPathA (SrcFileSpec, OPERATION_TEMP_PATH, TempFileSpec);

    //
    // Optionally move the file from temporary location to final dest
    //

    if (FinalDest) {
        //
        // We are adding additional properties to the temp path operation that
        // already exists.  So the properties are defined as zero being the temp
        // path, and one and higher being destinations. That's how we achieve
        // a one-to-many capability.
        //

        b = b && AssociatePropertyWithPathA (SrcFileSpec, OPERATION_TEMP_PATH, FinalDest);

        //
        // Now we add an external move operation, so the registry is updated
        // correctly.
        //

        b = b && MarkFileForMoveExternalA (SrcFileSpec, FinalDest);

    } else {
        //
        // Because the source file is going to be moved to a temporary location
        // and never moved back, it is effectively going to be deleted.
        //

        b = b && MarkFileForExternalDeleteA (SrcFileSpec);
    }

    return b;
}


BOOL
MarkFileForTemporaryMoveExA (
    IN      PCSTR SrcFileSpec,
    IN      PCSTR FinalDest,
    IN      PCSTR TempSpec,
    IN      BOOL TempSpecIsFile
    )
{
    return pMarkFileForTemporaryMoveA (SrcFileSpec, FinalDest, TempSpec, TempSpecIsFile, NULL, NULL);
}

PCSTR
GetTemporaryLocationForFileA (
    IN      PCSTR SourceFile
    )
{
    UINT sequencer;
    PCSTR result = NULL;
    FILEOP_PROP_ENUMA eOpProp;

    sequencer = GetSequencerFromPathA (SourceFile);

    if (sequencer) {
        if (EnumFirstFileOpPropertyA (&eOpProp, sequencer, OPERATION_TEMP_PATH)) {
            result = DuplicatePathStringA (eOpProp.Property, 0);
        }
    }
    return result;
}

PCWSTR
GetTemporaryLocationForFileW (
    IN      PCWSTR SourceFile
    )
{
    UINT sequencer;
    PCWSTR result = NULL;
    FILEOP_PROP_ENUMW eOpProp;

    sequencer = GetSequencerFromPathW (SourceFile);

    if (sequencer) {
        if (EnumFirstFileOpPropertyW (&eOpProp, sequencer, OPERATION_TEMP_PATH)) {
            result = DuplicatePathStringW (eOpProp.Property, 0);
        }
    }
    return result;
}


BOOL
MarkHiveForTemporaryMoveA (
    IN      PCSTR HivePath,
    IN      PCSTR TempDir,
    IN      PCSTR UserName,
    IN      BOOL DefaultHives,
    IN      BOOL CreateOnly
    )

/*++

Routine Description:

  Adds a file or directory path to the TempReloc memdb category.  The file or
  dir is moved during text mode and is never moved back.  If the file name is
  user.dat, the destination location is written to the UserDatLoc category.

  All hives are deleted at the end of setup.

Arguments:

  HivePath - Specifies the Win9x path to a user.dat or system.dat file

  TempDir - Specifies the path to the setup temporary dir on the same drive
            as HivePath

  UserName - Specifies the current user or NULL if default user or no user

  DefaultHives - Specifies TRUE if the HivePath is a system default path, or
                 FALSE if the HivePath is specific to a user profile.

  CreateOnly - Specifies TRUE if this account is create-only (such as
               Administrator), or FALSE if this account gets full migration.

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

{
    BOOL b = TRUE;
    CHAR OurTempFileSpec[MAX_MBCHAR_PATH];
    CHAR RealTempFileSpec[MAX_MBCHAR_PATH];
    static DWORD Sequencer = 0;
    PSTR p, q;

    if (!UserName || !UserName[0]) {
        UserName = S_DOT_DEFAULTA;
    }

    //
    // Has hive already been moved?  If so, point two or more users to
    // the same hive.
    //

    RealTempFileSpec[0] = 0;
    p = (PSTR) GetFileNameFromPathA (HivePath);

    GetPathPropertyA (HivePath, OPERATION_TEMP_PATH, 0, RealTempFileSpec);

    if (!(RealTempFileSpec[0])) {
        //
        // Hive has not been moved yet -- move it now
        //

        if (!DefaultHives) {
            Sequencer++;
            wsprintfA (OurTempFileSpec, "hive%04u\\%s", Sequencer, p);
        } else {
            wsprintfA (OurTempFileSpec, "defhives\\%s", p);
        }

        b = pMarkFileForTemporaryMoveA (
                HivePath,
                NULL,
                TempDir,
                FALSE,
                OurTempFileSpec,
                RealTempFileSpec
                );

        if (b && DefaultHives) {
            //
            // Save defhives location in Paths\RelocWinDir
            //

            q = _mbsrchr (RealTempFileSpec, '\\');
            MYASSERT(q);
            *q = 0;

            b = MemDbSetValueExA (
                    MEMDB_CATEGORY_PATHSA,      // "Paths"
                    MEMDB_ITEM_RELOC_WINDIRA,   // "RelocWinDir"
                    RealTempFileSpec,           // Path to default hives
                    NULL,
                    0,
                    NULL
                    );

            *q = '\\';
        }
    }

    if (b && StringIMatchA (p, "USER.DAT")) {
        //
        // Save location to all user.dat files in UserDatLoc
        //

        b = MemDbSetValueExA (
                MEMDB_CATEGORY_USER_DAT_LOCA,
                UserName,
                NULL,
                RealTempFileSpec,
                (DWORD) CreateOnly,
                NULL
                );
    }

    if (b) {
        DEBUGMSGA ((DBG_NAUSEA, "%s -> %s", HivePath, RealTempFileSpec));
    }

    return b;
}


VOID
MarkShellFolderForMoveA (
    IN      PCSTR SrcPath,
    IN      PCSTR TempPath
    )
{
    DWORD Offset;

    //
    // Add an entry so the specified source file or directory
    // is moved to the temp path.
    //

    MemDbSetValueExA (
        MEMDB_CATEGORY_SHELL_FOLDERS_PATHA,
        SrcPath,
        NULL,
        NULL,
        0,
        &Offset
        );

    MemDbSetValueExA (
        MEMDB_CATEGORY_SF_TEMPA,
        TempPath,
        NULL,
        NULL,
        Offset,
        NULL
        );
}


BOOL
EnumFirstFileRelocA (
    OUT     PFILERELOC_ENUMA EnumPtr,
    IN      PCSTR FileSpec             OPTIONAL
    )
{
    if (EnumFirstFileOpA (&EnumPtr->e, ALL_DEST_CHANGE_OPERATIONS, FileSpec)) {
        if (!EnumPtr->e.PropertyValid) {
            return EnumNextFileRelocA (EnumPtr);
        } else {
            StringCopyA (EnumPtr->SrcFile, EnumPtr->e.Path);
            StringCopyA (EnumPtr->DestFile, EnumPtr->e.Property);

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnumNextFileRelocA (
    IN OUT  PFILERELOC_ENUMA EnumPtr
    )
{
    do {
        if (!EnumNextFileOpA (&EnumPtr->e)) {
            return FALSE;
        }
    } while (!EnumPtr->e.PropertyValid);

    StringCopyA (EnumPtr->SrcFile, EnumPtr->e.Path);
    StringCopyA (EnumPtr->DestFile, EnumPtr->e.Property);

    return TRUE;
}


/*++

Routine Description:

  DeclareTemporaryFile adds a file to the memdb FileDel and CancelFileDel
  category. That means the file will get deleted if the user hits CANCEL
  or at the end of GUI mode setup.

Arguments:

  FileSpec - Specifies the file to declare in long name format

Return Value:

  TRUE if the file was recorded in memdb, or FALSE if it could not be recorded.

--*/

BOOL
DeclareTemporaryFileA (
    IN      PCSTR FileSpec
    )

{
    return MarkFileForCleanUpA (FileSpec) &&
           MemDbSetValueExA (MEMDB_CATEGORY_CANCELFILEDELA, FileSpec, NULL, NULL, 0, NULL);

}


BOOL
DeclareTemporaryFileW (
    IN      PCWSTR FileSpec
    )

{
    return MarkFileForCleanUpW (FileSpec) &&
           MemDbSetValueExW (MEMDB_CATEGORY_CANCELFILEDELW, FileSpec, NULL, NULL, 0, NULL);

}



/*++

Routine Description:

  FileIsProvidedByNt identifies a file as being installed by Windows NT.
  An entry is made in the NtFiles category for the file name, and the file
  name is linked to the full path in NtDirs.

  This funciton is implemented as an A version only because the list is
  created on the Win9x side of the upgrade.

Arguments:

  FullPath - Specifies the full path, including the file name.

  FileName - Specifiles the file name only

  UserFlags - Specifies if the existence of NT file should be verified very first
              thing on NT side.

Return Value:

  TRUE if memdb was updated, or FALSE if an error occurred.

--*/

BOOL
FileIsProvidedByNtA (
    IN      PCSTR FullPath,
    IN      PCSTR FileName,
    IN      DWORD UserFlags
    )
{
    DWORD Offset;
    PSTR DirOnly;
    CHAR Key[MEMDB_MAX];
    PSTR p;
    BOOL b;

    DirOnly = DuplicatePathStringA (FullPath, 0);
    p = _mbsrchr (DirOnly, '\\');
    if (p) {
        *p = 0;
    }

    b = MemDbSetValueExA (
            MEMDB_CATEGORY_NT_DIRSA,
            DirOnly,
            NULL,
            NULL,
            0,
            &Offset
            );

    if (b) {
        MemDbBuildKeyA (Key, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
        b = MemDbSetValueAndFlagsA (Key, Offset, UserFlags, 0);
    }

    FreePathStringA (DirOnly);

    return b;
}



/*++

Routine Description:

  GetNtFilePath looks in the NtFiles category for the specified file,
  and if found builds the complete path.

Arguments:

  FileName - Specifies the file that may be installed by NT

  FullPath - Receives the full path to the file as it will be installed

Return Value:

  TRUE if the file exists and there were no errors building the path,
  or FALSE if the file does not exist or the path could not be built.

--*/

BOOL
GetNtFilePathA (
    IN      PCSTR FileName,
    OUT     PSTR FullPath
    )
{
    DWORD Offset;
    CHAR Node[MEMDB_MAX];

    MemDbBuildKeyA (Node, MEMDB_CATEGORY_NT_FILESA, FileName, NULL, NULL);
    if (MemDbGetValueA (Node, &Offset)) {
        if (MemDbBuildKeyFromOffsetA (Offset, FullPath, 1, NULL)) {
            StringCopyA (AppendPathWackA (FullPath), FileName);
            return TRUE;
        }

        DEBUGMSG ((DBG_WHOOPS, "GetNtFilePath: Could not build path from offset"));
    }

    return FALSE;
}


BOOL
GetNtFilePathW (
    IN      PCWSTR FileName,
    OUT     PWSTR FullPath
    )
{
    DWORD Offset;
    WCHAR Node[MEMDB_MAX];

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_NT_FILESW, FileName, NULL, NULL);
    if (MemDbGetValueW (Node, &Offset)) {
        if (MemDbBuildKeyFromOffsetW (Offset, FullPath, 1, NULL)) {
            StringCopyW (AppendPathWackW (FullPath), FileName);
            return TRUE;
        }

        DEBUGMSG ((DBG_WHOOPS, "GetNtFilePath: Could not build path from offset"));
    }

    return FALSE;
}


DWORD
GetFileInfoOnNtW (
    IN      PCWSTR FileSpec,
    OUT     PWSTR  NewFileSpec,   // OPTIONAL
    IN      UINT   BufferChars    // Required if NewFileSpec is specified
    )
{
    WCHAR Node[MEMDB_MAX];
    DWORD Operations;
    DWORD Offset;
    WCHAR NtFilePath[MEMDB_MAX];
    WCHAR DestPath[MEMDB_MAX];
    PCWSTR InboundPath;
    BOOL UserFile = FALSE;
    DWORD status = FILESTATUS_UNCHANGED;
    BOOL ShortFileNameFlag;
    PCWSTR UltimateDestiny;
    BOOL NtProvidesThisFile;
    WCHAR LongFileSpec[MAX_WCHAR_PATH];
    PCWSTR SanitizedPath;
    PCSTR ansiPath;
    CHAR ansiOutput[MAX_MBCHAR_PATH];
    PWSTR lastWack;

    //
    // Require FileSpec to be a local path and less than MAX_WCHAR_PATH
    //

    if (lstrlen (FileSpec) >= MAX_WCHAR_PATH) {
        if (NewFileSpec) {
            _wcssafecpy (NewFileSpec, FileSpec, BufferChars * sizeof (WCHAR));
        }

        return 0;
    }

    //
    // Now get the file status of an actual path
    //

    SanitizedPath = SanitizePathW (FileSpec);
    if (!SanitizedPath) {
        SanitizedPath = DuplicatePathStringW (FileSpec, 0);
    }

    lastWack = wcsrchr (SanitizedPath, L'\\');
    if (lastWack) {
        if (lastWack[1] != 0 || lastWack == wcschr (SanitizedPath, L'\\')) {
            lastWack = NULL;
        } else {
            *lastWack = 0;
        }
    }

    pFileOpsGetLongPathW (SanitizedPath, LongFileSpec);
    if (!StringIMatchW (SanitizedPath, LongFileSpec)) {
        InboundPath = LongFileSpec;
        ShortFileNameFlag = TRUE;
    } else {
        InboundPath = SanitizedPath;
        ShortFileNameFlag = FALSE;
    }

    DestPath[0] = 0;
    UltimateDestiny = InboundPath;

    //
    // Get all operations set on the file
    //

    MemDbBuildKeyW (Node, MEMDB_CATEGORY_PATHROOTW, InboundPath, NULL, NULL);
    if (!MemDbGetValueAndFlagsW (Node, NULL, &Operations)) {
        Operations = 0;
    }

    //
    // Migration DLLs have priority over all other operations
    //

    if (Operations & OPERATION_MIGDLL_HANDLED) {

        if (Operations & OPERATION_FILE_DELETE_EXTERNAL) {
            status = FILESTATUS_DELETED;
        } else {
            status = FILESTATUS_REPLACED;
            if (Operations & OPERATION_FILE_MOVE_EXTERNAL) {
                status |= FILESTATUS_MOVED;
                GetNewPathForFileW (InboundPath, DestPath);
                UltimateDestiny = DestPath;
            }
        }

    } else {
        //
        // Check for per-user move
        //

        if (g_CurrentUser) {
            MemDbBuildKeyW (
                Node,
                MEMDB_CATEGORY_USERFILEMOVE_SRCW,
                InboundPath,
                g_CurrentUser,
                NULL
                );

            if (MemDbGetValueW (Node, &Offset)) {
                if (MemDbBuildKeyFromOffsetW (Offset, DestPath, 1, NULL)) {
                    status = FILESTATUS_MOVED;
                    UltimateDestiny = DestPath;
                }

                UserFile = TRUE;
            }
        }

        //
        // Check for move or delete
        //

        if (!UserFile) {
            if (Operations & ALL_MOVE_OPERATIONS) {
                status = FILESTATUS_MOVED;
                GetNewPathForFileW (InboundPath, DestPath);
                UltimateDestiny = DestPath;
                if (Operations & OPERATION_FILE_MOVE_EXTERNAL) {
                    status |= FILESTATUS_REPLACED;
                }
            } else if (Operations & ALL_DELETE_OPERATIONS) {
                status = FILESTATUS_DELETED;
            }
        }

        //
        // Check if the file (or the new destination) is an NT file
        //

        NtProvidesThisFile = GetNtFilePathW (GetFileNameFromPathW (UltimateDestiny), NtFilePath);

        if (status != FILESTATUS_UNCHANGED && NtProvidesThisFile) {

            //
            // Status may be either FILESTATUS_MOVED or FILESTATUS_DELETED.
            //

            if (StringIMatchW (UltimateDestiny, NtFilePath)) {

                //
                // NT installs the same file, so now we know that the ultimate
                // destiny isn't deleted.
                //

                status &= ~FILESTATUS_DELETED;
                status |= FILESTATUS_REPLACED|FILESTATUS_NTINSTALLED;

            } else if (Operations & ALL_DELETE_OPERATIONS) {

                //
                // NT installs the same file but in a different location
                // and the original file was to be deleted.  The
                // ultimate destiny is the NT location, and we know that the
                // file is moved.
                //

                status = FILESTATUS_MOVED|FILESTATUS_REPLACED|FILESTATUS_NTINSTALLED;
                UltimateDestiny = NtFilePath;

            } else {

                status |= FILESTATUS_NTINSTALLED;

            }

        } else if (NtProvidesThisFile) {

            //
            // Status is FILESTATUS_UNCHANGED
            //

            status = FILESTATUS_NTINSTALLED;

            if (StringIMatchW (UltimateDestiny, NtFilePath)) {
                status |= FILESTATUS_REPLACED;
            }
        }

        if (!ShortFileNameFlag && (status == FILESTATUS_UNCHANGED)) {
            //
            // let's check for this case: undetected short file name query, NT installs this file in the same path
            //
            if (ISNT()) {
                OurGetLongPathNameW (SanitizedPath, LongFileSpec, MAX_WCHAR_PATH);

                if (!StringMatchW (UltimateDestiny, LongFileSpec)) {
                    //
                    // this was an undetected short file name query
                    //
                    NtProvidesThisFile = GetNtFilePathW (GetFileNameFromPathW (UltimateDestiny), NtFilePath);

                    if (StringIMatchW (UltimateDestiny, NtFilePath)) {
                        status |= FILESTATUS_REPLACED;
                    }
                }
            }
        }
    }

    //
    // Return the new path to the caller
    //

    if (NewFileSpec) {
        if (lastWack) {
            //
            // BUGBUG - ugly truncation can happen here
            //

            BufferChars -= sizeof (WCHAR);
        }

        if (status & FILESTATUS_MOVED) {

            if (ShortFileNameFlag) {
                if (ISNT()) {
                    if (!OurGetShortPathNameW (UltimateDestiny, NewFileSpec, MAX_WCHAR_PATH)) {
                        _wcssafecpy (NewFileSpec, UltimateDestiny, BufferChars * sizeof (WCHAR));
                    }
                } else {
                    ansiPath = ConvertWtoA (UltimateDestiny);
                    if (!OurGetShortPathNameA (ansiPath, ansiOutput, ARRAYSIZE(ansiOutput))) {
                        _mbssafecpy (ansiOutput, ansiPath, BufferChars);
                    }
                    FreeConvertedStr (ansiPath);

                    KnownSizeAtoW (NewFileSpec, ansiOutput);
                }
            } else {
                _wcssafecpy (NewFileSpec, UltimateDestiny, BufferChars * sizeof (WCHAR));
            }
        } else {
            _wcssafecpy (NewFileSpec, SanitizedPath, BufferChars * sizeof (WCHAR));
        }

        if (lastWack) {
            AppendWackW (NewFileSpec);
        }
    }

    if (Operations & ALL_CONTENT_CHANGE_OPERATIONS) {
        status |= FILESTATUS_BACKUP;
    }

    FreePathStringW (SanitizedPath);

    return status;
}


DWORD
GetFileStatusOnNtW (
    IN      PCWSTR FileName
    )
{
    return GetFileInfoOnNtW (FileName, NULL, 0);
}


PWSTR
GetPathStringOnNtW (
    IN      PCWSTR FileName
    )
{
    PWSTR newFileName;

    newFileName = AllocPathStringW (MEMDB_MAX);

    GetFileInfoOnNtW (FileName, newFileName, MEMDB_MAX);

    return newFileName;
}


DWORD
GetFileInfoOnNtA (
    IN      PCSTR FileName,
    OUT     PSTR  NewFileName,   // OPTIONAL
    IN      UINT  BufferChars    // Required if NewFileSpec is specified
    )
{
    PCWSTR UnicodeFileName;
    PWSTR UnicodeNewFileName = NULL;
    DWORD fileStatus;

    if (NewFileName && BufferChars) {
        UnicodeNewFileName = AllocPathStringW (BufferChars);
    }

    UnicodeFileName = ConvertAtoW (FileName);

    fileStatus = GetFileInfoOnNtW (UnicodeFileName, UnicodeNewFileName, BufferChars);

    FreeConvertedStr (UnicodeFileName);

    if (NewFileName && BufferChars) {

        KnownSizeWtoA (NewFileName, UnicodeNewFileName);

        FreePathStringW (UnicodeNewFileName);
    }

    return fileStatus;
}


DWORD
GetFileStatusOnNtA (
    IN      PCSTR FileName
    )
{
    return GetFileInfoOnNtA (FileName, NULL, 0);
}


PSTR
GetPathStringOnNtA (
    IN      PCSTR FileName
    )
{
    PSTR newFileName;

    newFileName = AllocPathStringA (MEMDB_MAX);

    GetFileInfoOnNtA (FileName, newFileName, MEMDB_MAX);

    return newFileName;
}



/*++

Routine Description:

  ExtractArgZero locates the first argument in a command line and copies
  it to Buffer.  Assumes the break is the first space character, the ending
  quote of a quoted argument, or the nul terminator.

Arguments:

  CmdLine - Specifies the full command line that has zero or more arguments

  Buffer - Receives the  first argument on the command line if it exists, or
           an empty string if it does not exist.  Must hold MAX_TCHAR_PATH
           bytes.

  TerminatingChars - Specifies character set that terminates the command line arg.
                     If NULL, the set " ,;"

Return Value:

  none

--*/

PCSTR
ExtractArgZeroExA (
    IN      PCSTR CmdLine,
    OUT     PSTR Buffer,
    IN      PCSTR TerminatingChars,     OPTIONAL
    IN      BOOL KeepQuotes
    )
{
    CHAR cmdLine1 [MAX_CMDLINE];
    CHAR cmdLine2 [MAX_CMDLINE];
    PSTR spacePtr1 [MAX_PATH];
    PSTR spacePtr2 [MAX_PATH];
    UINT spaceIdx = 0;
    PSTR ptr1 = cmdLine1;
    PSTR ptr2 = cmdLine2;
    PSTR end;
    CHAR saved;
    PCSTR s = CmdLine;
    BOOL inQuote = FALSE;
    BOOL skipQuotes = FALSE;
    MBCHAR ch;
    BOOL fullPath = FALSE;
    WIN32_FIND_DATAA FindData;

    ch = _mbsnextc (CmdLine);
    fullPath = (isalpha (ch) && *(_mbsinc (CmdLine)) == ':');

    for (;;) {

        ch = _mbsnextc (s);

        if (ch == 0) {
            break;
        }

        if (ch == '\"') {
            skipQuotes = TRUE;
            inQuote = !inQuote;
        }
        else {
            if (!inQuote) {
                if (TerminatingChars && _mbschr (TerminatingChars, ch)) {
                    break;
                }
                if (isspace (ch)) {
                    if (spaceIdx < MAX_PATH) {
                        spacePtr1 [spaceIdx] = ptr1;
                        spacePtr2 [spaceIdx] = ptr2;
                        spaceIdx ++;
                    }
                    else {
                        // too many spaces. We better stop now.
                        break;
                    }
                }
            }

        }
        if (KeepQuotes && skipQuotes) {
            _copymbchar (ptr2, s);
            ptr2 = _mbsinc (ptr2);
        }
        if (skipQuotes) {
            skipQuotes = FALSE;
        }
        else {
            _copymbchar (ptr1, s);
            ptr1 = _mbsinc (ptr1);
            _copymbchar (ptr2, s);
            ptr2 = _mbsinc (ptr2);
        }
        s = _mbsinc(s);
    }

    saved = 0;
    *ptr1 = 0;
    *ptr2 = 0;
    end = ptr2;
    for (;;) {
        if (fullPath && DoesFileExistExA (cmdLine1, &FindData)) {
            break;
        }

        if (ISNT()) {
            if (GetOperationsOnPathA (cmdLine1)) {
                break;
            }
        }

        if (spaceIdx) {
            spaceIdx --;
            *ptr2 = saved;
            ptr1 = spacePtr1 [spaceIdx];
            ptr2 = spacePtr2 [spaceIdx];
            if (fullPath) {
                saved = *ptr2;
            }
            *ptr1 = 0;
            *ptr2 = 0;
        }
        else {
            *ptr2 = saved;
            break;
        }
    }

    StringCopyA (Buffer, cmdLine2);

    if (*ptr2) {
        return (CmdLine + (end - cmdLine2));
    }
    else {
        return (CmdLine + (ptr2 - cmdLine2));
    }
}


PCWSTR
ExtractArgZeroExW (
    IN      PCWSTR CmdLine,
    OUT     PWSTR Buffer,
    IN      PCWSTR TerminatingChars,    OPTIONAL
    IN      BOOL KeepQuotes
    )
{
    WCHAR cmdLine1 [MAX_CMDLINE];
    WCHAR cmdLine2 [MAX_CMDLINE];
    PWSTR spacePtr1 [MAX_PATH];
    PWSTR spacePtr2 [MAX_PATH];
    UINT spaceIdx = 0;
    PWSTR ptr1 = cmdLine1;
    PWSTR ptr2 = cmdLine2;
    PWSTR end;
    WCHAR saved;
    PCWSTR s = CmdLine;
    BOOL inQuote = FALSE;
    BOOL skipQuotes = FALSE;
    BOOL fullPath = FALSE;
    WIN32_FIND_DATAW FindData;

    fullPath = (iswalpha (CmdLine[0]) && (CmdLine[1] == L':'));

    for (;;) {

        if (*s == 0) {
            break;
        }

        if (*s == '\"') {
            skipQuotes = TRUE;
            inQuote = !inQuote;
        }
        else {
            if (!inQuote) {
                if (TerminatingChars && wcschr (TerminatingChars, *s)) {
                    break;
                }
                if (iswspace (*s)) {
                    if (spaceIdx < MAX_PATH) {
                        spacePtr1 [spaceIdx] = ptr1;
                        spacePtr2 [spaceIdx] = ptr2;
                        spaceIdx ++;
                    }
                    else {
                        // too many spaces. We better stop now.
                        break;
                    }
                }
            }

        }
        if (KeepQuotes && skipQuotes) {
            *ptr2 = *s;
            ptr2 ++;
        }
        if (skipQuotes) {
            skipQuotes = FALSE;
        }
        else {
            *ptr1 = *s;
            ptr1 ++;
            *ptr2 = *s;
            ptr2 ++;
        }
        s ++;
    }

    saved = 0;
    *ptr1 = 0;
    *ptr2 = 0;
    end = ptr2;
    for (;;) {
        if (fullPath && DoesFileExistExW (cmdLine1, &FindData)) {
            break;
        }
        if (ISNT()) {
            if (GetOperationsOnPathW (cmdLine1)) {
                break;
            }
        }

        if (spaceIdx) {
            spaceIdx --;
            *ptr2 = saved;
            ptr1 = spacePtr1 [spaceIdx];
            ptr2 = spacePtr2 [spaceIdx];
            if (fullPath) {
                saved = *ptr2;
            }
            *ptr1 = 0;
            *ptr2 = 0;
        }
        else {
            *ptr2 = saved;
            break;
        }
    }

    StringCopyW (Buffer, cmdLine2);

    if (*ptr2) {
        return (CmdLine + (end - cmdLine2));
    }
    else {
        return (CmdLine + (ptr2 - cmdLine2));
    }
}


BOOL
pIsExcludedFromBackupW (
    IN      PCWSTR Path,
    IN      PCWSTR TempDir      OPTIONAL
    )
{
    PCWSTR fileName;

    fileName = GetFileNameFromPathW (Path);
    if (!fileName) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"win386.swp")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"backup.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"moved.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"delfiles.txt")) {
        return TRUE;
    }

    if (StringIMatchW (fileName, L"deldirs.txt")) {
        return TRUE;
    }

    if (StringIMatchW (Path, L"c:\\boot.ini")) {
        return TRUE;
    }

    if (TempDir) {
        if (StringIPrefixW (Path, TempDir)) {
            fileName = Path + TcharCountW (TempDir) + 1;
            if (wcschr (fileName, L'\\')) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

HANDLE
pCreateFileList (
    IN      PCSTR TempDir,
    IN      PCSTR FileName,
    IN      BOOL InUninstallSubDir
    )
{
    HANDLE file;
    PCSTR fileString;
    DWORD bytesWritten;
    CHAR decoratedFile[MAX_PATH];
    PCSTR fileToUse;

    if (!InUninstallSubDir) {
        fileToUse = FileName;
    } else {
        wsprintfA (decoratedFile, "uninstall\\%s", FileName);
        fileToUse = decoratedFile;
    }
    fileString = JoinPathsA (TempDir, fileToUse);

    file = CreateFileA (
                fileString,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (file == INVALID_HANDLE_VALUE) {
        LOGA ((LOG_ERROR,"Error creating file %s.", fileString));
        FreePathStringA (fileString);
        return INVALID_HANDLE_VALUE;
    }

    DeclareTemporaryFileA (fileString);
    FreePathStringA (fileString);

    //
    // Write UNICODE signature
    //
    // Do not write as a string. FE is a lead byte.
    //
    if ((!WriteFile (file, "\xff\xfe", 2, &bytesWritten, NULL)) ||
        (bytesWritten != 2)
        ) {
        LOG ((LOG_ERROR,"Unable to write unicode header."));
        CloseHandle (file);
        return INVALID_HANDLE_VALUE;
    }

    return file;
}


BOOL
WriteHashTableToFileW (
    IN HANDLE File,
    IN HASHTABLE FileTable
    )
{

    UINT unused;
    HASHTABLE_ENUMW e;
    BOOL result = TRUE;

    if (!FileTable || File == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    if (EnumFirstHashTableStringW (&e, FileTable)) {
        do {

            if (!WriteFile (File, e.String, ByteCountW (e.String), &unused, NULL)) {
                result = FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &unused, NULL)) {
                result = FALSE;
            }

        } while (result && EnumNextHashTableStringW (&e));
    }

    return result;
}

PWSTR
pGetParentDirPathFromFilePathW(
    IN      PCWSTR FilePath,
    OUT     PWSTR DirPath
    )
{
    PWSTR ptr;

    if(!FilePath || !DirPath){
        MYASSERT(FALSE);
        return NULL;
    }

    StringCopyW(DirPath, FilePath);
    ptr = wcsrchr(DirPath, '\\');
    if(ptr){
        *ptr = '\0';
    }

    return DirPath;
}

PSTR
pGetParentDirPathFromFilePathA(
    IN      PCSTR FilePath,
    OUT     PSTR DirPath
    )
{
    PSTR ptr;

    if(!FilePath || !DirPath){
        MYASSERT(FALSE);
        return NULL;
    }

    StringCopyA(DirPath, FilePath);
    ptr = _mbsrchr(DirPath, '\\');
    if(ptr){
        *ptr = '\0';
    }

    return DirPath;
}

BOOL
IsDirEmptyA(
     IN      PCSTR DirPathPtr
     )
{
    TREE_ENUMA e;
    BOOL result;

    if (!EnumFirstFileInTreeExA (
        &e,
        DirPathPtr,
        NULL,
        FALSE,
        FALSE,
        FILE_ENUM_ALL_LEVELS
        )) {
        result = TRUE;
    }
    else{
        AbortEnumFileInTreeA(&e);
        result = FALSE;
    }

    return result;
}

BOOL
IsDirEmptyW(
     IN      PCWSTR DirPathPtr
     )
{
    TREE_ENUMW e;
    BOOL result;

    if (!EnumFirstFileInTreeExW (
        &e,
        DirPathPtr,
        NULL,
        FALSE,
        FALSE,
        FILE_ENUM_ALL_LEVELS
        )) {
        result = TRUE;
    }
    else{
        AbortEnumFileInTreeW(&e);
        result = FALSE;
    }

    return result;
}

VOID
pAddDirWorkerW (
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist,   OPTIONAL
    IN      DWORD InitialAttributes
    )
{
    DWORD fileAttributes;
    BOOL addToCategory;
    WCHAR parentDirPath[MAX_WCHAR_PATH];
    PCWSTR parentDirPathPtr;
    FILE_ENUMW e;

    //
    // We are adding to the empty dirs category, which once held
    // empty dirs, but now holds all kinds of dirs and their attributes
    //

    if (!DirPathPtr) {
        MYASSERT(FALSE);
        return;
    }

    //
    // Ignore root dir
    //

    if (!DirPathPtr[0] ||           // C
        !DirPathPtr[1] ||           // :
        !DirPathPtr[2] ||           // backslash
        !DirPathPtr[3]
        ) {
        return;
    }

    addToCategory = FALSE;

    fileAttributes = InitialAttributes;
    if (fileAttributes == INVALID_ATTRIBUTES) {
        fileAttributes = GetFileAttributesW (DirPathPtr);
    }

    if (fileAttributes != INVALID_ATTRIBUTES){
        if (!(fileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // Ignore files. If caller wants the parent dir, then
            // process it now.
            //

            if (AddParentDirIfFile) {
                parentDirPathPtr = pGetParentDirPathFromFilePathW (DirPathPtr, parentDirPath);
                if (parentDirPathPtr) {
                    AddDirPathToEmptyDirsCategoryW (parentDirPathPtr, FALSE, FALSE);
                }
            }

            return;
        }

        //
        // This is a dir, add it to memdb, and add attributes if they aren't normal
        //

        addToCategory = TRUE;
        if (fileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
            fileAttributes = 0;
        }

    } else {

        //
        // This file does not exist. If it is a dir spec, then
        // add it with no attributes.
        //

        if (!AddParentDirIfFile || !AddParentDirIfFileExist) {
            fileAttributes = 0;
            addToCategory = TRUE;
        }
    }

    if (addToCategory) {
        //
        // Add only if fileAttributes are non normal or
        // dir is empty
        //

        if (!fileAttributes) {
            if (EnumFirstFileW (&e, DirPathPtr, NULL)) {
                addToCategory = FALSE;
                AbortFileEnumW (&e);
            }
        }
    }

    if (addToCategory) {
        MemDbSetValueExW (
            MEMDB_CATEGORY_EMPTY_DIRSW,
            DirPathPtr,
            NULL,
            NULL,
            fileAttributes,
            NULL
            );
    }
}


VOID
AddDirPathToEmptyDirsCategoryW (
    IN      PCWSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    )
{
    pAddDirWorkerW (
        DirPathPtr,
        AddParentDirIfFile,
        AddParentDirIfFileExist,
        INVALID_ATTRIBUTES
        );
}


VOID
pAddDirWorkerA (
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist,   OPTIONAL
    IN      DWORD InitialAttributes
    )
{
    DWORD fileAttributes;
    BOOL addToCategory;
    CHAR parentDirPath[MAX_MBCHAR_PATH];
    PCSTR parentDirPathPtr;
    FILE_ENUMA e;

    //
    // We are adding to the empty dirs category, which once held
    // empty dirs, but now holds all kinds of dirs and their attributes
    //

    if (!DirPathPtr) {
        MYASSERT(FALSE);
        return;
    }

    addToCategory = FALSE;

    fileAttributes = InitialAttributes;
    if (fileAttributes == INVALID_ATTRIBUTES) {
        fileAttributes = GetFileAttributesA (DirPathPtr);
    }

    if (fileAttributes != INVALID_ATTRIBUTES){
        if (!(fileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // Ignore files. If caller wants the parent dir, then
            // process it now.
            //

            if (AddParentDirIfFile) {
                parentDirPathPtr = pGetParentDirPathFromFilePathA (DirPathPtr, parentDirPath);
                if (parentDirPathPtr) {
                    AddDirPathToEmptyDirsCategoryA (parentDirPathPtr, FALSE, FALSE);
                }
            }

            return;
        }

        //
        // This is a dir, add it to memdb, and add attributes if they aren't normal
        //

        addToCategory = TRUE;
        if (fileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
            fileAttributes = 0;
        }

    } else {

        //
        // This file does not exist. If it is a dir spec, then
        // add it with no attributes.
        //

        if (!AddParentDirIfFile || !AddParentDirIfFileExist) {
            fileAttributes = 0;
            addToCategory = TRUE;
        }
    }

    if (addToCategory) {
        //
        // Add only if fileAttributes are non normal or
        // dir is empty
        //

        if (!fileAttributes) {
            if (EnumFirstFileA (&e, DirPathPtr, NULL)) {
                addToCategory = FALSE;
                AbortFileEnumA (&e);
            }
        }
    }

    if (addToCategory) {
        MemDbSetValueExA (
            MEMDB_CATEGORY_EMPTY_DIRSA,
            DirPathPtr,
            NULL,
            NULL,
            fileAttributes,
            NULL
            );
    }
}


VOID
AddDirPathToEmptyDirsCategoryA(
    IN      PCSTR DirPathPtr,
    IN      BOOL AddParentDirIfFile,        OPTIONAL
    IN      BOOL AddParentDirIfFileExist    OPTIONAL
    )
{
    pAddDirWorkerA (
        DirPathPtr,
        AddParentDirIfFile,
        AddParentDirIfFileExist,
        INVALID_ATTRIBUTES
        );
}

BOOL
GetDiskSpaceForFilesList (
    IN      HASHTABLE FileTable,
    OUT     ULARGE_INTEGER * AmountOfSpace,                 OPTIONAL
    OUT     ULARGE_INTEGER * AmountOfSpaceIfCompressed,     OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    IN      BOOL ProcessDirs,                               OPTIONAL
    OUT     ULARGE_INTEGER * AmountOfSpaceClusterAligned    OPTIONAL
    )
/*++

Routine Description:

  GetDiskSpaceForFilesList calculate amount of space to store all files
  from FileTable hashtable.

Arguments:

  FileTable - Specifies container for paths of files.

  AmountOfSpace - Receives the amount of space required to store files.

  AmountOfSpaceIfCompressed - Receives the amount of space required to store
                              files, if compression will apply on files.

  CompressionFactor - Receives the compression factor in 0..100 range.

  BootCabImagePadding - Receives the backup disk space padding for
                           additional files like boot.cab.

Return Value:

  TRUE if IN parameters is correct, FALSE otherwise

--*/
{
    HASHTABLE_ENUMW e;
    WIN32_FIND_DATAA fileAttributeData;
    HANDLE h;
    ULARGE_INTEGER sizeOfFiles;
    ULARGE_INTEGER fileSize;
    unsigned int numberOfFiles = 0;
    char filePathNameA[MAX_PATH * 2];
    ULARGE_INTEGER BootCabImagePaddingInBytes;
    TCHAR DirPath[MAX_PATH * 2];
    ULARGE_INTEGER clusterSize = {512, 0};
    char drive[_MAX_DRIVE] = "?:";
    DWORD sectorsPerCluster;
    DWORD bytesPerSector;

    if (!FileTable) {
        return FALSE;
    }

    sizeOfFiles.QuadPart = 0;

    if (EnumFirstHashTableStringW (&e, FileTable)) {
        do {
            KnownSizeUnicodeToDbcsN(filePathNameA, e.String, wcslen(e.String) + 1);

            h = FindFirstFileA (filePathNameA, &fileAttributeData);
            if(h != INVALID_HANDLE_VALUE) {
                FindClose (h);
                if(!(fileAttributeData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)){
                    fileSize.LowPart = fileAttributeData.nFileSizeLow;
                    fileSize.HighPart = fileAttributeData.nFileSizeHigh;

                    sizeOfFiles.QuadPart += fileSize.QuadPart;
                    numberOfFiles++;

                    if(AmountOfSpaceClusterAligned){
                        if(UNKNOWN_DRIVE == drive[0]){

                            drive[0] = filePathNameA[0];

                            if(GetDiskFreeSpaceA(drive, &sectorsPerCluster, &bytesPerSector, NULL, NULL)){
                                clusterSize.QuadPart = sectorsPerCluster * bytesPerSector;
                                AmountOfSpaceClusterAligned->QuadPart = 0;
                            }
                            else{
                                DEBUGMSG((DBG_VERBOSE, "GetDiskFreeSpace failed in GetDiskSpaceForFilesList"));
                                AmountOfSpaceClusterAligned = NULL;
                                continue;
                            }
                        }

                        AmountOfSpaceClusterAligned->QuadPart +=
                            fileSize.QuadPart % clusterSize.QuadPart? // || sizeOfFiles.QuadPart == NULL
                                ((fileSize.QuadPart / clusterSize.QuadPart) + 1) * clusterSize.QuadPart:
                                fileSize.QuadPart;
                    }
                }

                if(ProcessDirs){
                    AddDirPathToEmptyDirsCategoryA(filePathNameA, TRUE, TRUE);
                }

                MYASSERT(DirPath);
            }
            else {
                //DEBUGMSGA((DBG_VERBOSE, "SETUP: GetDiskSpaceForFilesList - file does not exist: %s", filePathNameA));
            }
        } while (EnumNextHashTableStringW (&e));
    }

    if(!BootCabImagePadding) {
        BootCabImagePaddingInBytes.QuadPart = BACKUP_DISK_SPACE_PADDING_DEFAULT;
        DEBUGMSG ((DBG_VERBOSE, "Disk space padding for backup image: %i MB (DEFAULT)", BootCabImagePadding));
    }
    else{
        BootCabImagePaddingInBytes.QuadPart = BootCabImagePadding;
        BootCabImagePaddingInBytes.QuadPart <<= 20;
        DEBUGMSG ((DBG_VERBOSE, "Disk space padding for backup image: %i MB", BootCabImagePadding));
    }

    if(AmountOfSpaceClusterAligned){
        AmountOfSpaceClusterAligned->QuadPart += BootCabImagePaddingInBytes.QuadPart;
    }

    if(AmountOfSpace) {
        AmountOfSpace->QuadPart = sizeOfFiles.QuadPart + BootCabImagePaddingInBytes.QuadPart;
    }

    if(AmountOfSpaceIfCompressed) {
        if(!CompressionFactor) {
            CompressionFactor = COMPRESSION_RATE_DEFAULT;
            DEBUGMSG ((DBG_VERBOSE, "Compression factor: %i (DEFAULT)", CompressionFactor));
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "Compression factor: %i", CompressionFactor));

        AmountOfSpaceIfCompressed->QuadPart =
            (sizeOfFiles.QuadPart * CompressionFactor) / 100 +
            STARTUP_INFORMATION_BYTES_NUMBER * numberOfFiles + BootCabImagePaddingInBytes.QuadPart;//boot.cab
    }

    return TRUE;
}


#if 0
BOOL
pGetTruePathName (
    IN      PCWSTR InPath,
    OUT     PWSTR OutPath
    )
{
    PCSTR start;
    PCSTR end;
    WIN32_FIND_DATAA fd;
    PCSTR ansiInPath;
    CHAR ansiOutPath[MAX_MBCHAR_PATH];
    HANDLE findHandle;
    PSTR p;

    //
    // If not a local path, ignore it. If longer than MAX_PATH, ignore it.
    //

    if (!InPath[0] || InPath[1] != L':' || InPath[2] != L'\\') {
        StringCopyW (OutPath, InPath);
        return;
    }

    if (TcharCount (InPath) >= MAX_PATH) {
        StringCopyW (OutPath, InPath);
        return;
    }

    //
    // Convert down to ANSI because Win9x API requirements
    //

    ansiInPath = ConvertWtoA (InPath);

    //
    // Copy the drive spec
    //

    start = ansiInPath;
    end = start + 2;
    MYASSERT (*end == '\\');

    p = ansiOutPath;

    StringCopyABA (p, start, end);
    p = GetEndOfStringA (p);

    //
    // Walk the path, and for each segment, get the full name via
    // FindFirstFile
    //

    start = end + 1;
    end = _mbschr (start, '\\');
    if (!end) {
        end = GetEndOfStringA (start);
    }

    for (;;) {
        if (end > start + 1) {
            *p++ = '\\';
            StringCopyABA (p, start, end);

            findHandle = FindFirstFileA (ansiOutPath, &fd);

            if (findHandle == INVALID_HANDLE_VALUE) {
                //
                // File/directory does not exist. Use the remaining
                // string as passed in.
                //

                StringCopyA (p, start);

                DEBUGMSGA ((DBG_ERROR, "File %s not found", ansiInPath));

                KnownSizeAtoW (OutPath, ansiOutPath);
                FreeConvertedStr (ansiInPath);
                return FALSE;
            }

            //
            // Copy the file system's value to the out buffer
            //

            StringCopyA (p, fd.cFileName);
            p = GetEndOfStringA (p);

            FindClose (findHandle);
        }

        //
        // Advance to the next segment
        //

        if (*end) {
            start = end + 1;
            end = _mbschr (start, '\\');
            if (!end) {
                end = GetEndOfStringA (start);
            }
        } else {
            break;
        }
    }

    KnownSizeAtoW (OutPath, ansiOutPath);
    FreeConvertedStr (ansiInPath);
    return TRUE;
}
#endif

VOID
pPutInBackupTable (
    IN      HASHTABLE BackupTable,
    IN      HASHTABLE SourceTable,
    IN      PCWSTR Path
    )
{
    if (pIsExcludedFromBackupW (Path, NULL)) {
        return;
    }

    if (!HtFindStringW (SourceTable, Path)) {
        HtAddStringW (SourceTable, Path);
        MarkFileForBackupW (Path);
        HtAddStringW (BackupTable, Path);
    }
}


VOID
pPutInDelFileTable (
    IN      HASHTABLE DelFileTable,
    IN      HASHTABLE DestTable,
    IN      PCWSTR Path
    )
{
    if (!HtFindStringW (DestTable, Path)) {
        HtAddStringW (DestTable, Path);
        HtAddStringW (DelFileTable, Path);
    }
}


BOOL
pIsWinDirProfilesPath (
    IN      PCWSTR PathToTest
    )
{
    static WCHAR winDirProfiles[MAX_PATH];
    CHAR winDirProfilesA[MAX_PATH];
    UINT rc;

    if (!(winDirProfiles[0])) {
        rc = GetWindowsDirectoryA (winDirProfilesA, MAX_PATH - 9);
        if (rc && rc < (MAX_PATH - 9)) {
            KnownSizeAtoW (winDirProfiles, winDirProfilesA);
        } else {
            LOG ((LOG_ERROR, "GetWindowsDirectoryA failed"));
            return FALSE;
        }

        StringCatW (winDirProfiles, L"\\Profiles");
    }

    return StringIMatchW (PathToTest, winDirProfiles);
}


BOOL
WriteBackupFilesA (
    IN      BOOL Win9xSide,
    IN      PCSTR TempDir,
    OUT     ULARGE_INTEGER * OutAmountOfSpaceIfCompressed,  OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpace,              OPTIONAL
    IN      INT CompressionFactor,                          OPTIONAL
    IN      INT BootCabImagePadding,                        OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceForDelFiles,   OPTIONAL
    OUT     ULARGE_INTEGER * OutAmountOfSpaceClusterAligned OPTIONAL
    )

/*++

Routine Description:

  WriteBackupFiles outputs the files needed by the text mode backup engine
  to create a backup image. This includes:

    backup.txt      - Lists all files that need to be backed up, either
                      because they are Win9x-specific, or are replaced
                      during the upgrade.

    moved.txt       - Lists all files that were moved from a Win9x location
                      to a temporary or NT location

    delfiles.txt    - Lists all files that are new to the upgraded OS

    deldirs.txt     - Lists subdirectories that are new to the upgraded OS

Arguments:

  Win9xSide - Specifies TRUE if setup is running on Win9x. This causes the
              files to be generated for the rollback of an incomplete setup.

              Specifies FALSE if setup is running on NT. This causes the
              files to be generated for the rollback of the final NT OS.

  TempDir - Specifies the setup temporary directory (%windir%\setup).

  OutAmountOfSpaceIfCompressed - return amount of space for backup files, if
                                 compression will apply.

  OutAmountOfSpace - return amount of space for backup files, if compression
                     will not apply.

  CompressionFactor - receives the compression factor in 0..100 range.

  BootCabImagePadding - receives the backup disk space padding for
                           additional files.

Return Value:

  TRUE if the files were created successfully, FALSE otherwise.

--*/

{
    MEMDB_ENUMW e;
    TREE_ENUMA treeEnumA;
    PCSTR ansiRoot;
    PCSTR ansiFullPath;
    PCWSTR unicodeFullPath;
    PCWSTR unicodeTempDir = NULL;
    PBYTE bufferRoot;
    PWSTR buffer;
    WCHAR pattern[MAX_PATH];
    DWORD  bytesWritten;
    DWORD Count = 0;
    PWSTR srcFile = NULL;
    PWSTR destFile = NULL;
    DWORD status;
    HANDLE backupFileList = INVALID_HANDLE_VALUE;
    HANDLE movedOutput = INVALID_HANDLE_VALUE;
    HANDLE delDirsList = INVALID_HANDLE_VALUE;
    HANDLE mkDirsList = INVALID_HANDLE_VALUE;
    HANDLE delFilesList = INVALID_HANDLE_VALUE;
    HASHTABLE backupTable = NULL;
    HASHTABLE delFileTable = NULL;
    HASHTABLE delDirTable = NULL;
    HASHTABLE mkDirsTable = NULL;
    HASHTABLE srcTable = HtAllocExW (FALSE, 0, 41911);
    HASHTABLE destTable = HtAllocExW (FALSE, 0, 41911);
    UINT type;
    ULARGE_INTEGER AmountOfSpace;
    ULARGE_INTEGER AmountOfSpaceIfCompressed;
    ULARGE_INTEGER AmountOfSpaceClusterAligned;
    ULARGE_INTEGER FreeBytesAvailableUser;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER FreeBytesAvailable;
    DWORD attribs;
    PCSTR ansiFile;
    PWSTR entryName;
    DWORD fileAttributes;
    PCSTR dirName;
    BOOL IsDirExist;
    UINT depth;
    POOLHANDLE moveListPool;
    MOVELISTW moveList;
    BOOL result = FALSE;
    HASHTABLE_ENUM htEnum;
    PWSTR thisDir;
    PWSTR lastDir;
    PWSTR p;
    FILEOP_ENUMW OpEnum;
    ALL_FILEOPS_ENUMW allOpEnum;

    __try {
        bufferRoot = MemAllocUninit ((MEMDB_MAX * 6) * sizeof (WCHAR));
        if (!bufferRoot) {
            __leave;
        }

        srcFile = (PWSTR) bufferRoot;
        destFile = srcFile + MEMDB_MAX;
        buffer = destFile + MEMDB_MAX;
        thisDir = buffer + MEMDB_MAX;
        lastDir = thisDir + MEMDB_MAX;
        entryName = lastDir + MEMDB_MAX;

        //
        // Open the output files
        //
        backupTable = HtAllocExW(TRUE, 0, 31013);
        delFileTable = HtAllocExW(TRUE, 0, 10973);
        delDirTable = HtAllocExW(TRUE, 0, 23);

        delFilesList = pCreateFileList (TempDir, "delfiles.txt", TRUE);
        delDirsList = pCreateFileList (TempDir, "deldirs.txt", TRUE);

        moveListPool = PoolMemInitNamedPool ("Reverse Move List");
        if (!moveListPool) {
            DEBUGMSG ((DBG_ERROR, "Can't create move list pool"));
            __leave;
        }

        moveList = AllocateMoveListW (moveListPool);
        if (!moveList) {
            DEBUGMSG ((DBG_ERROR, "Can't create move list"));
            __leave;
        }

        if (delFilesList == INVALID_HANDLE_VALUE ||
            delDirsList == INVALID_HANDLE_VALUE
            ) {
            DEBUGMSG ((DBG_ERROR, "Can't open one of the backup files"));
            __leave;
        }

        if (Win9xSide) {
            mkDirsTable = HtAllocExW(TRUE, 0, 0);

            backupFileList = pCreateFileList (TempDir, "backup.txt", FALSE);
            mkDirsList = pCreateFileList (TempDir, "mkdirs.txt", TRUE);

            if (backupFileList == INVALID_HANDLE_VALUE ||
                mkDirsList == INVALID_HANDLE_VALUE
                ) {
                DEBUGMSG ((DBG_ERROR, "Can't open one of the backup files"));
                __leave;
            }

        }

        unicodeTempDir = ConvertAtoW (TempDir);

        //
        // Go through the registered operations and put the reverse action
        // in the undo hash tables. As files are processed here, they are
        // recorded in the source and dest hash tables, so they don't end
        // up in multiple hash tables.
        //

        if (EnumFirstPathInOperationW (&OpEnum, OPERATION_LONG_FILE_NAME)) {
            do {
                //
                // Ignore excluded files
                // Ignore already processed files
                //

                // we fix this with case-insensitive srcTable and rely on
                // the first entry being the proper case
                //pGetTruePathName (OpEnum.Path, caseCorrectName);

                if (pIsExcludedFromBackupW (OpEnum.Path, unicodeTempDir)) {
                    continue;
                }

                if (HtFindStringW (srcTable, OpEnum.Path)) {
                    continue;
                }

                //
                // If this is a preserved dir, then put it in mkdirs.txt
                //

                if (mkDirsTable) {
                    MYASSERT (Win9xSide);

                    if (IsDirectoryMarkedAsEmptyW (OpEnum.Path)) {

                        ansiFile = ConvertWtoA (OpEnum.Path);

                        if (ansiFile) {
                            attribs = GetFileAttributesA (ansiFile);

                            if (attribs != INVALID_ATTRIBUTES) {
                                if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                                    HtAddStringW (mkDirsTable, OpEnum.Path);
                                }
                            }

                            FreeConvertedStr (ansiFile);
                        }

                    }
                }

                //
                // Process the source file given in OpEnum.Path
                //

                status = GetFileInfoOnNtW (OpEnum.Path, destFile, MEMDB_MAX);

                if (status & FILESTATUS_BACKUP) {
                    //
                    // This file is going to change -- back it up
                    //

                    if (backupFileList != INVALID_HANDLE_VALUE) {
                        //
                        // If this file is a directory, then back up the whole tree
                        //

                        ansiFile = ConvertWtoA (OpEnum.Path);
                        attribs = GetFileAttributesA (ansiFile);

                        if (attribs != INVALID_ATTRIBUTES &&
                            (attribs & FILE_ATTRIBUTE_DIRECTORY)
                            ) {
                            if (EnumFirstFileInTreeA (&treeEnumA, ansiFile, NULL, FALSE)) {
                                do {

                                    unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);
                                    pPutInBackupTable (backupTable, srcTable, unicodeFullPath);
                                    FreeConvertedStr (unicodeFullPath);

                                } while (EnumNextFileInTreeA (&treeEnumA));
                            }

                        } else if (attribs != INVALID_ATTRIBUTES) {
                            pPutInBackupTable (backupTable, srcTable, OpEnum.Path);
                        }

                        FreeConvertedStr (ansiFile);
                    }

                    //
                    // If the file is also going to be moved, remove the dest copy
                    //

                    if (status & FILESTATUS_MOVED) {
                        HtAddStringW (delFileTable, destFile);
                    }

                    //
                    // Keep track that we're done for good with the source
                    // file and dest file
                    //

                    HtAddStringW (srcTable, OpEnum.Path);
                    HtAddStringW (destTable, destFile);

                } else if (!Win9xSide && (status & FILESTATUS_MOVED)) {

                    if (!pIsWinDirProfilesPath (OpEnum.Path)) {
                        //
                        // This file isn't going to change, but it will be moved
                        //

                        InsertMoveIntoListW (
                            moveList,
                            destFile,
                            OpEnum.Path
                            );

                        //
                        // Keep track that we're done for good with the source
                        // file and dest file
                        //

                        HtAddStringW (srcTable, OpEnum.Path);
                        HtAddStringW (destTable, destFile);
                    }
                }

                //
                // Update UI
                //

                Count++;
                if (!(Count % 128)) {
                    if (!TickProgressBar ()) {
                        __leave;
                    }
                }

            } while (EnumNextPathInOperationW (&OpEnum));
        }

        //
        // On the Win9x side, put the temp file moves in the move hash table, so
        // that they are returned back to their original locations.
        //

        if (Win9xSide) {
            if (EnumFirstFileOpW (&allOpEnum, OPERATION_FILE_MOVE|OPERATION_TEMP_PATH, NULL)) {
                do {

                    //
                    // only take into account the first destination of a file
                    // (when allOpEnum.PropertyNum == 0)
                    // all other destinations are not relevant for textmode move
                    //
                    if (allOpEnum.PropertyValid && allOpEnum.PropertyNum == 0) {

                        if (!pIsWinDirProfilesPath (allOpEnum.Path)) {
                            InsertMoveIntoListW (
                                moveList,
                                allOpEnum.Property,
                                allOpEnum.Path
                                );
                        }

                        Count++;
                        if (!(Count % 256)) {
                            if (!TickProgressBar ()) {
                                __leave;
                            }
                        }
                    }

                } while (EnumNextFileOpW (&allOpEnum));
            }

            //
            // Enumerate all the SfTemp values and add them to the list of things to move.
            //

            if (MemDbGetValueExW (&e, MEMDB_CATEGORY_SF_TEMPW, NULL, NULL)) {
                do {

                    if (MemDbBuildKeyFromOffsetW (e.dwValue, srcFile, 1, NULL)) {

                        if (!pIsWinDirProfilesPath (srcFile)) {
                            InsertMoveIntoListW (
                                moveList,
                                e.szName,
                                srcFile
                                );
                        }

                        Count++;
                        if (!(Count % 256)) {
                            if (!TickProgressBar ()) {
                                __leave;
                            }
                        }
                    }

                } while (MemDbEnumNextValueW (&e));
            }

            //
            // Enumerate all DirsCollision values and add them to the list of things to move.
            //

            if (MemDbGetValueExW (&e, MEMDB_CATEGORY_DIRS_COLLISIONW, NULL, NULL)) {
                do {
                    if (EnumFirstFileOpW (&allOpEnum, OPERATION_FILE_MOVE, e.szName)) {

                        if (!pIsWinDirProfilesPath (allOpEnum.Path)) {
                            InsertMoveIntoListW (
                                moveList,
                                allOpEnum.Property,
                                e.szName
                                );
                        }
                    }
                } while (MemDbEnumNextValueW (&e));
            }
        }

        //
        // Process the NT file list, adding files specific to NT to the delete hash table
        //

        if (delFilesList != INVALID_HANDLE_VALUE) {

            MemDbBuildKeyW (pattern, MEMDB_CATEGORY_NT_FILESW, L"*", NULL, NULL);

            if (MemDbEnumFirstValueW (&e, pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

                do {
                    if (MemDbBuildKeyFromOffsetW (e.dwValue, buffer, 1, NULL)) {
                        StringCopyW (AppendWackW (buffer), e.szName);
                        pPutInDelFileTable (delFileTable, destTable, buffer);
                    }

                    Count++;
                    if (!(Count % 128)) {
                        if (!TickProgressBar ()) {
                            __leave;
                        }
                    }

                } while (MemDbEnumNextValueW (&e));
            }
        }

        //
        // Append the remaining files to the backup (Win9xSide) or delete
        // (!Win9xSide) lists by scanning the current file system. These specs
        // mostly come from win95upg.inf's [Backup] section. This INF is
        // parsed during WINNT32 and converted into memdb operations. The
        // memdb operations persist to the GUI mode side automatically, as
        // memdb is saved before reboot to text mode and is reloaded in GUI
        // mode.
        //

        if (MemDbEnumFirstValueW (
                &e,
                MEMDB_CATEGORY_CLEAN_OUTW L"\\*",
                MEMDB_ALL_SUBLEVELS,
                MEMDB_ENDPOINTS_ONLY
                )) {
            do {

                type = e.dwValue;

                //
                // If on Win9x, and if type is BACKUP_SUBDIRECTORY_TREE, then
                // back up the entire tree as well as putting it in the
                // deldirs.txt file.
                //
                if (Win9xSide) {
                    if (type == BACKUP_SUBDIRECTORY_TREE) {
                        type = BACKUP_AND_CLEAN_TREE;
                    } else if (type == BACKUP_AND_CLEAN_SUBDIR) {
                        type = BACKUP_SUBDIRECTORY_FILES;
                    }
                }

                if (type == BACKUP_FILE) {
                    //
                    // file
                    //

                    if (Win9xSide) {
                        //
                        // This is a single file or directory specification.
                        // - If it exists as a file, then back it up.
                        // - If it exists as a directory, then back up its
                        //   contents (if any).
                        // - If it does not exist, put it in the delete list.
                        //

                        ansiFile = ConvertWtoA (e.szName);
                        attribs = GetFileAttributesA (ansiFile);

                        if (attribs != INVALID_ATTRIBUTES) {
                            if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                                if (EnumFirstFileInTreeA (&treeEnumA, ansiFile, NULL, FALSE)) {
                                    do {
                                        unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);
                                        pPutInBackupTable (backupTable, srcTable, unicodeFullPath);
                                        FreeConvertedStr (unicodeFullPath);

                                    } while (EnumNextFileInTreeA (&treeEnumA));
                                }
                            } else {
                                pPutInBackupTable (backupTable, srcTable, e.szName);
                            }
                        } else {
                            pPutInDelFileTable (delFileTable, destTable, e.szName);
                        }

                        FreeConvertedStr (ansiFile);

                    } else {

                        //
                        // Put this file/subdirectory in the delete list
                        // unless it was either backed up or is the
                        // destination of a move. Note we rely on the fact
                        // that every time a file was put in the backup table
                        // on Win9xSide, it was also marked for explicit
                        // backup. This causes the loop at the top of this
                        // function to put the proper file spec in destTable.
                        //

                        GetNewPathForFileW (e.szName, buffer);
                        pPutInDelFileTable (delFileTable, destTable, buffer);
                    }

                } else {
                    //
                    // directory or tree
                    //

                    if (Win9xSide || type != BACKUP_AND_CLEAN_TREE) {
                        //
                        // Record backup or single dir cleanup
                        //

                        if (!Win9xSide) {
                            GetNewPathForFileW (e.szName, buffer);
                            ansiRoot = ConvertWtoA (buffer);
                        } else {
                            ansiRoot = ConvertWtoA (e.szName);
                        }

                        if (type == BACKUP_SUBDIRECTORY_FILES ||
                            type == BACKUP_AND_CLEAN_SUBDIR
                            ) {
                            depth = 1;
                        } else {
                            depth = FILE_ENUM_ALL_LEVELS;
                        }

                        if (EnumFirstFileInTreeExA (
                                &treeEnumA,
                                ansiRoot,
                                NULL,
                                FALSE,
                                FALSE,
                                depth
                                )) {

                            do {
                                if (treeEnumA.Directory) {
                                    continue;
                                }

                                unicodeFullPath = ConvertAtoW (treeEnumA.FullPath);

                                if (Win9xSide) {
                                    //
                                    // Mark this file for backup and put it in the txt file.
                                    //

                                    pPutInBackupTable (backupTable, srcTable, unicodeFullPath);

                                } else {
                                    //
                                    // Put this file in the delete list unless it was either
                                    // backed up or is the destination of a move. This is
                                    // the same logic as the call to pPutInDelFileTable above.
                                    //

                                    pPutInDelFileTable (delFileTable, destTable, unicodeFullPath);
                                }

                                FreeConvertedStr (unicodeFullPath);

                            } while (EnumNextFileInTreeA (&treeEnumA));
                        }

                        FreeConvertedStr (ansiRoot);
                    }

                    //
                    // Write deldirs entry if subdir should be blown away on
                    // rollback. (Backup files might be restored after the
                    // subdir is blown away.)
                    //
                    // For backups of type BACKUP_SUBDIRECTORY_TREE, put
                    // this subdirectory in the deldirs.txt file on the Win9x
                    // side. Deldirs.txt will be re-written in GUI mode
                    // without it.
                    //

                    if (type == BACKUP_AND_CLEAN_TREE) {
                        //
                        // Record tree deletes
                        //

                        GetNewPathForFileW (e.szName, buffer);
                        HtAddStringW (delDirTable, buffer);

                        if (Win9xSide) {
                            ansiFullPath = ConvertWtoA (e.szName);
                            AddDirPathToEmptyDirsCategoryA(ansiFullPath, TRUE, TRUE);
                            FreeConvertedStr (ansiFullPath);
                        }
                    }
                }

            } while (MemDbEnumNextValue (&e));
        }

        //
        // Disk Space calculation and check for availability
        //
        if(OutAmountOfSpaceIfCompressed || OutAmountOfSpace || OutAmountOfSpaceClusterAligned) {
            AmountOfSpace.QuadPart = 0;
            AmountOfSpaceIfCompressed.QuadPart = 0;
            AmountOfSpaceClusterAligned.QuadPart = 0;

            if(!GetDiskSpaceForFilesList(
                    backupTable,
                    &AmountOfSpace,
                    &AmountOfSpaceIfCompressed,
                    CompressionFactor,
                    BootCabImagePadding,
                    FALSE,
                    &AmountOfSpaceClusterAligned
                    )) {
                DEBUGMSG((DBG_WHOOPS, "Can't calculate disk space for files. GetDiskSpaceForFilesList - failed.\n"));
            } else {
                //
                // The disk space numbers include the padding necessary to ensure
                // a user's hard disk does not get filled completely
                //

                if (OutAmountOfSpaceIfCompressed) {
                    OutAmountOfSpaceIfCompressed->QuadPart = AmountOfSpaceIfCompressed.QuadPart;
                }

                if (OutAmountOfSpace) {
                    OutAmountOfSpace->QuadPart = AmountOfSpace.QuadPart;
                }

                if(OutAmountOfSpaceClusterAligned){
                    OutAmountOfSpaceClusterAligned->QuadPart = AmountOfSpaceClusterAligned.QuadPart;
                }

                DEBUGMSG((DBG_VERBOSE, "AmountOfSpace: %dMB\nAmountOfSpaceIfCompressed: %dMB\nAmountOfSpaceClusterAligned: %dMB", (UINT)(AmountOfSpace.QuadPart>>20), (UINT)(AmountOfSpaceIfCompressed.QuadPart>>20), (UINT)(AmountOfSpaceClusterAligned.QuadPart>>20)));
            }
        }

        //
        // Disk Space calculation for deldirs
        //
        if(OutAmountOfSpaceForDelFiles) {
            if(!GetDiskSpaceForFilesList(
                    delFileTable,
                    NULL,
                    NULL,
                    0,
                    1,
                    FALSE,
                    OutAmountOfSpaceForDelFiles
                    )) {
                DEBUGMSG((DBG_WHOOPS, "Can't calculate disk space for del files. GetDiskSpaceForFilesList - failed.\n"));
            } else {
                DEBUGMSG((DBG_VERBOSE, "AmountOfSpaceForDelFiles: %d MB", (UINT)(OutAmountOfSpaceForDelFiles->QuadPart>>20)));
            }
        }

        //
        // preserve attributes of all the backup file parent dirs
        //

        if (Win9xSide) {

            lastDir[0] = 0;

            if (EnumFirstHashTableStringW (&htEnum, backupTable)) {
                do {
                    //
                    // Put the dir attributes or file's parent attributes in
                    // memdb. Optimize for the case where there are several
                    // files in a row all from the same parent.
                    //

                    ansiFullPath = ConvertWtoA (htEnum.String);
                    attribs = GetFileAttributesA (ansiFullPath);

                    if (attribs != INVALID_ATTRIBUTES &&
                        !(attribs & FILE_ATTRIBUTE_DIRECTORY)
                        ) {

                        StringCopyTcharCountW (thisDir, htEnum.String, MEMDB_MAX);
                        p = wcsrchr (thisDir, L'\\');
                        if (p) {
                            *p = 0;
                        }

                        _wcslwr (thisDir);
                        MYASSERT (thisDir[0]);

                    } else {
                        thisDir[0] = 0;
                        lastDir[0] = 0;
                        if (attribs != INVALID_ATTRIBUTES) {
                            //
                            // Optimize for case where dir is normal
                            //

                            if (attribs == FILE_ATTRIBUTE_DIRECTORY) {
                                attribs = INVALID_ATTRIBUTES;
                            }
                        }
                    }

                    //
                    // record attributes in memdb
                    //

                    if (attribs != INVALID_ATTRIBUTES) {
                        if ((!thisDir[0]) || (!StringMatchW (lastDir, thisDir))) {
                            pAddDirWorkerA (ansiFullPath, TRUE, TRUE, attribs);
                            StringCopyW (lastDir, thisDir);
                        }
                    }

                    //
                    // continue with loop, remembering current dir
                    //

                    FreeConvertedStr (ansiFullPath);

                    Count++;
                    if (!(Count % 256)) {
                        if (!TickProgressBar ()) {
                            __leave;
                        }
                    }
                } while (EnumNextHashTableStringW (&htEnum));
            }
        }

        //
        // Transfer the empty dirs to a hash table. We could just output the
        // file now but to be consistent at the expense of a few milliseconds
        // we'll use the hash table.
        //

        if (mkDirsTable && MemDbEnumFirstValueW (
                                &e,
                                MEMDB_CATEGORY_EMPTY_DIRSW L"\\*",
                                MEMDB_ALL_SUBLEVELS,
                                MEMDB_ENDPOINTS_ONLY
                                )) {
            do {
                if (!e.szName[0] ||
                    e.szName[1] != L':' ||
                    e.szName[2] != L'\\' ||
                    !e.szName[3]
                    ) {
                    //
                    // Ignore roots & malformed entries
                    //
                    continue;
                }

                swprintf(
                    entryName,
                    e.dwValue? L"%s,%u": L"%s",
                    e.szName,
                    e.dwValue
                    );

                ansiFile = ConvertWtoA (e.szName);

                if (ansiFile) {
                    attribs = GetFileAttributesA (ansiFile);

                    if (attribs != INVALID_ATTRIBUTES) {
                        if (attribs & FILE_ATTRIBUTE_DIRECTORY) {
                            HtAddStringW (mkDirsTable, entryName);
                        }
                    }

                    FreeConvertedStr (ansiFile);
                }

            } while (MemDbEnumNextValue (&e));
        }

        //
        // blast the lists to disk
        //
        if (!WriteHashTableToFileW (backupFileList, backupTable)) {
            LOG ((LOG_ERROR, "Unable to write to backup.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (delFilesList, delFileTable)) {
            LOG ((LOG_ERROR, "Unable to write to delfiles.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (delDirsList, delDirTable)) {
            LOG ((LOG_ERROR, "Unable to write to deldirs.txt"));
            __leave;
        }

        if (!WriteHashTableToFileW (mkDirsList, mkDirsTable)) {
            LOG ((LOG_ERROR, "Unable to write to mkdirs.txt"));
            __leave;
        }

        //
        // Finalize move list processing. If we are on the Win9x side, then
        // allow nesting collisions (the second arg).
        //

        moveList = RemoveMoveListOverlapW (moveList);

        ansiFullPath = JoinPathsA (TempDir, "uninstall\\moved.txt");
        if (!ansiFullPath) {
            __leave;
        }

        movedOutput = CreateFileA (
                            ansiFullPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        FreePathStringA (ansiFullPath);

        if (!OutputMoveListW (movedOutput, moveList, !Win9xSide)) {
            LOG ((LOG_ERROR,"Unable to write to moved.txt."));
            __leave;
        }

        //
        // Success
        //

        result = TRUE;

    }
    __finally {

        if (backupFileList != INVALID_HANDLE_VALUE) {
            CloseHandle (backupFileList);
        }

        if (movedOutput != INVALID_HANDLE_VALUE) {
            CloseHandle (movedOutput);
        }

        if (delDirsList != INVALID_HANDLE_VALUE) {
            CloseHandle (delDirsList);
        }

        if (mkDirsList != INVALID_HANDLE_VALUE) {
            CloseHandle (mkDirsList);
        }

        if (delFilesList != INVALID_HANDLE_VALUE) {
            CloseHandle (delFilesList);
        }

        HtFree (backupTable);
        HtFree (delFileTable);
        HtFree (delDirTable);
        HtFree (mkDirsTable);
        HtFree (destTable);
        HtFree (srcTable);

        PoolMemDestroyPool (moveListPool);

        FreeConvertedStr (unicodeTempDir);

        if (bufferRoot) {
            FreeMem (bufferRoot);
        }

    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\memdb.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdb.c

Abstract:

    A simple memory-based database for associating flags
    with a string.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    jimschm     23-Sep-1998  Expanded user flags to 24 bits (from 12 bits)
    calinn      12-Dec-1997  Extended MemDbMakePrintableKey and MemDbMakeNonPrintableKey
    jimschm     03-Dec-1997  Added multi-thread synchronization
    jimschm     22-Oct-1997  Split into multiple source files,
                             added multiple memory block capability
    jimschm     16-Sep-1997  Hashing: delete fix
    jimschm     29-Jul-1997  Hashing, user flags added
    jimschm     07-Mar-1997  Signature changes
    jimschm     03-Mar-1997  PrivateBuildKeyFromOffset changes
    jimschm     18-Dec-1996  Fixed deltree bug

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif


//
// Global delcaration
//

PDATABASE g_db;
GROWLIST g_DatabaseList = GROWLIST_INIT;
BYTE g_SelectedDatabase;
PHIVE g_HeadHive;
CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG

#define FILE_SIGNATURE DEBUG_FILE_SIGNATURE
BOOL g_UseDebugStructs = TRUE;

#else

#define FILE_SIGNATURE RETAIL_FILE_SIGNATURE

#endif

//
// Private prototypes
//

INT
pCreateDatabase (
    PCWSTR Name
    );

BOOL
pInitializeDatabase (
    OUT     PDATABASE Database,
    IN      PCWSTR Name
    );

BOOL
pFreeDatabase (
    IN OUT  PDATABASE Database
    );

VOID
pFreeSelectedDatabase (
    VOID
    );

VOID
pFreeAllDatabases (
    VOID
    );

BOOL
pPrivateMemDbGetValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    );

BOOL
pInitializeMemDb (
    VOID
    );


//
// Implementation
//


BOOL
MemDb_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD Reason,
    IN PVOID lpv
    )

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  Reason    - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (Reason) {

    case DLL_PROCESS_ATTACH:
        if (!pInitializeMemDb()) {
            return FALSE;
        }

        InitializeCriticalSection (&g_MemDbCs);

        InitOperationTable();

        break;

    case DLL_PROCESS_DETACH:
        pFreeAllDatabases();
        FreeGrowList (&g_DatabaseList);
        DeleteCriticalSection (&g_MemDbCs);

        DumpBinTreeStats();

        break;
    }

    return TRUE;
}


BOOL
pInitializeMemDb (
    VOID
    )
{
    FreeGrowList (&g_DatabaseList);
    ZeroMemory (&g_DatabaseList, sizeof (g_DatabaseList));
    g_db = NULL;

    if (!InitializeHashBlock()) {
        return FALSE;
    }

    if (pCreateDatabase (L"") != 0) {
        return FALSE;
    }

    g_SelectedDatabase = 1;
    SelectDatabase (0);

    return TRUE;
}




BOOL
pInitializeDatabase (
    OUT     PDATABASE Database,
    IN      PCWSTR Name
    )
{
    UINT u;

    Database->AllocSize = BLOCK_SIZE;

    Database->Buf = (PBYTE) MemAlloc (g_hHeap, 0, Database->AllocSize);

    Database->End = 0;
    Database->FirstLevelRoot = INVALID_OFFSET;
    Database->FirstDeleted = INVALID_OFFSET;

    MYASSERT (INVALID_OFFSET == 0xFFFFFFFF);
    FillMemory (Database->TokenBuckets, sizeof (Database->TokenBuckets), 0xFF);

    _wcssafecpy (Database->Hive, Name, MAX_HIVE_NAME);

    return TRUE;
}

BOOL
pFreeDatabase (
    IN OUT  PDATABASE Database
    )
{
    if (Database->Buf) {
        MemFree (g_hHeap, 0, Database->Buf);
        Database->Buf = NULL;
    }
    Database->End = 0;
    Database->FirstLevelRoot = INVALID_OFFSET;
    Database->FirstDeleted = INVALID_OFFSET;
    Database->Hive[0] = 0;

    return TRUE;
}


INT
pCreateDatabase (
    PCWSTR Name
    )
{
    DATABASE Database;
    BYTE Index;
    UINT Count;
    UINT u;

    //
    // Does key exist already?
    //

    if (g_db) {
        SelectDatabase (0);

        if (INVALID_OFFSET != FindKeyStruct (g_db->FirstLevelRoot, Name)) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot create %ls because it already exists!", Name));
            SetLastError (ERROR_ALREADY_EXISTS);
            return -1;
        }
    }

    //
    // Scan list for a blank spot
    //

    Count = GrowListGetSize (&g_DatabaseList);
    for (u = 0 ; u < Count ; u++) {
        if (!GrowListGetItem (&g_DatabaseList, u)) {
            break;
        }
    }

    if (u < Count) {
        //
        // Use empty slot
        //

        Index = (BYTE) u;
    } else if (Count < 256) {
        //
        // No empty slot; grow the list
        //

        Index = (BYTE) Count;
        if (!GrowListAppend (&g_DatabaseList, NULL, 0)) {
            DEBUGMSG ((DBG_WARNING, "Could not create database because GrowListAppend failed"));
            return -1;
        }
    } else {
        DEBUGMSG ((DBG_ERROR, "Cannot have more than 256 databases in memdb!"));
        return -1;
    }

    //
    // Create the database memory block
    //

    pInitializeDatabase (&Database, Name);

    if (!GrowListSetItem (&g_DatabaseList, (UINT) Index, (PBYTE) &Database, sizeof (Database))) {
        DEBUGMSG ((DBG_WARNING, "Could not create database because GrowListSetItem failed"));
        pFreeDatabase (&Database);
        return -1;
    }

    return (INT) Index;
}


VOID
pDestroySelectedDatabase (
    VOID
    )
{
    //
    // Free all resources for the database
    //

    pFreeSelectedDatabase ();

    //
    // For all databases except for the root, free the DATABASE
    // structure in g_DatabaseList.
    //

    if (g_SelectedDatabase) {
        GrowListResetItem (&g_DatabaseList, (UINT) g_SelectedDatabase);
    }
}


VOID
pFreeSelectedDatabase (
    VOID
    )
{
    //
    // Free all resources used by a single database
    //

    if (g_db->Buf) {
        MemFree (g_hHeap, 0, g_db->Buf);
    }

    FreeAllBinaryBlocks();

    ZeroMemory (g_db, sizeof (DATABASE));
}


VOID
pFreeAllDatabases (
    VOID
    )
{
    UINT Count;
    UINT Index;

    //
    // Free all database blocks
    //

    Count = GrowListGetSize (&g_DatabaseList);
    for (Index = 0 ; Index < Count ; Index++) {
        if (SelectDatabase ((BYTE) Index)) {
            pDestroySelectedDatabase();
        }
    }

    //
    // Free global hash table
    //

    FreeHashBlock();

    SelectDatabase(0);
}


BOOL
SelectDatabase (
    BYTE DatabaseId
    )
{
    PDATABASE Database;

    if (g_SelectedDatabase == DatabaseId) {
        return TRUE;
    }

    Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, (UINT) DatabaseId);
    if (!Database) {
        DEBUGMSG ((DBG_WHOOPS, "MemDb: Invalid database selection!"));
        return FALSE;
    }

    g_db = Database;
    g_SelectedDatabase = DatabaseId;

    return TRUE;
}


PCWSTR
SelectHive (
    PCWSTR FullKeyStr
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    PCWSTR End;

    //
    // Determine if root of FullKeyStr is part of a hive
    //

    End = wcschr (FullKeyStr, L'\\');
    if (End) {
        Count = GrowListGetSize (&g_DatabaseList);
        for (Index = 1 ; Index < Count ; Index++) {
            Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

            if (Database && StringIMatchABW (Database->Hive, FullKeyStr, End)) {
                //
                // Match found; select the database and return the subkey
                //

                SelectDatabase ((BYTE) Index);
                End = _wcsinc (End);
                return End;
            }
        }
    }
    SelectDatabase (0);

    return FullKeyStr;
}


BOOL
IsTemporaryKey (
    PCWSTR FullKeyStr
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    PCWSTR End;

    End = wcschr (FullKeyStr, L'\\');
    if (!End) {
        End = GetEndOfStringW (FullKeyStr);
    }
    Count = GrowListGetSize (&g_DatabaseList);
    for (Index = 1 ; Index < Count ; Index++) {
        Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

        if (Database && StringIMatchABW (Database->Hive, FullKeyStr, End)) {
            //
            // Match found; return true
            //
            return TRUE;
        }
    }
    return FALSE;
}


//
// MemDbSetValue creates or modifies KeyStr.  The value of the key is changed
// when the return value is TRUE.
//

BOOL
PrivateMemDbSetValueA (
    PCSTR Key,
    DWORD Val,
    DWORD SetFlags,
    DWORD ClearFlags,
    PDWORD Offset
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (Key);
    if (p) {
        b = PrivateMemDbSetValueW (p, Val, SetFlags, ClearFlags, Offset);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
PrivateMemDbSetValueW (
    PCWSTR Key,
    DWORD Val,
    DWORD SetFlags,
    DWORD ClearFlags,
    PDWORD Offset
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (Key);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            KeyOffset = NewKey (SubKey, Key);
            if (KeyOffset == INVALID_OFFSET) {
                __leave;
            }
        }

        KeyStruct = GetKeyStruct (KeyOffset);
        FreeKeyStructBinaryBlock (KeyStruct);

        KeyStruct->dwValue = Val;
        if (Offset) {
            *Offset = KeyOffset | (g_SelectedDatabase << RESERVED_BITS);
        }
        KeyStruct->Flags = KeyStruct->Flags & ~(ClearFlags & KSF_USERFLAG_MASK);
        KeyStruct->Flags = KeyStruct->Flags | (SetFlags & KSF_USERFLAG_MASK);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


BOOL
PrivateMemDbSetBinaryValueA (
    IN      PCSTR Key,
    IN      PCBYTE Data,
    IN      DWORD SizeOfData,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (Key);
    if (p) {
        b = PrivateMemDbSetBinaryValueW (p, Data, SizeOfData, Offset);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
PrivateMemDbSetBinaryValueW (
    IN      PCWSTR Key,
    IN      PCBYTE Data,
    IN      DWORD SizeOfData,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (Key);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            KeyOffset = NewKey (SubKey, Key);
            if (KeyOffset == INVALID_OFFSET) {
                __leave;
            }

        }

        KeyStruct = GetKeyStruct (KeyOffset);

        // Free existing buffer
        FreeKeyStructBinaryBlock (KeyStruct);

        // Alloc new buffer
        KeyStruct->BinaryPtr = AllocBinaryBlock (Data, SizeOfData, KeyOffset);
        if (!KeyStruct->BinaryPtr) {
            __leave;
        }

        KeyStruct->Flags |= KSF_BINARY;

        if (Offset) {
            *Offset = KeyOffset | (g_SelectedDatabase << RESERVED_BITS);
        }

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


BOOL
MemDbSetValueA (
    IN  PCSTR KeyStr,
    IN  DWORD dwValue
    )
{
    return PrivateMemDbSetValueA (KeyStr, dwValue, 0, 0, NULL);
}

BOOL
MemDbSetValueW (
    IN  PCWSTR KeyStr,
    IN  DWORD dwValue
    )
{
    return PrivateMemDbSetValueW (KeyStr, dwValue, 0, 0, NULL);
}

BOOL
MemDbSetValueAndFlagsA (
    IN  PCSTR KeyStr,
    IN  DWORD dwValue,
    IN  DWORD SetUserFlags,
    IN  DWORD ClearUserFlags
    )
{
    return PrivateMemDbSetValueA (KeyStr, dwValue, SetUserFlags, ClearUserFlags, NULL);
}

BOOL
MemDbSetValueAndFlagsW (
    IN  PCWSTR KeyStr,
    IN  DWORD dwValue,
    IN  DWORD SetUserFlags,
    IN  DWORD ClearUserFlags
    )
{
    return PrivateMemDbSetValueW (KeyStr, dwValue, SetUserFlags, ClearUserFlags, NULL);
}

BOOL
MemDbSetBinaryValueA (
    IN      PCSTR KeyStr,
    IN      PCBYTE Data,
    IN      DWORD DataSize
    )
{
    return PrivateMemDbSetBinaryValueA (KeyStr, Data, DataSize, NULL);
}


BOOL
MemDbSetBinaryValueW (
    IN      PCWSTR KeyStr,
    IN      PCBYTE Data,
    IN      DWORD DataSize
    )
{
    return PrivateMemDbSetBinaryValueW (KeyStr, Data, DataSize, NULL);
}



//
// GetValue takes a full key string and returns the
// value to the caller-supplied DWORD.  Value
// may be NULL to check only for existance of the
// value.
//

BOOL
pPrivateMemDbGetValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = pPrivateMemDbGetValueW (p, Value, UserFlagsPtr);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
pPrivateMemDbGetValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value,           OPTIONAL
    OUT PDWORD UserFlagsPtr     OPTIONAL
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyStr);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);
        CopyFlagsToPtr (GetKeyStruct (KeyOffset), UserFlagsPtr);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}

BOOL
MemDbGetValueA (
    IN  PCSTR Key,
    OUT PDWORD ValuePtr         OPTIONAL
    )
{
    return pPrivateMemDbGetValueA (Key, ValuePtr, NULL);
}

BOOL
MemDbGetValueW (
    IN  PCWSTR Key,
    OUT PDWORD ValuePtr         OPTIONAL
    )
{
    return pPrivateMemDbGetValueW (Key, ValuePtr, NULL);
}

BOOL
MemDbGetValueAndFlagsA (
    IN  PCSTR Key,
    OUT PDWORD ValuePtr,        OPTIONAL
    OUT PDWORD UserFlagsPtr
    )
{
    return pPrivateMemDbGetValueA (Key, ValuePtr, UserFlagsPtr);
}

BOOL
MemDbGetValueAndFlagsW (
    IN  PCWSTR Key,
    OUT PDWORD ValuePtr,       OPTIONAL
    OUT PDWORD UserFlagsPtr
    )
{
    return pPrivateMemDbGetValueW (Key, ValuePtr, UserFlagsPtr);
}


PCBYTE
MemDbGetBinaryValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD DataSize        OPTIONAL
    )
{
    PCWSTR p;
    BYTE const * b = NULL;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetBinaryValueW (p, DataSize);
        FreeConvertedStr (p);
    }

    return b;
}

PCBYTE
MemDbGetBinaryValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD DataSize        OPTIONAL
    )
{
    DWORD KeyOffset;
    PKEYSTRUCT KeyStruct;
    PCWSTR SubKey;
    PCBYTE Result = NULL;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyStr);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        KeyStruct = GetKeyStruct (KeyOffset);

        if (DataSize) {
            *DataSize = GetKeyStructBinarySize (KeyStruct);
        }

        Result = GetKeyStructBinaryData (KeyStruct);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return Result;
}


//
// GetPatternValue takes a full key string and returns the
// value to the caller-supplied DWORD.  The stored value string
// is treated as a pattern, but KeyStr is not a pattern.
// The return value represents the first match found.
//

BOOL
MemDbGetPatternValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetPatternValueW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
MemDbGetPatternValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SubKey = SelectHive (KeyStr);

        KeyOffset = FindPatternKey (g_db->FirstLevelRoot, SubKey, FALSE);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


//
// MemDbGetStoredEndPatternValue takes a full key string and returns the
// value to the caller-supplied DWORD.  The stored value string
// is treated as a pattern, but KeyStr is not a pattern.
// The return value represents the first match found.
//
// If the last stored key segment is an asterisk, then the pattern
// is considered to match.
//

BOOL
MemDbGetStoredEndPatternValueA (
    IN  PCSTR KeyStr,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyStr);
    if (p) {
        b = MemDbGetStoredEndPatternValueW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
MemDbGetStoredEndPatternValueW (
    IN  PCWSTR KeyStr,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SubKey = SelectHive (KeyStr);

        KeyOffset = FindPatternKey (g_db->FirstLevelRoot, SubKey, TRUE);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


//
// GetValueWithPattern takes a full key string that may contain
// wildcards between the backslashes, and returns the value
// to the caller-supplied DWORD.  The stored value string
// is not treated as a pattern.  The return value represents
// the first match found.
//

BOOL
MemDbGetValueWithPatternA (
    IN  PCSTR KeyPattern,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyPattern);
    if (p) {
        b = MemDbGetValueWithPatternW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}

BOOL
MemDbGetValueWithPatternW (
    IN  PCWSTR KeyPattern,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyPattern);

        KeyOffset = FindKeyUsingPattern (g_db->FirstLevelRoot, SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}



BOOL
MemDbGetPatternValueWithPatternA (
    IN  PCSTR KeyPattern,
    OUT PDWORD Value
    )
{
    PCWSTR p;
    BOOL b = FALSE;

    p = ConvertAtoW (KeyPattern);
    if (p) {
        b = MemDbGetPatternValueWithPatternW (p, Value);
        FreeConvertedStr (p);
    }

    return b;
}


BOOL
MemDbGetPatternValueWithPatternW (
    IN  PCWSTR KeyPattern,
    OUT PDWORD Value
    )
{
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {
        SubKey = SelectHive (KeyPattern);

        KeyOffset = FindPatternKeyUsingPattern (g_db->FirstLevelRoot, SubKey);
        if (KeyOffset == INVALID_OFFSET) {
            __leave;
        }

        CopyValToPtr (GetKeyStruct (KeyOffset), Value);

        b = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


VOID
MemDbDeleteValueA (
    IN  PCSTR KeyStr
    )
{
    PCWSTR p;

    p = ConvertAtoW (KeyStr);
    if (p) {
        MemDbDeleteValueW (p);
        FreeConvertedStr (p);
    }
}

VOID
MemDbDeleteValueW (
    IN  PCWSTR KeyStr
    )
{
    PCWSTR SubKey;

    EnterCriticalSection (&g_MemDbCs);

    SubKey = SelectHive (KeyStr);
    DeleteKey (SubKey, &g_db->FirstLevelRoot, TRUE);

    LeaveCriticalSection (&g_MemDbCs);
}


VOID
MemDbDeleteTreeA (
    IN  PCSTR KeyStr
    )
{
    PCWSTR p;

    p = ConvertAtoW (KeyStr);
    if (p) {
        MemDbDeleteTreeW (p);
        FreeConvertedStr (p);
    }
}

VOID
MemDbDeleteTreeW (
    IN  PCWSTR KeyStr
    )
{
    PCWSTR SubKey;

    EnterCriticalSection (&g_MemDbCs);

    SubKey = SelectHive (KeyStr);
    DeleteKey (SubKey, &g_db->FirstLevelRoot, FALSE);

    LeaveCriticalSection (&g_MemDbCs);
}


//
// Enum functions
//

BOOL
MemDbEnumFirstValueA (
    OUT     PMEMDB_ENUMA EnumPtr,
    IN      PCSTR PatternStr,
    IN      INT Depth,
    IN      DWORD Flags
    )
{
    BOOL b = FALSE;
    PCWSTR p;
    PCSTR str;
    MEMDB_ENUMW enumw;

    p = ConvertAtoW (PatternStr);
    if (p) {
        b = MemDbEnumFirstValueW (&enumw, p, Depth, Flags);
        FreeConvertedStr (p);
    } else {
        b = FALSE;
    }

    if (b) {
        str = ConvertWtoA (enumw.szName);
        if (str) {
            // ANSI struct is padded to match UNICODE
            MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
            CopyMemory (EnumPtr, &enumw, sizeof (MEMDB_ENUMW));

            // Only the output key name needs to be converted
            StringCopyA (EnumPtr->szName, str);
            FreeConvertedStr (str);
        } else {
            b = FALSE;
        }
    }

    return b;
}

BOOL
MemDbEnumFirstValueW (
    OUT     PMEMDB_ENUMW EnumPtr,
    IN      PCWSTR PatternStr,
    IN      INT Depth,
    IN      DWORD Flags
    )
{
    PCWSTR Start;
    PCWSTR wstrLastWack;
    PCWSTR SubPatternStr;

    SubPatternStr = SelectHive (PatternStr);

    //
    // Init the EnumPtr struct
    //

    ZeroMemory (EnumPtr, sizeof (MEMDB_ENUM));

    if (!Depth) {
        Depth = MAX_ENUM_POS;
    }

    EnumPtr->Depth = Depth;
    EnumPtr->Flags = Flags;

    //
    // If pattern has wack, locate the starting level by
    // counting the number of parts that do not have
    // wildcard characters.
    //

    Start = SubPatternStr;
    while (wstrLastWack = wcschr (Start, L'\\')) {

        // See if part has a wildcard character
        while (Start < wstrLastWack) {
            if (*Start == L'*' || *Start == L'?')
                break;
            Start++;
        }

        // If a wildcard character was found, we have to stop here
        if (Start < wstrLastWack)
            break;

        // Otherwise, look at next part of the pattern
        Start = wstrLastWack + 1;
        EnumPtr->Start++;
    }

    EnumPtr->PosCount = 1;
    EnumPtr->LastPos[0] = INVALID_OFFSET;
    StringCopyW (EnumPtr->PatternStr, PatternStr);

    return MemDbEnumNextValueW (EnumPtr);
}


BOOL
MemDbEnumNextValueA (
    IN OUT  PMEMDB_ENUMA EnumPtr
    )
{
    BOOL b = FALSE;
    PCSTR str;
    MEMDB_ENUMW enumw;

    // ANSI struct is padded to match UNICODE
    MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
    CopyMemory (&enumw, EnumPtr, sizeof (MEMDB_ENUMW));

    // ANSI output members are ignored (i.e. EnumPtr->szName)
    b = MemDbEnumNextValueW (&enumw);

    if (b) {
        str = ConvertWtoA (enumw.szName);
        if (str) {
            // ANSI struct is padded to match UNICODE
            MYASSERT (sizeof (MEMDB_ENUMW) == sizeof (MEMDB_ENUMA));
            CopyMemory (EnumPtr, &enumw, sizeof (MEMDB_ENUMW));

            // Only the output key name needs to be converted
            StringCopyA (EnumPtr->szName, str);
            FreeConvertedStr (str);
        } else {
            b = FALSE;
        }
    }

    return b;
}

BOOL
MemDbEnumNextValueW (
    IN OUT  PMEMDB_ENUMW EnumPtr
    )
{
    // no init allowed in declarations
    PKEYSTRUCT KeyStruct = NULL;
    int Count;
    int Level;
    WCHAR PartBuf[MEMDB_MAX];
    PWSTR PartStr;
    PWSTR Src, Dest;
    int Pos;
    BOOL Wildcard;
    BOOL MatchNotFound;
    PCWSTR SubPatternStr;

    EnterCriticalSection (&g_MemDbCs);

    SubPatternStr = SelectHive (EnumPtr->PatternStr);

    MatchNotFound = TRUE;

    do {

        Wildcard = FALSE;

        //
        // The following states exist upon entry:
        //
        //   STATE                        DESCRIPTION
        // First time through   PosCount == 1, LastPos[0] == INVALID_OFFSET
        //
        // Not first time       LastPos[PosCount - 1] == INVALID_OFFSET
        // through
        //
        // Not first time       LastPos[PosCount - 1] != INVALID_OFFSET
        // through, last match
        // hit the depth
        // ceiling
        //
        // PosCount points to the current unprocessed level, or when the
        // depth ceiling is reached, it points to the level of the last
        // match.
        //

        do {
            //
            // Build PartStr
            //

            Pos = EnumPtr->PosCount - 1;
            Count = Pos + 1;

            // Locate start of pattern part (if it is long enough)
            PartStr = PartBuf;
            for (Src = (PWSTR) SubPatternStr ; Count > 1 ; Count--) {

                Src = wcschr (Src, L'\\');

                if (!Src) {
                    break;
                }

                Src++;
            }

            // Copy part from pattern to buffer
            if (Src) {
                Dest = PartStr;
                while (*Src && *Src != L'\\') {
                    *Dest = *Src;
                    Wildcard = Wildcard || (*Dest == L'*') || (*Dest == L'?');
                    Dest++;
                    Src++;
                }

                // Truncate
                *Dest = 0;
            }

            // Use asterisk when pattern is shorter than current level
            else {
                PartStr = L"*";
                Wildcard = TRUE;
            }

            //
            // If current level is set to invalid offset, we have not yet
            // tried it.
            //

            if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {

                //
                // Initialize the level
                //

                if (Pos == 0) {
                    EnumPtr->LastPos[0] = g_db->FirstLevelRoot;
                } else {
                    KeyStruct = GetKeyStruct (EnumPtr->LastPos[Pos - 1]);
                    EnumPtr->LastPos[Pos] = KeyStruct->NextLevelRoot;
                }

                //
                // If still invalid, the level is complete, and we need to
                // go back.
                //

                if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                    EnumPtr->PosCount--;
                    continue;
                }

                //
                // Level ready to be processed
                //

                if (!Wildcard) {
                    //
                    // Use binary tree to locate this item.  If no match, the pattern
                    // will not match anything.  Otherwise, we found something to
                    // return.
                    //

                    EnumPtr->LastPos[Pos] = FindKeyStruct (EnumPtr->LastPos[Pos], PartStr);
                    if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                        //
                        // Non-wildcard ot found.  We can try going back because
                        // there might be a pattern at a higher level.
                        //
                        if (Pos > 0) {
                            PCWSTR p;
                            INT ParentLevel = 0;
                            INT LastParentLevel;

                            LastParentLevel = 0;

                            // Locate the previous pattern level
                            p = SubPatternStr;
                            while (*p && ParentLevel < Pos) {
                                // Locate wack, pattern or nul
                                while (*p && *p != L'\\') {
                                    if (*p == L'?' || *p == L'*') {
                                        break;
                                    }
                                    p++;
                                }

                                // If pattern or nul, set last pattern level
                                if (*p != L'\\') {
                                    LastParentLevel = ParentLevel + 1;

                                    // Jump to wack if not at nul
                                    while (*p && *p != L'\\') {
                                        p++;
                                    }
                                }

                                // If more pattern exists, skip wack
                                if (p[0] && p[1]) {
                                    MYASSERT (p[0] == L'\\');
                                    p++;
                                }
                                ParentLevel++;
                            }

                            // Default: when no pattern, last pattern level is parent
                            // (Pos is zero-based while LastParentLevel is one-based)
                            if (!(*p)) {
                                LastParentLevel = Pos;
                            }

                            if (LastParentLevel) {
                                // Yes, a pattern does exist at a higher level
                                EnumPtr->PosCount = LastParentLevel;
                                continue;
                            }
                        }

                        // Pattern not found, we have exhausted all possibilities
                        LeaveCriticalSection (&g_MemDbCs);
                        return FALSE;
                    }

                    // If level is before start, keep searching forward instead
                    // of reporting a result.

                    if (EnumPtr->PosCount <= EnumPtr->Start) {
                        EnumPtr->PosCount++;
                        EnumPtr->LastPos[Pos + 1] = INVALID_OFFSET;
                        continue;
                    }

                    // Break out of last nested loop
                    break;
                } else {
                    //
                    // Because of pattern, each item in the level must be examined.
                    // Set the pos to the first item and fall through to the pattern
                    // search code.
                    //

                    EnumPtr->LastPos[Pos] = GetFirstOffset (EnumPtr->LastPos[Pos]);
                }

            //
            // Else if current level is not invalid, last time through we had a
            // match and we need to increment the offset (wildcard patterns only).
            //

            } else {

                if (Wildcard) {
                    EnumPtr->LastPos[Pos] = GetNextOffset (EnumPtr->LastPos[Pos]);

                    // If there are no more items, go back a level
                    if (EnumPtr->LastPos[Pos] == INVALID_OFFSET) {
                        EnumPtr->PosCount--;
                        continue;
                    }
                }
            }

            //
            // If we are here, it is because we are looking at a level, trying
            // to find a pattern match.  Loop until either a match is found,
            // or we run out of items.
            //
            // The only exception is when the last match hit the depth ceiling
            // and PartStr does not have a wildcard.  In this case, we must
            // reset the last pos and go back one level.
            //

            if (Wildcard) {
                do  {
                    // Get current key, advance, then check current key against pattern
                    KeyStruct = GetKeyStruct (EnumPtr->LastPos[Pos]);
                    if (IsPatternMatch (PartStr, GetKeyToken (KeyStruct->KeyToken)))
                        break;

                    EnumPtr->LastPos[Pos] = GetNextOffset (EnumPtr->LastPos[Pos]);
                } while (EnumPtr->LastPos[Pos] != INVALID_OFFSET);

                // Match found so break out of last nested loop
                if (EnumPtr->LastPos[Pos] != INVALID_OFFSET)
                    break;
            } else {
                EnumPtr->LastPos[Pos] = INVALID_OFFSET;
            }

            //
            // We ran out of items before finding a match, so it is time to
            // go back up a level.
            //

            EnumPtr->PosCount--;
        } while (EnumPtr->PosCount);

        // Return if no items found
        if (!EnumPtr->PosCount) {
            LeaveCriticalSection (&g_MemDbCs);
            return FALSE;
        }

        //
        // A match was found.  Build output string and prepare position for
        // next level.
        //

        // Build the name of the item and get the value
        EnumPtr->szName[0] = 0;
        for (Level = EnumPtr->Start ; Level < EnumPtr->PosCount ; Level++) {
            PWSTR namePointer = EnumPtr->szName;
            KeyStruct = GetKeyStruct (EnumPtr->LastPos[Level]);
            if (Level > EnumPtr  -> Start) {
                namePointer = _wcsappend(namePointer,L"\\");
            }
            _wcsappend (namePointer, GetKeyToken (KeyStruct->KeyToken));
        }

        MYASSERT (KeyStruct);
        EnumPtr->bEndpoint = (KeyStruct->Flags & KSF_ENDPOINT) != 0;
        EnumPtr->bBinary   = (KeyStruct->Flags & KSF_BINARY) != 0;
        EnumPtr->bProxy = (KeyStruct->Flags & KSF_PROXY_NODE) != 0;
        EnumPtr->UserFlags = (KeyStruct->Flags & KSF_USERFLAG_MASK);
        EnumPtr->BinaryPtr = GetKeyStructBinaryData (KeyStruct);
        EnumPtr->BinarySize = GetKeyStructBinarySize (KeyStruct);
        if (EnumPtr->bBinary) {
            EnumPtr->dwValue = 0;
        } else {
            EnumPtr->dwValue   = KeyStruct->dwValue;
        }

        EnumPtr->Offset = EnumPtr->LastPos[Pos] | (g_SelectedDatabase << RESERVED_BITS);

        // Prepare position for next level
        if ((EnumPtr->PosCount + 1) <= (EnumPtr->Depth + EnumPtr->Start)) {
            EnumPtr->LastPos[Pos + 1] = INVALID_OFFSET;
            EnumPtr->PosCount++;
        }

        switch (EnumPtr->Flags) {

        case MEMDB_ALL_MATCHES:
            MatchNotFound = FALSE;
            break;

        case MEMDB_ENDPOINTS_ONLY:
            MatchNotFound = (KeyStruct->Flags & (KSF_ENDPOINT|KSF_PROXY_NODE)) != KSF_ENDPOINT;
            break;

        case MEMDB_BINARY_NODES_ONLY:
            MatchNotFound = (KeyStruct->Flags & KSF_BINARY) == 0;
            break;

        case MEMDB_PROXY_NODES_ONLY:
            MatchNotFound = (KeyStruct->Flags & KSF_PROXY_NODE) == 0;
            break;

        case MEMDB_ALL_BUT_PROXY:
            MatchNotFound = (KeyStruct->Flags & KSF_PROXY_NODE) != 0;
            break;
        }

    // Loop until flag match is found
    } while (MatchNotFound);

    LeaveCriticalSection (&g_MemDbCs);
    return TRUE;
}


//
// Save and restore functions
//

BOOL
pPrivateMemDbSave (
    PCWSTR FileName,
    BOOL bUnicode
    )
{
    HANDLE FileHandle;
    BOOL b = FALSE;
    DWORD BytesWritten;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        SelectDatabase(0);

        if (bUnicode) {
            FileHandle = CreateFileW (FileName, GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        } else {
            FileHandle = CreateFileA ((PCSTR) FileName, GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        }

        if (FileHandle == INVALID_HANDLE_VALUE) {
            if (bUnicode) {
                DEBUGMSGW ((DBG_ERROR, "Can't open %s", FileName));
            } else {
                DEBUGMSGA ((DBG_ERROR, "Can't open %s", FileName));
            }
            __leave;
        }

        // entire file written in UNICODE char set
        b = WriteFile (FileHandle, FILE_SIGNATURE, sizeof(FILE_SIGNATURE), &BytesWritten, NULL);

        if (b) {
            b = WriteFile (FileHandle, g_db, sizeof (DATABASE), &BytesWritten, NULL);
        }

        if (b) {
            b = WriteFile (FileHandle, g_db->Buf, g_db->AllocSize, &BytesWritten, NULL);
            if (BytesWritten != g_db->AllocSize)
                b = FALSE;
        }

        if (b) {
            b = SaveHashBlock (FileHandle);
        }

        if (b) {
            b = SaveBinaryBlocks (FileHandle);
        }

        PushError();
        CloseHandle (FileHandle);
        PopError();

        if (!b) {
            if (bUnicode) {
                DEBUGMSGW ((DBG_ERROR, "Error writing %s", FileName));
                DeleteFileW (FileName);
            } else {
                DEBUGMSGA ((DBG_ERROR, "Error writing %s", FileName));
                DeleteFileA ((PCSTR) FileName);
            }
            __leave;
        }

        MYASSERT (b == TRUE);
    }
    __finally {
        PushError();
        LeaveCriticalSection (&g_MemDbCs);
        PopError();
    }

    return b;
}

BOOL
MemDbSaveA (
    PCSTR FileName
    )
{
    return pPrivateMemDbSave ((PCWSTR) FileName, FALSE);        // FALSE=ANSI
}


BOOL
MemDbSaveW (
    PCWSTR FileName
    )
{
    return pPrivateMemDbSave (FileName, TRUE);                   // TRUE=UNICODE
}


BOOL
pPrivateMemDbLoad (
    IN      PCWSTR FileName,
    IN      BOOL bUnicode,
    OUT     PMEMDB_VERSION Version,                 OPTIONAL
    IN      BOOL QueryVersionOnly
    )
{
    HANDLE FileHandle;
    BOOL b;
    DWORD BytesRead;
    WCHAR Buf[sizeof(FILE_SIGNATURE)];
    PBYTE TempBuf = NULL;
    PCWSTR VerPtr;

    EnterCriticalSection (&g_MemDbCs);

    if (Version) {
        ZeroMemory (Version, sizeof (MEMDB_VERSION));
    }

    //
    // Blow away existing resources
    //

    if (!QueryVersionOnly) {
        pFreeAllDatabases();
    }

    //
    // Load in file
    //

    if (*FileName && FileName) {
        if (bUnicode) {
            FileHandle = CreateFileW (FileName, GENERIC_READ, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        } else {
            FileHandle = CreateFileA ((PCSTR) FileName, GENERIC_READ, 0, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        }
    } else {
        FileHandle = INVALID_HANDLE_VALUE;
    }

    b = (FileHandle != INVALID_HANDLE_VALUE);

    __try {
        //
        // Obtain the file signature
        //
        // NOTE: Entire file read is in UNICODE char set
        //

        if (b) {
            b = ReadFile (FileHandle, Buf, sizeof(FILE_SIGNATURE), &BytesRead, NULL);

            if (Version) {
                if (StringMatchByteCountW (
                        VERSION_BASE_SIGNATURE,
                        Buf,
                        sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR)
                        )) {

                    Version->Valid = TRUE;

                    //
                    // Identify version number
                    //

                    VerPtr = (PCWSTR) ((PBYTE) Buf + sizeof (VERSION_BASE_SIGNATURE) - sizeof (WCHAR));

                    if (StringMatchByteCountW (
                            MEMDB_VERSION,
                            VerPtr,
                            sizeof (MEMDB_VERSION) - sizeof (WCHAR)
                            )) {
                        Version->CurrentVersion = TRUE;
                    }

                    Version->Version = (UINT) _wtoi (VerPtr + 1);

                    //
                    // Identify checked or free build
                    //

                    VerPtr += (sizeof (MEMDB_VERSION) / sizeof (WCHAR)) - 1;

                    if (StringMatchByteCountW (
                            MEMDB_DEBUG_SIGNATURE,
                            VerPtr,
                            sizeof (MEMDB_DEBUG_SIGNATURE) - sizeof (WCHAR)
                            )) {

                        Version->Debug = TRUE;

                    } else if (!StringMatchByteCountW (
                                    VerPtr,
                                    MEMDB_NODBG_SIGNATURE,
                                    sizeof (MEMDB_NODBG_SIGNATURE) - sizeof (WCHAR)
                                    )) {
                        Version->Valid = FALSE;
                    }
                }
            }
        }

        if (QueryVersionOnly) {
            b = FALSE;
        }

        if (b) {
            b = StringMatchW (Buf, FILE_SIGNATURE);

    #ifdef DEBUG
            //
            // This code allows a debug build of memdb to work with both
            // debug and retail versions of the DAT file
            //

            if (!b) {
                if (StringMatchW (Buf, DEBUG_FILE_SIGNATURE)) {
                    g_UseDebugStructs = TRUE;
                    b = TRUE;
                } else if (StringMatchW (Buf, RETAIL_FILE_SIGNATURE)) {
                    DEBUGMSG ((DBG_ERROR, "memdb dat file is from free build; checked version expected"));
                    g_UseDebugStructs = FALSE;
                    b = TRUE;
                }
            }
    #else
            if (!b) {
                SetLastError (ERROR_BAD_FORMAT);
                LOG ((LOG_WARNING, "Warning: data file could be from checked build; free version expected"));
            }
    #endif
        }

        //
        // Obtain the database struct
        //

        if (b) {
            b = ReadFile (FileHandle, (PBYTE) g_db, sizeof (DATABASE), &BytesRead, NULL);
            if (BytesRead != sizeof (DATABASE)) {
                b = FALSE;
                SetLastError (ERROR_BAD_FORMAT);
            }
        }

        //
        // Allocate the memory block
        //

        if (b) {
            TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_db->AllocSize);
            if (TempBuf) {
                g_db->Buf = TempBuf;
                TempBuf = NULL;
            } else {
                b = FALSE;
            }
        }

        //
        // Read the memory block
        //

        if (b) {
            b = ReadFile (FileHandle, g_db->Buf, g_db->AllocSize, &BytesRead, NULL);
            if (BytesRead != g_db->AllocSize) {
                b = FALSE;
                SetLastError (ERROR_BAD_FORMAT);
            }
        }

        //
        // Read the hash table
        //

        if (b) {
            b = LoadHashBlock (FileHandle);
        }

        //
        // Read binary blocks
        //

        if (b) {
            b = LoadBinaryBlocks (FileHandle);
        }
    }

    __except (TRUE) {
        b = FALSE;
        PushError();
        LOG ((LOG_ERROR, "MemDb dat file %s could not be loaded because of an exception", FileName));

        FreeAllBinaryBlocks();
        PopError();
    }

    PushError();
    if (FileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle (FileHandle);
    }

    if (!b && !QueryVersionOnly) {
        pFreeAllDatabases();
        pInitializeMemDb();
    }

    LeaveCriticalSection (&g_MemDbCs);
    PopError();

    if (QueryVersionOnly) {
        return TRUE;
    }

    return b;
}


BOOL
MemDbLoadA (
    IN PCSTR FileName
    )
{
    return pPrivateMemDbLoad ((PCWSTR) FileName, FALSE, NULL, FALSE);
}

BOOL
MemDbLoadW (
    IN PCWSTR FileName
    )
{
    return pPrivateMemDbLoad (FileName, TRUE, NULL, FALSE);
}


BOOL
MemDbValidateDatabase (
    VOID
    )
{
    MEMDB_ENUMW e;

    if (MemDbEnumFirstValueW (&e, L"*", 0, MEMDB_ENDPOINTS_ONLY)) {

        do {
            if (!pPrivateMemDbGetValueW (e.szName, NULL, NULL)) {
                return FALSE;
            }
        } while (MemDbEnumNextValueW (&e));
    }

    return TRUE;
}



BOOL
MemDbCreateTemporaryKeyA (
    IN      PCSTR KeyName
    )
{
    PCWSTR KeyNameW;
    BOOL b = FALSE;

    KeyNameW = ConvertAtoW (KeyName);

    if (KeyNameW) {
        b = MemDbCreateTemporaryKeyW (KeyNameW);
        FreeConvertedStr (KeyNameW);
    }

    return b;
}


BOOL
MemDbCreateTemporaryKeyW (
    IN      PCWSTR KeyName
    )
{
    UINT Count;
    UINT Index;
    PDATABASE Database;
    DWORD KeyOffset;
    PCWSTR SubKey;
    BOOL b = FALSE;

    EnterCriticalSection (&g_MemDbCs);

    __try {

        if (wcslen (KeyName) >= MAX_HIVE_NAME) {
            SetLastError (ERROR_INVALID_PARAMETER);
            __leave;
        }

        SubKey = SelectHive (KeyName);

        KeyOffset = FindKey (SubKey);
        if (KeyOffset != INVALID_OFFSET) {
            SetLastError (ERROR_ALREADY_EXISTS);
            __leave;
        }

        Count = GrowListGetSize (&g_DatabaseList);
        for (Index = 1 ; Index < Count ; Index++) {
            Database = (PDATABASE) GrowListGetItem (&g_DatabaseList, Index);

            if (Database && StringIMatchW (Database->Hive, KeyName)) {
                SetLastError (ERROR_ALREADY_EXISTS);
                __leave;
            }
        }

        b = pCreateDatabase (KeyName);
    }
    __finally {
        LeaveCriticalSection (&g_MemDbCs);
    }

    return b;
}


/*++

Routine Description:

  MemDbMakeNonPrintableKey converts the double-backslashe pairs in a string
  to ASCII 1, a non-printable character.  This allows the caller to store
  properly escaped strings in MemDb.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakeNonPrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == '\\' &&
                _mbsnextc (_mbsinc (KeyName)) == '\\'
                ) {
                _setmbchar (KeyName, 1);
                KeyName = _mbsinc (KeyName);
                MYASSERT (_mbsnextc (KeyName) == '\\');
                _setmbchar (KeyName, 1);
            }

            DEBUGMSG_IF ((
                _mbsnextc (KeyName) == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == '*') {
                _setmbchar (KeyName, 2);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == '?') {
                _setmbchar (KeyName, 3);
            }

            DEBUGMSG_IF ((
                _mbsnextc (_mbsinc (KeyName)) == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyA: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakeNonPrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == L'\\' && KeyName[1] == L'\\') {
                KeyName[0] = 1;
                KeyName[1] = 1;
                KeyName++;
            }

            DEBUGMSG_IF ((
                KeyName[0] == 1,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 2;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 2,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == L'*') {
                KeyName[0] = 3;
            }

            DEBUGMSG_IF ((
                KeyName[1] == 3,
                DBG_WHOOPS,
                "MemDbMakeNonPrintableKeyW: Non-printable character "
                    "collision detected; key was damaged"
                ));
        }
        KeyName++;
    }
}


/*++

Routine Description:

  MemDbMakePrintableKey converts the ASCII 1 characters to backslashes,
  restoring the string converted by MemDbMakeNonPrintableKey.

  This routine is desinged to be expanded for other types of escape
  processing.

Arguments:

  KeyName - Specifies the key text; receives the converted text.  The DBCS
            version may grow the text buffer, so the text buffer must be twice
            the length of the inbound string.

  Flags - Specifies the type of conversion.  Currently only
          MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1 is supported.

Return Value:

  none

--*/

VOID
MemDbMakePrintableKeyA (
    IN OUT  PSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (_mbsnextc (KeyName) == 1) {
                _setmbchar (KeyName, '\\');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (_mbsnextc (KeyName) == 2) {
                _setmbchar (KeyName, '*');
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (_mbsnextc (KeyName) == 3) {
                _setmbchar (KeyName, '?');
            }
        }
        KeyName = _mbsinc (KeyName);
    }
}


VOID
MemDbMakePrintableKeyW (
    IN OUT  PWSTR KeyName,
    IN      DWORD Flags
    )
{
    while (*KeyName) {
        if (Flags & MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1) {
            if (KeyName[0] == 1) {
                KeyName[0] = L'\\';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_STAR_TO_ASCII_2) {
            if (KeyName[0] == 2) {
                KeyName[0] = L'*';
            }
        }
        if (Flags & MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3) {
            if (KeyName[0] == 3) {
                KeyName[0] = L'?';
            }
        }
        KeyName++;
    }
}


VOID
GetFixedUserNameA (
    IN OUT  PSTR SrcUserBuf
    )

/*++

Routine Description:

  GetFixedUserName looks in memdb for the user specified in SrcUserBuf,
  and if found, returns the changed name.

Arguments:

  SrcUserBuf - Specifies the user to look up as returned from the Win9x
               registry.  Receives the user name to create on NT.

Return Value:

  None.

--*/

{
    CHAR EncodedName[MEMDB_MAX];
    CHAR FixedName[MEMDB_MAX];

    StackStringCopyA (EncodedName, SrcUserBuf);
    MemDbMakeNonPrintableKeyA (
        EncodedName,
        MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1|
            MEMDB_CONVERT_WILD_STAR_TO_ASCII_2|
            MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3
        );

    if (MemDbGetEndpointValueExA (
            MEMDB_CATEGORY_FIXEDUSERNAMESA,
            EncodedName,
            NULL,
            FixedName
            )) {
        StringCopyA (SrcUserBuf, FixedName);
    }
}


VOID
GetFixedUserNameW (
    IN OUT  PWSTR SrcUserBuf
    )

/*++

Routine Description:

  GetFixedUserName looks in memdb for the user specified in SrcUserBuf,
  and if found, returns the changed name.

Arguments:

  SrcUserBuf - Specifies the user to look up as returned from the Win9x
               registry.  Receives the user name to create on NT.

Return Value:

  None.

--*/

{
    WCHAR EncodedName[MEMDB_MAX];
    WCHAR FixedName[MEMDB_MAX];

    StackStringCopyW (EncodedName, SrcUserBuf);
    MemDbMakeNonPrintableKeyW (
        EncodedName,
        MEMDB_CONVERT_DOUBLEWACKS_TO_ASCII_1|
            MEMDB_CONVERT_WILD_STAR_TO_ASCII_2|
            MEMDB_CONVERT_WILD_QMARK_TO_ASCII_3
        );

    if (MemDbGetEndpointValueExW (
            MEMDB_CATEGORY_FIXEDUSERNAMESW,
            EncodedName,
            NULL,
            FixedName
            )) {
        StringCopyW (SrcUserBuf, FixedName);
    }
}

/*
    The format of the binary file for MemDb export

    DWORD Signature

    DWORD Version

    DWORD GlobalFlags// 0x00000001 mask for Ansi format
                     // 0x00000002 mask for Temporary key

    BYTE Root[];     // The root of the tree (zero terminated).

    struct _KEY {

        WORD Flags;  // 0xF000 mask for accessing the entry flags
                     //     - 0x1000 - Mask for Key name (0 - root relative, 1 - previous key relative)
                     //     - 0x2000 - Mask for existing data (0 - no data, 1 - some data)
                     //     - 0x4000 - Mast for data type (0 - DWORD, 1 - binary data)
                     //     - 0x8000 - Mast for key flags (0 - nonexistent, 1 - existent)
                     // 0x0FFF mask for accessing size of the entry (except the data)

        BYTE Key[];  // Should be PCSTR or PCWSTR (not zero terminated)

        DWORD KeyFlags; //optional (dependant on Flags).

        BYTE Data[]; // optional (dependant on Flags).
                     // if BLOB first DWORD is the size of the BLOB
                     // if DWORD then has exactly 4 bytes
    }
    ...
*/

#define MEMDB_EXPORT_SIGNATURE              0x42444D4D
#define MEMDB_EXPORT_VERSION                0x00000001
#define MEMDB_EXPORT_FLAGS_ANSI             0x00000001
#define MEMDB_EXPORT_FLAGS_TEMP_KEY         0x00000002
#define MEMDB_EXPORT_FLAGS_PREV_RELATIVE    0x1000
#define MEMDB_EXPORT_FLAGS_DATA_PRESENT     0x2000
#define MEMDB_EXPORT_FLAGS_BINARY_DATA      0x4000
#define MEMDB_EXPORT_FLAGS_FLAGS_PRESENT    0x8000
#define MEMDB_EXPORT_FLAGS_SIZE_MASK        0x0FFF

BOOL
pMemDbExportWorkerA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCWSTR uRootTree;
    PCSTR lastWackPtr;
    DWORD globalFlags;
    WORD localFlags;
    CHAR key[MEMDB_MAX];
    DWORD keySize;
    DWORD copySize;
    MEMDB_ENUMA e;
    WORD blobSize;
    DWORD written;

    fileHandle = CreateFileA (FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    globalFlags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_VERSION;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_FLAGS_ANSI;

    // get the information if this key is a temporary key and set the flags if true
    uRootTree = ConvertAtoW (RootTree);
    if (IsTemporaryKey (uRootTree)) {
        globalFlags |= MEMDB_EXPORT_FLAGS_TEMP_KEY;
    }
    FreeConvertedStr (uRootTree);

    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // now write the root tree
    WriteFile (fileHandle, RootTree, SizeOfStringA (RootTree), &written, NULL);

    MemDbBuildKeyA (key, RootTree, "*", NULL, NULL);

    if (MemDbEnumFirstValueA (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        key [0] = 0;
        keySize = 0;
        do {
            // initialize the flags
            localFlags = 0;
            if (e.bBinary) {
                localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                localFlags |= MEMDB_EXPORT_FLAGS_BINARY_DATA;
            } else {
                if (e.dwValue) {
                    localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                }
            }
            if (e.UserFlags) {
                localFlags |= MEMDB_EXPORT_FLAGS_FLAGS_PRESENT;
            }

            // let's compute the size for this blob
            blobSize = sizeof (WORD); // Flags

            if (keySize &&
                StringIMatchByteCountA (key, e.szName, keySize - sizeof (CHAR)) &&
                (e.szName [keySize - 1] == '\\')
                ) {
                localFlags |= MEMDB_EXPORT_FLAGS_PREV_RELATIVE;
                copySize = SizeOfStringA (e.szName) - keySize - sizeof (CHAR);
            } else {
                copySize = SizeOfStringA (e.szName) - sizeof (CHAR);
                keySize = 0;
            }
            MYASSERT (copySize < 4096);
            blobSize += (WORD) copySize;

            localFlags |= blobSize;

            // write the flags
            WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

            // write the key
            WriteFile (fileHandle, ((PBYTE) e.szName) + keySize, copySize, &written, NULL);

            // write the key flags if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {
                WriteFile (fileHandle, &e.UserFlags, sizeof (DWORD), &written, NULL);
            }

            // write the data if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
                if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                    WriteFile (fileHandle, &e.BinarySize, sizeof (DWORD), &written, NULL);
                    WriteFile (fileHandle, e.BinaryPtr, e.BinarySize, &written, NULL);
                } else {
                    WriteFile (fileHandle, &e.dwValue, sizeof (DWORD), &written, NULL);
                }
            }
            lastWackPtr = _mbsrchr (e.szName, '\\');
            if (lastWackPtr) {
                keySize = ByteCountABA (e.szName, lastWackPtr) + sizeof (CHAR);
                StringCopyByteCountA (key, e.szName, keySize);
            } else {
                keySize = 0;
            }

        } while (MemDbEnumNextValueA (&e));
    }

    localFlags = 0;

    // finally write the zero terminator
    WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
pMemDbExportWorkerW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName
    )
{
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCWSTR lastWackPtr;
    DWORD globalFlags;
    WORD localFlags;
    WCHAR key[MEMDB_MAX];
    DWORD keySize;
    DWORD copySize;
    MEMDB_ENUMW e;
    WORD blobSize;
    DWORD written;

    fileHandle = CreateFileW (FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    globalFlags = MEMDB_EXPORT_SIGNATURE;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    globalFlags = MEMDB_EXPORT_VERSION;
    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // get the information if this key is a temporary key and set the flags if true
    if (IsTemporaryKey (RootTree)) {
        globalFlags |= MEMDB_EXPORT_FLAGS_TEMP_KEY;
    }

    WriteFile (fileHandle, &globalFlags, sizeof (DWORD), &written, NULL);

    // now write the root tree
    WriteFile (fileHandle, RootTree, SizeOfStringW (RootTree), &written, NULL);

    MemDbBuildKeyW (key, RootTree, L"*", NULL, NULL);

    if (MemDbEnumFirstValueW (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        key [0] = 0;
        keySize = 0;
        do {
            // initialize the flags
            localFlags = 0;
            if (e.bBinary) {
                localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                localFlags |= MEMDB_EXPORT_FLAGS_BINARY_DATA;
            } else {
                if (e.dwValue) {
                    localFlags |= MEMDB_EXPORT_FLAGS_DATA_PRESENT;
                }
            }
            if (e.UserFlags) {
                localFlags |= MEMDB_EXPORT_FLAGS_FLAGS_PRESENT;
            }

            // let's compute the size for this blob
            blobSize = sizeof (WORD); // Flags

            if (keySize &&
                StringIMatchByteCountW (key, e.szName, keySize - sizeof (WCHAR)) &&
                (e.szName [keySize - 1] == L'\\')
                ) {
                localFlags |= MEMDB_EXPORT_FLAGS_PREV_RELATIVE;
                copySize = SizeOfStringW (e.szName) - keySize - sizeof (WCHAR);
            } else {
                copySize = SizeOfStringW (e.szName) - sizeof (WCHAR);
                keySize = 0;
            }
            MYASSERT (copySize < 4096);
            blobSize += (WORD) copySize;

            localFlags |= blobSize;

            // write the flags
            WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

            // write the key
            WriteFile (fileHandle, ((PBYTE) e.szName) + keySize, copySize, &written, NULL);

            // write the key flags if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {
                WriteFile (fileHandle, &e.UserFlags, sizeof (DWORD), &written, NULL);
            }

            // write the data if appropriate
            if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
                if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                    WriteFile (fileHandle, &e.BinarySize, sizeof (DWORD), &written, NULL);
                    WriteFile (fileHandle, e.BinaryPtr, e.BinarySize, &written, NULL);
                } else {
                    WriteFile (fileHandle, &e.dwValue, sizeof (DWORD), &written, NULL);
                }
            }
            lastWackPtr = wcsrchr (e.szName, L'\\');
            if (lastWackPtr) {
                keySize = ByteCountABW (e.szName, lastWackPtr) + sizeof (WCHAR);
                StringCopyByteCountW (key, e.szName, keySize);
            } else {
                keySize = 0;
            }

        } while (MemDbEnumNextValueW (&e));
    }

    localFlags = 0;

    // finally write the zero terminator
    WriteFile (fileHandle, &localFlags, sizeof (WORD), &written, NULL);

    CloseHandle (fileHandle);

    return TRUE;
}

BOOL
MemDbExportA (
    IN      PCSTR RootTree,
    IN      PCSTR FileName,
    IN      BOOL AnsiFormat
    )

/*++

Routine Description:

  MemDbExportA exports a tree in a private binary format. The format is described above.

Arguments:

  RootTree - Specifies the tree to be exported
  FileName - Name of the binary format file to export to.
  AnsiFormat - Keys should be written in ANSI rather than in Unicode.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PCWSTR uRootTree, uFileName;
    BOOL result = TRUE;

    if (AnsiFormat) {
        result = pMemDbExportWorkerA (RootTree, FileName);
    } else {
        uRootTree = ConvertAtoW (RootTree);
        uFileName = ConvertAtoW (FileName);
        result = pMemDbExportWorkerW (uRootTree, uFileName);
        FreeConvertedStr (uFileName);
        FreeConvertedStr (uRootTree);
    }
    return result;
}

BOOL
MemDbExportW (
    IN      PCWSTR RootTree,
    IN      PCWSTR FileName,
    IN      BOOL AnsiFormat
    )

/*++

Routine Description:

  MemDbExportW exports a tree in a private binary format. The format is described above.

Arguments:

  RootTree - Specifies the tree to be exported
  FileName - Name of the binary format file to export to.
  AnsiFormat - Keys should be written in ANSI rather than in Unicode.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PCSTR aRootTree, aFileName;
    BOOL result = TRUE;

    if (!AnsiFormat) {
        result = pMemDbExportWorkerW (RootTree, FileName);
    } else {
        aRootTree = ConvertWtoA (RootTree);
        aFileName = ConvertWtoA (FileName);
        result = pMemDbExportWorkerA (aRootTree, aFileName);
        FreeConvertedStr (aFileName);
        FreeConvertedStr (aRootTree);
    }
    return result;
}

BOOL
pMemDbImportWorkerA (
    IN      PBYTE FileBuffer
    )
{
    DWORD globalFlags;
    WORD localFlags;
    PCSTR rootTree;
    CHAR lastKey [MEMDB_MAX];
    PSTR lastKeyPtr;
    CHAR node [MEMDB_MAX];
    CHAR localKey [MEMDB_MAX];
    DWORD flags = 0;

    globalFlags = *((PDWORD) FileBuffer);

    // FileBuffer will point to the tree that's imported
    FileBuffer += sizeof (DWORD);
    rootTree = (PCSTR) FileBuffer;

    if (globalFlags & MEMDB_EXPORT_FLAGS_TEMP_KEY) {
        // a temporary key was exported
        MemDbCreateTemporaryKeyA ((PCSTR) FileBuffer);
    }

    // let's pass the string
    FileBuffer = GetEndOfStringA ((PCSTR) FileBuffer) + sizeof (CHAR);

    // ok from this point on we read and add all keys
    lastKey [0] = 0;
    localFlags = *((PWORD) FileBuffer);

    while (localFlags) {

        localKey [0] = 0;

        StringCopyByteCountA (localKey, (PSTR)(FileBuffer + sizeof (WORD)), (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK) - sizeof (WORD) + sizeof (CHAR));

        MemDbBuildKeyA (node, rootTree, (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE)?lastKey:NULL, localKey, NULL);

        FileBuffer += (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK);

        MYASSERT (!((localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) && (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT)));

        if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {

            flags = *(PDWORD)FileBuffer;
            FileBuffer += sizeof (DWORD);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
            if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                MemDbSetBinaryValueA (node, FileBuffer + sizeof (DWORD), *(PDWORD)FileBuffer);
                FileBuffer += (*(PDWORD)FileBuffer + sizeof (DWORD));
            } else {
                MemDbSetValueAndFlagsA (node, *(PDWORD)FileBuffer, flags, 0);
                FileBuffer += sizeof (DWORD);
            }
        } else {
            MemDbSetValueA (node, 0);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE) {

            StringCatA (lastKey, "\\");
            StringCatA (lastKey, localKey);
            lastKeyPtr = _mbsrchr (lastKey, '\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        } else {

            StringCopyA (lastKey, localKey);
            lastKeyPtr = _mbsrchr (lastKey, '\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        }
        localFlags = *((PWORD) FileBuffer);
    }

    return TRUE;
}

BOOL
pMemDbImportWorkerW (
    IN      PBYTE FileBuffer
    )
{
    DWORD globalFlags;
    WORD localFlags;
    PCWSTR rootTree;
    WCHAR lastKey [MEMDB_MAX];
    PWSTR lastKeyPtr;
    WCHAR node [MEMDB_MAX];
    WCHAR localKey [MEMDB_MAX];
    DWORD flags = 0;

    globalFlags = *((PDWORD) FileBuffer);

    // FileBuffer will point to the tree that's imported
    FileBuffer += sizeof (DWORD);
    rootTree = (PCWSTR) FileBuffer;

    if (globalFlags & MEMDB_EXPORT_FLAGS_TEMP_KEY) {
        // a temporary key was exported
        MemDbCreateTemporaryKeyW ((PCWSTR) FileBuffer);
    }

    // let's pass the string
    FileBuffer = (PBYTE)GetEndOfStringW ((PCWSTR) FileBuffer) + sizeof (WCHAR);

    // ok from this point on we read and add all keys
    lastKey [0] = 0;
    localFlags = *((PWORD) FileBuffer);

    while (localFlags) {

        localKey [0] = 0;

        StringCopyByteCountW (localKey, (PWSTR)(FileBuffer + sizeof (WORD)), (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK) - sizeof (WORD) + sizeof (WCHAR));

        MemDbBuildKeyW (node, rootTree, (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE)?lastKey:NULL, localKey, NULL);

        FileBuffer += (localFlags & MEMDB_EXPORT_FLAGS_SIZE_MASK);

        MYASSERT (!((localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) && (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT)));

        if (localFlags & MEMDB_EXPORT_FLAGS_FLAGS_PRESENT) {

            flags = *(PDWORD)FileBuffer;
            FileBuffer += sizeof (DWORD);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_DATA_PRESENT) {
            if (localFlags & MEMDB_EXPORT_FLAGS_BINARY_DATA) {
                MemDbSetBinaryValueW (node, FileBuffer + sizeof (DWORD), *(PDWORD)FileBuffer);
                FileBuffer += (*(PDWORD)FileBuffer + sizeof (DWORD));
            } else {
                MemDbSetValueAndFlagsW (node, *(PDWORD)FileBuffer, flags, 0);
                FileBuffer += sizeof (DWORD);
            }
        } else {
            MemDbSetValueW (node, 0);
        }

        if (localFlags & MEMDB_EXPORT_FLAGS_PREV_RELATIVE) {

            StringCatW (lastKey, L"\\");
            StringCatW (lastKey, localKey);
            lastKeyPtr = wcsrchr (lastKey, L'\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        } else {

            StringCopyW (lastKey, localKey);
            lastKeyPtr = wcsrchr (lastKey, L'\\');
            if (lastKeyPtr) {
                *lastKeyPtr = 0;
            } else {
                lastKey [0] = 0;
            }
        }
        localFlags = *((PWORD) FileBuffer);
    }

    return TRUE;
}

BOOL
MemDbImportA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  MemDbImportA imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PBYTE fileBuff;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL result = TRUE;

    fileBuff = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGA ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        if (*((PDWORD) fileBuff) != MEMDB_EXPORT_SIGNATURE) {
            DEBUGMSGA ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            result = FALSE;
        } else {

            fileBuff += sizeof (DWORD);

            if (*((PDWORD) fileBuff) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGA ((DBG_ERROR, "Unknown version for file to import: %s", FileName));
                result = FALSE;

            } else {

                fileBuff += sizeof (DWORD);

                if (*((PDWORD) fileBuff) & MEMDB_EXPORT_FLAGS_ANSI) {
                    result = pMemDbImportWorkerA (fileBuff);
                } else {
                    result = pMemDbImportWorkerW (fileBuff);
                }
            }
        }
    }
    __except (1) {
        DEBUGMSGA ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return result;
}

BOOL
MemDbImportW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  MemDbImportW imports a tree from a private binary format. The format is described above.

Arguments:

  FileName - Name of the binary format file to import from.

Return Value:

  TRUE is successfull, FALSE if not.

--*/

{
    PBYTE fileBuff;
    HANDLE fileHandle;
    HANDLE mapHandle;
    BOOL result;

    fileBuff = MapFileIntoMemoryW (FileName, &fileHandle, &mapHandle);
    if (fileBuff == NULL) {
        DEBUGMSGW ((DBG_ERROR, "Could not execute MemDbImport for %s", FileName));
        return FALSE;
    }

    __try {
        if (*((PDWORD) fileBuff) != MEMDB_EXPORT_SIGNATURE) {

            DEBUGMSGW ((DBG_ERROR, "Unknown signature for file to import: %s", FileName));
            result = FALSE;

        } else {

            fileBuff += sizeof (DWORD);

            if (*((PDWORD) fileBuff) != MEMDB_EXPORT_VERSION) {

                DEBUGMSGW ((DBG_ERROR, "Unknown version for file to import: %s", FileName));
                result = FALSE;

            } else {

                fileBuff += sizeof (DWORD);

                if (*((PDWORD) fileBuff) & MEMDB_EXPORT_FLAGS_ANSI) {
                    result = pMemDbImportWorkerA (fileBuff);
                } else {
                    result = pMemDbImportWorkerW (fileBuff);
                }
            }
        }
    }
    __except (1) {
        DEBUGMSGW ((DBG_ERROR, "Access violation while importing: %s", FileName));
    }

    UnmapFile (fileBuff, mapHandle, fileHandle);

    return result;
}


BOOL
MemDbQueryVersionA (
    PCSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad ((PCWSTR) FileName, FALSE, Version, TRUE);

    return Version->Valid;
}


BOOL
MemDbQueryVersionW (
    PCWSTR FileName,
    PMEMDB_VERSION Version
    )
{
    pPrivateMemDbLoad (FileName, TRUE, Version, TRUE);

    return Version->Valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\hash.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Hashing routines used to speed lookup of memdb keys.

Author:

    Jim Schmidt (jimschm) 8-Aug-1996

Revision History:

    Jim Schmidt (jimschm) 21-Oct-1997  Split from memdb.c

--*/

#include "pch.h"
#include "memdbp.h"

#ifndef UNICODE
#error UNICODE required
#endif

#define DBG_MEMDB       "MemDb"

//
// Globals
//

DWORD g_HashSize;
DWORD g_HashEnd;
DWORD g_HashFreeHead;
PBYTE g_HashBuf;


//
// #defines
//

// see memdbp.h for bit restrictions
#define INVALID_OFFSET_MASKED (INVALID_OFFSET & OFFSET_MASK)
#define ASSERT_OFFSET_ONLY(x) MYASSERT(((x) & RESERVED_MASK) == 0 || (x) == INVALID_OFFSET)
#define UNMASK_OFFSET(x) ((x)==INVALID_OFFSET_MASKED ? INVALID_OFFSET : (x))
#define MASK_OFFSET(x) ((x) & OFFSET_MASK)

#define MASK_4BIT       0x0000000f
#define INVALID_OFFSET_4BIT (INVALID_OFFSET & MASK_4BIT)
#define ASSERT_4BIT(x) MYASSERT(((x) & (~MASK_4BIT)) == 0 || (x) == INVALID_OFFSET)
#define CONVERT_4TO8(x) ((BYTE) ((x)==INVALID_OFFSET_4BIT ? INVALID_OFFSET : (x)))
#define CONVERT_8TO4(x) ((x) & MASK_4BIT)

#define HASH_BUCKETS    39989
#define HASH_BLOCK_SIZE (HASH_BUCKETS * sizeof (BUCKETSTRUCT))
#define HASHBUFPTR(offset) ((PBUCKETSTRUCT) (g_HashBuf + offset))

//
// Local privates
//

VOID
pResetHashBlock (
    VOID
    );


//
// Implementation
//

BOOL
InitializeHashBlock (
    VOID
    )
{
    g_HashSize = HASH_BLOCK_SIZE * 2;

    g_HashBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_HashSize);
    pResetHashBlock();

    return TRUE;
}


VOID
pResetHashBlock (
    VOID
    )
{
    PBUCKETSTRUCT BucketPtr;
    INT i;

    g_HashEnd = HASH_BLOCK_SIZE;
    g_HashFreeHead = INVALID_OFFSET;

    BucketPtr = (PBUCKETSTRUCT) g_HashBuf;
    for (i = 0 ; i < HASH_BUCKETS ; i++) {
        BucketPtr->Offset = INVALID_OFFSET;
        BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;
        BucketPtr->Info.Hive = 0;
        BucketPtr++;
    }
}


VOID
FreeHashBlock (
    VOID
    )
{
    if (g_HashBuf) {
        MemFree (g_hHeap, 0, g_HashBuf);
        g_HashBuf = NULL;
    }

    g_HashSize = 0;
    g_HashEnd = 0;
    g_HashFreeHead = INVALID_OFFSET;
}


BOOL
EnumFirstHashEntry (
    OUT     PHASHENUM EnumPtr
    )
{
    ZeroMemory (EnumPtr, sizeof (HASHENUM));

    return EnumNextHashEntry (EnumPtr);
}


BOOL
EnumNextHashEntry (
    IN OUT  PHASHENUM EnumPtr
    )
{
    for (;;) {
        if (EnumPtr->Bucket == HASH_BUCKETS) {
            //
            // The completion case
            //

            return FALSE;
        }

        if (!EnumPtr->BucketPtr) {
            //
            // This case occurs when we are begining to enumerate a bucket
            //

            EnumPtr->BucketPtr = (PBUCKETSTRUCT) g_HashBuf + EnumPtr->Bucket;
            if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Return this first item in the bucket
            //

            EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
            return TRUE;
        }

        //
        // This case occurs when we are continuing enumeration of a bucket
        //

        if (EnumPtr->BucketPtr->Offset == INVALID_OFFSET) {
            //
            // Current bucket item (and also the last bucket item) may have
            // been deleted -- check that now
            //

            if (!EnumPtr->PrevBucketPtr) {
                //
                // Last item has been deleted; continue to next bucket
                //

                EnumPtr->BucketPtr = NULL;
                EnumPtr->Bucket += 1;
                continue;
            }

            //
            // Previous bucket item is valid; use it.
            //

            EnumPtr->BucketPtr = EnumPtr->PrevBucketPtr;

        } else {
            //
            // Current bucket item may have been deleted, but another item was
            // moved to its place -- check that now
            //

            if (EnumPtr->BucketPtr->Offset != EnumPtr->LastOffset) {
                EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
                return TRUE;
            }
        }

        //
        // We now know that the current bucket item was not changed, so it
        // becomes our previous item and we move on to the next item (if
        // one exists)
        //

        if (UNMASK_OFFSET (EnumPtr->BucketPtr->Info.NextItem) == INVALID_OFFSET) {
            //
            // End of bucket reached
            //

            EnumPtr->BucketPtr = NULL;
            EnumPtr->Bucket += 1;
            continue;
        }

        EnumPtr->PrevBucketPtr = EnumPtr->BucketPtr;
        EnumPtr->BucketPtr = HASHBUFPTR (UNMASK_OFFSET (EnumPtr->BucketPtr->Info.NextItem));


        EnumPtr->LastOffset = EnumPtr->BucketPtr->Offset;
        MYASSERT(EnumPtr->LastOffset != INVALID_OFFSET);
        break;
    }

    return TRUE;
}


typedef struct {
    BYTE Hive;
    DWORD Offset;
} HASH_ITEM, *PHASH_ITEM;

BOOL
SaveHashBlock (
    HANDLE File
    )
{
    BOOL b;
    DWORD Written;
    PBYTE BackupBlock;
    UINT OrgEnd, OrgSize, OrgFreeHead;
    PBYTE OrgBlock;
    WCHAR TempStr[MEMDB_MAX];
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    HASHENUM e;
    PHASH_ITEM ItemPtr;
    UINT u;

    //
    // Back up the hash block
    //

    BackupBlock = MemAlloc (g_hHeap, 0, g_HashEnd);
    CopyMemory (BackupBlock, g_HashBuf, g_HashEnd);

    OrgEnd = g_HashEnd;
    OrgSize = g_HashSize;
    OrgFreeHead = g_HashFreeHead;
    OrgBlock = g_HashBuf;

    g_HashBuf = BackupBlock;

    //
    // Delete all hash entries that do not belong to the root database.
    // Do this by queueing the hash entry removal, so the EnumNextHashEntry
    // function will continue to work.
    //

    if (EnumFirstHashEntry (&e)) {
        do {

            if (e.BucketPtr->Info.Hive) {
                ItemPtr = (PHASH_ITEM) GrowBuffer (&GrowBuf, sizeof (HASH_ITEM));
                ItemPtr->Hive   = (BYTE) (e.BucketPtr->Info.Hive);
                ItemPtr->Offset = e.BucketPtr->Offset;
            }

        } while (EnumNextHashEntry (&e));
    }

    ItemPtr = (PHASH_ITEM) GrowBuf.Buf;

    for (u = 0 ; u < GrowBuf.End ; u += sizeof (HASH_ITEM), ItemPtr++) {

        SelectDatabase (ItemPtr->Hive);

        if (PrivateBuildKeyFromOffset (
                0,
                ItemPtr->Offset,
                TempStr,
                NULL,
                NULL,
                NULL
                )) {

            RemoveHashTableEntry (TempStr);
        }
    }


    //
    // Write the hash block end and deleted pointer
    //

    b = WriteFile (File, &g_HashEnd, sizeof (DWORD), &Written, NULL);

    if (b) {
        b = WriteFile (File, &g_HashFreeHead, sizeof (DWORD), &Written, NULL);
    }

    //
    // Write the hash block
    //

    if (b) {
        b = WriteFile (File, g_HashBuf, g_HashEnd, &Written, NULL);
        if (Written != g_HashEnd) {
            b = FALSE;
        }
    }

    //
    // Restore the hash block
    //

    PushError();

    g_HashEnd = OrgEnd;
    g_HashSize = OrgSize;
    g_HashFreeHead = OrgFreeHead;
    g_HashBuf = OrgBlock;

    SelectDatabase (0);

    MemFree (g_hHeap, 0, BackupBlock);

    PopError();

    return b;
}


BOOL
LoadHashBlock (
    HANDLE File
    )
{
    BOOL b;
    DWORD Read;
    PBYTE TempBuf = NULL;

    //
    // Read the hash block end and deleted pointer; allocate memory for block.
    //

    b = ReadFile (File, &g_HashEnd, sizeof (DWORD), &Read, NULL);

    if (b) {
        b = ReadFile (File, &g_HashFreeHead, sizeof (DWORD), &Read, NULL);
    }

    if (b) {
        g_HashSize = g_HashEnd;

        TempBuf = (PBYTE) MemAlloc (g_hHeap, 0, g_HashSize);
        if (TempBuf) {
            if (g_HashBuf) {
                MemFree (g_hHeap, 0, g_HashBuf);
            }

            g_HashBuf = TempBuf;
            TempBuf = NULL;
        } else {
            b = FALSE;
        }
    }

    //
    // Read the hash block
    //

    if (b) {
        b = ReadFile (File, g_HashBuf, g_HashSize, &Read, NULL);
        if (Read != g_HashSize) {
            b = FALSE;
            SetLastError (ERROR_BAD_FORMAT);
        }
    }

    return b;
}


DWORD
pCalculateHashVal (
    IN      PCWSTR String
    )
{
    DWORD Hash = 0;

    while (*String) {
        Hash = (Hash << 3) | (Hash >> 29);
        Hash += towlower (*String);
        String++;
    }

    Hash %= HASH_BUCKETS;

    return Hash;
}

DWORD
pAllocBucket (
    VOID
    )
{
    DWORD rBucketOffset;
    PBYTE TempBuf;
    PBUCKETSTRUCT BucketPtr;

    if (g_HashFreeHead != INVALID_OFFSET) {
        rBucketOffset = g_HashFreeHead;
        BucketPtr = HASHBUFPTR (rBucketOffset);
        g_HashFreeHead = UNMASK_OFFSET (BucketPtr->Info.NextItem);

        MYASSERT (rBucketOffset < g_HashEnd);
    } else {

        if (g_HashEnd + sizeof (BUCKETSTRUCT) > g_HashSize) {
            g_HashSize += HASH_BLOCK_SIZE;
            TempBuf = MemReAlloc (g_hHeap, 0, g_HashBuf, g_HashSize);
            DEBUGMSG ((DBG_NAUSEA, "Realloc'd memdb hash table"));

            if (!TempBuf) {
                DEBUGMSG ((DBG_ERROR, "Out of memory!"));
                g_HashSize -= HASH_BLOCK_SIZE;
                return INVALID_OFFSET;
            }

            g_HashBuf = TempBuf;
        }

        rBucketOffset = g_HashEnd;
        g_HashEnd += sizeof (BUCKETSTRUCT);

        BucketPtr = HASHBUFPTR (rBucketOffset);
    }

    BucketPtr->Offset = INVALID_OFFSET;
    BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;

    ASSERT_4BIT (g_SelectedDatabase);
    BucketPtr->Info.Hive = CONVERT_8TO4 (g_SelectedDatabase);

    return rBucketOffset;
}


BOOL
AddHashTableEntry (
    IN      PCWSTR FullString,
    IN      DWORD Offset
    )
{
    DWORD Bucket;
    PBUCKETSTRUCT BucketPtr, PrevBucketPtr;
    DWORD BucketOffset;
    DWORD NewOffset;
    DWORD PrevBucketOffset;

    Bucket = pCalculateHashVal (FullString);
    BucketPtr = (PBUCKETSTRUCT) g_HashBuf + Bucket;

    //
    // See if root bucket item has been used or not
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        //
        // Yes - add to end of the chain
        //

        BucketOffset = Bucket * sizeof (BUCKETSTRUCT);
        do {
            BucketPtr = HASHBUFPTR (BucketOffset);
            PrevBucketOffset = BucketOffset;
            BucketOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);
        } while (BucketOffset != INVALID_OFFSET);


        //
        // Add to the chain
        //

        NewOffset = pAllocBucket();
        PrevBucketPtr = HASHBUFPTR (PrevBucketOffset);
        ASSERT_OFFSET_ONLY (NewOffset);
        PrevBucketPtr->Info.NextItem = MASK_OFFSET (NewOffset);

        if (NewOffset == INVALID_OFFSET) {
            return FALSE;
        }

        BucketPtr = HASHBUFPTR (NewOffset);
        MYASSERT (BucketPtr->Info.NextItem == INVALID_OFFSET_MASKED);
    }

    BucketPtr->Offset = Offset;
    ASSERT_4BIT (g_SelectedDatabase);
    BucketPtr->Info.Hive = CONVERT_8TO4 (g_SelectedDatabase);

#ifdef DEBUG
    {
        DWORD HashOffset;

        HashOffset = FindStringInHashTable (FullString, NULL);
        MYASSERT (HashOffset != INVALID_OFFSET);
        DEBUGMSG_IF ((HashOffset != Offset, DBG_MEMDB, "Duplicate in hash table: %s", FullString));
    }
#endif

    return TRUE;
}


PBUCKETSTRUCT
pFindBucketItemInHashTable (
    IN      PCWSTR FullString,
    OUT     PBUCKETSTRUCT *PrevBucketPtr,       OPTIONAL
    OUT     DWORD *HashOffsetPtr                OPTIONAL
    )
{
    DWORD Bucket;
    DWORD BucketOffset;
    PBUCKETSTRUCT BucketPtr = NULL;
    WCHAR TempStr[MEMDB_MAX];

    Bucket = pCalculateHashVal (FullString);
    BucketOffset = Bucket * sizeof (BUCKETSTRUCT);

#ifdef MEMORY_TRACKING
    {
        //
        // Circular link check
        //

        DWORD Prev, Next;
        DWORD Turtle, Rabbit;
        BOOL Even = FALSE;

        Rabbit = BucketOffset;
        Turtle = Rabbit;
        while (Rabbit != INVALID_OFFSET) {
            // Make rabbit point to next item in chain
            Prev = Rabbit;
            BucketPtr = HASHBUFPTR (Rabbit);
            Rabbit = UNMASK_OFFSET (BucketPtr->Info.NextItem);

            // We should always be ahead of the turtle
            if (Rabbit == Turtle) {
                BucketPtr = HASHBUFPTR (Rabbit);
                Next = UNMASK_OFFSET (BucketPtr->Info.NextItem);
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "Circular link detected in memdb hash table!  Turtle=%u, Rabbit=%u, Next=%u, Prev=%u",
                    Turtle,
                    Rabbit,
                    Next,
                    Prev
                    ));

                return NULL;
            }

            // Make turtle point to next item in chain (1 of every 2 passes)
            if (Even) {
                BucketPtr = HASHBUFPTR (Turtle);
                Turtle = UNMASK_OFFSET (BucketPtr->Info.NextItem);
            }

            Even = !Even;
        }
    }
#endif

    BucketPtr = HASHBUFPTR (BucketOffset);

    if (PrevBucketPtr) {
        *PrevBucketPtr = BucketPtr;
    }

    //
    // If root bucket is not empty, scan bucket for FullString
    //

    if (BucketPtr->Offset != INVALID_OFFSET) {
        do  {

            BucketPtr = HASHBUFPTR (BucketOffset);
            ASSERT_4BIT (g_SelectedDatabase);

            if (BucketPtr->Info.Hive == g_SelectedDatabase) {
                //
                // Build string using offset
                //

                PrivateBuildKeyFromOffset (
                    0,
                    BucketPtr->Offset,
                    TempStr,
                    NULL,
                    NULL,
                    NULL
                    );

                //
                // Do compare and return if match is found
                //

                if (StringIMatchW (FullString, TempStr)) {
                    if (HashOffsetPtr) {
                        *HashOffsetPtr = BucketOffset;
                    }
                    return BucketPtr;
                }

            }

            if (PrevBucketPtr) {
                *PrevBucketPtr = BucketPtr;
            }

            BucketOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);

        } while (BucketOffset != INVALID_OFFSET);
    }

    return NULL;
}


DWORD
FindStringInHashTable (
    IN      PCWSTR FullString,
    OUT     PBYTE DatabaseId        OPTIONAL
    )
{
    PBUCKETSTRUCT BucketPtr;

    BucketPtr = pFindBucketItemInHashTable (FullString, NULL, NULL);
    if (BucketPtr) {
        if (DatabaseId) {
            *DatabaseId = (BYTE) (BucketPtr->Info.Hive);
        }

        return BucketPtr->Offset;
    }

    return INVALID_OFFSET;
}


BOOL
RemoveHashTableEntry (
    IN      PCWSTR FullString
    )
{
    PBUCKETSTRUCT BucketPtr;
    PBUCKETSTRUCT PrevBucketPtr;
    DWORD NextOffset;
    PBUCKETSTRUCT NextBucketPtr;
    DWORD BucketOffset;

    BucketPtr = pFindBucketItemInHashTable (FullString, &PrevBucketPtr, &BucketOffset);
    if (!BucketPtr) {
        return FALSE;
    }

    if (PrevBucketPtr != BucketPtr) {
        //
        // If not at the first level (prev != current), give the block
        // to free space.
        //

        PrevBucketPtr->Info.NextItem = BucketPtr->Info.NextItem;
        ASSERT_OFFSET_ONLY (g_HashFreeHead);
        BucketPtr->Info.NextItem = MASK_OFFSET (g_HashFreeHead);
        BucketPtr->Offset = INVALID_OFFSET;
        g_HashFreeHead = BucketOffset;

    } else {

        //
        // Invalidate next item pointer if at the first level
        //

        if (UNMASK_OFFSET (BucketPtr->Info.NextItem) != INVALID_OFFSET) {
            //
            // Copy next item to root array
            //

            NextOffset = UNMASK_OFFSET (BucketPtr->Info.NextItem);
            NextBucketPtr = HASHBUFPTR (NextOffset);
            CopyMemory (BucketPtr, NextBucketPtr, sizeof (BUCKETSTRUCT));

            //
            // Donate next item to free space
            //

            ASSERT_OFFSET_ONLY (g_HashFreeHead);
            NextBucketPtr->Info.NextItem = MASK_OFFSET (g_HashFreeHead);
            NextBucketPtr->Offset = INVALID_OFFSET;
            g_HashFreeHead = NextOffset;


        } else {
            //
            // Delete of last item in bucket -- invalidate the root array item
            //

            BucketPtr->Info.NextItem = INVALID_OFFSET_MASKED;
            BucketPtr->Offset = INVALID_OFFSET;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\memdbp.h ===
#include "migshared.h"

//
// #defines
//

//
// This is our version stamp.  Change MEMDB_VERSION only.
//

#define MEMDB_VERSION L"v9 "

#define VERSION_BASE_SIGNATURE L"memdb dat file "
#define MEMDB_DEBUG_SIGNATURE   L"debug"
#define MEMDB_NODBG_SIGNATURE   L"nodbg"

#define VERSION_SIGNATURE VERSION_BASE_SIGNATURE MEMDB_VERSION
#define DEBUG_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_DEBUG_SIGNATURE
#define RETAIL_FILE_SIGNATURE VERSION_SIGNATURE MEMDB_NODBG_SIGNATURE

#define SIGNATURE 0xab12e87d


//
// We must reserve 5 bits. In a KEYSTRUCT node, 2 bits are used for AVL
// balancing, 1 bit for endpoint, 1 bit for proxy nodes, and 1 bit for binary
// nodes. In a hash table entry, the top 5 bits provide the hive index.
//

#define RESERVED_BITS       27
#define RESERVED_MASK       0xf8000000
#define OFFSET_MASK         (~RESERVED_MASK)

//
// KEYSTRUCT flags
//

#define KSF_ENDPOINT        0x08000000
#define KSF_BINARY          0x40000000
#define KSF_PROXY_NODE      0x80000000
#define KSF_BALANCE_MASK    0x30000000
#define KSF_BALANCE_SHIFT   28              // bit pos of KSF_RIGHT_HEAVY
#define KSF_RIGHT_HEAVY     0x10000000
#define KSF_LEFT_HEAVY      0x20000000
#define KSF_USERFLAG_MASK   OFFSET_MASK

//
// Binary tree allocation parameters
//

#define ALLOC_TOLERANCE 32
#define BLOCK_SIZE      0x00010000

#define MAX_HIVE_NAME       64

#define TOKENBUCKETS    511


//
// Typedefs
//

//
// The DATABASE structure holds all pieces of information necessary
// to maintain a portion of the overall memory database.  There is a
// root DATABASE structure that always exists (its index is zero),
// and there are additional DATABASE structures for each database
// the caller creates via the MemDbCreateDatabase call.  Callers create
// additional databases when a node is needed for temporary processing.
//

typedef struct {
    DWORD AllocSize;
    DWORD End;
    DWORD FirstLevelRoot;
    DWORD FirstDeleted;
    DWORD TokenBuckets[TOKENBUCKETS];
    PBYTE Buf;
    WCHAR Hive[MAX_HIVE_NAME];
} DATABASE, *PDATABASE;

//
// Hive struct (for KSF_HIVE type)
//

typedef struct {
    DATABASE DatabaseInfo;
} HIVE, *PHIVE;

//
// Binary block struct (for KSF_BINARY type of the key struct)
//

typedef struct _tagBINARYBLOCK {
#ifdef DEBUG
    DWORD Signature;
#endif

    DWORD Size;
    struct _tagBINARYBLOCK *NextPtr, *PrevPtr;
    DWORD OwningKey;
    BYTE Data[];
} BINARYBLOCK, *PBINARYBLOCK;


//
// KEYSTRUCT holds each piece of memdb entries.  A single KEYSTRUCT
// holds a portion of a key (delimited by a backslash), and the
// KEYSTRUCTs are organized into a binary tree.  Each KEYSTRUCT
// can also contain additional binary trees.  This is what makes
// memdb so versitle--many relationships can be established by
// formatting key strings in various ways.
//

typedef struct {
    DWORD Signature;

    // Offsets for data struct
    DWORD Left, Right;
    DWORD Parent;

    union {
        struct {
            union {
                DWORD dwValue;
                PBINARYBLOCK BinaryPtr;
            };
            DWORD Flags;
            // Other properties here
        };

        DWORD NextDeleted;        // for deleted items, we keep a list of free blocks
    };

    DWORD NextLevelRoot;
    DWORD PrevLevelNode;

    DWORD KeyToken;
} KEYSTRUCT_DEBUG, *PKEYSTRUCT_DEBUG;


typedef struct {
    // Offsets for data struct
    DWORD Left, Right;
    DWORD Parent;

    union {
        struct {
            union {
                DWORD dwValue;
                PBINARYBLOCK BinaryPtr;
            };
            DWORD Flags;
            // Other properties here
        };

        DWORD NextDeleted;        // for deleted items, we keep a list of free blocks
    };

    DWORD NextLevelRoot;
    DWORD PrevLevelNode;

    DWORD KeyToken;
} KEYSTRUCT_RETAIL, *PKEYSTRUCT_RETAIL;

typedef struct {
    DWORD Right;
    WCHAR String[];
} TOKENSTRUCT, *PTOKENSTRUCT;

#ifdef DEBUG
#define KEYSTRUCT       KEYSTRUCT_DEBUG
#define PKEYSTRUCT      PKEYSTRUCT_DEBUG
#else
#define KEYSTRUCT       KEYSTRUCT_RETAIL
#define PKEYSTRUCT      PKEYSTRUCT_RETAIL
#endif



//
// Globals
//

extern PDATABASE g_db;
extern BYTE g_SelectedDatabase;        // current index of active database
extern PHIVE g_HeadHive;
extern CRITICAL_SECTION g_MemDbCs;

#ifdef DEBUG
extern BOOL g_UseDebugStructs;
#endif

//
// memdb.c routines
//

PCWSTR
SelectHive (
    PCWSTR FullKeyStr
    );

BOOL
PrivateMemDbSetValueA (
    IN      PCSTR Key,
    IN      DWORD Val,
    IN      DWORD SetFlags,
    IN      DWORD ClearFlags,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetValueW (
    IN      PCWSTR Key,
    IN      DWORD Val,
    IN      DWORD SetFlags,
    IN      DWORD ClearFlags,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetBinaryValueA (
    IN      PCSTR Key,
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset           OPTIONAL
    );

BOOL
PrivateMemDbSetBinaryValueW (
    IN      PCWSTR Key,
    IN      PCBYTE  BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset           OPTIONAL
    );

//
// hash.c routines
//

BOOL
InitializeHashBlock (
    VOID
    );

VOID
FreeHashBlock (
    VOID
    );


BOOL
SaveHashBlock (
    HANDLE File
    );

BOOL
LoadHashBlock (
    HANDLE File
    );

BOOL
AddHashTableEntry (
    IN      PCWSTR FullString,
    IN      DWORD Offset
    );

DWORD
FindStringInHashTable (
    IN      PCWSTR FullString,
    OUT     PBYTE DatabaseId        OPTIONAL
    );

BOOL
RemoveHashTableEntry (
    IN      PCWSTR FullString
    );

//
// binval.c
//

PCBYTE
GetKeyStructBinaryData (
    PKEYSTRUCT KeyStruct
    );

DWORD
GetKeyStructBinarySize (
    PKEYSTRUCT KeyStruct
    );

PBINARYBLOCK
AllocBinaryBlock (
    IN      PCBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD OwningKey
    );

VOID
FreeKeyStructBinaryBlock (
    PKEYSTRUCT KeyStruct
    );

VOID
FreeAllBinaryBlocks (
    VOID
    );

BOOL
LoadBinaryBlocks (
    HANDLE File
    );

BOOL
SaveBinaryBlocks (
    HANDLE File
    );


//
// bintree.c
//

PKEYSTRUCT
GetKeyStruct (
    DWORD Offset
    );

DWORD
FindKeyStruct (
    IN DWORD RootOffset,
    IN PCWSTR KeyName
    );


DWORD
GetFirstOffset (
    DWORD RootOffset
    );

DWORD
GetNextOffset (
    DWORD NodeOffset
    );

DWORD
FindKey (
    IN  PCWSTR FullKeyPath
    );

DWORD
FindPatternKey (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath,
    IN  BOOL EndPatternAllowed
    );

DWORD
FindKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    );

DWORD
FindPatternKeyUsingPattern (
    IN  DWORD RootOffset,
    IN  PCWSTR FullKeyPath
    );

DWORD
NewKey (
    IN  PCWSTR KeyStr,
    IN  PCWSTR KeyStrWithHive
    );

VOID
DeleteKey (
    IN      PCWSTR KeyStr,
    IN OUT  PDWORD RootPtr,
    IN      BOOL MustMatch
    );

VOID
CopyValToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    );

VOID
CopyFlagsToPtr (
    PKEYSTRUCT KeyStruct,
    PDWORD ValPtr
    );

BOOL
PrivateBuildKeyFromOffset (
    IN      DWORD StartLevel,               // zero-based
    IN      DWORD TailOffset,
    OUT     PWSTR Buffer,                   OPTIONAL
    OUT     PDWORD ValPtr,                  OPTIONAL
    OUT     PDWORD UserFlagsPtr,            OPTIONAL
    OUT     PDWORD CharCount                OPTIONAL
    );

BOOL
SelectDatabase (
    IN      BYTE DatabaseId
    );

#ifdef DEBUG

VOID
DumpBinTreeStats (
    VOID
    );

#else

#define DumpBinTreeStats()

#endif

PCWSTR
GetKeyToken (
    IN      DWORD Token
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\regops.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  regops.c

Abstract:

  Routines that manage the merging of registry keys. Given a key
  and a value, these functions allow the user to perform the same
  types of actions as those specified in usermig.inf and wkstamig.inf
  (i.e.: Copying, Suppressing, and Forcing various registry keys to be
  merged into the NT registry.)


Routines:


Author:

    Marc R. Whitten (marcw) 01-Aug-1997

Revision History:

    Jim Schmidt (jimschm)   25-Mar-1998     Updated to properly support
                                            tree notation, fixed value suppression
                                            bug.


--*/

#include "pch.h"
#include "memdbp.h"

#define DBG_REGOPS "RegOps"




/*++

Routine Description:

  IsRegObjectMarkedForOperation builds an encoded key, escaping multi-byte
  characters and syntax characters, and then performs a MemDb lookup to see
  if the object is marked with the bit specified by OperationMask.  A set of
  macros are built on top of this routine in regops.h.

Arguments:

  Key           - Specifies the unencoded registry key, with abriviated roots
                  (i.e., HKLM\Software\Foo)
  Value         - Specifies the registry key value name
  TreeState     - Specifies KEY_ONLY to query against the key and optional
                  value, KEY_TREE to query against the key with a star at the
                  end, or TREE_OPTIONAL to query both.
  OperationMask - Specifies an operation mask.  See merge.h.

Return Value:

  TRUE if the key is in MemDb, or FALSE if it is not.

--*/

BOOL
IsRegObjectMarkedForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,                OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    )
{
    PCSTR regObject;
    BOOL rIsMarked = FALSE;
    DWORD value;

    MYASSERT (TreeState != KEY_TREE || !Value);

    if (TreeState == KEY_ONLY || TreeState == TREE_OPTIONAL) {
        regObject = CreateEncodedRegistryStringExA(Key,Value,FALSE);

        if (MemDbGetStoredEndPatternValueA(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringA(regObject);
    }

    if (!rIsMarked && TreeState == KEY_TREE || TreeState == TREE_OPTIONAL && !Value) {
        regObject = CreateEncodedRegistryStringExA(Key,Value,TRUE);

        if (MemDbGetStoredEndPatternValueA(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringA(regObject);
    }

    return rIsMarked;
}

BOOL
IsRegObjectMarkedForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,               OPTIONAL
    IN      TREE_STATE TreeState,
    IN      DWORD OperationMask
    )
{
    PCWSTR regObject;
    BOOL rIsMarked = FALSE;
    DWORD value;

    MYASSERT (TreeState != KEY_TREE || !Value);

    if (TreeState == KEY_ONLY || TreeState == TREE_OPTIONAL) {
        regObject = CreateEncodedRegistryStringExW(Key,Value,FALSE);

        if (MemDbGetStoredEndPatternValueW(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringW(regObject);
    }

    if (!rIsMarked && TreeState == KEY_TREE || TreeState == TREE_OPTIONAL && !Value) {
        regObject = CreateEncodedRegistryStringExW(Key,Value,TRUE);

        if (MemDbGetStoredEndPatternValueW(regObject,&value)) {
            rIsMarked = (value & OperationMask) == OperationMask;
        }

        FreeEncodedRegistryStringW(regObject);
    }

    return rIsMarked;
}



/*++

Routine Description:

  MarkRegObjectForOperation creates an encoded string and sets the operation
  bit in memdb.  This routine is used to suppress operations from occurring
  on a registry key, registry value, or registry key tree.

Arguments:

  Key           - Specifies an unencoded registry key, with abriviated root
                  (i.e., HKLM\Software\Foo).
  Value         - Specifies the registry key value name.
  Tree          - Specifies TRUE if Key specifies an entire registry key tree
                  (in which case Value must be NULL), or FALSE if Key
                  specifies a key that has different behavior for its subkeys.
  OperationMask - Specifies the suppression operation.  See merge.h.

Return Value:

  TRUE if the set was successful.

--*/

BOOL
MarkRegObjectForOperationA (
    IN      PCSTR Key,
    IN      PCSTR Value,            OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    )
{

    PCSTR regObject;
    BOOL rSuccess = TRUE;

    if (Tree && Value) {
        Tree = FALSE;
    }

    regObject = CreateEncodedRegistryStringExA(Key,Value,Tree);

    rSuccess = MarkObjectForOperationA (regObject, OperationMask);

    FreeEncodedRegistryStringA(regObject);

    return rSuccess;
}

BOOL
MarkRegObjectForOperationW (
    IN      PCWSTR Key,
    IN      PCWSTR Value,           OPTIONAL
    IN      BOOL Tree,
    IN      DWORD OperationMask
    )
{

    PCWSTR regObject;
    BOOL rSuccess = TRUE;

    if (Tree && Value) {
        Tree = FALSE;
    }

    regObject = CreateEncodedRegistryStringExW(Key,Value,Tree);

    rSuccess = MarkObjectForOperationW (regObject, OperationMask);

    FreeEncodedRegistryStringW(regObject);

    return rSuccess;
}


/*++

Routine Description:

  MarkObjectForOperation sets operation bits on a specified registry object,
  unless operation bits have already been specified.

Arguments:

  Object        - Specifies the encoded registry object.  See memdbdef.h for
                  syntax (the HKLM or HKR categories).
  OperationMask - Specifies the suppression operation for the particular
                  object.

Return Value:

  TRUE if the set operation was successful, or FALSE if an operation was
  already specified.

--*/


BOOL
MarkObjectForOperationA (
    IN      PCSTR Object,
    IN      DWORD OperationMask
    )
{
    DWORD Value;

    if (MemDbGetValueA (Object, &Value)) {
        DEBUGMSG_IF ((
            Value == OperationMask,
            DBG_REGOPS,
            "%hs is already in memdb.",
            Object
            ));

        DEBUGMSG_IF ((
            Value != OperationMask,
            DBG_REGOPS,
            "%hs is already in memdb with different flags %u. New flags ignored: %u.",
            Object,
            Value,
            OperationMask
            ));

        return FALSE;
    }

    return MemDbSetValueA (Object, OperationMask);
}

BOOL
MarkObjectForOperationW (
    IN      PCWSTR Object,
    IN      DWORD OperationMask
    )
{
    DWORD Value;

    if (MemDbGetValueW (Object, &Value)) {
        DEBUGMSG_IF ((
            Value == OperationMask,
            DBG_REGOPS,
            "%ls is already in memdb.",
            Object
            ));

        DEBUGMSG_IF ((
            Value != OperationMask,
            DBG_REGOPS,
            "%ls is already in memdb with different flags %u. New flags ignored: %u.",
            Object,
            Value,
            OperationMask
            ));

        return FALSE;
    }

    return MemDbSetValueW (Object, OperationMask);
}

BOOL
ForceWin9xSettingA (
    IN      PCSTR SourceKey,
    IN      PCSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCSTR DestinationKey,
    IN      PCSTR DestinationValue,
    IN      BOOL DestinationTree
    )
{
    PCSTR regSource;
    CHAR keySource[MEMDB_MAX];
    PCSTR regDestination;
    CHAR keyDestination[MEMDB_MAX];
    DWORD offset = 0;
    BOOL rSuccess = TRUE;

    regSource = CreateEncodedRegistryStringExA (SourceKey, SourceValue, SourceTree);
    MemDbBuildKeyA (keySource, MEMDB_CATEGORY_FORCECOPYA, regSource, NULL, NULL);

    regDestination = CreateEncodedRegistryStringExA (DestinationKey, DestinationValue, DestinationTree);
    MemDbBuildKeyA (keyDestination, MEMDB_CATEGORY_FORCECOPYA, regDestination, NULL, NULL);

    rSuccess = MemDbSetValueExA (keyDestination, NULL, NULL, NULL, 0, &offset);

    if (rSuccess) {
        rSuccess = MemDbSetValueA (keySource, offset);
    }

    FreeEncodedRegistryStringA (regDestination);

    FreeEncodedRegistryStringA (regSource);

    return rSuccess;
}

BOOL
ForceWin9xSettingW (
    IN      PCWSTR SourceKey,
    IN      PCWSTR SourceValue,
    IN      BOOL SourceTree,
    IN      PCWSTR DestinationKey,
    IN      PCWSTR DestinationValue,
    IN      BOOL DestinationTree
    )
{
    PCWSTR regSource;
    WCHAR keySource[MEMDB_MAX];
    PCWSTR regDestination;
    WCHAR keyDestination[MEMDB_MAX];
    DWORD offset = 0;
    BOOL rSuccess = TRUE;

    regSource = CreateEncodedRegistryStringExW (SourceKey, SourceValue, SourceTree);
    MemDbBuildKeyW (keySource, MEMDB_CATEGORY_FORCECOPYW, regSource, NULL, NULL);

    regDestination = CreateEncodedRegistryStringExW (DestinationKey, DestinationValue, DestinationTree);
    MemDbBuildKeyW (keyDestination, MEMDB_CATEGORY_FORCECOPYW, regDestination, NULL, NULL);

    rSuccess = MemDbSetValueExW (keyDestination, NULL, NULL, NULL, 0, &offset);

    if (rSuccess) {
        rSuccess = MemDbSetValueW (keySource, offset);
    }

    FreeEncodedRegistryStringW (regDestination);

    FreeEncodedRegistryStringW (regSource);

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\memdb\memdbex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memdbex.c

Abstract:

    Extensions to use the memdb tree like a relational database

Author:

    Jim Schmidt (jimschm) 2-Dec-1996

Revision History:

    jimschm     23-Sep-1998 Expanded user flags to 24 bits (from
                            12 bits), removed AnsiFromUnicode
    jimschm     21-Oct-1997 Cleaned up a little
    marcw       09-Apr-1997 Added MemDbGetOffset* functions.
    jimschm     17-Jan-1997 All string params can be NULL now
    jimschm     18-Dec-1996 Added GetEndpointValue functions

--*/

#include "pch.h"
#include "memdbp.h"

VOID
MemDbBuildKeyA (
    OUT     PSTR Buffer,
    IN      PCSTR Category,
    IN      PCSTR Item,
    IN      PCSTR Field,
    IN      PCSTR Data
    )
{
    PSTR p;
    static CHAR Wack[] = "\\";

    p = Buffer;
    *p = 0;

    if (Category)
        p = _mbsappend (p, Category);
    if (Item) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Item);
    }
    if (Field) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Field);
    }
    if (Data) {
        if (p != Buffer)
            p = _mbsappend (p, Wack);

        p = _mbsappend (p, Data);
    }

}


VOID
MemDbBuildKeyW (
    OUT     PWSTR Buffer,
    IN      PCWSTR Category,
    IN      PCWSTR Item,
    IN      PCWSTR Field,
    IN      PCWSTR Data
    )
{
    PWSTR p;
    static WCHAR Wack[] = L"\\";

    p = Buffer;
    *p = 0;

    if (Category)
        p = _wcsappend (p, Category);
    if (Item) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Item);
    }
    if (Field) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Field);
    }
    if (Data) {
        if (p != Buffer)
            p = _wcsappend (p, Wack);

        p = _wcsappend (p, Data);
    }
}


BOOL
MemDbSetValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,         OPTIONAL
    IN      PCSTR Field,        OPTIONAL
    IN      PCSTR Data,         OPTIONAL
    IN      DWORD  Val,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, Category, Item, Field, Data);

    return PrivateMemDbSetValueA (Key, Val, 0, 0, Offset);
}


BOOL
MemDbSetValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,        OPTIONAL
    IN      PCWSTR Field,       OPTIONAL
    IN      PCWSTR Data,        OPTIONAL
    IN      DWORD   Val,
    OUT     PDWORD  Offset      OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW (Key, Category, Item, Field, Data);

    return PrivateMemDbSetValueW (Key, Val, 0, 0, Offset);
}


BOOL
MemDbSetBinaryValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,         OPTIONAL
    IN      PCSTR Field,        OPTIONAL
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA (Key, Category, Item, Field, NULL);

    return PrivateMemDbSetBinaryValueA (Key, BinaryData, DataSize, Offset);
}


BOOL
MemDbSetBinaryValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,        OPTIONAL
    IN      PCWSTR Field,       OPTIONAL
    IN      PCBYTE BinaryData,
    IN      DWORD DataSize,
    OUT     PDWORD Offset       OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW (Key, Category, Item, Field, NULL);

    return PrivateMemDbSetBinaryValueW (Key, BinaryData, DataSize, Offset);
}



/*++

Routine Description:

  MemDbBuildKeyFromOffset and MemDbBuildKeyFromOffsetEx create a key
  string given the offset to the key, copying the string into the
  supplied buffer.  If a value pointer or user flag pointer is
  provided, it is filled with the value or flag stored at the offset.

  These functions also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if an offset points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar in Buffer.

Arguments:

  Offset     - Specifies the offset to the key as returned by MemDbSetValueEx.

  Buffer     - Specifies a MEMDB_MAX buffer.

  StartLevel - Specifies a zero-based starting level, where zero represents
               the complete string, one represents the string starting after
               the first backslash, and so on.

  ValPtr     - Specifies a variable that receives the value stored for the key

Return Value:

  TRUE if the offset is valid and the function completed successfully, or
  FALSE if the offset is not valid or an internal memory corruption was detected.

--*/

BOOL
MemDbBuildKeyFromOffsetA (
    IN      DWORD Offset,
    OUT     PSTR Buffer,            OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr           OPTIONAL
    )
{
    WCHAR WideBuffer[MEMDB_MAX];
    BOOL b;

    b = MemDbBuildKeyFromOffsetW (
            Offset,
            WideBuffer,
            StartLevel,
            ValPtr
            );

    if (b) {
        KnownSizeWtoA (Buffer, WideBuffer);
    }

    return b;
}

BOOL
MemDbBuildKeyFromOffsetW (
    IN      DWORD Offset,
    OUT     PWSTR Buffer,           OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr           OPTIONAL
    )
{
    return MemDbBuildKeyFromOffsetExW (
                Offset,
                Buffer,
                NULL,
                StartLevel,
                ValPtr,
                NULL
                );
}


/*++

Routine Description:

  MemDbBuildKeyFromOffset and MemDbBuildKeyFromOffsetEx create a key
  string given the offset to the key, copying the string into the
  supplied buffer.  If a value pointer or user flag pointer is
  provided, it is filled with the value or flag stored at the offset.

  These functions also allow trimming from the beginning of the string.
  By specifying a start level, the function will skip a number of
  levels before building the string.  For example, if an offset points
  to the string mycat\foo\bar, and StartLevel is 1, the function will
  return foo\bar in Buffer.

Arguments:

  Offset      - Specifies the offset to the key as returned by MemDbSetValueEx.

  Buffer      - Specifies a MEMDB_MAX buffer.

  BufferLen   - Receives the length of the string in characters, excluding the
                terminating nul.  If caller is using this for buffer allocation
                size, double BufferLen.

  StartLevel  - Specifies a zero-based starting level, where zero represents
                the complete string, one represents the string starting after
                the first backslash, and so on.

  ValPtr      - Specifies a variable that receives the value stored for the key

  UserFlagPtr - Specifies a variable that receives the user flags stored for the
                key

Return Value:

  TRUE if the offset is valid and the function completed successfully, or
  FALSE if the offset is not valid or an internal memory corruption was detected.

--*/

BOOL
MemDbBuildKeyFromOffsetExA (
    IN      DWORD Offset,
    OUT     PSTR Buffer,            OPTIONAL
    OUT     PDWORD BufferLen,       OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr,          OPTIONAL
    OUT     PDWORD UserFlagPtr      OPTIONAL
    )
{
    WCHAR WideBuffer[MEMDB_MAX];
    BOOL b;

    b = MemDbBuildKeyFromOffsetExW (
            Offset,
            WideBuffer,
            BufferLen,
            StartLevel,
            ValPtr,
            UserFlagPtr
            );

    if (b) {
        KnownSizeWtoA (Buffer, WideBuffer);
    }

    return b;
}

BOOL
MemDbBuildKeyFromOffsetExW (
    IN      DWORD Offset,
    OUT     PWSTR Buffer,           OPTIONAL
    OUT     PDWORD BufferLen,       OPTIONAL
    IN      DWORD StartLevel,
    OUT     PDWORD ValPtr,          OPTIONAL
    OUT     PDWORD UserFlagPtr      OPTIONAL
    )
{
    PWSTR p,s;
    BYTE newDb = (BYTE) (Offset >> RESERVED_BITS);

    if (Offset == INVALID_OFFSET) {
        return FALSE;
    }

    SelectDatabase (newDb);

    p = Buffer;

    if (newDb != 0) {
        if (StartLevel == 0) {

            if (Buffer) {
                s = g_db->Hive;
                while (*s) {
                    *p++ = *s++;
                }
                *p++ = L'\\';
            }
        }
        else {
            StartLevel --;
        }
    }

    return PrivateBuildKeyFromOffset (
                StartLevel,
                Offset & OFFSET_MASK,
                p,
                ValPtr,
                UserFlagPtr,
                BufferLen
                );
}


BOOL
MemDbEnumItemsA  (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR  Category
    )
{
    CHAR Pattern[MEMDB_MAX];

    if (!Category)
        return FALSE;

    wsprintfA (Pattern, "%s\\*", Category);
    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumItemsW  (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category
    )
{
    WCHAR Pattern[MEMDB_MAX];

    if (!Category)
        return FALSE;

    wsprintfW (Pattern, L"%s\\*", Category);
    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumFieldsA (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR  Category,
    IN      PCSTR  Item             OPTIONAL
    )
{
    CHAR Pattern[MEMDB_MAX];

    if (!Category)
        return MemDbEnumItemsA (pEnum, Item);

    if (!Item)
        return MemDbEnumItemsA (pEnum, Category);

    wsprintfA (Pattern, "%s\\%s\\*", Category, Item);
    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbEnumFieldsW (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category,
    IN      PCWSTR Item             OPTIONAL
    )
{
    WCHAR Pattern[MEMDB_MAX];

    if (!Category)
        return MemDbEnumItemsW (pEnum, Item);

    if (!Item)
        return MemDbEnumItemsW (pEnum, Category);

    wsprintfW (Pattern, L"%s\\%s\\*", Category, Item);
    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_THIS_LEVEL_ONLY, NO_FLAGS);
}


BOOL
MemDbGetValueExA (
    OUT     PMEMDB_ENUMA pEnum,
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field             OPTIONAL
    )
{
    CHAR Pattern[MEMDB_MAX];

    MemDbBuildKeyA (Pattern, Category, Item, Field, NULL);
    if (*Pattern) {
        AppendWackA (Pattern);
    }
    StringCatA (Pattern, "*");

    return MemDbEnumFirstValueA (pEnum, Pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);
}


BOOL
MemDbGetValueExW (
    OUT     PMEMDB_ENUMW pEnum,
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field            OPTIONAL
    )
{
    WCHAR Pattern[MEMDB_MAX];

    MemDbBuildKeyW (Pattern, Category, Item, Field, NULL);
    if (*Pattern) {
        AppendWackW (Pattern);
    }
    StringCatW (Pattern, L"*");

    return MemDbEnumFirstValueW (pEnum, Pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);
}



BOOL
MemDbGetEndpointValueA (
    IN      PCSTR Pattern,
    IN      PCSTR Item,             OPTIONAL        // used as the first variable arg to wsprintfA
    OUT     PSTR Buffer
    )
{
    CHAR Path[MEMDB_MAX];
    MEMDB_ENUMA memdb_enum;

    if (!Pattern) {
        if (!Item)
            return FALSE;

        StringCopyA (Path, Item);
    }
    else {
        if (!Item)
            StringCopyA (Path, Pattern);
        else
            wsprintfA (Path, Pattern, Item);
    }

    if (!MemDbEnumFirstValueA (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyA (Buffer, memdb_enum.szName);
    return TRUE;


}


BOOL
MemDbGetEndpointValueW (
    IN      PCWSTR Pattern,
    IN      PCWSTR Item,            OPTIONAL
    OUT     PWSTR Buffer
    )
{
    WCHAR Path[MEMDB_MAX];
    MEMDB_ENUMW memdb_enum;

    if (!Pattern) {
        if (!Item)
            return FALSE;

        StringCopyW (Path, Item);
    }
    else {
        if (!Item)
            StringCopyW (Path, Pattern);
        else
            wsprintfW (Path, Pattern, Item);
    }

    if (!MemDbEnumFirstValueW (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyW (Buffer, memdb_enum.szName);
    return TRUE;

}


BOOL
MemDbGetEndpointValueExA (
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field,            OPTIONAL
    OUT     PSTR Buffer
    )
{
    CHAR Path[MEMDB_MAX];
    MEMDB_ENUMA memdb_enum;

    MemDbBuildKeyA (Path, Category, Item, Field, NULL);
    if (*Path) {
        AppendWackA (Path);
    }
    StringCatA (Path, "*");


    if (!MemDbEnumFirstValueA (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    strcpy (Buffer, memdb_enum.szName);
    return TRUE;

}

BOOL
MemDbGetEndpointValueExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field,           OPTIONAL
    OUT     PWSTR Buffer
    )
{
    WCHAR Path[MEMDB_MAX];
    MEMDB_ENUMW memdb_enum;

    MemDbBuildKeyW (Path, Category, Item, Field, NULL);
    if (*Path) {
        AppendWackW (Path);
    }
    StringCatW (Path, L"*");

    if (!MemDbEnumFirstValueW (&memdb_enum, Path,
                                MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        Buffer[0] = 0;
        return FALSE;
    }
    StringCopyW (Buffer, memdb_enum.szName);
    return TRUE;

}


BOOL
MemDbGetOffsetW(
    IN      PCWSTR Key,
    OUT     PDWORD Offset
    )
{
    BOOL b;
    DWORD keyOffset;

    keyOffset = FindKey (Key);
    if (keyOffset == INVALID_OFFSET) {
        b = FALSE;
    }
    else {
        b = TRUE;
        *Offset = keyOffset;
    }

    return b;
}


BOOL
MemDbGetOffsetA (
    IN      PCSTR Key,
    OUT     PDWORD Offset
    )
{

    PCWSTR wstr;
    BOOL b;

    wstr = ConvertAtoW (Key);
    if (wstr) {
        b = MemDbGetOffsetW (wstr,Offset);
        FreeConvertedStr (wstr);
    }
    else {
        b = FALSE;
    }

    return b;
}


BOOL
MemDbGetOffsetExW (
    IN      PCWSTR Category,
    IN      PCWSTR Item,            OPTIONAL
    IN      PCWSTR Field,           OPTIONAL
    IN      PCWSTR Data,            OPTIONAL
    OUT     PDWORD Offset           OPTIONAL
    )
{
    WCHAR Key[MEMDB_MAX];

    MemDbBuildKeyW(Key,Category,Item,Field,Data);

    return MemDbGetOffsetW(Key,Offset);
}


BOOL
MemDbGetOffsetExA (
    IN      PCSTR Category,
    IN      PCSTR Item,             OPTIONAL
    IN      PCSTR Field,            OPTIONAL
    IN      PCSTR Data,             OPTIONAL
    OUT     PDWORD Offset           OPTIONAL
    )
{
    CHAR Key[MEMDB_MAX];

    MemDbBuildKeyA(Key,Category,Item,Field,Data);

    return MemDbGetOffsetA(Key,Offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\app.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    app.cpp

Abstract:

    Source file for dealing with registered apps.

Author:

    Jim Schmidt (jimschm)   06-Mar-2001

Revision History:

    <alias> <date> <description>

--*/

#include "pch.h"
#include "migutilp.h"

#include "shappmgrp.h"


ULONGLONG
pComputeWstrChecksum (
    IN      ULONGLONG Checksum,
    IN      PCWSTR String
    )
{
    Checksum = (Checksum << 2) | (Checksum >> 62);
    if (String) {
        while (*String) {
            Checksum = (Checksum << 17) | (Checksum >> 47);
            Checksum ^= (ULONGLONG) (*String);
            String++;
        }
    }

    return Checksum;
}

PINSTALLEDAPPW
GetInstalledAppsW (
    IN OUT  PGROWBUFFER Buffer,
    OUT     PUINT Count             OPTIONAL
    )
{
    IShellAppManager *appManager = NULL;
    IEnumInstalledApps *enumApps = NULL;
    IInstalledApp *installedApp = NULL;
    APPINFODATA appInfoData;
    HRESULT hr = S_FALSE;
    PINSTALLEDAPPW instApp;
    UINT orgEnd;

    MYASSERT(Buffer);

    orgEnd = Buffer->End;

    if (Count) {
        *Count = 0;
    }

    __try {

        //
        // Create shell manager interface
        //

        hr = CoCreateInstance (
                __uuidof(ShellAppManager),
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(IShellAppManager),
                (void**) &appManager
                );

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, "Can't create ShellAppManager interface. hr=%X", hr));
            __leave;
        }

        //
        // Create installed apps enum interface
        //

        hr = appManager->EnumInstalledApps (&enumApps);

        if (hr != S_OK) {
            DEBUGMSG ((DBG_ERROR, "Can't create EnumInstalledApps interface. hr=%X", hr));
            __leave;
        }

        //
        // Enumerate the apps
        //

        hr = enumApps->Next (&installedApp);

        while (hr == S_OK) {
            ZeroMemory (&appInfoData, sizeof (APPINFODATA));
            appInfoData.cbSize = sizeof(APPINFODATA);
            appInfoData.dwMask = AIM_DISPLAYNAME|
                                 AIM_VERSION|
                                 AIM_PUBLISHER|
                                 AIM_PRODUCTID|
                                 AIM_REGISTEREDOWNER|
                                 AIM_REGISTEREDCOMPANY|
                                 AIM_LANGUAGE|
                                 AIM_SUPPORTURL|
                                 AIM_SUPPORTTELEPHONE|
                                 AIM_HELPLINK|
                                 AIM_INSTALLLOCATION|
                                 AIM_INSTALLSOURCE|
                                 AIM_INSTALLDATE|
                                 AIM_CONTACT|
                                 AIM_COMMENTS|
                                 AIM_IMAGE|
                                 AIM_READMEURL|
                                 AIM_UPDATEINFOURL;

            hr = installedApp->GetAppInfo (&appInfoData);

            if (hr == S_OK) {
                instApp = (PINSTALLEDAPPW) GrowBuffer (Buffer, sizeof (INSTALLEDAPPW));
                MYASSERT(instApp);

                StringCopyByteCountW (instApp->DisplayName, appInfoData.pszDisplayName, sizeof (instApp->DisplayName));

                if (appInfoData.pszVersion) {
                    StringCopyByteCountW (instApp->Version, appInfoData.pszVersion, sizeof (instApp->Version));
                } else {
                    instApp->Version[0] = 0;
                }

                if (appInfoData.pszPublisher) {
                    StringCopyByteCountW (instApp->Publisher, appInfoData.pszPublisher, sizeof (instApp->Publisher));
                } else {
                    instApp->Publisher[0] = 0;
                }

                if (appInfoData.pszProductID) {
                    StringCopyByteCountW (instApp->ProductID, appInfoData.pszProductID, sizeof (instApp->ProductID));
                } else {
                    instApp->ProductID[0] = 0;
                }

                if (appInfoData.pszRegisteredOwner) {
                    StringCopyByteCountW (instApp->RegisteredOwner, appInfoData.pszRegisteredOwner, sizeof (instApp->RegisteredOwner));
                } else {
                    instApp->RegisteredOwner[0] = 0;
                }

                if (appInfoData.pszRegisteredCompany) {
                    StringCopyByteCountW (instApp->RegisteredCompany, appInfoData.pszRegisteredCompany, sizeof (instApp->RegisteredCompany));
                } else {
                    instApp->RegisteredCompany[0] = 0;
                }

                if (appInfoData.pszLanguage) {
                    StringCopyByteCountW (instApp->Language, appInfoData.pszLanguage, sizeof (instApp->Language));
                } else {
                    instApp->Language[0] = 0;
                }

                if (appInfoData.pszSupportUrl) {
                    StringCopyByteCountW (instApp->SupportUrl, appInfoData.pszSupportUrl, sizeof (instApp->SupportUrl));
                } else {
                    instApp->SupportUrl[0] = 0;
                }

                if (appInfoData.pszSupportTelephone) {
                    StringCopyByteCountW (instApp->SupportTelephone, appInfoData.pszSupportTelephone, sizeof (instApp->SupportTelephone));
                } else {
                    instApp->SupportTelephone[0] = 0;
                }

                if (appInfoData.pszHelpLink) {
                    StringCopyByteCountW (instApp->HelpLink, appInfoData.pszHelpLink, sizeof (instApp->HelpLink));
                } else {
                    instApp->HelpLink[0] = 0;
                }

                if (appInfoData.pszInstallLocation) {
                    StringCopyByteCountW (instApp->InstallLocation, appInfoData.pszInstallLocation, sizeof (instApp->InstallLocation));
                } else {
                    instApp->InstallLocation[0] = 0;
                }

                if (appInfoData.pszInstallSource) {
                    StringCopyByteCountW (instApp->InstallSource, appInfoData.pszInstallSource, sizeof (instApp->InstallSource));
                } else {
                    instApp->InstallSource[0] = 0;
                }

                if (appInfoData.pszInstallDate) {
                    StringCopyByteCountW (instApp->InstallDate, appInfoData.pszInstallDate, sizeof (instApp->InstallDate));
                } else {
                    instApp->InstallDate[0] = 0;
                }

                if (appInfoData.pszContact) {
                    StringCopyByteCountW (instApp->Contact, appInfoData.pszContact, sizeof (instApp->Contact));
                } else {
                    instApp->Contact[0] = 0;
                }

                if (appInfoData.pszComments) {
                    StringCopyByteCountW (instApp->Comments, appInfoData.pszComments, sizeof (instApp->Comments));
                } else {
                    instApp->Comments[0] = 0;
                }

                if (appInfoData.pszImage) {
                    StringCopyByteCountW (instApp->Image, appInfoData.pszImage, sizeof (instApp->Image));
                } else {
                    instApp->Image[0] = 0;
                }

                if (appInfoData.pszReadmeUrl) {
                    StringCopyByteCountW (instApp->ReadmeUrl, appInfoData.pszReadmeUrl, sizeof (instApp->ReadmeUrl));
                } else {
                    instApp->ReadmeUrl[0] = 0;
                }

                if (appInfoData.pszUpdateInfoUrl) {
                    StringCopyByteCountW (instApp->UpdateInfoUrl, appInfoData.pszUpdateInfoUrl, sizeof (instApp->UpdateInfoUrl));
                } else {
                    instApp->UpdateInfoUrl[0] = 0;
                }

                instApp->Checksum = pComputeWstrChecksum (0, appInfoData.pszVersion);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszPublisher);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszProductID);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszLanguage);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszInstallLocation);
                instApp->Checksum = pComputeWstrChecksum (instApp->Checksum, appInfoData.pszInstallDate);

                if (Count) {
                    *Count += 1;
                }
            }

            installedApp->Release();
            hr = enumApps->Next (&installedApp);
        }

        //
        // Done
        //

        hr = S_OK;

    }
    __finally {
        if (enumApps) {
            enumApps->Release();
        }

        if (appManager) {
            appManager->Release();
        }
    }

    return hr == S_OK ? (PINSTALLEDAPPW) (Buffer->Buf + orgEnd) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\cache.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    Implements a cache mechanism to speed up OpenRegKeyStr.

Author:

    Jim Schmidt (jimschm)  11-Sep-2000

Revisions:

    <alias>     <date>      <comments>

--*/

#include "pch.h"
#include "migutilp.h"

#include "regp.h"

#define DBG_REG     "Reg"

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    BYTE KeyString[];
} REGKEYCACHE, *PREGKEYCACHE;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    CHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMA, *PWORKITEMA;

typedef struct {
    HKEY Key;
    BOOL Unicode;
    UINT RefCount;
    UINT ClosesNeeded;
    REGSAM Sam;
    UINT KeyStringBytes;
    WCHAR KeyString[MAX_REGISTRY_KEY];
} WORKITEMW, *PWORKITEMW;

GROWLIST g_KeyCache = GROWLIST_INIT;
UINT g_MaxCacheCount = 0;
UINT g_CacheAddPos;
CHAR g_LastParent[MAX_REGISTRY_KEY];
UINT g_LastParentBytes;
UINT g_LastParentUse;
WCHAR g_LastParentW[MAX_REGISTRY_KEY];
UINT g_LastParentBytesW;
UINT g_LastParentUseW;

BOOL
pRemoveItemFromCache (
    IN      UINT Item
    );

//
// Implementation
//

VOID
RegInitializeCache (
    IN      UINT InitialCacheSize
    )
{
    if (InitialCacheSize > 64) {
        InitialCacheSize = 64;
    }

    g_MaxCacheCount = InitialCacheSize;
    g_CacheAddPos = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


VOID
RegTerminateCache (
    VOID
    )
{
    UINT u;
    UINT count;

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        pRemoveItemFromCache (u);
    }

    FreeGrowList (&g_KeyCache);
    g_MaxCacheCount = 0;
    g_LastParentUse = 0;
    g_LastParentUseW = 0;
}


BOOL
pRemoveItemFromCache (
    IN      UINT Item
    )
{
    PREGKEYCACHE cacheItem;

    cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, Item);

    if (!cacheItem) {
        return TRUE;
    }

    if (cacheItem->RefCount == 0) {

        while (cacheItem->ClosesNeeded) {
            CloseRegKeyWorker (cacheItem->Key);
            cacheItem->ClosesNeeded--;
        }

        return TRUE;

    } else {
        return FALSE;
    }
}


VOID
RegRecordParentInCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if(!KeyString){
        MYASSERT(KeyString);
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (UINT_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (CHAR))) {
        DEBUGMSG((DBG_WARNING, "RegRecordParentInCacheA: byteCount >= (MAX_REGISTRY_KEY * sizeof (CHAR))"));
        return;
    }

    if (g_LastParentUse && g_LastParentUse < 3 && g_LastParentBytes == byteCount) {

        StringCopyABA (lowerStr, KeyString, StringEnd);
        CharLowerA (lowerStr);

        if (StringMatchA (g_LastParent, lowerStr)) {
            g_LastParentUse++;

            if (g_LastParentUse == 3) {
                //
                // Stimulate the cache
                //
                rootKey = ConvertRootStringToKeyA (lowerStr, &end);
                if (rootKey) {
                    MYASSERT(end <= TcharCountA(lowerStr));
                    if (lowerStr[end]) {
#ifdef DEBUG
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerA (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheA (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABA (g_LastParent, KeyString, StringEnd);
    CharLowerA (g_LastParent);
    g_LastParentBytes = byteCount;

    g_LastParentUse = 1;
}


HKEY
RegGetKeyFromCacheA (
    IN      PCSTR KeyString,
    IN      PCSTR KeyEnd,       OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCSTR end;
    CHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    if(!KeyString){
        MYASSERT(KeyString);
        return NULL;
    }

    count = GrowListGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyA (lowerStr, KeyString);
    } else {
        if (KeyEnd > (KeyString + MAX_REGISTRY_KEY)) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABA (lowerStr, KeyString, KeyEnd);
    }

    CharLowerA (lowerStr);

    stringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (!cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchA ((PCSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheA (
    IN      PCSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMA workItem;
    PCSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if(!KeyString){
        MYASSERT(KeyString);
        return;
    }

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && !cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                DEBUGMSG ((DBG_REG, "Updating empty-named key %s", KeyString));

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);

                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyA (workItem.KeyString, KeyString);
                CharLowerA (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (CHAR);
                GrowListSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = FALSE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyA (workItem.KeyString, KeyString);
    CharLowerA (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (CHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixA ((PCSTR) lastAddItem->KeyString, (PCSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GrowListSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}


BOOL
RegDecrementRefCount (
    IN      HKEY Key
    )
{
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    if (!g_MaxCacheCount) {
        return FALSE;
    }

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);
        if (cacheItem->Key == Key) {
            if (cacheItem->RefCount == 0) {

                //
                // The caller is tried to close the key more times than what
                // it was opened.
                //

                if (cacheItem->Unicode) {
                    DEBUGMSGW ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                } else {
                    DEBUGMSGA ((
                        DBG_WHOOPS,
                        "Reg key %s ref count == 0; trying to close it too many times",
                        cacheItem->KeyString
                        ));
                }
            } else {
                cacheItem->RefCount--;
            }

            //
            // Return TRUE to postpone the close
            //

            return TRUE;
        }
    }

    return FALSE;
}


VOID
RegRecordParentInCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR StringEnd
    )
{
    HKEY key;
    UINT byteCount;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    HKEY rootKey;
    UINT end;

    if (!g_MaxCacheCount) {
        return;
    }

    if(!KeyString){
        MYASSERT(KeyString);
        return;
    }

    if (StringEnd <= KeyString) {
        return;
    }

    byteCount = (UINT) (UINT_PTR) ((PBYTE) StringEnd - (PBYTE) KeyString);

    if (byteCount >= (MAX_REGISTRY_KEY * sizeof (WCHAR))) {
        DEBUGMSG((DBG_WARNING, "RegRecordParentInCacheW: byteCount >= (MAX_REGISTRY_KEY * sizeof (WCHAR))"));
        return;
    }

    if (g_LastParentUseW && g_LastParentUseW < 3 && g_LastParentBytesW == byteCount) {

        StringCopyABW (lowerStr, KeyString, StringEnd);
        CharLowerW (lowerStr);

        if (StringMatchW (g_LastParentW, lowerStr)) {
            g_LastParentUseW++;

            if (g_LastParentUseW == 3) {
                //
                // Stimulate the cache
                //

                rootKey = ConvertRootStringToKeyW (lowerStr, &end);
                if (rootKey) {
                    MYASSERT(end <= TcharCountW(lowerStr));
                    if (lowerStr[end]) {

#ifdef DEBUG
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end], __FILE__, __LINE__);
#else
                        key = OpenRegKeyWorkerW (rootKey, &lowerStr[end]);
#endif

                        if (key) {
                            RegAddKeyToCacheW (lowerStr, key, g_OpenSam);
                            CloseRegKey (key);
                        }
                    }
                }
            }

            return;
        }
    }

    StringCopyABW (g_LastParentW, KeyString, StringEnd);
    CharLowerW (g_LastParentW);
    g_LastParentBytesW = byteCount;

    g_LastParentUseW = 1;
}


HKEY
RegGetKeyFromCacheW (
    IN      PCWSTR KeyString,
    IN      PCWSTR KeyEnd,          OPTIONAL
    IN      REGSAM Sam,
    IN      BOOL IncRefCount
    )
{
    UINT stringBytes;
    PCWSTR end;
    WCHAR lowerStr[MAX_REGISTRY_KEY];
    UINT u;
    UINT count;
    PREGKEYCACHE cacheItem;

    if(!KeyString){
        MYASSERT(KeyString);
        return NULL;
    }

    count = GrowListGetSize (&g_KeyCache);
    if (!count) {
        return NULL;
    }

    if (!KeyEnd) {
        end = StackStringCopyW (lowerStr, KeyString);
    } else {
        if (KeyEnd > (KeyString + MAX_REGISTRY_KEY)) {
            KeyEnd = KeyString + MAX_REGISTRY_KEY;
        }

        end = StringCopyABW (lowerStr, KeyString, KeyEnd);
    }

    CharLowerW (lowerStr);

    stringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) lowerStr);

    //
    // Scan the cache sequentially (it should be small), and return a match
    // if one is found. Stored strings are always in lower case.
    //

    u = g_CacheAddPos;

    do {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (!cacheItem) {
            return NULL;
        }

        if ((cacheItem->KeyStringBytes == stringBytes) &&
            (cacheItem->Unicode) &&
            ((cacheItem->Sam & Sam) == Sam) &&
            (StringMatchW ((PCWSTR) cacheItem->KeyString, lowerStr))
            ) {

            if (IncRefCount) {
                cacheItem->RefCount++;
            }

            return cacheItem->Key;
        }

        u++;
        if (u >= count) {
            u = 0;
        }

    } while (u != g_CacheAddPos);

    return NULL;
}


VOID
RegAddKeyToCacheW (
    IN      PCWSTR KeyString,
    IN      HKEY Key,
    IN      REGSAM Sam
    )
{
    PREGKEYCACHE cacheItem;
    PREGKEYCACHE lastAddItem;
    WORKITEMW workItem;
    PCWSTR end;
    UINT minStructSize;
    UINT pos;
    UINT count;
    UINT u;

    if(!KeyString){
        MYASSERT(KeyString);
        return;
    }

    if (!g_MaxCacheCount || !Key) {
        return;
    }

    //
    // Scan the cache for the existing Key
    //

    count = GrowListGetSize (&g_KeyCache);

    for (u = 0 ; u < count ; u++) {
        cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, u);

        if (cacheItem->Key == Key) {
            cacheItem->RefCount++;

            g_CacheAddPos = u;
            cacheItem->Sam |= Sam;

            if (cacheItem->KeyStringBytes == 0 && *KeyString && cacheItem->Unicode) {

                //
                // This key was added before we knew the name. Update the name
                // now.
                //

                minStructSize = sizeof (workItem) - sizeof (workItem.KeyString);

                CopyMemory (&workItem, cacheItem, minStructSize);

                end = StackStringCopyW (workItem.KeyString, KeyString);
                CharLowerW (workItem.KeyString);
                workItem.KeyStringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);
                workItem.ClosesNeeded++;

                minStructSize += workItem.KeyStringBytes + sizeof (WCHAR);
                GrowListSetItem (&g_KeyCache, u, (PBYTE) &workItem, minStructSize);

            } else if (*KeyString == 0) {
                cacheItem->ClosesNeeded++;
            }

            return;
        }
    }

    //
    // Create the new cache item
    //

    workItem.Key = Key;
    workItem.Unicode = TRUE;
    workItem.RefCount = 1;
    workItem.ClosesNeeded = 1;
    workItem.Sam = Sam;
    end = StackStringCopyW (workItem.KeyString, KeyString);
    CharLowerW (workItem.KeyString);
    workItem.KeyStringBytes = (UINT) (UINT_PTR) ((PBYTE) end - (PBYTE) workItem.KeyString);

    minStructSize = sizeof (workItem) - sizeof (workItem.KeyString) + workItem.KeyStringBytes + sizeof (WCHAR);

    //
    // Put work item into grow list
    //

    if (count < g_MaxCacheCount) {
        g_CacheAddPos = count;
        GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);
    } else {

        //
        // Look for a closed key to discard. If cache is too full, then
        // increase the cache size. If the cache size hits 64, then don't
        // cache this add.
        //

        lastAddItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, g_CacheAddPos);

        if (lastAddItem) {

            for (pos = 0 ; pos < count ; pos++) {
                if (pos == g_CacheAddPos) {
                    continue;
                }

                cacheItem = (PREGKEYCACHE) GrowListGetItem (&g_KeyCache, pos);
                if (cacheItem->KeyStringBytes >= lastAddItem->KeyStringBytes) {
                    break;
                }

                if (!cacheItem->Unicode) {
                    continue;
                }

                if (cacheItem->RefCount) {
                    continue;
                }

                if (!StringPrefixW ((PCWSTR) lastAddItem->KeyString, (PCWSTR) cacheItem->KeyString)) {
                    break;
                }
            }

            if (pos == count) {
                if (g_MaxCacheCount == 64) {
                    DEBUGMSG ((DBG_REG, "Cache is full of open keys"));
                    return;
                }

                g_MaxCacheCount++;
                GrowListAppend (&g_KeyCache, (PBYTE) &workItem, minStructSize);

            } else {
                pRemoveItemFromCache (pos);
                GrowListSetItem (&g_KeyCache, pos, (PBYTE) &workItem, minStructSize);
            }

            g_CacheAddPos = pos;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\debug.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Debug helpers and memory allocation wrappers

Author:

    Jim Schmidt (jimschm) 13-Aug-1996

Revision History:

    Marc R. Whitten (marcw) 27-May-1997
        Added DEBUGLOGTIME() functions and support for the /#U:DOLOG cmd line option.
    Ovidiu Temereanca (ovidiut) 06-Nov-1998
        Took out log related functions and put them in log.c file
--*/

#include "pch.h"
#include "migutilp.h"

//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

#pragma message("DEBUG macros enabled")

#define PCVOID LPCVOID

typedef DWORD ALLOCATION_ITEM_OFFSET;

typedef struct _tagTRACKBUCKETITEM {
    struct _tagTRACKBUCKETITEM *Next;
    struct _tagTRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

#define TRACK_BUCKETS   1501

PTRACKBUCKETITEM g_TrackBuckets[TRACK_BUCKETS];

#define BUCKET_ITEMS_PER_POOL   8192

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;

PTRACKBUCKETITEM g_TrackPoolDelHead;
PTRACKBUCKETPOOL g_TrackPool;

typedef struct _tagTRACKSTRUCT {
    DWORD Signature;
    PCSTR File;
    DWORD Line;
    SIZE_T Size;
    PSTR Comment;
    struct _tagTRACKSTRUCT *PrevAlloc;
    struct _tagTRACKSTRUCT *NextAlloc;
} TRACKSTRUCT, *PTRACKSTRUCT;

PTRACKSTRUCT TrackHead = NULL;
#define TRACK_SIGNATURE     0x30405060

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD Line
    );





//
// The following pointer can be used to help identify memory leak sources.
// It is copied to the memory tracking log.
//

PCSTR g_TrackComment;
PCSTR g_TrackFile;
UINT g_TrackLine;
INT g_UseCount;
UINT g_DisableTrackComment = 0;

VOID
DisableTrackComment (
    VOID
    )
{
    g_DisableTrackComment ++;
}

VOID
EnableTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        g_DisableTrackComment --;
    }
}

DWORD
SetTrackComment (
    PCSTR Msg,
    PCSTR File,
    UINT Line
    )
{
    static CHAR Buffer[1024];
    static CHAR FileCopy[1024];

    if (g_DisableTrackComment > 0) {
        return 0;
    }

    if (g_UseCount > 0) {
        g_UseCount++;
        return 0;
    }

    if (Msg) {
        wsprintfA (Buffer, "%s (%s line %u)", Msg, File, Line);
    } else {
        wsprintfA (Buffer, "%s line %u", File, Line);
    }

    StringCopyA (FileCopy, File);
    g_TrackFile = FileCopy;
    g_TrackLine = Line;

    g_TrackComment = Buffer;
    g_UseCount = 1;

    return 0;
}

DWORD
ClrTrackComment (
    VOID
    )
{
    if (g_DisableTrackComment > 0) {
        return 0;
    }

    g_UseCount--;

    if (!g_UseCount) {
        g_TrackComment=NULL;
    }

    return 0;
}


VOID
pTrackInsert (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    )
{
    p->Signature = TRACK_SIGNATURE;
    p->File      = File;
    p->Line      = Line;
    p->Size      = Size;
    p->Comment   = g_TrackComment ? SafeHeapAlloc (g_hHeap, 0, SizeOfStringA (g_TrackComment)) : NULL;
    p->PrevAlloc = NULL;
    p->NextAlloc = TrackHead;

    if (p->Comment) {
        StringCopyA (p->Comment, g_TrackComment);
    }

    if (TrackHead) {
        TrackHead->PrevAlloc = p;
    }

    TrackHead = p;
}

VOID
pTrackDelete (
    PTRACKSTRUCT p
    )
{
    if (p->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_WARNING, "A tracking signature is invalid.  "
                                "This suggests memory corruption."));
        return;
    }

    if (p->PrevAlloc) {
        p->PrevAlloc->NextAlloc = p->NextAlloc;
    } else {
        TrackHead = p->NextAlloc;
    }

    if (p->NextAlloc) {
        p->NextAlloc->PrevAlloc = p->PrevAlloc;
    }
}

VOID
pWriteTrackLog (
    VOID
    )
{
    HANDLE File;
    CHAR LineBuf[2048];
    PTRACKSTRUCT p;
    DWORD DontCare;
    DWORD Count;
    BOOL BadMem = FALSE;
    CHAR TempPath[MAX_TCHAR_PATH];
    CHAR memtrackLogPath[] = "c:\\memtrack.log";

    if (!TrackHead) {
        return;
    }

    if (ISPC98()) {
        GetSystemDirectory(TempPath, MAX_TCHAR_PATH);
        memtrackLogPath[0] = TempPath[0];
    }
    File = CreateFileA (memtrackLogPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
                        );

    if (File != INVALID_HANDLE_VALUE) {
        Count = 0;
        __try {
            for (p = TrackHead ; p ; p = p->NextAlloc) {
                Count++;
                __try {
                    if (p->Comment) {
                        wsprintfA (LineBuf, "%s line %u\r\n  %s\r\n\r\n", p->File, p->Line, p->Comment);
                    } else {
                        wsprintfA (LineBuf, "%s line %u\r\n\r\n", p->File, p->Line);
                    }
                }
                __except (TRUE) {
                    // BUGBUG -- truncates 64-bit addresses
                    wsprintfA (LineBuf, "Address %Xh was freed, but not by MemFree!!\r\n", (UINT) (UINT_PTR) p);
                    BadMem = TRUE;
                }
                WriteFile (File, LineBuf, ByteCountA (LineBuf), &DontCare, NULL);

                if (BadMem) {
                    break;
                }
            }
        }
        __except (TRUE) {
        }

        wsprintfA (LineBuf, "\r\n%i item%s allocated but not freed.\r\n", Count, Count == 1 ? "":"s");
        WriteFile (File, LineBuf, ByteCountA (LineBuf), &DontCare, NULL);

        CloseHandle (File);
    }
}

typedef struct {
    ALLOCTYPE Type;
    PVOID Ptr;
    PCSTR FileName;
    UINT Line;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;

GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;

VOID
InitAllocationTracking (
    VOID
    )
{
    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
}

VOID
FreeAllocationTracking (
    VOID
    )
{
    UINT Size;
    UINT u;
    PALLOCATION_ITEM Item;
    GROWBUFFER Msg = GROWBUF_INIT;
    CHAR Text[1024];
    PSTR p;
    UINT Bytes;

    Size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);;

    for (u = 0 ; u < Size ; u++) {
        Item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!Item->FileName) {
            continue;
        }

        Bytes = wsprintfA (Text, "%s line %u\r\n", Item->FileName, Item->Line);

        p = (PSTR) RealGrowBuffer (&Msg, Bytes);
        if (p) {
            CopyMemory (p, Text, Bytes);
        }
    }

    if (Msg.End) {

        p = (PSTR) RealGrowBuffer (&Msg, 1);
        if (p) {
            *p = 0;
            DEBUGMSGA (("Leaks", "%s", Msg.Buf));
        }

        FreeGrowBuffer (&Msg);
    }

    FreeGrowBuffer (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    // Intentional leak -- who cares about track memory
    g_TrackPoolDelHead = NULL;
    g_TrackPool = NULL;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM BucketItem;

    if (g_TrackPoolDelHead) {
        BucketItem = g_TrackPoolDelHead;
        g_TrackPoolDelHead = BucketItem->Next;
    } else {

        if (!g_TrackPool || g_TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            g_TrackPool = (PTRACKBUCKETPOOL) SafeHeapAlloc (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            if (!g_TrackPool) {
                return NULL;
            }

            g_TrackPool->Count = 0;
        }

        BucketItem = g_TrackPool->Items + g_TrackPool->Count;
        g_TrackPool->Count++;
    }

    return BucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    BucketItem->Next = g_TrackPoolDelHead;
    g_TrackPoolDelHead = BucketItem;
}



DWORD
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    UINT_PTR Hash;

    Hash = (UINT_PTR) (Type << 16) ^ (UINT_PTR) Ptr;
    return (DWORD) (Hash % TRACK_BUCKETS);
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    DWORD Hash;
    PTRACKBUCKETITEM BucketItem;
    PALLOCATION_ITEM Item;

    Item = (PALLOCATION_ITEM) (Base + ItemOffset);

    Hash = pComputeTrackHashVal (Item->Type, Item->Ptr);

    BucketItem = pAllocTrackBucketItem();

    if (!BucketItem) {
        DEBUGMSG ((DBG_WHOOPS, "pTrackHashTableInsert failed to alloc memory"));
        return;
    }

    BucketItem->Prev = NULL;
    BucketItem->Next = g_TrackBuckets[Hash];
    BucketItem->Type = Item->Type;
    BucketItem->Ptr  = Item->Ptr;
    BucketItem->ItemOffset = ItemOffset;

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem;
    }

    g_TrackBuckets[Hash] = BucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    DWORD Hash;

    Hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        g_TrackBuckets[Hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PTRACKBUCKETITEM BucketItem;
    DWORD Hash;

    Hash = pComputeTrackHashVal (Type, Ptr);

    BucketItem = g_TrackBuckets[Hash];
    while (BucketItem) {
        if (BucketItem->Type == Type && BucketItem->Ptr == Ptr) {
            return BucketItem;
        }

        BucketItem = BucketItem->Next;
    }

    return NULL;
}


VOID
DebugRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM Item;

    MYASSERT (File);

    if (!g_FirstDeletedAlloc) {
        Item = (PALLOCATION_ITEM) RealGrowBuffer (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        Item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item->Ptr;
    }

    if (Item) {
        Item->Type = Type;
        Item->Ptr = Ptr;
        Item->FileName = File;
        Item->Line = Line;

        pTrackHashTableInsert (g_AllocationList.Buf, (UINT) (UINT_PTR) ((PBYTE) Item - g_AllocationList.Buf));
    }
}


VOID
DebugUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr
    )
{
    PALLOCATION_ITEM Item;
    PTRACKBUCKETITEM BucketItem;

    BucketItem = pTrackHashTableFind (Type, Ptr);
    if (!g_AllocationList.Buf) {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (BucketItem) {
        Item = (PALLOCATION_ITEM) (g_AllocationList.Buf + BucketItem->ItemOffset);

        Item->FileName = NULL;
        Item->Type = -1;
        Item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = Item;

        pTrackHashTableDelete (BucketItem);

    } else {
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}



//
// File and Line settings
//

static PCSTR g_File;
static DWORD g_Line;

void
HeapCallFailed (
    PCSTR Msg,
    PCSTR File,
    DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    StringCchCatA (Msg2, ARRAYSIZE(Msg2), Msg);
    StringCchCatA (Msg2, ARRAYSIZE(Msg2), "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        DebugBreak ();
    }
}


#define INVALID_PTR     -1


SIZE_T
DebugHeapValidatePtr (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD Line
    )
{
    SIZE_T rc;

    EnterCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);

    LeaveCriticalSection (&g_MemAllocCs);

    return rc;
}


SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE hHeap,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD Line
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;

    SizeAdjust = sizeof (TRACKSTRUCT);
    RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);

    if (IsBadWritePtr ((PBYTE) RealPtr - 8, 8)) {
        CHAR BadPtrMsg[256];

        // BUGBUG - address is wrong for 64-bit
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x.  This address is not valid.",
            (UINT) (UINT_PTR) CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return INVALID_PTR;
    }

    size = HeapSize (hHeap, 0, RealPtr);
    if (size == (SIZE_T) -1) {
        CHAR BadPtrMsg[256];

        // BUGBUG -- loss of info in 64-bit
        wsprintfA (
            BadPtrMsg,
            "Attempt to free memory at 0x%08x.  "
                "This address is not the start of a memory block.",
            (UINT) (UINT_PTR) CallerPtr
            );

        HeapCallFailed (BadPtrMsg, File, Line);

        return INVALID_PTR;
    }

    return size;
}



//
// Heap debug statistics
//

static SIZE_T g_dwTotalBytesAllocated = 0;
static SIZE_T g_dwMaxBytesInUse = 0;
static DWORD g_dwHeapAllocs = 0;
static DWORD g_dwHeapReAllocs = 0;
static DWORD g_dwHeapFrees = 0;
static DWORD g_dwHeapAllocFails = 0;
static DWORD g_dwHeapReAllocFails = 0;
static DWORD g_dwHeapFreeFails = 0;
#define TRAIL_SIG       0x708aa210

PVOID
DebugHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID RealPtr;
    PVOID ReturnPtr = NULL;
    SIZE_T SizeAdjust;
    SIZE_T TrackStructSize;
    DWORD OrgError;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapAllocFails++;
            __leave;
        }

        RealPtr = SafeHeapAlloc(hHeap, Flags, BytesToAlloc + SizeAdjust);
        if (RealPtr) {
            g_dwHeapAllocs++;
            g_dwTotalBytesAllocated += HeapSize (hHeap, 0, RealPtr);
            g_dwMaxBytesInUse = max (g_dwMaxBytesInUse, g_dwTotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) RealPtr);
            *((PDWORD) ((PBYTE) RealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_dwHeapAllocFails++;
        }

        if (RealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) RealPtr + TrackStructSize);
        }

        if (ReturnPtr && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory (ReturnPtr, BytesToAlloc, 0xAA);
        }

        if (RealPtr) {
            SetLastError(OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

PVOID
DebugHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    SIZE_T lastSize;
    PVOID NewRealPtr;
    PCVOID RealPtr;
    PVOID ReturnPtr = NULL;
    SIZE_T SizeAdjust;
    DWORD OrgError;
    SIZE_T TrackStructSize;
    SIZE_T OrgSize;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {

        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        TrackStructSize = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - TrackStructSize);
        pts = (PTRACKSTRUCT) RealPtr;
        OrgSize = pts->Size;

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapReAllocFails++;
            __leave;
        }

        lastSize = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (lastSize == INVALID_PTR) {
            g_dwHeapReAllocFails++;
            __leave;
        }

        pTrackDelete (pts);

        NewRealPtr = SafeHeapReAlloc (hHeap, Flags, (PVOID) RealPtr, BytesToAlloc + SizeAdjust);
        if (NewRealPtr) {
            g_dwHeapReAllocs++;
            g_dwTotalBytesAllocated -= lastSize;
            g_dwTotalBytesAllocated += HeapSize (hHeap, 0, NewRealPtr);
            g_dwMaxBytesInUse = max (g_dwMaxBytesInUse, g_dwTotalBytesAllocated);

            pTrackInsert (File, Line, BytesToAlloc, (PTRACKSTRUCT) NewRealPtr);
            *((PDWORD) ((PBYTE) NewRealPtr + TrackStructSize + BytesToAlloc)) = TRAIL_SIG;
        }
        else {
            g_dwHeapReAllocFails++;

            // Put original address back in
            pTrackInsert (
                pts->File,
                pts->Line,
                pts->Size,
                pts
                );

        }

        if (NewRealPtr) {
            ReturnPtr = (PVOID) ((PBYTE) NewRealPtr + TrackStructSize);
        }

        if (ReturnPtr && BytesToAlloc > OrgSize && !(Flags & HEAP_ZERO_MEMORY)) {
            FillMemory ((PBYTE) ReturnPtr + OrgSize, BytesToAlloc - OrgSize, 0xAA);
        }

        if (ReturnPtr) {
            SetLastError (OrgError);
        }
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return ReturnPtr;
}

BOOL
DebugHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    SIZE_T size;
    PCVOID RealPtr;
    SIZE_T SizeAdjust;
    DWORD OrgError;
    BOOL Result = FALSE;
    PTRACKSTRUCT pts = NULL;

    EnterCriticalSection (&g_MemAllocCs);

    __try {
        OrgError = GetLastError();

        SizeAdjust = sizeof (TRACKSTRUCT);
        RealPtr = (PCVOID) ((PBYTE) CallerPtr - SizeAdjust);
        pts = (PTRACKSTRUCT) RealPtr;

        if (*((PDWORD) ((PBYTE) CallerPtr + pts->Size)) != TRAIL_SIG) {
            HeapCallFailed ("Heap tag was overwritten!", File, Line);
            __leave;
        }

        if (!HeapValidate (hHeap, 0, NULL)) {
            HeapCallFailed ("Heap is corrupt!", File, Line);
            g_dwHeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (hHeap, CallerPtr, File, Line);
        if (size == (SIZE_T) -1) {
            g_dwHeapFreeFails++;
            __leave;
        }

        pTrackDelete ((PTRACKSTRUCT) RealPtr);

        if (!HeapFree (hHeap, Flags, (PVOID) RealPtr)) {
            CHAR BadPtrMsg[256];

            // BUGBUG -- loss of info in 64-bit
            wsprintf (BadPtrMsg,
                      "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                      "HeapFree() failed.",
                      (UINT) (UINT_PTR) CallerPtr,
                      (UINT) (UINT_PTR) Flags
                      );

            HeapCallFailed (BadPtrMsg, File, Line);
            g_dwHeapFreeFails++;
            __leave;
        }

        g_dwHeapFrees++;
        if (g_dwTotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_dwTotalBytesAllocated = 0;
        } else {
            g_dwTotalBytesAllocated -= size;
        }

        SetLastError (OrgError);
        Result = TRUE;
    }
    __finally {
        LeaveCriticalSection (&g_MemAllocCs);
    }

    return Result;

}


VOID
DumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    pWriteTrackLog();

    wsprintfA (OutputMsg,
               "Bytes currently allocated: %u\n"
               "Peak bytes allocated: %u\n"
               "Allocation count: %u\n"
               "Reallocation count: %u\n"
               "Free count: %u\n",
               g_dwTotalBytesAllocated,
               g_dwMaxBytesInUse,
               g_dwHeapAllocs,
               g_dwHeapReAllocs,
               g_dwHeapFrees
               );

    if (g_dwHeapAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Allocation failures: %u\n",
                   g_dwHeapAllocFails);
    }
    if (g_dwHeapReAllocFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Reallocation failures: %u\n",
                   g_dwHeapReAllocFails);
    }
    if (g_dwHeapFreeFails) {
        wsprintfA (strchr (OutputMsg, 0),
                   "***Free failures: %u\n",
                   g_dwHeapFreeFails);
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));

#ifdef CONSOLE
    printf ("%s", OutputMsg);
#else  // i.e. ifndef CONSOLE

#if 0
    if (0) {
        PROCESS_HEAP_ENTRY he;
        CHAR FlagMsg[256];

        ZeroMemory (&he, sizeof (he));

        while (HeapWalk (g_hHeap, &he)) {
            FlagMsg[0] = 0;
            if (he.wFlags & PROCESS_HEAP_REGION) {
                strcpy (FlagMsg, "PROCESS_HEAP_REGION");
            }
            if (he.wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_UNCOMMITTED_RANGE");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_BUSY");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_MOVEABLE");
            }
            if (he.wFlags & PROCESS_HEAP_ENTRY_DDESHARE) {
                if (FlagMsg[0])
                    strcat (FlagMsg, ", ");

                strcat (FlagMsg, "PROCESS_HEAP_ENTRY_DDESHARE");
            }

            wsprintfA (OutputMsg,
                       "Address of Data: %Xh\n"
                       "Size of Data: %u byte%s\n"
                       "OS Overhead: %u byte%s\n"
                       "Region index: %u\n"
                       "Flags: %s\n\n"
                       "Examine Data?",
                       he.lpData,
                       he.cbData, he.cbData == 1 ? "" : "s",
                       he.cbOverhead, he.cbOverhead == 1 ? "" : "s",
                       he.iRegionIndex,
                       FlagMsg
                       );

            rc = MessageBoxA (GetFocus(), OutputMsg, "Memory Allocation Statistics", MB_YESNOCANCEL|MB_APPLMODAL|MB_SETFOREGROUND);

            if (rc == IDCANCEL) {
                break;
            }

            if (rc == IDYES) {
                int i, j, k, l;
                PBYTE p;
                PSTR p2;
                OutputMsg[0] = 0;

                p = he.lpData;
                p2 = OutputMsg;
                j = min (256, he.cbData);
                for (i = 0 ; i < j ; i += 16) {
                    l = i + 16;
                    for (k = i ; k < l ; k++) {
                        if (k < j) {
                            wsprintfA (p2, "%02X ", (DWORD) (p[k]));
                        } else {
                            wsprintfA (p2, "   ");
                        }

                        p2 = strchr (p2, 0);
                    }

                    l = min (l, j);
                    for (k = i ; k < l ; k++) {
                        if (isprint (p[k])) {
                            *p2 = (CHAR) p[k];
                        } else {
                            *p2 = '.';
                        }
                        p2++;
                    }

                    *p2 = '\n';
                    p2++;
                    *p2 = 0;
                }

                MessageBoxA (GetFocus(), OutputMsg, "Memory Allocation Statistics", MB_OK|MB_APPLMODAL|MB_SETFOREGROUND);
            }
        }
    }
#endif // #if 0

#endif // #ifndef CONSOLE
}

void
DebugHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE hHeap
    )
{
    EnterCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (hHeap, 0, NULL)) {
        HeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    LeaveCriticalSection (&g_MemAllocCs);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\file.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    file.c

Abstract:

    General file-related functions.

Author:

    Mike Condra 16-Aug-1996

Revision History:

    calinn      23-Sep-1998 Additional options to file enum
    jimschm     05-Feb-1998 File enumeration code
    jimschm     30-Sep-1997 WriteFileString routines

--*/

#include "pch.h"
#include "migutilp.h"

BOOL
IsPathLengthOkA (
    IN      PCSTR FileSpec
    )

/*++

Routine Description:

  IsPathLengthOkA checks the inbound string to make sure it fits within
  MAX_MBCHAR_PATH. This includes the nul terminator.

Arguments:

  FileSpec - Specifies the C string to test for appropriate length

Return Value:

  TRUE if FileSpec fits completely within MAX_MBCHAR_PATH

  FALSE otherwise

--*/

{
    PCSTR maxEnd;

    if (!FileSpec) {
        return FALSE;
    }

    maxEnd = FileSpec + MAX_MBCHAR_PATH - 1;

    while (*FileSpec) {
        if (FileSpec == maxEnd) {
            return FALSE;
        }

        FileSpec++;
    }

    return TRUE;
}


BOOL
IsPathLengthOkW (
    IN      PCWSTR FileSpec
    )

/*++

Routine Description:

  IsPathLengthOkW checks the inbound string to make sure it fits within
  MAX_WCHAR_PATH. This includes the nul terminator.

Arguments:

  FileSpec - Specifies the C string to test for appropriate length

Return Value:

  TRUE if FileSpec fits completely within MAX_MBCHAR_PATH

  FALSE otherwise

--*/

{
    PCWSTR maxEnd;

    if (!FileSpec) {
        return FALSE;
    }

    maxEnd = FileSpec + MAX_WCHAR_PATH - 1;

    while (*FileSpec) {
        if (FileSpec == maxEnd) {
            return FALSE;
        }

        FileSpec++;
    }

    return TRUE;
}


BOOL
IsPathOnFixedDriveA (
    IN      PCSTR FileSpec          OPTIONAL
    )

/*++

Routine Description:

  IsPathOnFixedDriveA checks the first three characters of the specified file
  path. If the first three characters are in the form of C:\, and the first
  letter refers to a local fixed disk, then the path is on a fixed
  drive.

  This function does not validate the rest of the path.

  CAUTION: This function has an optimization to cache the last drive letter
  test, and the optimization is not designed to be thread-safe.

Arguments:

  FileSpec - Specifies the file string to test

Return Value:

  TRUE if FileSpec starts with a valid local fixed drive specification

  FALSE otherwise

--*/

{
    static CHAR root[] = "?:\\";
    UINT type;
    static BOOL lastResult;

    if (!FileSpec) {
        return FALSE;
    }

    if (!FileSpec[0]) {
        return FALSE;
    }

    if (FileSpec[1] != ':' || FileSpec[2] != '\\') {
        return FALSE;
    }

    if (root[0] == FileSpec[0]) {
        return lastResult;
    }

    root[0] = FileSpec[0];
    type = GetDriveTypeA (root);

    if (type != DRIVE_FIXED && type != DRIVE_REMOTE) {
        DEBUGMSGA_IF ((
            type != DRIVE_REMOVABLE && type != DRIVE_NO_ROOT_DIR,
            DBG_VERBOSE,
            "Path %s is on unexpected drive type %u",
            FileSpec,
            type
            ));

        lastResult = FALSE;
    } else {
        lastResult = TRUE;
    }

    return lastResult;
}


BOOL
IsPathOnFixedDriveW (
    IN      PCWSTR FileSpec         OPTIONAL
    )

/*++

Routine Description:

  IsPathOnFixedDriveW checks the first three characters of the specified file
  path. If the first three characters are in the form of C:\, and the first
  letter refers to a local fixed disk, then the path is on a fixed
  drive.

  This function does not validate the rest of the path.

  This function is intended for use only on Windows NT. To test for a drive
  letter on Win9x, use IsPathOnFixedDriveA.

  This function supports NT's extended path syntax, \\?\drive:\path,
  as in \\?\c:\foo.

  CAUTION: This function has an optimization to cache the last drive letter
  test, and the optimization is not designed to be thread-safe.

Arguments:

  FileSpec - Specifies the file string to test

Return Value:

  TRUE if FileSpec starts with a valid local fixed drive specification

  FALSE otherwise

--*/

{
    static WCHAR root[] = L"?:\\";
    UINT type;
    static BOOL lastResult;
    PCWSTR p;

    if (!FileSpec) {
        return FALSE;
    }

    p = FileSpec;
    if (p[0] == L'\\' && p[1] == L'\\' && p[2] == L'?' && p[3] == L'\\') {
        p += 4;
    }

    MYASSERT (ISNT());

    if (!p[0]) {
        return FALSE;
    }

    if (p[1] != L':' || p[2] != L'\\') {
        return FALSE;
    }

    if (root[0] == p[0]) {
        return lastResult;
    }

    root[0] = p[0];
    type = GetDriveTypeW (root);

    if (type != DRIVE_FIXED && type != DRIVE_REMOTE) {
        DEBUGMSGW_IF ((
            type != DRIVE_REMOVABLE && type != DRIVE_NO_ROOT_DIR,
            DBG_VERBOSE,
            "Path %s is on unexpected drive type %u",
            FileSpec,
            type
            ));

        lastResult = FALSE;
    } else {
        lastResult = TRUE;
    }

    return lastResult;
}


BOOL
CopyFileSpecToLongA (
    IN      PCSTR FullFileSpecIn,
    OUT     PSTR OutPath                // MAX_MBCHAR_PATH buffer
    )

/*++

Routine Description:

  CopyFileSpecToLongA takes a file specification, either in short or long
  format, and copies the long format into the caller's destination
  buffer.

  This routine generally assumes the caller has restricted the path length to
  fit in a buffer of MAX_PATH.

  CAUTION:

  - If the initial file spec won't fit within MAX_PATH, then it will be copied
    into the destination, but will also be truncated.

  - If the long format of FullFileSpec won't fit within MAX_PATH, then
    FullFileSpecIn is copied into the destination unchanged.

  - MAX_PATH is actually smaller than MAX_MBCHAR_PATH. This function assumes
    the destination buffer is only MAX_PATH chars.

Arguments:

  FullFileSpecIn - Specifies the inbound file spec.

  OutPath - Receives the long path, original path or truncated original path.
            The function attempts to fit long path in, then falls back to
            original path, and then falls back to truncated original path.

Return Value:

  TRUE if the long path was transferred into the destination without any
  issues. In this case, multiple backslashes are converted to one (e.g.,
  c:\\foo becomes c:\foo).

  FALSE if the original path was transferred into the destination; the
  original path might get truncated

--*/

{
    CHAR fullFileSpec[MAX_MBCHAR_PATH];
    WIN32_FIND_DATAA findData;
    HANDLE findHandle;
    PSTR end;
    PSTR currentIn;
    PSTR currentOut;
    PSTR outEnd;
    PSTR maxOutPath = OutPath + MAX_PATH - 1;
    BOOL result = FALSE;
    UINT oldMode;
    BOOL forceCopy = FALSE;

    oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    __try {
        //
        // Limit source length for temp copy below
        //
        if (!IsPathLengthOkA (FullFileSpecIn)) {
            DEBUGMSGA ((DBG_ERROR, "Inbound file spec is too long: %s", FullFileSpecIn));
            __leave;
        }

        //
        // If path is on removable media, don't touch the disk
        //

        if (!IsPathOnFixedDriveA (FullFileSpecIn)) {
            forceCopy = TRUE;
            __leave;
        }

        //
        // Make a copy of the file spec so we can truncate it at the wacks
        //

        StackStringCopyA (fullFileSpec, FullFileSpecIn);

        //
        // Begin building the path
        //

        OutPath[0] = fullFileSpec[0];
        OutPath[1] = fullFileSpec[1];
        OutPath[2] = fullFileSpec[2];
        OutPath[3] = 0;

        MYASSERT (OutPath[0] && OutPath[1] && OutPath[2]);

        //
        // IsPathOnFixedDrive makes the following addition of 3 OK
        //

        currentIn = fullFileSpec + 3;
        currentOut = OutPath + 3;

        //
        // Loop for each segment of the path
        //

        for (;;) {

            end = _mbschr (currentIn, '\\');

            if (end == (currentIn + 1)) {
                //
                // Treat multiple backslashes as one
                //

                currentIn++;
                continue;
            }

            if (end) {
                *end = 0;
            }

            findHandle = FindFirstFileA (fullFileSpec, &findData);

            if (findHandle != INVALID_HANDLE_VALUE) {
                FindClose (findHandle);

                //
                // Copy long file name obtained from FindFirstFile
                //

                outEnd = currentOut + TcharCountA (findData.cFileName);
                if (outEnd > maxOutPath) {

#ifdef DEBUG
                    *currentOut = 0;
                    DEBUGMSGA ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        findData.cFileName,
                        OutPath
                        ));
#endif

                    __leave;
                }

                //
                // StringCopy is not bound because length is restricted above
                //

                StringCopyA (currentOut, findData.cFileName);
                currentOut = outEnd;

            } else {
                //
                // Copy the rest of the path since it doesn't exist
                //

                if (end) {
                    *end = '\\';
                }

                outEnd = currentOut + TcharCountA (currentIn);

                if (outEnd > maxOutPath) {

#ifdef DEBUG
                    DEBUGMSGA ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        currentIn,
                        OutPath
                        ));
#endif

                    __leave;
                }

                //
                // StringCopy is not bound because length is restricted above
                //

                StringCopyA (currentOut, currentIn);
                break;      // done with path
            }

            if (!end) {
                MYASSERT (*currentOut == 0);
                break;      // done with path
            }

            //
            // Ensure wack fits in destination buffer
            //

            if (currentOut + 1 > maxOutPath) {
                DEBUGMSGW ((
                    DBG_WARNING,
                    "Append wack exceeds MAX_PATH for %s",
                    OutPath
                    ));

                __leave;
            }

            //
            // Add wack and advance pointers
            //

            *currentOut++ = '\\';
            *currentOut = 0;
            *end = '\\';            // restore cut point

            currentIn = end + 1;
        }

        result = TRUE;
    }
    __finally {
        SetErrorMode (oldMode);
    }

    if (!result) {
        StringCopyTcharCountA (OutPath, FullFileSpecIn, MAX_PATH);
    }

    MYASSERT (IsPathLengthOkA (OutPath));

    return result || forceCopy;
}


BOOL
CopyFileSpecToLongW (
    IN      PCWSTR FullFileSpecIn,
    OUT     PWSTR OutPath               // MAX_WCHAR_PATH buffer
    )

/*++

Routine Description:

  CopyFileSpecToLongW takes a file specification, either in short or long
  format, and copies the long format into the caller's destination
  buffer.

  This routine generally assumes the caller has restricted the path length to
  fit in a buffer of MAX_PATH.

  CAUTION:

  - If the initial file spec won't fit within MAX_PATH, then it will be copied
    into the destination, but will also be truncated.

  - If the long format of FullFileSpec won't fit within MAX_PATH, then
    FullFileSpecIn is copied into the destination unchanged.

  - MAX_PATH is equal to MAX_WCHAR_PATH. This function assumes the destination
    buffer is only MAX_PATH wchars.

Arguments:

  FullFileSpecIn - Specifies the inbound file spec.

  OutPath - Receives the long path, original path or truncated original path.
            The function attempts to fit long path in, then falls back to
            original path, and then falls back to truncated original path.

Return Value:

  TRUE if the long path was transferred into the destination without any
  issues. In this case, multiple backslashes are converted to one (e.g.,
  c:\\foo becomes c:\foo).

  FALSE if the original path was transferred into the destination; the
  original path might get truncated

--*/

{
    WCHAR fullFileSpec[MAX_WCHAR_PATH];
    WIN32_FIND_DATAW findData;
    HANDLE findHandle;
    PWSTR end;
    PWSTR currentIn;
    PWSTR currentOut;
    PWSTR outEnd;
    PWSTR maxOutPath = OutPath + MAX_PATH - 1;
    BOOL result = FALSE;
    UINT oldMode;
    BOOL forceCopy = FALSE;

    MYASSERT (ISNT());

    oldMode = SetErrorMode (SEM_FAILCRITICALERRORS);

    __try {
        //
        // Limit source length for temp copy below
        //

        if (!IsPathLengthOkW (FullFileSpecIn)) {
            DEBUGMSGW ((DBG_ERROR, "Inbound file spec is too long: %s", FullFileSpecIn));
            __leave;
        }

        //
        // If path is on removable media, don't touch the disk
        //

        if (!IsPathOnFixedDriveW (FullFileSpecIn)) {
            forceCopy = TRUE;
            __leave;
        }

        //
        // Make a copy of the file spec so we can truncate it at the wacks
        //

        StackStringCopyW (fullFileSpec, FullFileSpecIn);

        //
        // Begin building the path
        //

        OutPath[0] = fullFileSpec[0];
        OutPath[1] = fullFileSpec[1];
        OutPath[2] = fullFileSpec[2];
        OutPath[3] = 0;

        MYASSERT (OutPath[0] && OutPath[1] && OutPath[2]);

        //
        // IsPathOnFixedDrive makes the following addition of 3 OK
        //

        currentIn = fullFileSpec + 3;
        currentOut = OutPath + 3;

        //
        // Loop for each segment of the path
        //

        for (;;) {

            end = wcschr (currentIn, L'\\');

            if (end == (currentIn + 1)) {
                //
                // Treat multiple backslashes as one
                //

                currentIn++;
                continue;
            }

            if (end) {
                *end = 0;
            }

            findHandle = FindFirstFileW (fullFileSpec, &findData);

            if (findHandle != INVALID_HANDLE_VALUE) {
                FindClose (findHandle);

                //
                // Copy long file name obtained from FindFirstFile
                //

                outEnd = currentOut + TcharCountW (findData.cFileName);
                if (outEnd > maxOutPath) {

                    DEBUGMSGW ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        findData.cFileName,
                        OutPath
                        ));

                    __leave;
                }

                //
                // StringCopy is not bound because length is restricted above
                //

                StringCopyW (currentOut, findData.cFileName);
                currentOut = outEnd;

            } else {
                //
                // Copy the rest of the path since it doesn't exist
                //

                if (end) {
                    *end = L'\\';
                }

                outEnd = currentOut + TcharCountW (currentIn);

                if (outEnd > maxOutPath) {

                    DEBUGMSGW ((
                        DBG_WARNING,
                        "Path %s too long to append to %s",
                        currentIn,
                        OutPath
                        ));

                    __leave;
                }

                //
                // StringCopy is not bound because length is restricted above
                //

                StringCopyW (currentOut, currentIn);
                break;      // done with path
            }

            if (!end) {
                MYASSERT (*currentOut == 0);
                break;      // done with path
            }

            //
            // Ensure wack fits in destination buffer
            //

            if (currentOut + 1 > maxOutPath) {
                DEBUGMSGW ((
                    DBG_WARNING,
                    "Append wack exceeds MAX_PATH for %s",
                    OutPath
                    ));

                __leave;
            }

            //
            // Add wack and advance pointers
            //

            *currentOut++ = L'\\';
            *currentOut = 0;
            *end = L'\\';               // restore cut point

            currentIn = end + 1;
        }

        result = TRUE;
    }
    __finally {
        SetErrorMode (oldMode);
    }

    if (!result) {
        StringCopyTcharCountW (OutPath, FullFileSpecIn, MAX_PATH);
    }

    MYASSERT (IsPathLengthOkW (OutPath));

    return result || forceCopy;
}



BOOL
DoesFileExistExA(
    IN      PCSTR FileName,
    OUT     PWIN32_FIND_DATAA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAA ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    if (!FindData) {
        //
        // We know that this can fail for other reasons, but for our purposes,
        // we want to know if the file is there. If we can't access it, we'll
        // just assume it is not there.
        //
        // Technically, the caller can look at GetLastError() results to make
        // a distinction. (Nobody does this.)
        //

        return GetFileAttributesA (FileName) != 0xffffffff;
    }

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFileA(FileName, &ourFindData);

    if (FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        *FindData = ourFindData;
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}


BOOL
DoesFileExistExW (
    IN      PCWSTR FileName,
    OUT     PWIN32_FIND_DATAW FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATAW ourFindData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error = NO_ERROR;
    UINT length;
    BOOL result = FALSE;
    PCWSTR longFileName = NULL;

    __try {
        if (FileName[0] != TEXT('\\')) {
            length = TcharCountW (FileName);
            if (length >= MAX_PATH) {
                longFileName = JoinPathsW (L"\\\\?", FileName);
                MYASSERT (longFileName);
                FileName = longFileName;
            }
        }

        if (!FindData) {
            //
            // We know that this can fail for other reasons, but for our
            // purposes, we want to know if the file is there. If we can't
            // access it, we'll just assume it is not there.
            //
            // Technically, the caller can look at GetLastError() results to
            // make a distinction. (Nobody does this.)
            //

            result = (GetLongPathAttributesW (FileName) != 0xffffffff);
            __leave;
        }

        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        FindHandle = FindFirstFileW(FileName,&ourFindData);

        if (FindHandle == INVALID_HANDLE_VALUE) {
            Error = GetLastError();
        } else {
            FindClose(FindHandle);
            *FindData = ourFindData;
        }

        SetErrorMode(OldMode);
        SetLastError(Error);

        result = (Error == NO_ERROR);
    }
    __finally {
        if (longFileName) {
            FreePathStringW (longFileName);
        }
    }

    return result;
}


DWORD
MakeSurePathExistsA(
    IN      PCSTR FullFileSpec,
    IN      BOOL PathOnly
    )

/*++

Routine Description:

  MakeSurePathExistsA creates the subdirectories necessary to hold FileSpec.
  It attempts to create each level of the subdirectory.

  CAUTION: This routine does not set ACLs. Instead, it relies on
           parent inheritance. It is intended for Win9x use.

Arguments:

  FullFileSpec - Specifies the path, which might be a local drive or a UNC
                 path.

  PathOnly - Specifies TRUE if FullFileSpec represents a subdirectory path, or
             FALSE if FullFileSpec represents a subdirectory/file path.

Return Value:

  The Win32 result code, normally ERROR_SUCCESS.

--*/

{
    CHAR Buffer[MAX_MBCHAR_PATH];
    PCHAR p,q;
    BOOL Done;
    BOOL isUnc;
    DWORD d;
    WIN32_FIND_DATAA FindData;

    isUnc = (FullFileSpec[0] == '\\') && (FullFileSpec[1] == '\\');

    //
    // Locate and strip off the final component
    //

    _mbssafecpy(Buffer,FullFileSpec,sizeof(Buffer));

    p = _mbsrchr(Buffer, '\\');

    if (p) {
        if (!PathOnly) {
            *p = 0;
        }
        //
        // If it's a drive root, nothing to do.
        //
        if(Buffer[0] && (Buffer[1] == ':') && !Buffer[2]) {
            return(NO_ERROR);
        }
    } else {
        //
        // Just a relative filename, nothing to do.
        //
        return(NO_ERROR);
    }

    //
    // If it already exists do nothing.
    //
    if (DoesFileExistExA (Buffer,&FindData)) {
        return NO_ERROR;
    }

    p = Buffer;

    //
    // Compensate for drive spec.
    //
    if(p[0] && (p[1] == ':')) {
        p += 2;
    }

    //
    // Compensate for UNC paths.
    //
    if (isUnc) {

        //
        // Skip the initial wack wack before machine name.
        //
        p += 2;


        //
        // Skip to the share.
        //
        p = _mbschr(p, '\\');
        if (p==NULL) {
            return ERROR_BAD_PATHNAME;
        }

        //
        // Skip past the share.
        //
        p = _mbschr(p, '\\');
        if (p==NULL) {
            return ERROR_BAD_PATHNAME;
        }
    }

    Done = FALSE;
    do {
        //
        // Skip path sep char.
        //
        while(*p == '\\') {
            p++;
        }

        //
        // Locate next path sep char or terminating nul.
        //
        if(q = _mbschr(p, '\\')) {
            *q = 0;
        } else {
            q = GetEndOfStringA(p);
            Done = TRUE;
        }

        //
        // Create this portion of the path.
        //
        if(!CreateDirectoryA(Buffer,NULL)) {
            d = GetLastError();
            if(d != ERROR_ALREADY_EXISTS) {
                return(d);
            }
        }

        if(!Done) {
            *q = '\\';
            p = q+1;
        }

    } while(!Done);

    return(NO_ERROR);
}


#if 0           // UNUSED FUNCTION

VOID
DestPathCopyW (
    OUT     PWSTR DestPath,
    IN      PCWSTR SrcPath
    )
{
    PCWSTR p;
    PWSTR q;
    PCWSTR end;
    PCWSTR maxStart;
    UINT len;
    UINT count;

    len = TcharCountW (SrcPath);

    if (len < MAX_PATH) {
        StringCopyW (DestPath, SrcPath);
        return;
    }

    //
    // Path is too long -- try to truncate it
    //

    wsprintfW (DestPath, L"%c:\\Long", SrcPath[0]);
    CreateDirectoryW (DestPath, NULL);

    p = SrcPath;
    end = SrcPath + len;
    maxStart = end - 220;

    while (p < end) {
        if (*p == '\\') {
            if (p >= maxStart) {
                break;
            }
        }

        p++;
    }

    if (p == end) {
        p = maxStart;
    }

    MYASSERT (TcharCountW (p) <= 220);

    StringCopyW (AppendWackW (DestPath), p);
    q = (PWSTR) GetEndOfStringW (DestPath);

    //
    // Verify there is no collision
    //

    for (count = 1 ; count < 1000000 ; count++) {
        if (GetFileAttributesW (DestPath) == INVALID_ATTRIBUTES) {
            break;
        }

        wsprintfW (q, L" (%u)", count);
    }
}

#endif

DWORD
MakeSurePathExistsW(
    IN LPCWSTR FullFileSpec,
    IN BOOL    PathOnly
    )

/*++

Routine Description:

  MakeSurePathExistsW creates the subdirectories necessary to hold FileSpec.
  It attempts to create each level of the subdirectory.

  This function will not create subdirectories that exceed MAX_PATH, unless
  the path is decordated with the \\?\ prefix.

  CAUTION: This routine does not set ACLs. Instead, it relies on
           parent inheritance. It is intended for Win9x use.

Arguments:

  FullFileSpec - Specifies the path, which might be a local drive or a UNC
                 path.

  PathOnly - Specifies TRUE if FullFileSpec represents a subdirectory path, or
             FALSE if FullFileSpec represents a subdirectory/file path.

Return Value:

  The Win32 result code, normally ERROR_SUCCESS.

--*/

{
    PWSTR buffer;
    WCHAR *p, *q;
    BOOL Done;
    DWORD d;
    WIN32_FIND_DATAW FindData;
    DWORD result = NO_ERROR;

    if (FullFileSpec[0] != L'\\') {
        if (TcharCountW (FullFileSpec) >= MAX_PATH) {
            //
            // Verify the path portion is too large. Note that a string without a wack
            // does work here.
            //

            if (PathOnly || ((wcsrchr (FullFileSpec, L'\\') - FullFileSpec) >= MAX_PATH)) {
                LOGW ((LOG_ERROR, "Can't create path %s because it is too long", FullFileSpec));
                return ERROR_FILENAME_EXCED_RANGE;
            }
        }
    }

    //
    // Locate and strip off the final component
    //
    buffer = DuplicatePathStringW (FullFileSpec, 0);
    __try {

        p = wcsrchr(buffer, L'\\');

        if (p) {
            if (!PathOnly) {
                *p = 0;
            }
        } else {
            //
            // Just a relative filename, nothing to do.
            //
            __leave;
        }

        //
        // If it already exists do nothing.
        //
        if (DoesFileExistExW (buffer, &FindData)) {
            result = ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? NO_ERROR : ERROR_DIRECTORY);
            __leave;
        }

        p = buffer;

        //
        // Compensate for drive spec.
        //
        if (p[0] == L'\\' && p[1] == L'\\' && p[2] == L'?' && p[3] == L'\\') {
            p += 4;
        }

        if (p[0] && (p[1] == L':')) {
            p += 2;
        }

        if ((p[0] == 0) || (p[0] == L'\\' && p[1] == 0)) {
            //
            // Root -- leave
            //

            __leave;
        }

        Done = FALSE;
        do {
            //
            // Skip path sep char.
            //
            while(*p == L'\\') {
                p++;
            }

            //
            // Locate next path sep char or terminating nul.
            //
            q = wcschr(p, L'\\');

            if(q) {
                *q = 0;
            } else {
                q = GetEndOfStringW (p);
                Done = TRUE;
            }

            //
            // Create this portion of the path.
            //
            if(!CreateDirectoryW(buffer,NULL)) {
                d = GetLastError();
                if(d != ERROR_ALREADY_EXISTS) {
                    result = d;
                    __leave;
                }
            }

            if(!Done) {
                *q = L'\\';
                p = q+1;
            }

        } while(!Done);
    }
    __finally {
        FreePathStringW (buffer);
    }

    return result;
}


BOOL
WriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, ByteCountA (String), &DontCare, NULL);
}


BOOL
WriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = ConvertWtoA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, ByteCountA (AnsiVersion), &DontCare, NULL);

    FreeConvertedStr (AnsiVersion);

    return b;
}


BOOL
pFindShortNameA (
    IN      PCSTR WhatToFind,
    OUT     PSTR Buffer,
    IN OUT  INT *BufferSizeInBytes
    )

/*++

Routine Description:

  pFindShortNameA is a helper function for OurGetLongPathName.  It
  obtains the short file name, if it exists, using FindFirstFile.

Arguments:

  WhatToFind - Specifies the short or long name of a file to locate

  Buffer - Receives the matching file name. This buffer must be MAX_PATH or
           larger (actually, it must be sized identical to Win32's
           WIN32_FIND_DATAA cFileName member, which is MAX_PATH).

  BufferSizeInBytes - Specifies the size of Buffer (the bytes remaining),
                      receives the number of bytes (excluding the terminating
                      nul) written to Buffer. This is for optimizing.

Return Value:

  TRUE if the file was found and Buffer was updated, or FALSE if the
  file was not found and Buffer was not updated.

--*/

{
    WIN32_FIND_DATAA fd;
    HANDLE hFind;

    hFind = FindFirstFileA (WhatToFind, &fd);
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FindClose (hFind);

    //
    // CAUTION: This code is returning TRUE when it cannot append the next
    // segment to Buffer. However, BufferSizeInBytes is reduced, so the caller
    // will not be able to add anything else.
    //

    *BufferSizeInBytes -= ByteCountA (fd.cFileName);
    if (*BufferSizeInBytes >= sizeof (CHAR)) {
        StringCopyTcharCountA (Buffer, fd.cFileName, ARRAYSIZE(fd.cFileName));
    }

    return TRUE;
}


BOOL
pFindShortNameW (
    IN      PCWSTR WhatToFind,
    OUT     PWSTR Buffer,
    IN OUT  INT *BufferSizeInBytes
    )

/*++

Routine Description:

  pFindShortNameW is a helper function for OurGetLongPathName.  It obtains the
  short file name, if it exists, using FindFirstFile. This version (the wide
  character version) calls FindFirstFileW on NT, and FindFirstFileA on 9x.

Arguments:

  WhatToFind - Specifies the short or long name of a file to locate

  Buffer - Receives the matching file name. This buffer must be MAX_PATH or
           larger (actually, it must be sized identical to Win32's
           WIN32_FIND_DATAA cFileName member, which is MAX_PATH).

  BufferSizeInBytes - Specifies the size of Buffer (the bytes remaining),
                      receives the number of bytes (excluding the terminating
                      nul) written to Buffer. This is for optimizing.

Return Value:

  TRUE if the file was found and Buffer was updated, or FALSE if the
  file was not found and Buffer was not updated.

--*/

{
    WIN32_FIND_DATAA fdA;
    WIN32_FIND_DATAW fdW;
    PCWSTR UnicodeVersion;
    PCSTR AnsiVersion;
    HANDLE hFind;

    if (ISNT ()) {
        hFind = FindFirstFileW (WhatToFind, &fdW);
        if (hFind == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        FindClose (hFind);
    } else {
        AnsiVersion = ConvertWtoA (WhatToFind);
        MYASSERT (AnsiVersion);

        hFind = FindFirstFileA (AnsiVersion, &fdA);
        FreeConvertedStr (AnsiVersion);
        if (hFind == INVALID_HANDLE_VALUE) {
            return FALSE;
        }
        FindClose (hFind);

        //
        // Transfer ANSI to UNICODE.
        //
        // BUGBUG -- this is highly unnecessary, as fdW is local and is
        //           eventually discarded.
        //

        fdW.dwFileAttributes = fdA.dwFileAttributes;
        fdW.ftCreationTime = fdA.ftCreationTime;
        fdW.ftLastAccessTime = fdA.ftLastAccessTime;
        fdW.ftLastWriteTime = fdA.ftLastWriteTime;
        fdW.nFileSizeHigh = fdA.nFileSizeHigh;
        fdW.nFileSizeLow = fdA.nFileSizeLow;
        fdW.dwReserved0 = fdA.dwReserved0;
        fdW.dwReserved1 = fdA.dwReserved1;

        UnicodeVersion = ConvertAtoW (fdA.cFileName);
        MYASSERT (UnicodeVersion);
        StringCopyTcharCountW (fdW.cFileName, UnicodeVersion, ARRAYSIZE(fdW.cFileName));
        FreeConvertedStr (UnicodeVersion);

        UnicodeVersion = ConvertAtoW (fdA.cAlternateFileName);
        MYASSERT (UnicodeVersion);
        StringCopyTcharCountW (fdW.cAlternateFileName, UnicodeVersion, ARRAYSIZE(fdW.cAlternateFileName));
        FreeConvertedStr (UnicodeVersion);
    }

    //
    // CAUTION: This code is returning TRUE when it cannot append the next
    // segment to Buffer. However, BufferSizeInBytes is reduced, so the caller
    // will not be able to add anything else.
    //

    *BufferSizeInBytes -= ByteCountW (fdW.cFileName);
    if (*BufferSizeInBytes >= sizeof (WCHAR)) {
        StringCopyTcharCountW (Buffer, fdW.cFileName, ARRAYSIZE(fdW.cFileName));
    }

  return TRUE;
}


BOOL
OurGetLongPathNameA (
    IN      PCSTR ShortPath,
    OUT     PSTR Buffer,
    IN      INT BufferSizeInBytes
    )

/*++

Routine Description:

  OurGetLongPathNameA locates the long file name for the specified short file.
  It first computes the full path if a path is not explicitly provided, and
  then uses FindFirstFileA to get the long file name. NOTE: This is exactly
  what the Win32 function GetLongPathName does, but unfortunately the Win32
  API is not available on Win95.

  CAUTION: If the buffer is not big enough to hold the whole path, the path
           will be truncated.

Arguments:

  ShortPath - Specifies the file name or full file path to locate

  Buffer - Receives the full file path.  This buffer must be big enough to
           handle the maximum file name size.

  BufferSizeInBytes - Specifies the size of Buffer, in bytes (not TCHARs).
                      Since this is the A version, bytes happens to equal
                      sizeof (TCHAR).

Return Value:

  TRUE if the file is found and Buffer contains the long name, or FALSE
  if the file is not found and Buffer is not modified.

--*/

{
    CHAR FullPath[MAX_MBCHAR_PATH];
    PCSTR SanitizedPath;
    PSTR FilePart;
    PSTR BufferEnd;
    PSTR p, p2;
    MBCHAR c;
    BOOL result = TRUE;

    // BUGBUG: This has been reviewed to be true for XP SP1, but should be
    // enforced by returning an error if it is not the case
    MYASSERT (BufferSizeInBytes >= MAX_MBCHAR_PATH);

    if (ShortPath[0] == 0) {
        return FALSE;
    }

    __try {

        //
        // Clean up the path so it is just a path spec, not filled with .. or
        // other combinations
        //

        SanitizedPath = SanitizePathA (ShortPath);
        if (!SanitizedPath) {
            SanitizedPath = DuplicatePathStringA (ShortPath, 0);
        }

        if (!_mbschr (SanitizedPath, '\\')) {
            //
            // If only a file name is specified, use the path to find the file
            //

            if (!SearchPathA (NULL, SanitizedPath, NULL, ARRAYSIZE(FullPath), FullPath, &FilePart)) {

                result = FALSE;
                __leave;
            }
        } else {
            //
            // Use the OS to sanitize the path even further
            //

            GetFullPathNameA (SanitizedPath, ARRAYSIZE(FullPath), FullPath, &FilePart);
        }

        //
        // Convert short paths to long paths
        //

        p = FullPath;

        if (!IsPathOnFixedDriveA (FullPath)) {
            //
            // Not a local path, just return what we have. It might get truncated.
            //

            _mbssafecpy (Buffer, FullPath, BufferSizeInBytes);
            __leave;
        }

        //
        // We know that the first three chars are something like c:\, so we
        // can advance by 3
        //

        MYASSERT (FullPath[0] && FullPath[1] && FullPath[2]);
        p += 3;

        //
        // We've already asserted that the caller passed in a MAX_PATH buffer
        //

        MYASSERT (BufferSizeInBytes > 3 * sizeof (CHAR));

        //
        // Copy drive letter to buffer
        //

        StringCopyABA (Buffer, FullPath, p);
        BufferEnd = GetEndOfStringA (Buffer);
        BufferSizeInBytes -= (UINT) (UINT_PTR) (p - FullPath);

        //
        // Convert each portion of the path
        //

        do {
            //
            // Locate end of this file or dir
            //
            // BUGBUG: Other functions take into account multiple wack
            // combinations, like c:\\\foo is really c:\foo. Is this a
            // problem?
            //

            p2 = _mbschr (p, '\\');
            if (!p2) {
                p = GetEndOfStringA (p);
            } else {
                p = p2;
            }

            //
            // Cut the path and look up file
            //

            c = *p;
            *p = 0;

            if (!pFindShortNameA (FullPath, BufferEnd, &BufferSizeInBytes)) {
                DEBUGMSG ((DBG_VERBOSE, "OurGetLongPathNameA: %s does not exist", FullPath));
                result = FALSE;
                __leave;
            }

            *p = (CHAR)c;       // restore the cut point

            //
            // Move on to next part of path
            //

            if (*p) {
                p = _mbsinc (p);
                if (BufferSizeInBytes >= sizeof (CHAR) * 2) {
                    BufferEnd = _mbsappend (BufferEnd, "\\");
                    BufferSizeInBytes -= sizeof (CHAR);
                }

                // BUGBUG -- let's break if we're out of buffer space!
            }

            //
            // CAUTION: result is assumed TRUE until proven otherwise
            //

        } while (*p);
    }
    __finally {
        FreePathStringA (SanitizedPath);
    }

    return result;
}


DWORD
OurGetShortPathNameW (
    IN      PCWSTR LongPath,
    OUT     PWSTR ShortPath,
    IN      DWORD CharSize
    )

/*++

Routine Description:

  OurGetShortPathNameW copies an 8.3 filename for the given LongPath, if the
  file exists on the system.

  If this function is called on Win9x, then the long path is converted to
  ANSI, and GetShortPathNameA is called. Additionally, if the path points to a
  non-local disk, then the true short path is not obtained, because it can
  either take an unexpectedly long time, or it can cause other side effects
  like spinning the floppy or CD drive.

  If this function is called on NT, then the request is passed directly to the
  Win32 version -- GetShortPathNameW.

Arguments:

  LongPath - Specifies the long path to examine

  ShortPath - Receives the short path on success

  CharSize - Specifies the number of TCHARs (wchars in this case) that
             ShortPath can hold

Return Value:

  The number of TCHARs (wchars in this case) copied to ShortPath, excluding
  the nul terminator, or zero if an error occurred. GetLastError provides the
  error code.

  CAUTION: This function fills in ShortPath on failure on Win9x, but does not
  fill it in on NT.

--*/

{
    PCSTR LongPathA;
    PSTR ShortPathA;
    PCWSTR ShortPathW;
    DWORD result;

    if (ISNT()) {
        return GetShortPathNameW (LongPath, ShortPath, CharSize);
    } else {
        LongPathA = ConvertWtoA (LongPath);
        MYASSERT (LongPathA);

        if (!IsPathOnFixedDriveA (LongPathA)) {
            StringCopyTcharCountW (ShortPath, LongPath, CharSize);
            FreeConvertedStr (LongPathA);
            return TcharCountW (ShortPath);
        }

        ShortPathA = AllocPathStringA (CharSize);
        result = GetShortPathNameA (LongPathA, ShortPathA, CharSize);
        if (result) {
            ShortPathW = ConvertAtoW (ShortPathA);
            MYASSERT (ShortPathW);

            StringCopyTcharCountW (ShortPath, ShortPathW, CharSize);
            FreeConvertedStr (ShortPathW);
        } else {
            // BUGBUG -- this is not consistent behavior
            StringCopyTcharCountW (ShortPath, LongPath, CharSize);
        }

        FreePathStringA (ShortPathA);
        FreeConvertedStr (LongPathA);
        return result;
    }
}


DWORD
OurGetFullPathNameW (
    IN      PCWSTR FileName,
    IN      DWORD CharSize,
    OUT     PWSTR FullPath,
    OUT     PWSTR *FilePtr
    )

/*++

Routine Description:

  OurGetFullPathNameW is a wrapper to GetFullPathName. Depending on the OS, it
  is directed to GetFullPathNameW (NT) or GetFullPathNameA (9x).

  CAUTION: The failure code for the 9x case is lost, but currently nobody
           cares about this.

Arguments:

  FileName - Specifies the file name to get the full path name of (see Win32
             API for details on what GetFullPathName does)

  CharSize - Specifies the number of TCHARs (wchars in this case) that
             FullPath points to.

  FullPath - Receives the full path specification of FileName

  FilePtr - Receives a pointer to the file within FullPath. CAUTION: You
            would think this is optional, but it is NOT.

Return Value:

  The number of TCHARs (wchars in this case) written to FullPath, or zero if
  an error occurred. On NT, GetLastError() will provide the status code. On
  9x, GetLastError() might provide the status code, but it could be eaten by
  the ANSI/UNICODE conversion routines. BUGBUG -- maybe this should be fixed.

--*/

{
    PCSTR FileNameA;
    PSTR FullPathA;
    PSTR FilePtrA;
    PCWSTR FullPathW;
    DWORD result;
    DWORD err;

    if (ISNT()) {
        return GetFullPathNameW (FileName, CharSize, FullPath, FilePtr);
    } else {
        FileNameA = ConvertWtoA (FileName);
        MYASSERT (FileNameA);

        FullPathA = AllocPathStringA (CharSize);
        MYASSERT (FullPathA);
        MYASSERT (*FullPathA == 0);     // this is important!

        result = GetFullPathNameA (FileNameA, CharSize, FullPathA, &FilePtrA);

        FullPathW = ConvertAtoW (FullPathA);
        MYASSERT (FullPathW);

        StringCopyTcharCountW (FullPath, FullPathW, CharSize);

        err = GetLastError ();  // BUGBUG -- unused assignment

        MYASSERT (FilePtr);     // non-optional argument
        *FilePtr = (PWSTR)GetFileNameFromPathW (FullPath);

        FreeConvertedStr (FullPathW);
        FreePathStringA (FullPathA);
        FreeConvertedStr (FileNameA);

        return result;
    }
}


BOOL
OurGetLongPathNameW (
    IN      PCWSTR ShortPath,
    OUT     PWSTR Buffer,
    IN      INT BufferSizeInChars
    )

/*++

Routine Description:

  OurGetLongPathNameW locates the long file name for the specified short file.
  It first computes the full path if a path is not explicitly provided, and
  then uses FindFirstFileA to get the long file name. NOTE: This is exactly
  what the Win32 function GetLongPathName does, but unfortunately the Win32
  API is not available on Win95.

  CAUTIONS: If the buffer is not big enough to hold the whole path, the path
            will be truncated.

            If this version (the W version) is called on Win9x, and a full
            path specification is not provided, the function will fail.

            Path sanitization is not done in this version, but it is done in
            the A version.

Arguments:

  ShortPath - Specifies the file name or full file path to locate

  Buffer - Receives the full file path.  This buffer must be big enough to
           handle the maximum file name size.

  BufferSizeInBytes - Specifies the size of Buffer, in bytes (not TCHARs).
                      Since this is the A version, bytes happens to equal
                      sizeof (TCHAR).

Return Value:

  TRUE if the file is found and Buffer contains the long name, or FALSE
  if the file is not found and Buffer is not modified.

--*/

{
    WCHAR FullPath[MAX_WCHAR_PATH];
    PWSTR FilePart;
    PWSTR BufferEnd;
    PWSTR p, p2;
    WCHAR c;
    INT BufferSizeInBytes;

    // BUGBUG: This has been reviewed to be true for XP SP1, but should be
    // enforced by returning an error if it is not the case
    MYASSERT (BufferSizeInChars >= MAX_WCHAR_PATH);

    if (ShortPath[0] == 0) {
        return FALSE;
    }

    BufferSizeInBytes = BufferSizeInChars * sizeof (WCHAR);

    //
    // CAUTION: In the A version, we sanitize the path (e.g., convert
    // c:\foo\..\bar to c:\bar), but we don't do this for the W version,
    // because it isn't necessary given the current use of this function.
    //

    //
    // Resolve the ShortPath into a full path
    //

    if (!wcschr (ShortPath, L'\\')) {
        if (!SearchPathW (NULL, ShortPath, NULL, MAX_WCHAR_PATH, FullPath, &FilePart)) {
            return FALSE;
        }
    } else {
        if (OurGetFullPathNameW (ShortPath, MAX_WCHAR_PATH, FullPath, &FilePart) == 0) {
            return FALSE;
        }
    }

    //
    // Convert short paths to long paths
    //

    p = FullPath;

    if (!IsPathOnFixedDriveW (FullPath)) {
        StringCopyTcharCountW (Buffer, FullPath, BufferSizeInChars);
        return TRUE;
    }

    //
    // We know that the first three chars are something like c:\, so we
    // can advance by 3
    //

    MYASSERT (FullPath[0] && FullPath[1] && FullPath[2]);
    p += 3;

    //
    // Copy drive letter to buffer
    //

    StringCopyABW (Buffer, FullPath, p);
    BufferEnd = GetEndOfStringW (Buffer);
    BufferSizeInBytes -= sizeof (WCHAR) * 3;

    //
    // Convert each portion of the path
    //

    do {
        //
        // Locate end of this file or dir
        //
        // BUGBUG: Other functions take into account multiple wack
        // combinations, like c:\\\foo is really c:\foo. Is this a
        // problem?
        //

        p2 = wcschr (p, L'\\');
        if (!p2) {
            p = GetEndOfStringW (p);
        } else {
            p = p2;
        }

        //
        // Cut the path and look up file
        //

        c = *p;
        *p = 0;

        if (!pFindShortNameW (FullPath, BufferEnd, &BufferSizeInBytes)) {
            DEBUGMSG ((DBG_VERBOSE, "OurGetLongPathNameW: %ls does not exist", FullPath));
            return FALSE;
        }
        *p = c;         // restore cut point

        //
        // Move on to next part of path
        //

        if (*p) {
            p++;
            if (BufferSizeInBytes >= sizeof (WCHAR) * 2) {
                BufferEnd = _wcsappend (BufferEnd, L"\\");
                BufferSizeInBytes -= sizeof (WCHAR);
            }

            // BUGBUG -- let's break if we're out of buffer space!
        }

    } while (*p);

    return TRUE;
}


#ifdef DEBUG
UINT g_FileEnumResourcesInUse;
#endif

VOID
pTrackedFindClose (
    HANDLE FindHandle
    )
{
#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    FindClose (FindHandle);
}

BOOL
EnumFirstFileInTreeExA (
    OUT     PTREE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern,          OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    )

/*++

Routine Description:

  EnumFirstFileInTreeA begins an enumeration of a directory tree.  The
  caller supplies an uninitialized enum structure, a directory path to
  enumerate, and an optional file pattern.  On return, the caller
  receives all files and directories that match the pattern.

  If a file pattern is supplied, directories that do not match the
  file pattern are enumerated anyway.

Arguments:

  EnumPtr - Receives the enumerated file or directory

  RootPath - Specifies the full path of the directory to enumerate

  FilePattern - Specifies a pattern of files to limit the search to

  EnumDirsFirst - Specifies TRUE if the directories should be enumerated
                  before the files, or FALSE if the directories should
                  be enumerated after the files.

Return Value:

  TRUE if a file or directory was enumerated, or FALSE if enumeration is complete
  or an error occurred.  (Use GetLastError to determine the result.)

--*/

{
    ZeroMemory (EnumPtr, sizeof (TREE_ENUMA));

    EnumPtr->State = TREE_ENUM_INIT;

    _mbssafecpy (EnumPtr->RootPath, RootPath, sizeof (EnumPtr->RootPath));

    if (FilePattern) {
        _mbssafecpy (EnumPtr->FilePattern, FilePattern, sizeof (EnumPtr->FilePattern));
    } else {
        //
        // Important: some drivers on Win9x don't think * is *.*
        //

        StringCopyA (EnumPtr->FilePattern, "*.*");
    }

    EnumPtr->EnumDirsFirst = EnumDirsFirst;
    EnumPtr->EnumDepthFirst = EnumDepthFirst;

    EnumPtr->Level    = 1;
    EnumPtr->MaxLevel = MaxLevel;

    return EnumNextFileInTreeA (EnumPtr);
}


BOOL
EnumFirstFileInTreeExW (
    OUT     PTREE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern,         OPTIONAL
    IN      BOOL EnumDirsFirst,
    IN      BOOL EnumDepthFirst,
    IN      INT  MaxLevel
    )

/*++

Routine Description:

  EnumFirstFileInTreeW begins an enumeration of a directory tree.  The
  caller supplies an uninitialized enum structure, a directory path to
  enumerate, and an optional file pattern.  On return, the caller
  receives all files and directories that match the pattern.

  If a file pattern is supplied, directories that do not match the
  file pattern are enumerated anyway.

Arguments:

  EnumPtr - Receives the enumerated file or directory

  RootPath - Specifies the full path of the directory to enumerate

  FilePattern - Specifies a pattern of files to limit the search to

  EnumDirsFirst - Specifies TRUE if the directories should be enumerated
                  before the files, or FALSE if the directories should
                  be enumerated after the files.

Return Value:

  TRUE if a file or directory was enumerated, or FALSE if enumeration is complete
  or an error occurred.  (Use GetLastError to determine the result.)

--*/

{
    ZeroMemory (EnumPtr, sizeof (TREE_ENUMW));

    EnumPtr->State = TREE_ENUM_INIT;

    _wcssafecpy (EnumPtr->RootPath, RootPath, sizeof (EnumPtr->RootPath));

    if (FilePattern) {
        _wcssafecpy (EnumPtr->FilePattern, FilePattern, sizeof (EnumPtr->FilePattern));
    } else {
        //
        // Important: some drivers on Win9x don't think * is *.*
        //

        StringCopyW (EnumPtr->FilePattern, L"*.*");
    }

    EnumPtr->EnumDirsFirst = EnumDirsFirst;
    EnumPtr->EnumDepthFirst = EnumDepthFirst;

    EnumPtr->Level    = 1;
    EnumPtr->MaxLevel = MaxLevel;

    return EnumNextFileInTreeW (EnumPtr);
}


BOOL
EnumNextFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextFileInTree continues an enumeration of a directory tree,
  returning the files that match the pattern specified in EnumFirstFileInTree,
  and also returning all directories.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives the enumerated file
            or directory

Return Value:

  TRUE if a file or directory was enumerated, or FALSE if enumeration is complete
  or an error occurred.  (Use GetLastError to determine the result.)

--*/

{
    PSTR p;

    for (;;) {
        switch (EnumPtr->State) {

        case TREE_ENUM_INIT:
            //
            // Get rid of wack at the end of root path, if it exists
            //

            p = GetEndOfStringA (EnumPtr->RootPath);
            p = our_mbsdec (EnumPtr->RootPath, p);
            if (!p) {
                DEBUGMSGA ((DBG_ERROR, "Path spec %s is incomplete", EnumPtr->RootPath));
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            if (_mbsnextc (p) == '\\') {
                *p = 0;
            }

            //
            // Initialize enumeration structure
            //

            EnumPtr->FilePatternSize = SizeOfStringA (EnumPtr->FilePattern);

            MYASSERT (sizeof (EnumPtr->FileBuffer) == sizeof (EnumPtr->RootPath));
            StringCopyA (EnumPtr->FileBuffer, EnumPtr->RootPath);
            EnumPtr->EndOfFileBuffer = GetEndOfStringA (EnumPtr->FileBuffer);

            MYASSERT (sizeof (EnumPtr->Pattern) == sizeof (EnumPtr->RootPath));
            StringCopyA (EnumPtr->Pattern, EnumPtr->RootPath);
            EnumPtr->EndOfPattern = GetEndOfStringA (EnumPtr->Pattern);

            EnumPtr->FullPath = EnumPtr->FileBuffer;

            EnumPtr->RootPathSize = ByteCountA (EnumPtr->RootPath);

            //
            // Allocate first find data sturct
            //

            EnumPtr->Current = (PFIND_DATAA) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAA)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

#ifdef DEBUG
            g_FileEnumResourcesInUse++;        // account for grow buffer
#endif

            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_BEGIN:
            //
            // Initialize current find data struct
            //

            EnumPtr->Current->SavedEndOfFileBuffer = EnumPtr->EndOfFileBuffer;
            EnumPtr->Current->SavedEndOfPattern = EnumPtr->EndOfPattern;

            //
            // Limit the length of the pattern string
            //

            MYASSERT (ARRAYSIZE(EnumPtr->FileBuffer) == MAX_MBCHAR_PATH);

            //
            // This math below does account for the added wack between the
            // pattern base already in EnumPtr->Pattern and the new pattern
            // in EnumPtr->FilePatternSize. The way it is included is by
            // using >= instead of ==, and an assumption that sizeof(CHAR) == 1.
            // EnumPtr->FilePatternSize includes the nul terminator.
            //

            MYASSERT (sizeof (CHAR) == 1);      // the math is totally dependent on this

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) +
                    EnumPtr->FilePatternSize >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->FilePattern));

                EnumPtr->State = TREE_ENUM_POP;

                break;
            }

            //
            // Enumerate the files or directories
            //

            if (EnumPtr->EnumDirsFirst) {
                EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
            } else {
                EnumPtr->State = TREE_ENUM_FILES_BEGIN;
            }
            break;

        case TREE_ENUM_FILES_BEGIN:
            //
            // Begin enumeration of files
            //

            // This assert is valid because of length check in TREE_ENUM_BEGIN

            MYASSERT ((TcharCountA (EnumPtr->Pattern) + 1 +
                        TcharCountA (EnumPtr->FilePattern)) < ARRAYSIZE(EnumPtr->Pattern)
                        );

            StringCopyA (EnumPtr->EndOfPattern, "\\");
            StringCopyA (EnumPtr->EndOfPattern + 1, EnumPtr->FilePattern);

            EnumPtr->Current->FindHandle = FindFirstFileA (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                if (EnumPtr->EnumDirsFirst) {
                    EnumPtr->State = TREE_ENUM_POP;
                } else {
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                }
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif
                //
                // Skip directories
                //

                if (EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            }

            break;

        case TREE_ENUM_RETURN_ITEM:
            //
            // Update pointers to current item
            //

            EnumPtr->FindData = &EnumPtr->Current->FindData;
            EnumPtr->Name = EnumPtr->FindData->cFileName;
            EnumPtr->Directory = (EnumPtr->FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

            //
            // Limit the length of the resulting full path. The nul is
            // accounted for in SizeOfStringA, and the additional wack is
            // accounted for by using >= instead of ==.
            //

            MYASSERT (ARRAYSIZE(EnumPtr->FileBuffer) == MAX_MBCHAR_PATH);
            MYASSERT (sizeof (CHAR) == 1);      // the math is totally dependent on this

            if ((EnumPtr->EndOfFileBuffer - EnumPtr->FileBuffer) +
                    SizeOfStringA (EnumPtr->Name) >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                if (EnumPtr->Directory) {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                }

                break;
            }

            //
            // Generate the full path
            //

            StringCopyA (EnumPtr->EndOfFileBuffer, "\\");
            StringCopyA (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Name);

            if (EnumPtr->Directory) {
                if ((EnumPtr->MaxLevel == FILE_ENUM_ALL_LEVELS) ||
                    (EnumPtr->Level < EnumPtr->MaxLevel)
                    ) {
                    if (EnumPtr->EnumDepthFirst) {
                        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                    }
                    else {
                        EnumPtr->State = TREE_ENUM_PUSH;
                    }
                }
                else {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                }
            } else {
                EnumPtr->State = TREE_ENUM_FILES_NEXT;
            }

            EnumPtr->SubPath = (PCSTR) ((PBYTE) EnumPtr->FileBuffer + EnumPtr->RootPathSize);
            if (*EnumPtr->SubPath) {
                EnumPtr->SubPath++;     // advance beyond wack
            }

            return TRUE;

        case TREE_ENUM_FILES_NEXT:
            if (FindNextFileA (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return files only
                //

                if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            } else {
                if (!EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_DIRS_FILTER:
            if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else if (StringMatchA (EnumPtr->Current->FindData.cFileName, ".") ||
                StringMatchA (EnumPtr->Current->FindData.cFileName, "..")
                ) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else {

                if (EnumPtr->EnumDepthFirst) {
                    EnumPtr->State = TREE_ENUM_PUSH;
                }
                else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }

            }
            break;

        case TREE_ENUM_DIRS_BEGIN:
            //
            // Begin enumeration of directories
            //

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) + 4 >= MAX_MBCHAR_PATH) {
                LOGA ((LOG_ERROR, "Path %s\\*.* is too long", EnumPtr->Pattern));
                EnumPtr->State = TREE_ENUM_POP;
                break;
            }

            StringCopyA (EnumPtr->EndOfPattern, "\\*.*");

            EnumPtr->Current->FindHandle = FindFirstFileA (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                EnumPtr->State = TREE_ENUM_POP;
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;
            }

            break;

        case TREE_ENUM_DIRS_NEXT:
            if (FindNextFileA (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return directories only, then recurse into directory
                //

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;

            } else {
                //
                // Directory enumeration complete.
                //

                if (EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_FILES_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_PUSH:

            //
            // Limit the length of the resulting full path. The nul is
            // accounted for in SizeOfStringA, and the additional wack is
            // accounted for by using >= instead of ==.
            //

            MYASSERT (ARRAYSIZE(EnumPtr->FileBuffer) == MAX_MBCHAR_PATH);
            MYASSERT (sizeof (CHAR) == 1);      // the math is totally dependent on this

            if ((EnumPtr->EndOfFileBuffer - EnumPtr->FileBuffer) +
                    SizeOfStringA (EnumPtr->Current->FindData.cFileName) >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Current->FindData.cFileName));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) +
                    SizeOfStringA (EnumPtr->Current->FindData.cFileName) >= MAX_MBCHAR_PATH
                ) {

                LOGA ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->Current->FindData.cFileName));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            //
            // Tack on directory name to strings and recalcuate end pointers
            //

            StringCopyA (EnumPtr->EndOfPattern + 1, EnumPtr->Current->FindData.cFileName);
            StringCopyA (EnumPtr->EndOfFileBuffer, "\\");
            StringCopyA (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Current->FindData.cFileName);

            EnumPtr->EndOfPattern = GetEndOfStringA (EnumPtr->EndOfPattern);
            EnumPtr->EndOfFileBuffer = GetEndOfStringA (EnumPtr->EndOfFileBuffer);

            //
            // Allocate another find data struct
            //

            EnumPtr->Current = (PFIND_DATAA) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAA)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            EnumPtr->Level++;
            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_POP:
            //
            // Free the current resources
            //

            pTrackedFindClose (EnumPtr->Current->FindHandle);
            EnumPtr->Level--;

            //
            // Get the previous find data struct
            //

            MYASSERT (EnumPtr->FindDataArray.End >= sizeof (FIND_DATAA));
            EnumPtr->FindDataArray.End -= sizeof (FIND_DATAA);
            if (!EnumPtr->FindDataArray.End) {
                EnumPtr->State = TREE_ENUM_DONE;
                break;
            }

            EnumPtr->Current = (PFIND_DATAA) (EnumPtr->FindDataArray.Buf +
                                              (EnumPtr->FindDataArray.End - sizeof (FIND_DATAA)));

            //
            // Restore the settings of the parent directory
            //

            EnumPtr->EndOfPattern = EnumPtr->Current->SavedEndOfPattern;
            EnumPtr->EndOfFileBuffer = EnumPtr->Current->SavedEndOfFileBuffer;

            if (EnumPtr->EnumDepthFirst) {
                EnumPtr->State = TREE_ENUM_RETURN_ITEM;
            }
            else {
                EnumPtr->State = TREE_ENUM_DIRS_NEXT;
            }
            break;

        case TREE_ENUM_DONE:
            AbortEnumFileInTreeA (EnumPtr);
            SetLastError (ERROR_SUCCESS);
            return FALSE;

        case TREE_ENUM_FAILED:
            PushError();
            AbortEnumFileInTreeA (EnumPtr);
            PopError();
            return FALSE;

        case TREE_ENUM_CLEANED_UP:
            return FALSE;
        }
    }
}


BOOL
EnumNextFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    )
{
    PWSTR p;

    for (;;) {
        switch (EnumPtr->State) {

        case TREE_ENUM_INIT:

            //
            // Get rid of wack at the end of root path, if it exists
            //

            p = GetEndOfStringW (EnumPtr->RootPath);
            p = _wcsdec2 (EnumPtr->RootPath, p);
            if (!p) {
                DEBUGMSG ((DBG_ERROR, "Path spec %ls is incomplete", EnumPtr->RootPath));
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            if (*p == L'\\') {
                *p = 0;
            }

            //
            // Initialize enumeration structure
            //

            EnumPtr->FilePatternSize = SizeOfStringW (EnumPtr->FilePattern);

            MYASSERT (sizeof (EnumPtr->FileBuffer) == sizeof (EnumPtr->RootPath));
            StringCopyW (EnumPtr->FileBuffer, EnumPtr->RootPath);
            EnumPtr->EndOfFileBuffer = GetEndOfStringW (EnumPtr->FileBuffer);

            MYASSERT (sizeof (EnumPtr->Pattern) == sizeof (EnumPtr->RootPath));
            StringCopyW (EnumPtr->Pattern, EnumPtr->RootPath);
            EnumPtr->EndOfPattern = GetEndOfStringW (EnumPtr->Pattern);

            EnumPtr->FullPath = EnumPtr->FileBuffer;

            EnumPtr->RootPathSize = ByteCountW (EnumPtr->RootPath);

            //
            // Allocate first find data sturct
            //

            EnumPtr->Current = (PFIND_DATAW) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAW)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

#ifdef DEBUG
            g_FileEnumResourcesInUse++;        // account for grow buffer
#endif

            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_BEGIN:
            //
            // Initialize current find data struct
            //

            EnumPtr->Current->SavedEndOfFileBuffer = EnumPtr->EndOfFileBuffer;
            EnumPtr->Current->SavedEndOfPattern = EnumPtr->EndOfPattern;

            //
            // Limit the length of the pattern string. Calculate:
            //
            //   pattern root + wack + file pattern + nul.
            //

            MYASSERT (ARRAYSIZE(EnumPtr->FileBuffer) == (MAX_PATH * 2));

            if (((PBYTE) EnumPtr->EndOfPattern - (PBYTE) EnumPtr->Pattern) + sizeof (WCHAR) +
                    EnumPtr->FilePatternSize > (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->FilePattern));

                EnumPtr->State = TREE_ENUM_POP;

                break;
            }

            //
            // Enumerate the files or directories
            //

            if (EnumPtr->EnumDirsFirst) {
                EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
            } else {
                EnumPtr->State = TREE_ENUM_FILES_BEGIN;
            }
            break;

        case TREE_ENUM_FILES_BEGIN:
            //
            // Begin enumeration of files
            //

            // This assert is valid because of length check in TREE_ENUM_BEGIN

            MYASSERT ((TcharCountW (EnumPtr->Pattern) + 1 +
                        TcharCountW (EnumPtr->FilePattern)) < ARRAYSIZE(EnumPtr->Pattern)
                        );

            StringCopyW (EnumPtr->EndOfPattern, L"\\");
            StringCopyW (EnumPtr->EndOfPattern + 1, EnumPtr->FilePattern);

            EnumPtr->Current->FindHandle = FindFirstFileW (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                if (EnumPtr->EnumDirsFirst) {
                    EnumPtr->State = TREE_ENUM_POP;
                } else {
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                }
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif
                //
                // Skip directories
                //

                if (EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            }

            break;

        case TREE_ENUM_RETURN_ITEM:
            //
            // Update pointers to current item
            //

            EnumPtr->FindData = &EnumPtr->Current->FindData;
            EnumPtr->Name = EnumPtr->FindData->cFileName;
            EnumPtr->Directory = (EnumPtr->FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

            //
            // Limit the length of the resulting full path. Math is:
            //
            //   file root + wack + file name + nul.
            //

            if (((PBYTE) EnumPtr->EndOfFileBuffer - (PBYTE) EnumPtr->FileBuffer) + sizeof (WCHAR) +
                    SizeOfStringW (EnumPtr->Name) >= (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Name));

                if (EnumPtr->Directory) {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                } else {
                    EnumPtr->State = TREE_ENUM_FILES_NEXT;
                }

                break;
            }

            //
            // Generate the full path
            //

            StringCopyW (EnumPtr->EndOfFileBuffer, L"\\");
            StringCopyW (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Name);

            if (EnumPtr->Directory) {
                if ((EnumPtr->MaxLevel == FILE_ENUM_ALL_LEVELS) ||
                    (EnumPtr->Level < EnumPtr->MaxLevel)
                    ) {
                    if (EnumPtr->EnumDepthFirst) {
                        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                    }
                    else {
                        EnumPtr->State = TREE_ENUM_PUSH;
                    }
                }
                else {
                    EnumPtr->State = TREE_ENUM_DIRS_NEXT;
                }
            } else {
                EnumPtr->State = TREE_ENUM_FILES_NEXT;
            }

            EnumPtr->SubPath = (PCWSTR) ((PBYTE) EnumPtr->FileBuffer + EnumPtr->RootPathSize);
            if (*EnumPtr->SubPath) {
                EnumPtr->SubPath++;         // advance beyond wack
            }

            return TRUE;

        case TREE_ENUM_FILES_NEXT:
            if (FindNextFileW (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return files only
                //

                if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }
            } else {
                if (!EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_DIRS_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_DIRS_FILTER:
            if (!(EnumPtr->Current->FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else if (StringMatchW (EnumPtr->Current->FindData.cFileName, L".") ||
                       StringMatchW (EnumPtr->Current->FindData.cFileName, L"..")
                       ) {

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

            } else {

                if (EnumPtr->EnumDepthFirst) {
                    EnumPtr->State = TREE_ENUM_PUSH;
                }
                else {
                    EnumPtr->State = TREE_ENUM_RETURN_ITEM;
                }

            }
            break;

        case TREE_ENUM_DIRS_BEGIN:
            //
            // Begin enumeration of directories
            //

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) + 4 >= (MAX_PATH * 2)) {
                LOGW ((LOG_ERROR, "Path %s\\*.* is too long", EnumPtr->Pattern));
                EnumPtr->State = TREE_ENUM_POP;
                break;
            }

            StringCopyW (EnumPtr->EndOfPattern, L"\\*.*");

            EnumPtr->Current->FindHandle = FindFirstFileW (
                                                EnumPtr->Pattern,
                                                &EnumPtr->Current->FindData
                                                );

            if (EnumPtr->Current->FindHandle == INVALID_HANDLE_VALUE) {
                EnumPtr->State = TREE_ENUM_POP;
            } else {
#ifdef DEBUG
                g_FileEnumResourcesInUse++;        // account for creation of find handle
#endif

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;
            }

            break;

        case TREE_ENUM_DIRS_NEXT:
            if (FindNextFileW (EnumPtr->Current->FindHandle, &EnumPtr->Current->FindData)) {
                //
                // Return directories only, then recurse into directory
                //

                EnumPtr->State = TREE_ENUM_DIRS_FILTER;

            } else {
                //
                // Directory enumeration complete.
                //

                if (EnumPtr->EnumDirsFirst) {
                    pTrackedFindClose (EnumPtr->Current->FindHandle);
                    EnumPtr->State = TREE_ENUM_FILES_BEGIN;
                } else {
                    EnumPtr->State = TREE_ENUM_POP;
                }
            }
            break;

        case TREE_ENUM_PUSH:

            //
            // Limit the length of the resulting full path. Math is:
            //
            //   file root + wack + file name + nul.
            //

            if (((PBYTE) EnumPtr->EndOfFileBuffer - (PBYTE) EnumPtr->FileBuffer) + sizeof (WCHAR) +
                    SizeOfStringW (EnumPtr->Current->FindData.cFileName) >= (MAX_PATH * 2 * sizeof (WCHAR))
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->FileBuffer, EnumPtr->Current->FindData.cFileName));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            if ((EnumPtr->EndOfPattern - EnumPtr->Pattern) + 2 +
                    TcharCountW (EnumPtr->Current->FindData.cFileName) >= (MAX_PATH * 2)
                ) {

                LOGW ((LOG_ERROR, "Path %s\\%s is too long", EnumPtr->Pattern, EnumPtr->Current->FindData.cFileName));

                EnumPtr->State = TREE_ENUM_DIRS_NEXT;

                break;
            }

            //
            // Tack on directory name to strings and recalcuate end pointers
            //

            StringCopyW (EnumPtr->EndOfPattern + 1, EnumPtr->Current->FindData.cFileName);
            StringCopyW (EnumPtr->EndOfFileBuffer, L"\\");
            StringCopyW (EnumPtr->EndOfFileBuffer + 1, EnumPtr->Current->FindData.cFileName);

            EnumPtr->EndOfPattern = GetEndOfStringW (EnumPtr->EndOfPattern);
            EnumPtr->EndOfFileBuffer = GetEndOfStringW (EnumPtr->EndOfFileBuffer);

            //
            // Allocate another find data struct
            //

            EnumPtr->Current = (PFIND_DATAW) GrowBuffer (
                                                &EnumPtr->FindDataArray,
                                                sizeof (FIND_DATAW)
                                                );
            if (!EnumPtr->Current) {
                EnumPtr->State = TREE_ENUM_FAILED;
                break;
            }

            EnumPtr->Level++;
            EnumPtr->State = TREE_ENUM_BEGIN;
            break;

        case TREE_ENUM_POP:
            //
            // Free the current resources
            //

            pTrackedFindClose (EnumPtr->Current->FindHandle);
            EnumPtr->Level--;

            //
            // Get the previous find data struct
            //

            MYASSERT (EnumPtr->FindDataArray.End >= sizeof (FIND_DATAW));
            EnumPtr->FindDataArray.End -= sizeof (FIND_DATAW);
            if (!EnumPtr->FindDataArray.End) {
                EnumPtr->State = TREE_ENUM_DONE;
                break;
            }

            EnumPtr->Current = (PFIND_DATAW) (EnumPtr->FindDataArray.Buf +
                                              (EnumPtr->FindDataArray.End - sizeof (FIND_DATAW)));

            //
            // Restore the settings of the parent directory
            //

            EnumPtr->EndOfPattern = EnumPtr->Current->SavedEndOfPattern;
            EnumPtr->EndOfFileBuffer = EnumPtr->Current->SavedEndOfFileBuffer;

            if (EnumPtr->EnumDepthFirst) {
                EnumPtr->State = TREE_ENUM_RETURN_ITEM;
            }
            else {
                EnumPtr->State = TREE_ENUM_DIRS_NEXT;
            }
            break;

        case TREE_ENUM_DONE:
            AbortEnumFileInTreeW (EnumPtr);
            SetLastError (ERROR_SUCCESS);
            return FALSE;

        case TREE_ENUM_FAILED:
            PushError();
            AbortEnumFileInTreeW (EnumPtr);
            PopError();
            return FALSE;

        case TREE_ENUM_CLEANED_UP:
            return FALSE;
        }
    }
}


VOID
AbortEnumFileInTreeA (
    IN OUT  PTREE_ENUMA EnumPtr
    )

/*++

Routine Description:

  AbortEnumFileInTreeA cleans up all resources used by an enumeration started
  by EnumFirstFileInTree.  This routine must be called if file enumeration
  will not be completed by calling EnumNextFileInTree until it returns FALSE.

  If EnumNextFileInTree returns FALSE, it is unnecessary (but harmless) to
  call this function.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives the enumerated file
            or directory

Return Value:

  none

--*/

{
    UINT Pos;
    PGROWBUFFER g;
    PFIND_DATAA Current;

    if (EnumPtr->State == TREE_ENUM_CLEANED_UP) {
        return;
    }

    //
    // Close any currently open handles
    //

    g = &EnumPtr->FindDataArray;
    for (Pos = 0 ; Pos < g->End ; Pos += sizeof (FIND_DATAA)) {
        Current = (PFIND_DATAA) (g->Buf + Pos);
        pTrackedFindClose (Current->FindHandle);
    }

    FreeGrowBuffer (&EnumPtr->FindDataArray);

#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    EnumPtr->State = TREE_ENUM_CLEANED_UP;
}


VOID
AbortEnumFileInTreeW (
    IN OUT  PTREE_ENUMW EnumPtr
    )

/*++

Routine Description:

  AbortEnumFileInTreeW cleans up all resources used by an enumeration started
  by EnumFirstFileInTree.  This routine must be called if file enumeration
  will not be completed by calling EnumNextFileInTree until it returns FALSE.

  If EnumNextFileInTree returns FALSE, it is unnecessary (but harmless) to
  call this function.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives the enumerated file
            or directory

Return Value:

  none

--*/

{
    UINT Pos;
    PGROWBUFFER g;
    PFIND_DATAW Current;

    if (EnumPtr->State == TREE_ENUM_CLEANED_UP) {
        return;
    }

    //
    // Close any currently open handles
    //

    g = &EnumPtr->FindDataArray;
    for (Pos = 0 ; Pos < g->End ; Pos += sizeof (FIND_DATAW)) {
        Current = (PFIND_DATAW) (g->Buf + Pos);
        pTrackedFindClose (Current->FindHandle);
    }

    FreeGrowBuffer (&EnumPtr->FindDataArray);

#ifdef DEBUG
    g_FileEnumResourcesInUse--;
#endif

    EnumPtr->State = TREE_ENUM_CLEANED_UP;
}


VOID
AbortEnumCurrentDirA (
    IN OUT  PTREE_ENUMA EnumPtr
    )

/*++

Routine Description:

  AbortEnumCurrentDirA discontinues enumeration of the current subdirectory,
  continuing enumeration at its parent.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives updated state
            machine position.

Return Value:

  None.

--*/

{
    if (EnumPtr->State == TREE_ENUM_PUSH) {
        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
    }
}


VOID
AbortEnumCurrentDirW (
    IN OUT  PTREE_ENUMW EnumPtr
    )

/*++

Routine Description:

  AbortEnumCurrentDirW discontinues enumeration of the current subdirectory,
  continuing enumeration at its parent.

Arguments:

  EnumPtr - Specifies the enumeration in progress, receives updated state
            machine position.

Return Value:

  None.

--*/

{
    if (EnumPtr->State == TREE_ENUM_PUSH) {
        EnumPtr->State = TREE_ENUM_DIRS_NEXT;
    }
}


BOOL
EnumFirstFileA (
    OUT     PFILE_ENUMA EnumPtr,
    IN      PCSTR RootPath,
    IN      PCSTR FilePattern           OPTIONAL
    )

/*++

Routine Description:

  EnumFirstFileA enumerates file names/subdirectory names in a specified
  subdirectory. It does not enumerate the contents of subdirectories.

  The output is limited to paths that fit in MAX_PATH.

Arguments:

  EnumPtr - Receives the enumeration output

  RootPath - Specifies the path to enumerate

  FilePattern - Specifies the pattern of files to enumerate within RootPath

Return Value:

  TRUE if a file or subdirectory was found, FALSE otherwise.

  NOTE: There is no need to call AbortFileEnumA on return of FALSE.

--*/

{
    UINT patternTchars;

    ZeroMemory (EnumPtr, sizeof (FILE_ENUMA));

    EnumPtr->FileName = EnumPtr->fd.cFileName;
    EnumPtr->FullPath = EnumPtr->RootPath;

    if (!RootPath) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (FilePattern) {
        patternTchars = TcharCountA (FilePattern) + 1;
    } else {
        patternTchars = 4;      // number of tchars in \*.*
    }

    patternTchars += TcharCountA (RootPath);

    if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
        LOGA ((LOG_ERROR, "Enumeration path is too long: %s\\%s", RootPath, FilePattern ? FilePattern : "*.*"));
        return FALSE;
    }

    StringCopyA (EnumPtr->RootPath, RootPath);
    EnumPtr->EndOfRoot = AppendWackA (EnumPtr->RootPath);
    StringCopyA (EnumPtr->EndOfRoot, FilePattern ? FilePattern : "*.*");

    EnumPtr->Handle = FindFirstFileA (EnumPtr->RootPath, &EnumPtr->fd);

    if (EnumPtr->Handle != INVALID_HANDLE_VALUE) {

        if (StringMatchA (EnumPtr->FileName, ".") ||
            StringMatchA (EnumPtr->FileName, "..")
            ) {
            return EnumNextFileA (EnumPtr);
        }

        patternTchars = (UINT) (UINT_PTR) (EnumPtr->EndOfRoot - EnumPtr->RootPath);
        patternTchars += TcharCountA (EnumPtr->FileName);
        if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
            LOGA ((LOG_ERROR, "Enumeration item is too long: %s\\%s", EnumPtr->RootPath, EnumPtr->FileName));
            return EnumNextFileA (EnumPtr);
        }

        StringCopyA (EnumPtr->EndOfRoot, EnumPtr->FileName);
        EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        return TRUE;
    }

    return FALSE;
}


BOOL
EnumFirstFileW (
    OUT     PFILE_ENUMW EnumPtr,
    IN      PCWSTR RootPath,
    IN      PCWSTR FilePattern           OPTIONAL
    )

/*++

Routine Description:

  EnumFirstFileW enumerates file names/subdirectory names in a specified
  subdirectory. It does not enumerate the contents of subdirectories.

  The output is limited to paths that fit in MAX_PATH.

Arguments:

  EnumPtr - Receives the enumeration output

  RootPath - Specifies the path to enumerate

  FilePattern - Specifies the pattern of files to enumerate within RootPath

Return Value:

  TRUE if a file or subdirectory was found, FALSE otherwise.

  NOTE: There is no need to call AbortFileEnumW on return of FALSE.

--*/

{
    UINT patternTchars;

    ZeroMemory (EnumPtr, sizeof (FILE_ENUMW));

    EnumPtr->FileName = EnumPtr->fd.cFileName;
    EnumPtr->FullPath = EnumPtr->RootPath;

    if (!RootPath) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (FilePattern) {
        patternTchars = TcharCountW (FilePattern) + 1;
    } else {
        patternTchars = 4;      // number of tchars in \*.*
    }

    patternTchars += TcharCountW (RootPath);

    if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
        LOGW ((LOG_ERROR, "Enumeration path is too long: %s\\%s", RootPath, FilePattern ? FilePattern : L"*.*"));
        return FALSE;
    }

    StringCopyW (EnumPtr->RootPath, RootPath);
    EnumPtr->EndOfRoot = AppendWackW (EnumPtr->RootPath);
    StringCopyW (EnumPtr->EndOfRoot, FilePattern ? FilePattern : L"*.*");

    EnumPtr->Handle = FindFirstFileW (EnumPtr->RootPath, &EnumPtr->fd);

    if (EnumPtr->Handle != INVALID_HANDLE_VALUE) {

        if (StringMatchW (EnumPtr->FileName, L".") ||
            StringMatchW (EnumPtr->FileName, L"..")
            ) {
            return EnumNextFileW (EnumPtr);
        }

        patternTchars = (UINT) (UINT_PTR) (EnumPtr->EndOfRoot - EnumPtr->RootPath);
        patternTchars += TcharCountW (EnumPtr->FileName);
        if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
            LOGW ((LOG_ERROR, "Enumeration item is too long: %s\\%s", EnumPtr->RootPath, EnumPtr->FileName));
            return EnumNextFileW (EnumPtr);
        }

        StringCopyW (EnumPtr->EndOfRoot, EnumPtr->FileName);
        EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
        return TRUE;
    }

    return FALSE;
}


BOOL
EnumNextFileA (
    IN OUT  PFILE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextFileA continues enumeration of file names/subdirectory names in a
  specified subdirectory. It does not enumerate the contents of
  subdirectories.

  The output is limited to paths that fit in MAX_PATH.

Arguments:

  EnumPtr - Specifies the previous enumeration state, receives the enumeration
            output

Return Value:

  TRUE if a file or subdirectory was found, FALSE otherwise.

  NOTE: There is no need to call AbortFileEnumA on return of FALSE.

--*/

{
    UINT patternTchars;

    do {
        if (!FindNextFileA (EnumPtr->Handle, &EnumPtr->fd)) {
            AbortFileEnumA (EnumPtr);
            return FALSE;
        }

        patternTchars = (UINT) (UINT_PTR) (EnumPtr->EndOfRoot - EnumPtr->RootPath);
        patternTchars += TcharCountA (EnumPtr->FileName);
        if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
            LOGA ((LOG_ERROR, "Enumeration path is too long: %s\\%s", EnumPtr->RootPath, EnumPtr->FileName));
            continue;
        }

    } while (StringMatchA (EnumPtr->FileName, ".") ||
             StringMatchA (EnumPtr->FileName, "..")
             );

    StringCopyA (EnumPtr->EndOfRoot, EnumPtr->FileName);
    EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    return TRUE;
}


BOOL
EnumNextFileW (
    IN OUT  PFILE_ENUMW EnumPtr
    )

/*++

Routine Description:

  EnumNextFileW continues enumeration of file names/subdirectory names in a
  specified subdirectory. It does not enumerate the contents of
  subdirectories.

  The output is limited to paths that fit in MAX_PATH.

Arguments:

  EnumPtr - Specifies the previous enumeration state, receives the enumeration
            output

Return Value:

  TRUE if a file or subdirectory was found, FALSE otherwise.

  NOTE: There is no need to call AbortFileEnumW on return of FALSE.

--*/

{
    UINT patternTchars;

    do {
        if (!FindNextFileW (EnumPtr->Handle, &EnumPtr->fd)) {
            AbortFileEnumW (EnumPtr);
            return FALSE;
        }

        patternTchars = (UINT) (UINT_PTR) (EnumPtr->EndOfRoot - EnumPtr->RootPath);
        patternTchars += TcharCountW (EnumPtr->FileName);
        if (patternTchars >= ARRAYSIZE (EnumPtr->RootPath)) {
            LOGW ((LOG_ERROR, "Enumeration path is too long: %s\\%s", EnumPtr->RootPath, EnumPtr->FileName));
            continue;
        }

    } while (StringMatchW (EnumPtr->FileName, L".") ||
             StringMatchW (EnumPtr->FileName, L"..")
             );

    if (!FindNextFileW (EnumPtr->Handle, &EnumPtr->fd)) {
        AbortFileEnumW (EnumPtr);
        return FALSE;
    }

    StringCopyW (EnumPtr->EndOfRoot, EnumPtr->FileName);
    EnumPtr->Directory = EnumPtr->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
    return TRUE;
}


VOID
AbortFileEnumA (
    IN OUT  PFILE_ENUMA EnumPtr
    )

/*++

Routine Description:

  AbortFileEnumA stops an incomplete enumeration and cleans up its resources.
  This function is intended for the case in which some but not all of the
  matches are enumerated. In other words, enumerations of all items do not
  need to be aborted.

Arguments:

  EnumPtr - Specifies the previous enumeration state, receives a zeroed struct

Return Value:

  None.

--*/

{
    if (EnumPtr->Handle && EnumPtr->Handle != INVALID_HANDLE_VALUE) {
        FindClose (EnumPtr->Handle);
        ZeroMemory (EnumPtr, sizeof (FILE_ENUMA));
    }
}


VOID
AbortFileEnumW (
    IN OUT  PFILE_ENUMW EnumPtr
    )

/*++

Routine Description:

  AbortFileEnumW stops an incomplete enumeration and cleans up its resources.
  This function is intended for the case in which some but not all of the
  matches are enumerated. In other words, enumerations of all items do not
  need to be aborted.

Arguments:

  EnumPtr - Specifies the previous enumeration state, receives a zeroed struct

Return Value:

  None.

--*/

{
    if (EnumPtr->Handle && EnumPtr->Handle != INVALID_HANDLE_VALUE) {
        FindClose (EnumPtr->Handle);
        ZeroMemory (EnumPtr, sizeof (FILE_ENUMW));
    }
}


PVOID
MapFileIntoMemoryExA (
    IN      PCSTR FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryA maps a file into memory. It does that by opening the
  file, creating a mapping object and mapping opened file into created mapping
  object. It returns the address where the file is mapped and also sets
  FileHandle and MapHandle variables to be used in order to unmap the file
  when work is done.

Arguments:

  FileName - Specifies the name of the file to be mapped into memory

  FileHandle - Receives the file handle on success

  MapHandle - Receives the map handle on success

  WriteAccess - Specifies TRUE to create a read/write mapping, or FALSE to
                create a read-only mapping.

Return Value:

  NULL if function fails, a valid memory address if successful.

  Call UnmapFile to release all allocated resources, even if the return value
  is NULL.

--*/

{
    PVOID fileImage = NULL;

    //
    // verify function parameters
    //

    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //
    // Try to open the file
    //

    *FileHandle = CreateFileA (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //
    // now try to create a mapping object
    //

    *MapHandle = CreateFileMappingA (
                        *FileHandle,
                        NULL,
                        WriteAccess?PAGE_READWRITE:PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if (*MapHandle == NULL) {
        return NULL;
    }

    //
    // map view of file
    //

    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


PVOID
MapFileIntoMemoryExW (
    IN      PCWSTR FileName,
    OUT     PHANDLE FileHandle,
    OUT     PHANDLE MapHandle,
    IN      BOOL WriteAccess
    )

/*++

Routine Description:

  MapFileIntoMemoryW maps a file into memory. It does that by opening the
  file, creating a mapping object and mapping opened file into created mapping
  object. It returns the address where the file is mapped and also sets
  FileHandle and MapHandle variables to be used in order to unmap the file
  when work is done.

Arguments:

  FileName - Specifies the name of the file to be mapped into memory

  FileHandle - Receives the file handle on success

  MapHandle - Receives the map handle on success

  WriteAccess - Specifies TRUE to create a read/write mapping, or FALSE to
                create a read-only mapping.

Return Value:

  NULL if function fails, a valid memory address if successful.

  Call UnmapFile to release all allocated resources, even if the return value
  is NULL.

--*/

{
    PVOID fileImage = NULL;

    //
    // verify function parameters
    //

    if ((FileHandle == NULL) || (MapHandle == NULL)) {
        return NULL;
    }

    //
    // Try to open the file, read-only
    //

    *FileHandle = CreateFileW (
                        FileName,
                        WriteAccess?GENERIC_READ|GENERIC_WRITE:GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if (*FileHandle == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    //
    // now try to create a mapping object
    //

    *MapHandle = CreateFileMappingW (
                    *FileHandle,
                    NULL,
                    WriteAccess ? PAGE_READWRITE : PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

    if (*MapHandle == NULL) {
        return NULL;
    }

    //
    // map view of file
    //

    fileImage = MapViewOfFile (*MapHandle, WriteAccess?FILE_MAP_WRITE:FILE_MAP_READ, 0, 0, 0);

    return fileImage;
}


BOOL
UnmapFile (
    IN      PVOID FileImage,            OPTIONAL
    IN      HANDLE MapHandle,           OPTIONAL
    IN      HANDLE FileHandle           OPTIONAL
    )

/*++

Routine Description:

  UnmapFile is used to release all resources allocated by MapFileIntoMemory.

Arguments:

  FileImage - Specifies the image of the mapped file as returned by
              MapFileIntoMemoryExA/W

  MapHandle - Specifies the handle of the mapping object as returned by
              MapFileIntoMemoryExA/W

  FileHandle - Specifies the handle of the file as returned by
               MapFileIntoMemoryExA/W

Return Value:

  TRUE if successful, FALSE if not

--*/

{
    BOOL result = TRUE;

    //
    // if FileImage is a valid pointer then try to unmap file
    //

    if (FileImage != NULL) {
        if (UnmapViewOfFile (FileImage) == 0) {
            result = FALSE;
        }
    }

    //
    // if mapping object is valid then try to delete it
    //

    if (MapHandle != NULL) {
        if (CloseHandle (MapHandle) == 0) {
            result = FALSE;
        }
    }

    //
    // if file handle is valid then try to close the file
    //

    if (FileHandle && FileHandle != INVALID_HANDLE_VALUE) {
        if (CloseHandle (FileHandle) == 0) {
            result = FALSE;
        }
    }

    return result;
}


BOOL
RemoveCompleteDirectoryA (
    IN      PCSTR Dir
    )

/*++

Routine Description:

  RemoveCompleteDirectoryA enumerates the file system and obliterates all
  files and subdirectories within the specified path. It resets file
  attributes to normal prior to deleting. It does not change ACLs however.

  Any files that cannot be deleted (e.g., ACLs are different) are left on the
  system unchanged.

  This function is limited to MAX_PATH.

Arguments:

  Dir - Specifies the directory to remove.

Return Value:

  TRUE on complete removal of the directory, FALSE if at least one
  subdirectory still remains. GetLastError() returns the error code of the
  first failure encountered.

--*/

{
    TREE_ENUMA e;
    BOOL b = TRUE;
    CHAR CurDir[MAX_MBCHAR_PATH];
    CHAR NewDir[MAX_MBCHAR_PATH];
    LONG rc = ERROR_SUCCESS;
    DWORD Attribs;

    //
    // Validate
    //

    if (!IsPathLengthOkA (Dir)) {
        LOGA ((LOG_ERROR, "Can't remove very long dir: %s", Dir));
        return FALSE;
    }

    //
    // Capture attributes and check for existence
    //

    Attribs = GetFileAttributesA (Dir);

    if (Attribs == INVALID_ATTRIBUTES) {
        return TRUE;
    }

    //
    // If it's a file, delete it
    //

    if (!(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
        SetFileAttributesA (Dir, FILE_ATTRIBUTE_NORMAL);
        return DeleteFileA (Dir);
    }

    //
    // Set the current directory to the specified path, so the current dir is
    // not keeping us from removing the dir. Then get the current directory in
    // NewDir (to sanitize it).
    //

    GetCurrentDirectoryA (ARRAYSIZE(CurDir), CurDir);
    SetCurrentDirectoryA (Dir);
    GetCurrentDirectoryA (ARRAYSIZE(NewDir), NewDir);

    //
    // Enumerate the file system and delete all the files. Record failures
    // along the way in the log. Keep the first error code.
    //

    if (EnumFirstFileInTreeA (&e, NewDir, NULL, FALSE)) {
        do {
            if (!e.Directory) {
                SetFileAttributesA (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteFileA (e.FullPath)) {
                    DEBUGMSGA ((DBG_ERROR, "Can't delete %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeA (&e));
    }

    //
    // Enumerate the file system again (dirs first this time) and delete the
    // dirs. Record failures along the way. Keep the first error code.
    //

    if (EnumFirstFileInTreeExA (&e, NewDir, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {
        do {
            if (e.Directory) {
                SetFileAttributesA (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!RemoveDirectoryA (e.FullPath)) {
                    DEBUGMSGA ((DBG_ERROR, "Can't remove %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeA (&e));
    }

    if (b) {
        //
        // Try to remove the directory itself
        //

        SetFileAttributesA (NewDir, FILE_ATTRIBUTE_NORMAL);
        SetCurrentDirectoryA ("..");
        b = RemoveDirectoryA (NewDir);
    }

    if (!b && rc == ERROR_SUCCESS) {
        //
        // Capture the error
        //

        rc = GetLastError();
        MYASSERT (rc != ERROR_SUCCESS);
    }

    SetCurrentDirectoryA (CurDir);

    SetLastError (rc);
    return b;
}


BOOL
RemoveCompleteDirectoryW (
    IN      PCWSTR Dir
    )

/*++

Routine Description:

  RemoveCompleteDirectoryW enumerates the file system and obliterates all
  files and subdirectories within the specified path. It resets file
  attributes to normal prior to deleting. It does not change ACLs however.

  Any files that cannot be deleted (e.g., ACLs are different) are left on the
  system unchanged.

  This function is limited to MAX_PATH * 2.

Arguments:

  Dir - Specifies the directory to remove.

Return Value:

  TRUE on complete removal of the directory, FALSE if at least one
  subdirectory still remains. GetLastError() returns the error code of the
  first failure encountered.

--*/

{
    TREE_ENUMW e;
    BOOL b = TRUE;
    WCHAR CurDir[MAX_PATH * 2];
    WCHAR NewDir[MAX_PATH * 2];
    LONG rc = ERROR_SUCCESS;
    DWORD Attribs;

    //
    // Capture attributes and check for existence
    //

    Attribs = GetLongPathAttributesW (Dir);

    if (Attribs == INVALID_ATTRIBUTES) {
        return TRUE;
    }

    //
    // If path is a file, delete the file
    //

    if (!(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
        SetLongPathAttributesW (Dir, FILE_ATTRIBUTE_NORMAL);
        return DeleteLongPathW (Dir);
    }

    //
    // Move the current directory outside of the path, to keep us from failing
    // the delete because our own current dir is in the path. Fetch the
    // sanitized path.
    //

    // BUGBUG - Does this behave properly with extended (e.g., \\?\) paths?

    GetCurrentDirectoryW (ARRAYSIZE(CurDir), CurDir);
    SetCurrentDirectoryW (Dir);
    GetCurrentDirectoryW (ARRAYSIZE(NewDir), NewDir);

    //
    // Enumerate the file system again (dirs first this time) and delete the
    // dirs. Record failures along the way. Keep the first error code.
    //
    // CAUTION: Enum is limited to MAX_PATH * 2
    //

    MYASSERT (ARRAYSIZE(e.FileBuffer) >= MAX_PATH * 2);

    if (EnumFirstFileInTreeW (&e, NewDir, NULL, FALSE)) {
        do {
            if (!e.Directory) {
                SetLongPathAttributesW (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!DeleteLongPathW (e.FullPath)) {
                    DEBUGMSGW ((DBG_ERROR, "Can't delete %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeW (&e));
    }

    //
    // Enumerate the file system again (dirs first this time) and delete the
    // dirs. Record failures along the way. Keep the first error code.
    //

    if (EnumFirstFileInTreeExW (&e, NewDir, NULL, TRUE, TRUE, FILE_ENUM_ALL_LEVELS)) {
        do {
            if (e.Directory) {
                SetLongPathAttributesW (e.FullPath, FILE_ATTRIBUTE_NORMAL);
                if (!RemoveDirectoryW (e.FullPath)) {
                    DEBUGMSGW ((DBG_ERROR, "Can't remove %s", e.FullPath));
                    if (b) {
                        b = FALSE;
                        rc = GetLastError();
                    }
                }
            }
        } while (EnumNextFileInTreeW (&e));
    }

    if (b) {
        //
        // Try to remove the directory itself
        //

        SetLongPathAttributesW (NewDir, FILE_ATTRIBUTE_NORMAL);
        SetCurrentDirectoryW (L"..");
        b = RemoveDirectoryW (NewDir);
    }

    if (!b && rc == ERROR_SUCCESS) {
        //
        // Capture the error
        //

        rc = GetLastError();
    }

    SetCurrentDirectoryW (CurDir);

    SetLastError (rc);
    return b;
}


PCMDLINEA
ParseCmdLineA (
    IN      PCSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    )
{
    GROWBUFFER SpacePtrs = GROWBUF_INIT;
    PCSTR p;
    PSTR q;
    INT Count;
    INT i;
    INT j;
    PSTR *Array;
    PCSTR Start;
    CHAR OldChar = 0;
    GROWBUFFER StringBuf = GROWBUF_INIT;
    PBYTE CopyBuf;
    PCMDLINEA CmdLineTable;
    PCMDLINEARGA CmdLineArg;
    UINT_PTR Base;
    CHAR Path[MAX_MBCHAR_PATH];
    CHAR UnquotedPath[MAX_MBCHAR_PATH];
    CHAR FixedFileName[MAX_MBCHAR_PATH];
    PCSTR FullPath = NULL;
    DWORD Attribs = INVALID_ATTRIBUTES;
    PSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PSTR DontCare;
    CHAR FirstArgPath[MAX_MBCHAR_PATH];
    PSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PSTR End;

    CmdLineCopy = DuplicateTextA (CmdLine);

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p = _mbsinc (p)) {

        if (_mbsnextc (p) == '\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode && (_mbsnextc (p) == ' ' || _mbsnextc (p) == '=')) {

            //
            // Remove excess spaces
            //

            q = (PSTR) p + 1;
            while (_mbsnextc (q) == ' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (CHAR), q, SizeOfStringA (q));
            }

            GrowBufAppendUintPtr (&SpacePtrs, (UINT_PTR) p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEA) GrowBuffer (Buffer, sizeof (CMDLINEA));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCSTR) (UINT_PTR) StringBuf.End;
    MultiSzAppendA (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (UINT_PTR);
    Array = (PSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (_mbsnextc (Start) != '/') {

            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (_mbsnextc (Start) == '\"') {

                    StringCopyByteCountA (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                    q = _mbschr (UnquotedPath, '\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    Attribs = GetFileAttributesA (FullPath);

                    if (Attribs == INVALID_ATTRIBUTES && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountA (
                            EndOfFirstArg,
                            FullPath,
                            sizeof (FirstArgPath) - ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        Attribs = GetFileAttributesA (FullPath);
                    }

                    if (Attribs == INVALID_ATTRIBUTES && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountA (
                            FixedFileName,
                            FullPath,
                            sizeof (FixedFileName) - sizeof (".exe")        // includes nul in subtraction
                            );

                        //
                        // Back up one to make sure we don't generate foo..exe
                        //

                        q = GetEndOfStringA (FixedFileName);
                        q = _mbsdec (FixedFileName, q);
                        MYASSERT (q);                                       // we know FullPath != ""

                        if (_mbsnextc (q) != '.') {
                            q = _mbsinc (q);
                        }

                        StringCopyA (q, ".exe");

                        FullPath = FixedFileName;
                        Attribs = GetFileAttributesA (FullPath);
                    }

                    if (Attribs != INVALID_ATTRIBUTES) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        MultiSzAppendA (&StringBuf, Start);

                        if (!StringMatchA (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            MultiSzAppendA (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (_mbschr (Start, '\\')) {
#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGA ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // SearchPath.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (_mbsnextc (Start) == '\"') {

                            StringCopyByteCountA (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                            q = _mbschr (UnquotedPath, '\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (SearchPathA (
                                    NULL,
                                    FullPath,
                                    NULL,
                                    sizeof (Path) / sizeof (Path[0]),
                                    Path,
                                    &DontCare
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountA (
                                    FixedFileName,
                                    FullPath,
                                    sizeof (FixedFileName) - sizeof (".exe")        // includes nul in subtraction
                                    );

                                //
                                // Back up one and check for dot, to prevent
                                // "foo..exe" when input is "foo."
                                //

                                q = GetEndOfStringA (FixedFileName);
                                q = _mbsdec (FixedFileName, q);
                                MYASSERT (q);

                                if (_mbsnextc (q) != '.') {
                                    q = _mbsinc (q);
                                }

                                StringCopyA (q, ".exe");

                                if (SearchPathA (
                                        NULL,
                                        FixedFileName,
                                        NULL,
                                        sizeof (Path) / sizeof (Path[0]),
                                        Path,
                                        &DontCare
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }

                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            Attribs = GetFileAttributesA (FullPath);
                            MYASSERT (Attribs != INVALID_ATTRIBUTES);

                            OriginalArgOffset = StringBuf.End;
                            MultiSzAppendA (&StringBuf, Start);

                            if (!StringMatchA (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                MultiSzAppendA (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGA) GrowBuffer (Buffer, sizeof (CMDLINEARGA));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its attributes
            // are in Attribs, and it has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCSTR) (UINT_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCSTR) (UINT_PTR) CleanedUpArgOffset;
            CmdLineArg->Attributes = Attribs;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountA (
                    FirstArgPath,
                    (PCSTR) (StringBuf.Buf + (UINT_PTR) CmdLineArg->CleanedUpArg),
                    sizeof (FirstArgPath) - sizeof (CHAR)                       // account for AppendWack
                    );

                q = (PSTR) GetFileNameFromPathA (FirstArgPath);
                if (q) {
                    q = _mbsdec (FirstArgPath, q);
                    if (q) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackA (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCSTR) (UINT_PTR) StringBuf.End;
                MultiSzAppendA (&StringBuf, Start);

                Quoted = FALSE;

                if (_mbschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PSTR) ((PBYTE) UnquotedPath + sizeof (UnquotedPath) - sizeof (CHAR));

                    while (*p && q < End) {
                        if (IsLeadByte (p)) {
                            *q++ = *p++;
                            *q++ = *p++;
                        } else {
                            if (*p == '\"') {
                                p++;
                            } else {
                                *q++ = *p++;
                            }
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCSTR) (UINT_PTR) StringBuf.End;
                    MultiSzAppendA (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Attributes = INVALID_ATTRIBUTES;
                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GrowBuffer (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (UINT_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    CmdLineTable->CmdLine = (PCSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    FreeGrowBuffer (&StringBuf);
    FreeGrowBuffer (&SpacePtrs);

    return (PCMDLINEA) Buffer->Buf;
}


PCMDLINEW
ParseCmdLineW (
    IN      PCWSTR CmdLine,
    IN OUT  PGROWBUFFER Buffer
    )
{
    GROWBUFFER SpacePtrs = GROWBUF_INIT;
    PCWSTR p;
    PWSTR q;
    INT Count;
    INT i;
    INT j;
    PWSTR *Array;
    PCWSTR Start;
    WCHAR OldChar = 0;
    GROWBUFFER StringBuf = GROWBUF_INIT;
    PBYTE CopyBuf;
    PCMDLINEW CmdLineTable;
    PCMDLINEARGW CmdLineArg;
    UINT_PTR Base;
    WCHAR Path[MAX_WCHAR_PATH];
    WCHAR UnquotedPath[MAX_WCHAR_PATH];
    WCHAR FixedFileName[MAX_WCHAR_PATH];
    PCWSTR FullPath = NULL;
    DWORD Attribs = INVALID_ATTRIBUTES;
    PWSTR CmdLineCopy;
    BOOL Quoted;
    UINT OriginalArgOffset = 0;
    UINT CleanedUpArgOffset = 0;
    BOOL GoodFileFound = FALSE;
    PWSTR DontCare;
    WCHAR FirstArgPath[MAX_MBCHAR_PATH];
    PWSTR EndOfFirstArg;
    BOOL QuoteMode = FALSE;
    PWSTR End;

    CmdLineCopy = DuplicateTextW (CmdLine);

    //
    // Build an array of places to break the string
    //

    for (p = CmdLineCopy ; *p ; p++) {
        if (*p == L'\"') {

            QuoteMode = !QuoteMode;

        } else if (!QuoteMode && (*p == L' ' || *p == L'=')) {

            //
            // Remove excess spaces
            //

            q = (PWSTR) p + 1;
            while (*q == L' ') {
                q++;
            }

            if (q > p + 1) {
                MoveMemory ((PBYTE) p + sizeof (WCHAR), q, SizeOfStringW (q));
            }

            GrowBufAppendUintPtr (&SpacePtrs, (UINT_PTR) p);
        }
    }

    //
    // Prepare the CMDLINE struct
    //

    CmdLineTable = (PCMDLINEW) GrowBuffer (Buffer, sizeof (CMDLINEW));
    MYASSERT (CmdLineTable);

    //
    // NOTE: We store string offsets, then at the end resolve them
    //       to pointers later.
    //

    CmdLineTable->CmdLine = (PCWSTR) (UINT_PTR) StringBuf.End;
    MultiSzAppendW (&StringBuf, CmdLine);

    CmdLineTable->ArgCount = 0;

    //
    // Now test every combination, emulating CreateProcess
    //

    Count = SpacePtrs.End / sizeof (UINT_PTR);
    Array = (PWSTR *) SpacePtrs.Buf;

    i = -1;
    EndOfFirstArg = NULL;

    while (i < Count) {

        GoodFileFound = FALSE;
        Quoted = FALSE;

        if (i >= 0) {
            Start = Array[i] + 1;
        } else {
            Start = CmdLineCopy;
        }

        //
        // Check for a full path at Start
        //

        if (*Start != L'/') {
            for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                FullPath = Start;

                //
                // Remove quotes; continue in the loop if it has no terminating quotes
                //

                Quoted = FALSE;
                if (*Start == L'\"') {

                    StringCopyByteCountW (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                    q = wcschr (UnquotedPath, L'\"');

                    if (q) {
                        *q = 0;
                        FullPath = UnquotedPath;
                        Quoted = TRUE;
                    } else {
                        FullPath = NULL;
                    }
                }

                if (FullPath && *FullPath) {
                    //
                    // Look in file system for the path
                    //

                    Attribs = GetLongPathAttributesW (FullPath);

                    if (Attribs == INVALID_ATTRIBUTES && EndOfFirstArg) {
                        //
                        // Try prefixing the path with the first arg's path.
                        //

                        StringCopyByteCountW (
                            EndOfFirstArg,
                            FullPath,
                            sizeof (FirstArgPath) - ((PBYTE) EndOfFirstArg - (PBYTE) FirstArgPath)
                            );

                        FullPath = FirstArgPath;
                        Attribs = GetLongPathAttributesW (FullPath);
                    }

                    if (Attribs == INVALID_ATTRIBUTES && i < 0) {
                        //
                        // Try appending .exe, then testing again.  This
                        // emulates what CreateProcess does.
                        //

                        StringCopyByteCountW (
                            FixedFileName,
                            FullPath,
                            sizeof (FixedFileName) - sizeof (L".exe")       // includes nul in subtraction
                            );

                        //
                        // Back up one and overwrite any trailing dot
                        //

                        q = GetEndOfStringW (FixedFileName);
                        q--;
                        MYASSERT (q >= FixedFileName);

                        if (*q != L'.') {
                            q++;
                        }

                        StringCopyW (q, L".exe");

                        FullPath = FixedFileName;
                        Attribs = GetLongPathAttributesW (FullPath);
                    }

                    if (Attribs != INVALID_ATTRIBUTES) {
                        //
                        // Full file path found.  Test its file status, then
                        // move on if there are no important operations on it.
                        //

                        OriginalArgOffset = StringBuf.End;
                        MultiSzAppendW (&StringBuf, Start);

                        if (!StringMatchW (Start, FullPath)) {
                            CleanedUpArgOffset = StringBuf.End;
                            MultiSzAppendW (&StringBuf, FullPath);
                        } else {
                            CleanedUpArgOffset = OriginalArgOffset;
                        }

                        i = j;
                        GoodFileFound = TRUE;
                    }
                }

                if (j < Count) {
                    *Array[j] = OldChar;
                }
            }

            if (!GoodFileFound) {
                //
                // If a wack is in the path, then we could have a relative path, an arg, or
                // a full path to a non-existent file.
                //

                if (wcschr (Start, L'\\')) {

#ifdef DEBUG
                    j = i + 1;

                    if (j < Count) {
                        OldChar = *Array[j];
                        *Array[j] = 0;
                    }

                    DEBUGMSGW ((
                        DBG_VERBOSE,
                        "%s is a non-existent path spec, a relative path, or an arg",
                        Start
                        ));

                    if (j < Count) {
                        *Array[j] = OldChar;
                    }
#endif

                } else {
                    //
                    // The string at Start did not contain a full path; try using
                    // SearchPath.
                    //

                    for (j = i + 1 ; j <= Count && !GoodFileFound ; j++) {

                        if (j < Count) {
                            OldChar = *Array[j];
                            *Array[j] = 0;
                        }

                        FullPath = Start;

                        //
                        // Remove quotes; continue in the loop if it has no terminating quotes
                        //

                        Quoted = FALSE;
                        if (*Start == L'\"') {

                            StringCopyByteCountW (UnquotedPath, Start + 1, sizeof (UnquotedPath));
                            q = wcschr (UnquotedPath, L'\"');

                            if (q) {
                                *q = 0;
                                FullPath = UnquotedPath;
                                Quoted = TRUE;
                            } else {
                                FullPath = NULL;
                            }
                        }

                        if (FullPath && *FullPath) {
                            if (SearchPathW (
                                    NULL,
                                    FullPath,
                                    NULL,
                                    sizeof (Path) / sizeof (Path[0]),
                                    Path,
                                    &DontCare
                                    )) {

                                FullPath = Path;

                            } else if (i < 0) {
                                //
                                // Try appending .exe and searching the path again
                                //

                                StringCopyByteCountW (
                                    FixedFileName,
                                    FullPath,
                                    sizeof (FixedFileName) - sizeof (L".exe")       // includes nul in subtraction
                                    );

                                //
                                // Back up one and overwrite any trailing dot
                                //

                                q = GetEndOfStringW (FixedFileName);
                                q--;
                                MYASSERT (q >= FixedFileName);

                                if (*q != L'.') {
                                    q++;
                                }

                                StringCopyW (q, L".exe");

                                if (SearchPathW (
                                        NULL,
                                        FixedFileName,
                                        NULL,
                                        sizeof (Path) / sizeof (Path[0]),
                                        Path,
                                        &DontCare
                                        )) {

                                    FullPath = Path;

                                } else {

                                    FullPath = NULL;

                                }
                            } else {

                                FullPath = NULL;

                            }
                        }

                        if (FullPath && *FullPath) {
                            Attribs = GetLongPathAttributesW (FullPath);
                            MYASSERT (Attribs != INVALID_ATTRIBUTES);

                            OriginalArgOffset = StringBuf.End;
                            MultiSzAppendW (&StringBuf, Start);

                            if (!StringMatchW (Start, FullPath)) {
                                CleanedUpArgOffset = StringBuf.End;
                                MultiSzAppendW (&StringBuf, FullPath);
                            } else {
                                CleanedUpArgOffset = OriginalArgOffset;
                            }

                            i = j;
                            GoodFileFound = TRUE;
                        }

                        if (j < Count) {
                            *Array[j] = OldChar;
                        }
                    }
                }
            }
        }

        CmdLineTable->ArgCount += 1;
        CmdLineArg = (PCMDLINEARGW) GrowBuffer (Buffer, sizeof (CMDLINEARGW));
        MYASSERT (CmdLineArg);

        if (GoodFileFound) {
            //
            // We have a good full file spec in FullPath, its attributes
            // are in Attribs, and i has been moved to the space beyond
            // the path.  We now add a table entry.
            //

            CmdLineArg->OriginalArg = (PCWSTR) (UINT_PTR) OriginalArgOffset;
            CmdLineArg->CleanedUpArg = (PCWSTR) (UINT_PTR) CleanedUpArgOffset;
            CmdLineArg->Attributes = Attribs;
            CmdLineArg->Quoted = Quoted;

            if (!EndOfFirstArg) {
                StringCopyByteCountW (
                    FirstArgPath,
                    (PCWSTR) (StringBuf.Buf + (UINT_PTR) CmdLineArg->CleanedUpArg),
                    sizeof (FirstArgPath) - sizeof (WCHAR)      // account for AppendWack
                    );
                q = (PWSTR) GetFileNameFromPathW (FirstArgPath);
                if (q) {
                    q--;
                    if (q >= FirstArgPath) {
                        *q = 0;
                    }
                }

                EndOfFirstArg = AppendWackW (FirstArgPath);
            }

        } else {
            //
            // We do not have a good file spec; we must have a non-file
            // argument.  Put it in the table, and advance to the next
            // arg.
            //

            j = i + 1;
            if (j <= Count) {

                if (j < Count) {
                    OldChar = *Array[j];
                    *Array[j] = 0;
                }

                CmdLineArg->OriginalArg = (PCWSTR) (UINT_PTR) StringBuf.End;
                MultiSzAppendW (&StringBuf, Start);

                Quoted = FALSE;
                if (wcschr (Start, '\"')) {

                    p = Start;
                    q = UnquotedPath;
                    End = (PWSTR) ((PBYTE) UnquotedPath + sizeof (UnquotedPath) - sizeof (WCHAR));

                    while (*p && q < End) {
                        if (*p == L'\"') {
                            p++;
                        } else {
                            *q++ = *p++;
                        }
                    }

                    *q = 0;

                    CmdLineArg->CleanedUpArg = (PCWSTR) (UINT_PTR) StringBuf.End;
                    MultiSzAppendW (&StringBuf, UnquotedPath);
                    Quoted = TRUE;

                } else {
                    CmdLineArg->CleanedUpArg = CmdLineArg->OriginalArg;
                }

                CmdLineArg->Attributes = INVALID_ATTRIBUTES;
                CmdLineArg->Quoted = Quoted;

                if (j < Count) {
                    *Array[j] = OldChar;
                }

                i = j;
            }
        }
    }

    //
    // We now have a command line table; transfer StringBuf to Buffer, then
    // convert all offsets into pointers.
    //

    MYASSERT (StringBuf.End);

    CopyBuf = GrowBuffer (Buffer, StringBuf.End);
    MYASSERT (CopyBuf);

    Base = (UINT_PTR) CopyBuf;
    CopyMemory (CopyBuf, StringBuf.Buf, StringBuf.End);

    CmdLineTable->CmdLine = (PCWSTR) ((PBYTE) CmdLineTable->CmdLine + Base);

    CmdLineArg = &CmdLineTable->Args[0];

    for (i = 0 ; i < (INT) CmdLineTable->ArgCount ; i++) {
        CmdLineArg->OriginalArg = (PCWSTR) ((PBYTE) CmdLineArg->OriginalArg + Base);
        CmdLineArg->CleanedUpArg = (PCWSTR) ((PBYTE) CmdLineArg->CleanedUpArg + Base);

        CmdLineArg++;
    }

    FreeGrowBuffer (&StringBuf);
    FreeGrowBuffer (&SpacePtrs);

    return (PCMDLINEW) Buffer->Buf;
}


BOOL
GetFileSizeFromFilePathA(
    IN  PCSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    )
{
    WIN32_FILE_ATTRIBUTE_DATA fileDataAttributes;

    if(!FilePath || !FileSize){
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!IsPathOnFixedDriveA (FilePath)) {
        FileSize->QuadPart = 0;
        MYASSERT(FALSE);
        return FALSE;
    }

    if(!GetFileAttributesExA(FilePath, GetFileExInfoStandard, &fileDataAttributes) ||
       fileDataAttributes.dwFileAttributes == INVALID_ATTRIBUTES ||
       (fileDataAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
        MYASSERT(FALSE);
        return FALSE;
    }

    FileSize->LowPart = fileDataAttributes.nFileSizeLow;
    FileSize->HighPart = fileDataAttributes.nFileSizeHigh;

    return TRUE;
}


BOOL
GetFileSizeFromFilePathW(
    IN  PCWSTR FilePath,
    OUT ULARGE_INTEGER * FileSize
    )
{
    WIN32_FILE_ATTRIBUTE_DATA fileDataAttributes;

    if(!FilePath || !FileSize){
        MYASSERT(FALSE);
        return FALSE;
    }

    if (!IsPathOnFixedDriveW (FilePath)) {
        FileSize->QuadPart = 0;
        MYASSERT(FALSE);
        return FALSE;
    }

    if(!GetFileAttributesExW(FilePath, GetFileExInfoStandard, &fileDataAttributes) ||
       fileDataAttributes.dwFileAttributes == INVALID_ATTRIBUTES ||
       (fileDataAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){
        MYASSERT(FALSE);
        return FALSE;
    }

    FileSize->LowPart = fileDataAttributes.nFileSizeLow;
    FileSize->HighPart = fileDataAttributes.nFileSizeHigh;

    return TRUE;
}


VOID
InitializeDriveLetterStructureA (
    OUT     PDRIVELETTERSA DriveLetters
    )
{
    BYTE bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    CHAR rootPath[] = "?:\\";
    BOOL driveExists;
    UINT type;

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize this drive
        //

        DriveLetters->ExistsOnSystem[bitPosition] = FALSE;
        DriveLetters->Type[bitPosition] = 0;
        DriveLetters->IdentifierString[bitPosition][0] = 0;

        rootPath[0] = 'A' + bitPosition;
        DriveLetters->Letter[bitPosition] = rootPath[0];

        //
        // Determine if there is a drive in this spot.
        //
        driveExists = GetLogicalDrives() & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            type = GetDriveTypeA(rootPath);

            if (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                DriveLetters->ExistsOnSystem[bitPosition] = TRUE;
                DriveLetters->Type[bitPosition] = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }
}


VOID
InitializeDriveLetterStructureW (
    OUT     PDRIVELETTERSW DriveLetters
    )
{
    BYTE bitPosition;
    DWORD maxBitPosition = NUMDRIVELETTERS;
    WCHAR rootPath[] = L"?:\\";
    BOOL driveExists;
    UINT type;

    //
    // GetLogicalDrives returns a bitmask of all of the drive letters
    // in use on the system. (i.e. bit position 0 is turned on if there is
    // an 'A' drive, 1 is turned on if there is a 'B' drive, etc.
    // This loop will use this bitmask to fill in the global drive
    // letters structure with information about what drive letters
    // are available and what there drive types are.
    //

    for (bitPosition = 0; bitPosition < maxBitPosition; bitPosition++) {

        //
        // Initialize this drive
        //

        DriveLetters->ExistsOnSystem[bitPosition] = FALSE;
        DriveLetters->Type[bitPosition] = 0;
        DriveLetters->IdentifierString[bitPosition][0] = 0;

        rootPath[0] = L'A' + bitPosition;
        DriveLetters->Letter[bitPosition] = rootPath[0];

        //
        // Determine if there is a drive in this spot.
        //
        driveExists = GetLogicalDrives() & (1 << bitPosition);

        if (driveExists) {

            //
            // There is. Now, see if it is one that we care about.
            //
            type = GetDriveTypeW(rootPath);

            if (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_CDROM) {

                //
                // This is a drive that we are interested in.
                //
                DriveLetters->ExistsOnSystem[bitPosition] = TRUE;
                DriveLetters->Type[bitPosition] = type;

                //
                // Identifier String is not filled in this function.
                //
            }
        }
    }
}

typedef BOOL (WINAPI * GETDISKFREESPACEEXA)(
  PCSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

typedef BOOL (WINAPI * GETDISKFREESPACEEXW)(
  PCWSTR lpDirectoryName,                  // directory name
  PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
  PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
  PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
);

BOOL
GetDiskFreeSpaceNewA(
    IN      PCSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )

/*++

Routine Description:

  On Win9x GetDiskFreeSpace never return free/total space more than 2048MB.
  GetDiskFreeSpaceNew use GetDiskFreeSpaceEx to calculate real number of free/total clusters.
  Has same  declaration as GetDiskFreeSpaceA.

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXA pGetDiskFreeSpaceExA;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceA(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DEBUGMSG((DBG_ERROR,"GetDiskFreeSpaceNewA: GetDiskFreeSpaceA failed on drive %s", DriveName));
        return FALSE;
    }

    hKernel32 = LoadSystemLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExA = (GETDISKFREESPACEEXA)GetProcAddress(hKernel32, "GetDiskFreeSpaceExA");
    if(pGetDiskFreeSpaceExA &&
       pGetDiskFreeSpaceExA(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DEBUGMSG((DBG_WARNING,
                  pGetDiskFreeSpaceExA?
                    "GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA is failed":
                    "GetDiskFreeSpaceNewA: GetDiskFreeSpaceExA function is not in kernel32.dll"));
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    DEBUGMSG((DBG_VERBOSE,
              "GetDiskFreeSpaceNewA: \n\t"
                "SectorsPerCluster = %d\n\t"
                "BytesPerSector = %d\n\t"
                "NumberOfFreeClusters = %I64u\n\t"
                "TotalNumberOfClusters = %I64u",
                SectorsPerCluster,
                BytesPerSector,
                NumberOfFreeClusters.QuadPart,
                TotalNumberOfClusters.QuadPart));

    return TRUE;
}


BOOL
GetDiskFreeSpaceNewW(
    IN      PCWSTR  DriveName,
    OUT     DWORD * OutSectorsPerCluster,
    OUT     DWORD * OutBytesPerSector,
    OUT     ULARGE_INTEGER * OutNumberOfFreeClusters,
    OUT     ULARGE_INTEGER * OutTotalNumberOfClusters
    )
/*++

Routine Description:

  Correct NumberOfFreeClusters and TotalNumberOfClusters out parameters
  with using GetDiskFreeSpace and GetDiskFreeSpaceEx

Arguments:

    DriveName - supplies directory name
    OutSectorsPerCluster - receive number of sectors per cluster
    OutBytesPerSector - receive number of bytes per sector
    OutNumberOfFreeClusters - receive number of free clusters
    OutTotalNumberOfClusters - receive number of total clusters

Return Value:

    TRUE if the function succeeds.
    If the function fails, the return value is FALSE. To get extended error information, call GetLastError

--*/
{
    ULARGE_INTEGER TotalNumberOfFreeBytes = {0, 0};
    ULARGE_INTEGER TotalNumberOfBytes = {0, 0};
    ULARGE_INTEGER DonotCare;
    HMODULE hKernel32;
    GETDISKFREESPACEEXW pGetDiskFreeSpaceExW;
    ULARGE_INTEGER NumberOfFreeClusters = {0, 0};
    ULARGE_INTEGER TotalNumberOfClusters = {0, 0};
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;

    if(!GetDiskFreeSpaceW(DriveName,
                          &SectorsPerCluster,
                          &BytesPerSector,
                          &NumberOfFreeClusters.LowPart,
                          &TotalNumberOfClusters.LowPart)){
        DEBUGMSG((DBG_ERROR,"GetDiskFreeSpaceNewW: GetDiskFreeSpaceW failed on drive %s", DriveName));
        return FALSE;
    }

    hKernel32 = LoadSystemLibraryA("kernel32.dll");
    pGetDiskFreeSpaceExW = (GETDISKFREESPACEEXW)GetProcAddress(hKernel32, "GetDiskFreeSpaceExW");
    if(pGetDiskFreeSpaceExW &&
       pGetDiskFreeSpaceExW(DriveName, &DonotCare, &TotalNumberOfBytes, &TotalNumberOfFreeBytes)){
        NumberOfFreeClusters.QuadPart = TotalNumberOfFreeBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
        TotalNumberOfClusters.QuadPart = TotalNumberOfBytes.QuadPart / (SectorsPerCluster * BytesPerSector);
    }
    else{
        DEBUGMSG((DBG_WARNING,
                  pGetDiskFreeSpaceExW?
                    "GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW is failed":
                    "GetDiskFreeSpaceNewW: GetDiskFreeSpaceExW function is not in kernel32.dll"));
    }
    FreeLibrary(hKernel32);

    if(OutSectorsPerCluster){
        *OutSectorsPerCluster = SectorsPerCluster;
    }

    if(OutBytesPerSector){
        *OutBytesPerSector = BytesPerSector;
    }

    if(OutNumberOfFreeClusters){
        OutNumberOfFreeClusters->QuadPart = NumberOfFreeClusters.QuadPart;
    }

    if(OutTotalNumberOfClusters){
        OutTotalNumberOfClusters->QuadPart = TotalNumberOfClusters.QuadPart;
    }

    DEBUGMSG((DBG_VERBOSE,
              "GetDiskFreeSpaceNewW: \n\t"
                "SectorsPerCluster = %d\n\t"
                "BytesPerSector = %d\n\t"
                "NumberOfFreeClusters = %I64u\n\t"
                "TotalNumberOfClusters = %I64u",
                SectorsPerCluster,
                BytesPerSector,
                NumberOfFreeClusters.QuadPart,
                TotalNumberOfClusters.QuadPart));

    return TRUE;
}


DWORD
QuietGetFileAttributesA (
    IN      PCSTR FilePath
    )
{
    if (!IsPathOnFixedDriveA (FilePath)) {
        return INVALID_ATTRIBUTES;
    }

    return GetFileAttributesA (FilePath);
}


DWORD
QuietGetFileAttributesW (
    IN      PCWSTR FilePath
    )
{
    MYASSERT (ISNT());

    if (!IsPathOnFixedDriveW (FilePath)) {
        return INVALID_ATTRIBUTES;
    }

    return GetLongPathAttributesW (FilePath);
}


DWORD
MakeSureLongPathExistsW (
    IN      PCWSTR Path,
    IN      BOOL PathOnly
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = MakeSurePathExistsW (Path, PathOnly);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = MakeSurePathExistsW (tmp, PathOnly);
        FreePathStringW (tmp);
    }

    return result;
}


DWORD
SetLongPathAttributesW (
    IN      PCWSTR Path,
    IN      DWORD Attributes
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = SetFileAttributesW (Path, Attributes);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = SetFileAttributesW (tmp, Attributes);
        FreePathStringW (tmp);
    }

    return result;
}


DWORD
GetLongPathAttributesW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    DWORD result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = GetFileAttributesW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = GetFileAttributesW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}


BOOL
DeleteLongPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    BOOL result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = DeleteFileW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = DeleteFileW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}


BOOL
RemoveLongDirectoryPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR tmp;
    BOOL result;

    if (Path[0] == L'\\' || TcharCountW (Path) < MAX_PATH) {
        result = RemoveDirectoryW (Path);
    } else {
        tmp = JoinPathsW (L"\\\\?", Path);
        result = RemoveDirectoryW (tmp);
        FreePathStringW (tmp);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"
#include "migutilp.h"

#define DEFAULT_GROW_SIZE 8192

PBYTE
RealGrowBuffer (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);
    MYASSERT(GrowBuf);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GrowBuffer: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GrowBuffer: Realloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return NewBuffer;
}


PBYTE
RealGrowBufferReserve (
    IN  PGROWBUFFER GrowBuf,
    IN  DWORD BytesToReserve
    )
{
    DWORD end;
    PBYTE result;

    MYASSERT(GrowBuf);
    MYASSERT(BytesToReserve);

    end = GrowBuf->End;
    result = GrowBuffer (GrowBuf, BytesToReserve);
    GrowBuf->End = end;

    return result;
}


VOID
FreeGrowBuffer (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    if(!GrowBuf || !String){
        MYASSERT(GrowBuf);
        MYASSERT(String);

        return FALSE;
    }

    p = (PSTR) GrowBuffer (GrowBuf, SizeOfStringA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    MYASSERT(GrowBuf);
    MYASSERT(Key);
/*
//BUGBUG: Decided to leave it as it was, because we know callers.
    if(!GrowBuf || !Key){
        MYASSERT(GrowBuf);
        MYASSERT(Key);
        return FALSE;
    }

    if(_snprintf(KeyValPair, ARRAYSIZE(KeyValPair), "%s=%u", Key, Val) < 0){
        DEBUGMSG((DBG_ERROR, "RealMultiSzAppendValA: Key was truncated, function fails."));
        //KeyValPair[ARRAYSIZE(KeyValPair) - 1] = '\0';
        return FALSE;//Continue with truncated string or return FALSE;
    }
*/

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return MultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    MYASSERT(GrowBuf);
    MYASSERT(Key);
    MYASSERT(Val);
/*
//BUGBUG: Decided to leave it as it was, because we know callers.
    if(!GrowBuf || !Key || !Val){
        MYASSERT(GrowBuf);
        MYASSERT(Key);
        MYASSERT(Val);
        return FALSE;
    }

    if(_snprintf(KeyValPair, ARRAYSIZE(KeyValPair), "%s=%s", Key, Val) < 0){
        DEBUGMSG((DBG_ERROR, "RealMultiSzAppendStringA: Key was truncated, function fails."));
        //KeyValPair[ARRAYSIZE(KeyValPair) - 1] = '\0';
        return FALSE;//BUGBUG: Continue with truncated string or return FALSE;
    }
*/

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return MultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    if(!GrowBuf || !String){
        MYASSERT(GrowBuf);
        MYASSERT(String);
        return FALSE;
    }

    p = (PWSTR) GrowBuffer (GrowBuf, SizeOfStringW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    StringCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    MYASSERT(GrowBuf);
    MYASSERT(Key);

/*
//BUGBUG: Decided to leave it as it was, because we know callers.
    if(!GrowBuf || !Key){
        MYASSERT(GrowBuf);
        MYASSERT(Key);

        return FALSE;
    }

    if(_snwprintf(KeyValPair, ARRAYSIZE(KeyValPair), L"%s=%u", Key, Val) < 0){
        DEBUGMSG((DBG_ERROR, "RealMultiSzAppendValW: Key was truncated, function fails."));
        //KeyValPair[ARRAYSIZE(KeyValPair) - 1] = '\0';
        return FALSE;//BUGBUG: Continue with truncated string or return FALSE;
    }
*/

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return MultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    MYASSERT(GrowBuf);
    MYASSERT(Key);
    MYASSERT(Val);
/*
//BUGBUG: Decided to leave it as it was, because we know callers.
    if(!GrowBuf || !Key || !Val){
        MYASSERT(GrowBuf);
        MYASSERT(Key);
        MYASSERT(Val);
        return FALSE;
    }

    if(_snwprintf(KeyValPair, ARRAYSIZE(KeyValPair), L"%s=%s", Key, Val) < 0){
        DEBUGMSG((DBG_ERROR, "RealMultiSzAppendStringW: Key was truncated, function fails."));
        //KeyValPair[ARRAYSIZE(KeyValPair) - 1] = '\0';
        return FALSE;//BUGBUG: Continue with truncated string or return FALSE;
    }
*/

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return MultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGrowBufAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    p = (PDWORD) GrowBuffer (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGrowBufAppendUintPtr (
    PGROWBUFFER GrowBuf,
    UINT_PTR d
    )
{
    PUINT_PTR p;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    p = (PUINT_PTR) GrowBuffer (GrowBuf, sizeof (UINT_PTR));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGrowBufAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    if (String) {
        Bytes = SizeOfStringA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        StringCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGrowBufAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    if (String) {
        Bytes = SizeOfStringW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        StringCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGrowBufAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT) (UINT_PTR) ((PBYTE) EndPlusOne - (PBYTE) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGrowBufAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if(!GrowBuf){
        MYASSERT(GrowBuf);
        return FALSE;
    }

    if (Start && Start < EndPlusOne) {
        Bytes = (UINT) (UINT_PTR) ((PBYTE) EndPlusOne - (PBYTE) Start);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGrowBuffer (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGrowBufCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    if(!GrowBuf || !String){
        MYASSERT(GrowBuf);
        MYASSERT(String);
        return FALSE;
    }

    Size = SizeOfStringA (String);

    Buf = RealGrowBuffer (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGrowBufCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    if(!GrowBuf || !String){
        MYASSERT(GrowBuf);
        MYASSERT(String);
        return FALSE;
    }

    Size = SizeOfStringW (String);

    Buf = RealGrowBuffer (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\cablib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cablib.c

Abstract:

    Implements wrappers for cabinet APIs

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "migutilp.h"

#include <cablib.h>
#include <fci.h>
#include <fdi.h>
#include <fcntl.h>
#include <crt\sys\stat.h>

//
// Includes
//

// None

#define DBG_CABLIB  "CabLib"

//
// Strings
//

// None

//
// Constants
//

#define VERIFY_HANDLE   ((HANDLE) (-2))

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PCSTR CabPath;
    PCSTR CabFileFormat;
    PCSTR CabDiskFormat;
    PCABGETCABINETNAMESA CabGetCabinetNames;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFileFormat;
    PCWSTR CabDiskFormat;
    PCABGETCABINETNAMESW CabGetCabinetNames;
    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;
} FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW;

typedef struct {
    PCSTR CabPath;
    PCSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA;

typedef struct {
    PCWSTR CabPath;
    PCWSTR CabFile;
    HFDI FdiHandle;
    ERF FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
} FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW;

typedef struct {
    PCSTR ExtractPath;
    PCABNOTIFICATIONA CabNotificationA;
} CAB_DATAA, *PCAB_DATAA;

typedef struct {
    PCWSTR ExtractPath;
    PCABNOTIFICATIONW CabNotificationW;
    BOOL VerifyMode;
} CAB_DATAW, *PCAB_DATAW;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

INT
DIAMONDAPI
pCabFilePlacedA (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    MYASSERT(Context);

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


INT
DIAMONDAPI
pCabFilePlacedW (
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    MYASSERT(Context);

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return 0;
    }

    cabHandle->FileCount++;
    cabHandle->FileSize += FileSize;

    return 0;
}


PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MYASSERT(Size);

    return MemAlloc (g_hHeap, 0, Size);
}

VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MYASSERT(Memory);

    MemFree (g_hHeap, 0, Memory);
}

INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    if(!FileName){
        MYASSERT(FileName);
        if(Error){
            *Error = ERROR_FILE_NOT_FOUND;
        }
        return -1;
    }

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    MYASSERT (pMode == (_S_IREAD | _S_IWRITE));

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        if(Error){
            *Error = GetLastError ();
        }
        return -1;
    }
    if(Error){
        *Error = 0;
    }

    return (INT_PTR)fileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    HANDLE fileHandle;

    if(!FileName){
        MYASSERT(FileName);
        return -1;
    }

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    MYASSERT (oFlag == _O_BINARY);

    fileHandle = CreateFileA (
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return -1;
    }
    return (INT_PTR)fileHandle;
}

UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);
    MYASSERT(Buffer);
    MYASSERT(Size);

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        if(Error){
            *Error = GetLastError ();
        }
        return ((UINT)(-1));
    }
    if(Error){
        *Error = 0;
    }

    return bytesRead;
}

UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    UINT bytesRead;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);
    MYASSERT(Buffer);
    MYASSERT(Size);

    result = ReadFile ((HANDLE)FileHandle, Buffer, Size, &bytesRead, NULL);
    if (!result) {
        return ((UINT)(-1));
    }
    return bytesRead;
}

UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    DWORD dontCare;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);
    MYASSERT(Buffer);
    MYASSERT(Size);

    if (FileHandle == (INT_PTR) VERIFY_HANDLE) {
        return Size;
    }

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &dontCare, NULL);
    if (!result) {
        if(Error){
            *Error = GetLastError ();
        }
        return ((UINT)(-1));
    }

    if(Error){
        *Error = 0;
    }

    return Size;
}

UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    BOOL result;
    DWORD dontCare;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);
    MYASSERT(Buffer);
    MYASSERT(Size);

    if (FileHandle == (INT_PTR) VERIFY_HANDLE) {
        return Size;
    }

    result = WriteFile ((HANDLE)FileHandle, Buffer, Size, &dontCare, NULL);
    if (!result) {
        return ((UINT)(-1));
    }

    return Size;
}

INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);

    CloseHandle ((HANDLE)FileHandle);
    if(Error){
        *Error = 0;
    }
    return 0;
}

INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);

    CloseHandle ((HANDLE)FileHandle);
    return 0;
}

LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return ((LONG)(result));
}

LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    DWORD result;
    DWORD seekType = FILE_BEGIN;

    MYASSERT(((HANDLE)FileHandle) != INVALID_HANDLE_VALUE);

    switch (SeekType) {
    case SEEK_SET:
        seekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        seekType = FILE_CURRENT;
        break;
    case SEEK_END:
        seekType = FILE_END;
        break;
    }

    result = SetFilePointer ((HANDLE)FileHandle, Distance, NULL, seekType);

    if (result == INVALID_SET_FILE_POINTER) {
        return -1;
    }
    return ((LONG)(result));
}

INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    MYASSERT(FileName);
    MYASSERT(Error);

    if (!DeleteFileA (FileName)) {
        *Error = GetLastError ();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    CHAR tempPath[MAX_PATH];
    PSTR p;

    MYASSERT(FileName);

    if (!GetTempPathA (ARRAYSIZE(tempPath), tempPath)) {
        return FALSE;
    }

    p = _mbsrchr (tempPath, '\\');
    if (p && !p[1]) {
        *p = 0;
    }

    if (!DoesFileExistA (tempPath)) {
        CreateDirectoryA (tempPath, NULL);
    }

    if (!GetTempFileNameA (tempPath, "cab", 0, FileName)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [CB_MAX_CABINET_NAME];
    CHAR cabDisk [CB_MAX_DISK_NAME];

    MYASSERT(Context);

    cabHandle = (PFCI_CAB_HANDLEA) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        return cabHandle->CabGetCabinetNames (
                            FciCabParams->szCabPath,
                            CB_MAX_CAB_PATH,
                            FciCabParams->szCab,
                            CB_MAX_CABINET_NAME,
                            FciCabParams->szDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            if(_snprintf(cabFile, CB_MAX_CABINET_NAME, cabHandle->CabFileFormat, FciCabParams->iCab) < 0){
                cabFile[CB_MAX_CABINET_NAME - 1] = '\0';
                DEBUGMSG((DBG_ERROR, "pCabGetNextCabinetW: _snprintf truncated cabfile %s", cabFile));
                //BUGBUG: we have truncated path, what to do?
                //return TRUE;
            }
            StringCopyByteCountA (FciCabParams->szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));
        }
        if (cabHandle->CabDiskFormat) {
            if(_snprintf(cabDisk, CB_MAX_DISK_NAME, cabHandle->CabDiskFormat, FciCabParams->iDisk) < 0){
                cabDisk[CB_MAX_DISK_NAME - 1] = '\0';
                DEBUGMSG((DBG_ERROR, "pCabGetNextCabinetW: _snprintf truncated cabdisk %s", cabDisk));
                //BUGBUG: we have truncated path, what to do?
                //return TRUE;
            }
            StringCopyByteCountA (FciCabParams->szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
        }
    }
    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [CB_MAX_CAB_PATH];
    WCHAR cabFile [CB_MAX_CABINET_NAME];
    WCHAR cabDisk [CB_MAX_DISK_NAME];
    BOOL result;

    MYASSERT(Context);
    MYASSERT(FciCabParams);

    cabHandle = (PFCI_CAB_HANDLEW) Context;
    if (!cabHandle) {
        return FALSE;
    }
    if (cabHandle->CabGetCabinetNames) {
        result = cabHandle->CabGetCabinetNames (
                            cabPath,
                            CB_MAX_CAB_PATH,
                            cabFile,
                            CB_MAX_CABINET_NAME,
                            cabDisk,
                            CB_MAX_DISK_NAME,
                            FciCabParams->iCab,
                            &FciCabParams->iDisk
                            );
        if (result) {
            KnownSizeUnicodeToDbcs (FciCabParams->szCabPath, cabPath);
            KnownSizeUnicodeToDbcs (FciCabParams->szCab, cabFile);
            KnownSizeUnicodeToDbcs (FciCabParams->szDisk, cabDisk);
            return TRUE;
        }
        return FALSE;
    } else {
        FciCabParams->iDisk = FciCabParams->iCab;
        if (cabHandle->CabFileFormat) {
            if(_snwprintf(cabFile, CB_MAX_CABINET_NAME, cabHandle->CabFileFormat, FciCabParams->iCab) < 0){
                cabFile[CB_MAX_CABINET_NAME - 1] = '\0';
                DEBUGMSG((DBG_ERROR, "pCabGetNextCabinetW: _snwprintf truncated cabfile %s", cabFile));
                //BUGBUG: we have truncated path, what to do?
                //return TRUE;
            }
            KnownSizeUnicodeToDbcs (FciCabParams->szCab, cabFile);
        }
        if (cabHandle->CabDiskFormat) {
            if(_snwprintf(cabDisk, CB_MAX_DISK_NAME, cabHandle->CabDiskFormat, FciCabParams->iDisk) < 0){
                cabDisk[CB_MAX_DISK_NAME - 1] = '\0';
                DEBUGMSG((DBG_ERROR, "pCabGetNextCabinetW: _snwprintf truncated cabdisk %s", cabDisk));
                //BUGBUG: we have truncated path, what to do?
                //return TRUE;
            }
            KnownSizeUnicodeToDbcs (FciCabParams->szDisk, cabDisk);
        }
    }
    return TRUE;
}

LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (StatusType == statusCabinet) {

        MYASSERT(Context);
        cabHandle = (PFCI_CAB_HANDLEA) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PFCI_CAB_HANDLEW cabHandle;

    if (StatusType == statusCabinet) {

        MYASSERT(Context);
        cabHandle = (PFCI_CAB_HANDLEW) Context;
        if (!cabHandle) {
            return 0;
        }

        cabHandle->CabCount++;
        cabHandle->CompressedSize += (LONGLONG) Size2;
    }

    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    WIN32_FIND_DATAA findData;
    FILETIME fileTime;
    HANDLE fileHandle;

    MYASSERT(FileName);
    MYASSERT(Error);

    if (DoesFileExistExA (FileName, &findData)) {

        FileTimeToLocalFileTime (&findData.ftLastWriteTime, &fileTime);
        FileTimeToDosDateTime (&fileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (findData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        fileHandle = CreateFileA (
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (fileHandle == INVALID_HANDLE_VALUE) {
            *Error = GetLastError ();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)fileHandle;
    } else {
        *Error = GetLastError ();
        return -1;
    }
}


BOOL
pIsFullPathA (
    IN      PCSTR PathToTest
    )
{
    MBCHAR ch1;
    MBCHAR ch2;

    MYASSERT(PathToTest);

    ch1 = _mbsnextc (PathToTest);
    _mbsinc (PathToTest);
    ch2 = _mbsnextc (PathToTest);

    if ((ch1 == '\\' && ch2 == '\\') ||
        (isalpha (ch1) && ch2 == '\\')
        ) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pIsFullPathW (
    IN      PCWSTR PathToTest
    )
{
    WCHAR ch1;
    WCHAR ch2;

    MYASSERT(PathToTest);

    ch1 = *PathToTest++;
    ch2 = *PathToTest;

    if ((ch1 == '\\' && ch2 == '\\') ||
        (isalpha (ch1) && ch2 == '\\')
        ) {
        return TRUE;
    }

    return FALSE;
}


PCSTR
pComputeDestPathA (
    IN      PCSTR ExtractPath,          OPTIONAL
    IN      PCSTR PathStoredInCab
    )
{
    PCSTR destFile;

    MYASSERT(PathStoredInCab);

    //
    // If ExtractPath is NULL, then use the path stored in the cab.
    // If the path stored in the cab is a full path, use only the file name.
    // Otherwise join ExtractPath with PathStoredInCab.
    //

    if (!ExtractPath) {

        destFile = DuplicatePathStringA (PathStoredInCab, 0);

    } else if (pIsFullPathA (PathStoredInCab)) {

        destFile = JoinPathsA (ExtractPath, GetFileNameFromPathA (PathStoredInCab));

    } else {

        destFile = JoinPathsA (ExtractPath, PathStoredInCab);

    }

    return destFile;
}


PCWSTR
pComputeDestPathW (
    IN      PCWSTR ExtractPath,         OPTIONAL
    IN      PCWSTR PathStoredInCab
    )
{
    PCWSTR destFile;

    MYASSERT(PathStoredInCab);

    //
    // If ExtractPath is NULL, then use the path stored in the cab.
    // If the path stored in the cab is a full path, use only the file name.
    // Otherwise join ExtractPath with PathStoredInCab.
    //

    if (!ExtractPath) {

        destFile = DuplicatePathStringW (PathStoredInCab, 0);

    } else if (pIsFullPathW (PathStoredInCab)) {

        destFile = JoinPathsW (ExtractPath, GetFileNameFromPathW (PathStoredInCab));

    } else {

        destFile = JoinPathsW (ExtractPath, PathStoredInCab);

    }

    return destFile;
}


INT_PTR
DIAMONDAPI
pCabNotificationA (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAA cabData;
    INT createFlag;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied

        cabData = (PCAB_DATAA)FdiNotification->pv;

        destFile = pComputeDestPathA (cabData->ExtractPath, FdiNotification->psz1);
        MYASSERT(destFile);
        createFlag = TRUE;

        if (cabData->CabNotificationA) {
            createFlag = cabData->CabNotificationA (destFile);
        }

        if(-1 == createFlag){
            FreePathStringA (destFile);
            return -1;
        }

        if (createFlag) {
            MakeSurePathExistsA (FdiNotification->psz1, FALSE);

            SetFileAttributesA (destFile, FILE_ATTRIBUTE_NORMAL);
            destHandle = CreateFileA (
                            destFile,
                            GENERIC_READ|GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        }
        FreePathStringA (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAA)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }

        destFile = pComputeDestPathA (cabData->ExtractPath, FdiNotification->psz1);

        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesA (destFile, attributes);

        FreePathStringA (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        return 0;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabNotificationW (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    PCWSTR destFile = NULL;
    HANDLE destHandle = NULL;
    DWORD attributes;
    FILETIME localFileTime;
    FILETIME fileTime;
    PCAB_DATAW cabData;
    INT createFlag;
    PCWSTR cabFileSpecW;

    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        return 0;
    case fdintCOPY_FILE:        // File to be copied

        cabFileSpecW = ConvertAtoW (FdiNotification->psz1);
        cabData = (PCAB_DATAW)FdiNotification->pv;

        destFile = pComputeDestPathW (cabData->ExtractPath, cabFileSpecW);
        MYASSERT(destFile);

        FreeConvertedStr (cabFileSpecW);
        createFlag = TRUE;

        if (cabData->CabNotificationW) {
            createFlag = cabData->CabNotificationW (destFile);
        }

        if(-1 == createFlag){
            FreePathStringW (destFile);
            return -1;
        }

        if (createFlag) {
            if (!cabData->VerifyMode) {
                MakeSurePathExistsW (cabFileSpecW, FALSE);

                SetFileAttributesW (destFile, FILE_ATTRIBUTE_NORMAL);
                destHandle = CreateFileW (
                                destFile,
                                GENERIC_READ|GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            } else {
                destHandle = VERIFY_HANDLE;
            }
        }

        FreePathStringW (destFile);
        return (INT_PTR)destHandle;
    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        cabData = (PCAB_DATAW)FdiNotification->pv;
        if (DosDateTimeToFileTime (FdiNotification->date, FdiNotification->time, &localFileTime)) {
            if (LocalFileTimeToFileTime (&localFileTime, &fileTime)) {
                SetFileTime ((HANDLE)FdiNotification->hf, &fileTime, &fileTime, &fileTime);
            }
        }

        cabFileSpecW = ConvertAtoW (FdiNotification->psz1);
        destFile = pComputeDestPathW (cabData->ExtractPath, cabFileSpecW);
        MYASSERT(destFile);
        FreeConvertedStr (cabFileSpecW);

        CloseHandle ((HANDLE)FdiNotification->hf);
        attributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        SetFileAttributesW (destFile, attributes);
        FreePathStringW (destFile);
        return TRUE;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        return 0;
    case fdintENUMERATE:        // Enumeration status
        return 0;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        return 0;
    }
    return 0;
}

CCABHANDLE
CabCreateCabinetA (
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    CHAR cabFile [CB_MAX_CABINET_NAME];
    CHAR cabDisk [CB_MAX_DISK_NAME];

    if(!CabPath){
        MYASSERT(CabPath);
        return NULL;
    }

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringA (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringA (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringA (CabDiskFormat, 0);
    }

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        StringCopyByteCountA (cabHandle->FciCabParams.szCabPath, CabPath, CB_MAX_CAB_PATH - 1);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        if(_snprintf(cabDisk, CB_MAX_DISK_NAME, CabDiskFormat, cabHandle->FciCabParams.iDisk) < 0){
            cabDisk[CB_MAX_DISK_NAME - 1] = '\0';
            DEBUGMSG((DBG_ERROR, "CabCreateCabinetA: _snwprintf truncated cabdisk %s", cabDisk));
            //BUGBUG: we have truncated path, what to do?
            //return NULL;
        }
        StringCopyByteCountA (cabHandle->FciCabParams.szDisk, cabDisk, CB_MAX_DISK_NAME * sizeof (CHAR));
    }
    if(_snprintf(cabFile, CB_MAX_CABINET_NAME, CabFileFormat, cabHandle->FciCabParams.iCab) < 0){
        cabFile[CB_MAX_CABINET_NAME - 1] = '\0';
        DEBUGMSG((DBG_ERROR, "CabCreateCabinetA: _snwprintf truncated cabfile %s", cabFile));
        //BUGBUG: we have truncated path, what to do?
        //return NULL;
    }
    StringCopyByteCountA (cabHandle->FciCabParams.szCab, cabFile, CB_MAX_CABINET_NAME * sizeof (CHAR));

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetW (
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPath - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabFile [CB_MAX_CABINET_NAME];
    WCHAR cabDisk [CB_MAX_DISK_NAME];

    if(!CabPath){
        MYASSERT(CabPath);
        return NULL;
    }

    if (!CabFileFormat) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    cabHandle = (PFCI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    if (CabPath) {
        cabHandle->CabPath = DuplicatePathStringW (CabPath, 0);
    }
    cabHandle->CabFileFormat = DuplicatePathStringW (CabFileFormat, 0);
    if (CabDiskFormat) {
        cabHandle->CabDiskFormat = DuplicatePathStringW (CabDiskFormat, 0);
    }

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (CabPath) {
        KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCabPath, CabPath);
        AppendWackA (cabHandle->FciCabParams.szCabPath);
    }
    if (CabDiskFormat) {
        if(_snwprintf(cabDisk, CB_MAX_DISK_NAME, CabDiskFormat, cabHandle->FciCabParams.iDisk) < 0){
            cabDisk[CB_MAX_DISK_NAME - 1] = '\0';
            DEBUGMSG((DBG_ERROR, "CabCreateCabinetW: _snwprintf truncated cabdisk %s", cabDisk));
            //BUGBUG: we have truncated path, what to do?
            //return NULL;
        }
        KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szDisk, cabDisk);
    }
    if(_snwprintf(cabFile, CB_MAX_CABINET_NAME, CabFileFormat, cabHandle->FciCabParams.iCab) < 0){
        cabFile[CB_MAX_CABINET_NAME - 1] = '\0';
        DEBUGMSG((DBG_ERROR, "CabCreateCabinetW: _snwprintf truncated cabfile %s", cabFile));
        //BUGBUG: we have truncated path, what to do?
        //return NULL;
    }
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCab, cabFile);

    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExA (
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEA));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabHandle->FciCabParams.szCabPath,
            CB_MAX_CAB_PATH,
            cabHandle->FciCabParams.szCab,
            CB_MAX_CABINET_NAME,
            cabHandle->FciCabParams.szDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

CCABHANDLE
CabCreateCabinetExW (
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    )

/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    WCHAR cabPath [CB_MAX_CAB_PATH];
    WCHAR cabFile [CB_MAX_CABINET_NAME];
    WCHAR cabDisk [CB_MAX_DISK_NAME];

    if (!CabGetCabinetNames) {
        return NULL;
    }

    if (MaxFileSize < 0) {
        return NULL;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    cabHandle = MemAlloc (g_hHeap, 0, sizeof (FCI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FCI_CAB_HANDLEW));
    cabHandle->CabGetCabinetNames = CabGetCabinetNames;

    // fill out the CCAB structure
    cabHandle->FciCabParams.cb = MaxFileSize;
    cabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    cabHandle->FciCabParams.cbReserveCFHeader = 0;
    cabHandle->FciCabParams.cbReserveCFFolder = 0;
    cabHandle->FciCabParams.cbReserveCFData = 0;
    cabHandle->FciCabParams.iCab = 1;
    cabHandle->FciCabParams.iDisk = 1;
    cabHandle->FciCabParams.setID = 0;
    if (!CabGetCabinetNames (
            cabPath,
            CB_MAX_CAB_PATH,
            cabFile,
            CB_MAX_CABINET_NAME,
            cabDisk,
            CB_MAX_DISK_NAME,
            cabHandle->FciCabParams.iCab,
            &cabHandle->FciCabParams.iDisk
            )) {
        return NULL;
    }
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCabPath, cabPath);
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szCab, cabFile);
    KnownSizeUnicodeToDbcs (cabHandle->FciCabParams.szDisk, cabDisk);
    cabHandle->FciHandle = FCICreate (
                                &cabHandle->FciErrorStruct,
                                pCabFilePlacedW,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &cabHandle->FciCabParams,
                                cabHandle
                                );
    if (!cabHandle->FciHandle) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabAddFileToCabinetA (
    IN      CCABHANDLE CabHandle,
    IN      PCSTR FileName,
    IN      PCSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }

    return FCIAddFile (
                cabHandle->FciHandle,
                (PSTR)FileName,
                (PSTR)StoredName,
                FALSE,
                pCabGetNextCabinetA,
                pCabStatusA,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabAddFileToCabinetW (
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    )

/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileName - Specifies the file to be added.

  StoredName - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    CHAR ansiFileName [1024];
    CHAR ansiStoredName [1024];

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }

    if(!StoredName || !FileName){
        MYASSERT(FileName);
        MYASSERT(StoredName);
        return FALSE;
    }

    KnownSizeUnicodeToDbcs (ansiFileName, FileName);
    KnownSizeUnicodeToDbcs (ansiStoredName, StoredName);

    return FCIAddFile (
                cabHandle->FciHandle,
                ansiFileName,
                ansiStoredName,
                FALSE,
                pCabGetNextCabinetW,
                pCabStatusW,
                pCabGetOpenInfoA,
                tcompTYPE_MSZIP
                );
}

BOOL
CabFlushAndCloseCabinetExA (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEA cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEA) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetA,
            pCabStatusA
            )) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringA (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringA (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }

    return result;
}

BOOL
CabFlushAndCloseCabinetExW (
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )

/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFCI_CAB_HANDLEW cabHandle;
    BOOL result = FALSE;

    cabHandle = (PFCI_CAB_HANDLEW) CabHandle;
    if (cabHandle == NULL) {
        return FALSE;
    }
    if (cabHandle->FciHandle == NULL) {
        return FALSE;
    }
    if (FCIFlushCabinet (
            cabHandle->FciHandle,
            FALSE,
            pCabGetNextCabinetW,
            pCabStatusW
            )) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFileFormat) {
            FreePathStringW (cabHandle->CabFileFormat);
        }
        if (cabHandle->CabDiskFormat) {
            FreePathStringW (cabHandle->CabDiskFormat);
        }
        result = FCIDestroy (cabHandle->FciHandle);

        if (FileCount) {
            *FileCount = cabHandle->FileCount;
        }

        if (FileSize) {
            *FileSize = cabHandle->FileSize;
        }

        if (CabFileCount) {
            *CabFileCount = cabHandle->CabCount;
        }

        if (CabFileSize) {
            *CabFileSize = cabHandle->CompressedSize;
        }

        MemFree (g_hHeap, 0, cabHandle);
    }
    return result;
}

OCABHANDLE
CabOpenCabinetA (
    IN      PCSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    PSTR filePtr;
    HANDLE fileHandle;
    PCSTR fileName;

    if(!FileName){
        MYASSERT(FileName);
        return NULL;
    }

    cabHandle = (PFDI_CAB_HANDLEA) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEA));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEA));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringA (FileName, 0);
    fileHandle = CreateFileA (
                    fileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringA (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PSTR)GetFileNameFromPathA (fileName);
    if (!filePtr) {
        FreePathStringA (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringA (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringA (fileName, 0);
    FreePathStringA (fileName);
    return ((CCABHANDLE)(cabHandle));
}

OCABHANDLE
CabOpenCabinetW (
    IN      PCWSTR FileName
    )

/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    PWSTR filePtr;
    HANDLE fileHandle;
    PCWSTR fileName;

    if(!FileName){
        MYASSERT(FileName);
        return NULL;
    }

    cabHandle = (PFDI_CAB_HANDLEW) MemAlloc (g_hHeap, 0, sizeof (FDI_CAB_HANDLEW));
    ZeroMemory (cabHandle, sizeof (FDI_CAB_HANDLEW));
    cabHandle->FdiHandle = FDICreate (
                                pCabAlloc,
                                pCabFree,
                                pCabOpen1A,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN,
                                &cabHandle->FdiErrorStruct
                                );
    if (!cabHandle->FdiHandle) {
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    fileName = DuplicatePathStringW (FileName, 0);
    fileHandle = CreateFileW (
                    fileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (fileHandle == INVALID_HANDLE_VALUE) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    if (!FDIIsCabinet (cabHandle->FdiHandle, (INT_PTR)fileHandle, &cabHandle->FdiCabinetInfo)) {
        FreePathStringW (fileName);
        CloseHandle (fileHandle);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    CloseHandle (fileHandle);
    filePtr = (PWSTR)GetFileNameFromPathW (fileName);
    if (!filePtr) {
        FreePathStringW (fileName);
        MemFree (g_hHeap, 0, cabHandle);
        return NULL;
    }
    cabHandle->CabFile = DuplicatePathStringW (filePtr, 0);
    *filePtr = 0;
    cabHandle->CabPath = DuplicatePathStringW (fileName, 0);
    FreePathStringW (fileName);
    return ((CCABHANDLE)(cabHandle));
}

BOOL
CabExtractAllFilesExA (
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,                      OPTIONAL
    IN      PCABNOTIFICATIONA CabNotification       OPTIONAL
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;
    CAB_DATAA cabData;

    cabHandle = (PFDI_CAB_HANDLEA)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotificationA = CabNotification;

    return FDICopy (
                cabHandle->FdiHandle,
                (PSTR)cabHandle->CabFile,
                (PSTR)cabHandle->CabPath,
                0,
                pCabNotificationA,
                NULL,
                (PVOID)(&cabData)
                );
}


BOOL
pCabExtractAllFilesExWorkerW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,                     OPTIONAL
    IN      PCABNOTIFICATIONW CabNotificationW,     OPTIONAL
    IN      BOOL VerifyMode
    )

/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

  CabNotification - Specifies the notification callback function that is
        called for every file in the cab

  VerifyMode - Specifies TRUE if the cab should be verified, FALSE if it
        should be extracted

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;
    CAB_DATAW cabData;
    BOOL result;
    PCSTR cabFileAnsi;
    PCSTR cabPathAnsi;

    cabHandle = (PFDI_CAB_HANDLEW)CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    cabData.ExtractPath = ExtractPath;
    cabData.CabNotificationW = CabNotificationW;
    cabData.VerifyMode = VerifyMode;

    cabFileAnsi = ConvertWtoA (cabHandle->CabFile);
    cabPathAnsi = ConvertWtoA (cabHandle->CabPath);

    result = FDICopy (
                cabHandle->FdiHandle,
                (PSTR) cabFileAnsi,
                (PSTR) cabPathAnsi,
                0,
                pCabNotificationW,
                NULL,
                (PVOID)(&cabData)
                );

    FreeConvertedStr (cabFileAnsi);
    FreeConvertedStr (cabPathAnsi);

    return result;
}


BOOL
CabExtractAllFilesExW (
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,                     OPTIONAL
    IN      PCABNOTIFICATIONW CabNotificationW      OPTIONAL
    )
{
    return pCabExtractAllFilesExWorkerW (CabHandle, ExtractPath, CabNotificationW, FALSE);
}

BOOL
CabVerifyCabinet (
    IN      OCABHANDLE CabHandle
    )
{
    return pCabExtractAllFilesExWorkerW (CabHandle, NULL, NULL, TRUE);

}

BOOL
CabCloseCabinetA (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEA cabHandle;

    cabHandle = (PFDI_CAB_HANDLEA) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringA (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringA (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}

BOOL
CabCloseCabinetW (
    IN      OCABHANDLE CabHandle
    )

/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/

{
    PFDI_CAB_HANDLEW cabHandle;

    cabHandle = (PFDI_CAB_HANDLEW) CabHandle;
    if (!cabHandle) {
        return FALSE;
    }
    if (!cabHandle->FdiHandle) {
        return FALSE;
    }
    if (FDIDestroy (cabHandle->FdiHandle)) {
        if (cabHandle->CabPath) {
            FreePathStringW (cabHandle->CabPath);
        }
        if (cabHandle->CabFile) {
            FreePathStringW (cabHandle->CabFile);
        }
        MemFree (g_hHeap, 0, cabHandle);
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of
    binary objects.

Author:

    08-Aug-1997   jimschm     Created

Revision History:

--*/

#include "pch.h"
#include "migutilp.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGrowListAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGrowListAdd allocates memory for a binary block by using a pool, and
  then expands an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);
    MYASSERT(GrowList);

    //
    // Allocate pool if necessary
    //

    if (!GrowList->ListData) {
        GrowList->ListData = PoolMemInitNamedPool ("GrowList");
        if (!GrowList->ListData) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate pool"));
            return NULL;
        }

        PoolMemDisableTracking (GrowList->ListData);
    }

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GrowBuffer (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = PoolMemGetAlignedMemory (GrowList->ListData, TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GrowListGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
FreeGrowList (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  FreeGrowList frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    if(!GrowList){
        MYASSERT(GrowList);
        return;
    }

    FreeGrowBuffer (&GrowList->ListArray);
    if (GrowList->ListData) {
        PoolMemDestroyPool (GrowList->ListData);
    }

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


PBYTE
GrowListGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListGetItem returns a pointer to the block of data
  for item specified by Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    MYASSERT(ItemPtr);

    return ItemPtr[Index];
}


UINT
GrowListGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GrowListGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    if(!GrowList){
        MYASSERT(GrowList);
        return 0;
    }

    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGrowListAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGrowListAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend appends a black of data as a new list item and
  appends two zero bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    return pGrowListAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGrowListInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend inserts a black of data as a new list item,
  before the specified Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGrowListAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGrowListInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GrowListAppend inserts a block of data as a new list item,
  before the specified Index.  Two zero bytes are appended to
  the block of data (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    Size = GrowListGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    return pGrowListAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GrowListDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    if(!GrowList){
        MYASSERT(GrowList);
        return FALSE;
    }

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*DeleteAt));
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    GrowList->ListArray.End = Size * sizeof (PBYTE);

    return TRUE;
}


BOOL
GrowListResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GrowListResetItem sets the list pointer of the specified item
  to NULL, freeing the memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    if(!GrowList){
        MYASSERT(GrowList);
        return FALSE;
    }

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*ResetAt));
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGrowListSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GrowListSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    if(!GrowList){
        MYASSERT(GrowList);
        return NULL;
    }

    Size = GrowListGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = PoolMemGetAlignedMemory (GrowList->ListData, DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        PoolMemReleaseMemory (GrowList->ListData, (PVOID) (*ReplaceAt));
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"
#include "migutilp.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    BOOL CaseSensitive;
    POOLHANDLE Pool;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    PBUCKETITEM DelayedDelete;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
HtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  if all strings should be stored and compared in lower-case
                  only

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;
    POOLHANDLE pool;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    pool = PoolMemInitNamedPool (S_HASHTABLE);
    MYASSERT (pool);

    PoolMemDisableTracking (pool);

    hashTable = (PHASHTABLESTRUCT) PoolMemGetAlignedMemory (
                                        pool,
                                        sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets)
                                        );
    MYASSERT (hashTable);

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->CaseSensitive = CaseSensitive;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Pool = pool;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);
        PoolMemEmptyPool (table->Pool);
        PoolMemDestroyPool (table->Pool);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is already lower case
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.
  PrevBucketItem    - Receives the previous bucket item

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        (void) CharLowerA (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        (void) _wcslwr (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  BufferEnd        - Specifies the end of the string buffer, which may be longer
                     than all entries in the hash table, or it may be shorter.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is in lower-case, FALSE otherwise.
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.  If pHtFindPrefix does not find a match,
                     this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

    if (maxBytes > ByteCountA(String) + sizeof(CHAR))
    {
        LOG((LOG_WARNING, "HtFindPrefixA - BufferEnd points past end of String"));
        MYASSERT(FALSE);
        return NULL;
    }

    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = AllocTextA (maxBytes / sizeof (CHAR));
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        StringCopyByteCountA (dupStr, String, maxBytes + sizeof (CHAR));
        CharLowerA (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = our_mbsdec (String, BufferEnd);
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

    if (maxBytes > ByteCountW(String) + sizeof(WCHAR))
    {
        LOG((LOG_WARNING, "HtFindPrefixW - BufferEnd points past end of String"));
        MYASSERT(FALSE);
        return NULL;
    }

    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = AllocTextW (maxBytes / sizeof (WCHAR));
        if (!dupStr) {
            MYASSERT (FALSE);
            return NULL;
        }

        StringCopyByteCountW (dupStr, String, maxBytes + sizeof (WCHAR));
        _wcslwr (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable        - Specifies the handle to the hash table, as returned from
                     AllocateHashTable.
  String           - Specifies the string to add to the table
  ExtraData        - Specifies the source binary data to be copied to the hash
                     table entry
  AlreadyLowercase - Specifies TRUE String is in all lowercase

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextA (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return 0;
        }

        CharLowerA (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add UNICODE string to ANSI table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = DuplicateTextW (String);
        if (!dupStr) {
            MYASSERT (FALSE);
            return 0;
        }

        _wcslwr (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SizeOfStringW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) PoolMemGetAlignedMemory (table->Pool, size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    FreeTextW (dupStr);

    return rc;
}


VOID
pRemoveHashItem (
    IN      PHASHTABLESTRUCT Table,
    IN      UINT BucketNum,
    IN      PBUCKETITEM PrevItem,
    IN      PBUCKETITEM ItemToDelete
    )
{
    if (!PrevItem) {
        MYASSERT (Table->Bucket[BucketNum] == ItemToDelete);
        Table->Bucket[BucketNum] = ItemToDelete->Next;
    } else {
        PrevItem->Next = ItemToDelete->Next;
    }

    if (ItemToDelete->PrevLink) {
        ItemToDelete->PrevLink->NextLink = ItemToDelete->NextLink;
    } else {
        Table->FirstLink = ItemToDelete->Next;
    }

    if (ItemToDelete->NextLink) {
        ItemToDelete->NextLink->PrevLink = ItemToDelete->PrevLink;
    } else {
        Table->LastLink = ItemToDelete->PrevLink;
    }

    if (ItemToDelete->Locked) {
        ItemToDelete->Next = Table->DelayedDelete;
        Table->DelayedDelete = ItemToDelete;
    } else {
        PoolMemReleaseMemory (Table->Pool, ItemToDelete);
    }
}


BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    if (!Item) {
        return FALSE;
    }

    //
    // Find prev bucket item
    //

    if (table->Unicode) {
        unicodeStr = HtGetStringFromItemW (Item);
        MYASSERT (unicodeStr);

        thisItem = pHtFindStringW (
                        HashTable,
                        unicodeStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    } else {
        ansiStr = HtGetStringFromItemA (Item);
        MYASSERT (ansiStr);

        thisItem = pHtFindStringA (
                        HashTable,
                        ansiStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    }

    MYASSERT (Item == thisItem);

    if (Item != thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}


BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete UNICODE table with ANSI api"));
        return FALSE;
    }

    thisItem = pHtFindStringA (
                    HashTable,
                    AnsiString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete ANSI table with UNICODE api"));
        return FALSE;
    }

    thisItem = pHtFindStringW (
                    HashTable,
                    UnicodeString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if the String is in lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringA (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringW (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  BufferEnd        - Specifies the end of the buffer for String
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if String is in all lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetExtraData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraDataBuffer
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable       - Specifies the handle to the hash table
  Index           - Specifies the offset as returned from HtFindStringEx or
                    HtAddStringEx
  ExtraDataBuffer - Receives the extra data

Return Value:

  TRUE if ExtraDataBuffer was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraDataBuffer,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
EnumFirstHashTableStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  EnumFirstHashTableString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringA (EnumPtr);
}


BOOL
EnumFirstHashTableStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return EnumNextHashTableStringW (EnumPtr);
}


BOOL
EnumNextHashTableStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  EnumNextHashTableString continues an enumeration started by
  EnumFirstHashTableString.  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
EnumNextHashTableStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


VOID
AbortHashTableEnumA (
    IN      PHASHTABLE_ENUMA EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM nextItem;
    PBUCKETITEM prevItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PoolMemReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));
}


VOID
AbortHashTableEnumW (
    IN      PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM prevItem;
    PBUCKETITEM nextItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                PoolMemReleaseMemory (table->Pool, item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));
}


BOOL
EnumHashTableWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  EnumHashTableWithCallback implements a setupapi-style enumerator.  The
  callback routine is called for each item in the string table, and if the
  callback routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumA (&e);
                break;
            }
        } while (EnumNextHashTableStringA (&e));
    }

    return TRUE;
}


BOOL
EnumHashTableWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (EnumFirstHashTableStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumW (&e);
                break;
            }
        } while (EnumNextHashTableStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


BOOL
HtIsEmpty (
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    return (table->FirstLink == NULL);
}


BOOL
HtWriteToFile (
    IN      HASHTABLE HashTable,
    IN      HANDLE OutputFile,
    IN      HASHTABLEOUTPUTFLAGS Flags
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    BOOL result = FALSE;
    DWORD bytesWritten;
    PBUCKETITEM item;
    PCWSTR unicodeStr;
    PCSTR ansiStr;
    DWORD dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    __try {
        if (Flags & WRITE_UNICODE_HEADER) {
            if (table->Unicode) {
                if ((!WriteFile (OutputFile, "\xff\xfe", 2, &bytesWritten, NULL)) ||
                    (bytesWritten != 2)
                    ) {
                    DEBUGMSG ((DBG_ERROR, "Error writing hash table to output file"));
                    __leave;
                }
            }
        }

        if (Flags & REVERSE_ORDER) {
            item = table->LastLink;
        } else {
            item = table->FirstLink;
        }

        while (item) {

            if (table->Unicode) {

                unicodeStr = HtGetStringFromItemW (item);

                if (!WriteFile (OutputFile, unicodeStr, ByteCountW (unicodeStr), &dontCare, NULL)) {
                    __leave;
                }

                if (!WriteFile (OutputFile, L"\r\n", 4, &dontCare, NULL)) {
                    __leave;
                }

            } else {

                ansiStr = HtGetStringFromItemA (item);

                if (!WriteFile (OutputFile, ansiStr, ByteCountA (ansiStr), &dontCare, NULL)) {
                    __leave;
                }

                if (!WriteFile (OutputFile, "\r\n", 2, &dontCare, NULL)) {
                    __leave;
                }

            }

            if (Flags & REVERSE_ORDER) {
                item = item->PrevLink;
            } else {
                item = item->NextLink;
            }
        }

        result = TRUE;
    }
    __finally {
    }

    return result;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\icons.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    icons.c

Abstract:

    Icon extraction and manipulation routines

Author:

    Jim Schmidt (jimschm)   04-May-1998

Revision History:

    jimschm     23-Sep-1998 String icon ID bug fixes, error path bug fixes

--*/

#include "pch.h"
#include "migutilp.h"

#define MAX_RESOLUTIONS     32      // 8 sizes times 4 color palettes

#pragma pack(push)
#pragma pack(2)

typedef struct {
    BYTE        Width;          // Width, in pixels, of the image
    BYTE        Height;         // Height, in pixels, of the image
    BYTE        ColorCount;     // Number of colors in image (0 if >=8bpp)
    BYTE        Reserved;       // Reserved ( must be 0)
    WORD        Planes;         // Color Planes
    WORD        BitCount;       // Bits per pixel
    DWORD       BytesInRes;     // How many bytes in this resource?
    DWORD       ImageOffset;    // Where in the file is this image?
} ICONDIRENTRY, *PICONDIRENTRY;

typedef struct {
    WORD           Reserved;   // Reserved (must be 0)
    WORD           Type;       // Resource Type (1 for icons)
    WORD           Count;      // How many images?
    ICONDIRENTRY   Entries[1]; // An entry for each image (idCount of 'em)
} ICONDIR, *PICONDIR;

typedef struct {
    BYTE   Width;               // Width, in pixels, of the image
    BYTE   Height;              // Height, in pixels, of the image
    BYTE   ColorCount;          // Number of colors in image (0 if >=8bpp)
    BYTE   Reserved;            // Reserved
    WORD   Planes;              // Color Planes
    WORD   BitCount;            // Bits per pixel
    DWORD  BytesInRes;          // how many bytes in this resource?
    WORD   ID;                  // the ID
} GRPICONDIRENTRY, *PGRPICONDIRENTRY;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
    GRPICONDIRENTRY  Entries[1]; // The entries for each image
} GRPICONDIR, *PGRPICONDIR;

typedef struct {
    WORD             Reserved;   // Reserved (must be 0)
    WORD             Type;       // Resource type (1 for icons)
    WORD             Count;      // How many images?
} GRPICONDIRBASE, *PGRPICONDIRBASE;

#pragma pack( pop )

#define PICONIMAGE PBYTE


BOOL
ReadBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    )
{
    DWORD BytesRead;

    if(File == INVALID_HANDLE_VALUE || !Buffer || !Size){
        MYASSERT(File != INVALID_HANDLE_VALUE);
        MYASSERT(Buffer);
        MYASSERT(Size);
        return FALSE;
    }

    if (!ReadFile (File, Buffer, Size, &BytesRead, NULL)) {
        return FALSE;
    }

    return Size == BytesRead;
}


BOOL
pWriteBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    )
{
    DWORD BytesWritten;

    if(File == INVALID_HANDLE_VALUE || !Buffer || !Size){
        MYASSERT(File != INVALID_HANDLE_VALUE);
        MYASSERT(Buffer);
        MYASSERT(Size);
        return FALSE;
    }

    if (!WriteFile (File, Buffer, Size, &BytesWritten, NULL)) {
        return FALSE;
    }

    return Size == BytesWritten;
}



UINT
Power (
    UINT x,
    UINT e
    )
{
    UINT r;

    r = 1;

    while (e > 0) {
        r = r * x;
        e--;
    }

    return r;
}


UINT
pComputeSizeOfIconImage (
    IN      PICONIMAGE IconImage
    )
{
    PBITMAPINFOHEADER Header;
    UINT Size;
    UINT Bits;
    UINT Colors;
    UINT BytesInImage;

    MYASSERT(IconImage);

    Header = (PBITMAPINFOHEADER) IconImage;

    Size = Header->biSize;

    Bits = Header->biBitCount * Header->biPlanes;
    if (Bits > 32) {
        Bits = 4;
    }

    Colors = Power (2, Bits);

    if (Bits < 24) {
        Size += Colors * sizeof (RGBQUAD);
    }

    BytesInImage = (Header->biWidth + 7) / 8 * (Header->biHeight / 2);
    Size += BytesInImage * Bits;     // XOR mask

    //
    // The following computation is very strange, but it was added based on
    // test comparisons.
    //

    if (Header->biWidth == 32) {
        Size += BytesInImage;     // AND mask
    } else {
        Size += BytesInImage + Header->biHeight;     // AND mask plus who knows what
    }

    MYASSERT (Size);

    return Size;
}


BOOL
pAddIconImagesToGrowBuffer (
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PICONDIRENTRY IconDirEntryBase,
    IN      WORD Count,
    IN      DWORD Pos,
    IN      DWORD Size
    )
{
    WORD w;
    PICONDIRENTRY IconDirEntry;
    PBYTE Dest;
    DWORD Offset;

    MYASSERT(Buffer);
    MYASSERT(File != INVALID_HANDLE_VALUE);
    MYASSERT(IconDirEntryBase);

    for (w = 0 ; w < Count ; w++) {
        IconDirEntry = &IconDirEntryBase[w];
        MYASSERT(File);

        Offset = IconDirEntry->ImageOffset & 0x0fffffff;

        if (Offset < Pos || Offset >= Size) {
            return FALSE;
        }

        SetFilePointer (File, Offset, NULL, FILE_BEGIN);

        Dest = GrowBuffer (Buffer, IconDirEntry->BytesInRes);
        if (!Dest) {
            return FALSE;
        }

        if (!ReadBinaryBlock (File, Dest, IconDirEntry->BytesInRes)) {
            return FALSE;
        }

        if (IconDirEntry->BytesInRes != pComputeSizeOfIconImage (Dest)) {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
pGetIconImageArrayFromIcoFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    BOOL b = FALSE;
    ICONDIR IconDir;
    PICONDIRENTRY IconDirEntryBase = NULL;
    DWORD Size;
    DWORD Pos;
    UINT IconDirEntrySize;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);
    MYASSERT(File != INVALID_HANDLE_VALUE);

    Size = GetFileSize (File, NULL);
    SetFilePointer (File, 0, NULL, FILE_BEGIN);

    Buffer->End = 0;

    __try {
        if (!ReadBinaryBlock (File, &IconDir, sizeof (WORD) * 3)) {
            __leave;
        }

        IconDirEntrySize = (UINT) IconDir.Count * sizeof (ICONDIRENTRY);

        if (IconDirEntrySize > (UINT) Size) {
            __leave;
        }

        IconDirEntryBase = (PICONDIRENTRY) MemAlloc (g_hHeap, 0, IconDirEntrySize);
        if (!IconDirEntryBase) {
            MYASSERT(IconDirEntryBase);
            __leave;
        }

        if (!ReadBinaryBlock (File, IconDirEntryBase, IconDirEntrySize)) {
            __leave;
        }

        Pos = SetFilePointer (File, 0, NULL, FILE_CURRENT);

        if (!pAddIconImagesToGrowBuffer (Buffer, File, IconDirEntryBase, IconDir.Count, Pos, Size)) {
            DEBUGMSG ((DBG_WARNING, "Icon file %ls has a bogus offset", ModuleContainingIcon));
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (IconDirEntryBase) {
            MemFree (g_hHeap, 0, IconDirEntryBase);
        }
    }

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    PCWSTR UnicodeFileName;
    BOOL b;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);
    MYASSERT(File != INVALID_HANDLE_VALUE);

    UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
    if (!UnicodeFileName) {
        MYASSERT(UnicodeFileName);
        return FALSE;
    }

    b = pGetIconImageArrayFromIcoFileExW (UnicodeFileName, Buffer, File);

    PushError();
    FreeConvertedStr (UnicodeFileName);
    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    File = CreateFileW (ModuleContainingIcon, GENERIC_READ, 0, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%ls could not be opened", ModuleContainingIcon));
        return FALSE;
    }

    __try {

        b = pGetIconImageArrayFromIcoFileExW (ModuleContainingIcon, Buffer, File);

    }
    __finally {
        CloseHandle (File);
    }

    return b;
}


BOOL
pGetIconImageArrayFromIcoFileA (
    IN      PCSTR ModuleContainingIcon,
    IN OUT  PGROWBUFFER Buffer
    )
{
    PCWSTR UnicodeFileName;
    BOOL b;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
    if (!UnicodeFileName) {
        MYASSERT(UnicodeFileName);
        return FALSE;
    }

    b = pGetIconImageArrayFromIcoFileW (UnicodeFileName, Buffer);

    PushError();
    FreeConvertedStr (UnicodeFileName);
    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromBinaryExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE Library,
    IN      HANDLE Library16
    )
{
    HRSRC ResourceHandle;
    HGLOBAL ResourceBlock;
    PBYTE ResourceData;
    DWORD ResourceSize;
    PBYTE Dest;
    BOOL b = FALSE;
    PGRPICONDIR GroupIconDir;
    WORD w;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    if (!GroupIconId) {
        return FALSE;
    }

    __try {

        Buffer->End = 0;

        if (Library) {

            //
            // Get icon from PE file
            //

            ResourceHandle = FindResourceW (Library, GroupIconId, (PCWSTR) RT_GROUP_ICON);
            if (!ResourceHandle) {
                __leave;
            }

            ResourceBlock = LoadResource (Library, ResourceHandle);
            if (!ResourceBlock) {
                __leave;
            }

            GroupIconDir = (PGRPICONDIR) LockResource (ResourceBlock);
            if (!GroupIconDir) {
                __leave;
            }

            if (GroupIconDir->Type != 1) {
                DEBUGMSGW_IF ((
                    (UINT_PTR) GroupIconId < 0x10000,
                    DBG_ERROR,
                    "icon type for resource %u is not 1 in %s",
                    GroupIconId,
                    ModuleContainingIcon
                    ));
                DEBUGMSGW_IF ((
                    (UINT_PTR) GroupIconId >= 0x10000,
                    DBG_ERROR,
                    "icon type for resource %s is not 1 in %s",
                    GroupIconId,
                    ModuleContainingIcon
                    ));
                __leave;
            }

            if (GroupIconDir->Count > MAX_RESOLUTIONS) {
                DEBUGMSGW ((DBG_ERROR, "%u resolutions found in %s", GroupIconDir->Count, ModuleContainingIcon));
                __leave;
            }

            //
            // Add the ICONIMAGE array to the grow buffer
            //

            for (w = 0 ; w < GroupIconDir->Count ; w++) {

                ResourceHandle = FindResourceW (
                                     Library,
                                     (PCWSTR) (GroupIconDir->Entries[w].ID),
                                     (PCWSTR) RT_ICON
                                     );

                if (ResourceHandle) {
                    ResourceBlock = LoadResource (Library, ResourceHandle);
                    if (!ResourceBlock) {
                        continue;
                    }

                    ResourceData = (PBYTE) LockResource (ResourceBlock);
                    if (!ResourceData) {
                        continue;
                    }

                    ResourceSize = pComputeSizeOfIconImage ((PICONIMAGE) ResourceData);
                    if (!ResourceSize) {
                        DEBUGMSG ((DBG_WARNING, "Zero-length icon in %s", ModuleContainingIcon));
                        continue;
                    }


                    if (ResourceSize > 0x10000) {
                        // too big for an icon
                        __leave;
                    }

                    Dest = GrowBuffer (Buffer, ResourceSize);
                    if (!Dest) {
                        __leave;
                    }

                    CopyMemory (Dest, ResourceData, ResourceSize);
                }
                ELSE_DEBUGMSG ((DBG_WARNING, "Indexed icon could not be loaded from resource"));
            }
        }

        else if (Library16) {
            //
            // Get icon from NE file
            //

            GroupIconDir = (PGRPICONDIR) FindNeResourceExW (Library16, (PCWSTR) RT_GROUP_ICON, GroupIconId);
            if (!GroupIconDir) {
                DEBUGMSG ((DBG_WHOOPS, "NE group icon %u not found", GroupIconId));
                __leave;
            }

            DEBUGMSG_IF ((GroupIconDir->Count > MAX_RESOLUTIONS, DBG_WHOOPS, "%u resolutions found in %hs", GroupIconDir->Count, ModuleContainingIcon));

            //
            // Add the ICONIMAGE array to the grow buffer
            //

            for (w = 0 ; w < GroupIconDir->Count ; w++) {

                ResourceData = FindNeResourceExA (
                                     Library16,
                                     (PCSTR) RT_ICON,
                                     (PCSTR) GroupIconDir->Entries[w].ID
                                     );

                if (!ResourceData) {
                    DEBUGMSG ((DBG_WHOOPS, "NE Icon ID %u not found", GroupIconDir->Entries[w].ID));
                    __leave;
                }

                ResourceSize = pComputeSizeOfIconImage ((PICONIMAGE) ResourceData);
                if (!ResourceSize) {
                    DEBUGMSG ((DBG_WARNING, "Zero-length icon in %s", ModuleContainingIcon));
                    continue;
                }

                if (ResourceSize > 0x10000) {
                    // too big for an icon
                    __leave;
                }

                Dest = GrowBuffer (Buffer, ResourceSize);
                if (!Dest) {
                    __leave;
                }

                CopyMemory (Dest, ResourceData, ResourceSize);
            }
        }

        b = TRUE;
    }
    __finally {
        // empty
    }

    return b;
}


BOOL
pGenerateUnicodeArgs (
    IN      PCSTR ModuleContainingIcon,         OPTIONAL
    IN      PCSTR GroupIconId,                  OPTIONAL
    OUT     PCWSTR *UnicodeFileName,            OPTIONAL
    OUT     PCWSTR *UnicodeGroupIconId          OPTIONAL
    )
{
    if (UnicodeFileName) {
        if (ModuleContainingIcon) {
            *UnicodeFileName = ConvertAtoW (ModuleContainingIcon);
            if (!(*UnicodeFileName)) {
                return FALSE;
            }
        } else {
            *UnicodeFileName = NULL;
        }
    }

    if (UnicodeGroupIconId) {
        if (GroupIconId) {

            if ((UINT_PTR) GroupIconId > 0xffff) {

                *UnicodeGroupIconId = ConvertAtoW (GroupIconId);

                if (!(*UnicodeGroupIconId)) {
                    if (UnicodeFileName && *UnicodeFileName) {
                        FreeConvertedStr (*UnicodeFileName);
                    }
                    return FALSE;
                }

            } else {
                *UnicodeGroupIconId = (PCWSTR) GroupIconId;
            }

        } else {
            *UnicodeGroupIconId = NULL;
        }
    }

    return TRUE;
}



VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    )
{
    if (HIWORD (AnsiId)) {
        FreeConvertedStr (AnsiId);
    }
}


VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    )
{
    if (HIWORD (UnicodeId)) {
        FreeConvertedStr (UnicodeId);
    }
}


BOOL
pGetIconImageArrayFromBinaryExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE Library,
    IN      HANDLE Library16
    )
{
    PCWSTR UnicodeFileName;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    if (!pGenerateUnicodeArgs (
            ModuleContainingIcon,
            GroupIconId,
            &UnicodeFileName,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = pGetIconImageArrayFromBinaryExW (UnicodeFileName, UnicodeGroupIconId, Buffer, Library, Library16);

    PushError();

    FreeConvertedStr (UnicodeFileName);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}


BOOL
pGetIconImageArrayFromBinaryW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE Library;
    HANDLE Library16 = NULL;
    BOOL b = FALSE;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    Library = LoadLibraryExW (ModuleContainingIcon, NULL, LOAD_LIBRARY_AS_DATAFILE);

    __try {
        if (!Library) {

            Library16 = OpenNeFileW (ModuleContainingIcon);
            if (!Library16) {
                __leave;
            }
        }

        b = pGetIconImageArrayFromBinaryExW (ModuleContainingIcon, GroupIconId, Buffer, Library, Library16);

    }
    __finally {
        if (Library) {
            FreeLibrary (Library);
        }

        if (Library16) {
            CloseNeFile (Library16);
        }
    }

    return b;
}


BOOL
pGetIconImageArrayFromBinaryA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    HANDLE Library;
    HANDLE Library16 = NULL;
    BOOL b = FALSE;

    MYASSERT(ModuleContainingIcon);
    MYASSERT(Buffer);

    Library = LoadLibraryExA (ModuleContainingIcon, NULL, LOAD_LIBRARY_AS_DATAFILE);

    __try {
        if (!Library) {

            Library16 = OpenNeFileA (ModuleContainingIcon);
            if (!Library16) {
                __leave;
            }
        }

        b = pGetIconImageArrayFromBinaryExA (ModuleContainingIcon, GroupIconId, Buffer, Library, Library16);

    }
    __finally {
        if (Library) {
            FreeLibrary (Library);
        }

        if (Library16) {
            CloseNeFile (Library16);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileEx (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File
    )
{
    WORD w;
    BOOL b = FALSE;
    PICONIMAGE IconImage, IconImageEnd;
    PICONIMAGE p;
    INT ImageCount;
    ICONDIRENTRY Entry;
    PBITMAPINFOHEADER Header;
    UINT ColorCount;
    DWORD Offset;

    if (!Buffer || !Buffer->End) {
        MYASSERT(Buffer);
        return FALSE;
    }

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);

        //
        // Count the images
        //

        IconImage    = (PICONIMAGE) Buffer->Buf;
        IconImageEnd = (PICONIMAGE) (Buffer->Buf + Buffer->End);

        p = IconImage;
        ImageCount = 0;

        while (p < IconImageEnd) {
            ImageCount++;
            p = (PICONIMAGE) ((PBYTE) p + pComputeSizeOfIconImage (p));
        }

        //
        // Write the icon header
        //

        w = 0;      // reserved
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        w = 1;      // type (1 == icon)
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        w = (WORD) ImageCount;
        if (!pWriteBinaryBlock (File, &w, sizeof (WORD))) {
            __leave;
        }

        //
        // For each icon image, write the directory entry
        //

        p = IconImage;
        Offset = 0;

        while (p < IconImageEnd) {

            ZeroMemory (&Entry, sizeof (Entry));

            Header = (PBITMAPINFOHEADER) p;
            Entry.Width = (BYTE) Header->biWidth;
            Entry.Height = (BYTE) Header->biHeight / 2;

            ColorCount = Header->biPlanes * Header->biBitCount;
            if (ColorCount >= 8) {
                Entry.ColorCount = 0;
            } else {
                Entry.ColorCount = (BYTE) Power (2, ColorCount);
            }

            Entry.Planes = Header->biPlanes;
            Entry.BitCount = Header->biBitCount;
            Entry.BytesInRes = pComputeSizeOfIconImage (p);
            Entry.ImageOffset = sizeof (WORD) * 3 + sizeof (Entry) * ImageCount + Offset;

            if (!pWriteBinaryBlock (File, &Entry, sizeof (Entry))) {
                __leave;
            }

            Offset += Entry.BytesInRes;

            p = (PICONIMAGE) ((PBYTE) p + Entry.BytesInRes);
        }

        //
        // Write the image array
        //

        if (!pWriteBinaryBlock (File, IconImage, Buffer->End)) {
            __leave;
        }

        b = TRUE;

    }
    __finally {
        // empty
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    if (!DestinationFile || !Buffer || !Buffer->End) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;
    }

    File = CreateFileW (DestinationFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%ls could not be created", DestinationFile));
        return FALSE;
    }

    __try {
        b = WriteIconImageArrayToIcoFileEx (Buffer, File);
    }
    __finally {
        CloseHandle (File);
        if (!b) {
            DeleteFileW (DestinationFile);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToIcoFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer
    )
{
    HANDLE File;
    BOOL b = FALSE;

    if (!DestinationFile || !Buffer || !Buffer->End) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;
    }

    File = CreateFileA (DestinationFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (File == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_WARNING, "%hs could not be created", DestinationFile));
        return FALSE;
    }

    __try {
        b = WriteIconImageArrayToIcoFileEx (Buffer, File);
    }
    __finally {
        CloseHandle (File);
        if (!b) {
            DeleteFileA (DestinationFile);
        }
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileExW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    )
{
    BOOL b = FALSE;
    GROWBUFFER GroupIcon = GROWBUF_INIT;
    PGRPICONDIRBASE IconDir;
    PGRPICONDIRENTRY Entry;
    PICONIMAGE IconImage, IconImageEnd;
    PICONIMAGE p;
    PBITMAPINFOHEADER Header;
    UINT ColorCount;

    if (!DestinationFile || !Buffer) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;
    }

    if (!Buffer->End) {
        return TRUE;
    }

    __try {
        //
        // Make a group icon directory for all icon images in Buffer
        //

        IconDir = (PGRPICONDIRBASE) GrowBuffer (&GroupIcon, sizeof (GRPICONDIRBASE));
        if (!IconDir) {
            __leave;
        }

        IconDir->Reserved = 0;
        IconDir->Type = 1;
        IconDir->Count = 0;

        IconImage    = (PICONIMAGE) Buffer->Buf;
        IconImageEnd = (PICONIMAGE) (Buffer->Buf + Buffer->End);

        p = IconImage;
        while (p < IconImageEnd) {

            Entry = (PGRPICONDIRENTRY) GrowBuffer (&GroupIcon, sizeof (GRPICONDIRENTRY));
            if (!Entry) {
                __leave;
            }

            Header = (PBITMAPINFOHEADER) p;

            Entry->Width = (BYTE) Header->biWidth;
            Entry->Height = (BYTE) Header->biHeight / 2;

            ColorCount = Header->biPlanes * Header->biBitCount;
            if (ColorCount >= 8) {
                Entry->ColorCount = 0;
            } else {
                Entry->ColorCount = (BYTE) Power (2, ColorCount);
            }

            Entry->Planes = Header->biPlanes;
            Entry->BitCount = Header->biBitCount;
            Entry->BytesInRes = pComputeSizeOfIconImage (p);

            if (!NextIconId) {
                Entry->ID = 1 + (WORD) ((UINT_PTR) GroupIconId & (0xffff / MAX_RESOLUTIONS)) * MAX_RESOLUTIONS + IconDir->Count;
            } else {
                Entry->ID = *NextIconId;
            }

            //
            // Add icon to the PE file
            //

            b = UpdateResourceA (
                    UpdateHandle,
                    RT_ICON,
                    MAKEINTRESOURCE(Entry->ID),
                    MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                    p,
                    Entry->BytesInRes
                    );

            if (!b) {
                LOGA ((LOG_ERROR, "Could not add icon to %s", DestinationFile));
                __leave;
            }

            IconDir->Count += 1;
            if (NextIconId) {
                *NextIconId += 1;
            }

            p = (PICONIMAGE) ((PBYTE) p + Entry->BytesInRes);
        }

        //
        // Add the group icon to the PE
        //

        b = UpdateResourceW (
                UpdateHandle,
                (PCWSTR) RT_GROUP_ICON,
                GroupIconId,
                MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                GroupIcon.Buf,
                GroupIcon.End
                );

        if (!b) {
            LOGA ((LOG_ERROR, "Unable to add icon to %s", DestinationFile));
            __leave;
        }

        b = TRUE;
    }
    __finally {
        FreeGrowBuffer (&GroupIcon);
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileExA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId,
    IN      PWORD NextIconId,            OPTIONAL
    IN      HANDLE UpdateHandle
    )
{
    PCWSTR UnicodeDestinationFile;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    if (!DestinationFile || !Buffer) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;//BUGBUG: TRUE or FALSE?????
    }

    if (!pGenerateUnicodeArgs (
            DestinationFile,
            GroupIconId,
            &UnicodeDestinationFile,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = WriteIconImageArrayToPeFileExW (
            UnicodeDestinationFile,
            Buffer,
            UnicodeGroupIconId,
            NextIconId,
            UpdateHandle
            );

    PushError();

    FreeConvertedStr (UnicodeDestinationFile);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}


BOOL
WriteIconImageArrayToPeFileW (
    IN      PCWSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCWSTR GroupIconId
    )
{
    HANDLE UpdateHandle = NULL;
    BOOL b = FALSE;

    if (!DestinationFile || !Buffer) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;//BUGBUG: TRUE or FALSE?????
    }

    if (!Buffer->End) {
        return TRUE;
    }

    __try {
        //
        // Open PE file for update
        //

        UpdateHandle = BeginUpdateResourceW (DestinationFile, FALSE);

        if (!UpdateHandle) {
            LOGW ((LOG_ERROR, "Unable to begin resource update of %s", DestinationFile));
            __leave;
        }

        //
        // Update the PE file
        //

        b = WriteIconImageArrayToPeFileExW (DestinationFile, Buffer, (PCWSTR) GroupIconId, NULL, UpdateHandle);
    }
    __finally {
        EndUpdateResource (UpdateHandle, !b);
    }

    return b;
}


BOOL
WriteIconImageArrayToPeFileA (
    IN      PCSTR DestinationFile,
    IN      PGROWBUFFER Buffer,
    IN      PCSTR GroupIconId
    )
{
    PCWSTR UnicodeDestinationFile;
    PCWSTR UnicodeGroupIconId;
    BOOL b;

    if (!DestinationFile || !Buffer) {
        MYASSERT(DestinationFile);
        MYASSERT(Buffer);
        return FALSE;//BUGBUG: TRUE or FALSE?????
    }

    if (!pGenerateUnicodeArgs (
            DestinationFile,
            GroupIconId,
            &UnicodeDestinationFile,
            &UnicodeGroupIconId
            )) {
        return FALSE;
    }

    b = WriteIconImageArrayToPeFileW (
            UnicodeDestinationFile,
            Buffer,
            UnicodeGroupIconId
            );

    PushError();

    FreeConvertedStr (UnicodeDestinationFile);
    DestroyUnicodeResourceId (UnicodeGroupIconId);

    PopError();

    return b;
}

BOOL
IsFileAnIcoW (
    IN      PCWSTR FileInQuestion
    )
{
    PCWSTR p;
    DWORD magic;
    DWORD bytesRead;
    HANDLE icoFileHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    if (!FileInQuestion) {
        MYASSERT(FileInQuestion);
        return FALSE;
    }

    p = wcsrchr (FileInQuestion, L'.');

    if (p) {
        if (StringIMatchW (p, L".ico")) {
            return TRUE;
        }
    }

    icoFileHandle = CreateFileW (
                        FileInQuestion,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if (icoFileHandle != INVALID_HANDLE_VALUE) {

        if (ReadFile (icoFileHandle, (PBYTE)(&magic), sizeof (magic), &bytesRead, NULL)) {
            if (bytesRead == sizeof (magic)) {
                if (magic != IMAGE_DOS_SIGNATURE) {
                    result = TRUE;
                }
            }
        }

        CloseHandle (icoFileHandle);
    }

    return result;
}


BOOL
IsFileAnIcoA (
    IN      PCSTR FileInQuestion
    )
{
    PCSTR p;
    WORD magic;
    DWORD bytesRead;
    HANDLE icoFileHandle = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;

    if (!FileInQuestion) {
        MYASSERT(FileInQuestion);
        return FALSE;
    }

    p = _mbsrchr (FileInQuestion, '.');

    if (p) {
        if (StringIMatchA (p, ".ico")) {
            return TRUE;
        }
    }

    icoFileHandle = CreateFileA (
                        FileInQuestion,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if (icoFileHandle != INVALID_HANDLE_VALUE) {

        if (ReadFile (icoFileHandle, (PBYTE)(&magic), sizeof (magic), &bytesRead, NULL)) {
            if (bytesRead == sizeof (magic)) {
                if (magic != IMAGE_DOS_SIGNATURE) {
                    result = TRUE;
                }
            }
        }

        CloseHandle (icoFileHandle);
    }

    return result;
}


BOOL
ExtractIconImageFromFileExW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    )
{
    if(!ModuleContainingIcon){
        MYASSERT(ModuleContainingIcon);
        return FALSE;
    }

    if (IsFileAnIcoW (ModuleContainingIcon)) {
        if (IcoFileHandle) {
            return pGetIconImageArrayFromIcoFileExW (ModuleContainingIcon, Buffer, IcoFileHandle);
        } else {
            return pGetIconImageArrayFromIcoFileW (ModuleContainingIcon, Buffer);
        }
    }

    if (PeModuleHandle) {
        return pGetIconImageArrayFromBinaryExW (
                    ModuleContainingIcon,
                    GroupIconId,
                    Buffer,
                    PeModuleHandle,
                    NeModuleHandle
                    );
    } else {
        return pGetIconImageArrayFromBinaryW (ModuleContainingIcon, GroupIconId, Buffer);
    }
}


BOOL
ExtractIconImageFromFileExA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer,
    IN      HANDLE IcoFileHandle,       OPTIONAL
    IN      HANDLE PeModuleHandle,      OPTIONAL
    IN      HANDLE NeModuleHandle       OPTIONAL
    )
{
    if(!ModuleContainingIcon){
        MYASSERT(ModuleContainingIcon);
        return FALSE;
    }

    if (IsFileAnIcoA (ModuleContainingIcon)) {
        if (IcoFileHandle) {
            return pGetIconImageArrayFromIcoFileExA (ModuleContainingIcon, Buffer, IcoFileHandle);
        } else {
            return pGetIconImageArrayFromIcoFileA (ModuleContainingIcon, Buffer);
        }
    }

    if (PeModuleHandle) {
        return pGetIconImageArrayFromBinaryExA (
                    ModuleContainingIcon,
                    GroupIconId,
                    Buffer,
                    PeModuleHandle,
                    NeModuleHandle
                    );
    } else {
        return pGetIconImageArrayFromBinaryA (ModuleContainingIcon, GroupIconId, Buffer);
    }
}


BOOL
ExtractIconImageFromFileW (
    IN      PCWSTR ModuleContainingIcon,
    IN      PCWSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    MYASSERT(ModuleContainingIcon);

    return ExtractIconImageFromFileExW (
                ModuleContainingIcon,
                GroupIconId,
                Buffer,
                NULL,
                NULL,
                NULL
                );
}


BOOL
ExtractIconImageFromFileA (
    IN      PCSTR ModuleContainingIcon,
    IN      PCSTR GroupIconId,
    IN OUT  PGROWBUFFER Buffer
    )
{
    MYASSERT(ModuleContainingIcon);

    return ExtractIconImageFromFileExA (
                ModuleContainingIcon,
                GroupIconId,
                Buffer,
                NULL,
                NULL,
                NULL
                );
}


BOOL
CALLBACK
pEnumIconNameProcA (
    HANDLE Module,
    PCSTR Type,
    PSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCSTR Num;
    CHAR NumBuf[32];

    MYASSERT(lParam);

    Buf = (PGROWBUFFER) lParam;

    if ((UINT_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfA (NumBuf, "#%u", (UINT) (WORD) Name);
    }

    MultiSzAppendA (Buf, Num);
    return TRUE;
}


BOOL
CALLBACK
pEnumIconNameProcW (
    HANDLE Module,
    PCWSTR Type,
    PWSTR Name,
    LONG_PTR lParam
    )
{
    PGROWBUFFER Buf;
    PCWSTR Num;
    WCHAR NumBuf[32];

    MYASSERT(lParam);

    Buf = (PGROWBUFFER) lParam;

    if ((UINT_PTR) Name > 0xffff) {
        Num = Name;
    } else {
        Num = NumBuf;
        wsprintfW (NumBuf, L"#%u", (UINT) (WORD) Name);
    }

    MultiSzAppendW (Buf, Num);
    return TRUE;
}


PCSTR
ExtractIconNamesFromFileExA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    )
{
    PCSTR ReturnBuf;

    NameBuf->End = 0;

    if (Module) {
        if (!EnumResourceNamesA (Module, RT_GROUP_ICON, pEnumIconNameProcA, (LONG_PTR) NameBuf)) {
            return NULL;
        }
    } else if (Module16) {
        if (!EnumNeResourceNamesA (Module16, RT_GROUP_ICON, pEnumIconNameProcA, (LONG_PTR) NameBuf)) {
            return NULL;
        }
    } else {
        return NULL;
    }

    MultiSzAppendA (NameBuf, "");
    ReturnBuf = (PCSTR) NameBuf->Buf;

    return ReturnBuf;
}


PCWSTR
ExtractIconNamesFromFileExW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf,
    IN      HANDLE Module,
    IN      HANDLE Module16
    )
{
    PCWSTR ReturnBuf;

    NameBuf->End = 0;

    if (Module) {
        if (!EnumResourceNamesW (Module, (PCWSTR) RT_GROUP_ICON, pEnumIconNameProcW, (LONG_PTR) NameBuf)) {
            return NULL;
        }
    } else if (Module16) {
        if (!EnumNeResourceNamesW (Module16, (PWSTR) RT_GROUP_ICON, pEnumIconNameProcW, (LONG_PTR) NameBuf)) {
            return NULL;
        }
    } else {
        return NULL;
    }

    MultiSzAppendW (NameBuf, L"");
    ReturnBuf = (PCWSTR) NameBuf->Buf;

    return ReturnBuf;
}


PCSTR
ExtractIconNamesFromFileA (
    IN      PCSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    )
{
    HANDLE Module = NULL;
    HANDLE Module16 = NULL;
    PCSTR ReturnBuf = NULL;

    if(!ModuleContainingIcons){
        MYASSERT(ModuleContainingIcons);
        return NULL;
    }

    __try {
        Module = LoadLibraryExA (ModuleContainingIcons, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (!Module) {

            Module16 = OpenNeFileA (ModuleContainingIcons);
            if (!Module16) {
                DEBUGMSGA ((DBG_WARNING, "Can't load %s, error %u", ModuleContainingIcons, GetLastError()));
                __leave;
            }
        }

        ReturnBuf = ExtractIconNamesFromFileExA (ModuleContainingIcons, NameBuf, Module, Module16);

    }
    __finally {
        if (Module) {
            FreeLibrary (Module);
        }

        if (Module16) {
            CloseNeFile (Module16);
        }
    }

    return ReturnBuf;
}


PCWSTR
ExtractIconNamesFromFileW (
    IN      PCWSTR ModuleContainingIcons,
    IN OUT  PGROWBUFFER NameBuf
    )
{
    HANDLE Module = NULL;
    HANDLE Module16 = NULL;
    PCWSTR ReturnBuf = NULL;

    if(!ModuleContainingIcons){
        MYASSERT(ModuleContainingIcons);
        return NULL;
    }

    __try {
        Module = LoadLibraryExW (ModuleContainingIcons, NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (!Module) {

            Module16 = OpenNeFileW (ModuleContainingIcons);
            if (!Module16) {
                DEBUGMSGW ((DBG_WARNING, "Can't load %s, error %u", ModuleContainingIcons, GetLastError()));
                __leave;
            }
        }

        ReturnBuf = ExtractIconNamesFromFileExW (ModuleContainingIcons, NameBuf, Module, Module16);

    }
    __finally {
        if (Module) {
            FreeLibrary (Module);
        }

        if (Module16) {
            CloseNeFile (Module16);
        }
    }

    return ReturnBuf;
}


VOID
pInitContextA (
    PICON_EXTRACT_CONTEXTA Context
    )
{
    MYASSERT(Context);

    ZeroMemory (Context, sizeof (ICON_EXTRACT_CONTEXTA));
    Context->GroupId = 1;
    Context->IconId = 1;
    Context->IconImageFile = INVALID_HANDLE_VALUE;
}


VOID
pInitContextW (
    PICON_EXTRACT_CONTEXTW Context
    )
{
    MYASSERT(Context);

    ZeroMemory (Context, sizeof (ICON_EXTRACT_CONTEXTW));
    Context->GroupId = 1;
    Context->IconId = 1;
    Context->IconImageFile = INVALID_HANDLE_VALUE;
}


BOOL
BeginIconExtractionA (
    OUT     PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR DestFile                          OPTIONAL
    )
{
    MYASSERT(Context);

    pInitContextA (Context);

    if (DestFile) {
        Context->Update = BeginUpdateResourceA (DestFile, FALSE);

        if (!Context->Update) {
            LOGA ((LOG_ERROR, "Unable to begin resource update of %s", DestFile));
            return FALSE;
        }

        if(strlen(DestFile) >= ARRAYSIZE(Context->DestFile)){
            MYASSERT(strlen(DestFile) < ARRAYSIZE(Context->DestFile));
            return FALSE;
        }
        StringCopyA (Context->DestFile, DestFile);
    }

    return TRUE;
}


BOOL
BeginIconExtractionW (
    OUT     PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR DestFile                         OPTIONAL
    )
{
    MYASSERT(Context);

    pInitContextW (Context);

    if (DestFile) {
        Context->Update = BeginUpdateResourceW (DestFile, FALSE);

        if (!Context->Update) {
            LOGW ((LOG_ERROR, "Unable to begin resource update of %s", DestFile));
            return FALSE;
        }

        if(wcslen(DestFile) >= ARRAYSIZE(Context->DestFile)){
            MYASSERT(wcslen(DestFile) < ARRAYSIZE(Context->DestFile));
            return FALSE;
        }
        StringCopyW (Context->DestFile, DestFile);
    }

    return TRUE;
}


BOOL
pLoadBinaryImageA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR IconFile
    )
{
    MYASSERT(Context);
    MYASSERT(IconFile);

    if (Context->Module || Context->Module16) {
        if (StringIMatchA (Context->ModuleName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
        Context->Module = NULL;
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
        Context->Module16 = NULL;
    }

    Context->Module = LoadLibraryExA (IconFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Context->Module) {
        StringCopyA (Context->ModuleName, IconFile);
    } else {
        Context->Module16 = OpenNeFileA (IconFile);
        if (Context->Module16) {
            if(strlen(IconFile) >= ARRAYSIZE(Context->ModuleName)){
                MYASSERT(strlen(IconFile) < ARRAYSIZE(Context->ModuleName));
                return FALSE;
            }
            StringCopyA (Context->ModuleName, IconFile);
        } else {
            Context->ModuleName[0] = 0;
        }
    }

    return Context->Module != NULL || Context->Module16 != NULL;
}


BOOL
pLoadBinaryImageW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR IconFile
    )
{
    if (Context->Module || Context->Module16) {
        if (StringIMatchW (Context->ModuleName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
        Context->Module16 = NULL;
    }

    Context->Module = LoadLibraryExW (IconFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (Context->Module) {
        StringCopyW (Context->ModuleName, IconFile);
    } else {
        Context->Module16 = OpenNeFileW (IconFile);
        if (Context->Module16) {
            if(wcslen(IconFile) >= ARRAYSIZE(Context->ModuleName)){
                MYASSERT(wcslen(IconFile) < ARRAYSIZE(Context->ModuleName));
                return FALSE;
            }
            StringCopyW (Context->ModuleName, IconFile);
        } else {
            Context->ModuleName[0] = 0;
        }
    }

    return Context->Module != NULL || Context->Module16 != NULL;
}


BOOL
pOpenIcoFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR IconFile
    )
{
    MYASSERT(Context);
    MYASSERT(IconFile);

    if (Context->IcoFile) {
        if (StringIMatchA (Context->IcoFileName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->IcoFile) {
        CloseHandle (Context->IcoFile);
    }

    Context->IcoFile = CreateFileA (IconFile, GENERIC_READ, 0, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (Context->IcoFile == INVALID_HANDLE_VALUE) {
        Context->IcoFile = NULL;
        Context->IcoFileName[0] = 0;
    } else {
        if(strlen(IconFile) >= ARRAYSIZE(Context->IcoFileName)){
            MYASSERT(strlen(IconFile) < ARRAYSIZE(Context->IcoFileName));
            return FALSE;
        }
        StringCopyA (Context->IcoFileName, IconFile);
    }

    return Context->IcoFile != NULL;
}


BOOL
pOpenIcoFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR IconFile
    )
{
    MYASSERT(Context);
    MYASSERT(IconFile);

    if (Context->IcoFile) {
        if (StringIMatchW (Context->IcoFileName, IconFile)) {
            return TRUE;
        }
    }

    if (Context->IcoFile) {
        CloseHandle (Context->IcoFile);
    }

    Context->IcoFile = CreateFileW (IconFile, GENERIC_READ, 0, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (Context->IcoFile == INVALID_HANDLE_VALUE) {
        Context->IcoFile = NULL;
        Context->IcoFileName[0] = 0;
    } else {
        if(wcslen(IconFile) >= ARRAYSIZE(Context->IcoFileName)){
            MYASSERT(wcslen(IconFile) < ARRAYSIZE(Context->IcoFileName));
            return FALSE;
        }
        StringCopyW (Context->IcoFileName, IconFile);
    }

    return Context->IcoFile != NULL;
}


BOOL
pOpenIconImageA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    )
{
    MYASSERT(Context);
    MYASSERT(FileToOpen);

    if (Is16Bit) {
        *Is16Bit = FALSE;
    }

    if (IsFileAnIcoA (FileToOpen)) {
        if (IsIco) {
            *IsIco = TRUE;
        }

        return pOpenIcoFileA (Context, FileToOpen);
    }

    if (IsIco) {
        *IsIco = FALSE;
    }

    if (pLoadBinaryImageA (Context, FileToOpen)) {
        if (Context->Module16 && Is16Bit) {
            *Is16Bit = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
pOpenIconImageW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileToOpen,
    OUT     PBOOL IsIco,                        OPTIONAL
    OUT     PBOOL Is16Bit                       OPTIONAL
    )
{
    MYASSERT(Context);
    MYASSERT(FileToOpen);

    if (Is16Bit) {
        *Is16Bit = FALSE;
    }

    if (IsFileAnIcoW (FileToOpen)) {
        if (IsIco) {
            *IsIco = TRUE;
        }

        return pOpenIcoFileW (Context, FileToOpen);
    }

    if (IsIco) {
        *IsIco = FALSE;
    }

    if (pLoadBinaryImageW (Context, FileToOpen)) {
        if (Context->Module16 && Is16Bit) {
            *Is16Bit = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
OpenIconImageFileA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileName,
    IN      BOOL SaveMode
    )
{
    if(!Context || !FileName){
        MYASSERT(Context);
        MYASSERT(FileName);
        return FALSE;
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
        Context->IconImageFileName[0] = 0;
    }

    if (SaveMode) {
        Context->IconImageFile = CreateFileA (
                                    FileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    } else {
        Context->IconImageFile = CreateFileA (
                                    FileName,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        if(strlen(FileName) >= ARRAYSIZE(Context->IconImageFileName)){
            MYASSERT(strlen(FileName) < ARRAYSIZE(Context->IconImageFileName));
            return FALSE;
        }
        StringCopyA (Context->IconImageFileName, FileName);
        Context->SaveMode = SaveMode;
        return TRUE;
    }

    return FALSE;
}


BOOL
OpenIconImageFileW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileName,
    IN      BOOL SaveMode
    )
{
    if(!Context || !FileName){
        MYASSERT(Context);
        MYASSERT(FileName);
        return FALSE;
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
        Context->IconImageFileName[0] = 0;
    }

    if (SaveMode) {
        Context->IconImageFile = CreateFileW (
                                    FileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    } else {
        Context->IconImageFile = CreateFileW (
                                    FileName,
                                    GENERIC_READ,
                                    0,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        if(wcslen(FileName) >= ARRAYSIZE(Context->IconImageFileName)){
            MYASSERT(wcslen(FileName) < ARRAYSIZE(Context->IconImageFileName));
            return FALSE;
        }
        StringCopyW (Context->IconImageFileName, FileName);
        Context->SaveMode = SaveMode;
        return TRUE;
    }

    return FALSE;
}


BOOL
pGetIconImageArrayFromFileA (
    IN      PICON_EXTRACT_CONTEXTA Context
    )
{
    DWORD Size;
    PBYTE Dest;
    HANDLE File;

    MYASSERT(Context);

    File = Context->IconImageFile;

    if (!ReadBinaryBlock (File, &Size, sizeof (DWORD))) {
        return FALSE;
    }

    Context->IconImages.End = 0;

    Dest = GrowBuffer (&Context->IconImages, Size);
    if (!Dest) {
        return FALSE;
    }

    return ReadBinaryBlock (File, Dest, Size);
}


BOOL
pGetIconImageArrayFromFileW (
    IN      PICON_EXTRACT_CONTEXTW Context
    )
{
    DWORD Size;
    PBYTE Dest;
    HANDLE File;

    MYASSERT(Context);

    File = Context->IconImageFile;

    if (!ReadBinaryBlock (File, &Size, sizeof (DWORD))) {
        return FALSE;
    }

    Context->IconImages.End = 0;

    Dest = GrowBuffer (&Context->IconImages, Size);
    if (!Dest) {
        return FALSE;
    }

    return ReadBinaryBlock (File, Dest, Size);
}


BOOL
pPutIconImageArrayInFileA (
    IN      PICON_EXTRACT_CONTEXTA Context
    )
{
    HANDLE File;

    MYASSERT(Context);

    File = Context->IconImageFile;

    if (!Context->IconImages.End) {

        DEBUGMSGA_IF ((
            Context->ModuleName[0],
            DBG_WARNING,
            "Ignoring empty icon in %s",
            Context->ModuleName
            ));

        return TRUE;
    }

    if (!pWriteBinaryBlock (File, &Context->IconImages.End, sizeof (DWORD))) {
        return FALSE;
    }

    return pWriteBinaryBlock (File, Context->IconImages.Buf, Context->IconImages.End);
}


BOOL
pPutIconImageArrayInFileW (
    IN      PICON_EXTRACT_CONTEXTW Context
    )
{
    HANDLE File;

    MYASSERT(Context);

    File = Context->IconImageFile;

    if (!Context->IconImages.End) {

        DEBUGMSGW_IF ((
            Context->ModuleName[0],
            DBG_WARNING,
            "Ignoring empty icon in %s",
            Context->ModuleName
            ));

        return TRUE;
    }


    if (!pWriteBinaryBlock (File, &Context->IconImages.End, sizeof (DWORD))) {
        return FALSE;
    }

    return pWriteBinaryBlock (File, Context->IconImages.Buf, Context->IconImages.End);
}


PCSTR
pFindResourceIdFromIndexA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,
    IN      INT ResourceIndex,
    OUT     PSTR Buffer,
    IN      UINT BufferSize
    )
{
    PCSTR ImageList;

    MYASSERT(Context);
    MYASSERT(FileContainingIcon);
    MYASSERT(Buffer);
    MYASSERT(BufferSize);

    if (!pLoadBinaryImageA (Context, FileContainingIcon)) {
        return NULL;
    }

    if (ResourceIndex < 0) {
        MYASSERT(BufferSize > ARRAYSIZE("-2147483648\0"));
        wsprintfA (Buffer, "#%i", -ResourceIndex);
        return Buffer;
    } else {
        *Buffer = 0;
    }

    ImageList = ExtractIconNamesFromFileExA (
                    FileContainingIcon,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    while (ImageList) {
        if (!ResourceIndex) {
            if(BufferSize <= strlen(ImageList)){
                MYASSERT(BufferSize > strlen(ImageList));
                return NULL;
            }
            StringCopyA (Buffer, ImageList);
            break;
        }

        ResourceIndex--;
    }

    return *Buffer ? Buffer : NULL;
}


PCWSTR
pFindResourceIdFromIndexW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,
    IN      INT ResourceIndex,
    OUT     PWSTR Buffer,
    IN      UINT BufferSize
    )
{
    PCWSTR ImageList;

    MYASSERT(Context);
    MYASSERT(FileContainingIcon);
    MYASSERT(Buffer);
    MYASSERT(BufferSize);

    if (!pLoadBinaryImageW (Context, FileContainingIcon)) {
        return NULL;
    }

    if (ResourceIndex < 0) {
        MYASSERT(BufferSize > ARRAYSIZE("-2147483648\0"));
        wsprintfW (Buffer, L"#%i", -ResourceIndex);
        return Buffer;
    } else {
        *Buffer = 0;
    }

    ImageList = ExtractIconNamesFromFileExW (
                    FileContainingIcon,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    while (ImageList) {
        if (!ResourceIndex) {
            if(BufferSize <= wcslen(ImageList)){
                MYASSERT(BufferSize > wcslen(ImageList));
                return NULL;
            }
            StringCopyW (Buffer, ImageList);
            break;
        }

        ResourceIndex--;
    }

    return *Buffer ? Buffer : NULL;
}


BOOL
CopyIconA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcon,           OPTIONAL
    IN      PCSTR ResourceId,                   OPTIONAL
    IN      INT ResourceIndex                   OPTIONAL
    )
{
    BOOL IsIco;
    BOOL b;
    CHAR Buffer[256];

    if (!Context || Context->Error) {
        MYASSERT(Context);
        return FALSE;
    }

    if (!ResourceId && FileContainingIcon) {
        if (!IsFileAnIco (FileContainingIcon)) {
            ResourceId = pFindResourceIdFromIndexA (
                                Context,
                                FileContainingIcon,
                                ResourceIndex,
                                Buffer,
                                ARRAYSIZE(Buffer)
                                );

            if (!ResourceId) {
                return FALSE;
            }
        }
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
        !Context->SaveMode
        ) {
        //
        // Get icon image from the icon image array file
        //

        b =  pGetIconImageArrayFromFileA (Context);

    } else {
        //
        // Get icon image from source file
        //

        if (!pOpenIconImageA (Context, FileContainingIcon, &IsIco, NULL)) {
            return FALSE;
        }

        if (IsIco) {
            b = pGetIconImageArrayFromIcoFileExA (
                    Context->IcoFileName,
                    &Context->IconImages,
                    Context->IcoFile
                    );
        } else {

            b = pGetIconImageArrayFromBinaryExA (
                    Context->ModuleName,
                    ResourceId,
                    &Context->IconImages,
                    Context->Module,
                    Context->Module16
                    );
        }
    }

    if (b) {
        if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
            Context->SaveMode
            ) {

            //
            // Save icon to icon image array file
            //

            b = pPutIconImageArrayInFileA (Context);

        } else {

            //
            // Save icon to PE file
            //

            b = WriteIconImageArrayToPeFileExA (
                    Context->DestFile,
                    &Context->IconImages,
                    (PCSTR) Context->GroupId,
                    &Context->IconId,
                    Context->Update
                    );
        }

        if (!b) {
            Context->Error = TRUE;
        } else {
            Context->GroupId++;
        }
    }

    return b;
}


BOOL
CopyIconW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcon,           // OPTIONAL if using an icon image file
    IN      PCWSTR ResourceId,                   // OPTIONAL if FileContainingIcon is an ico
    IN      INT ResourceIndex                   OPTIONAL
    )
{
    BOOL IsIco;
    BOOL b;
    WCHAR Buffer[256];

    if (!Context || Context->Error) {
        MYASSERT(Context);
        return FALSE;
    }

    if (!ResourceId && FileContainingIcon) {
        if (!IsFileAnIcoW (FileContainingIcon)) {

            ResourceId = pFindResourceIdFromIndexW (
                                Context,
                                FileContainingIcon,
                                ResourceIndex,
                                Buffer,
                                ARRAYSIZE(Buffer)
                                );

            if (!ResourceId) {
                return FALSE;
            }
        }
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
        !Context->SaveMode
        ) {
        //
        // Get icon image from the icon image array file
        //

        b =  pGetIconImageArrayFromFileW (Context);

    } else {
        //
        // Get icon image from source file
        //

        if (!pOpenIconImageW (Context, FileContainingIcon, &IsIco, NULL)) {
            return FALSE;
        }

        if (IsIco) {
            b = pGetIconImageArrayFromIcoFileExW (
                    Context->IcoFileName,
                    &Context->IconImages,
                    Context->IcoFile
                    );
        } else {

            b = pGetIconImageArrayFromBinaryExW (
                    Context->ModuleName,
                    ResourceId,
                    &Context->IconImages,
                    Context->Module,
                    Context->Module16
                    );
        }
    }

    if (b) {
        if (Context->IconImageFile != INVALID_HANDLE_VALUE &&
            Context->SaveMode
            ) {

            //
            // Save icon to icon image array file
            //

            b = pPutIconImageArrayInFileW (Context);

        } else {

            //
            // Save icon to PE file
            //

            b = WriteIconImageArrayToPeFileExW (
                    Context->DestFile,
                    &Context->IconImages,
                    (PCWSTR) Context->GroupId,
                    &Context->IconId,
                    Context->Update
                    );
        }

        if (!b) {
            Context->Error = TRUE;
        } else {
            Context->GroupId++;
        }
    }

    return b;
}


BOOL
CopyAllIconsA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context,
    IN      PCSTR FileContainingIcons
    )
{
    MULTISZ_ENUMA e;
    BOOL IsIco;
    PCSTR IconList;
    BOOL b = TRUE;

    if (!Context || Context->Error) {
        MYASSERT(Context);
        return FALSE;
    }

    if(!FileContainingIcons){
        MYASSERT(FileContainingIcons);
        return FALSE;
    }

    if (!pOpenIconImageA (Context, FileContainingIcons, &IsIco, NULL)) {
        return FALSE;
    }

    if (IsIco) {
        return CopyIconA (Context, FileContainingIcons, NULL, 0);
    }

    IconList = ExtractIconNamesFromFileExA (
                    FileContainingIcons,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    if (!IconList) {
        return FALSE;
    }

    if (EnumFirstMultiSzA (&e, IconList)) {
        do {
            b = CopyIconA (Context, FileContainingIcons, e.CurrentString, 0);
            if (!b) {
                break;
            }

        } while (EnumNextMultiSzA (&e));
    }

    return b;
}


BOOL
CopyAllIconsW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context,
    IN      PCWSTR FileContainingIcons
    )
{
    MULTISZ_ENUMW e;
    BOOL IsIco;
    PCWSTR IconList;
    BOOL b = TRUE;

    if (!Context || Context->Error) {
        MYASSERT(Context);
        return FALSE;
    }

    if(!FileContainingIcons){
        MYASSERT(FileContainingIcons);
        return FALSE;
    }

    if (!pOpenIconImageW (Context, FileContainingIcons, &IsIco, NULL)) {
        return FALSE;
    }

    if (IsIco) {
        return CopyIconW (Context, FileContainingIcons, NULL, 0);
    }

    IconList = ExtractIconNamesFromFileExW (
                    FileContainingIcons,
                    &Context->IconList,
                    Context->Module,
                    Context->Module16
                    );

    if (!IconList) {
        return FALSE;
    }

    if (EnumFirstMultiSzW (&e, IconList)) {
        do {
            b = CopyIconW (Context, FileContainingIcons, e.CurrentString, 0);
            if (!b) {
                break;
            }

        } while (EnumNextMultiSzW (&e));
    }

    return b;
}


BOOL
EndIconExtractionA (
    IN OUT  PICON_EXTRACT_CONTEXTA Context
    )
{
    BOOL b = FALSE;

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    if (Context->Update) {
        b = EndUpdateResource (Context->Update, Context->Error);
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
    }

    if (Context->IcoFile) {
        FreeLibrary (Context->IcoFile);
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
    }

    FreeGrowBuffer (&Context->IconImages);

    FreeGrowBuffer (&Context->IconList);

    pInitContextA (Context);

    return b;
}


BOOL
EndIconExtractionW (
    IN OUT  PICON_EXTRACT_CONTEXTW Context
    )
{
    BOOL b = FALSE;

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    if (Context->Update) {
        b = EndUpdateResource (Context->Update, Context->Error);
    }

    if (Context->Module) {
        FreeLibrary (Context->Module);
    }

    if (Context->Module16) {
        CloseNeFile (Context->Module16);
    }

    if (Context->IcoFile) {
        FreeLibrary (Context->IcoFile);
    }

    if (Context->IconImageFile != INVALID_HANDLE_VALUE) {
        CloseHandle (Context->IconImageFile);
    }

    FreeGrowBuffer (&Context->IconImages);
    FreeGrowBuffer (&Context->IconList);

    pInitContextW (Context);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\inf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Provides wrappers for commonly used INF file handling routines. The wrappers provide, amount
    other things, easy memory allocation using a user supplied GROWBUFFER or POOLHANDLE

Author:

    09-Jul-1997 Marc R. Whitten (marcw) - File creation.

Revision History:

    07-Feb-2001  ovidiut  Revised the replace/append capability.
    22-Oct-1998  marcw    Added capability to replace/append inf files.
    08-Oct-1997  jimschm  OEM version of SetupGetStringField

--*/

#include "pch.h"

#define INF_REPLACE 1
#define INF_APPEND  2

#define S_VERSION_A     "Version"
#define S_TARGETINF_A   "TargetInf_2"
#define S_VERSION_W     L"Version"
#define S_LANGUAGE_W    L"Language"
#define S_STRINGS_W     L"Strings"
#define S_INFDIR_A      "inf"
#define S_TAG_A         "Tag"


#define INF_INVALID_VERSION 0xffff
#define INF_ANY_LANGUAGE 0

#define ASSERT_VALID_INF(handle) MYASSERT((handle) != INVALID_HANDLE_VALUE && (handle) != NULL)

UINT pGetLanguage (IN PCSTR File);


typedef struct _tagINFMOD {
    struct _tagINFMOD *Next;
    PCSTR TargetInf;
    DWORD Language;
    DWORD Version;
    PCSTR Tag;
    BOOL ReplacementFile;
    PCSTR PatchInf;
} INFMOD, *PINFMOD;


PINFMOD g_RootInfMod;
POOLHANDLE g_InfModPool;

VOID
InfGlobalInit (
    IN  BOOL Terminate
    )
{
    if (!Terminate) {
        g_InfModPool = PoolMemInitNamedPool ("INF Modifications");
    } else {
        MYASSERT(g_InfModPool);
        PoolMemDestroyPool (g_InfModPool);
        g_RootInfMod = NULL;
    }
}


/*++

Routine Description:

    pAllocateSpace is a private function that allocates space using the user specified allocator.

Arguments:

    Context - A valid INFSTRUCT which has been initialized either by a call to InitInfStruct or
              by using one of the static initializers (INITINFSTRUCT_GROWBUFFER or
              INITINFSTRUCT_POOLHANDLE)

    Size    - The size (in bytes) to allocate.

Return Value:

    A pointer to the successfully allocated memory or NULL if no memory could be allocated.

--*/

PBYTE
pAllocateSpaceA (
    IN PINFSTRUCTA  Context,
    IN UINT         Size
    )
{

    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using Poolmem.
        //
        rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GrowBuffer(&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_POOLHANDLE:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PoolMemInitNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        }
        break;
    default:
        return NULL;
    }

    MYASSERT(rBytes);

    return rBytes;
}

PBYTE
pAllocateSpaceW (
    IN PINFSTRUCTW  Context,
    IN UINT         Size
    )
{
    PBYTE rBytes = NULL;

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using Poolmem.
        //
        rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        break;

    case INF_USE_GROWBUFFER:
    case INF_USE_PRIVATE_GROWBUFFER:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using Growbuf.
        //
        Context->GrowBuffer.End = 0;
        rBytes = GrowBuffer(&(Context -> GrowBuffer), Size);
        break;

    case INF_USE_PRIVATE_POOLHANDLE:
        MYASSERT(Context);
        MYASSERT(Size);
        //
        // Allocate space using private growbuffer.
        //
        if (!Context -> PoolHandle) {
            Context -> PoolHandle = PoolMemInitNamedPool ("INF Pool");
        }
        if (Context -> PoolHandle) {
            rBytes = PoolMemGetMemory(Context -> PoolHandle, Size);
        }
        break;
    default:
        return NULL;
    }

    MYASSERT(rBytes);

    return rBytes;
}


/*++

Routine Description:

    This function initializes an INFSTRUCT with the user supplied allocator. It is used when
    user of the INF wrapper routines wishes to manage his own memory (i.e. such as when he
    already has a suitable allocator with sufficient scope created, etc.)

    There is no need to call this function if the user wishes to have the INF wrapper routines
    manage there own memory. Initialize your Init structure with one of either

    INITINFSTRUCT_POOLMEM or INITINFSTRUCT_GROWBUFFER, depending on your preference and needs
    for an allocator.



Arguments:

    Context      - Recieves the initialized INFSTRUCT.
    GrowBuffer   - An optional parameter containing a user supplied and initialized GROWBUFFER.
                   If this parameter is non-NULL, then PoolHandle should be NULL.
    PoolHandle   - An optional parameter containing a user supplied and initialized POOLHANDLE.
                   If this parameter is non-NULL, then GrowBuffer should be NULL.

    One of either GrowBuffer or PoolHandle *must* be specified.

Return Value:

    None.

--*/

VOID
InitInfStructA (
    OUT PINFSTRUCTA Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle   OPTIONAL
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    ZeroMemory(Context,sizeof(INFSTRUCTA));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_POOLHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_POOLHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}

VOID
InitInfStructW (
    OUT PINFSTRUCTW Context,
    IN  PGROWBUFFER GrowBuffer,  OPTIONAL
    IN  POOLHANDLE PoolHandle   OPTIONAL
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    ZeroMemory(Context,sizeof(INFSTRUCTW));

    if (!PoolHandle && !GrowBuffer) {
        Context  -> Allocator = INF_USE_PRIVATE_POOLHANDLE;
    }

    if (PoolHandle) {
        Context  -> PoolHandle = PoolHandle;
        Context  -> Allocator = INF_USE_POOLHANDLE;
    }
    if (GrowBuffer) {
        Context -> GrowBuffer = *GrowBuffer;
        Context -> Allocator = INF_USE_GROWBUFFER;
    }

}


/*++

Routine Description:

    InfCleanupInfStruct is responsible for cleaning up the data associated
    with an INFSTRUCT.  This is a mandatory call, unless the INFSTRUCT
    was initialized with InitInfStruct, called with a non-NULL grow buffer or
    pool handle.

    This routine can be called no matter how the INFSTRUCT was initialized.
    However, it will NOT free caller-owned grow buffers or pools.

Arguments:

    Context - Receives the properly cleaned up INFSTRUCT, ready to be
              reused.


Return Value:

     none

--*/

VOID
InfCleanUpInfStructA (
    IN OUT PINFSTRUCTA Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        FreeGrowBuffer (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_POOLHANDLE && Context -> PoolHandle) {
        PoolMemDestroyPool(Context -> PoolHandle);
    }

    InitInfStructA (Context, NULL, NULL);
}

VOID
InfCleanUpInfStructW (
    IN OUT PINFSTRUCTW Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    if (Context -> Allocator == INF_USE_PRIVATE_GROWBUFFER) {
        FreeGrowBuffer (&(Context -> GrowBuffer));
    }
    else if (Context -> Allocator == INF_USE_PRIVATE_POOLHANDLE && Context -> PoolHandle) {
        PoolMemDestroyPool(Context -> PoolHandle);
    }

    InitInfStructW (Context, NULL, NULL);
}


/*++

Routine Description:

  InfResetInfStruct resets the pool so memory can be recycled.  The intent is
  to allow a caller to reset the INFSTRUCT in order to release the memory
  obtained from getting INF fields.  This is useful in a loop of InfFindFirstLine/
  InfFindNextLine, where two or more fields are processed for each line.

  If only one field is processed in an InfFindFirstLine/InfFindNextLine loop,
  a grow buffer should be used instead.

  This routine empties the active pool block, a block that is 8K by default.  If
  more than the block size has been allocated, other memory blocks besides the
  active block will exist.  Because only the active block is reset, the pool will
  grow.

  If the caller expects more than the block size during one iteration, it should call
  InfCleanupInfStruct to free the pool completely.

Arguments:

  Context - Specifies the struct to reset


Return Value:

  none

--*/

VOID
InfResetInfStructA (
    IN OUT PINFSTRUCTA Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
    case INF_USE_PRIVATE_POOLHANDLE:
        if (Context->PoolHandle) {
            PoolMemEmptyPool (Context->PoolHandle);
        }
        break;
    }
}

VOID
InfResetInfStructW (
    IN OUT PINFSTRUCTW Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return;
    }

    switch (Context -> Allocator) {
    case INF_USE_POOLHANDLE:
    case INF_USE_PRIVATE_POOLHANDLE:
        if (Context->PoolHandle) {
            PoolMemEmptyPool (Context->PoolHandle);
        }
        break;
    }
}


VOID
pDeleteNode (
    IN      PINFMOD Node
    )
{
    if (Node) {
        if (Node->TargetInf) {
            PoolMemReleaseMemory (g_InfModPool, (PVOID)Node->TargetInf);
        }
        if (Node->Tag) {
            PoolMemReleaseMemory (g_InfModPool, (PVOID)Node->Tag);
        }
        if (Node->PatchInf) {
            PoolMemReleaseMemory (g_InfModPool, (PVOID)Node->PatchInf);
        }
        PoolMemReleaseMemory (g_InfModPool, Node);
    }
}


PINFMOD
pCreateInfMod (
    IN      PCSTR TargetInf,
    IN      DWORD Language,
    IN      DWORD Version,
    IN      PCSTR Tag,                              OPTIONAL
    IN      BOOL ReplacementFile,
    IN      PCSTR PatchInf
    )
{
    PINFMOD node;

    node = (PINFMOD) PoolMemGetAlignedMemory (g_InfModPool, sizeof (INFMOD));
    if (node) {
        node->Next = NULL;
        node->TargetInf = PoolMemDuplicateString (g_InfModPool, TargetInf);
        node->Language = Language;
        node->Version = Version;
        node->Tag = Tag ? PoolMemDuplicateString (g_InfModPool, Tag) : NULL;
        node->ReplacementFile = ReplacementFile;
        node->PatchInf = PoolMemDuplicateString (g_InfModPool, PatchInf);
    }
    return node;
}


BOOL
pAddReplacementInfToTable (
    IN PSTR InfToPatch,
    IN UINT Version,
    IN UINT Language,
    IN PCSTR Tag,                              OPTIONAL
    IN DWORD Operation,
    IN PCSTR PatchInf
    )
{
    PINFMOD node;

    node = pCreateInfMod (InfToPatch, Language, Version, Tag, Operation & INF_REPLACE, PatchInf);

    if (!node) {
        return FALSE;
    }

    node->Next = g_RootInfMod;
    g_RootInfMod = node;

    return TRUE;
}


BOOL
pGetInfModificationList (
    IN      PCSTR TargetInf,
    IN      UINT TargetLanguage,
    IN      UINT TargetVersion,
    IN      PCSTR Tag,                              OPTIONAL
    OUT     PCSTR* TargetReplacementFile,           OPTIONAL
    OUT     PGROWBUFFER TargetAppendList            OPTIONAL
    )
{
    PINFMOD node;
    UINT version;
    PCSTR patchInf;
    BOOL b = FALSE;

    if (TargetReplacementFile) {
        *TargetReplacementFile = NULL;
    }
    if (TargetAppendList) {
        TargetAppendList->End = 0;
    }

    if (TargetVersion == INF_INVALID_VERSION) {
        return FALSE;
    }

    version = TargetVersion;
    patchInf = NULL;

    for (node = g_RootInfMod; node; node = node->Next) {

        if (node->Version > version &&
            (node->Language == TargetLanguage || node->Language == INF_ANY_LANGUAGE) &&
            (!Tag || !node->Tag || StringIMatchA (node->Tag, Tag)) &&
            StringIMatchA (node->TargetInf, TargetInf)
            ) {

            if (node->ReplacementFile) {
                //
                // rev the version#; new minimum version will be that of the replacement file
                //
                version = node->Version;
                patchInf = node->PatchInf;
                b = TRUE;
            }
        }
    }

    if (TargetReplacementFile) {
        *TargetReplacementFile = patchInf;
    }

    //
    // for append nodes, add to the list only those that have a higher version than the
    // target or the replacement file
    //
    for (node = g_RootInfMod; node; node = node->Next) {

        if (node->Version > version &&
            (node->Language == TargetLanguage || node->Language == INF_ANY_LANGUAGE) &&
            (!Tag || !node->Tag || StringIMatchA (node->Tag, Tag)) &&
            StringIMatchA (node->TargetInf, TargetInf) &&
            !node->ReplacementFile
            ) {

            if (TargetAppendList) {
                MultiSzAppendA (TargetAppendList, node->PatchInf);
            }
            b = TRUE;
        }
    }
    if (TargetAppendList && TargetAppendList->End) {
        MultiSzAppendA (TargetAppendList, "");
    }

    return b;
}


VOID
pDestroyInfModList (
    IN      PINFMOD List
    )
{
    PINFMOD node, next;

    node = List;
    while (node) {
        next = node->Next;
        pDeleteNode (node);
        node = next;
    }
}


/*++

Routine Description:

    InfOpenInfFileA and InfOpenInfFileW are wrappers for the SetupOpenInfFile function.
    They cut down the number of parameters necessary to open an INF file by supplying
    the most common options for non-user specified parameters.

    A call to one of these functions is equivelant to
    SetupOpenInfFile(<FileName>,NULL,INF_STYLE_WIN4,NULL)

Arguments:

    FileName - Contains the name of the INF file to open. See the help for SetupOpenInfFile
               for special details concerning this parameter.

Return Value:

    If the INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
RealInfOpenInfFileA (
    IN PCSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR p;
    HINF rInf;
    UINT language;
    GROWBUFFER AppendList = GROWBUF_INIT;
    MULTISZ_ENUM e;
    UINT version;
    PCSTR replacementFile;
    CHAR windir[MAX_MBCHAR_PATH];
    CHAR buf[MAX_MBCHAR_PATH];
    PCSTR tag;
    PCSTR fullPath = NULL;

    if(!FileSpec){
        MYASSERT(FileSpec);
        return INVALID_HANDLE_VALUE;
    }

    //
    // if FileSpec is incomplete, make the full path first
    //
    if (!_mbschr (FileSpec, '\\')) {
        if (GetWindowsDirectoryA (windir, MAX_MBCHAR_PATH)) {
            WIN32_FIND_DATAA fd;
            p = JoinPathsA (windir, S_INFDIR_A);
            fullPath = JoinPathsA (p, FileSpec);
            FreePathStringA (p);
            if (!DoesFileExistExA (fullPath, &fd) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                ) {
                FreePathStringA (fullPath);
                if (GetSystemDirectoryA (windir, MAX_MBCHAR_PATH)) {
                    fullPath = JoinPathsA (windir, FileSpec);
                    if (!DoesFileExistExA (fullPath, &fd) ||
                        (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                        ) {
                        FreePathStringA (fullPath);
                        fullPath = NULL;
                    }
                }
            }
        }
        if (fullPath) {
            FileSpec = fullPath;
        }
    }

    //
    // gather info we'll need to determine if there are infs to replace/append
    // this inf.
    //
    p = GetFileNameFromPathA (FileSpec);

    language = pGetLanguage (FileSpec);
    version = GetPrivateProfileIntA (
                    S_VERSION_A,
                    S_VERSION_A,
                    INF_INVALID_VERSION,
                    FileSpec
                    );

    if (GetPrivateProfileStringA (
                    S_VERSION_A,
                    S_TAG_A,
                    TEXT(""),
                    buf,
                    MAX_MBCHAR_PATH,
                    FileSpec
                    )) {
        tag = buf;
    } else {
        tag = NULL;
    }

    if (!pGetInfModificationList (p, language, version, tag, &replacementFile, &AppendList)) {
        replacementFile = FileSpec;
    } else {
        if (replacementFile) {
            LOGA ((LOG_INFORMATION, "Using replacement file %s for %s", replacementFile, FileSpec));
        } else {
            replacementFile = FileSpec;
        }
    }

    //
    // Open the main inf.
    //
    rInf = SetupOpenInfFileA (
                replacementFile,
                NULL,
                INF_STYLE_WIN4 | INF_STYLE_OLDNT,
                NULL
                );

    //
    // Append language and non-language-specific .add files.
    //
    if (rInf != INVALID_HANDLE_VALUE) {
        if (EnumFirstMultiSzA (&e, (PCSTR) AppendList.Buf)) {
            do {

                if (!SetupOpenAppendInfFileA (e.CurrentString, rInf, NULL)) {
                    DEBUGMSGA ((
                        DBG_ERROR,
                        "Unable to append %s to %s.",
                        e.CurrentString,
                        FileSpec
                        ));
                } else {
                    LOGA ((LOG_INFORMATION, "Using append file %s for %s", e.CurrentString, FileSpec));
                }

            } while (EnumNextMultiSzA (&e));
        }
    }

    FreeGrowBuffer (&AppendList);

    if (rInf != INVALID_HANDLE_VALUE) {
        DebugRegisterAllocation (INF_HANDLE, (PVOID) rInf, File, Line);
    }
    if (fullPath) {
        FreePathStringA (fullPath);
    }

    return rInf;
}


HINF
RealInfOpenInfFileW (
    IN PCWSTR FileSpec /*,*/
    ALLOCATION_TRACKING_DEF
    )
{
    PCSTR AnsiFileSpec;
    HINF rInf;

    if(!FileSpec){
        MYASSERT(FileSpec);
        return INVALID_HANDLE_VALUE;
    }

    AnsiFileSpec = ConvertWtoA (FileSpec);
    MYASSERT (AnsiFileSpec);

    rInf = InfOpenInfFileA (AnsiFileSpec);

    FreeConvertedStr (AnsiFileSpec);

    return rInf;
}


VOID
InfCloseInfFile (
    HINF Inf
    )
{
    ASSERT_VALID_INF(Inf);

    DebugUnregisterAllocation (INF_HANDLE, Inf);

    SetupCloseInfFile (Inf);
}



/*++

Routine Description:

    InfOpenInfInAllSourcesA and InfOpenInfInAllSourcesW are special inf open routines that
    are capable of opening multiple versions of the same inf file that may be spread out across
    installation directories. The first INF file found will be opened with a call to
    SetupOpenInfFile. Additional files will be opened with SetupOpenAppendInfFile.

Arguments:

    InfSpecifier - Contains the source directory indepent portion of the path to a particular inf file.
                   For files located in the root of the source directory, this will simply be the name
                   of the file. For files located in a sub-directory of the source directory, this will
                   be a partial path.

    SourceCount  - Contains the number of source directories

    SourceDirectories - Contains an array of all the source directories.


Return Value:

    If any INF file is successfully opened, a valid HINF is returned, otherwise,
    INVALID_HANDLE_VALUE is returned. See the documentation for SetupOpenInfFile for more
    details.

--*/


HINF
InfOpenInfInAllSourcesA (
    IN PCSTR    InfSpecifier,
    IN DWORD    SourceCount,
    IN PCSTR  * SourceDirectories
    )
{
    DWORD           index;
    HINF            rInf = INVALID_HANDLE_VALUE;
    PSTR            curPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsA(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistA (curPath)) {

            //
            // Open the INF file.
            //
            rInf = InfOpenInfFileA(curPath);
            if (rInf == INVALID_HANDLE_VALUE) {
                LOGA ((LOG_ERROR, "Error opening INF %s.", curPath));
            }
        }

        //
        // Free this string.
        //
        FreePathStringA(curPath);

        if (rInf != INVALID_HANDLE_VALUE) {
            //
            // done
            //
            break;
        }
    }

    return rInf;
}



HINF
InfOpenInfInAllSourcesW (
    IN PCWSTR   InfSpecifier,
    IN DWORD    SourceCount,
    IN PCWSTR  *SourceDirectories
    )
{
    DWORD index;
    HINF rInf = INVALID_HANDLE_VALUE;
    PWSTR curPath;

    MYASSERT(InfSpecifier && SourceDirectories);

    //
    // Open all available inf files in the source directories.
    //
    for (index = 0;index < SourceCount; index++) {

        //
        // Create a path to the INF in the current source directory.
        //
        curPath = JoinPathsW(SourceDirectories[index],InfSpecifier);

        //
        // See if the INF file exists there...
        //
        if (DoesFileExistW (curPath)) {

            //
            // Open the INF file.
            //
            rInf = InfOpenInfFileW(curPath);
            if (rInf == INVALID_HANDLE_VALUE) {
                LOGW ((LOG_ERROR, "OpenInfInAllSources: Error opening INF %s.", curPath));
            }
        }

        //
        // Free this string.
        //
        FreePathStringW(curPath);

        if (rInf != INVALID_HANDLE_VALUE) {
            //
            // done
            //
            break;
        }
    }

    return rInf;
}



/*++

Routine Description:

    InfGetLineTextA and InfGetLineTextW are wrappers for the SetupGetLineText function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetLineTextA (
    IN OUT  PINFSTRUCTA Context
    )
{
    PSTR    rLine = NULL;
    UINT   requiredSize;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextA(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextA(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetLineTextA: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}

PWSTR
InfGetLineTextW (
    IN OUT PINFSTRUCTW Context
    )
{
    PWSTR rLine = NULL;
    UINT requiredSize;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetLineTextW(
        &(Context -> Context),
        NULL,
        NULL,
        NULL,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rLine = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rLine) {

            //
            // Get the field.
            //
            if (!SetupGetLineTextW(
                &(Context -> Context),
                NULL,
                NULL,
                NULL,
                rLine,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetLineTextW: Error retrieving field from INF file."));
                rLine = NULL;
            }
        }
    }


    return rLine;
}


/*++

Routine Description:

    InfGetMultiSzFieldA and InfGetMultiSzFieldW are wrappers for the SetupGetMultiSzField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated fields or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetMultiSzFieldA (
    IN OUT PINFSTRUCTA     Context,
    IN     UINT            FieldIndex
    )
{

    UINT   requiredSize;
    PSTR    rFields = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldA(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetMultiSzFieldA: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

PWSTR
InfGetMultiSzFieldW (
    IN OUT PINFSTRUCTW     Context,
    IN     UINT            FieldIndex
    )
{

    UINT   requiredSize;
    PWSTR   rFields = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetMultiSzFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rFields = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rFields) {

            //
            // Get the field.
            //
            if (!SetupGetMultiSzFieldW(
                &(Context -> Context),
                FieldIndex,
                rFields,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetMultiSzFieldW: Error retrieving field from INF file."));
                rFields = NULL;
            }
        }
    }


    return rFields;
}

/*++

Routine Description:

    InfGetStringFieldA and InfGetStringFieldW are wrappers for the SetupGetStringField function.
    They both reduce the number of parameters required to get the line text and
    take care of allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line to retrieve a string field.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PSTR
InfGetStringFieldA (
    IN OUT  PINFSTRUCTA Context,
    IN      UINT FieldIndex
    )
{

    UINT   requiredSize;
    PSTR    rField = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldA(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PSTR) pAllocateSpaceA(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldA(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetStringFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PWSTR
InfGetStringFieldW (
    IN OUT PINFSTRUCTW  Context,
    IN     UINT         FieldIndex
    )
{

    UINT requiredSize;
    PWSTR rField = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetStringFieldW(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = (PWSTR) pAllocateSpaceW(Context,requiredSize*sizeof(WCHAR));

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetStringFieldW(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetStringFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


/*++

Routine Description:

    InfGetIntField is a wrapper for SetupGetIntField. It is virtually identical to this function
    except that it takes care of getting the INFCONTEXT out of the INFSTRUCT structure.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.

    FieldIndex - The index within the line from which to retrieve the field.

    Value   - Recieves the value of the requested Int field.

Return Value:

     TRUE if the field was successfully retrieved, FALSE otherwise. Use GetLastError() To receive
     extended error information.

--*/

BOOL
InfGetIntFieldA (
    IN PINFSTRUCTA  Context,
    IN UINT         FieldIndex,
    IN PINT         Value
    )
{
    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}

BOOL
InfGetIntFieldW (
    IN PINFSTRUCTW  Context,
    IN UINT         FieldIndex,
    IN PINT         Value
    )
{
    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupGetIntField (&(Context -> Context), FieldIndex, Value);
}


/*++

Routine Description:

    InfGetBinaryField is a wrapper for the SetupGetBinaryField function. It reduces
    the number of parameters required to get the line text and takes care of
    allocating and filling a buffer with the data returned from the API.

Arguments:

    Context - A valid InfStruct. The INFCONTEXT member of the structure must point to a valid
              line to retrieve (i.e. through the use of InfFindFirstLine/InfFindNextLine.
    FieldIndex - the index within the line of the desired binary information.

Return Value:

    A pointer to the allocated line or NULL if there was an error. Consult GetLastError() for
    extended error information.

--*/

PBYTE
InfGetBinaryFieldA (
    IN  PINFSTRUCTA     Context,
    IN  UINT            FieldIndex
    )
{

    UINT requiredSize;
    PBYTE rField = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpaceA(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGA((DBG_ERROR,"InfGetBinaryFieldA: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}

PBYTE
InfGetBinaryFieldW (
    IN  PINFSTRUCTW     Context,
    IN  UINT            FieldIndex
    )
{

    UINT requiredSize;
    PBYTE rField = NULL;

    if(!Context){
        MYASSERT(Context);
        return NULL;
    }

    //
    // Get the size necessary for holding the field.
    //
    if (SetupGetBinaryField(
        &(Context -> Context),
        FieldIndex,
        NULL,
        0,
        &requiredSize
        )) {

        //
        // Create a string big enough.
        //
        rField = pAllocateSpaceW(Context,requiredSize);

        if (rField) {

            //
            // Get the field.
            //
            if (!SetupGetBinaryField(
                &(Context -> Context),
                FieldIndex,
                rField,
                requiredSize,
                NULL
                )) {

                //
                // If we did not successfully get the field, reset the string to NULL.
                //
                DEBUGMSGW((DBG_ERROR,"InfGetBinaryFieldW: Error retrieving field from INF file."));
                rField = NULL;
            }
        }
    }


    return rField;
}


/*++

Routine Description:

  InfGetIndexByLine is a straight wrapper for SetupGetLineByIndex. The only
  difference is the use of an PINFSTRUCT instead of a PINFCONTEXT.

Arguments:

  InfHandle - Contains a valid HINF.

  Section   - Contains the name of the section within the InfFile.

  Index     - Contains the index within the section of the line in question.

  Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

  TRUE if the function was called successfully, FALSE otherwise.

--*/


BOOL
InfGetLineByIndexA (
    IN HINF         InfHandle,
    IN PCSTR        Section,
    IN DWORD        Index,
    OUT PINFSTRUCTA Context
    )
{
    ASSERT_VALID_INF(InfHandle);

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupGetLineByIndexA(InfHandle,Section,Index,&(Context -> Context));
}

BOOL
InfGetLineByIndexW (
    IN HINF         InfHandle,
    IN PCWSTR       Section,
    IN DWORD        Index,
    OUT PINFSTRUCTW Context
    )
{
    ASSERT_VALID_INF(InfHandle);

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupGetLineByIndexW(InfHandle,Section,Index,&(Context -> Context));
}


/*++

Routine Description:

    InfFindFirstLineA and InfFindFirstLineW are wrappers for the SetupFindFirstLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS.

Arguments:


    InfHandle - Contains a valid HINF.

    Section   - Contains the name of the section within the InfFile.

    Key       - An optional parameter containing the name of the key within the section to find.
                If NULL, these routines will return the first line in the section.

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if lines exist in the section, FALSE otherwise.

--*/

BOOL
InfFindFirstLineA (
    IN  HINF         InfHandle,
    IN  PCSTR        Section,
    IN  PCSTR        Key,       OPTIONAL
    OUT PINFSTRUCTA  Context
    )
{
    ASSERT_VALID_INF(InfHandle);

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    if (Key) {
        Context->KeyName = (PCSTR) pAllocateSpaceA (Context, SizeOfStringA (Key));
        StringCopyA ((PSTR)Context->KeyName, Key);
    } else {
        Context->KeyName = NULL;
    }
    return SetupFindFirstLineA (
        InfHandle,
        Section,
        Context->KeyName,
        &(Context -> Context)
        );
}

BOOL
InfFindFirstLineW (
    IN HINF         InfHandle,
    IN PCWSTR       Section,
    IN PCWSTR       Key,        OPTIONAL
    OUT PINFSTRUCTW Context
    )
{
    ASSERT_VALID_INF(InfHandle);

    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    if (Key) {
        Context->KeyName = (PCWSTR) pAllocateSpaceW (Context, SizeOfStringW (Key));
        StringCopyW ((PWSTR)Context->KeyName, Key);
    } else {
        Context->KeyName = NULL;
    }
    return SetupFindFirstLineW (
        InfHandle,
        Section,
        Context->KeyName,
        &(Context -> Context)
        );
}


/*++

Routine Description:

    InfFindNextLineA and InfFindNextLineW are wrappers for the SetupFindNextMatchLine function.
    They are virtually identical except that they operate on INFSTRUCTs instead of INFCONTEXTS and
    need only one INFSTRUCT parameter.

Arguments:

    Context - A valid InfStruct that is updated with the result of these calls.

Return Value:

    TRUE if there is another line in the section, FALSE otherwise.

--*/

BOOL
InfFindNextLineA (
    IN OUT PINFSTRUCTA    Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupFindNextMatchLineA (&(Context -> Context), Context->KeyName, &(Context -> Context));
}

BOOL
InfFindNextLineW (
    IN OUT PINFSTRUCTW    Context
    )
{
    if(!Context){
        MYASSERT(Context);
        return FALSE;
    }

    return SetupFindNextMatchLineW (&(Context -> Context), Context->KeyName, &(Context -> Context));
}


UINT
InfGetFieldCountA (
    IN PINFSTRUCTA Context
    )
{
    if (!Context) {
        MYASSERT(Context);
        return 0;
    }

    return SetupGetFieldCount(&(Context  -> Context));
}

UINT
InfGetFieldCountW (
    IN PINFSTRUCTW Context
    )
{
    if (!Context) {
        MYASSERT(Context);
        return 0;
    }

    return SetupGetFieldCount(&(Context  -> Context));
}


PCSTR
InfGetOemStringFieldA (
    IN      PINFSTRUCTA Context,
    IN      UINT        Field
    )

/*++

Routine Description:

  InfGetOemStringField returns a string field in the OEM character set.
  This routine is used when accessing txtsetup.sif.  It is implemented
  only in the A version because UNICODE does not have a concept of OEM
  characters.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Field - Specifies the field number

Return Value:

  A pointer to the OEM string, or NULL if an error occurred.

--*/

{
    PCSTR Text;
    PSTR OemText;
    INT Size;

    Text = InfGetStringFieldA (Context, Field);
    if (!Text) {
        return NULL;
    }

    Size = SizeOfStringA (Text);

    OemText = (PSTR) pAllocateSpaceA (Context, Size);
    if (!OemText) {
        return NULL;
    }

    //
    // We leave Text allocated because the caller will free everything
    // when they clean up Context.  Note the assumption that the conversion
    // doesn't change string length.
    //

    OemToCharBuffA (Text, OemText, Size);

    return OemText;
}


BOOL
SetupGetOemStringFieldA (
    IN      PINFCONTEXT Context,
    IN      DWORD Index,
    IN      PTSTR ReturnBuffer,                 OPTIONAL
    IN      DWORD ReturnBufferSize,
    OUT     PDWORD RequiredSize                 OPTIONAL
    )

/*++

Routine Description:

  SetupGetOemStringFieldA is a SetupGetStringField that converts the
  return text to the OEM character set.

Arguments:

  Context - Specifies the initialized INF structure that points to the
            line to read from

  Index - Specifies the field number

  ReturnBuffer - Specifies the buffer to fill the text into

  ReturnBufferSize - Specifies the size of ReturnBuffer in bytes

  RequiredSize - Receives the size of the buffer needed

Return Value:

  TRUE if successful, FALSE if failure.

--*/

{
    PSTR OemBuf;

    INT Size;

    if (!SetupGetStringFieldA (
            Context,
            Index,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            )) {
        return FALSE;
    }

    if (!ReturnBuffer) {
        return TRUE;
    }

    Size = SizeOfStringA (ReturnBuffer);

    //
    // BUGBUG - why not use in-place conversion like the function above?
    // OemToCharBuff supports in-place conversion as well
    //
    OemBuf = (PSTR) MemAlloc (g_hHeap, 0, Size);

    OemToCharBuffA (ReturnBuffer, OemBuf, Size);
    StringCopyA (ReturnBuffer, OemBuf);
    MemFree (g_hHeap, 0, OemBuf);

    return TRUE;
}


UINT
pGetLanguage (
    IN PCSTR File
    )
{

    HINF inf = INVALID_HANDLE_VALUE;
    PINFSECTION section;
    PINFLINE line;
    PWSTR start, end;
    UINT rLanguage = INF_INVALID_VERSION;
    WCHAR envvar[MAX_MBCHAR_PATH];

    *envvar = 0;

    MYASSERT(File);

    //
    // Use the infparse rourtines to get this information. They
    // are more reliable than the *privateprofile* apis.
    //

    inf = OpenInfFileExA (File, "version, strings", FALSE);
    if (inf == INVALID_HANDLE_VALUE) {
        return rLanguage;
    }
    section = FindInfSectionInTableW (inf, S_VERSION_W);

    if (section) {
        line = FindLineInInfSectionW (inf, section, S_LANGUAGE_W);

        if (line && line->Data) {

            start = wcschr (line->Data, L'%');
            if (start) {
                end = wcschr (start + 1, L'%');

                if (end) {
                    if(ARRAYSIZE(envvar) <= (end - start - 1)){
                        MYASSERT(ARRAYSIZE(envvar) > (end - start - 1));
                        envvar[0] = '\0';
                    }
                    else{
                        StringCopyABW(envvar, start+1, end);
                    }
                }
            }
            else {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    MYASSERT(line->Data);
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (*envvar) {
        //
        // Get the data from the strings section.
        //
        section = FindInfSectionInTableW (inf, S_STRINGS_W);
        if (section) {

            line = FindLineInInfSectionW (inf, section, envvar);

            if (line && line->Data) {

                if (*line->Data == L'*') {

                    rLanguage = INF_ANY_LANGUAGE;
                }
                else {
                    rLanguage = _wcsnum (line->Data);
                }
            }
        }
    }

    if (inf != INVALID_HANDLE_VALUE) {
        CloseInfFile (inf);
    }
    return rLanguage;
}



BOOL
pInitInfReplaceTableA (
    IN      PCSTR UpginfsDir            OPTIONAL
    )
{
    CHAR systemPath[MAX_MBCHAR_PATH];
    CHAR buffer[MAX_MBCHAR_PATH];
    BOOL validFile;
    TREE_ENUMA e;
    INT version;
    INT language;
    DWORD operation;
    BOOL bReplace, bAdd;
    CHAR buf[MAX_MBCHAR_PATH];
    PCSTR tag;
    BOOL b;

//  pDestroyInfModList (g_RootInfMod);
    PoolMemEmptyPool (g_InfModPool);
    g_RootInfMod = NULL;

    if (!(UpginfsDir && *UpginfsDir)) {
        return TRUE;
    }

    if (!EnumFirstFileInTreeA (&e, UpginfsDir, NULL, FALSE)) {
        DEBUGMSGA ((
            DBG_VERBOSE,
            "InfInitialize: No infs in %s or not a directory (rc=%u)",
            UpginfsDir,
            GetLastError ()
            ));
        return FALSE;
    }

    b = FALSE;

    do {

        //
        // we only care about *.rep and *.add files. Ignore everything
        // else.
        //
        if (e.Directory) {
            continue;
        }

        bReplace = IsPatternMatchA ("*.rep", e.Name);
        bAdd = IsPatternMatchA ("*.add", e.Name);
        if (bAdd || bReplace) {

            __try {

                validFile = FALSE;

                operation = bReplace ? INF_REPLACE : INF_APPEND;

                GetPrivateProfileStringA (
                    S_VERSION_A,
                    S_TARGETINF_A,
                    "",
                    buffer,
                    MAX_MBCHAR_PATH,
                    e.FullPath
                    );

                if (!*buffer) {
                    DEBUGMSGA ((DBG_WARNING, "%s not found in %s [%s]", S_TARGETINF_A, e.FullPath, S_VERSION_A));
                    __leave;
                }

                //
                // CAUTION: as a result of the security review,
                // require a new key called Version2 in the [Version]
                // section of the patch INF
                //
                version = GetPrivateProfileIntA (
                                S_VERSION_A,
                                S_VERSION_A,
                                INF_INVALID_VERSION,
                                e.FullPath
                                );


                //
                // version is ALWAYS needed
                //
                if (version == INF_INVALID_VERSION) {
                    DEBUGMSGA ((DBG_WARNING, "%s not found in %s [%s]", S_VERSION_A, e.FullPath, S_VERSION_A));
                    __leave;
                }

                language = pGetLanguage (e.FullPath);

                if (language == INF_INVALID_VERSION) {
                    __leave;
                }

                if (GetPrivateProfileStringA (
                                S_VERSION_A,
                                S_TAG_A,
                                TEXT(""),
                                buf,
                                MAX_MBCHAR_PATH,
                                e.FullPath
                                )) {
                    tag = buf;
                } else {
                    tag = NULL;
                }

                validFile = TRUE;
            }
            __finally {

                if (!validFile || !pAddReplacementInfToTable (buffer, version, language, tag, operation, e.FullPath)) {
                    DEBUGMSGA ((DBG_WARNING,"Invalid Replace or Add file found in %s.", UpginfsDir));
                } else {
                    //
                    // at least one patch was successfully added to the table
                    //
                    b = TRUE;
                }
            }
        } else {
            DEBUGMSGA ((
                DBG_WARNING,
                "Non .rep or .add file found in %s directory! Unexpected.",
                UpginfsDir
                ));
        }

    } while (EnumNextFileInTreeA (&e));

    return b;
}



/*++

Routine Description:

    InitInfReplaceTable [re]initializes the table used by this module
    with patches for inbox INFs

Arguments:

    UpginfsDir - Specifies the (full path) directory to search for patches;
                 if NULL, clears the table

Return Value:

    None

--*/

BOOL
InitInfReplaceTableA (
    IN      PCSTR UpginfsDir            OPTIONAL
    )
{
    return pInitInfReplaceTableA (UpginfsDir);
}

BOOL
InitInfReplaceTableW (
    IN      PCWSTR UpginfsDir           OPTIONAL
    )
{
    BOOL b;
    PCSTR ansiDir;
    
    ansiDir = UpginfsDir ? ConvertWtoA (UpginfsDir) : NULL;

    b = InitInfReplaceTableA (ansiDir);

    if (ansiDir) {
        FreeConvertedStr (ansiDir);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    Ovidiu Temereanca (ovidiut)  23-Oct-1998
        Implemented a new log mechanism and added new logging capabilities

--*/


#include "pch.h"
#include "migutilp.h"


/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/


#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG|OD_NOFORMAT)                               \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_DEBUGLOG|OD_LOGFILE)                             \
        DEFMAC(DBG_VERBOSE, OD_DEBUGLOG)                                        \
        DEFMAC(DBG_NAUSEA, OD_DEBUGLOG)                                         \
        DEFMAC(DBG_ASSERT, DEFAULT_ERROR_FLAGS)                                 \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_ACCOUNTS, OD_LOGFILE)                                        \
        DEFMAC(LOG_CONFIG, OD_CONFIG|OD_NOFORMAT)                               \
        DEFMAC("PoolMem", OD_SUPPRESS)                                          \

#endif





//
// This constant sets the default output
//

#ifndef DEBUG
#define NORMAL_DEFAULT      OD_LOGFILE
#else
#define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

//
// Constants and types
//

#define OUTPUT_BUFSIZE_LARGE  8192
#define OUTPUT_BUFSIZE_SMALL  128
#define MAX_MSGTITLE_LEN  14
#define MSGBODY_INDENT  12
#define SCREEN_WIDTH  80
#define MAX_TYPE  64

#define S_COLUMNDOUBLELINEA  ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW  L":\r\n\r\n"
#define S_NEWLINEA  "\r\n"
#define S_NEWLINEW  L"\r\n"

#define NEWLINE_CHAR_COUNT  (sizeof (S_NEWLINEA) - 1)


#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)
#define OUT_CONFIG(OutDest)         ((OutDest & OD_CONFIG) != 0)
#define OUT_NOFORMAT(OutDest)       ((OutDest & OD_NOFORMAT) != 0)

#ifdef DEBUG
#define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
#define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#else
#define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
#define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)  ((buf) + (sizeof(buf) / sizeof(buf[0])) - 1)

#define DEBUG_SECTION  "Debug"
#define ENTRY_ALL  "All"
#define ENTRY_DEFAULTOVERRIDE  "DefaultOverride"


#define LOGSEVERITY LogSeverity

#define LOGSEV_FATAL_ERROR  LogSevFatalError
#define LOGSEV_ERROR  LogSevError
#define LOGSEV_WARNING  LogSevWarning
#define LOGSEV_INFORMATION  LogSevInformation



typedef enum {
    OD_UNDEFINED = 0x00,            // undefined output dest
    OD_DEBUGLOG = 0x01,             // debuglog used
    OD_SUPPRESS = 0x02,             // don't log to any device
    OD_ERROR = 0x04,                // automatically append GetLastError() to the message
    OD_LOGFILE = 0x08,              // messages go to logfile
    OD_DEBUGGER = 0x10,             // messages go to debugger
    OD_CONSOLE = 0x20,              // messages go to console
    OD_POPUP = 0x40,                // display a popup dialog
    OD_POPUP_CANCEL = 0x80,         // do not display a popup dialog (cancelled by user)
    OD_FORCE_POPUP = 0x100,         // force the popup to be displayed always
    OD_MUST_BE_LOCALIZED = 0x200,   // used for LOG() that will generate a popup
    OD_UNATTEND_POPUP = 0x400,      // force the popup to be displayed in unattend mode
    OD_ASSERT = 0x800,              // give DebugBreak option in popup
    OD_CONFIG = 0x1000,             // output to config.dmp
    OD_NOFORMAT = 0x2000            // no format on output string
} OUTPUT_DESTINATION;

#define OUTPUTDEST      DWORD

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;


const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};


const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

//
// a window handle for popup parent
//
HWND g_LogPopupParentWnd = NULL;

//
// thread id that set this window handle
//
DWORD g_InitThreadId = 0;


static OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
static OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
static PVOID g_TypeSt = NULL;
static BOOL g_HasTitle = FALSE;
static CHAR g_LastType [MAX_TYPE];
static BOOL g_SuppressAllPopups = FALSE;

CHAR g_ConfigDmpPathBufA[MAX_MBCHAR_PATH];
BOOL g_ResetLog = FALSE;

#ifdef PROGRESS_BAR

HANDLE g_ProgressBarLog = INVALID_HANDLE_VALUE;

#endif //PROGRESS_BAR


#ifdef DEBUG

CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
WCHAR g_DebugInfPathBufW[] = L"C:\\debug.inf";
CHAR g_Debug9xLogPathBufA[] = "C:\\debug9x.log";
CHAR g_DebugNtLogPathBufA[] = "C:\\debugnt.log";
PCSTR g_DebugLogPathA = NULL;

//
// If g_DoLog is TRUE, then, debug logging is enabled in the
// checked build even if there is no debug.inf.
// This variable can be enabled via the /#U:DOLOG command line directive...

BOOL g_DoLog = FALSE;

#define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);

#else

#define PRIVATE_ASSERT(expr)

#endif // DEBUG


#define DEFMAC(typestr, flags)      {typestr, flags},

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;

DEFAULT_DESTINATION g_DefaultDest[] = {TYPE_DEFAULTS /* , */ {NULL, 0}};

#undef DEFMAC



#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR Buffer[512];
    HRESULT hr;

    if (Expr) {
        return;
    }

    hr = StringCbPrintfA(Buffer, sizeof(Buffer), "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);

    if (SUCCEEDED(hr))
    {
        MessageBox (NULL, Buffer, NULL, MB_OK);
    }
    else
    {
        MessageBox (NULL, "LOG FAILURE!", NULL, MB_OK);
    }
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    INT i;

    for(i = 0; i < sizeof (g_IgnoreKeys) / sizeof (PCSTR); i++) {
        if (StringIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    INT i;

    for(i = 0; i < sizeof (g_String2Binary) / sizeof (STRING2BINARY); i++) {
        if (StringIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST OutDest;

    if (g_TypeSt == NULL) {
        //
        // sorry, log is closed
        //
        return OD_UNDEFINED;
    }

    if (-1 != pSetupStringTableLookUpStringEx (
                    g_TypeSt,
                    (PSTR)Type, // remove const, however string will not be modified
                    STRTAB_CASE_INSENSITIVE,
                    &OutDest,
                    sizeof (OutDest)
                    )) {

#ifdef DEBUG
        if (g_DoLog) {
            OutDest |= OD_DEBUGLOG;
        }
#endif
        return OutDest;

    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST OutDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        OutDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        OutDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (OutDest)) {

            //
            // just return the default
            //

            OutDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        OutDest |= OD_DEBUGLOG;
    }
#endif


    return OutDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST OutDest;

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    OutDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (OutDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LogSevInformation.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LogSevError;
    }

    return LogSevInformation;
}


BOOL
pTableAddType (
    IN      PCSTR Type,
    IN      OUTPUTDEST OutDest
    )

/*++

Routine Description:

  pTableAddType adds a <Type, OutDest> association
  to the table g_TypeSt. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    PRIVATE_ASSERT (g_TypeSt != NULL);

    return -1 != pSetupStringTableAddStringEx(
                    g_TypeSt,
                    (PSTR)Type, // remove const, however string will not be modified
                    STRTAB_CASE_INSENSITIVE | STRTAB_NEW_EXTRADATA,
                    &OutDest,
                    sizeof(OutDest)
                    );
}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST OutDest = OD_UNDEFINED;
    CHAR Value[OUTPUT_BUFSIZE_SMALL];
    INT Field;

    for(Field = SetupGetFieldCount (InfContext); Field > 0; Field--) {
        if (SetupGetStringFieldA (
                InfContext,
                Field,
                Value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            OutDest |= pConvertToOutputType(Value);
        }
    }

    return OutDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_TypeSt table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT InfContext;
    OUTPUTDEST OutDest;
    CHAR Key[OUTPUT_BUFSIZE_SMALL];

    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &InfContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &InfContext,
                    0,
                    Key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }

            if (pIgnoreKey (Key)) {
                continue;
            }

            // check for special cases
            if (StringIMatchA (Key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&InfContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (StringIMatchA (Key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&InfContext);
                } else {
                    OutDest = pGetAttributes(&InfContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (OutDest)) {
                        if (!pTableAddType (Key, OutDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&InfContext, &InfContext));
    }

    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      INT  Indent
    )

{
    INT i;
    PSTR p;

    for (i = ByteCountA (Title), p = GetEndOfStringA (Title); i < Indent; i++) {
        *p++ = ' ';
    }

    *p = 0;
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      INT   Indent
    )
{
    INT i;
    PWSTR p;

    for (i = TcharCountW (Title), p = GetEndOfStringW (Title); i < Indent; i++) {
        *p++ = L' ';
    }

    *p = 0;
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      INT Indent,
    IN      PBOOL TrimLeadingSpace
    )

{
    INT Col = 0;
    INT MaxCol = SCREEN_WIDTH - 1 - Indent;
    PCSTR LastSpace = NULL;
    PCSTR PrevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    //BUGBUG - QUESTION - can these mbs functions fail?
    while ( (ch = _mbsnextc (Line)) != 0 && Col < MaxCol) {

        if (ch == '\n') {
            LastSpace = Line;
            break;
        }

        if (ch > 255) {
            LastSpace = Line;
            Col++;
        } else {
            if (_ismbcspace (ch)) {
                LastSpace = Line;
            }
        }

        Col++;
        PrevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (LastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        LastSpace = PrevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (LastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      INT Indent,
    IN      PBOOL TrimLeadingSpace
    )
{
    INT Col = 0;
    INT MaxCol = SCREEN_WIDTH - 1 - Indent;
    PCWSTR LastSpace = NULL;
    PCWSTR PrevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && Col < MaxCol) {

        if (ch == L'\n') {
            LastSpace = Line;
            break;
        }

        if (ch > 255) {
            LastSpace = Line;
        } else {
            if (iswspace (ch)) {
                LastSpace = Line;
            }
        }

        Col++;
        PrevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (LastSpace == NULL) {
        // we must cut this even if no white space was found
        LastSpace = PrevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return LastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in Buffer, which is no larger than Size.

Arguments:

  Buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR Buffer,
    IN      DWORD Size,
    IN      INT Indent
    )

{
    CHAR IndentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR NextLine;
    PCSTR s;
    PSTR d;
    INT i;
    BOOL TrimLeadingSpace;
    PCSTR EndOfBuf;
    BOOL AppendNewLine = FALSE;

    NextLine = Buffer;
    s = Buffer;
    d = IndentBuffer;

    EndOfBuf = END_OF_BUFFER(IndentBuffer) - 3;

    while (*s && d < EndOfBuf) {

        //
        // Find end of next line
        //

        NextLine = (PSTR)pFindNextLineA (s, Indent, &TrimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < NextLine && d < EndOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (isleadbyte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (TrimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            AppendNewLine = TRUE;

            if (d < EndOfBuf && TrimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < EndOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (AppendNewLine && d < EndOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(IndentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyByteCountA (Buffer, IndentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR Buffer,
    IN      DWORD Size,
    IN      INT Indent
    )
{
    WCHAR IndentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR NextLine;
    PCWSTR s;
    PWSTR d;
    INT i;
    BOOL TrimLeadingSpace;
    PCWSTR EndOfBuf;
    BOOL AppendNewLine = FALSE;

    NextLine = Buffer;
    s = Buffer;
    d = IndentBuffer;

    EndOfBuf = END_OF_BUFFER(IndentBuffer) - 1;

    while (*s && d < EndOfBuf) {

        //
        // Find end of next line
        //

        NextLine = (PWSTR)pFindNextLineW (s, Indent, &TrimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < NextLine && d < EndOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (TrimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            AppendNewLine = TRUE;

            if (d < EndOfBuf && TrimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < EndOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (AppendNewLine && d < EndOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(IndentBuffer));
    *d = 0;

    // copy the result to output buffer
    StringCopyTcharCountW (Buffer, IndentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      LONG LastError
    )
{
    PSTR Append;
    DWORD ErrMsgLen;

    StringCopyByteCountA (MsgWithErr, Message, BufferSize);
    Append = GetEndOfStringA (MsgWithErr);
    ErrMsgLen = (UINT) (UINT_PTR) (MsgWithErr + BufferSize - Append);

    if (ErrMsgLen > 0) {
        if (LastError < 10) {
            StringCchPrintfA(Append, ErrMsgLen, " [ERROR=%lu]", LastError);
        } else {
            StringCchPrintfA(Append, ErrMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      LONG LastError
    )
{
    PWSTR Append;
    DWORD ErrMsgLen;

    StringCopyTcharCountW (MsgWithErr, Message, BufferSize / sizeof(WCHAR));
    Append = GetEndOfStringW (MsgWithErr);
    ErrMsgLen = (UINT) (UINT_PTR) (MsgWithErr + (BufferSize / sizeof(WCHAR)) - Append);

    if (ErrMsgLen > 0) {
        if (LastError < 10) {
           StringCchPrintfW(Append, ErrMsgLen, L" [ERROR=%lu]", LastError);
        } else {
           StringCchPrintfW(Append, ErrMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  FormattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR FormattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      INT Indent,
    IN      LONG LastError
    )
{
    CHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR MyMsgBody;
    PSTR Current;
    DWORD Remaining;

    MyMsgBody = Body;
    Remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        MyMsgBody = BodyWithErr;

        pAppendLastErrorA (BodyWithErr, sizeof (BodyWithErr), Body, LastError);
    }

    //We know that the buffer is always large enough to accomodate
    //the indent, since buffer size will be OUTPUT_BUFSIZE_LARGE = 8192,
    //and Indent will be MSGBODY_INDENT = 12
    StringCopyByteCountA (FormattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (FormattedMsg, Indent);

    Current = FormattedMsg + Indent;
    StringCopyByteCountA (Current, MyMsgBody, Remaining);
    pHangingIndentA (Current, Remaining, Indent);

    // append a new line if space left
    Current = GetEndOfStringA (Current);
    if (Current + NEWLINE_CHAR_COUNT + 1 < FormattedMsg + BufferSize) {
        *Current++ = '\r';
        *Current++ = '\n';
        *Current = 0;
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR FormattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      INT Indent,
    IN      LONG LastError
    )
{
    WCHAR TypeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR MyMsgBody;
    PWSTR Current;
    DWORD Remaining;

    MyMsgBody = Body;
    Remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        MyMsgBody = BodyWithErr;

        #pragma prefast(suppress:209, "Using bytes is correct in sizeof(BodyWithErr)")
        pAppendLastErrorW (BodyWithErr, sizeof (BodyWithErr), Body, LastError);
    }

    KnownSizeAtoW (TypeW, Type);

    //We know that the buffer is always large enough to accomodate
    //the indent, since buffer size will be OUTPUT_BUFSIZE_LARGE = 8192,
    //and Indent will be MSGBODY_INDENT = 12
    StringCopyTcharCountW (FormattedMsg, TypeW, MAX_MSGTITLE_LEN);
    pPadTitleW (FormattedMsg, Indent);

    Current = FormattedMsg + Indent;
    StringCopyTcharCountW (Current, MyMsgBody, Remaining);
    pHangingIndentW (Current, Remaining, Indent);

    // append a new line if space left
    Current = GetEndOfStringW (Current);
    if (Current + NEWLINE_CHAR_COUNT + 1 < FormattedMsg + BufferSize) {
        *Current++ = L'\r';
        *Current++ = L'\n';
        *Current = 0;
    }
}


typedef BOOL (WINAPI *PSETUPOPENLOG) (BOOL);
typedef BOOL (WINAPI *PSETUPLOGERRORA) (LPCSTR, LogSeverity);
typedef BOOL (WINAPI *PSETUPLOGERRORW) (LPCWSTR, LogSeverity);
typedef VOID (WINAPI *PSETUPCLOSELOG) (VOID);

HMODULE g_SetupApiInst;
PSETUPOPENLOG pDynSetupOpenLog;
PSETUPLOGERRORA pDynSetupLogErrorA;
PSETUPLOGERRORW pDynSetupLogErrorW;
PSETUPCLOSELOG pDynSetupCloseLog;

BOOL
pDynSetupApiInit (
    VOID
    )
{
    if (pDynSetupOpenLog &&
        pDynSetupLogErrorA &&
        pDynSetupLogErrorW &&
        pDynSetupCloseLog
        ) {
        return TRUE;
    }

    if (g_SetupApiInst) {
        return FALSE;
    }

    g_SetupApiInst = LoadLibraryA ("setupapi.dll");
    if (!g_SetupApiInst) {
        return FALSE;
    }

    (FARPROC) pDynSetupOpenLog = GetProcAddress (g_SetupApiInst, "SetupOpenLog");
    (FARPROC) pDynSetupLogErrorA = GetProcAddress (g_SetupApiInst, "SetupLogErrorA");
    (FARPROC) pDynSetupLogErrorW = GetProcAddress (g_SetupApiInst, "SetupLogErrorW");
    (FARPROC) pDynSetupCloseLog = GetProcAddress (g_SetupApiInst, "SetupCloseLog");

    if (pDynSetupOpenLog &&
        pDynSetupLogErrorA &&
        pDynSetupLogErrorW &&
        pDynSetupCloseLog
        ) {
        return TRUE;
    }

    return FALSE;
}



/*++

Routine Description:

  pWriteToSetupLogA and pWriteToSetupLogW log the specified message
  to the setup log using Setup API functions.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  FormattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToSetupLogA (
    IN      LOGSEVERITY Severity,
    IN      PCSTR FormattedMsg
    )
{
    if (!pDynSetupApiInit()) {
        return;
    }

    if (!pDynSetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }
    if (!pDynSetupLogErrorA (FormattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    pDynSetupCloseLog();
}


VOID
pWriteToSetupLogW (
    IN      LOGSEVERITY Severity,
    IN      PCWSTR FormattedMsg
    )
{
    if (!pDynSetupApiInit()) {
        PRIVATE_ASSERT (FALSE);
        return;
    }

    if (!pDynSetupOpenLog (FALSE)) {
        PRIVATE_ASSERT (FALSE);
        return;
    }

    if (!pDynSetupLogErrorW (FormattedMsg, Severity)) {
        PRIVATE_ASSERT (FALSE);
    }

    pDynSetupCloseLog();
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      LONG LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR Buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR Current = Buffer;
#endif
    UINT MBStyle;
    LONG rc;
    OUTPUTDEST OutDest;
    HWND ParentWnd;
    PCSTR DisplayMessage = Msg;
    LOGSEVERITY Severity = pGetSeverityFromType (Type);

    OutDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS)
        {
            if (LastError < 10)
            {
                StringCbPrintfA(Buffer, sizeof(Buffer), " [ERROR=%u]", LastError);
                Current = Buffer + TcharCountA(Buffer);
            }
            else
            {
                StringCbPrintfA(Buffer, sizeof(Buffer), " [ERROR=%u (%Xh)]", LastError, LastError);
                Current = Buffer + TcharCountA(Buffer);
            }
        }

        if (OUT_ASSERT (OutDest))
        {
             StringCbPrintfA (
                Current,
                sizeof(Buffer) - (Current - Buffer),
                "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                Type
                );

              Current = Buffer + TcharCountA(Buffer);
        }
        else
        {
            StringCbPrintfA (
                Current,
                sizeof(Buffer) - (Current - Buffer),
                "\n\n(Hit Cancel to disable '%s' message boxes)",
                Type
                );

            Current = Buffer + TcharCountA(Buffer);
        }

        if (Current > Buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            DisplayMessage = FormattedMsg;
            StringCopyByteCountA (
                FormattedMsg,
                Msg,
                sizeof (FormattedMsg) / sizeof (CHAR) - ((UINT) (UINT_PTR) (Current - Buffer))
                );

            StringCbCatA(FormattedMsg, sizeof(FormattedMsg), Buffer);
        }
#endif

        switch (Severity) {

        case LOGSEV_FATAL_ERROR:
            MBStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            MBStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            MBStyle = MB_ICONEXCLAMATION;
            break;

        default:
            MBStyle = MB_ICONINFORMATION;

        }
        MBStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (OutDest)) {
            MBStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            MBStyle |= MB_OKCANCEL;
        }
#else
        MBStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            ParentWnd = g_LogPopupParentWnd;

        } else {

            ParentWnd = NULL;

        }

        rc = MessageBoxA (ParentWnd, DisplayMessage, Type, MBStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            pTableAddType (Type, OutDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      LONG LastError,
    IN      BOOL Forced
    )
{
    PCSTR MsgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    MsgA = ConvertWtoA (Msg);
    pDisplayPopupA (Type, MsgA, LastError, Forced);
    FreeConvertedStr (MsgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR FormattedMsg
    )
{
    OUTPUTDEST OutDest;
    HANDLE Handle;
    LONG LastError;
    CHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR LogMessage;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (OutDest)) {
        return;
    }

    if (OUT_LOGFILE (OutDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (OutDest)) {

            if (Message) {

                LogMessage = Message;

                LastError = GetLastError ();

                if (LastError != ERROR_SUCCESS) {

                    pAppendLastErrorA (BodyWithErr, sizeof (BodyWithErr), Message, LastError);

                    LogMessage = BodyWithErr;
                }

                pWriteToSetupLogA (LOGSEV_INFORMATION, "Error:\r\n");
                pWriteToSetupLogA (LOGSEV_ERROR, LogMessage);
                pWriteToSetupLogA (LOGSEV_INFORMATION, "\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogA (LOGSEV_INFORMATION, FormattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(OutDest)) {
        OutputDebugStringA (FormattedMsg);
    }

    if (OUT_CONSOLE(OutDest)) {
        fprintf (stderr, "%s", FormattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (OutDest)) {

        Handle = CreateFileA (
                            g_DebugLogPathA,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringA (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
#endif

    if (OUT_CONFIG (OutDest)) {

        Handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringA (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR FormattedMsg
    )
{
    OUTPUTDEST OutDest;
    HANDLE Handle;
    LONG LastError;
    WCHAR BodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR LogMessage;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (OutDest)) {
        return;
    }

    if (OUT_LOGFILE (OutDest)) {

        //
        // determine the severity of the message
        //

        if (OUT_ERROR (OutDest)) {

            if (Message) {

                LogMessage = Message;

                LastError = GetLastError ();

                if (LastError != ERROR_SUCCESS) {

                    #pragma prefast(suppress:209, "Using bytes is correct in sizeof(BodyWithErr)")
                    pAppendLastErrorW (BodyWithErr, sizeof (BodyWithErr), Message, LastError);

                    LogMessage = BodyWithErr;
                }
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"Error:\r\n");
                pWriteToSetupLogW (LOGSEV_ERROR, LogMessage);
                pWriteToSetupLogW (LOGSEV_INFORMATION, L"\r\n\r\n");

            } else {
                PRIVATE_ASSERT (FALSE);
            }

        } else {
            pWriteToSetupLogW (LOGSEV_INFORMATION, FormattedMsg);
        }
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(OutDest)) {
        OutputDebugStringW (FormattedMsg);
    }

    if (OUT_CONSOLE(OutDest)) {
        fwprintf (stderr, L"%s", FormattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (OutDest)) {

        Handle = CreateFileA (
                        g_DebugLogPathA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringW (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
#endif

    if (OUT_CONFIG (OutDest)) {

        Handle = CreateFileA (
                        g_ConfigDmpPathBufA,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (Handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (Handle, 0, NULL, FILE_END);
            WriteFileStringW (Handle, FormattedMsg);
            CloseHandle (Handle);
        }
    }
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR Output[OUTPUT_BUFSIZE_LARGE];
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST OutDest;
    LONG LastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(OutDest)) {
        return;
    }

    if (OUT_ERROR (OutDest)) {
        LastError = GetLastError();
    } else {
        LastError = ERROR_SUCCESS;
    }

    // format output string
    if (HIWORD(Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (UINT) (UINT_PTR) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) Output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        StringCbVPrintfA(Output, sizeof(Output), Format, args);
    }

    if (OUT_NOFORMAT (OutDest)) {
        _tcssafecpy (FormattedMsg, Output, sizeof(FormattedMsg) - (NEWLINE_CHAR_COUNT + 1) * sizeof (CHAR));
        StringCbCatA (FormattedMsg, sizeof(FormattedMsg), S_NEWLINEA);
    } else {
        pIndentMessageA (
            FormattedMsg,
            OUTPUT_BUFSIZE_LARGE,
            Type,
            Output,
            MSGBODY_INDENT,
            LastError
            );
    }

    pRawWriteLogOutputA (Type, Output, FormattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (OutDest)) {
            PRIVATE_ASSERT (HIWORD (Format) == 0);
        }

        pDisplayPopupA (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));

#else
        if (HIWORD (Format) == 0) {
            pDisplayPopupA (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR FormatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR Output[OUTPUT_BUFSIZE_LARGE];
    WCHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST OutDest;
    LONG LastError;

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    OutDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(OutDest)) {
        return;
    }

    if (OUT_ERROR (OutDest)) {
        LastError = GetLastError();
    } else {
        LastError = ERROR_SUCCESS;
    }

    // format output string
    if (HIWORD(Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_hInst,
                (UINT) (UINT_PTR) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) Output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID"));
            return;
        }
    } else {
        KnownSizeAtoW(FormatW, Format);

        //
        // format given string using printf style
        //

        StringCchVPrintfW(Output, OUTPUT_BUFSIZE_LARGE, FormatW, args);
    }

    if (OUT_NOFORMAT (OutDest)) {
        #pragma prefast(suppress:209, "Using bytes is correct in sizeof(FormattedMsg)")
        _wcssafecpy (FormattedMsg, Output, sizeof(FormattedMsg) - (NEWLINE_CHAR_COUNT + 1) * sizeof (WCHAR));

        #pragma prefast(suppress:209, "Using bytes is correct in sizeof(FormattedMsg)")
        StringCbCatW (FormattedMsg, sizeof(FormattedMsg), S_NEWLINEW);
    } else {
        pIndentMessageW (
            FormattedMsg,
            OUTPUT_BUFSIZE_LARGE,
            Type,
            Output,
            MSGBODY_INDENT,
            LastError
            );
    }

    pRawWriteLogOutputW (Type, Output, FormattedMsg);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (OutDest)) {
            PRIVATE_ASSERT (HIWORD (Format) == 0);
        }

        pDisplayPopupW (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));

#else
        if (HIWORD (Format) == 0) {
            pDisplayPopupW (Type, Output, LastError, OUT_FORCED_POPUP(OutDest));
        }
#endif

    }
}


BOOL
pLogInit (
    IN      HWND *LogPopupParentWnd,    OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      BOOL FirstTimeInit
    )

/*++

Routine Description:

  pLogInit actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is optional only if FirstTimeInit
                       is FALSE.

  OrgPopupParentWnd  - Receives the original parent window.

  FirstTimeInit  - Specifies TRUE for the first log initialization,
                   or FALSE for reinitialization

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF Inf = INVALID_HANDLE_VALUE;
    BOOL Result = FALSE;
    PDEFAULT_DESTINATION Dest;
#ifdef DEBUG
    CHAR TempPath[MAX_MBCHAR_PATH];
#endif

    PRIVATE_ASSERT (!FirstTimeInit || LogPopupParentWnd);

    __try {

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_TypeSt);
            g_TypeSt = pSetupStringTableInitializeEx(sizeof (OUTPUTDEST), 0);

            if (!g_TypeSt) {
                __leave;
            }

            Dest = g_DefaultDest;

            while (Dest->Type) {
                pTableAddType (Dest->Type, Dest->Flags);
                Dest++;
            }

            if (!GetWindowsDirectoryA (g_ConfigDmpPathBufA, MAX_MBCHAR_PATH-1)) {
                __leave;
            }

            AppendWackA(g_ConfigDmpPathBufA); //enough buffer space here, since we used path-1 above
            StringCbCatA(g_ConfigDmpPathBufA, sizeof(g_ConfigDmpPathBufA), TEXT("config.dmp"));

#ifdef PROGRESS_BAR
            PRIVATE_ASSERT (g_ProgressBarLog == INVALID_HANDLE_VALUE);
            g_ProgressBarLog = CreateFile (
                                ISNT() ? TEXT("C:\\pbnt.txt") : TEXT("C:\\pb9x.txt"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                SetFilePointer (g_ProgressBarLog, 0, NULL, FILE_END);
            }
#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_ConfigDmpPathBufA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_ConfigDmpPathBufA);
        }

//BUGBUG - ISSUE -- Any path name vulnerabilities here?
//Also, doesn't check return value of GetSystemDirectoryA.
#ifdef DEBUG
        if (FirstTimeInit) {
            if (ISPC98()) {
                GetSystemDirectoryA (TempPath, ARRAYSIZE (TempPath));
                // replace C with the actual sys drive letter
                g_DebugNtLogPathBufA[0] = g_Debug9xLogPathBufA[0] = TempPath[0];
                g_DebugInfPathBufA[0] = TempPath[0];
                //
                // only the first byte is important because drive letters are not double-byte chars
                //
                g_DebugInfPathBufW[0] = (WCHAR)TempPath[0];
            }

            //
            // now get user's preferences
            //

            Inf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            if (INVALID_HANDLE_VALUE != Inf && pGetUserPreferences(Inf)) {
                g_DoLog = TRUE;
            }
        }

        if (g_DebugLogPathA == NULL) {

            g_DebugLogPathA = ISNT() ? g_DebugNtLogPathBufA : g_Debug9xLogPathBufA;
        }

        if (g_ResetLog) {

            SetFileAttributesA (g_DebugLogPathA, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogPathA);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = *LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        Result = TRUE;
    }
    __finally {

        if (Inf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (Inf);
        }

        if (!Result) {

            if (g_TypeSt) {
                pSetupStringTableDestroy(g_TypeSt);
                g_TypeSt = NULL;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif

#ifdef PROGRESS_BAR
            if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
                CloseHandle (g_ProgressBarLog);
                g_ProgressBarLog = INVALID_HANDLE_VALUE;
            }
#endif
        }
    }

    return Result;
}


BOOL
LogInit (
    HWND Parent
    )

/*++

Routine Description:

  LogInit initializes the log system calling the worker pLogInit. This function
  should be only called once

Arguments:

  Parent  - Specifies the initial parent window for all popups.  If NULL,
            the popups are suppressed.  Callers can use LogReInit to change
            the parent window handle at any time.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    return pLogInit (&Parent, NULL, TRUE);
}


BOOL
LogReInit (
    IN      HWND *NewParent,           OPTIONAL
    OUT     HWND *OrgParent            OPTIONAL
    )

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pLogInit.
  This function may be called any number of times, but only after LogInit

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

Return Value:

  TRUE if log system was successfully re-initialized

--*/

{
    return pLogInit (NewParent, OrgParent, FALSE);
}


VOID
LogExit (
    VOID
    )

/*++

Routine Description:

  LogExit cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{

#ifdef DEBUG

    if (g_DebugLogPathA) {
        g_DebugLogPathA = NULL;
    }

#endif

#ifdef PROGRESS_BAR
    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        CloseHandle (g_ProgressBarLog);
        g_ProgressBarLog = INVALID_HANDLE_VALUE;
    }
#endif

    if (g_TypeSt) {
        pSetupStringTableDestroy(g_TypeSt);
        g_TypeSt = NULL;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgA (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!Condition) {
        return;
    }

    PushError();

    va_start (args, Format);
    pFormatAndWriteMsgW (
        Type,
        Format,
        args
        );
    va_end (args);

    PopError();
}


VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        Title = Type;
    }

    StringCbCopyA (FormattedMsg, sizeof (FormattedMsg) - sizeof (S_COLUMNDOUBLELINEA), Title);
    StringCbCatA  (FormattedMsg, sizeof (FormattedMsg), S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, FormattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR FormattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR TypeW[OUTPUT_BUFSIZE_SMALL];

    StringCopyByteCountA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        KnownSizeAtoW (TypeW, Type);
        Title = TypeW;
    }

    #pragma prefast(suppress:209, "Using bytes is correct in sizeof(FormattedMsg)")
    StringCbCopyW (FormattedMsg, sizeof(FormattedMsg) - sizeof(S_COLUMNDOUBLELINEW), Title);

    #pragma prefast(suppress:209, "Using bytes is correct in sizeof(FormattedMsg)")
    StringCbCatW  (FormattedMsg, sizeof(FormattedMsg), S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, FormattedMsg);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR Output[OUTPUT_BUFSIZE_LARGE];
    BOOL HasNewLine = FALSE;
    PCSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyByteCountA (Output, Line, sizeof (Output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (Output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNT, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNT] == 0) {

            //
            // the line ends with a newline
            //

            HasNewLine = TRUE;
            break;
        }
    }

    if (!HasNewLine) {
        StringCbCatA (Output, sizeof(Output), S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, Output);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR Output[OUTPUT_BUFSIZE_LARGE];
    BOOL HasNewLine = FALSE;
    PCWSTR p;

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    StringCopyTcharCountW (Output, Line, sizeof (Output) / sizeof (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (Output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNT, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNT] == 0) {

            //
            // the line ends with a newline
            //

            HasNewLine = TRUE;
            break;
        }
    }

    if (!HasNewLine) {
        #pragma prefast(suppress:209, "Using bytes is correct in sizeof(Output)")
        StringCbCatW (Output, sizeof(Output), S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, Output);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text);
}


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef PROGRESS_BAR

VOID
_cdecl
LogTime (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCount = 0;
    static DWORD LastTickCount  = 0;
    DWORD CurrentTickCount;
    CHAR Msg[OUTPUT_BUFSIZE_LARGE];
    PSTR AppendPos;
    va_list args;

    PushError();

    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCount) {
        FirstTickCount = CurrentTickCount;
        LastTickCount  = CurrentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    StringCbVPrintfA(Msg, sizeof(Msg), Format, args);
    AppendPos = Msg + TcharCount(Msg);
    va_end (args);

    StringCbPrintfA(
        AppendPos,
        sizeof(Msg) - (AppendPos - Msg),
        "\t%lu\t%lu\r\n",
        CurrentTickCount - LastTickCount,
        CurrentTickCount - FirstTickCount
        );

    if (g_ProgressBarLog != INVALID_HANDLE_VALUE) {
        WriteFileStringA (g_ProgressBarLog, Msg);
    }

    LastTickCount = CurrentTickCount;

    PopError();
}

#else // !PROGRESS_BAR

#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if HIWORD(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCountA = 0;
    static DWORD LastTickCountA  = 0;
    CHAR Msg[OUTPUT_BUFSIZE_LARGE];
    CHAR Date[OUTPUT_BUFSIZE_SMALL];
    CHAR Time[OUTPUT_BUFSIZE_SMALL];
    PSTR AppendPos, End;
    DWORD CurrentTickCount;
    va_list args;

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            Date,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCbCopyA (Date, sizeof(Date), "** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            Time,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCbCopyA (Time, sizeof(Time), "** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCountA) {
        FirstTickCountA = CurrentTickCount;
        LastTickCountA  = CurrentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    StringCbVPrintfA (Msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    AppendPos = Msg + ByteCountA(Msg);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    End = Msg + OUTPUT_BUFSIZE_LARGE;
    StringCbPrintfA(
        AppendPos,
        End - AppendPos,
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        Date,
        Time,
        CurrentTickCount - LastTickCountA,
        CurrentTickCount - FirstTickCountA
        );

    LastTickCountA = CurrentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", Msg);

    PopError();
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    static DWORD FirstTickCountW = 0;
    static DWORD LastTickCountW  = 0;
    WCHAR MsgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR DateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR TimeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR FormatW;
    PWSTR AppendPosW, EndW;
    DWORD CurrentTickCount;
    va_list args;

    PushError();

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            DateW,
            OUTPUT_BUFSIZE_SMALL)) {
        #pragma prefast(suppress:209, "Using bytes is correct in sizeof(DateW)")
        StringCbCopyW (DateW, sizeof(DateW), L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            TimeW,
            OUTPUT_BUFSIZE_SMALL)) {
        StringCbCopyW (TimeW, sizeof(DateW), L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    CurrentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!FirstTickCountW) {
        FirstTickCountW = CurrentTickCount;
        LastTickCountW  = CurrentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    FormatW = ConvertAtoW (Format);
    StringCchVPrintfW(MsgW, OUTPUT_BUFSIZE_LARGE, FormatW, args);
    AppendPosW = MsgW + ByteCountW(MsgW);
    FreeConvertedStr (FormatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    EndW = MsgW + OUTPUT_BUFSIZE_LARGE;
    StringCchPrintfW(
        AppendPosW,
        EndW - AppendPosW,
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        DateW,
        TimeW,
        CurrentTickCount - LastTickCountW,
        CurrentTickCount - FirstTickCountW
        );

    LastTickCountW = CurrentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", MsgW);

    PopError();
}

#endif // DEBUG

#endif // PROGRESS_BAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\migutilp.h ===
#include "migshared.h"

#ifndef MSG_MESSAGEBOX_TITLE
#define MSG_MESSAGEBOX_TITLE        10000
#endif

extern POOLHANDLE g_RegistryApiPool;
extern POOLHANDLE g_PathsPool;
extern CRITICAL_SECTION g_PoolMemCs;
extern CRITICAL_SECTION g_MemAllocCs;

VOID
RegTrackTerminate (
    VOID
    );


BOOL
ReadBinaryBlock (
    HANDLE File,
    PVOID Buffer,
    UINT Size
    );

VOID
DestroyAnsiResourceId (
    IN      PCSTR AnsiId
    );

VOID
DestroyUnicodeResourceId (
    IN      PCWSTR UnicodeId
    );


VOID
InfGlobalInit (
    BOOL Terminate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\ipc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ipc.c

Abstract:

  The routines in this source file implement an interprocess communication
  mechanism to allow migration DLLs to be isolated into a separate process
  ("sandboxing").  This is done so that no DLL can affect the results of
  any other DLL or Setup.

  The IPC mechanism used here is memory mapped files.  Writes to the
  memory mapped file are synchronized by two events, one for the receiver
  and one by the host.

Author:

    Jim Schmidt (jimschm) 22-Mar-1997

Revision History:

    jimschm     19-Mar-2001 Removed DVD check (now in migration dll)
    jimschm     02-Jun-1999 Added IPC-based DVD check
    jimschm     21-Sep-1998 Converted from mailslots to memory mapped files.
                            (There are bugs in both Win9x and NT mailslots
                            that broke the original design.)
    jimschm     19-Jan-1998  Added beginings of WinVerifyTrust calls

    jimschm     15-Jul-1997  Added many workarounds for Win95 bugs.

--*/


#include "pch.h"
#include "migutilp.h"

#include <softpub.h>

#ifdef UNICODE
#error Build must be ANSI
#endif

#define DBG_IPC "Ipc"
#define SHARED_MEMORY_SIZE  0x10000




typedef struct {
    HANDLE Mapping;
    HANDLE DoCommand;
    HANDLE GetResults;
} IPCDATA, *PIPCDATA;

static PCTSTR g_Mode;
static HANDLE g_ProcessHandle;
static BOOL g_Host;
static IPCDATA g_IpcData;

VOID
pCloseIpcData (
    VOID
    );

BOOL
pOpenIpcData (
    VOID
    );

BOOL
pCreateIpcData (
    IN      PSECURITY_ATTRIBUTES psa
    );

typedef struct {
    DWORD   Command;
    DWORD   Result;
    DWORD   TechnicalLogId;
    DWORD   GuiLogId;
    DWORD   DataSize;
    BYTE    Data[];
} MAPDATA, *PMAPDATA;

BOOL
OpenIpcA (
    IN      BOOL Win95Side,
    IN      PCSTR ExePath,                  OPTIONAL
    IN      PCSTR RemoteArg,                OPTIONAL
    IN      PCSTR WorkingDir                OPTIONAL
    )

/*++

Routine Description:

  OpenIpc has two modes of operation, depending on who the caller is.  If the
  caller is w95upg.dll or w95upgnt.dll, then the IPC mode is called "host mode."
  If the caller is migisol.exe, then the IPC mode is called "remote mode."

  In host mode, OpenIpc creates all of the objects necessary to implement
  the IPC.  This includes two events, DoCommand and GetResults, and a
  file mapping.  After creating the objects, the remote process is launched.

  In remote mode, OpenIpc opens the existing objects that have already
  been created.

Arguments:

  Win95Side - Used in host mode only.  Specifies that w95upg.dll is running
              when TRUE, or that w95upgnt.dll is running when FALSE.

  ExePath   - Specifies the command line for migisol.exe.  Specifies NULL
              to indicate remote mode.

  RemoteArg - Used in host mode only.  Specifies the migration DLL
              path.  Ignored in remote mode.

  WorkingDir - Used in host mode only.  Specifies the working directory path
               for the migration DLL.  Ignored in remote mode.

Return value:

  TRUE if the IPC channel was opened.  If host mode, TRUE indicates that
  migisol.exe is up and running.  If remote mode, TRUE indicates that
  migisol is ready for commands.

--*/

{
    CHAR CmdLine[MAX_CMDLINE];
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL ProcessResult;
    HANDLE SyncEvent = NULL;
    HANDLE ObjectArray[2];
    DWORD rc;
    PSECURITY_DESCRIPTOR psd = NULL;
    SECURITY_ATTRIBUTES sa, *psa;
    BOOL Result = FALSE;
    HANDLE hToken = NULL;
    ULONG cbBuffer;
    PTOKEN_USER pUserToken = NULL;
    DWORD dwACLSize;
    PACL pACL = NULL;

#ifdef DEBUG
    g_Mode = ExePath ? TEXT("host") : TEXT("remote");
#endif

    __try {

        g_ProcessHandle = NULL;

        g_Host = (ExePath != NULL);

        if (ISNT()) {
            //
            // Create all access non-null DACL for NT
            //
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken)){
                DEBUGMSG((DBG_ERROR, "OpenIpcA:OpenProcessToken failed."));
                __leave;
            }
            cbBuffer = 0;
            if(GetTokenInformation(hToken, TokenUser, NULL, 0, &cbBuffer) || 
               GetLastError() != ERROR_INSUFFICIENT_BUFFER){
                DEBUGMSG((DBG_ERROR, "OpenIpcA:GetTokenInformation or GetLastError() != ERROR_INSUFFICIENT_BUFFER failed."));
                __leave;

            }
            pUserToken = (PTOKEN_USER)MemAlloc(g_hHeap, 0, cbBuffer);
            if(!pUserToken){
                __leave;    
            }
            
            if(!GetTokenInformation(hToken, TokenUser, pUserToken, cbBuffer, &cbBuffer)){
                DEBUGMSG((DBG_ERROR, "OpenIpcA:GetTokenInformation failed."));
                __leave;
            }
            
            dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 + GetLengthSid(pUserToken->User.Sid) - sizeof(DWORD);
            pACL = (PACL)MemAlloc(g_hHeap, 0, dwACLSize);
            
            if(!InitializeAcl(pACL, dwACLSize, ACL_REVISION2)){
                DEBUGMSG((DBG_ERROR, "OpenIpcA:InitializeAcl failed."));
                __leave;
            }
            
            if(!AddAccessAllowedAce(pACL, 
                                    ACL_REVISION, 
                                    GENERIC_ALL | STANDARD_RIGHTS_ALL, 
                                    pUserToken->User.Sid)){
                DEBUGMSG((DBG_ERROR, "OpenIpcA:AddAccessAllowedAce failed."));
                __leave;
            }

            ZeroMemory(&sa, sizeof(sa));

            psd = (PSECURITY_DESCRIPTOR)MemAlloc(g_hHeap, 0, SECURITY_DESCRIPTOR_MIN_LENGTH);

            if(!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) {
                DEBUGMSG((DBG_ERROR, "OpenIpcA:InitializeSecurityDescriptor failed."));
                __leave;
            }

            if(!SetSecurityDescriptorDacl(psd, TRUE, pACL, FALSE)) {
                DEBUGMSG((DBG_ERROR, "OpenIpcA:SetSecurityDescriptorDacl failed."));
                 __leave;
            }

            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = psd;

            psa = &sa;

        } else {
            psa = NULL;
        }

        if (g_Host) {
            //
            // Create the IPC objects
            //

            if (!pCreateIpcData (psa)) {
                DEBUGMSG ((DBG_ERROR, "Cannot create IPC channel"));
                __leave;
            }

            MYASSERT (RemoteArg);

            SyncEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("win9xupg"));
            MYASSERT (SyncEvent);

            //
            // Create the child process
            //

            if(FAILED(StringCchPrintfA(
                CmdLine,
                ARRAYSIZE(CmdLine), 
                "\"%s\" %s \"%s\"",
                ExePath,
                Win95Side ? "-r" : "-m",
                RemoteArg))
                )
            {
                LOG ((LOG_ERROR, "OpenIpcA: _snprintf cuts cmdline"));
                __leave;
            }

            ZeroMemory (&si, sizeof (si));
            si.cb = sizeof (si);
            si.dwFlags = STARTF_FORCEOFFFEEDBACK;

            ProcessResult = CreateProcessA (
                                NULL,
                                CmdLine,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_DEFAULT_ERROR_MODE,
                                NULL,
                                WorkingDir,
                                &si,
                                &pi
                                );

            if (ProcessResult) {
                CloseHandle (pi.hThread);
            } else {
                LOG ((LOG_ERROR, "Cannot start %s", CmdLine));
                __leave;
            }

            //
            // Wait for process to fail or wait for it to set the win95upg event
            //

            ObjectArray[0] = SyncEvent;
            ObjectArray[1] = pi.hProcess;
            rc = WaitForMultipleObjects (2, ObjectArray, FALSE, 60000);
            g_ProcessHandle = pi.hProcess;

            if (rc != WAIT_OBJECT_0) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "Process %x did not signal 'ready'. Wait timed out. (%s)",
                    g_ProcessHandle,
                    g_Mode
                    ));

                LOG ((LOG_ERROR, "Upgrade pack failed during process creation."));

                __leave;
            }

            DEBUGMSG ((DBG_IPC, "Process %s is running (%s)", CmdLine, g_Mode));

        } else {        // !g_Host
            //
            // Open the IPC objects
            //

            if (!pOpenIpcData()) {
                DEBUGMSG ((DBG_ERROR, "Cannot open IPC channel"));
                __leave;
            }

            //
            // Set event notifying setup that we've created our mailslot
            //

            SyncEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("win9xupg"));
            if (!SyncEvent) {
                __leave;
            }
            SetEvent (SyncEvent);
        }

        Result = TRUE;
    }

    __finally {
        //
        // Cleanup code
        //

        PushError();

        if (!Result) {
            CloseIpc();
        }

        if (SyncEvent) {
            CloseHandle (SyncEvent);
        }

        if (psd) {
            MemFree (g_hHeap, 0, psd);
        }
        if(hToken){
            CloseHandle(hToken);
        }
        if(pUserToken){
            MemFree(g_hHeap, 0, pUserToken);
        }
        if(pACL){
            MemFree(g_hHeap, 0, pACL);
        }

        PopError();
    }

    return Result;

}


BOOL
OpenIpcW (
    IN      BOOL Win95Side,
    IN      PCWSTR ExePath,                 OPTIONAL
    IN      PCWSTR RemoteArg,               OPTIONAL
    IN      PCWSTR WorkingDir               OPTIONAL
    )
{
    PCSTR AnsiExePath, AnsiRemoteArg, AnsiWorkingDir;
    BOOL b;

    if (ExePath) {
        AnsiExePath = ConvertWtoA (ExePath);
    } else {
        AnsiExePath = NULL;
    }

    if (RemoteArg) {
        AnsiRemoteArg = ConvertWtoA (RemoteArg);
    } else {
        AnsiRemoteArg = NULL;
    }

    if (WorkingDir) {
        AnsiWorkingDir = ConvertWtoA (WorkingDir);
    } else {
        AnsiWorkingDir = NULL;
    }

    b = OpenIpcA (Win95Side, AnsiExePath, AnsiRemoteArg, AnsiWorkingDir);

    if(AnsiExePath){
        FreeConvertedStr (AnsiExePath);
    }

    if(AnsiRemoteArg){
        FreeConvertedStr (AnsiRemoteArg);
    }
    
    if(AnsiWorkingDir){
        FreeConvertedStr (AnsiWorkingDir);
    }

    return b;
}


VOID
CloseIpc (
    VOID
    )

/*++

  Routine Description:

    Tells migisol.exe process to terminate, and then cleans up all resources
    opened by OpenIpc.

  Arguments:

    none

  Return Value:

    none

--*/

{
    if (g_Host) {
        //
        // Tell migisol.exe to terminate
        // if the communications channel is up
        //
        if (g_IpcData.Mapping && !SendIpcCommand (IPC_TERMINATE, NULL, 0)) {
            KillIpcProcess();
        }

        if (g_ProcessHandle) {
            WaitForSingleObject (g_ProcessHandle, 10000);
        }
    }

    pCloseIpcData();

    if (g_ProcessHandle) {
        CloseHandle (g_ProcessHandle);
        g_ProcessHandle = NULL;
    }
}


VOID
pCloseIpcData (
    VOID
    )
{
    if (g_IpcData.DoCommand) {
        CloseHandle (g_IpcData.DoCommand);
        g_IpcData.DoCommand = NULL;
    }

    if (g_IpcData.GetResults) {
        CloseHandle (g_IpcData.GetResults);
        g_IpcData.GetResults = NULL;
    }

    if (g_IpcData.Mapping) {
        CloseHandle (g_IpcData.Mapping);
        g_IpcData.Mapping = NULL;
    }
}


BOOL
pCreateIpcData (
    IN      PSECURITY_ATTRIBUTES psa
    )

/*++

Routine Description:

  pCreateIpcData creates the objects necessary to transfer data between
  migisol.exe and w95upg*.dll.  This function is called in host mode (i.e.,
  from w95upg.dll or w95upgnt.dll).

Arguments:

  psa - Specifies NT nul DACL, or NULL on Win9x

Return Value:

  TRUE if the objects were created properly, or FALSE if not.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = CreateEvent (psa, FALSE, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = CreateFileMapping (
                            INVALID_HANDLE_VALUE,
                            psa,
                            PAGE_READWRITE,
                            0,
                            SHARED_MEMORY_SIZE,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pCloseIpcData();
        return FALSE;
    }

    return TRUE;
}


BOOL
pOpenIpcData (
    VOID
    )

/*++

Routine Description:

  pOpenIpcData opens objects necessary to transfer data between migisol.exe
  and w95upg*.dll.  This funciton is called in remote mode (i.e., by
  migisol.exe).  This function must be called after the host has created the
  objects with pCreateIpcData.

Arguments:

  None.

Return Value:

  TRUE of the objects were opened successfully, FALSE otherwise.

--*/

{
    ZeroMemory (&g_IpcData, sizeof (g_IpcData));

    g_IpcData.DoCommand  = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.DoCommand"));
    g_IpcData.GetResults = OpenEvent (EVENT_ALL_ACCESS, FALSE, TEXT("Setup.GetResults"));

    g_IpcData.Mapping = OpenFileMapping (
                            FILE_MAP_READ|FILE_MAP_WRITE,
                            FALSE,
                            TEXT("Setup.IpcData")
                            );

    if (!g_IpcData.DoCommand ||
        !g_IpcData.GetResults ||
        !g_IpcData.Mapping
        ) {
        pCloseIpcData();
        return FALSE;
    }

    return TRUE;
}


BOOL
IsIpcProcessAlive (
    VOID
    )

/*++

Routine Description:

  IsIpcProcessAlive checks for the presense of migisol.exe.  This function is
  intended only for host mode.

Arguments:

  None.

Return Value:

  TRUE if migisol.exe is still running, FALSE otherwise.

--*/

{
    if (!g_ProcessHandle) {
        return FALSE;
    }

    if (WaitForSingleObject (g_ProcessHandle, 0) == WAIT_OBJECT_0) {
        return FALSE;
    }

    return TRUE;
}


VOID
KillIpcProcess (
    VOID
    )

/*++

Routine Description:

  KillIpcProcess forcefully terminates an open migisol.exe process.  This is
  used in GUI mode when the DLL refuses to die.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PushError();

    if (IsIpcProcessAlive()) {
        TerminateProcess (g_ProcessHandle, 0);
    }

    PopError();
}


DWORD
CheckForWaitingData (
    IN      HANDLE Slot,
    IN      DWORD MinimumSize,
    IN      DWORD Timeout
    )

/*++

Routine Description:

  CheckForWaitingData waits for data to be received by a mailslot.

  If the data does not arrive within the specified timeout, then zero is
  returned, and ERROR_SEM_TIMEOUT is set as the last error.

  If the data arrives within the specified timeout, then the number of
  waiting bytes are returned to the caller.

  This routine works around a Win95 bug with GetMailslotInfo.  Please
  change with caution.

Arguments:

  Slot - Specifies handle to inbound mailslot

  MinimumSize - Specifies the number of bytes that must be available before
                the routine considers the data to be available.  NOTE: If
                a message smaller than MinimumSize is waiting, this
                routine will be blocked until the timeout expires.
                This parameter must be greater than zero.

  Timeout - Specifies the number of milliseconds to wait for the message.

Return value:

  The number of bytes waiting in the mailslot, or 0 if the timeout was
  reached.

--*/

{
    DWORD WaitingSize;
    DWORD UnreliableTimeout;
    DWORD End;

    MYASSERT (MinimumSize > 0);

    End = GetTickCount() + Timeout;

    //
    // The wrap case -- this is really rare (once every 27 days),
    // so just let the tick count go back to zero
    //

    if (End < GetTickCount()) {
        while (End < GetTickCount()) {
            Sleep (100);
        }
        End = GetTickCount() + Timeout;
    }

    do {
        if (!GetMailslotInfo (Slot, NULL, &WaitingSize, NULL, &UnreliableTimeout)) {
            DEBUGMSG ((DBG_ERROR, "CheckForWaitingData: GetMailslotInfo failed (%s)", g_Mode));
            return 0;
        }

        //
        // WARNING: Win95 doesn't always return 0xffffffff when there is no data
        // available.  On some machines, Win9x has returned 0xc0ffffff.
        //

        WaitingSize = LOWORD(WaitingSize);

        if (WaitingSize < 0xffff && WaitingSize >= MinimumSize) {
            return WaitingSize;
        }
    } while (GetTickCount() < End);

    SetLastError (ERROR_SEM_TIMEOUT);
    return 0;
}



BOOL
pWriteIpcData (
    IN      HANDLE Mapping,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize,
    IN      DWORD Command,
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId
    )

/*++

Routine Description:

  pWriteIpcData puts data in the memory mapped block that migisol.exe and
  w95upg*.dll share.  The OS takes care of the synchronization for us.

Arguments:

  Mapping        - Specifies the open mapping object

  Data           - Specifies binary data to write

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

  Command        - Specifies a command DWORD, or 0 if not required

  ResultCode     - Specifies the result code of the last command, or 0 if not
                   applicable

  TechnicalLogId - Specifies the message constant ID (MSG_*) to be added to
                   setupact.log, or 0 if not applicable

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented via a popup, or 0 if not applicable

Return Value:

  TRUE if the data was written, FALSE if a sharing violation or other error
  occurs

--*/

{
    PMAPDATA MapData;

    if (!Data) {
        MYASSERT(!DataSize);
        DataSize = 0;
    }

    if((DataSize + sizeof(MAPDATA)) >= SHARED_MEMORY_SIZE){
        return FALSE;
    }

    MYASSERT (Mapping);
    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_WRITE, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    MapData->Command        = Command;
    MapData->Result         = ResultCode;
    MapData->TechnicalLogId = TechnicalLogId;
    MapData->GuiLogId       = GuiLogId;
    MapData->DataSize       = DataSize;

    if (DataSize) {
        CopyMemory (MapData->Data, Data, DataSize);
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
pReadIpcData (
    IN      HANDLE Mapping,
    OUT     PBYTE *Data,            OPTIONAL
    OUT     PDWORD DataSize,        OPTIONAL
    OUT     PDWORD Command,         OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  pReadIpcData retrieves data put in the shared memory block.  The OS takes
  care of synchronization for us.

Arguments:

  Mapping        - Specifies the memory mapping object

  Data           - Receives the inbound binary data, if any is available, or
                   NULL if no data is available.  The caller must free this
                   data with MemFree.

  DataSize       - Receives the number of bytes in Data

  Command        - Receives the inbound command, or 0 if no command was
                   specified

  ResultCode     - Receives the command result code, or 0 if not applicable

  TechnicalLogId - Receives the message constant (MSG_*) of the message to be
                   logged to setupact.log, or 0 if no message is to be logged

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if data was read, or FALSE if a sharing violation or other error occurs

--*/

{
    PMAPDATA MapData;

    MapData = (PMAPDATA) MapViewOfFile (Mapping, FILE_MAP_READ, 0, 0, 0);
    if (!MapData) {
        return FALSE;
    }

    if (Data) {
        if (MapData->DataSize) {
            *Data = MemAlloc (g_hHeap, 0, MapData->DataSize);
            MYASSERT (*Data);
            CopyMemory (*Data, MapData->Data, MapData->DataSize);
        } else {
            *Data = NULL;
        }
    }

    if (DataSize) {
        *DataSize = MapData->DataSize;
    }

    if (Command) {
        *Command = MapData->Command;
    }

    if (ResultCode) {
        *ResultCode = MapData->Result;
    }

    if (TechnicalLogId) {
        *TechnicalLogId = MapData->TechnicalLogId;
    }

    if (GuiLogId) {
        *GuiLogId = MapData->GuiLogId;
    }

    UnmapViewOfFile (MapData);

    return TRUE;
}


BOOL
SendIpcCommand (
    IN      DWORD Command,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  SendIpcCommand puts a command and optional binary data in the shared memory
  block.  It then sets the DoCommand event, triggering the other process to
  read the shared memory.  It is required that a command result is sent
  before the next SendIpcCommand.  See SendIpcCommandResult.

Arguments:

  Command  - Specifies the command to be executed by migisol.exe

  Data     - Specifies the data associated with the command

  DataSize - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command was placed in the shared memory block, FALSE otherwise

--*/

{
    if (!pWriteIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            0,
            0,
            0
            )) {
        DEBUGMSG ((DBG_ERROR, "SendIpcCommand: Can't send the command to the remote process"));
        return FALSE;
    }

    SetEvent (g_IpcData.DoCommand);

    return TRUE;
}


BOOL
GetIpcCommandResults (
    IN      DWORD Timeout,
    OUT     PBYTE *ReturnData,      OPTIONAL
    OUT     PDWORD ReturnDataSize,  OPTIONAL
    OUT     PDWORD ResultCode,      OPTIONAL
    OUT     PDWORD TechnicalLogId,  OPTIONAL
    OUT     PDWORD GuiLogId         OPTIONAL
    )

/*++

Routine Description:

  GetIpcCommandResults reads the shared memory block and returns the
  available data.

Arguments:

  Timeout        - Specifies the amount of time to wait for a command result
                   (in ms), or INFINITE to wait forever.

  ReturnData     - Receives the binary data associated with the command
                   result, or NULL if no data is associated with the result.
                   The caller must free this data with MemFree.

  ReturnDataSize - Receives the number of bytes in ReturnData, or 0 if
                   ReturnData is NULL.

  ResultCode     - Receives the command result code

  TechnicalLogId - Receives the message constant (MSG_*) to be logged in
                   setupact.log, or 0 if no message is specified

  GuiLogId       - Receives the message constant (MSG_*) of the message to be
                   presented in a popup, or 0 if no message is to be presented

Return Value:

  TRUE if command results were obtained, or FALSE if the wait timed out or
  the IPC connection crashed

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.GetResults, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pReadIpcData (
            g_IpcData.Mapping,
            ReturnData,
            ReturnDataSize,
            NULL,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    return b;
}


BOOL
GetIpcCommand (
    IN      DWORD Timeout,
    IN      PDWORD Command,         OPTIONAL
    IN      PBYTE *Data,            OPTIONAL
    IN      PDWORD DataSize         OPTIONAL
    )

/*++

Routine Description:

  GetIpcCommand obtains the command that needs to be processed.  This routine
  is called by migisol.exe (the remote process).

Arguments:

  Timeout  - Specifies the amount of time (in ms) to wait for a command, or
             INFINITE to wait forever

  Command  - Receives the command that needs to be executed

  Data     - Receives the data associated with the command.  The caller must
             free this block with MemFree.

  DataSize - Receives the number of bytes in Data, or 0 if Data is NULL.

Return Value:

  TRUE if a command was received, FALSE otherwise.

--*/

{
    DWORD rc;
    BOOL b;

    rc = WaitForSingleObject (g_IpcData.DoCommand, Timeout);

    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_NO_DATA);
        return FALSE;
    }

    b = pReadIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            Command,
            NULL,
            NULL,
            NULL
            );

    return b;
}


BOOL
SendIpcCommandResults (
    IN      DWORD ResultCode,
    IN      DWORD TechnicalLogId,
    IN      DWORD GuiLogId,
    IN      PBYTE Data,             OPTIONAL
    IN      DWORD DataSize
    )

/*++

Routine Description:

  SendIpcCommandResults puts the command results in the shared memory block.
  This routine is called by migisol.exe (the remote process).

Arguments:

  ResultCode     - Specifies the result code of the command.

  TechnicalLogId - Specifies the message constant (MSG_*) of the message to
                   be logged in setupact.log, or 0 if no message is to be
                   logged

  GuiLogId       - Specifies the message constant (MSG_*) of the message to
                   be presented in a popup to the user, or 0 if no message
                   needs to be presented

  Data           - Specifies the binary data to pass as command results, or
                   NULL of no binary data is required

  DataSize       - Specifies the number of bytes in Data, or 0 if Data is NULL

Return Value:

  TRUE if the command results were placed in shared memory, FALSE otherwise.

--*/

{
    BOOL b;

    b = pWriteIpcData (
            g_IpcData.Mapping,
            Data,
            DataSize,
            0,
            ResultCode,
            TechnicalLogId,
            GuiLogId
            );

    if (!b) {
        DEBUGMSG ((DBG_ERROR, "Can't write command results to IPC buffer"));
        return FALSE;
    }

    SetEvent (g_IpcData.GetResults);

    return TRUE;
}


BOOL
IsDllSignedA (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCSTR DllSpec
    )
{
    PCWSTR UnicodeStr;
    BOOL b;

    if(!DllSpec){
        MYASSERT(DllSpec);
        return FALSE;
    }

    UnicodeStr = CreateUnicode (DllSpec);
    if (!UnicodeStr) {
        return FALSE;
    }

    b = IsDllSignedW (WinVerifyTrustApi, UnicodeStr);

    DestroyUnicode (UnicodeStr);

    return b;
}


BOOL
IsDllSignedW (
    IN      WINVERIFYTRUST WinVerifyTrustApi,
    IN      PCWSTR DllSpec
    )
{
    GUID VerifyGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA WinTrustData;
    WINTRUST_FILE_INFO WinTrustFileInfo;
    LONG rc;

    if(!DllSpec){
        MYASSERT(DllSpec);
        return FALSE;
    }
    
    if (!WinVerifyTrustApi) {
        return TRUE;
    }

    ZeroMemory (&WinTrustData, sizeof (WinTrustData));
    ZeroMemory (&WinTrustFileInfo, sizeof (WinTrustFileInfo));

    WinTrustData.cbStruct       = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice     = WTD_UI_NONE;
    WinTrustData.dwUnionChoice  = WTD_CHOICE_FILE;
    WinTrustData.pFile          = &WinTrustFileInfo;

    WinTrustFileInfo.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    WinTrustFileInfo.hFile         = INVALID_HANDLE_VALUE;
    WinTrustFileInfo.pcwszFilePath = DllSpec;

    rc = WinVerifyTrustApi (
            INVALID_HANDLE_VALUE,
            &VerifyGuid,
            &WinTrustData
            );

    return rc == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be manipulated.

  The entry points are:

  OpenInfFile - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"
#include "migutilp.h"



//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

#define ASSERT_VALID_INF(handle) MYASSERT((handle) != INVALID_HANDLE_VALUE && (handle) != NULL)

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


typedef struct {
    HANDLE SourceInfFile;
    HANDLE DestInfFile;
    POOLHANDLE InfPool;             // A pool for appended INF data
    PINFSECTION FirstInfSection;    // The first section of the parsed INF
    PINFSECTION LastInfSection;     // The last section of the parsed INF
    BOOL InfIsUnicode;
} INFFILE, *PINFFILE;



BOOL
pReadInfIntoTable (
    IN OUT  PINFFILE InfFile,
    IN PWSTR SectionList,
    IN BOOL KeepComments
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.

Arguments:

  InfFile - Specifies the structure initilized with the INF file handle.
            Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = GROWBUF_INIT;
    PCWSTR Text;
    DWORD Pos;
    PCWSTR Key, Data;
    PWSTR p, q;
    DWORD i;
    PINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;
    HASHTABLE ht = NULL;
    BOOL neededSection = FALSE;
    PWSTR list;


    Section = AddInfSectionToTableW (InfFile, L"");
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }


    //
    // If we have a list of sections to fill, add them to a ht, for faster retrieval.
    //
    if (SectionList) {
        list = PoolMemDuplicateStringW (InfFile->InfPool, SectionList);
        MYASSERT(list);
        ht = HtAllocW ();
        if (ht) {
            while (list) {

                p = wcschr (list, L',');

                if (p) {
                    *p = 0;
                }

                HtAddStringW (ht, SkipSpaceW(list));

                if (p) {
                    *p = L',';
                    list = p + 1;
                }
                else {
                    list = p;
                }
            }
        }
        else {

            LOG ((LOG_ERROR, "Read Inf Into Table: Could not allocate section hash table."));
            return FALSE;
        }

    }


    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    MYASSERT(g_Buf1 && g_Buf2);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pGetInfFileWchar (InfFile->SourceInfFile, 0, &Error);
        InfFile->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        for (;;) {
            //
            // Get the line
            //

            Text = pGetNextInfLine (
                        InfFile->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        InfFile->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PWSTR) SkipSpaceW (Text);
            if (!p[0] || p[0] == L';') {
                if (KeepComments && !AddInfLineToTableW (InfFile, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (p[0] == L'[') {
                p++;
                q = wcschr (p, L']');
                if (!q) {
                    q = GetEndOfStringW (p);
                } else {
                    *q = 0;
                }

                if (!ht || HtFindStringW (ht, p)) {

                    Section = AddInfSectionToTableW (InfFile, p);
                    neededSection = TRUE;
                    if (!Section) {
                        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                        __leave;
                    }
                }
                else {

                    //
                    // We must not care about this section. Make sure we don't add any lines.
                    //
                    neededSection = FALSE;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                if (!neededSection) {
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (q[0] == L'\"') {
                    q = wcschr (q + 1, L'\"');
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q++;
                    }
                }

                i = (DWORD)wcscspn (q, L"\"=");

                if (q[i] == L'=') {
                    q += i;

                    Data = SkipSpaceW (q + 1);
                    *q = 0;
                    q = (PWSTR) SkipSpaceRW (Text, q);
                    if (q && *q) {
                        q++;
                        *q = 0;
                    }

                    Key = p;

                    if (Key[0] == L'\"') {

                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key++;

                        p = GetEndOfStringW (Key);
                        p = (PWSTR) SkipSpaceRW (Key, p);

                        if (p && *p) {
                            if (p[0] != L'\"') {
                                p++;
                            }

                            *p = 0;
                        }
                    }
                }

                if (!AddInfLineToTableW (InfFile, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (InfFile->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        FreeGrowBuffer (&LineBuf);
        if (ht) {
            HtFree (ht);
        }
    }

    return Result;
}


VOID
CloseInfFile (
    HINF InfFile
    )
{
    PINFFILE inf = (PINFFILE) InfFile;

    ASSERT_VALID_INF(InfFile);

    PoolMemEmptyPool (inf->InfPool);
    PoolMemDestroyPool (inf->InfPool);
    MemFree (g_hHeap, 0, inf);

}


HINF
OpenInfFileExA (
    IN      PCSTR InfFilePath,
    IN      PSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;
    PWSTR wSectionList = NULL;


    if(!InfFilePath){
        DEBUGMSG((DBG_ERROR, "OpenInfFileExW: InfFilePath is NULL."));
        return (HINF)INVALID_HANDLE_VALUE;
    }

    if (SectionList) {
        wSectionList = (PWSTR) ConvertAtoW (SectionList);
    }



    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileA (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PoolMemInitNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, wSectionList, KeepComments);
        CloseHandle (InfFile->SourceInfFile);
    }

    if (wSectionList) {
        FreeConvertedStr (wSectionList);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PoolMemDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


HINF
OpenInfFileExW (
    IN      PCWSTR InfFilePath,
    IN      PWSTR SectionList,
    IN      BOOL  KeepComments
    )
{
    PINFFILE InfFile;
    BOOL b = TRUE;

    if(!InfFilePath){
        DEBUGMSG((DBG_ERROR, "OpenInfFileExW: InfFilePath is NULL."));
        return (HINF)INVALID_HANDLE_VALUE;
    }

    InfFile = MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (INFFILE));

    InfFile->SourceInfFile = CreateFileW (
                                    InfFilePath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

    if (InfFile->SourceInfFile == INVALID_HANDLE_VALUE) {
        b = FALSE;
    } else {
        InfFile->InfPool = PoolMemInitNamedPool ("INF File");
        b = pReadInfIntoTable (InfFile, SectionList, KeepComments);
        CloseHandle (InfFile->SourceInfFile);
    }

    if (!b) {
        if (InfFile->InfPool) {
            PoolMemDestroyPool (InfFile->InfPool);
        }

        MemFree (g_hHeap, 0, InfFile);
        return INVALID_HANDLE_VALUE;
    }

    InfFile->SourceInfFile = INVALID_HANDLE_VALUE;

    return (HINF) InfFile;
}


BOOL
pWriteFileStringBufferedA (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PCSTR String
    )
{
    UINT stringBytes;
    PBYTE byteBuf;
    DWORD bytesWritten;

    MYASSERT(Buffer);

    if (!String) {
        if (Buffer->End) {
            if (!WriteFile (File, Buffer->Buf, Buffer->End, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != Buffer->End) {
                return FALSE;
            }

            Buffer->End = 0;
        }

        return TRUE;
    }

    stringBytes = ByteCountA (String);
    if (!stringBytes) {
        return TRUE;
    }

    if (stringBytes + Buffer->End > Buffer->Size) {
        //
        // Flush buffer by calling ourselves with a NULL String
        //

        if (!pWriteFileStringBufferedA (Buffer, File, NULL)) {
            return FALSE;
        }

        //
        // If string is huge, just write it directly
        //

        if (stringBytes > Buffer->Size) {
            if (!WriteFile (File, String, stringBytes, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != stringBytes) {
                return FALSE;
            }

            return TRUE;
        }
    }

    //
    // Put string in buffer
    //

    byteBuf = GrowBuffer (Buffer, stringBytes);
    MYASSERT(byteBuf);
    CopyMemory (byteBuf, String, stringBytes);

    return TRUE;
}


BOOL
pWriteFileStringBufferedW (
    IN      PGROWBUFFER Buffer,
    IN      HANDLE File,
    IN      PCWSTR String
    )
{
    UINT stringBytes;
    PBYTE byteBuf;
    DWORD bytesWritten;

    MYASSERT(Buffer);

    if (!String) {
        if (Buffer->End) {
            if (!WriteFile (File, Buffer->Buf, Buffer->End, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != Buffer->End) {
                return FALSE;
            }

            Buffer->End = 0;
        }

        return TRUE;
    }

    stringBytes = ByteCountW (String);

    if (stringBytes + Buffer->End > Buffer->Size) {
        //
        // Flush buffer by calling ourselves with a NULL String
        //

        if (!pWriteFileStringBufferedW (Buffer, File, NULL)) {
            return FALSE;
        }

        //
        // If string is huge, just write it directly
        //

        if (stringBytes > Buffer->Size) {
            if (!WriteFile (File, String, stringBytes, &bytesWritten, NULL)) {
                return FALSE;
            }

            if (bytesWritten != stringBytes) {
                return FALSE;
            }

            return TRUE;
        }
    }

    //
    // Put string in buffer
    //

    byteBuf = GrowBuffer (Buffer, stringBytes);
    MYASSERT(byteBuf);
    CopyMemory (byteBuf, String, stringBytes);

    return TRUE;
}


BOOL
pSaveInfToFile (
    IN      PINFFILE InfFile
    )

/*++

Routine Description:

  pSaveInfToFile writes the INF represented by the given memory image to disk.
  This is done by enumerating the INF data structures in the INF.

Arguments:

  InfFile - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PINFSECTION Section;
    PINFLINE Line;
    BYTE UnicodeHeader[] = { 0xff, 0xfe };
    DWORD DontCare;
    BOOL b = FALSE;
    GROWBUFFER outputBuf = GROWBUF_INIT;
    GROWBUFFER conversionBuf = GROWBUF_INIT;
    UINT maxBytes;

    ASSERT_VALID_INF(InfFile);

    MYASSERT (InfFile->SourceInfFile == INVALID_HANDLE_VALUE);
    MYASSERT (InfFile->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    __try {
        //
        // Write the unicode indicator. We rely on the fact that this is first--
        // the output buffer is not in use yet.
        //

        if (InfFile->InfIsUnicode) {
            if (!WriteFile (InfFile->DestInfFile, UnicodeHeader, sizeof (UnicodeHeader), &DontCare, NULL)) {
                __leave;
            }
        }

        //
        // Initialize the output buffer. It will never grow larger than what
        // we specify here.
        //

        GrowBuffer (&outputBuf, 16384);
        outputBuf.End = 0;

        //
        // Loop through all the sections
        //

        Section = InfFile->FirstInfSection;

        while (Section) {

            //
            // If a section name exists, write it in brackets. Section names
            // can be empty when comments appear at the top of the file.
            //

            if (Section->Name[0]) {

                if (InfFile->InfIsUnicode) {

                    if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"[") ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Section->Name) ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"]\r\n")
                        ) {
                        __leave;
                    }
                } else {

                    maxBytes = SizeOfStringW (Section->Name);
                    conversionBuf.End = 0;
                    GrowBuffer (&conversionBuf, maxBytes);

                    DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Section->Name, maxBytes);

                    if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "[") ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf) ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "]\r\n")
                        ) {
                        __leave;
                    }
                }
            }

            //
            // Write all the lines within the section
            //

            Line = Section->FirstLine;

            while (Line) {
                //
                // Write the key if it is present. Quote it if necessary.
                //

                if (Line->Key) {
                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (InfFile->InfIsUnicode) {
                            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\"")) {
                                __leave;
                            }
                        } else {
                            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\"")) {
                                __leave;
                            }
                        }
                    }

                    if (InfFile->InfIsUnicode) {

                        if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Line->Key)) {
                            __leave;
                        }

                    } else {

                        maxBytes = SizeOfStringW (Line->Key);
                        conversionBuf.End = 0;
                        GrowBuffer (&conversionBuf, maxBytes);

                        DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Line->Key, maxBytes);

                        if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf)) {
                            __leave;
                        }
                    }

                    if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {

                        if (InfFile->InfIsUnicode) {
                            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\"")) {
                                __leave;
                            }
                        } else {
                            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\"")) {
                                __leave;
                            }
                        }
                    }

                    //
                    // Note that when we write equals, we might add some
                    // space. Since space is trimmed by the INF parser, we say
                    // this is acceptable because it improves readability.
                    //

                    if (InfFile->InfIsUnicode) {

                        if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L" = ")) {
                            __leave;
                        }

                    } else {

                        if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, " = ")) {
                            __leave;
                        }
                    }
                }

                //
                // Write the rest of the line
                //

                if (InfFile->InfIsUnicode) {

                    if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, Line->Data) ||
                        !pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, L"\r\n")
                        ) {
                        __leave;
                    }

                } else {

                    maxBytes = SizeOfStringW (Line->Data);
                    conversionBuf.End = 0;
                    GrowBuffer (&conversionBuf, maxBytes);

                    DirectUnicodeToDbcsN ((PSTR) conversionBuf.Buf, Line->Data, maxBytes);

                    if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, (PCSTR) conversionBuf.Buf) ||
                        !pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, "\r\n")
                        ) {
                        __leave;
                    }
                }

                Line = Line->Next;
            }

            Section = Section->Next;
        }

        //
        // Flush output buffer
        //

        if (InfFile->InfIsUnicode) {
            if (!pWriteFileStringBufferedW (&outputBuf, InfFile->DestInfFile, NULL)) {
                __leave;
            }
        } else {
            if (!pWriteFileStringBufferedA (&outputBuf, InfFile->DestInfFile, NULL)) {
                __leave;
            }
        }

        b = TRUE;
    }
    __finally {
        FreeGrowBuffer (&outputBuf);
        FreeGrowBuffer (&conversionBuf);

        DEBUGMSG_IF((!b, DBG_ERROR, "Write Inf To Disk: Cannot write INF"));
    }

    return b;
}


BOOL
SaveInfFileA (
    IN      HINF Inf,
    IN      PCSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    ASSERT_VALID_INF(Inf);

    if(!SaveToFileSpec){
        DEBUGMSG((DBG_ERROR, "SaveInfFileA: SaveToFileSpec is NULL."));
        return FALSE;
    }

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileA (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileA (SaveToFileSpec);
    }

    return b;
}


BOOL
SaveInfFileW (
    IN      HINF Inf,
    IN      PCWSTR SaveToFileSpec
    )
{
    PINFFILE InfFile = (PINFFILE) Inf;
    BOOL b;

    ASSERT_VALID_INF(Inf);

    if(!SaveToFileSpec){
        DEBUGMSG((DBG_ERROR, "SaveInfFileW: SaveToFileSpec is NULL."));
        return FALSE;
    }

    if (Inf == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    InfFile->DestInfFile = CreateFileW (
                                SaveToFileSpec,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );

    if (InfFile->DestInfFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    b = pSaveInfToFile (InfFile);

    CloseHandle (InfFile->DestInfFile);
    InfFile->DestInfFile = INVALID_HANDLE_VALUE;

    if (!b) {
        DeleteFileW (SaveToFileSpec);
    }

    return b;
}


PINFSECTION
AddInfSectionToTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION SectionPtr;
    PCWSTR UnicodeSectionName;

    ASSERT_VALID_INF(Inf);

    if(!SectionName){
        DEBUGMSG((DBG_ERROR, "AddInfSectionToTableA: SectionName is NULL"));
        return NULL;
    }

    UnicodeSectionName = ConvertAtoW (SectionName);

    SectionPtr = AddInfSectionToTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return SectionPtr;
}


PINFSECTION
AddInfSectionToTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  Inf - Specifies the INF to add the section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PINFSECTION NewSection;
    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);

    //
    // Return early if this section already exists
    //

    MYASSERT(SectionName);

    NewSection = FindInfSectionInTableW (InfFile, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PINFSECTION) PoolMemGetAlignedMemory (
                                    InfFile->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PoolMemDuplicateStringW (
                            InfFile->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = InfFile->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        InfFile->FirstInfSection = NewSection;
    }

    //
    // Add a blank line to LastInfSection to make things tidy
    //

    if (InfFile->LastInfSection) {
        AddInfLineToTableW (Inf, InfFile->LastInfSection, NULL, L"", 0);
    }

    //
    // Finalize linkage
    //

    InfFile->LastInfSection = NewSection;

    return NewSection;
}


PINFLINE
AddInfLineToTableA (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCSTR Key,                      OPTIONAL
    IN      PCSTR Data,
    IN      DWORD LineFlags
    )
{
    PCWSTR UnicodeKey;
    PCWSTR UnicodeData;
    PINFLINE Line;

    ASSERT_VALID_INF(Inf);

    if (Key) {
        UnicodeKey = ConvertAtoW (Key);
    } else {
        UnicodeKey = NULL;
    }

    MYASSERT(Data);
    UnicodeData = ConvertAtoW (Data);

    Line = AddInfLineToTableW (Inf, SectionPtr, UnicodeKey, UnicodeData, LineFlags);

    if (Key) {
        FreeConvertedStr (UnicodeKey);
    }

    FreeConvertedStr (UnicodeData);

    return Line;
}


PINFLINE
AddInfLineToTableW (
    IN      HINF Inf,
    IN      PINFSECTION SectionPtr,
    IN      PCWSTR Key,                     OPTIONAL
    IN      PCWSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  InfFile - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PINFLINE NewLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);
    MYASSERT(SectionPtr);

    //
    // Allocate line struct
    //

    NewLine = (PINFLINE) PoolMemGetAlignedMemory (
                              InfFile->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link. We insert the line at the end
    // of the section but before all blank space.
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PoolMemDuplicateStringW (
                            InfFile->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PoolMemDuplicateStringW (
                        InfFile->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    while (NewLine->Prev) {
        if (NewLine->Prev->Key || *NewLine->Prev->Data) {
            break;
        }

        NewLine->Next = NewLine->Prev;
        NewLine->Prev = NewLine->Prev->Prev;
    }

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    if (NewLine->Next) {
        NewLine->Next->Prev = NewLine;
    } else {
        SectionPtr->LastLine = NewLine;
    }

    SectionPtr->LineCount++;

    return NewLine;
}


PINFSECTION
FindInfSectionInTableA (
    IN      HINF Inf,
    IN      PCSTR SectionName
    )
{
    PINFSECTION InfSectionPtr;
    PCWSTR UnicodeSectionName;

    ASSERT_VALID_INF(Inf);

    if(!SectionName){
        MYASSERT(SectionName);
        return NULL;
    }

    UnicodeSectionName = ConvertAtoW (SectionName);

    InfSectionPtr = FindInfSectionInTableW (Inf, UnicodeSectionName);

    FreeConvertedStr (UnicodeSectionName);

    return InfSectionPtr;
}


PINFSECTION
FindInfSectionInTableW (
    IN      HINF Inf,
    IN      PCWSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PINFSECTION Section;
    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);

    if(!SectionName){
        MYASSERT(SectionName);
        return NULL;
    }

    Section = InfFile->FirstInfSection;
    while (Section) {
        if (StringIMatchW (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PINFSECTION
GetFirstInfSectionInTable (
    IN HINF Inf
    )
{

    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);

    if (InfFile && InfFile != INVALID_HANDLE_VALUE) {
        return InfFile->FirstInfSection;
    }

    return NULL;
}

PINFSECTION
GetNextInfSectionInTable (
    IN PINFSECTION Section
    )
{

    if (Section) {
        return Section->Next;
    }

    return NULL;
}




PINFLINE
FindLineInInfSectionA (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCSTR Key
    )

{
    PCWSTR UnicodeKey;
    PINFLINE LinePtr;

    ASSERT_VALID_INF(Inf);

    if(!Key){
        MYASSERT(Key);
        return NULL;
    }

    UnicodeKey = ConvertAtoW (Key);

    LinePtr = FindLineInInfSectionW (Inf, Section, UnicodeKey);

    FreeConvertedStr (UnicodeKey);

    return LinePtr;
}


PINFLINE
FindLineInInfSectionW (
    IN      HINF Inf,
    IN      PINFSECTION Section,
    IN      PCWSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  Inf - Specifies the INF to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PINFLINE Line;

    ASSERT_VALID_INF(Inf);

    if(!Key){
        MYASSERT(Key);
        return NULL;
    }

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatchW (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PINFLINE
GetFirstLineInSectionStruct (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section || !Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return GetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PINFLINE
GetNextLineInSection (
    IN      PINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PINFLINE
GetFirstLineInSectionStrA (
    IN      HINF Inf,
    IN      PCSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PCWSTR UnicodeSection;
    PINFLINE LinePtr;

    ASSERT_VALID_INF(Inf);

    if(!Section){
        MYASSERT(Section);
        return NULL;
    }

    UnicodeSection = ConvertAtoW (Section);

    LinePtr = GetFirstLineInSectionStrW (Inf, UnicodeSection);

    FreeConvertedStr (UnicodeSection);

    return LinePtr;
}


PINFLINE
GetFirstLineInSectionStrW (
    IN      HINF Inf,
    IN      PCWSTR Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Inf - Specifies the INF that has the section

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PINFSECTION SectionPtr;
    PINFFILE Table = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);

    if(!Section){
        MYASSERT(Section);
        return NULL;
    }

    SectionPtr = FindInfSectionInTableW (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return GetFirstLineInSectionStruct (SectionPtr);
}


INT
pGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    MYASSERT(File != INVALID_HANDLE_VALUE);

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, (LONG)g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        g_Buf2End = g_Buf2Start;
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    MYASSERT(File != INVALID_HANDLE_VALUE);

    c = pGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        if(Error){
            *Error = TRUE;
        }
        return (WORD) c;
    }

    ch = (WORD) c;

    c = pGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        if(Error){
            *Error = TRUE;
        }
        return 0;
    }

    // pGetInfFileByte return a byte value or -1.
    // Since we checked for -1 the next cast is valid.
    ch += (WORD)(c * 256);
    if(Error){
        *Error = FALSE;
    }

    return ch;
}


PCSTR
pGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    MYASSERT(File != INVALID_HANDLE_VALUE);
    MYASSERT(LineBuf);

    EndPos = StartPos;
    for (;;) {
        c = pGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }
                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    MYASSERT(File != INVALID_HANDLE_VALUE);
    MYASSERT(LineBuf);

    EndPos = StartPos;
    for (;;) {

        ch = pGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == L'\r' || ch == L'\n') {
            EndPos += 2;
            if (ch == L'\r') {
                ch = pGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE) pGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCWSTR
pGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a string supplying the line.  This string can be any length and
  is nul-terminated.  It does not include the \r or \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCWSTR FinalStr;
    BOOL Converted = FALSE;

    MYASSERT(File != INVALID_HANDLE_VALUE);
    MYASSERT(LineBuf);

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }
        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = MultiSzAppendW (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCWSTR) LineBuf->Buf;
}


BOOL
DeleteLineInInfSection (
    IN      HINF Inf,
    IN      PINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  Inf - Specifies the INF to modify

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);
    MYASSERT(InfLine);

    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) InfLine);

    return TRUE;
}


BOOL
DeleteSectionInInfFile (
    IN      HINF Inf,
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  InfFile - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PINFLINE InfLine;
    PINFLINE DelInfLine;
    PINFFILE InfFile = (PINFFILE) Inf;

    ASSERT_VALID_INF(Inf);
    MYASSERT(Section);

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!DeleteLineInInfSection (InfFile, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        InfFile->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        InfFile->LastInfSection = Section->Prev;
    }

    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) Section->Name);
    PoolMemReleaseMemory (InfFile->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
GetInfSectionLineCount (
    IN      PINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    MYASSERT(Section);
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\main.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main source file of migutil.dll

Author:

    Jim Schmidt (jimschm)   01-Aug-1996

Revision History:

    jimschm     23-Sep-1998 Start thread
    marcw       23-Sep-1998 Locale fix
    jimschm     03-Nov-1997 Added TextAlloc routines
    marcw       22-Jul-1997 Added IS<platform> functions.

--*/


#include "pch.h"
#include "migutilp.h"
#include "locale.h"
#include <mbctype.h>

//#define DEBUG_ALL_FILES

OSVERSIONINFOA g_OsInfo;
extern OUR_CRITICAL_SECTION g_DebugMsgCs;

#define TEXT_GROWTH_SIZE    65536

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
PCSTR g_ErrorString = NULL;
HWND g_OutOfMemoryParentWnd;

//
// Flag used for MBCS string functions, which perform faster if the code page is NOT MBCS
//
BOOL g_IsMbcp = FALSE;

//
// OS-dependent flags for MultiByteToWideChar
//
DWORD g_MigutilWCToMBFlags = 0;

//
// A dynamic string. Among other things, this list can hold lists of imports
// as they are read out Win32 executables.
//
//DYNSTRING dynImp;

//
// g_ShortTermAllocTable is the default table used for resource string
// management.  New strings are allocated from the table.
//
// Allocation tables are very simple ways to store strings loaded in from
// the exe image.  The loaded string is copied into the table and kept
// around until it is explicitly freed.  Multiple attempts at getting the
// same resource string return the same string, inc'ing a use counter.
//
// g_LastAllocTable is a temporary holder for the wrapper APIs that
// do not require the caller to supply the alloc table.  DO NOT ALTER!
//
// g_OutOfMemoryTable is the table used to hold out-of-memory text.  It
// is loaded up at init time and is kept in memory for the whole time
// migutil is in use, so out-of-memory messages can always be displayed.
//

PGROWBUFFER g_ShortTermAllocTable;
PGROWBUFFER g_LastAllocTable;
PGROWBUFFER g_OutOfMemoryTable;

//
// We make sure the message APIs (GetStringResource, ParseMessageID, etc)
// are thread-safe
//

OUR_CRITICAL_SECTION g_MessageCs;
BOOL fInitedMessageCs = FALSE;

//
// The PoolMem routines must also be thread-safe
//

CRITICAL_SECTION g_PoolMemCs;
BOOL fInitedPoolMemCs = FALSE;

//
// MemAlloc critical section
//

CRITICAL_SECTION g_MemAllocCs;
BOOL fInitedMemAllocCs = FALSE;

//
// The following pools are used for text management.  g_RegistryApiPool is
// for reg.c, g_PathsPool is for the JoinPaths/DuplicatePath/etc routines,
// and g_TextPool is for AllocText, DupText, etc.
//

POOLHANDLE g_RegistryApiPool;
POOLHANDLE g_PathsPool;
POOLHANDLE g_TextPool;

//
// PC98 settings
//

BOOL g_IsPc98;

static CHAR g_BootDrivePathBufA[8];
static WCHAR g_BootDrivePathBufW[4];
PCSTR g_BootDrivePathA;
PCWSTR g_BootDrivePathW;
static CHAR g_BootDriveBufA[6];
static WCHAR g_BootDriveBufW[3];
PCSTR g_BootDriveA;
PCWSTR g_BootDriveW;
CHAR g_BootDriveLetterA;
WCHAR g_BootDriveLetterW;



//
// Implementation
//

BOOL
WINAPI
MigUtil_Entry (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{


    switch (dwReason) {

    case DLL_PROCESS_ATTACH:

        //
        // NOTE: If FALSE is returned, none of the executables will run.
        //       Every project executable links to this library.
        //

        if(!pSetupInitializeUtils()) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize SpUtils"));
            return FALSE;
        }

        //
        // Load in OSVERSION info.
        //
        g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        // this function only fails if we specify an invalid value
        // for the dwOSVersionInfoSize member (which we don't)
        if(!GetVersionExA(&g_OsInfo))
            MYASSERT(FALSE);

        //
        // Initialize the global flag indicating that a MBCS code page is in use
        //
        g_IsMbcp = (_getmbcp () != 0);

        //g_IsPc98 = (GetKeyboardType (0) == 7) && ((GetKeyboardType (1) & 0xff00) == 0x0d00);
        g_IsPc98 = FALSE;

        g_BootDrivePathA = g_BootDrivePathBufA;
        g_BootDrivePathW = g_BootDrivePathBufW;
        g_BootDriveA     = g_BootDriveBufA;
        g_BootDriveW     = g_BootDriveBufW;

        if (g_IsPc98) {
            StringCopyA ((PSTR) g_BootDrivePathA, "A:\\");
            StringCopyW ((PWSTR) g_BootDrivePathW, L"A:\\");
            StringCopyA ((PSTR) g_BootDriveA, "A:");
            StringCopyW ((PWSTR) g_BootDriveW, L"A:");
            g_BootDriveLetterA = 'A';
            g_BootDriveLetterW = L'A';
        } else {
            StringCopyA ((PSTR) g_BootDrivePathA, "C:\\");
            StringCopyW ((PWSTR) g_BootDrivePathW, L"C:\\");
            StringCopyA ((PSTR) g_BootDriveA, "C:");
            StringCopyW ((PWSTR) g_BootDriveW, L"C:");
            g_BootDriveLetterA = 'C';
            g_BootDriveLetterW = L'C';
        }

        // initialize log
        if (!LogInit (NULL)) {
            return FALSE;
        }

        // MemAlloc critical section
        InitializeCriticalSection (&g_MemAllocCs);
        fInitedMemAllocCs = TRUE;

        // Now that MemAlloc will work, initialize allocation tracking
        InitAllocationTracking();

        // PoolMem critical section
        InitializeCriticalSection (&g_PoolMemCs);
        fInitedPoolMemCs = TRUE;

        // The short-term alloc table for string resource utils
        g_ShortTermAllocTable = CreateAllocTable();
        if (!g_ShortTermAllocTable) {
            DEBUGMSG ((DBG_ERROR, "Cannot create short-term AllocTable"));
            return FALSE;
        }


        //
        // MultiByteToWideChar has desirable flags that only function on NT.
        // Because of our SUBSYSTEM=4.00 header requirements, we don't get
        // this constant.
        //
#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS      0x00000400
#endif

        g_MigutilWCToMBFlags = (ISNT()) ? WC_NO_BEST_FIT_CHARS : 0;


        // The critical section that guards ParseMessage/GetStringResource
        if (!InitializeOurCriticalSection (&g_MessageCs)) {
            DEBUGMSG ((DBG_ERROR, "Cannot initialize critical section"));
            DestroyAllocTable (g_ShortTermAllocTable);
            g_ShortTermAllocTable = NULL;
        }
        else
        {
            fInitedMessageCs = TRUE;
        }

        // A pool for APIs in reg.c
        g_RegistryApiPool = PoolMemInitNamedPool ("Registry API");
        g_PathsPool = PoolMemInitNamedPool ("Paths");
        g_TextPool = PoolMemInitNamedPool ("Text");

        if (!g_RegistryApiPool || !g_PathsPool || !g_TextPool) {
            return FALSE;
        }

        PoolMemSetMinimumGrowthSize (g_TextPool, TEXT_GROWTH_SIZE);

        // The "out of memory" message
        g_OutOfMemoryTable = CreateAllocTable();
        if (!g_OutOfMemoryTable) {
            DEBUGMSG ((DBG_ERROR, "Cannot create out of memory AllocTable"));
            return FALSE;
        }

        g_OutOfMemoryRetry  = GetStringResourceExA (g_OutOfMemoryTable, 10001 /* MSG_OUT_OF_MEMORY_RETRY */);
        g_OutOfMemoryString = GetStringResourceExA (g_OutOfMemoryTable, 10002 /* MSG_OUT_OF_MEMORY */);
        if (!g_OutOfMemoryString || !g_OutOfMemoryRetry) {
            DEBUGMSG ((DBG_WARNING, "Cannot load out of memory messages"));
        }

        g_ErrorString = GetStringResourceExA (g_OutOfMemoryTable, 10003 /* MSG_ERROR */);
        if (!g_ErrorString || g_ErrorString[0] == 0) {
            g_ErrorString = "Error";
        }

        //
        // set the locale to the system locale. Not doing this can cause isspace to Av in certain MBSCHR circumstances.
        //
        setlocale(LC_ALL,"");

        InfGlobalInit (FALSE);

        RegInitialize();

        break;

    case DLL_PROCESS_DETACH:

#ifdef DEBUG
        DumpOpenKeys();
        RegTerminate();
#endif
        InfGlobalInit (TRUE);

        if (g_RegistryApiPool) {
            PoolMemDestroyPool (g_RegistryApiPool);
        }
        if (g_PathsPool) {
            PoolMemDestroyPool (g_PathsPool);
        }
        if (g_TextPool) {
            PoolMemDestroyPool (g_TextPool);
        }

        if (g_ShortTermAllocTable) {
            DestroyAllocTable (g_ShortTermAllocTable);
        }

        if (g_OutOfMemoryTable) {
            DestroyAllocTable (g_OutOfMemoryTable);
        }

        FreeAllocationTracking();

        //
        // VERY LAST CODE TO RUN
        //

        DumpHeapStats();
        LogExit();
        pSetupUninitializeUtils();

        if (fInitedMessageCs) {
            DeleteOurCriticalSection (&g_MessageCs);
        }

        if (fInitedPoolMemCs) {
            DeleteCriticalSection (&g_PoolMemCs);
        }

        if (fInitedMemAllocCs) {
            DeleteCriticalSection (&g_MemAllocCs);
        }

        break;
    }
    return TRUE;
}



#define WIDTH(rect) (rect.right - rect.left)
#define HEIGHT(rect) (rect.bottom - rect.top)

void
CenterWindow (
    IN  HWND hwnd,
    IN  HWND Parent
    )
{
    RECT WndRect, ParentRect;
    int x, y;

    if (!Parent) {
        ParentRect.left = 0;
        ParentRect.top  = 0;
        ParentRect.right = GetSystemMetrics (SM_CXFULLSCREEN);
        ParentRect.bottom = GetSystemMetrics (SM_CYFULLSCREEN);
    } else {
        GetWindowRect (Parent, &ParentRect);
    }

    MYASSERT (IsWindow (hwnd));

    GetWindowRect (hwnd, &WndRect);

    x = ParentRect.left + (WIDTH(ParentRect) - WIDTH(WndRect)) / 2;
    y = ParentRect.top + (HEIGHT(ParentRect) - HEIGHT(WndRect)) / 2;

    SetWindowPos (hwnd, NULL, x, y, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}


static INT g_MigUtilWaitCounter = 0;
static HCURSOR g_MigUtilWaitCursor = NULL;

VOID
TurnOnWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOnWaitCursor sets the cursor to IDC_WAIT.  It maintains a use
  counter, so code requring the wait cursor can be nested.

Arguments:

  none

Return Value:

  none

--*/

{
    if (g_MigUtilWaitCounter == 0) {
        g_MigUtilWaitCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));
    }

    g_MigUtilWaitCounter++;
}


VOID
TurnOffWaitCursor (
    VOID
    )

/*++

Routine Description:

  TurnOffWaitCursor decrements the wait cursor counter, and if it
  reaches zero the cursor is restored.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_MigUtilWaitCounter) {
        DEBUGMSG ((DBG_WHOOPS, "TurnOffWaitCursor called too many times"));
    } else {
        g_MigUtilWaitCounter--;

        if (!g_MigUtilWaitCounter) {
            SetCursor (g_MigUtilWaitCursor);
        }
    }
}


/*++

Routine Description:

  Win9x does not support TryEnterOurCriticalSection, so we must implement
  our own version because it is quite a useful function.

Arguments:

  pcs - A pointer to an OUR_CRITICAL_SECTION object

Return Value:

  TRUE if the function succeeded, or FALSE if it failed.  See Win32
  SDK docs on critical sections, as these routines are identical to
  the caller.

--*/

BOOL
InitializeOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    // Create initially signaled, auto-reset event
    pcs->EventHandle = CreateEvent (NULL, FALSE, TRUE, NULL);
    if (!pcs->EventHandle) {
        return FALSE;
    }

    return TRUE;
}


VOID
DeleteOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    if (pcs->EventHandle) {
        CloseHandle (pcs->EventHandle);
        pcs->EventHandle = NULL;
    }

}


BOOL
EnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    // Wait for event to become signaled, then turn it off
    rc = WaitForSingleObject (pcs->EventHandle, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}

VOID
LeaveOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    SetEvent (pcs->EventHandle);
}

BOOL
TryEnterOurCriticalSection (
    OUR_CRITICAL_SECTION *pcs
    )
{
    DWORD rc;

    rc = WaitForSingleObject (pcs->EventHandle, 0);
    if (rc == WAIT_OBJECT_0) {
        return TRUE;
    }

    return FALSE;
}


#define REUSE_SIZE_PTR(ptr) ((PSIZE_T) ((PBYTE) ptr - sizeof (SIZE_T)))
#define REUSE_TAG_PTR(ptr)  ((PSIZE_T) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))

PVOID
ReuseAlloc (
    HANDLE Heap,
    PVOID OldPtr,
    SIZE_T SizeNeeded
    )
{
    SIZE_T CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(SIZE_T);

    //
    // HeapSize is bad, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (SIZE_T);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PSIZE_T) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (SIZE_T));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
ReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
SetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
OutOfMemory_Terminate (
    VOID
    )
{
    MessageBoxA (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        g_ErrorString,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    TerminateProcess (GetModuleHandle (NULL), 0);
}


VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBoxA (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    g_ErrorString,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                OutOfMemory_Terminate();
            }
        } else {
            OutOfMemory_Terminate();
        }
    }
}


PVOID
SafeHeapAlloc (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}



PVOID
SafeHeapReAlloc (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}



HANDLE
StartThread (
    IN      PTHREAD_START_ROUTINE Address,
    IN      PVOID Arg
    )
{
    DWORD DontCare;

    return CreateThread (NULL, 0, Address, Arg, 0, &DontCare);
}


BOOL
BuildSystemDirectoryPathA (
    OUT     PSTR Buffer,
    IN      UINT BufferSizeInTchars,
    IN      PCSTR SubPath               OPTIONAL
    )
{
    INT tcharsLeft;
    INT tcharsCopied;
    HRESULT hr;
    PSTR endOfBuffer;

    //
    // Compute the number of TCHARs available for c:\windows\system
    //

    tcharsLeft = BufferSizeInTchars;

    if (SubPath) {
        while (_mbsnextc (SubPath) == '\\') {
            SubPath = _mbsinc (SubPath);
        }

        tcharsLeft -= 1;                        // account for wack
        tcharsLeft -= TcharCountA (SubPath);    // account for subpath
    }

    if (tcharsLeft < 1) {
        return FALSE;
    }

    //
    // Get the system dir, validate the return result
    //

    tcharsCopied = GetSystemDirectoryA (Buffer, tcharsLeft);

    if (tcharsCopied == 0 || tcharsCopied >= tcharsLeft) {
        LOGA_IF ((SubPath != NULL, LOG_ERROR, "Can't build path to %s in system directory", SubPath));
        LOGA_IF ((!SubPath, LOG_ERROR, "Can't get system directory"));

        return FALSE;
    }

    //
    // Append the subpath if it was specified
    //

    if (SubPath) {
        //
        // Copy wack plus subpath, buffer space accounted for above.
        //

        endOfBuffer = Buffer + tcharsCopied;
        *endOfBuffer++ = '\\';

        tcharsLeft = BufferSizeInTchars - tcharsCopied - 1;
        MYASSERT (tcharsLeft > 0);

        hr = StringCchCopyA (endOfBuffer, tcharsLeft, SubPath);

        if (FAILED(hr)) {
            MYASSERT (FALSE);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
BuildSystemDirectoryPathW (
    OUT     PWSTR Buffer,
    IN      UINT BufferSizeInTchars,
    IN      PCWSTR SubPath              OPTIONAL
    )
{
    INT tcharsLeft;
    INT tcharsCopied;
    HRESULT hr;
    PWSTR endOfBuffer;

    //
    // Compute the number of TCHARs available for c:\windows\system
    //

    tcharsLeft = BufferSizeInTchars;

    if (SubPath) {
        while (*SubPath == '\\') {
            SubPath++;
        }

        tcharsLeft -= 1;                        // account for wack
        tcharsLeft -= TcharCountW (SubPath);    // account for subpath
    }

    if (tcharsLeft < 1) {
        return FALSE;
    }

    //
    // Get the system dir, validate the return result
    //

    tcharsCopied = GetSystemDirectoryW (Buffer, tcharsLeft);

    if (tcharsCopied == 0 || tcharsCopied >= tcharsLeft) {
        LOGW_IF ((SubPath != NULL, LOG_ERROR, "Can't build path to %s in system directory", SubPath));
        LOGW_IF ((!SubPath, LOG_ERROR, "Can't get system directory"));

        return FALSE;
    }

    //
    // Append the subpath if it was specified
    //

    if (SubPath) {
        //
        // Copy wack plus subpath, buffer space accounted for above.
        //

        endOfBuffer = Buffer + tcharsCopied;
        *endOfBuffer++ = L'\\';

        tcharsLeft = BufferSizeInTchars - tcharsCopied - 1;
        MYASSERT (tcharsLeft > 0);

        hr = StringCchCopyW (endOfBuffer, tcharsLeft, SubPath);

        if (FAILED(hr)) {
            MYASSERT (FALSE);
            return FALSE;
        }
    }

    return TRUE;
}


HMODULE
LoadSystemLibraryA (
    IN      PCSTR DllFileName
    )

/*++

Routine Description:

  LoadSystemLibraryW loads a DLL located in c:\windows\system (9x) or
  c:\windows\system32 (NT). If the DLL is not there, an error is generated.

Arguments:

  DllFileName - Specifies the file or file subpath to load. For example, it
                can be "kernel32.dll".

Return Value:

  The module handle, or NULL if an error occurs. Call GetLastError() for the
  error code.

--*/

{
    CHAR fullLibPath[MAX_MBCHAR_PATH];
    UINT result;

    if (!BuildSystemDirectoryPathA (fullLibPath, ARRAYSIZE(fullLibPath), DllFileName)) {
        return NULL;
    }

    return LoadLibraryA (fullLibPath);
}


HMODULE
LoadSystemLibraryW (
    IN      PCWSTR DllFileName
    )

/*++

Routine Description:

  LoadSystemLibraryW loads a DLL located in c:\windows\system32. If the DLL is
  not there, an error is generated.

  This version runs only on Windows NT, or on Win9x with the unicode layer.

Arguments:

  DllFileName - Specifies the file or file subpath to load. For example, it
                can be "kernel32.dll".

Return Value:

  The module handle, or NULL if an error occurs. Call GetLastError() for the
  error code.

--*/

{
    WCHAR fullLibPath[MAX_WCHAR_PATH];
    UINT result;

    if (!BuildSystemDirectoryPathW (fullLibPath, ARRAYSIZE(fullLibPath), DllFileName)) {
        return NULL;
    }

    return LoadLibraryW (fullLibPath);
}



/*++

Routine Description:

  OurGetModuleFileName is a wrapper for GetModuleFileName, but in addition

  it makes sure the output buffer is always nul-terminated.

Arguments:

  Same as GetModuleFileName

Return Value:

  Same as GetModuleFileName, but the output buffer is always nul-terminated

--*/

DWORD
OurGetModuleFileNameA (
    IN      HMODULE Module,
    OUT     PSTR Buffer,
    IN      INT BufferChars
    )
{
    //
    // call the real API
    //
#undef GetModuleFileNameA
    INT d = GetModuleFileNameA (Module, Buffer, BufferChars);
    if (BufferChars > 0) {
        Buffer[BufferChars - 1] = 0;
    } else {
        MYASSERT (FALSE);
    }
    return d < BufferChars ? d : 0;
}

DWORD
OurGetModuleFileNameW (
    IN      HMODULE Module,
    OUT     PWSTR Buffer,
    IN      INT BufferChars
    )
{
    //
    // call the real API
    //
#undef GetModuleFileNameW
    INT d = GetModuleFileNameW (Module, Buffer, BufferChars);
    if (BufferChars > 0) {
        Buffer[BufferChars - 1] = 0;
    } else {
        MYASSERT (FALSE);
    }
    return d < BufferChars ? d : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\linkpif.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    linkpif.c

Abstract:

    Functions to query and modify LNK and PIF files.

Author:

    Calin Negreanu (calinn) 07-Sep-1998

Revision History:

--*/


#include "pch.h"
#include "migutilp.h"


#include <pif.h>        // private\windows\inc


BOOL
InitCOMLinkA (
    OUT     IShellLinkA **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    if(!ShellLink || !PersistFile){
        MYASSERT(ShellLink);
        MYASSERT(PersistFile);
        return FALSE;
    }

    //
    // Initialize COM
    //
    hres = CoInitialize (NULL);
    if (!SUCCEEDED (hres)) {
        return FALSE;
    }

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkA, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
InitCOMLinkW (
    OUT     IShellLinkW **ShellLink,
    OUT     IPersistFile **PersistFile
    )
{
    HRESULT hres;
    BOOL result;

    if(!ShellLink || !PersistFile){
        MYASSERT(ShellLink);
        MYASSERT(PersistFile);
        return FALSE;
    }

    //
    // Initialize COM
    //
    hres = CoInitialize (NULL);
    if (!SUCCEEDED (hres)) {
        return FALSE;
    }

    *ShellLink = NULL;
    *PersistFile = NULL;
    result = FALSE;

    __try {

        //
        // Get a pointer to the IShellLink interface.
        //
        hres = CoCreateInstance (&CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, &IID_IShellLinkW, ShellLink);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        //
        // Get a pointer to the IPersistFile interface.
        //
        hres = (*ShellLink)->lpVtbl->QueryInterface ((*ShellLink), &IID_IPersistFile, PersistFile);

        if (!SUCCEEDED (hres)) {
            __leave;
        }

        result = TRUE;

    }
    __finally {

        if (!result) {

            if (*PersistFile) {
                (*PersistFile)->lpVtbl->Release (*PersistFile);
                *PersistFile = NULL;
            }

            if (*ShellLink) {
                (*ShellLink)->lpVtbl->Release (*ShellLink);
                *ShellLink = NULL;
            }
        }
    }

    if (!result) {
        //
        // Free COM
        //
        CoUninitialize ();
    }

    return result;
}

BOOL
FreeCOMLinkA (
    IN OUT  IShellLinkA **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}


BOOL
FreeCOMLinkW (
    IN OUT  IShellLinkW **ShellLink,
    IN OUT  IPersistFile **PersistFile
    )
{
    if (*PersistFile) {
        (*PersistFile)->lpVtbl->Release (*PersistFile);
        *PersistFile = NULL;
    }

    if (*ShellLink) {
        (*ShellLink)->lpVtbl->Release (*ShellLink);
        *ShellLink = NULL;
    }

    //
    // Free COM
    //
    CoUninitialize ();

    return TRUE;
}


PVOID
FindEnhPifSignature (
    IN      PVOID FileImage,
    IN      PCSTR Signature
    )

/*++

Routine Description:

  FindEnhPifSignature finds a certain PIF structure inside a PIF file (if it exists)
  based on a signature.

Arguments:

  FileImage - image of the PIF file mapped into memory

  Signature - structure signature

Return Value:

  address of the PIF structure, or NULL if non existent

--*/

{
    PBYTE tempPtr;
    PBYTE lastPtr;
    PVOID result = NULL;
    BOOL finished = FALSE;

    PPIFEXTHDR pifExtHdr;

    if(!FileImage || !Signature){
        MYASSERT(FileImage);
        MYASSERT(Signature);
        return NULL;
    }

    lastPtr = (PBYTE) FileImage;
    tempPtr = (PBYTE) FileImage;
    tempPtr += sizeof (STDPIF);

    pifExtHdr = (PPIFEXTHDR) tempPtr;
    __try {
        do {
            if (tempPtr < lastPtr) {
                result = NULL;
                break;
            } else {
                lastPtr = tempPtr;
            }
            finished = pifExtHdr->extnxthdrfloff == LASTHDRPTR;
            if (StringMatchA (pifExtHdr->extsig, Signature)) {
                result = tempPtr + sizeof (PIFEXTHDR);
                break;
            }
            else {
                tempPtr = (PBYTE)FileImage + pifExtHdr->extnxthdrfloff;
                pifExtHdr = (PPIFEXTHDR) tempPtr;
            }

        } while (!finished);
    }
    __except (1) {
        // something went wrong trying to access PIF file. Let's exit with NULL
        return NULL;
    }
    return result;
}


BOOL
ExtractPifInfoA(
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     BOOL  *MsDosMode,
    OUT     PLNK_EXTRA_DATAA ExtraData,      OPTIONAL
    IN      PCSTR FileName
    )
{
    PVOID  fileImage  = NULL;
    HANDLE mapHandle  = NULL;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;

    CHAR   tempStr [MEMDB_MAX];
    PSTR   strPtr;
    PSTR   dontCare;

    PSTDPIF    stdPif;
    PWENHPIF40 wenhPif40;
    PW386PIF30 w386ext30;

    BOOL result = TRUE;

    if(!FileName){
        MYASSERT(FileName);
        return FALSE;
    }

    //
    // This check will ensure we never overrun tempStr[MEMDB_MAX] buffer.
    // Max number of char this function able to use is MAX_PATH+64+1,
    // which is less than MEMDB_MAX.
    //
    if(TcharCountA(FileName) >= MAX_PATH){
        DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: TcharCountA(FileName) >= MAX_PATH"));
        return FALSE;
    }

    //
    // This function assume that:
    // Target is at least MAX_PATH char;
    // Params is at least 64 char;
    // WorkDir is at least MAX_PATH char;
    // IconPath is at least MAX_PATH char;
    //
    if(!Target || !Params || !WorkDir || !IconPath || !IconNumber || !MsDosMode){
        DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: Invalid parameters"));
        return FALSE;
    }

    *Target = *Params = *WorkDir = *IconPath = 0;
    *IconNumber = 0;
    *MsDosMode = FALSE;

    if (ExtraData) {
        ZeroMemory (ExtraData, sizeof(LNK_EXTRA_DATA));
    }

    __try {
        fileImage = MapFileIntoMemoryA (FileName, &fileHandle, &mapHandle);
        if (fileImage == NULL) {
            __leave;
        }
        __try {
            stdPif = (PSTDPIF) fileImage;


            //
            // getting working directory
            //
            if(SizeOfStringA(stdPif->defpath) > PIFDEFPATHSIZE){
                DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: SizeOfString(stdPif->defpath) > PIFDEFPATHSIZE (%s), function fails", stdPif->defpath));
                __leave;
            }
            _mbsncpy (tempStr, stdPif->defpath, PIFDEFPATHSIZE);

            // we might have a path terminated with a wack, we don't want that
            strPtr = our_mbsdec (tempStr, GetEndOfStringA (tempStr));
            if (strPtr) {
                if (_mbsnextc (strPtr) == '\\') {
                    *strPtr = 0;
                }
            }
            // now get the long path.
            // assume ARRAYSIZE(WorkDir) is at least MAX_PATH
            CopyFileSpecToLongA (tempStr, WorkDir);


            //
            // getting PIFs target
            //
            // assume ARRAYSIZE(Target) is at least PIFSTARTLOCSIZE(64)
            if(SizeOfStringA(stdPif->startfile) > PIFSTARTLOCSIZE){
                DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: SizeOfStringA(stdPif->startfile) > PIFSTARTLOCSIZE, function fails", stdPif->startfile));
                __leave;
            }
            _mbsncpy (Target, stdPif->startfile, PIFSTARTLOCSIZE);

            MYASSERT (ARRAYSIZE(tempStr) >= MAX_PATH * 2);  // unbounded copies below depend on a big buffer

            // in most cases, the target is without a path. We try to build the path, either
            // by using WorkDir or by calling SearchPath to look for this file.
            if (*Target) {//non empty target
                if (!DoesFileExist (Target)) {
                    if (*WorkDir) {
                        StringCopyA (tempStr, WorkDir);
                        StringCatA  (tempStr, "\\");
                        StringCatA  (tempStr, Target);
                    }
                    if (!DoesFileExist (tempStr)) {
                        StringCopyA (tempStr, FileName);
                        strPtr = _mbsrchr (tempStr, '\\');
                        if (strPtr) {
                            strPtr = _mbsinc (strPtr);
                            if (strPtr) {
                                StringCopyA (strPtr, Target);
                            }
                        }
                    }
                    if (!DoesFileExist (tempStr)) {
                        strPtr = (PSTR)GetFileNameFromPathA (Target);
                        if (!strPtr) {
                            strPtr = Target;
                        }
                        if (!SearchPathA (NULL, Target, NULL, ARRAYSIZE(tempStr), tempStr, &dontCare)) {
                            DEBUGMSG ((DBG_WARNING, "Could not find path for PIF target: %s", FileName));
                            StringCopyA (tempStr, Target);
                        }
                    }
                } else {
                    StringCopyA (tempStr, Target);
                }

                // now get the long path
                CopyFileSpecToLongA (tempStr, Target);
            }


            //
            // getting PIFs arguments
            //
            // assume ARRAYSIZE(Params) is at least PIFPARAMSSIZE(64)
            if(SizeOfStringA(stdPif->params) > PIFPARAMSSIZE){
                DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: SizeOfStringA(stdPif->params) > PIFPARAMSSIZE, function fails", stdPif->startfile));
                __leave;
            }
            _mbsncpy (Params, stdPif->params, PIFPARAMSSIZE);


            //
            // let's try to read the WENHPIF40 structure
            //
            wenhPif40 = FindEnhPifSignature (fileImage, WENHHDRSIG40);
            if (wenhPif40) {
                // assume ARRAYSIZE(IconPath) is at least MAX_PATH
                CopyFileSpecToLongA (wenhPif40->achIconFileProp, IconPath);
                *IconNumber = wenhPif40->wIconIndexProp;
                if (ExtraData) {
                    ExtraData->xSize = 80;
                    ExtraData->ySize = wenhPif40->vidProp.cScreenLines;
                    if (ExtraData->ySize < 25) {
                        ExtraData->ySize = 25;
                    }
                    ExtraData->QuickEdit = !(wenhPif40->mseProp.flMse & MSE_WINDOWENABLE);
                    ExtraData->CurrentCodePage = wenhPif40->fntProp.wCurrentCP;
                    // now let's do some crazy things trying to get the font used
                    {
                        LOGFONTA logFont;
                        HDC dc;
                        HFONT font;
                        HGDIOBJ oldObject;
                        TEXTMETRIC tm;

                        ZeroMemory (&logFont, sizeof (LOGFONTA));
                        logFont.lfHeight = wenhPif40->fntProp.cyFontActual;
                        logFont.lfWidth = wenhPif40->fntProp.cxFontActual;
                        logFont.lfEscapement = 0;
                        logFont.lfOrientation = 0;
                        logFont.lfWeight = FW_DONTCARE;
                        logFont.lfItalic = FALSE;
                        logFont.lfUnderline = FALSE;
                        logFont.lfStrikeOut = FALSE;
                        logFont.lfCharSet = DEFAULT_CHARSET;
                        logFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
                        logFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                        logFont.lfQuality = DEFAULT_QUALITY;
                        logFont.lfPitchAndFamily = DEFAULT_PITCH;
                        if (wenhPif40->fntProp.flFnt & FNT_TT) {
                            StringCopyTcharCountA(logFont.lfFaceName, wenhPif40->fntProp.achTTFaceName, ARRAYSIZE(logFont.lfFaceName));
                            StringCopyTcharCountA(ExtraData->FontName, wenhPif40->fntProp.achTTFaceName, ARRAYSIZE(ExtraData->FontName));
                        } else {
                            StringCopyTcharCountA(logFont.lfFaceName, wenhPif40->fntProp.achRasterFaceName, ARRAYSIZE(logFont.lfFaceName));
                            StringCopyTcharCountA(ExtraData->FontName, wenhPif40->fntProp.achRasterFaceName, ARRAYSIZE(ExtraData->FontName));
                        }
                        dc = CreateDCA ("DISPLAY", NULL, NULL, NULL);
                        if (dc) {
                            font = CreateFontIndirectA (&logFont);
                            if (font) {
                                oldObject = SelectObject (dc, font);

                                if (GetTextMetrics (dc, &tm)) {
                                    ExtraData->xFontSize = tm.tmAveCharWidth;
                                    ExtraData->yFontSize = tm.tmHeight;
                                    ExtraData->FontWeight = tm.tmWeight;
                                    ExtraData->FontFamily = tm.tmPitchAndFamily;
                                }
                                SelectObject (dc, oldObject);
                                DeleteObject (font);
                            }
                            DeleteDC (dc);
                        }
                    }
                }
            }
            w386ext30 = FindEnhPifSignature (fileImage, W386HDRSIG30);
            if (w386ext30) {
                if (((w386ext30->PfW386Flags & fRealMode      ) == fRealMode      ) ||
                    ((w386ext30->PfW386Flags & fRealModeSilent) == fRealModeSilent)
                    ) {
                    *MsDosMode = TRUE;
                }
                if (ExtraData) {
                    ExtraData->FullScreen = (w386ext30->PfW386Flags & fFullScreen) != 0;
                }
            }
        }
        __except (1) {
            // something went wrong when we tried to read or write PIF file,
            result = FALSE;
        }
    }
    __finally {
        UnmapFile (fileImage, mapHandle, fileHandle);
    }
    return result;
}


BOOL
ExtractPifInfoW(
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     BOOL   *MsDosMode,
    OUT     PLNK_EXTRA_DATAW ExtraData,      OPTIONAL
    IN      PCWSTR FileName
    )
{
    CHAR   aTarget   [MAX_MBCHAR_PATH];
    CHAR   aParams   [MAX_MBCHAR_PATH];
    CHAR   aWorkDir  [MAX_MBCHAR_PATH];
    CHAR   aIconPath [MAX_MBCHAR_PATH];
    PCSTR  aFileName;
    PCWSTR tempStrW;
    BOOL   result;
    LNK_EXTRA_DATAA extraDataA;

    if(!FileName || !Target || !Params || !WorkDir || !IconPath || !IconNumber || !MsDosMode){
        DEBUGMSG((DBG_ERROR, "ExtractPifInfoA: Invalid parameters"));
        return FALSE;
    }

    //
    // This function assume that:
    // Target is at least MAX_PATH char;
    // Params is at least 64 char;
    // WorkDir is at least MAX_PATH char;
    // IconPath is at least MAX_PATH char;
    //

    aFileName = ConvertWtoA (FileName);

    result = ExtractPifInfoA (
                aTarget,
                aParams,
                aWorkDir,
                aIconPath,
                IconNumber,
                MsDosMode,
                ExtraData?&extraDataA:NULL,
                aFileName
                );
    FreeConvertedStr (aFileName);

    tempStrW = ConvertAtoW (aTarget);
    StringCopyW (Target, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aParams);
    StringCopyW (Params, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aWorkDir);
    StringCopyW (WorkDir, tempStrW);
    FreeConvertedStr (tempStrW);

    tempStrW = ConvertAtoW (aIconPath);
    StringCopyW (IconPath, tempStrW);
    FreeConvertedStr (tempStrW);

    if (ExtraData) {
        ExtraData->FullScreen = extraDataA.FullScreen;
        ExtraData->xSize = extraDataA.xSize;
        ExtraData->ySize = extraDataA.ySize;
        ExtraData->QuickEdit = extraDataA.QuickEdit;
        tempStrW = ConvertAtoW (extraDataA.FontName);
        StringCopyW (ExtraData->FontName, tempStrW);
        FreeConvertedStr (tempStrW);
        ExtraData->xFontSize = extraDataA.xFontSize;
        ExtraData->yFontSize = extraDataA.yFontSize;
        ExtraData->FontWeight = extraDataA.FontWeight;
        ExtraData->FontFamily = extraDataA.FontFamily;
        ExtraData->CurrentCodePage = extraDataA.CurrentCodePage;
    }

    return result;
}


BOOL
ExtractShellLinkInfoA (
    OUT     PSTR Target,
    OUT     PSTR Params,
    OUT     PSTR WorkDir,
    OUT     PSTR IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     PINT ShowMode,                      OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    CHAR tempStr [MEMDB_MAX];
    PCSTR expandedStr;
    PCWSTR fileNameW;
    PSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAA fd;

    if(!FileName){
        MYASSERT(FileName);
        return FALSE;
    }

    if(TcharCountA(FileName) >= MAX_PATH){
        DEBUGMSG((DBG_ERROR, "ExtractShellLinkInfoA: TcharCountA(FileName) >= MAX_PATH"));
        return FALSE;
    }

    if(!ShellLink || !PersistFile || !PersistFile->lpVtbl || !ShellLink->lpVtbl ||
       !Target || !Params || !WorkDir || !IconPath || !IconNumber || !HotKey){
        DEBUGMSG((DBG_ERROR, "ExtractShellLinkInfoA: Invalid parameters"));
        return FALSE;
    }

    //
    // This function assume that:
    // Target is at least MAX_PATH char;
    // Params is at least MEMDB_MAX char;
    // WorkDir is at least MAX_PATH char;
    // IconPath is at least MAX_PATH char;
    //

    fileNameW = ConvertAtoW (FileName);
    hres = PersistFile->lpVtbl->Load(PersistFile, fileNameW, STGM_READ);
    FreeConvertedStr (fileNameW);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    expandedStr = ExpandEnvironmentTextA (tempStr);
    CopyFileSpecToLongA (expandedStr, Target);
    FreeTextA (expandedStr);

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    strPtr = GetEndOfStringA (tempStr);
    if (strPtr) {
        strPtr = _mbsdec (tempStr, strPtr);
        if (strPtr) {
            if (_mbsnextc (strPtr) == '\\') {
                *strPtr = 0;
            }
        }
    }
    CopyFileSpecToLongA (tempStr, WorkDir);

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                Params,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }
    CopyFileSpecToLongA (tempStr, IconPath);

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (ShellLink, HotKey);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    //
    // Get show command
    //
    if (ShowMode) {
        hres = ShellLink->lpVtbl->GetShowCmd (ShellLink, ShowMode);

        if (!SUCCEEDED(hres)) {
            DEBUGMSGA((DBG_WARNING, "Cannot read show mode for link %s", FileName));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ExtractShellLinkInfoW (
    OUT     PWSTR  Target,
    OUT     PWSTR  Params,
    OUT     PWSTR  WorkDir,
    OUT     PWSTR  IconPath,
    OUT     PINT   IconNumber,
    OUT     PWORD  HotKey,
    OUT     PINT ShowMode,
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    WCHAR tempStr [MEMDB_MAX];
    PCWSTR expandedStr;
    PWSTR strPtr;
    HRESULT hres;
    WIN32_FIND_DATAW fd;

    if(!FileName){
        MYASSERT(FileName);
        return FALSE;
    }

    if(TcharCountW(FileName) >= MAX_PATH){
        DEBUGMSG((DBG_ERROR, "ExtractShellLinkInfoA: TcharCountW(FileName) >= MAX_PATH"));
        return FALSE;
    }

    if(!ShellLink || !PersistFile || !PersistFile->lpVtbl || !ShellLink->lpVtbl ||
       !Target || !Params || !WorkDir || !IconPath || !IconNumber || !HotKey){
        DEBUGMSG((DBG_ERROR, "ExtractShellLinkInfoA: Invalid parameters"));
        return FALSE;
    }

    //
    // This function assume that:
    // Target is at least MAX_PATH char;
    // Params is at least MEMDB_MAX char;
    // WorkDir is at least MAX_PATH char;
    // IconPath is at least MAX_PATH char;
    //

    hres = PersistFile->lpVtbl->Load(PersistFile, FileName, STGM_READ);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot load link %s", FileName));
        return FALSE;
    }

    //
    // Get the link target
    //
    hres = ShellLink->lpVtbl->GetPath (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr),
                                &fd,
                                SLGP_RAWPATH
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGA((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    expandedStr = ExpandEnvironmentTextW (tempStr);
    CopyFileSpecToLongW (expandedStr, Target);
    FreeTextW (expandedStr);

    //
    // Get the link working directory
    //
    hres = ShellLink->lpVtbl->GetWorkingDirectory (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr)
                                );

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read target for link %s", FileName));
        return FALSE;
    }

    strPtr = GetEndOfStringW (tempStr) - 1;
    if (strPtr >= tempStr) {
        if (*strPtr == '\\') {
            *strPtr = 0;
        }
    }
    CopyFileSpecToLongW (tempStr, WorkDir);

    //
    // Get the arguments.
    //
    hres = ShellLink->lpVtbl->GetArguments (
                                ShellLink,
                                Params,
                                MEMDB_MAX
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read arguments for link %s", FileName));
        return FALSE;
    }

    //
    // Get icon path
    //
    hres = ShellLink->lpVtbl->GetIconLocation (
                                ShellLink,
                                tempStr,
                                ARRAYSIZE(tempStr),
                                IconNumber
                                );
    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read icon path for link %s", FileName));
        return FALSE;
    }

    CopyFileSpecToLongW (tempStr, IconPath);

    //
    // Get hot key
    //
    hres = ShellLink->lpVtbl->GetHotkey (ShellLink, HotKey);

    if (!SUCCEEDED(hres)) {
        DEBUGMSGW((DBG_WARNING, "Cannot read hot key for link %s", FileName));
        return FALSE;
    }

    //
    // Get show command
    //
    if (ShowMode) {
        hres = ShellLink->lpVtbl->GetShowCmd (ShellLink, ShowMode);

        if (!SUCCEEDED(hres)) {
            DEBUGMSGW((DBG_WARNING, "Cannot read show mode for link %s", FileName));
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
ExtractShortcutInfoA (
    OUT     PSTR  Target,
    OUT     PSTR  Params,
    OUT     PSTR  WorkDir,
    OUT     PSTR  IconPath,
    OUT     PINT  IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL  *DosApp,
    OUT     BOOL  *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAA ExtraData,     OPTIONAL
    IN      PCSTR FileName,
    IN      IShellLinkA *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCSTR shortcutExt = NULL;

    if(MsDosMode){
        *MsDosMode = FALSE;
    }
    if(DosApp){
        *DosApp = FALSE;
    }
    if(HotKey){
        *HotKey = 0;
    }

    if (ShowMode) {
        *ShowMode = SW_NORMAL;
    }

    if(!FileName){
        return FALSE;
    }

    shortcutExt = GetFileExtensionFromPathA (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchA (shortcutExt, "LNK")) {
            return ExtractShellLinkInfoA (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShowMode,
                        FileName,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchA (shortcutExt, "PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoA (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData,
                        FileName
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}


BOOL
ExtractShortcutInfoW (
    OUT     PWSTR Target,
    OUT     PWSTR Params,
    OUT     PWSTR WorkDir,
    OUT     PWSTR IconPath,
    OUT     PINT IconNumber,
    OUT     PWORD HotKey,
    OUT     BOOL *DosApp,
    OUT     BOOL *MsDosMode,
    OUT     PINT ShowMode,                  OPTIONAL
    OUT     PLNK_EXTRA_DATAW ExtraData,     OPTIONAL
    IN      PCWSTR FileName,
    IN      IShellLinkW *ShellLink,
    IN      IPersistFile *PersistFile
    )
{
    PCWSTR shortcutExt = NULL;

    if(MsDosMode){
        *MsDosMode = FALSE;
    }
    if(DosApp){
        *DosApp = FALSE;
    }
    if(HotKey){
        *HotKey = 0;
    }

    if (ShowMode) {
        *ShowMode = SW_NORMAL;
    }

    if(!FileName){
        return FALSE;
    }

    shortcutExt = GetFileExtensionFromPathW (FileName);

    if (shortcutExt != NULL) {
        if (StringIMatchW (shortcutExt, L"LNK")) {
            return ExtractShellLinkInfoW (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        HotKey,
                        ShowMode,
                        FileName,
                        ShellLink,
                        PersistFile
                        );

        } else if (StringIMatchW (shortcutExt, L"PIF")) {

            *DosApp = TRUE;
            return ExtractPifInfoW (
                        Target,
                        Params,
                        WorkDir,
                        IconPath,
                        IconNumber,
                        MsDosMode,
                        ExtraData,
                        FileName
                        );

        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\movelist.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    movelist.c

Abstract:

    Implements APIs to order nested renames

Author:

    03-Jun-2001 Jim Schmidt (jimschm)

Revision History:

    jimschm     03-Jun-2001     Moved from buildinf.c

--*/

#include "pch.h"
#include "migutilp.h"


#ifdef DEBUG
//#define MOVE_TEST
#endif

//
// Declare structures
//

#define MOVE_LIST_HASH_BUCKETS       11

struct TAG_MOVE_LIST_NODEW;

typedef struct {
    struct TAG_MOVE_LIST_NODEW *Left;
    struct TAG_MOVE_LIST_NODEW *Right;
    struct TAG_MOVE_LIST_NODEW *Parent;
} BINTREE_LINKAGE, *PBINTREE_LINKAGE;

#define SOURCE_LINKAGE          0
#define DESTINATION_LINKAGE     1

typedef struct TAG_MOVE_LIST_NODEW {
    BINTREE_LINKAGE Linkage[2];
    PCWSTR Source;
    PCWSTR Destination;
    PCWSTR FixedSource;
    PCWSTR FixedDestination;
} MOVE_LIST_NODEW, *PMOVE_LIST_NODEW;

typedef struct TAG_MOVE_LIST_GROUPW {
    PMOVE_LIST_NODEW SourceTreeRoot;
    struct TAG_MOVE_LIST_GROUPW *Next, *NextHash;
    UINT SourceLength;

#ifdef MOVE_TEST
    UINT ItemCount;
#endif

} MOVE_LIST_GROUPW, *PMOVE_LIST_GROUPW;

typedef struct TAG_MOVE_LISTW {
    PMOVE_LIST_GROUPW HeadGroup;
    PMOVE_LIST_GROUPW Buckets[MOVE_LIST_HASH_BUCKETS];
    struct TAG_MOVE_LISTW *NextChainedList;
    POOLHANDLE Pool;
    PMOVE_LIST_NODEW DestinationTreeRoot;

#ifdef MOVE_TEST
    UINT DestItemCount;
    UINT GroupCount;
#endif

} MOVE_LISTW, *PMOVE_LISTW;


typedef enum {
    BEGIN_LIST,
    BEGIN_LENGTH_GROUP,
    ENUM_RETURN_ITEM,
    ENUM_NEXT_ITEM,
    ENUM_NEXT_LENGTH_GROUP,
    ENUM_NEXT_LIST
} MOVE_ENUM_STATE;

typedef struct {
    // enum output
    PMOVE_LIST_NODEW Item;

    // private members
    MOVE_ENUM_STATE State;
    PMOVE_LIST_GROUPW LengthGroup;
    PMOVE_LISTW ThisList;
    PMOVE_LIST_NODEW StartFrom;
} MOVE_LIST_ENUMW, *PMOVE_LIST_ENUMW;



#ifdef MOVE_TEST

VOID
pTestList (
    IN      PMOVE_LISTW List
    );

INT
pCountTreeNodes (
    IN      PMOVE_LIST_GROUPW LengthGroup
    );

INT
pCountList (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_NODEW FromItem       OPTIONAL
    );

#endif


BOOL
pEnumFirstMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr,
    IN      PMOVE_LISTW List
    );

BOOL
pEnumNextMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr
    );




PMOVE_LISTW
pAllocateMoveList (
    IN      POOLHANDLE Pool
    )
{
    PMOVE_LISTW moveList;

    moveList = (PMOVE_LISTW) PoolMemGetMemory (Pool, sizeof (MOVE_LISTW));
    if (!moveList) {
        return NULL;
    }

    ZeroMemory (moveList, sizeof (MOVE_LISTW));
    moveList->Pool = Pool;

    return moveList;
}


MOVELISTW
AllocateMoveListW (
    IN      POOLHANDLE Pool
    )
{
    return (MOVELISTW) pAllocateMoveList (Pool);
}


PMOVE_LIST_GROUPW
pGetMoveListGroup (
    IN OUT  PMOVE_LISTW List,
    IN      UINT SourceLength
    )

/*++

Routine Description:

  pGetMoveListGroup searches the move list for the structure that represents
  the specified length. If no structure is found, then a new structure is
  allocated and inserted in the reverse-length-sorted list.

Arguments:

  List - Specifies the move list to search (as returned from pAllocateMoveList),
         receives updated pointers if an allocation occurred.

  SourceLength - Specifies the length of the source path, in WCHARs.

Return Value:

  A pointer to the move list group.

--*/

{
    PMOVE_LIST_GROUPW thisGroup;
    PMOVE_LIST_GROUPW insertAfter;
    PMOVE_LIST_GROUPW insertBefore = NULL;
    UINT hash;

    //
    // Search the current list for SourceLength. List is sorted from biggest
    // to smallest.
    //

    hash = SourceLength % MOVE_LIST_HASH_BUCKETS;
    thisGroup = List->Buckets[hash];

    while (thisGroup) {
        if (thisGroup->SourceLength == SourceLength) {
            return thisGroup;
        }

        thisGroup = thisGroup->NextHash;
    }

    //
    // Not in hash table; locate insert position
    //

    thisGroup = List->HeadGroup;

    while (thisGroup) {

        if (thisGroup->SourceLength < SourceLength) {
            break;
        }

        insertBefore = thisGroup;
        thisGroup = thisGroup->Next;
    }

    insertAfter = insertBefore;
    insertBefore = thisGroup;

    MYASSERT (!insertAfter || (insertAfter->Next == insertBefore));

    //
    // Allocate a new item
    //

    thisGroup = (PMOVE_LIST_GROUPW) PoolMemGetMemory (List->Pool, sizeof (MOVE_LISTW));
    if (thisGroup) {
        //
        // Insert it into the linked list, then the hash table
        //

        thisGroup->SourceLength = SourceLength;
        thisGroup->SourceTreeRoot = NULL;
        thisGroup->Next = insertBefore;         // insertBefore is on the right side

        if (insertAfter) {
            insertAfter->Next = thisGroup;
        } else {
            List->HeadGroup = thisGroup;
        }

        thisGroup->NextHash = List->Buckets[hash];
        List->Buckets[hash] = thisGroup;

#ifdef MOVE_TEST

        thisGroup->ItemCount = 0;
        List->GroupCount += 1;

#endif
    }

    return thisGroup;
}


INT
pCompareBackwards (
    IN      UINT Length,
    IN      PCWSTR LeftString,
    IN      PCWSTR RightString
    )
{
    INT result = 0;
    PCWSTR start = LeftString;

    LeftString += Length;
    RightString += Length;

    MYASSERT (*LeftString == 0);
    MYASSERT (*RightString == 0);

    while (LeftString > start) {
        LeftString--;
        RightString--;

        result = (INT) towlower (*RightString) - (INT) towlower (*LeftString);
        if (result) {
            break;
        }
    }

    return result;
}


PMOVE_LIST_NODEW
pFindNodeInTree (
    IN      PMOVE_LIST_NODEW Root,
    IN      UINT KeyLength,
    IN      PCWSTR Key,
    OUT     PMOVE_LIST_NODEW *Parent,
    OUT     PINT WhichChild
    )

/*++

Routine Description:

  pFindNodeInTree searches the binary tree for the specified source or
  destination path.

  In the case of a source path, KeyLength is non-zero, and Key specifies the
  source path. All elements in the binary tree have equal length.

  In the case of a destination path, KeyLength is zero, and Key specifies the
  destination path. All destination paths are in the same binary tree,
  regardless of length.

Arguments:

  Root - Specifies the root of the tree to search

  KeyLength - Specifies a non-zero wchar count of the characters in Key,
        excluding the terminator, or specifies zero for a destination path

  Key - Specifies the source or destination path to find

  Parent - Receives the pointer to the found node's parent, or NULL if the
        found node is the root of the tree. Receives an undefined value when a
        node is not found.

  WhichChild - Receives an indicator as to which child in Parent a new node
        should be inserted into.

        If the return value is non-NULL (a node was found), then WhichChild is
        set to zero.

        If the return value is NULL (a node was not found), then WhichChild is
        set to one of the following:

            < 0 - New node should be linked via Parent->Left
            > 0 - New node should be linked via Parent->Right
              0 - New node is the root of the tree

Return Value:

  A pointer to the found node, or NULL if the search key is not in the tree.

--*/

{
    PMOVE_LIST_NODEW thisNode;
    UINT linkageIndex;

    thisNode = Root;
    *Parent = NULL;
    *WhichChild = 0;

    linkageIndex = KeyLength ? SOURCE_LINKAGE : DESTINATION_LINKAGE;

    while (thisNode) {
        if (KeyLength) {
            *WhichChild = pCompareBackwards (KeyLength, thisNode->Source, Key);
        } else {
            *WhichChild = StringICompareW (Key, thisNode->Destination);
        }

        if (!(*WhichChild)) {
            return thisNode;
        }

        *Parent = thisNode;
        if (*WhichChild < 0) {
            thisNode = thisNode->Linkage[linkageIndex].Left;
        } else {
            thisNode = thisNode->Linkage[linkageIndex].Right;
        }
    }

    return NULL;
}


PMOVE_LIST_NODEW
pFindDestination (
    IN      PMOVE_LISTW List,
    IN      PCWSTR Destination
    )
{
    PMOVE_LIST_NODEW parent;
    INT compareResults;

    return pFindNodeInTree (
                List->DestinationTreeRoot,
                0,
                Destination,
                &parent,
                &compareResults
                );
}


BOOL
pInsertMovePairIntoEnabledGroup (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )
{
    PMOVE_LIST_NODEW node;
    PMOVE_LIST_NODEW srcParent;
    INT srcCompareResults;
    PMOVE_LIST_NODEW destNode;
    PMOVE_LIST_NODEW destParent;
    INT destCompareResults;

#ifdef MOVE_TEST
    INT count = pCountTreeNodes (LengthGroup);
#endif

    //
    // Check for duplicate dest
    //

    destNode = pFindNodeInTree (
                    List->DestinationTreeRoot,
                    0,
                    Destination,
                    &destParent,
                    &destCompareResults
                    );

    if (destNode) {
        DEBUGMSGW_IF ((
            !StringIMatchW (Source, destNode->Source),
            DBG_WARNING,
            "Destination %s is already in the moved list for %s; ignoring duplicate",
            Destination,
            destNode->Source
            ));

        return FALSE;
    }

    //
    // Search the tree for an existing source/dest pair
    //

    MYASSERT (TcharCountW (Source) == LengthGroup->SourceLength);
    MYASSERT (LengthGroup->SourceLength > 0);

    node = pFindNodeInTree (
                LengthGroup->SourceTreeRoot,
                LengthGroup->SourceLength,
                Source,
                &srcParent,
                &srcCompareResults
                );

    if (node) {
        DEBUGMSGW ((
            DBG_WARNING,
            "Ignoring move of %s to %s because source is already moved to %s",
            Source,
            Destination,
            node->Destination
            ));
        return FALSE;
    }

    //
    // Not in the tree; add it
    //

    node = (PMOVE_LIST_NODEW) PoolMemGetMemory (List->Pool, sizeof (MOVE_LIST_NODEW));
    if (!node) {
        return FALSE;
    }

    MYASSERT(Source);
    node->Source = PoolMemDuplicateStringW (List->Pool, Source);
    MYASSERT(Destination);
    node->Destination = PoolMemDuplicateStringW (List->Pool, Destination);
    node->FixedSource = node->Source;
    node->FixedDestination = node->Destination;

    //
    // Put source in binary tree
    //

    node->Linkage[SOURCE_LINKAGE].Left = NULL;
    node->Linkage[SOURCE_LINKAGE].Right = NULL;
    node->Linkage[SOURCE_LINKAGE].Parent = srcParent;

    if (!srcParent) {

        LengthGroup->SourceTreeRoot = node;

    } else if (srcCompareResults < 0) {

        MYASSERT (srcParent->Linkage[SOURCE_LINKAGE].Left == NULL);
        srcParent->Linkage[SOURCE_LINKAGE].Left = node;

    } else {

        MYASSERT (srcParent->Linkage[SOURCE_LINKAGE].Right == NULL);
        srcParent->Linkage[SOURCE_LINKAGE].Right = node;
    }

    //
    // Put dest in binary tree
    //

    node->Linkage[DESTINATION_LINKAGE].Left = NULL;
    node->Linkage[DESTINATION_LINKAGE].Right = NULL;
    node->Linkage[DESTINATION_LINKAGE].Parent = destParent;

    if (!destParent) {

        List->DestinationTreeRoot = node;

    } else if (destCompareResults < 0) {

        MYASSERT (destParent->Linkage[DESTINATION_LINKAGE].Left == NULL);
        destParent->Linkage[DESTINATION_LINKAGE].Left = node;

    } else {

        MYASSERT (destParent->Linkage[DESTINATION_LINKAGE].Right == NULL);
        destParent->Linkage[DESTINATION_LINKAGE].Right = node;
    }


#ifdef MOVE_TEST
    //
    // Verify the sanity of the data structures
    //

    LengthGroup->ItemCount += 1;
    List->DestItemCount += 1;

    pTestList (List);

    if (count + 1 != pCountTreeNodes (LengthGroup)) {
        DebugBreak();
    }

#endif

    return TRUE;
}


PMOVE_LIST_NODEW
pFindLeftmostNode (
    IN      PMOVE_LIST_NODEW Node,
    IN      UINT LinkageIndex
    )
{
    if (!Node) {
        return NULL;
    }

    while (Node->Linkage[LinkageIndex].Left) {
        Node = Node->Linkage[LinkageIndex].Left;
    }

    return Node;
}


PMOVE_LIST_NODEW
pFindRightmostNode (
    IN      PMOVE_LIST_NODEW Node,
    IN      UINT LinkageIndex
    )
{
    if (!Node) {
        return NULL;
    }

    while (Node->Linkage[LinkageIndex].Right) {
        Node = Node->Linkage[LinkageIndex].Right;
    }

    return Node;
}


PMOVE_LIST_NODEW
pEnumFirstItemInTree (
    IN      PMOVE_LIST_NODEW Root,
    IN      UINT LinkageIndex
    )
{
    if (!Root) {
        return NULL;
    }

    return pFindLeftmostNode (Root, LinkageIndex);
}


PMOVE_LIST_NODEW
pEnumNextItemInTree (
    IN      PMOVE_LIST_NODEW LastItem,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW nextItem;

    if (!LastItem) {
        return NULL;
    }

    if (LastItem->Linkage[LinkageIndex].Right) {
        return pFindLeftmostNode (
                    LastItem->Linkage[LinkageIndex].Right,
                    LinkageIndex
                    );
    }

    //
    // Go up the tree. If the parent's left pointer is not the last
    // item, then we are going up from the right side, and we need
    // to continue going up. It is important to note that the test
    // is not (nextItem->Right == LastItem) because we need to
    // support continuation from a deleted node. A deleted node
    // will not match any of the parent's children. If the deleted
    // node has no right pointer, then we need to keep going up.
    //
    // If the enum item was deleted, then left and parent point
    // to the next node.
    //

    nextItem = LastItem->Linkage[LinkageIndex].Parent;

    if (nextItem != LastItem->Linkage[LinkageIndex].Left) {

        while (nextItem && nextItem->Linkage[LinkageIndex].Left != LastItem) {
            LastItem = nextItem;
            nextItem = LastItem->Linkage[LinkageIndex].Parent;
        }

    }

    return nextItem;
}


#ifdef MOVE_TEST

INT
pCountList (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_NODEW FromItem       OPTIONAL
    )
{
    MOVE_LIST_ENUMW e;
    INT count = 0;
    BOOL startCounting;
    BOOL next = TRUE;
    INT debug = 2;

    if (!FromItem) {
        startCounting = TRUE;
    } else {
        startCounting = FALSE;
    }

    //
    // Count items in the binary tree
    //

    if (pEnumFirstMoveListItem (&e, List)) {

        do {
            if (FromItem == e.Item) {
                startCounting = TRUE;
            }

            if (startCounting) {
                if (debug) {
                    debug--;
                    DEBUGMSGW ((DBG_VERBOSE, "%i: %s", debug, e.Item->Source));
                }
                count++;
            }
        } while (pEnumNextMoveListItem (&e));
    }

    return count;
}


INT
pCountTreeNodes (
    IN      PMOVE_LIST_GROUPW LengthGroup
    )
{
    INT itemCount;
    PMOVE_LIST_NODEW thisNode;

    //
    // Count items in the binary tree
    //

    itemCount = 0;
    thisNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, SOURCE_LINKAGE);
    }

    return itemCount;
}


VOID
pTestDeleteAndEnum (
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PMOVE_LIST_NODEW DeletedNode
    )
{
    BOOL startCounting = FALSE;
    INT nodes;
    INT nodes2;
    PMOVE_LIST_NODEW nextNode;
    PMOVE_LIST_NODEW firstNodeAfterDeletion;

    //
    // Count # of nodes after DeletedNode
    //

    firstNodeAfterDeletion = pEnumNextItemInTree (DeletedNode, SOURCE_LINKAGE);
    nextNode = firstNodeAfterDeletion;
    nodes = 0;

    while (nextNode) {
        nodes++;
        nextNode = pEnumNextItemInTree (nextNode, SOURCE_LINKAGE);
    }

    //
    // Reenumerate the whole tree and verify the same # of nodes remain
    //

    nodes2 = 0;
    nextNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);

    while (nextNode) {
        if (nextNode == firstNodeAfterDeletion) {
            startCounting = TRUE;
        }

        if (startCounting) {
            nodes2++;
        }

        nextNode = pEnumNextItemInTree (nextNode, SOURCE_LINKAGE);
    }

    if (nodes != nodes2) {
        DebugBreak();
    }
}



VOID
pTestLengthGroup (
    IN      PMOVE_LIST_GROUPW LengthGroup
    )
{
    UINT itemCount;
    PMOVE_LIST_NODEW thisNode;

    MYASSERT(LengthGroup);

    //
    // Count items in the binary tree
    //

    itemCount = 0;
    thisNode = pEnumFirstItemInTree (LengthGroup->SourceTreeRoot, SOURCE_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, SOURCE_LINKAGE);
    }

    MYASSERT (itemCount == LengthGroup->ItemCount);
}

VOID
pTestList (
    IN      PMOVE_LISTW List
    )
{
    UINT itemCount;
    UINT groupCount;
    PMOVE_LIST_NODEW thisNode;
    PMOVE_LIST_GROUPW lengthGroup;

    MYASSERT(List);

    groupCount = 0;
    lengthGroup = List->HeadGroup;

    while (lengthGroup) {
        groupCount++;
        MYASSERT (pGetMoveListGroup (List, lengthGroup->SourceLength) == lengthGroup);

        pTestLengthGroup (lengthGroup);
        lengthGroup = lengthGroup->Next;
    }

    MYASSERT (groupCount == List->GroupCount);

    itemCount = 0;

    thisNode = pEnumFirstItemInTree (List->DestinationTreeRoot, DESTINATION_LINKAGE);
    while (thisNode) {
        itemCount++;
        thisNode = pEnumNextItemInTree (thisNode, DESTINATION_LINKAGE);
    }

    MYASSERT (itemCount == List->DestItemCount);
}

#endif


PMOVE_LIST_NODEW *
pFindParentChildLinkage (
    IN      PMOVE_LIST_NODEW Child,
    IN      PMOVE_LIST_NODEW *RootPointer,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW parent;

    MYASSERT(Child);

    parent = Child->Linkage[LinkageIndex].Parent;

    if (!parent) {
        return RootPointer;
    }

    if (parent->Linkage[LinkageIndex].Left == Child) {
        return &(parent->Linkage[LinkageIndex].Left);
    }

    MYASSERT (parent->Linkage[LinkageIndex].Right == Child);
    return &(parent->Linkage[LinkageIndex].Right);
}


VOID
pDeleteNodeFromBinaryTree (
    OUT     PMOVE_LIST_NODEW *RootPointer,
    IN      PMOVE_LIST_NODEW ItemToDelete,
    IN      UINT LinkageIndex
    )
{
    PMOVE_LIST_NODEW *parentChildLinkage;
    PMOVE_LIST_NODEW *swapNodeParentChildLinkage;
    PMOVE_LIST_NODEW swapNode;
    PMOVE_LIST_NODEW leftmostNode;
    PMOVE_LIST_NODEW nextEnumNode = NULL;
    PBINTREE_LINKAGE deleteItemLinkage;
    PBINTREE_LINKAGE leftLinkage;
    PBINTREE_LINKAGE rightLinkage;
    PBINTREE_LINKAGE swapLinkage;
    PBINTREE_LINKAGE leftmostLinkage;

    nextEnumNode = pEnumNextItemInTree (ItemToDelete, LinkageIndex);

    //
    // A node structure has multiple binary trees. We use the convention
    // of fooNode to represent the entire node structure, and fooLinkage
    // to represent just the left/right/parent structure for the tree
    // we are interested in. Kind of ugly, but necessary. A generalized
    // tree would not provide the optimum relationships.
    //

    //
    // Get the parent's link to the child, or the root pointer
    //

    parentChildLinkage = pFindParentChildLinkage (
                                ItemToDelete,
                                RootPointer,
                                LinkageIndex
                                );

    //
    // Remove the node from the tree. The complicated case is when we have a
    // node with two children. We attempt to move the children up as best as
    // we can.
    //

    deleteItemLinkage = &(ItemToDelete->Linkage[LinkageIndex]);

    if (deleteItemLinkage->Left && deleteItemLinkage->Right) {

        leftLinkage = &((deleteItemLinkage->Left)->Linkage[LinkageIndex]);
        rightLinkage = &((deleteItemLinkage->Right)->Linkage[LinkageIndex]);

        //
        // Node has left & right children. Search for a leaf node
        // that we can swap. We try to move items up as high as possible.
        //

        swapNode = pFindLeftmostNode (deleteItemLinkage->Right, LinkageIndex);
        swapLinkage = &(swapNode->Linkage[LinkageIndex]);

        if (swapLinkage->Right == NULL) {
            //
            // Found swapable node on the right side of ItemToDelete
            //

            MYASSERT (swapLinkage->Left == NULL);
            swapLinkage->Left = deleteItemLinkage->Left;
            leftLinkage->Parent = swapNode;

            if (swapNode != deleteItemLinkage->Right) {
                swapLinkage->Right = deleteItemLinkage->Right;
                rightLinkage->Parent = swapNode;
            }

        } else {
            //
            // Try to get a swapable node on the left side. If that
            // isn't possible, rechain the tree.
            //

            swapNode = pFindRightmostNode (deleteItemLinkage->Left, LinkageIndex);
            swapLinkage = &(swapNode->Linkage[LinkageIndex]);

            MYASSERT (swapLinkage->Right == NULL);

            swapLinkage->Right = deleteItemLinkage->Right;
            rightLinkage->Parent = swapNode;

            leftmostNode = pFindLeftmostNode (swapLinkage->Left, LinkageIndex);

            if (leftmostNode && leftmostNode != deleteItemLinkage->Left) {

                leftmostLinkage = &(leftmostNode->Linkage[LinkageIndex]);

                MYASSERT (leftmostLinkage->Left == NULL);

                leftmostLinkage->Left = deleteItemLinkage->Left;
                leftLinkage->Parent = leftmostNode;

            } else if (!leftmostNode) {
                MYASSERT (swapLinkage->Left == NULL);

                swapLinkage->Left = deleteItemLinkage->Left;
                leftLinkage->Parent = swapNode;
            }
        }

        swapNodeParentChildLinkage = pFindParentChildLinkage (
                                            swapNode,
                                            RootPointer,
                                            LinkageIndex
                                            );

        *swapNodeParentChildLinkage = NULL;

    } else if (deleteItemLinkage->Left) {
        //
        // Node has only a left child. Replace ItemToDelete with left child.
        //

        swapNode = deleteItemLinkage->Left;

    } else {
        //
        // Node has a right child or no children. Replace ItemToDelete
        // with right child if it is present.
        //

        swapNode = deleteItemLinkage->Right;
    }

    *parentChildLinkage = swapNode;

    if (swapNode) {
        swapLinkage = &(swapNode->Linkage[LinkageIndex]);
        swapLinkage->Parent = deleteItemLinkage->Parent;
    }

    //
    // Fix delete node pointers so enumeration can continue without interruption.
    // If nextEnumNode is NULL, enumeration will end.
    //

    deleteItemLinkage->Parent = nextEnumNode;
    deleteItemLinkage->Right = NULL;
    deleteItemLinkage->Left = nextEnumNode;
}


VOID
pDeleteMovePairFromGroup (
    IN      PMOVE_LISTW List,
    IN      PMOVE_LIST_GROUPW LengthGroup,
    IN      PMOVE_LIST_NODEW ItemToDelete
    )
{
    pDeleteNodeFromBinaryTree (
        &(LengthGroup->SourceTreeRoot),
        ItemToDelete,
        SOURCE_LINKAGE
        );

    pDeleteNodeFromBinaryTree (
        &(List->DestinationTreeRoot),
        ItemToDelete,
        DESTINATION_LINKAGE
        );

#ifdef MOVE_TEST

    LengthGroup->ItemCount -= 1;
    List->DestItemCount -= 1;

    pTestList (List);

#endif
}

BOOL
pEnumNextMoveListItem (
    IN OUT  PMOVE_LIST_ENUMW EnumPtr
    )
{
    MYASSERT(EnumPtr);

    for (;;) {

        switch (EnumPtr->State) {

        case BEGIN_LIST:
            if (!EnumPtr->ThisList) {
                return FALSE;
            }

            EnumPtr->LengthGroup = (EnumPtr->ThisList)->HeadGroup;
            EnumPtr->State = BEGIN_LENGTH_GROUP;

            break;

        case BEGIN_LENGTH_GROUP:
            if (!EnumPtr->LengthGroup) {

                EnumPtr->State = ENUM_NEXT_LIST;

            } else {

                EnumPtr->Item = pEnumFirstItemInTree (
                                    EnumPtr->LengthGroup->SourceTreeRoot,
                                    SOURCE_LINKAGE
                                    );

                EnumPtr->State = ENUM_RETURN_ITEM;
            }

            break;

        case ENUM_NEXT_ITEM:
            MYASSERT (EnumPtr->LengthGroup);
            MYASSERT (EnumPtr->Item);

            EnumPtr->Item = pEnumNextItemInTree (
                                EnumPtr->Item,
                                SOURCE_LINKAGE
                                );

            EnumPtr->State = ENUM_RETURN_ITEM;
            break;

        case ENUM_RETURN_ITEM:
            if (EnumPtr->Item) {
                EnumPtr->State = ENUM_NEXT_ITEM;
                return TRUE;
            }

            EnumPtr->State = ENUM_NEXT_LENGTH_GROUP;
            break;

        case ENUM_NEXT_LENGTH_GROUP:
            MYASSERT (EnumPtr->LengthGroup);
            EnumPtr->LengthGroup = (EnumPtr->LengthGroup)->Next;

            EnumPtr->State = BEGIN_LENGTH_GROUP;
            break;

        case ENUM_NEXT_LIST:
            MYASSERT (EnumPtr->ThisList);
            EnumPtr->ThisList = (EnumPtr->ThisList)->NextChainedList;

            EnumPtr->State = BEGIN_LIST;
            break;
        }
    }
}

BOOL
pEnumFirstMoveListItem (
    OUT     PMOVE_LIST_ENUMW EnumPtr,
    IN      PMOVE_LISTW List
    )
{
    MYASSERT(EnumPtr);

    if (!List) {
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (MOVE_LIST_ENUMW));
    EnumPtr->ThisList = List;
    EnumPtr->State = BEGIN_LIST;

    return pEnumNextMoveListItem (EnumPtr);
}


BOOL
pInsertMoveIntoListWorker (
    IN      PMOVE_LISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )

/*++

Routine Description:

  pInsertMoveIntoListWorker adds a source/dest move pair to a list and orders
  the list by the length of source (from biggest to smallest). This ensures
  nesting is taken care of properly.

  The move list is stored in the caller-owned pool. Before calling
  InsertMoveIntoList for the first time, the caller must first create a pool,
  and allocate a list from AllocateMoveListW.

  After the list is no longer needed, the caller frees all resources of the
  list by simply destroying the pool.

Arguments:

  List - Specifies the list to insert into

  Source - Specifies the source path

  Destination - Specifies the destination path

Return Value:

  TRUE if successful, FALSE if memory allocation failed, or if source is already
  in the list.

--*/

{
    PMOVE_LIST_GROUPW lengthGroup;
    UINT sourceLen;
    MOVE_LIST_ENUMW e;

    MYASSERT(Source);

    sourceLen = TcharCountW (Source);

    lengthGroup = pGetMoveListGroup (List, sourceLen);
    if (!lengthGroup) {
        return FALSE;
    }

    //
    // Insert pair into the list
    //

    if (!pInsertMovePairIntoEnabledGroup (
            List,
            lengthGroup,
            Source,
            Destination
            )) {
        return FALSE;
    }

    return TRUE;
}

BOOL
InsertMoveIntoListW (
    IN      MOVELISTW List,
    IN      PCWSTR Source,
    IN      PCWSTR Destination
    )
{
    return pInsertMoveIntoListWorker ((PMOVE_LISTW) List, Source, Destination);
}


VOID
pChainLists (
    IN      PMOVE_LISTW LeftList,
    IN      PMOVE_LISTW RightList
    )
{
    MYASSERT(LeftList);

    while (LeftList->NextChainedList) {
        LeftList = LeftList->NextChainedList;
        MYASSERT(LeftList);
    }

    LeftList->NextChainedList = RightList;
}


PMOVE_LISTW
pRemoveMoveListOverlapWorker (
    IN      PMOVE_LISTW List,
    IN      BOOL SkipPrePostLists
    )

/*++

Routine Description:

  pRemoveMoveListOverlapWorker searches the length-sorted move list and
  discards moves that are taken care of through moves of a parent. For
  example, consider the following moves:

  1. c:\a\b\c -> c:\x\c
  2. c:\a\b   -> c:\x

  In this case, line (1) is not needed, because it is implicit in line (2),
  even if line (1) is a file but line (2) is a subdirectory.

  This routine relies on the enumeration order. An item within that order
  is compared against items further down in the order.

  If there is a case such as:

  1. c:\a\b\c -> c:\x\q
  2. c:\a\b   -> c:\x

  This will produce an error, because the move cannot be executed. Line (1)
  would have to be moved first, but because it creates the destination of
  line (2), the second move will fail.

Arguments:

  List - Specifies the move list to check

  SkipPrePostLists - Specifies TRUE if the temp move algorithm should be
                     skipped; FALSE normally.

Return Value:

  The new move list that has overlaps removed. The caller must use the return
  value instead of the input List.

--*/

{
    PMOVE_LIST_NODEW currentNode;
    PMOVE_LIST_NODEW checkNode;
    PMOVE_LIST_NODEW collisionNode;
    UINT destLength;
    UINT collisionSrcLength = 0;
    BOOL disableThisPath;
    BOOL done;
    PCWSTR srcSubPath;
    PCWSTR destSubPath;
    PMOVE_LISTW preMoveList = NULL;
    PMOVE_LISTW postMoveList = NULL;
    WCHAR tempPathRoot[] = L"?:\\$tmp$dir.@xx";
    PCWSTR tempPath;
    PCWSTR subDir;
    PCWSTR collisionSrc;
    MOVE_LIST_ENUMW listEnum;
    PWSTR tempDest;
    PWSTR p;
    UINT currentNodeSrcLen;
    INT compareResult;
    PMOVE_LIST_GROUPW lengthGroup;
    BOOL currentMovedFirst;

    //
    // PASS 1: Minimize the list by eliminating nested moves
    //

    if (pEnumFirstMoveListItem (&listEnum, List)) {

        do {
            currentNode = listEnum.Item;
            currentNodeSrcLen = listEnum.LengthGroup->SourceLength;

            collisionNode = NULL;

            //
            // Locate a node that is further down the list but is
            // actually a parent of currentNode's destination
            //
            // That is, search for the following case:
            //
            //  collisionNode: c:\a -> c:\x
            //  currentNode:   c:\b -> c:\x\y
            //
            // collisionNode is moved ahead of currentNode.
            //

            disableThisPath = FALSE;
            done = FALSE;

            MYASSERT(currentNode->Destination);
            tempDest = DuplicatePathStringW (currentNode->Destination, 0);

            p = wcschr (tempDest + 3, L'\\');
            while (p) {
                *p = 0;

                __try {
                    checkNode = pFindDestination (List, tempDest);
                    if (!checkNode || (checkNode == currentNode)) {
                        __leave;
                    }

                    currentMovedFirst = TRUE;

                    MYASSERT(checkNode->Source);
                    collisionSrcLength = TcharCountW (checkNode->Source);

                    if (collisionSrcLength > currentNodeSrcLen) {
                        //
                        // checkNode is moved before currentNode
                        //

                        currentMovedFirst = FALSE;

                    } else if (currentNodeSrcLen == collisionSrcLength) {
                        //
                        // Need to compare source paths to see which one comes
                        // first. If the currentNode is alphabetically ahead of
                        // the collision, then its move will happen first.
                        //

                        compareResult = pCompareBackwards (
                                            collisionSrcLength,
                                            currentNode->Source,
                                            checkNode->Source
                                            );

                        if (compareResult < 0) {
                            currentMovedFirst = FALSE;
                        }
                    }

                    //
                    // currentNode's destination is a child of checkNode. We
                    // need to make sure currentNode's destination is not going
                    // to exist, or we need to ignore currentNode if it is
                    // implicitly handled by checkNode.
                    //

                    if (currentMovedFirst) {
                        //
                        // Record collision.
                        //
                        // currentNode->Source is moved ahead of checkNode->Source
                        // currentNode->Destination is a child of checkNode->Destination
                        //

                        if (!collisionNode) {
                            collisionNode = checkNode;
                        }

                        MYASSERT (TcharCountW (checkNode->Source) <= TcharCountW (currentNode->Source));

                        //
                        // If the subpath of currentNode's source is the same as its
                        // dest, and the base source path is the same for both,
                        // then remove currentNode. That is, we are testing for this case:
                        //
                        //  currentNode:    c:\a\y -> c:\x\y
                        //  checkNode:      c:\a   -> c:\x
                        //

                        MYASSERT (currentNodeSrcLen == TcharCountW (currentNode->Source));
                        MYASSERT (collisionSrcLength == TcharCountW (checkNode->Source));

                        if (StringIMatchTcharCountW (
                                currentNode->Source,
                                checkNode->Source,
                                collisionSrcLength
                                )) {

                            if (currentNode->Source[collisionSrcLength] == L'\\') {

                                //
                                // Now we know currentNode->Source is a child of
                                // checkNode->Source.
                                //

                                destLength = TcharCountW (checkNode->Destination);

                                srcSubPath = currentNode->Source + collisionSrcLength;
                                destSubPath = currentNode->Destination + destLength;

                                if (StringIMatchW (srcSubPath, destSubPath)) {
                                    //
                                    // Now we know that the sub path is identical.
                                    // The move in currentNode is handled implicitly
                                    // by checkNode, so we'll skip currentNode.
                                    //

                                    disableThisPath = TRUE;
                                    done = TRUE;
                                    __leave;
                                }
                            }
                        }
                    } else if (!SkipPrePostLists) {

                        MYASSERT (!currentMovedFirst);

                        if (!StringIPrefixW (currentNode->Source + 3, L"user~tmp.@0") &&
                            !StringIPrefixW (currentNode->Destination + 3, L"user~tmp.@0")
                            ) {

                            //
                            // We need to fix the case where the second destination is
                            // nested under the first. That is, currentNode->Destination
                            // is a subdir of checkNode->Destination.
                            //
                            // This is used for the case where:
                            //
                            //  checkNode:     c:\a -> c:\x
                            //  currentNode:   c:\b -> c:\x\y
                            //
                            // We must ensure that c:\a\y is not present for move 2.
                            // Therefore, we add 2 additional move operations:
                            //
                            // c:\a\y   -> c:\t\a\y
                            // c:\t\a\y -> c:\a\y
                            //
                            // This moves the collision out of the way, so that the parent
                            // can be moved, and then moves the folder back to its original
                            // location.
                            //
                            // The temp subdirectories for shell folders (user~tmp.@0?) are
                            // deliberatly ignored, because by definition they don't have
                            // collisions.
                            //

                            DEBUGMSGW ((
                                DBG_WARNING,
                                "Destination order collision:\n"
                                    "  Source: %s\n"
                                    "  Dest: %s\n"
                                    "  Collides with src: %s\n"
                                    "  Collides with dest: %s",
                                currentNode->Source,
                                currentNode->Destination,
                                checkNode->Source,
                                checkNode->Destination
                                ));

                            //
                            // compute pointer to subdir 'y' from c:\x\y
                            //

                            MYASSERT(checkNode->Destination);
                            destLength = TcharCountW (checkNode->Destination);

                            destSubPath = currentNode->Destination + destLength;
                            MYASSERT (*destSubPath == L'\\');   // this is because we tested by cutting at wacks above
                            destSubPath++;
                            MYASSERT (*destSubPath);

                            //
                            // build the path c:\a\y
                            //

                            MYASSERT(checkNode->Source);
                            collisionSrc = JoinPathsW (checkNode->Source, destSubPath);

                            //
                            // build the path c:\t\a\y
                            //

                            tempPathRoot[0] = currentNode->Destination[0];
                            subDir = wcschr (collisionSrc, L'\\');
                            MYASSERT (subDir);
                            subDir++;
                            MYASSERT (*subDir);     // we should not ever move a root dir

                            tempPath = JoinPathsW (tempPathRoot, subDir);

                            //
                            // move c:\a\y (might not exist) to c:\t\a\y, then
                            // reverse the move
                            //

                            DEBUGMSGW ((
                                DBG_WARNING,
                                "Avoiding collision problems by deliberately not moving %s",
                                collisionSrc
                                ));

                            if (!preMoveList) {
                                preMoveList = pAllocateMoveList (List->Pool);
                                postMoveList = pAllocateMoveList (List->Pool);
                            }

                            if (preMoveList) {
                                pInsertMoveIntoListWorker (
                                    preMoveList,
                                    collisionSrc,
                                    tempPath
                                    );

                                pInsertMoveIntoListWorker (
                                    postMoveList,
                                    tempPath,
                                    collisionSrc
                                    );
                            }

                            FreePathStringW (collisionSrc);
                            FreePathStringW (tempPath);
                        }
                    }
                }
                __finally {
                    MYASSERT (TRUE);        // workaround for debugging
                }

                if (done) {
                    break;
                }

                *p = L'\\';
                p = wcschr (p + 1, L'\\');
            }

            FreePathStringW (tempDest);

            if (disableThisPath) {
                //
                // Remove currentNode from the list
                //

                MYASSERT (collisionNode);

                DEBUGMSGW ((
                    DBG_VERBOSE,
                    "Ignoring contained move:\n"
                        "  Source: %s\n"
                        "  Dest: %s\n"
                        "  Contained src: %s\n"
                        "  Contained dest: %s",
                    currentNode->Source,
                    currentNode->Destination,
                    collisionNode->Source,
                    collisionNode->Destination
                    ));

                lengthGroup = pGetMoveListGroup (List, currentNodeSrcLen);
                pDeleteMovePairFromGroup (List, lengthGroup, currentNode);
            }

        } while (pEnumNextMoveListItem (&listEnum));
    }

    //
    // PASS 2: After list is minimized, correct order issues, so that
    //         all moves can succeed.
    //

    if (pEnumFirstMoveListItem (&listEnum, List)) {

        do {
            currentNode = listEnum.Item;

            MYASSERT(currentNode->FixedSource);
            currentNodeSrcLen = TcharCountW (currentNode->FixedSource);

            MYASSERT(currentNode->FixedDestination);
            destLength = TcharCountW (currentNode->FixedDestination);

            //
            // Locate a node that is further down the list but is actually a
            // parent of currentNode's destination
            //
            // That is, search for the following case:
            //
            //  checkNode:      c:\a -> c:\x
            //  currentNode:    c:\b -> c:\x\y
            //
            // checkNode is moved ahead of currentNode.
            //

            done = FALSE;
            tempDest = DuplicatePathStringW (currentNode->FixedDestination, 0);

            p = wcschr (tempDest + 3, L'\\');
            while (p) {
                *p = 0;

                __try {
                    //
                    // Find destination that is created ahead of currentNode's dest
                    //

                    checkNode = pFindDestination (List, tempDest);
                    if (!checkNode || (checkNode == currentNode)) {
                        __leave;
                    }

                    if (destLength <= TcharCountW (checkNode->FixedDestination)) {
                        __leave;
                    }

                    currentMovedFirst = TRUE;

                    collisionSrcLength = TcharCountW (checkNode->FixedSource);

                    if (collisionSrcLength > currentNodeSrcLen) {
                        currentMovedFirst = FALSE;

                    } else if (currentNodeSrcLen == collisionSrcLength) {

                        compareResult = pCompareBackwards (
                                            collisionSrcLength,
                                            currentNode->FixedSource,
                                            checkNode->FixedSource
                                            );

                        if (compareResult < 0) {
                            currentMovedFirst = FALSE;
                        }
                    }

                    if (currentMovedFirst) {

                        MYASSERT (TcharCountW (checkNode->FixedSource) <= TcharCountW (currentNode->FixedSource));

                        //
                        // We found a move contradiction, such as the following...
                        //
                        //  currentNode:    c:\a    -> c:\x\y
                        //  checkNode:      c:\b    -> c:\x
                        //
                        // or
                        //
                        //  currentNode:    c:\b\a  -> c:\x\y
                        //  checkNode:      c:\b    -> c:\x
                        //
                        // ...so we must reverse the order of the moves. This is done
                        // by swapping the strings. We have a separate set of pointers,
                        // so that the binary tree properties are not disturbed.
                        //

                        currentNode->FixedSource = checkNode->Source;
                        currentNode->FixedDestination = checkNode->Destination;

                        checkNode->FixedSource = currentNode->Source;
                        checkNode->FixedDestination = currentNode->Destination;

                        DEBUGMSGW ((
                            DBG_WARNING,
                            "Source order and dest order contradict each other. Fixing by reversing the order to:\n\n"
                                "%s -> %s\n"
                                "- before -\n"
                                "%s -> %s",
                            currentNode->FixedSource,
                            currentNode->FixedDestination,
                            checkNode->FixedSource,
                            checkNode->FixedDestination
                            ));

                        currentNodeSrcLen = collisionSrcLength;

                        FreePathStringW (tempDest);
                        tempDest = DuplicatePathStringW (currentNode->FixedDestination, 0);

                        destLength = TcharCountW (currentNode->FixedDestination);

                        p = wcschr (tempDest, L'\\');
                        if (!p) {
                            MYASSERT (FALSE);
                            done = TRUE;
                            __leave;
                        }
                    }
                }
                __finally {
                }

                if (done) {
                    break;
                }

                *p = L'\\';
                p = wcschr (p + 1, L'\\');
            }

            FreePathStringW (tempDest);

        } while (pEnumNextMoveListItem (&listEnum));
    }

    //
    // If we have a collision list, put the pre-moves at the head, and the
    // post-moves at the tail. This leaves the list out of order from the
    // point of view of longest to shortest source, so no additional
    // add/removes should be done.
    //

    if (preMoveList) {
        MYASSERT (postMoveList);

        preMoveList = pRemoveMoveListOverlapWorker (preMoveList, TRUE);

        postMoveList = pRemoveMoveListOverlapWorker (postMoveList, TRUE);

        pChainLists (preMoveList, List);
        pChainLists (List, postMoveList);

        List = preMoveList;
    }

    return List;
}


MOVELISTW
RemoveMoveListOverlapW (
    IN      MOVELISTW List
    )
{
    return (MOVELISTW) pRemoveMoveListOverlapWorker ((PMOVE_LISTW) List, FALSE);
}


BOOL
pOutputMoveListWorker (
    IN      HANDLE File,
    IN      PMOVE_LISTW List,            OPTIONAL
    IN      BOOL AddNestedMoves
    )

/*++

Routine Description:

  OutputMoveList writes every move pair in the specified list to the file
  handle specified. The output is a UNICODE text file.

Arguments:

  File - Specifies the file handle to write to

  List - Specifies the list to output

  AddNestedMoves - Specifies TRUE if the move list should contain extra
                   entries to ensure the move list records all subdirectories,
                   or FALSE if the move list should be the minimum list.

Return Value:

  TRUE if the file was written, FALSE if an error occurred.

--*/

{
    MOVE_LIST_ENUMW e;
    DWORD dontCare;
    HASHTABLE sourceMoveTable = NULL;
    PCWSTR src;
    PCWSTR dest;
    TREE_ENUMW unicodeEnum;
    PMOVE_LIST_NODEW node;

    if (pEnumFirstMoveListItem (&e, List)) {

        if (AddNestedMoves) {
            sourceMoveTable = HtAllocW();
        }

        //
        // Write UNICODE signature
        //
        // Do not write as a string. FE is a lead byte.
        //

        if (!WriteFile (File, "\xff\xfe", 2, &dontCare, NULL)) {
            return FALSE;
        }

        do {
            node = e.Item;

            if (!WriteFile (File, node->FixedSource, ByteCountW (node->FixedSource), &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, node->FixedDestination, ByteCountW (node->FixedDestination), &dontCare, NULL)) {
                return FALSE;
            }

            if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                return FALSE;
            }

            if (sourceMoveTable) {
                HtAddStringW (sourceMoveTable, node->FixedSource);
            }

            if (AddNestedMoves) {
                //
                // We assume by implementation that this is only used on NT.
                // If Win9x support is needed, this code would have to use
                // the ANSI file enumeration APIs.
                //

                MYASSERT (ISNT());

                if (EnumFirstFileInTreeW (&unicodeEnum, node->FixedSource, NULL, FALSE)) {
                    do {
                        src = unicodeEnum.FullPath;

                        if (unicodeEnum.Directory) {

                            //
                            // Skip previously processed trees
                            //

                            if (HtFindStringW (sourceMoveTable, src)) {
                                AbortEnumCurrentDirW (&unicodeEnum);
                                continue;
                            }
                        }

                        //
                        // Move subdirectory and files
                        //

                        dest = JoinPathsW (node->FixedDestination, unicodeEnum.SubPath);

                        if (!WriteFile (File, src, ByteCountW (src), &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, dest, ByteCountW (dest), &dontCare, NULL)) {
                            return FALSE;
                        }

                        if (!WriteFile (File, L"\r\n", 4, &dontCare, NULL)) {
                            return FALSE;
                        }

                        FreePathStringW (dest);

                    } while (EnumNextFileInTreeW (&unicodeEnum));
                }

                //
                // NOTE: We do not record the nested moves in sourceMoveTable,
                //       because it is a waste of time & memory. All nesting
                //       should be taken care of by the sort order of the list.
                //
            }

        } while (pEnumNextMoveListItem (&e));
    }

    HtFree (sourceMoveTable);

    return TRUE;
}


BOOL
OutputMoveListW (
    IN      HANDLE File,
    IN      MOVELISTW List,                 OPTIONAL
    IN      BOOL AddNestedMoves
    )
{
    return pOutputMoveListWorker (File, (PMOVE_LISTW) List, AddNestedMoves);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\ne.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ne.c

Abstract:

    New-Executable parsing routines

Author:

    Jim Schmidt (jimschm)   04-May-1998

Revision History:

    jimschm     23-Sep-1998 Named icon ID bug fix, error path fixes

--*/

#include "pch.h"
#include "migutilp.h"

//
// NE code
//

typedef struct {
    HANDLE File;
    DWORD HeaderOffset;
    NE_INFO_BLOCK Header;
    NE_RESOURCES Resources;
    BOOL ResourcesLoaded;
    POOLHANDLE ResourcePool;
} NE_HANDLE, *PNE_HANDLE;




typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXA)(HMODULE hModule, PCSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESTYPEPROCEXW)(HMODULE hModule, PCWSTR lpType, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXA)(HMODULE hModule, PCSTR lpType,
        PSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);

typedef BOOL (CALLBACK* ENUMRESNAMEPROCEXW)(HMODULE hModule, PCWSTR lpType,
        PWSTR lpName, LONG_PTR lParam, PNE_RES_TYPEINFO TypeInfo, PNE_RES_NAMEINFO NameInfo);


typedef struct {
    PCSTR TypeToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    BOOL Found;
} TYPESEARCHDATAA, *PTYPESEARCHDATAA;

typedef struct {
    PCSTR NameToFind;
    PNE_RES_TYPEINFO OutboundTypeInfo;
    PNE_RES_NAMEINFO OutboundNameInfo;
    BOOL Found;
} NAMESEARCHDATAA, *PNAMESEARCHDATAA;




BOOL
LoadNeHeader (
    IN      HANDLE File,
    OUT     PNE_INFO_BLOCK Header
    )


/*++

Routine Description:

  LoadNeHeader accesses the header at the start of the caller's file. If the
  header looks valid (it has MZ and an EXE signature), then the header is
  returned to the caller. Its contents are not validated.

Arguments:

  File - Specifies the Win32 file handle to read from. This file must have
         been opened with read privilege.

  Header - Receives the header from the caller's file. It is up to the caller
           to use the members of the header in a safe way, since it could be
           spoofed.

Return Value:

  TRUE if a header was read from the file, FALSE otherwise. GetLastError() can
  be used to find out the reason for failure.

--*/


{
    DOS_HEADER dh;
    LONG rc = ERROR_BAD_FORMAT;
    BOOL b = FALSE;

    __try {
        SetFilePointer (File, 0, NULL, FILE_BEGIN);
        if (!ReadBinaryBlock (File, &dh, sizeof (DOS_HEADER))) {
            __leave;
        }

        if (dh.e_magic != ('M' + 'Z' * 256)) {
            __leave;
        }

        SetFilePointer (File, dh.e_lfanew, NULL, FILE_BEGIN);
        if (!ReadBinaryBlock (File, Header, sizeof (NE_INFO_BLOCK))) {
            __leave;
        }

        if (Header->Signature != ('N' + 'E' * 256) &&
            Header->Signature != ('L' + 'E' * 256)
            ) {
            if (Header->Signature == ('P' + 'E' * 256)) {
                rc = ERROR_BAD_EXE_FORMAT;
            } else {
                rc = ERROR_INVALID_EXE_SIGNATURE;
            }

            DEBUGMSG ((DBG_NAUSEA, "Header signature is %c%c", Header->Signature & 0xff, Header->Signature >> 8));
            __leave;
        }

        SetFilePointer (File, (DWORD) dh.e_lfanew, NULL, FILE_BEGIN);

        b = TRUE;
    }
    __finally {
        if (!b) {
            SetLastError (rc);
        }
    }

    return b;
}


DWORD
pComputeSizeOfTypeInfo (
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    return sizeof (NE_RES_TYPEINFO) + TypeInfo->ResourceCount * sizeof (NE_RES_NAMEINFO);
}


PNE_RES_TYPEINFO
pReadNextTypeInfoStruct (
    IN      HANDLE File,
    IN      POOLHANDLE Pool
    )

/*++

Routine Description:

  pReadNextTypeInfoStruct extracts the NE type info structure from the
  specified file. The file pointer must point to the start of the typeinfo
  header.

  CAUTION: This routine currently accepts up to 64K of nameinfo elements in
  the typeinfo struct. NE_RES_NAMEINFO is 12 bytes, so the routine can
  allocate an array of 768K.

Arguments:

  File - Specifies the Win32 file handle with read privilege and a pointer
         that is set to the start of the typeinfo header.

  Pool - Specifies the pool to allocate memory in.

Return Value:

  A pointer to an array (NE_RES_TYPEINFO is the header, and is followed by
  n NE_RES_NAMEINFO elements), or NULL on failure. GetLastError() can be used
  to obtain the error code.

--*/

{
    WORD Type;
    WORD ResCount;
    NE_RES_TYPEINFO TypeInfo;
    PNE_RES_TYPEINFO ReturnInfo = NULL;
    DWORD Size;

    //
    // Read the type info header carefully
    //

    if (!ReadBinaryBlock (File, &Type, sizeof (WORD))) {
        return NULL;
    }

    if (!Type) {
        return NULL;
    }

    if (!ReadBinaryBlock (File, &ResCount, sizeof (WORD))) {
        return NULL;
    }

    TypeInfo.TypeId = Type;
    TypeInfo.ResourceCount = ResCount;

    if (!ReadBinaryBlock (File, &TypeInfo.Reserved, sizeof (DWORD))) {
        return NULL;
    }

    //
    // Read the array of name info structs.
    //
    // BUGBUG: ResCount can be big, like 0xFFFF. What would be a reasonable
    // limit?
    //

    Size = sizeof (NE_RES_NAMEINFO) * ResCount;

    ReturnInfo  = (PNE_RES_TYPEINFO) PoolMemGetMemory (Pool, Size + sizeof (TypeInfo));
    if (!ReturnInfo) {
        return NULL;
    }

    //
    // Transfer type info to the block, then append the array of binary info
    //

    CopyMemory (ReturnInfo, &TypeInfo, sizeof (TypeInfo));

    if (!ReadBinaryBlock (File, (PBYTE) ReturnInfo + sizeof (TypeInfo), Size)) {
        return NULL;
    }

    return ReturnInfo;
}


BOOL
pReadTypeInfoArray (
    IN      HANDLE File,
    IN OUT  PGROWLIST TypeInfoList
    )

/*++

Routine Description:

  pReadTypeInfoArray reads the chain of typeinfo structs from the NE file.

  CAUTION: Each typeinfo struct can be 768K, and this routine accepts any
  number of continuous typeinfo structs.

Arguments:

  File - Specifies the Win32 file handle that was opened with read privilege
         and has its file pointer pointing to the start of the typeinfo
         struct chain.

  TypeInfoList - Specifies an initialized type info list, receivies a list of
                 typeinfo structs.

Return Value:

  TRUE if the typeinfo struct chain is read into memory and organized into
  TypeInfoList, FALSE if a pool cannot be created.

--*/

{
    PNE_RES_TYPEINFO TypeInfo;
    DWORD Size;
    POOLHANDLE TempPool;
    BOOL b = FALSE;

    TempPool = PoolMemInitPool();
    if (!TempPool) {
        return FALSE;
    }

    __try {

        //
        // BUGBUG: An error encountered in pReadNextTypeInfoStruct is
        // discarded and it ends the processing of the type info array. Is
        // this right or wrong? Probably wrong since we return TRUE.
        //

        TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        while (TypeInfo) {
            Size = pComputeSizeOfTypeInfo (TypeInfo);
            if (!GrowListAppend (TypeInfoList, (PBYTE) TypeInfo, Size)) {
                __leave;
            }

            //
            // Discard the pool allocations prior to reading the next typeinfo
            // chain item
            //

            PoolMemEmptyPool (TempPool);

            TypeInfo = pReadNextTypeInfoStruct (File, TempPool);
        }

        b = TRUE;
    }
    __finally {

        PoolMemDestroyPool (TempPool);
    }

    return b;
}


BOOL
pReadStringArrayA (
    IN      HANDLE File,
    IN OUT  PGROWLIST GrowList
    )

/*++

Routine Description:

  pReadStringArrayA fetches an array of strings stored in a file in the format
  of (pseudocode)

    typedef struct {
        BYTE Length;
        CHAR String[];
    } STRING;

    typedef struct {
        STRING StringArray[];
        BYTE Terminator = 0;
    } STRINGARRAY;

  The strings are placed in a list.

  CAUTION: If the file pointer doesn't point to a string array, this routine
  could read in a lot of garbage strings, perhaps exhausing memory.

Arguments:

  File - Specifies a Win32 file handle with read privilege and a file position
         set to the start of the string array.

  GrowList - Specifies an initialized list of strings. Receivies additional
             strings appended to the end of the list.

Return Value:

  TRUE on successful read of the strings, FALSE otherwise. GetLastError()
  provides the failure code.

--*/

{
    BYTE Size;
    CHAR Name[256];

    if (!ReadBinaryBlock (File, &Size, sizeof (BYTE))) {
        return FALSE;
    }

    while (Size) {

        if (!ReadBinaryBlock (File, Name, (DWORD) Size)) {
            return FALSE;
        }

        Name[Size] = 0;

        GrowListAppendString (GrowList, Name);

        if (!ReadBinaryBlock (File, &Size, sizeof (BYTE))) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
LoadNeResources (
    IN      HANDLE File,
    OUT     PNE_RESOURCES Resources
    )

/*++

Routine Description:

  LoadNeResources parses an NE file and loads in the header, the typeinfo
  struct and all of the resource names.

Arguments:

  File - Specifies a Win32 file handle with read privilege

  Resources - Receives the resources stored in the NE file

Return Value:

  TRUE on success, FALSE otherwise. GetLastError() provides the failure code.

  File's position pointer is left in a random position.

--*/

{
    NE_INFO_BLOCK Header;

    ZeroMemory (Resources, sizeof (NE_RESOURCES));

    if (!LoadNeHeader (File, &Header)) {
        return FALSE;
    }

    //
    // Read in NE_RESOURCES struct
    //

    SetFilePointer (File, (DWORD) Header.OffsetToResourceTable, NULL, FILE_CURRENT);

    if (!ReadBinaryBlock (File, &Resources->AlignShift, sizeof (WORD))) {
        return FALSE;
    }

    // Array of NE_RES_TYPEINFO structs
    if (!pReadTypeInfoArray (File, &Resources->TypeInfoArray)) {
        FreeNeResources (Resources);
        return FALSE;
    }

    // Resource names
    if (!pReadStringArrayA (File, &Resources->ResourceNames)) {
        FreeNeResources (Resources);
        return FALSE;
    }

    return TRUE;
}


VOID
FreeNeResources (
    IN OUT  PNE_RESOURCES Resources
    )

/*++

Routine Description:

  FreeNeResources cleans up the memory allocated from a NE_RESOURCES struct.

Arguments:

  Resources - Specifies the struct to clean up, recieives zeroed members

Return Value:

  None.

--*/

{
    FreeGrowList (&Resources->TypeInfoArray);
    FreeGrowList (&Resources->ResourceNames);

    ZeroMemory (Resources, sizeof (NE_RESOURCES));
}


HANDLE
OpenNeFileA (
    PCSTR FileName
    )

/*++

Routine Description:

  OpenNeFileA opens the specified file for read and checks to see if it has
  the magic numbers (MZ and NE). If it does, then the file handle is returned
  and the file is assumed to be an exe.

Arguments:

  FileName - Specifies the file to open

Return Value:

  A handle to the NE file, or NULL if the file can't be opened or is not an NE
  file. GetLastError() returns the failure code.

--*/

{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));
    NeHandle->File = INVALID_HANDLE_VALUE;

    __try {

        NeHandle->ResourcePool = PoolMemInitPool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileA (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!LoadNeHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PoolMemDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    return (HANDLE) NeHandle;
}


HANDLE
OpenNeFileW (
    PCWSTR FileName
    )

/*++

Routine Description:

  OpenNeFileW opens the specified file for read and checks to see if it has
  the magic numbers (MZ and NE). If it does, then the file handle is returned
  and the file is assumed to be an exe.

Arguments:

  FileName - Specifies the file to open

Return Value:

  An NE_HANDLE pointer to the NE file (casted as a HANDLE), or NULL if the
  file can't be opened or is not an NE file. GetLastError() returns the
  failure code.

--*/

{
    PNE_HANDLE NeHandle;
    BOOL b = FALSE;

    NeHandle = (PNE_HANDLE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (NE_HANDLE));
    NeHandle->File = INVALID_HANDLE_VALUE;

    __try {

        NeHandle->ResourcePool = PoolMemInitPool();
        if (!NeHandle->ResourcePool) {
            __leave;
        }

        NeHandle->File = CreateFileW (
                            FileName,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if (NeHandle->File == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!LoadNeHeader (NeHandle->File, &NeHandle->Header)) {
            __leave;
        }

        NeHandle->HeaderOffset = SetFilePointer (NeHandle->File, 0, NULL, FILE_CURRENT);

        b = TRUE;
    }
    __finally {
        if (!b) {
            PushError();

            if (NeHandle->ResourcePool) {
                PoolMemDestroyPool (NeHandle->ResourcePool);
            }

            if (NeHandle->File != INVALID_HANDLE_VALUE) {
                CloseHandle (NeHandle->File);
            }

            MemFree (g_hHeap, 0, NeHandle);
            NeHandle = NULL;

            PopError();
        }
    }

    // BUGBUG -- this is confusing, shouldn't cast to HANDLE
    return (HANDLE) NeHandle;
}


VOID
CloseNeFile (
    HANDLE Handle       OPTIONAL
    )

/*++

Routine Description:

  CloseNeFile closes a file handle opened with OpenNeFileA or OpenNeFileW.

Arguments:

  Handle - Specifies a pointer to an NE_HANDLE struct

Return Value:

  None.

--*/

{
    PNE_HANDLE NeHandle;

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle) {
        return;
    }

    if (NeHandle->File != INVALID_HANDLE_VALUE) {
        CloseHandle (NeHandle->File);
    }

    if (NeHandle->ResourcesLoaded) {
        FreeNeResources (&NeHandle->Resources);
    }

    PoolMemDestroyPool (NeHandle->ResourcePool);

    MemFree (g_hHeap, 0, NeHandle);
}


PCSTR
pConvertUnicodeResourceId (
    IN      PCWSTR ResId
    )
{
    if (HIWORD (ResId)) {
        return ConvertWtoA (ResId);
    }

    return (PCSTR) ResId;
}


PCSTR
pDecodeIdReferenceInString (
    IN      PCSTR ResName
    )
{
    if (HIWORD (ResName) && ResName[0] == '#') {
        return (PCSTR) (UINT_PTR) atoi (&ResName[1]);
    }

    return ResName;
}



BOOL
pLoadNeResourcesFromHandle (
    IN      PNE_HANDLE NeHandle
    )
{
    if (NeHandle->ResourcesLoaded) {
        return TRUE;
    }

    if (!LoadNeResources (NeHandle->File, &NeHandle->Resources)) {
        return FALSE;
    }

    NeHandle->ResourcesLoaded = TRUE;
    return TRUE;
}


BOOL
pLoadNeResourceName (
    OUT     PSTR ResName,           // 256-char buffer
    IN      HANDLE File,
    IN      DWORD StringOffset
    )
{
    BYTE ResNameSize;

    SetFilePointer (File, StringOffset, NULL, FILE_BEGIN);
    if (!ReadBinaryBlock (File, &ResNameSize, 1)) {
        return FALSE;
    }

    ResName[ResNameSize] = 0;

    return ReadBinaryBlock (File, ResName, ResNameSize);
}


BOOL
pEnumNeResourceTypesEx (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )

/*++

Routine Description:

  pEnumNeResourceTypesEx enumerates all of the resource types stored in the
  specified NE file object. This function is the worker that examines the NE
  file structure and dispatches the resource name to a callback function.

Arguments:

  Handle - Specifies a pointer to a NE_HANDLE struct (as returned by
           OpenNeFile)

  EnumProc - Specifies a callback function address. This argument is
             overloaded with 4 possibilities -- either ANSI or UNICODE, and
             either normal or extended function params.

  lParam - Specifies extra data to pass to the callback function

  ExFunctionality - Specifies TRUE if EnumProc points to an extended function
                    address, or FALSE if EnumProc points to a normal function
                    address

  UnicodeProc - Specifies TRUE if EnumProc points to a UNICODE callback, or
                FALSE if EnumProc points to an ANSI callback.

Return Value:

  TRUE if the NE was enumerated properly, FALSE on error. Call GetLastError()
  for the failure code.

--*/

{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    INT Count;
    INT i;
    DWORD StringOffset;
    CHAR ResName[256];      // >= 256 is required
    ENUMRESTYPEPROCA EnumFunc2 = (ENUMRESTYPEPROCA) EnumFunc;
    ENUMRESTYPEPROCEXW EnumFuncW = (ENUMRESTYPEPROCEXW) EnumFunc;
    ENUMRESTYPEPROCW EnumFunc2W = (ENUMRESTYPEPROCW) EnumFunc;
    PWSTR UnicodeResName = NULL;
    BOOL result = TRUE;

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Enumerate all resource types
    //

    Count = GrowListGetSize (&NeHandle->Resources.TypeInfoArray);
    for (i = 0 ; i < Count ; i++) {
        TypeInfo = (PNE_RES_TYPEINFO) GrowListGetItem (&NeHandle->Resources.TypeInfoArray, i);

        if (TypeInfo->TypeId & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, (PWSTR) (UINT_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, (PSTR) (UINT_PTR) (TypeInfo->TypeId & 0x7fff), lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, (PWSTR) (UINT_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, (PSTR) (UINT_PTR) (TypeInfo->TypeId & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + TypeInfo->TypeId;

            MYASSERT (ARRAYSIZE(ResName) >= 256);

            if (!pLoadNeResourceName (ResName, NeHandle->File, StringOffset)) {
                result = FALSE;
                break;
            }

            if (UnicodeProc) {
                UnicodeResName = (PWSTR) ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeResName, lParam, TypeInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, ResName, lParam, TypeInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, ResName, lParam)) {
                        break;
                    }
                }
            }
        }
    }

    return result;
}


BOOL
EnumNeResourceTypesA (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pEnumNeResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                FALSE           // ANSI enum proc
                );
}


BOOL
EnumNeResourceTypesW (
    IN      HANDLE Handle,
    IN      ENUMRESTYPEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pEnumNeResourceTypesEx (
                Handle,
                (ENUMRESTYPEPROCEXA) EnumFunc,
                lParam,
                FALSE,          // no ex functionality
                TRUE            // UNICODE enum proc
                );
}


BOOL
pEnumTypeForNameSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      LONG_PTR lParam,
    IN      PNE_RES_TYPEINFO TypeInfo
    )
{
    PTYPESEARCHDATAA Data;

    Data = (PTYPESEARCHDATAA) lParam;

    //
    // Compare type
    //

    if (HIWORD (Data->TypeToFind) == 0) {
        if (Type != Data->TypeToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Type) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Type, Data->TypeToFind)) {
            return TRUE;
        }
    }

    //
    // Type found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->Found = TRUE;

    return FALSE;
}



BOOL
pEnumNeResourceNamesEx (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCEXA EnumFunc,
    IN      LONG_PTR lParam,
    IN      BOOL ExFunctionality,
    IN      BOOL UnicodeProc
    )

/*++

Routine Description:

  pEnumNeResourceNamesEx enumerates all of the resource names of a specified
  type that are stored in the specified NE file object. This function is the
  worker that examines the NE file structure and dispatches the resource name
  to a callback function.

Arguments:

  Handle - Specifies a pointer to a NE_HANDLE struct (as returned by
           OpenNeFile)

  Type - Specifies a type, which is either an ID (cast as a WORD) or a string.

  EnumFunc - Specifies a callback function address. This argument is
             overloaded with 4 possibilities -- either ANSI or UNICODE, and
             either normal or extended function params.

  lParam - Specifies extra data to pass to the callback function

  ExFunctionality - Specifies TRUE if EnumProc points to an extended function
                    address, or FALSE if EnumProc points to a normal function
                    address

  UnicodeProc - Specifies TRUE if EnumProc points to a UNICODE callback, or
                FALSE if EnumProc points to an ANSI callback.

Return Value:

  TRUE if the NE was enumerated properly, FALSE on error. Call GetLastError()
  for the failure code.

--*/

{
    PNE_HANDLE NeHandle;
    PNE_RES_TYPEINFO TypeInfo;
    PNE_RES_NAMEINFO NameInfo;
    TYPESEARCHDATAA Data;
    WORD w;
    DWORD StringOffset;
    CHAR ResName[256];          // must be >= 256
    ENUMRESNAMEPROCA EnumFunc2 = (ENUMRESNAMEPROCA) EnumFunc;
    ENUMRESNAMEPROCEXW EnumFuncW = (ENUMRESNAMEPROCEXW) EnumFunc;
    ENUMRESNAMEPROCW EnumFunc2W = (ENUMRESNAMEPROCW) EnumFunc;
    PCWSTR UnicodeType = NULL;
    PCWSTR UnicodeResName = NULL;
    BOOL result = TRUE;

    Type = pDecodeIdReferenceInString (Type);

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !EnumFunc) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return FALSE;
    }

    //
    // Locate type
    //

    ZeroMemory (&Data, sizeof (Data));

    Data.TypeToFind = Type;

    if (!pEnumNeResourceTypesEx (
            Handle,
            pEnumTypeForNameSearchProcA,
            (LONG_PTR) &Data,
            TRUE,           // ex functionality
            FALSE           // ANSI enum proc
            )) {
        return FALSE;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_TYPE_NOT_FOUND);
        return FALSE;
    }

    TypeInfo = Data.OutboundTypeInfo;

    if (UnicodeProc) {
        if (HIWORD (Type)) {
            UnicodeType = ConvertAtoW (Type);
        } else {
            UnicodeType = (PCWSTR) Type;
        }
    }

    //
    // Enumerate the resource names
    //

    NameInfo = TypeInfo->NameInfo;

    for (w = 0 ; w < TypeInfo->ResourceCount ; w++) {

        if (NameInfo->Id & 0x8000) {
            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) (UINT_PTR) (NameInfo->Id & 0x7fff), lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, (PSTR) (UINT_PTR) (NameInfo->Id & 0x7fff), lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) (UINT_PTR) (NameInfo->Id & 0x7fff), lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, (PSTR) (UINT_PTR) (NameInfo->Id & 0x7fff), lParam)) {
                        break;
                    }
                }
            }
        } else {
            //
            // TypeInfo->TypeId gives an offset to the resource string name,
            // relative to the start of the resource table
            //

            StringOffset = NeHandle->HeaderOffset + NeHandle->Header.OffsetToResourceTable + NameInfo->Id;

            MYASSERT (ARRAYSIZE(ResName) >= 256);
            if (!pLoadNeResourceName (ResName, NeHandle->File, StringOffset)) {
                result = FALSE;
                break;
            }

            if (UnicodeProc) {
                UnicodeResName = ConvertAtoW (ResName);
            }

            if (ExFunctionality) {
                if (UnicodeProc) {
                    if (!EnumFuncW (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                } else {
                    if (!EnumFunc (Handle, Type, ResName, lParam, TypeInfo, NameInfo)) {
                        break;
                    }
                }
            } else {
                if (UnicodeProc) {
                    if (!EnumFunc2W (Handle, UnicodeType, (PWSTR) UnicodeResName, lParam)) {
                        break;
                    }
                } else {
                    if (!EnumFunc2 (Handle, Type, ResName, lParam)) {
                        break;
                    }
                }
            }

            if (UnicodeProc) {
                FreeConvertedStr (UnicodeResName);
            }
        }

        NameInfo++;
    }

    if (UnicodeProc) {
       DestroyUnicodeResourceId (UnicodeType);
    }

    return result;
}


BOOL
EnumNeResourceNamesA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      ENUMRESNAMEPROCA EnumFunc,
    IN      LONG_PTR lParam
    )
{
    return pEnumNeResourceNamesEx (
                Handle,
                Type,
                (ENUMRESNAMEPROCEXA) EnumFunc,
                lParam,
                FALSE,      // no ex functionality
                FALSE       // ANSI enum proc
                );
}


BOOL
EnumNeResourceNamesW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      ENUMRESNAMEPROCW EnumFunc,
    IN      LONG_PTR lParam
    )
{
    BOOL b;
    PCSTR AnsiType;

    AnsiType = pConvertUnicodeResourceId (Type);

    b = pEnumNeResourceNamesEx (
            Handle,
            AnsiType,
            (ENUMRESNAMEPROCEXA) EnumFunc,
            lParam,
            FALSE,          // no ex functionality
            TRUE            // UNICODE enum proc
            );

    PushError();
    DestroyAnsiResourceId (AnsiType);
    PopError();

    return b;
}


BOOL
pEnumTypeForResSearchProcA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name,
    IN      LPARAM lParam,
    IN      PNE_RES_TYPEINFO TypeInfo,
    IN      PNE_RES_NAMEINFO NameInfo
    )
{
    PNAMESEARCHDATAA Data;

    Data = (PNAMESEARCHDATAA) lParam;

    //
    // Compare name
    //

    if (HIWORD (Data->NameToFind) == 0) {
        if (Name != Data->NameToFind) {
            return TRUE;
        }
    } else {
        if (HIWORD (Name) == 0) {
            return TRUE;
        }

        if (!StringIMatchA (Name, Data->NameToFind)) {
            return TRUE;
        }
    }

    //
    // Name found
    //

    Data->OutboundTypeInfo = TypeInfo;
    Data->OutboundNameInfo = NameInfo;
    Data->Found = TRUE;

    return FALSE;
}


PBYTE
FindNeResourceExA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )

/*++

Routine Description:

  FindNeResourceExA locates a specific resource in a NE file. It returns a
  pointer to the resource.

Arguments:

  Handle - Specifies a pointer to a NE_HANDLE struct, as returned from
           OpenNeFile

  Type - Specifies the type of resource, either a WORD id or a string

  Name - Specifies the name of the resource, either a WORD id or a string

Return Value:

  On success, the return value is a pointer to a copy of the resource (in
  memory). The copy is pool-allocated and is cleaned up when Handle is closed
  with CloseNeFile.

  On failure, the return value is NULL, and GetLastError() holds the failure
  code.

--*/

{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;
    DWORD Offset;
    DWORD Length;
    PNE_RES_NAMEINFO NameInfo;
    PBYTE ReturnData;

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        return NULL;
    }

    //
    // Find resource
    //

    Data.NameToFind = Name;

    if (!pEnumNeResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        return NULL;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return NULL;
    }

    NameInfo = Data.OutboundNameInfo;

    Offset = (DWORD) NameInfo->Offset << (DWORD) NeHandle->Resources.AlignShift;
    Length = (DWORD) NameInfo->Length << (DWORD) NeHandle->Resources.AlignShift;

    ReturnData = PoolMemGetMemory (NeHandle->ResourcePool, Length);
    if (!ReturnData) {
        return NULL;
    }

    SetFilePointer (NeHandle->File, Offset, NULL, FILE_BEGIN);

    if (!ReadBinaryBlock (NeHandle->File, ReturnData, Length)) {
        return NULL;
    }

    return ReturnData;
}


PBYTE
FindNeResourceExW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )
{
    PCSTR AnsiType;
    PCSTR AnsiName;
    PBYTE Resource;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Resource = FindNeResourceExA (
                    Handle,
                    AnsiType,
                    AnsiName
                    );

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Resource;
}



DWORD
SizeofNeResourceA (
    IN      HANDLE Handle,
    IN      PCSTR Type,
    IN      PCSTR Name
    )

/*++

Routine Description:

  SizeofNeResourceA computes the size, in bytes, of a specific resource.

Arguments:

  Handle - Specifies a pointer to a NE_HANDLE struct, as returned from
           OpenNeFile

  Type - Specifies the type of resource, either a WORD id or a string

  Name - Specifies the name of the resource, either a WORD id or a string

Return Value:

  The size, in bytes, of the specified resource. If the return value is zero,
  and GetLastError() == ERROR_SUCCESS, then the resource exists but is zero
  bytes. If the return value is zero and GetLastError() != ERROR_SUCCESS, then
  there was an error processing the resource.

--*/

{
    PNE_HANDLE NeHandle;
    NAMESEARCHDATAA Data;

    SetLastError (ERROR_SUCCESS);

    Type = pDecodeIdReferenceInString (Type);
    Name = pDecodeIdReferenceInString (Name);

    ZeroMemory (&Data, sizeof (Data));

    //
    // Make sure resources are loaded
    //

    NeHandle = (PNE_HANDLE) Handle;
    if (!NeHandle || !Type || !Name) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pLoadNeResourcesFromHandle (NeHandle)) {
        MYASSERT (GetLastError() != ERROR_SUCCESS);
        return 0;
    }

    //
    // Find resource
    //

    if (!pEnumNeResourceNamesEx (
            Handle,
            Type,
            pEnumTypeForResSearchProcA,
            (LONG_PTR) &Data,
            TRUE,
            FALSE
            )) {
        MYASSERT (GetLastError() != ERROR_SUCCESS);
        return 0;
    }

    if (!Data.Found) {
        SetLastError (ERROR_RESOURCE_NAME_NOT_FOUND);
        return 0;
    }

    return Data.OutboundNameInfo->Length;
}


DWORD
SizeofNeResourceW (
    IN      HANDLE Handle,
    IN      PCWSTR Type,
    IN      PCWSTR Name
    )

/*++

Routine Description:

  SizeofNeResourceW computes the size, in bytes, of a specific resource.

Arguments:

  Handle - Specifies a pointer to a NE_HANDLE struct, as returned from
           OpenNeFile

  Type - Specifies the type of resource, either a WORD id or a string

  Name - Specifies the name of the resource, either a WORD id or a string

Return Value:

  The size, in bytes, of the specified resource. If the return value is zero,
  and GetLastError() == ERROR_SUCCESS, then the resource exists but is zero
  bytes. If the return value is zero and GetLastError() != ERROR_SUCCESS, then
  there was an error processing the resource.

--*/

{
    PCSTR AnsiType;
    PCSTR AnsiName;
    DWORD Size;

    AnsiType = pConvertUnicodeResourceId (Type);
    AnsiName = pConvertUnicodeResourceId (Name);

    Size = SizeofNeResourceA (Handle, AnsiType, AnsiName);

    PushError();

    DestroyAnsiResourceId (AnsiType);
    DestroyAnsiResourceId (AnsiName);

    PopError();

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\persist.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    persist.c

Abstract:

    General structure persistence functions.

Author:

    Aghajanyan Souren 27-Mar-2001

Revision History:

--*/

#include "pch.h"
#include "migutilp.h"

#include "persist.h"

BOOL
MayExtraMemRequire (
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    FIELD_DESCRIPTION * FieldPtr;

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(!FieldPtr->FieldDescription && FieldPtr->ArraySizeFieldOffset && FieldPtr->byValue){
            return TRUE;
        }
    }

    return FALSE;
}

SIZE_T
GetExtraMemRequirements(
    IN      BYTE * StructurePtr,
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
/*
    This function provide additional memory requirements,
    only in case when structure has variable size.
    And have to be declared by PERSIST_FIELD_BY_VALUE_NESTED_TYPE_CYCLE
    For example:
    struct VariableSizeStruct{
        ......
        UINT    uiNumberOfItem;
        ITEM    items[1];
    };
    PERSIST_FIELD_BY_VALUE_NESTED_TYPE_CYCLE(VariableSizeStruct, ITEM, items, uiNumberOfItem)
*/
{
    UINT Len;
    FIELD_DESCRIPTION * FieldPtr;
    SIZE_T ExtraBytes = 0;
    UINT uiItemCount;

    MYASSERT(StructurePtr);

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(!FieldPtr->FieldDescription &&
           FieldPtr->ArraySizeFieldOffset &&
           FieldPtr->byValue &&
           FieldPtr->Size){
            uiItemCount = *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset));
            ExtraBytes += uiItemCount? FieldPtr->Size * (uiItemCount - FieldPtr->InitialNumberOfItem): 0;
        }
    }

    return ExtraBytes;
}

BOOL
SerializeStore(
    IN OUT  BYTE * BufferMain,
    IN      BYTE * StructurePtr,
    IN      PFIELD_DESCRIPTION FieldsDescription,
    IN OUT  SIZE_T * uiHowUsed
    )
{
    UINT i;
    UINT iLen;
    SIZE_T Size = 0;
    BYTE * SubStruct;
    FIELD_DESCRIPTION * FieldPtr;

    if(!uiHowUsed){
        uiHowUsed = &Size;
    }

    MYASSERT(StructurePtr);

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription)
        {
            iLen = FieldPtr->ArraySizeFieldOffset?
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)):
                    1;

            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                MYASSERT(SubStruct);
            }
            else{
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                if(BufferMain){
                    *(BufferMain + *uiHowUsed) = (SubStruct && iLen);
                }
                ++*uiHowUsed;
                if(!SubStruct || !iLen){
                    continue;
                }
            }

            for(i = 0; i < iLen;
                i++, SubStruct += FieldPtr->Size + GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription))
            {
                if(!SerializeStore(BufferMain,
                                   SubStruct,
                                   FieldPtr->FieldDescription,
                                   uiHowUsed)){
                    MYASSERT(FALSE);
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr)
            {
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
                if(!SubStruct){
                    SubStruct = (BYTE*)(FieldPtr->IsString == AnsiStr? "": (char*)L"");
                }

                if(FieldPtr->IsString == AnsiStr){
                    iLen = (strlen((PCSTR)SubStruct) + 1) * sizeof(CHAR);
                }
                else{
                    iLen = (wcslen((PWSTR)SubStruct) + 1) * sizeof(WCHAR);
                }

                if(BufferMain){
                    memcpy((BYTE *)(BufferMain + *uiHowUsed), SubStruct, iLen);
                }

                *uiHowUsed += iLen;
            }
            else
            {
                if(FieldPtr->Size)
                {
                    iLen = FieldPtr->ArraySizeFieldOffset?
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)):
                            1;
                    if(BufferMain){
                        memcpy((char *)(BufferMain + *uiHowUsed),
                               GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset),
                               iLen * FieldPtr->Size);
                    }
                    *uiHowUsed += iLen * FieldPtr->Size;
                }
            }
        }
    }

    return TRUE;
}

UINT
CalcSignature(
    IN      BYTE * BufferPtr,
    IN      SIZE_T Length
    )
{
    UINT i;
    SIZE_T iLen = Length >> 2;
    SIZE_T iRest = Length & 3;
    UINT uiSignature = 0;

    for(i = 0; i < iLen; i++){
        uiSignature ^= ((PUINT)BufferPtr)[i];
    }

    if(iRest){
        uiSignature ^= (((PUINT)BufferPtr)[iLen]) & (0xffffffff >> ((sizeof(UINT) - iRest) << 3));
    }

    return uiSignature;
}

PERSISTRESULTSENUM
PersistStore(
    OUT     BYTE ** BufferPtr,
    OUT     SIZE_T *Size,
    IN      BYTE * StructurePtr,
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    )
{
    BYTE * buffer = NULL;
    BYTE * memBlock = NULL;
    SIZE_T uiBufferSize = 0;
    PPERSIST_HEADER pPersistHeader;
    PFIELD_DESCRIPTION FieldsDescription;
    PERSISTRESULTSENUM result = Persist_Success;

    if(!BufferPtr || !Size || !StructurePtr || !StructDefinitionPtr){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }

    FieldsDescription = StructDefinitionPtr->FieldDescriptions;
    if(!FieldsDescription){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }

    __try{
        uiBufferSize = sizeof(PERSIST_HEADER);
        if(!SerializeStore(NULL, StructurePtr, FieldsDescription, &uiBufferSize)){
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }

        memBlock = (BYTE *)MemAllocUninit(uiBufferSize);

        if(!memBlock){
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            MYASSERT(FALSE);
            return Persist_Fail;
        }

        buffer = memBlock;
        *BufferPtr = memBlock;
        *Size = uiBufferSize;

        pPersistHeader = (PPERSIST_HEADER)memBlock;
        buffer += sizeof(PERSIST_HEADER);

        pPersistHeader->dwVersion = StructDefinitionPtr->dwVersion;
        pPersistHeader->dwReserved = 0;

        uiBufferSize = 0;
        if(!SerializeStore(buffer, StructurePtr, FieldsDescription, &uiBufferSize)){
            FreeMem(memBlock);
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }

        pPersistHeader->dwSignature = CalcSignature(buffer, uiBufferSize);

        SetLastError(ERROR_SUCCESS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        if(memBlock){
            FreeMem(memBlock);
        }
        result = Persist_Fail;
        SetLastError(ERROR_ACCESS_DENIED);
    }


    return result;
}

BOOL
SerializeLoad(
    IN      BYTE * BufferMain,
    IN OUT  BYTE * StructurePtr,
    IN      PFIELD_DESCRIPTION FieldsDescription,
    IN OUT  SIZE_T * uiHowUsed,
    IN      BOOL   bRestoreOnlyByValue
    )
{
    FIELD_DESCRIPTION * FieldPtr;
    UINT i;
    UINT iLen;
    SIZE_T Size = 0;
    BYTE * SubStruct;
    BYTE * OriginalBuffer;
    SIZE_T sizeValue;
    SIZE_T uiPrevValue;

    if(!uiHowUsed){
        uiHowUsed = &Size;
    }

    MYASSERT(StructurePtr);

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription)
        {
            iLen = FieldPtr->ArraySizeFieldOffset?
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)):
                    1;

            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }
            else{
                if(bRestoreOnlyByValue){
                    continue;
                }

                if(!*(BufferMain + (*uiHowUsed)++)){
                    *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT_PTR *, StructurePtr, FieldPtr->Offset) =
                            (UINT_PTR)NULL;
                    continue;
                }

                MYASSERT(FieldPtr->Size && iLen);

                sizeValue = FieldPtr->Size * iLen;

                SubStruct = (BYTE *)MemAllocUninit(sizeValue);
                if(!SubStruct){
                    return FALSE;
                }

                if(MayExtraMemRequire(FieldPtr->FieldDescription)){
                    OriginalBuffer = SubStruct;
                    uiPrevValue = *uiHowUsed;
                    for(i = 0; i < iLen; i++, SubStruct += FieldPtr->Size)
                    {
                        if(!SerializeLoad(BufferMain,
                                          SubStruct,
                                          FieldPtr->FieldDescription,
                                          &uiPrevValue,
                                          TRUE)){
                            return FALSE;
                        }
                        sizeValue += GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription);
                    }
                    FreeMem(OriginalBuffer);

                    SubStruct = (BYTE *)MemAllocZeroed(sizeValue);
                    if(!SubStruct){
                        return FALSE;
                    }
                }

                *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT_PTR *, StructurePtr, FieldPtr->Offset) =
                        (UINT_PTR)SubStruct;
            }

            for(i = 0; i < iLen;
                i++, SubStruct += FieldPtr->Size + GetExtraMemRequirements(SubStruct, FieldPtr->FieldDescription))
            {
                if(!SerializeLoad(BufferMain,
                                  SubStruct,
                                  FieldPtr->FieldDescription,
                                  uiHowUsed,
                                  FALSE)){
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr){
                if(bRestoreOnlyByValue){
                    continue;
                }

                if(FieldPtr->IsString == AnsiStr){
                    iLen = strlen((char *)(BufferMain + *uiHowUsed)) + sizeof(CHAR);
                }
                else{
                    iLen = (wcslen((WCHAR *)(BufferMain + *uiHowUsed)) + 1) * sizeof(WCHAR);
                }
                MYASSERT(iLen);

                if(iLen != (FieldPtr->IsString == AnsiStr? sizeof(CHAR): sizeof(WCHAR)))
                {
                    SubStruct = (BYTE *)MemAllocUninit(iLen);
                    if(!SubStruct){
                        return FALSE;
                    }
                    memcpy((BYTE *)SubStruct, (BYTE *)(BufferMain + *uiHowUsed), iLen);
                }
                else{
                    SubStruct = NULL;
                }

                *GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT_PTR *, StructurePtr, FieldPtr->Offset) = (UINT_PTR)SubStruct;

                *uiHowUsed += iLen;
            }
            else
            {
                if(FieldPtr->Size)
                {
                    iLen = FieldPtr->ArraySizeFieldOffset?
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)):
                            1;
                    sizeValue = iLen * FieldPtr->Size;
                    if(iLen > 1 && bRestoreOnlyByValue){
                        continue;
                    }

                    memcpy(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset),
                           (char *)(BufferMain + *uiHowUsed),
                           sizeValue);
                    *uiHowUsed += sizeValue;
                }
            }
        }
    }

    return TRUE;
}

PERSISTRESULTSENUM
PersistLoad(
    IN      BYTE * BufferPtr,
    IN      SIZE_T Size,
    OUT     BYTE * StructurePtr,
    IN      PSTRUCT_DEFINITION StructDefinitionPtr
    )
{
    SIZE_T uiBufferSize = 0;
    PPERSIST_HEADER pPersistHeader;
    PFIELD_DESCRIPTION FieldsDescription;
    PERSISTRESULTSENUM result = Persist_Success;

    if(!BufferPtr || !Size || !StructurePtr || !StructDefinitionPtr){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }

    FieldsDescription = StructDefinitionPtr->FieldDescriptions;
    if(!FieldsDescription){
        SetLastError(ERROR_INVALID_PARAMETER);
        MYASSERT(FALSE);
        return Persist_BadParameters;
    }

    __try{
        pPersistHeader = (PPERSIST_HEADER)BufferPtr;

        if(pPersistHeader->dwVersion != StructDefinitionPtr->dwVersion){
            SetLastError(ERROR_ACCESS_DENIED);
            MYASSERT(FALSE);
            return Persist_WrongVersion;
        }

        BufferPtr += sizeof(PERSIST_HEADER);
        Size -= sizeof(PERSIST_HEADER);
        if(pPersistHeader->dwSignature != CalcSignature(BufferPtr, Size)){
            SetLastError(ERROR_CRC);
            return Persist_WrongSignature;
        }

        uiBufferSize = 0;
        //Top structure cannot be variable size
        if(!SerializeLoad(BufferPtr, StructurePtr, FieldsDescription, &uiBufferSize, FALSE)){
            SetLastError(ERROR_ACCESS_DENIED);
            return Persist_Fail;
        }

        SetLastError(ERROR_SUCCESS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER){
        result = Persist_Fail;
        SetLastError(ERROR_ACCESS_DENIED);
    }

    return result;
}

VOID
PersistReleaseMemory(
    IN      BYTE * StructurePtr,
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    UINT i;
    UINT iLen;
    FIELD_DESCRIPTION * FieldPtr;
    BYTE * SubStruct;

    if(!StructurePtr || !FieldsDescription){
        return;
    }

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription){
            iLen = FieldPtr->ArraySizeFieldOffset?
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, StructurePtr, FieldPtr->ArraySizeFieldOffset)):
                    1;

            if(!iLen){
                continue;
            }

            if(FieldPtr->byValue){
                SubStruct = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }
            else{
                SubStruct = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset);
            }

            if(!SubStruct){
                continue;
            }

            for(i = 0; i < iLen; i++, SubStruct += FieldPtr->Size){
                PersistReleaseMemory(SubStruct, FieldPtr->FieldDescription);
            }

            if(!FieldPtr->byValue){
                FreeMem(GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, StructurePtr, FieldPtr->Offset));
            }
        }
        else{
            if(FieldPtr->IsString != NoStr){
                SubStruct = (BYTE *)GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(PCSTR, StructurePtr, FieldPtr->Offset);
                if(SubStruct){
                    FreeMem(SubStruct);
                }
            }
        }
    }
}

BOOL
CompareStructures(
    IN      BYTE * pStructure1,
    IN      BYTE * pStructure2,
    IN      PFIELD_DESCRIPTION FieldsDescription
    )
{
    UINT i;
    UINT iLen1;
    UINT iLen2;
    FIELD_DESCRIPTION * FieldPtr;
    BYTE * pSubStruct1;
    BYTE * pSubStruct2;

    if(!pStructure1 || !pStructure2 || !FieldsDescription){
        return FALSE;
    }

    for(FieldPtr = FieldsDescription; FieldPtr->Offset != END_OF_STRUCT; FieldPtr++){
        if(FieldPtr->FieldDescription){
            iLen1 = FieldPtr->ArraySizeFieldOffset?
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure1, FieldPtr->ArraySizeFieldOffset)):
                    1;

            iLen2 = FieldPtr->ArraySizeFieldOffset?
                    *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure2, FieldPtr->ArraySizeFieldOffset)):
                    1;

            if(iLen1 != iLen2){
                MYASSERT(FALSE);
                return FALSE;
            }

            if(!iLen1){
                continue;
            }

            if(FieldPtr->byValue){
                pSubStruct1 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
            }
            else{
                pSubStruct1 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
            }

            if(!pSubStruct1 || !pSubStruct2){
                if(pSubStruct1 != pSubStruct2){
                    MYASSERT(FALSE);
                    return FALSE;
                }
                continue;
            }

            for(i = 0; i < iLen1;
                i++,
                pSubStruct1 += FieldPtr->Size + GetExtraMemRequirements(pSubStruct1, FieldPtr->FieldDescription),
                pSubStruct2 += FieldPtr->Size + GetExtraMemRequirements(pSubStruct2, FieldPtr->FieldDescription)){
                if(!CompareStructures(pSubStruct1, pSubStruct2, FieldPtr->FieldDescription)){
                    return FALSE;
                }
            }
        }
        else{
            if(FieldPtr->IsString != NoStr)
            {
                pSubStruct1 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYREF_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
                if(!pSubStruct1 || !pSubStruct2){
                    if(pSubStruct1 != pSubStruct2){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                    continue;
                }

                if(FieldPtr->IsString == AnsiStr){
                    if(strcmp((LPCSTR)pSubStruct1, (LPCSTR)pSubStruct1)){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                }
                else{
                    if(wcscmp((LPCWSTR)pSubStruct1, (LPCWSTR)pSubStruct1)){
                        MYASSERT(FALSE);
                        return FALSE;
                    }
                }
            }
            else{
                iLen1 = FieldPtr->ArraySizeFieldOffset?
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure1, FieldPtr->ArraySizeFieldOffset)):
                            1;
                iLen2 = FieldPtr->ArraySizeFieldOffset?
                            *(GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(UINT*, pStructure2, FieldPtr->ArraySizeFieldOffset)):
                            1;

                if(iLen1 != iLen2){
                    MYASSERT(FALSE);
                    return FALSE;
                }

                pSubStruct1 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure1, FieldPtr->Offset);
                pSubStruct2 = GET_STRUCT_MEMBER_BYVALUE_FROM_OFFSET(BYTE*, pStructure2, FieldPtr->Offset);
                if(memcmp(pSubStruct1, pSubStruct2, iLen1 * FieldPtr->Size)){
                    MYASSERT(FALSE);
                    return FALSE;
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\migshared\migutil\reg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reg.c

Abstract:

    Implements utilities to parse a registry key string, and also implements
    wrappers to the registry API.  There are three groups of APIs in this
    source file: query functions, open and create functions, and registry
    string parsing functions.

    The query functions allow simplified querying, where the caller receives
    a MemAlloc'd pointer to the data and does not have to worry about managing
    the numerous parameters needed to do the query.  The query functions
    also allow filtering of values that are not the expected type.  All
    query functions have a version with 2 appended to the function name which
    allow the caller to specify an alternative allocator and deallocator.

    The open and create functions simplify the process of obtaining a key
    handle.  They allow the caller to specify a key string as input and return
    the key handle as output.

    The registry string parsing functions are utilities that can be used when
    processing registry key strings.  The functions extract the registry root
    from a string, convert it into a handle, convert a hive handle into a
    string, and so on.

Author:

    Jim Schmidt (jimschm)  20-Mar-1997

Revisions:

    jimschm     18-Sep-2000 Added cache
    ovidiut     22-Feb-1999 Added GetRegSubkeysCount
    calinn      23-Sep-1998 Fixed REG_SZ filtering
    jimschm     25-Mar-1998 Added CreateEncodedRegistryStringEx
    jimschm     21-Oct-1997 Added EnumFirstKeyInTree/EnumNextKeyInTree
    marcw       16-Jul-1997 Added CreateEncodedRegistryString/FreeEncodedRegistryString
    jimschm     22-Jun-1997 Added GetRegData

--*/

#include "pch.h"
#include "migutilp.h"

#include "regp.h"

#ifdef DEBUG
#undef RegCloseKey
#endif

HKEY g_Root = HKEY_ROOT;
REGSAM g_OpenSam = KEY_ALL_ACCESS;
REGSAM g_CreateSam = KEY_ALL_ACCESS;
INT g_RegRefs;

#define DBG_REG     "Reg"

//
// Implementation
//


BOOL
RegInitialize (
    VOID
    )
{
    BOOL b = TRUE;

    MYASSERT (g_RegRefs >= 0);

    g_RegRefs++;

    if (g_RegRefs == 1) {

        RegInitializeCache (0);
    }

    return b;
}


VOID
RegTerminate (
    VOID
    )
{
    MYASSERT (g_RegRefs > 0);

    g_RegRefs--;

    if (!g_RegRefs) {
        RegTerminateCache ();
    }

#ifdef DEBUG
    RegTrackTerminate();
#endif
}


VOID
SetRegRoot (
    IN      HKEY Root
    )
{
    g_Root = Root;
}

HKEY
GetRegRoot (
    VOID
    )
{
    return g_Root;
}


REGSAM
SetRegOpenAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_OpenSam;
    g_OpenSam = Mode;

    return OldMode;
}

REGSAM
GetRegOpenAccessMode (
    REGSAM Mode
    )
{
    return g_OpenSam;
}

REGSAM
SetRegCreateAccessMode (
    REGSAM Mode
    )
{
    REGSAM OldMode;

    OldMode = g_CreateSam;
    g_CreateSam = Mode;

    return OldMode;
}

REGSAM
GetRegCreateAccessMode (
    REGSAM Mode
    )
{
    return g_CreateSam;
}

/*++

Routine Description:

  OpenRegKeyStrA and OpenRegKeyStrW parse a text string that specifies a
  registry key into the hive and subkey, and then they open the subkey
  and return the handle.

Arguments:

  RegKey    - Specifies the complete path to the registry subkey, including
              the hive.

Return Value:

  A non-NULL registry handle if successful, or NULL if either the subkey
  could not be opened or the string is malformed.

--*/

HKEY
RealOpenRegKeyStrA (
    IN      PCSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheA (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYA (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = _mbsrchr (RegKey, '\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheA (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerA (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGA ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyA (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerA (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheA (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheA (RegKey, lastWack);
    }

    return Key;
}


HKEY
RealOpenRegKeyStrW (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    DWORD End;
    HKEY RootKey;
    HKEY Key;
    HKEY parentKey;
    PCWSTR lastWack;

    //
    // Attempt to use cache
    //

    Key = RegGetKeyFromCacheW (RegKey, NULL, g_OpenSam, TRUE);
    if (Key) {
        TRACK_KEYW (Key, RegKey);
        return Key;
    }

    //
    // Attempt to use cache for parent
    //

    lastWack = wcsrchr (RegKey, L'\\');
    if (lastWack) {
        parentKey = RegGetKeyFromCacheW (RegKey, lastWack, g_OpenSam, FALSE);
        if (parentKey) {
            Key = OpenRegKeyWorkerW (parentKey, lastWack + 1 /* , */ DEBUG_TRACKING_ARGS);
            RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
            return Key;
        }
    }

    //
    // Not in cache; use full api
    //

    DEBUGMSGW ((DBG_REG, "Opening %s", RegKey));

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return NULL;
    }

    if (!RegKey[End]) {
        OurRegOpenRootKeyW (RootKey, RegKey /* , */ DEBUG_TRACKING_ARGS);
        return RootKey;
    }

    Key = OpenRegKeyWorkerW (RootKey, &RegKey[End] /* , */ DEBUG_TRACKING_ARGS);

    if (Key) {
        RegAddKeyToCacheW (RegKey, Key, g_OpenSam);
        RegRecordParentInCacheW (RegKey, lastWack);
    }

    return Key;
}

HKEY
RealOpenRegKeyStrW1 (
    IN      PCWSTR RegKey
            DEBUG_TRACKING_PARAMS
    )
{
    PCSTR AnsiRegKey;
    HKEY Key;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return NULL;
    }

    Key = RealOpenRegKeyStrA (AnsiRegKey /* , */ DEBUG_TRACKING_ARGS);

    FreeConvertedStr (AnsiRegKey);

    return Key;
}

BOOL
DeleteRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyA (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    HKEY RootKey;

    RootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!RootKey) {
        return FALSE;
    }

    if (!RegKey[End]) {
        return FALSE;
    }

    return (RegDeleteKeyW (RootKey, &RegKey[End]) == ERROR_SUCCESS);
}

BOOL
DeleteRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

BOOL
DeleteEmptyRegKeyStrA (
    IN      PCSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyA (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyA (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyA (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW (
    IN      PCWSTR RegKey
    )
{
    DWORD End;
    LONG rc;
    DWORD subKeys;
    DWORD values;
    HKEY rootKey;
    HKEY subKey;

    rootKey = ConvertRootStringToKeyW (RegKey, &End);
    if (!rootKey) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!RegKey[End]) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    subKey = OpenRegKeyW (rootKey, &RegKey[End]);
    if (!subKey) {
        return TRUE;
    }

    rc = RegQueryInfoKey (subKey, NULL, NULL, NULL, &subKeys, NULL, NULL, &values, NULL, NULL, NULL, NULL);

    CloseRegKey (subKey);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    if (subKeys || values) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }

    rc = RegDeleteKeyW (rootKey, &RegKey[End]);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }
    return TRUE;
}

BOOL
DeleteEmptyRegKeyStrW1 (
    IN      PCWSTR RegKey
    )
{
    PCSTR AnsiRegKey;
    BOOL result = FALSE;

    AnsiRegKey = ConvertWtoA (RegKey);
    if (!AnsiRegKey) {
        return FALSE;
    }

    result = DeleteEmptyRegKeyStrA (AnsiRegKey);

    FreeConvertedStr (AnsiRegKey);

    return result;
}

PVOID
MemAllocWrapper (
    IN      DWORD Size
    )

/*++

Routine Description:

  pemAllocWrapper implements a default allocation routine.  The APIs
  that have a "2" at the end allow the caller to supply an alternative
  allocator or deallocator.  The routines without the "2" use this
  default allocator.

Arguments:

  Size - Specifies the amount of memory (in bytes) to allocate

Return Value:

  A pointer to a block of memory that can hold Size bytes, or NULL
  if allocation fails.

--*/

{
    return MemAlloc (g_hHeap, 0, Size);
}


VOID
MemFreeWrapper (
    IN      PCVOID Mem
    )

/*++

Routine Description:

  MemFreeWrapper implements a default deallocation routine.
  See MemAllocWrapper above.

Arguments:

  Mem - Specifies the block of memory to free, and was allocated by the
        MemAllocWrapper function.

Return Value:

  none

--*/

{
    MemFree (g_hHeap, 0, Mem);
}


/*++

Routine Description:

  GetRegValueData2A and GetRegValueData2W query a registry value and
  return the data as a pointer.  They use the specified Alloc and Free
  routines to allocate and free the memory as needed.

  A GetRegValueData macro is defined, and it uses the default allocators,
  simplifying the function parameters and allowing the caller to free
  the return value via MemFree.

Arguments:

  hKey  - Specifies the registry key that holds the specified value.

  Value - Specifies the value name to query.

  Alloc - Specifies the allocation routine, called to allocate a block of
          memory for the return data.

  FreeRoutine  - Specifies the deallocation routine, called if an error is encountered
          during processing.

Return Value:

  A pointer to the data retrieved, or NULL if the value does not exist or an
  error occurred.  Call GetLastError to obtian the failure code.

--*/

PBYTE
GetRegValueData2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;

    rc = RegQueryValueExA (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (CHAR));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PSTR) DataBuf + BufSize) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueData2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;

    rc = RegQueryValueExW (hKey, Value, NULL, NULL, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }


    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


/*++

Routine Description:

  GetRegValueDataOfType2A and GetRegValueDataOfType2W are extensions of
  GetRegValueData.  They only return a data pointer when the data stored
  in the registry value is the correct type.

Arguments:

  hKey - Specifies the registry key to query

  Value - Specifies the value name to query

  MustBeType - Specifies the type of data (a REG_* constant).  If the specified
               value has data but is a different type, NULL will be returned.

  AllocRoutine - Specifies the allocation routine, called to allocate the return data.

  FreeRoutine - Specifies the deallocation routine, called when an error is encountered.

Return Value:

  If successful, returns a pointer to data that matches the specified type.
  If the data is a different type, the value name does not exist, or an
  error occurs during the query, NULL is returned, and the failure code
  can be obtained from GetLastError.

--*/


PBYTE
GetRegValueDataOfType2A (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize = 0;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExA (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    switch (MustBeType) {

    case REG_SZ:
    case REG_EXPAND_SZ:
        if (Type == REG_SZ) {
            break;
        }
        if (Type == REG_EXPAND_SZ) {
            break;
        }
        return NULL;

    default:
        if (Type == MustBeType) {
            break;
        }
        return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof (WORD));
    rc = RegQueryValueExA (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWORD) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


PBYTE
GetRegValueDataOfType2W (
    IN      HKEY hKey,
    IN      PCWSTR Value,
    IN      DWORD MustBeType,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    LONG rc;
    DWORD BufSize;
    PBYTE DataBuf;
    DWORD Type;

    rc = RegQueryValueExW (hKey, Value, NULL, &Type, NULL, &BufSize);
    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }
    switch (MustBeType) {
        case REG_SZ:
        case REG_EXPAND_SZ:
            if (Type == REG_SZ) break;
            if (Type == REG_EXPAND_SZ) break;
            return NULL;
        case REG_DWORD:
        case REG_DWORD_BIG_ENDIAN:
            if (Type == REG_DWORD) break;
            if (Type == REG_DWORD_BIG_ENDIAN) break;
            return NULL;
        default:
            if (Type == MustBeType) break;
            return NULL;
    }

    DataBuf = (PBYTE) AllocRoutine (BufSize + sizeof(WCHAR));
    rc = RegQueryValueExW (hKey, Value, NULL, NULL, DataBuf, &BufSize);

    if (rc == ERROR_SUCCESS) {
        *((PWSTR) (DataBuf + BufSize)) = 0;
        return DataBuf;
    }

    MYASSERT (FALSE);   //lint !e506
    FreeRoutine (DataBuf);
    SetLastError ((DWORD)rc);
    return NULL;
}


BOOL
GetRegValueTypeAndSizeA (
    IN      HKEY Key,
    IN      PCSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size = 0;

    rc = RegQueryValueExA (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetRegValueTypeAndSizeW (
    IN      HKEY Key,
    IN      PCWSTR ValueName,
    OUT     PDWORD OutType,         OPTIONAL
    OUT     PDWORD OutSize          OPTIONAL
    )
{
    LONG rc;
    DWORD Type;
    DWORD Size;

    rc = RegQueryValueExW (Key, ValueName, NULL, &Type, NULL, &Size);

    if (rc == ERROR_SUCCESS) {
        if (OutType) {
            *OutType = Type;
        }

        if (OutSize) {
            *OutSize = Size;
        }

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

  GetRegKeyData2A and GetRegKeyData2W return default data associated
  with a registry key.  They open the specified subkey, query the value,
  close the subkey and return the data.

Arguments:

  Parent - Specifies the key that contains SubKey.

  SubKey - Specifies the name of the subkey to obtain the default value for.

  AllocRoutine  - Specifies the allocation routine, called to allocate a block of
           memory for the registry data.

  FreeRoutine   - Specifies the deallocation routine, called to free the block of
           data if an error occurs.

Return Value:

  A pointer to the block of data obtained from the subkey's default value,
  or NULL if the subkey does not exist or an error was encountered.  Call
  GetLastError for a failure code.

--*/

PBYTE
GetRegKeyData2A (
    IN      HKEY Parent,
    IN      PCSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyA (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2A (SubKeyHandle, "", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


PBYTE
GetRegKeyData2W (
    IN      HKEY Parent,
    IN      PCWSTR SubKey,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY SubKeyHandle;
    PBYTE Data;

    SubKeyHandle = OpenRegKeyW (Parent, SubKey);
    if (!SubKeyHandle) {
        return NULL;
    }

    Data = GetRegValueData2W (SubKeyHandle, L"", AllocRoutine, FreeRoutine);

    CloseRegKey (SubKeyHandle);

    return Data;
}


/*++

Routine Description:

  GetRegData2A and GetRegData2W open a registry key, query a value,
  close the registry key and return the value.

Arguments:

  KeyString - Specifies the registry key to open

  ValueName - Specifies the value to query

  AllocRoutine - Specifies the allocation routine, used to allocate a block of
          memory to hold the value data

  FreeRoutine  - Specifies the deallocation routine, used to free the block of
          memory when an error is encountered.

Return Value:

  A pointer to the registry data retrieved, or NULL if the key or value
  does not exist, or if an error occurs. Call GetLastError for a failure code.

--*/

PBYTE
GetRegData2A (
    IN      PCSTR KeyString,
    IN      PCSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrA (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2A (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


PBYTE
GetRegData2W (
    IN      PCWSTR KeyString,
    IN      PCWSTR ValueName,
    IN      ALLOCATOR AllocRoutine,
    IN      DEALLOCATOR FreeRoutine
    )
{
    HKEY Key;
    PBYTE Data;

    Key = OpenRegKeyStrW (KeyString);
    if (!Key) {
        return NULL;
    }

    Data = GetRegValueData2W (Key, ValueName, AllocRoutine, FreeRoutine);

    CloseRegKey (Key);

    return Data;
}


BOOL
GetRegSubkeysCount (
    IN      HKEY ParentKey,
    OUT     PDWORD SubKeyCount,     OPTIONAL
    OUT     PDWORD MaxSubKeyLen     OPTIONAL
    )
/*++

Routine Description:

  GetRegSubkeysCount retrieves the number of subkeys of a given parent key.

Arguments:

  ParentKey - Specifies a handle to the parent registry key.

  SubKeyCount - Receives the number of subkeys

  MaxSubKeyLen - Receives the length, in chars, of the longest subkey string

Return Value:

  TRUE if the count was retrieved successfully, FALSE otherwise.
  In this case, call GetLastError for a failure code.

--*/

{
    LONG rc;

    rc = RegQueryInfoKey (
                ParentKey,
                NULL,
                NULL,
                NULL,
                SubKeyCount,
                MaxSubKeyLen,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

  CreateRegKeyA and CreateRegKeyW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  ParentKey - Specifies a handle to the parent registry key to contain
              the new key.

  NewKeyName - Specifies the name of the subkey to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLastError for a failure code.

--*/

HKEY
pCreateRegKeyWorkerA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExA (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyA (
    IN      HKEY ParentKey,
    IN      PCSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerA (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheA ("", result, g_CreateSam);

    return result;
}

HKEY
pCreateRegKeyWorkerW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    LONG rc;
    HKEY SubKey;
    DWORD DontCare;

    rc = OurRegCreateKeyExW (
             ParentKey,
             NewKeyName,
             0,
             NULL,
             0,
             g_CreateSam,
             NULL,
             &SubKey,
             &DontCare
             DEBUG_TRACKING_ARGS
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError ((DWORD)rc);
        return NULL;
    }

    return SubKey;
}


HKEY
RealCreateRegKeyW (
    IN      HKEY ParentKey,
    IN      PCWSTR NewKeyName
            DEBUG_TRACKING_PARAMS
    )
{
    HKEY result;

    result = pCreateRegKeyWorkerW (ParentKey, NewKeyName /* , */ DEBUG_TRACKING_ARGS);
    RegAddKeyToCacheW (L"", result, g_CreateSam);

    return result;
}

/*++

Routine Description:

  CreateRegKeyStrA and CreateRegKeyStrW create a subkey if it does not
  exist already, or open a subkey if it already exists.

Arguments:

  NewKeyName - Specifies the full path to the key to create or open.

Return Value:

  The handle to an open registry key upon success, or NULL if an
  error occurred.  Call GetLast