ERT),
    SeedIoctlValue(IOCTL_SERIAL_LSRMST_INSERT),
    SeedIoctlValue(IOCTL_SERIAL_PURGE),
    SeedIoctlValue(IOCTL_SERIAL_RESET_DEVICE),
    SeedIoctlValue(IOCTL_SERIAL_SET_BAUD_RATE),
    SeedIoctlValue(IOCTL_SERIAL_SET_BREAK_OFF),
    SeedIoctlValue(IOCTL_SERIAL_SET_BREAK_ON),
    SeedIoctlValue(IOCTL_SERIAL_SET_CHARS),
    SeedIoctlValue(IOCTL_SERIAL_SET_COMMCONFIG),
    SeedIoctlValue(IOCTL_SERIAL_SET_DTR),
    SeedIoctlValue(IOCTL_SERIAL_SET_FIFO_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_HANDFLOW),
    SeedIoctlValue(IOCTL_SERIAL_SET_LINE_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_MODEM_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_QUEUE_SIZE),
    SeedIoctlValue(IOCTL_SERIAL_SET_RTS),
    SeedIoctlValue(IOCTL_SERIAL_SET_TIMEOUTS),
    SeedIoctlValue(IOCTL_SERIAL_SET_WAIT_MASK),
    SeedIoctlValue(IOCTL_SERIAL_SET_XOFF),
    SeedIoctlValue(IOCTL_SERIAL_SET_XON),
    SeedIoctlValue(IOCTL_SERIAL_WAIT_ON_MASK),
    SeedIoctlValue(IOCTL_SERIAL_XOFF_COUNTER),
    SeedIoctlValue(IOCTL_SET_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_SET_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS),
    SeedIoctlValue(IOCTL_SET_SERVER_STATE),
    SeedIoctlValue(IOCTL_SMARTCARD_CONFISCATE),
    SeedIoctlValue(IOCTL_SMARTCARD_EJECT),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_ATTRIBUTE),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_LAST_ERROR),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_PERF_CNTR),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_STATE),
    SeedIoctlValue(IOCTL_SMARTCARD_IS_ABSENT),
    SeedIoctlValue(IOCTL_SMARTCARD_IS_PRESENT),
    SeedIoctlValue(IOCTL_SMARTCARD_POWER),
    SeedIoctlValue(IOCTL_SMARTCARD_SET_ATTRIBUTE),
    SeedIoctlValue(IOCTL_SMARTCARD_SET_PROTOCOL),
    SeedIoctlValue(IOCTL_SMARTCARD_SWALLOW),
    SeedIoctlValue(IOCTL_SMARTCARD_TRANSMIT),
    SeedIoctlValue(IOCTL_SOCKET_INFORMATION),
    SeedIoctlValue(IOCTL_STORAGE_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_STORAGE_CHECK_VERIFY2),
    SeedIoctlValue(IOCTL_STORAGE_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_STORAGE_EJECTION_CONTROL),
    SeedIoctlValue(IOCTL_STORAGE_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_STORAGE_GET_DEVICE_NUMBER),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_TYPES),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_TYPES_EX),
    SeedIoctlValue(IOCTL_STORAGE_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_STORAGE_LOAD_MEDIA2),
    SeedIoctlValue(IOCTL_STORAGE_MCN_CONTROL),
    SeedIoctlValue(IOCTL_STORAGE_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_STORAGE_PREDICT_FAILURE),
    SeedIoctlValue(IOCTL_STORAGE_QUERY_PROPERTY),
    SeedIoctlValue(IOCTL_STORAGE_RELEASE),
    SeedIoctlValue(IOCTL_STORAGE_RESERVE),
    SeedIoctlValue(IOCTL_STORAGE_RESET_BUS),
    SeedIoctlValue(IOCTL_STORAGE_RESET_DEVICE),
    SeedIoctlValue(IOCTL_STORAGE_SET_READ_AHEAD),
    SeedIoctlValue(IOCTL_STREAMS_GETMSG),
    SeedIoctlValue(IOCTL_STREAMS_IOCTL),
    SeedIoctlValue(IOCTL_STREAMS_POLL),
    SeedIoctlValue(IOCTL_STREAMS_PUTMSG),
    SeedIoctlValue(IOCTL_STREAMS_TDI_TEST),
    SeedIoctlValue(IOCTL_SWENUM_GET_BUS_ID),
    SeedIoctlValue(IOCTL_SWENUM_INSTALL_INTERFACE),
    SeedIoctlValue(IOCTL_SWENUM_REMOVE_INTERFACE),
    SeedIoctlValue(IOCTL_TAPE_CREATE_PARTITION),
    SeedIoctlValue(IOCTL_TAPE_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_TAPE_ERASE),
    SeedIoctlValue(IOCTL_TAPE_GET_DRIVE_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_GET_MEDIA_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_GET_POSITION),
    SeedIoctlValue(IOCTL_TAPE_GET_STATUS),
    SeedIoctlValue(IOCTL_TAPE_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_TAPE_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_TAPE_PREPARE),
    SeedIoctlValue(IOCTL_TAPE_RELEASE),
    SeedIoctlValue(IOCTL_TAPE_RESERVE),
    SeedIoctlValue(IOCTL_TAPE_SET_DRIVE_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_SET_MEDIA_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_SET_POSITION),
    SeedIoctlValue(IOCTL_TAPE_WRITE_MARKS),
    SeedIoctlValue(IOCTL_TDI_ACCEPT),
    SeedIoctlValue(IOCTL_TDI_ACTION),
    SeedIoctlValue(IOCTL_TDI_ASSOCIATE_ADDRESS),
    SeedIoctlValue(IOCTL_TDI_CONNECT),
    SeedIoctlValue(IOCTL_TDI_DISASSOCIATE_ADDRESS),
    SeedIoctlValue(IOCTL_TDI_DISCONNECT),
    SeedIoctlValue(IOCTL_TDI_LISTEN),
    SeedIoctlValue(IOCTL_TDI_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_TDI_RECEIVE),
    SeedIoctlValue(IOCTL_TDI_RECEIVE_DATAGRAM),
    SeedIoctlValue(IOCTL_TDI_SEND),
    SeedIoctlValue(IOCTL_TDI_SEND_DATAGRAM),
    SeedIoctlValue(IOCTL_TDI_SET_EVENT_HANDLER),
    SeedIoctlValue(IOCTL_TDI_SET_INFORMATION),
    SeedIoctlValue(IOCTL_TRNXT_READ),
    SeedIoctlValue(IOCTL_TRNXT_XCEIVE),
    SeedIoctlValue(IOCTL_USB_DIAG_IGNORE_HUBS_OFF),
    SeedIoctlValue(IOCTL_USB_DIAG_IGNORE_HUBS_ON),
    SeedIoctlValue(IOCTL_USB_DIAGNOSTIC_MODE_OFF),
    SeedIoctlValue(IOCTL_USB_DIAGNOSTIC_MODE_ON),
    SeedIoctlValue(IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_INFORMATION),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_NAME),
    SeedIoctlValue(IOCTL_USB_GET_NODE_INFORMATION),
    SeedIoctlValue(IOCTL_USB_GET_ROOT_HUB_NAME),
    SeedIoctlValue(IOCTL_USB_HCD_GET_STATS_1),
    SeedIoctlValue(IOCTL_USB_HCD_GET_STATS_2),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_CURSOR),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_POINTER),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_VDM),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_CURSOR),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_POINTER),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_VDM),
    SeedIoctlValue(IOCTL_VIDEO_ENUM_MONITOR_PDO),
    SeedIoctlValue(IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES),
    SeedIoctlValue(IOCTL_VIDEO_GET_BANK_SELECT_CODE),
    SeedIoctlValue(IOCTL_VIDEO_GET_CHILD_STATE),
    SeedIoctlValue(IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_VIDEO_GET_POWER_MANAGEMENT),
    SeedIoctlValue(IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS),
    SeedIoctlValue(IOCTL_VIDEO_INIT_WIN32K_CALLBACKS),
    SeedIoctlValue(IOCTL_VIDEO_LOAD_AND_SET_FONT),
    SeedIoctlValue(IOCTL_VIDEO_MAP_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_MONITOR_DEVICE),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_AVAIL_MODES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURRENT_MODE),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURSOR_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES),
    SeedIoctlValue(IOCTL_VIDEO_REGISTER_VDM),
    SeedIoctlValue(IOCTL_VIDEO_RESET_DEVICE),
    SeedIoctlValue(IOCTL_VIDEO_RESTORE_HARDWARE_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SAVE_HARDWARE_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION),
    SeedIoctlValue(IOCTL_VIDEO_SET_COLOR_LUT_DATA),
    SeedIoctlValue(IOCTL_VIDEO_SET_COLOR_REGISTERS),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURRENT_MODE),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURSOR_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SET_PALETTE_REGISTERS),
    SeedIoctlValue(IOCTL_VIDEO_SET_POINTER_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_SET_POINTER_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_SET_POWER_MANAGEMENT),
    SeedIoctlValue(IOCTL_VIDEO_SHARE_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_UNMAP_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION),
    SeedIoctlValue(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS),
    SeedIoctlValue(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS),
    SeedIoctlValue(IOCTL_VOLUME_IS_IO_CAPABLE),
    SeedIoctlValue(IOCTL_VOLUME_IS_OFFLINE),
    SeedIoctlValue(IOCTL_VOLUME_LOGICAL_TO_PHYSICAL),
    SeedIoctlValue(IOCTL_VOLUME_OFFLINE),
    SeedIoctlValue(IOCTL_VOLUME_ONLINE),
    SeedIoctlValue(IOCTL_VOLUME_PHYSICAL_TO_LOGICAL),
    SeedIoctlValue(IOCTL_VOLUME_QUERY_FAILOVER_SET),
    SeedIoctlValue(IOCTL_VOLUME_QUERY_VOLUME_NUMBER),
    SeedIoctlValue(IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE),
    SeedIoctlValue(IOCTL_WAIT_ON_DEVICE_EVENT),
    SeedIoctlValue(IOCTL_WMI_CHECK_ACCESS),
    SeedIoctlValue(IOCTL_WMI_DISABLE_COLLECTION),
    SeedIoctlValue(IOCTL_WMI_DISABLE_EVENT),
    SeedIoctlValue(IOCTL_WMI_ENABLE_COLLECTION),
    SeedIoctlValue(IOCTL_WMI_ENABLE_EVENT),
    SeedIoctlValue(IOCTL_WMI_EXECUTE_METHOD),
    SeedIoctlValue(IOCTL_WMI_GENERATE_EVENT),
    SeedIoctlValue(IOCTL_WMI_GET_ALL_REGISTRANT),
    SeedIoctlValue(IOCTL_WMI_GET_NEXT_REGISTRANT),
    SeedIoctlValue(IOCTL_WMI_GET_REGINFO),
    SeedIoctlValue(IOCTL_WMI_GET_VERSION),
    SeedIoctlValue(IOCTL_WMI_NOTIFY_USER),
    SeedIoctlValue(IOCTL_WMI_OPEN_GUID),
    SeedIoctlValue(IOCTL_WMI_QUERY_ALL_DATA),
    SeedIoctlValue(IOCTL_WMI_QUERY_LOGGER),
    SeedIoctlValue(IOCTL_WMI_QUERY_SINGLE_INSTANCE),
    SeedIoctlValue(IOCTL_WMI_READ_NOTIFICATIONS),
    SeedIoctlValue(IOCTL_WMI_SET_SINGLE_INSTANCE),
    SeedIoctlValue(IOCTL_WMI_SET_SINGLE_ITEM),
    SeedIoctlValue(IOCTL_WMI_START_LOGGER),
    SeedIoctlValue(IOCTL_WMI_STOP_LOGGER),
    SeedIoctlValue(IOCTL_WMI_TRACE_EVENT),
    SeedIoctlValue(IOCTL_WMI_TRACE_MESSAGE),
    SeedIoctlValue(IOCTL_WMI_TRANSLATE_FILE_HANDLE),
    SeedIoctlValue(IOCTL_WMI_UPDATE_LOGGER),
    SeedIoctlValue(IOCTL_WRITE_REGISTERS),
    {NULL, 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\custcon.cpp ===
//////////////////////////////////////////////////////////////////////
//
// custcon.cpp : AvP[VpNXÃí`s‹ÇB
//
// 1998 Jun, Hiro Yamamoto
//

#include "stdafx.h"
#include "custcon.h"
#include "custconDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCustconApp

BEGIN_MESSAGE_MAP(CCustconApp, CWinApp)
    //{{AFX_MSG_MAP(CCustconApp)
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustconApp NXÃç\z

CCustconApp::CCustconApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// B CCustconApp IuWFNg

CCustconApp theApp;

int gExMode;

/////////////////////////////////////////////////////////////////////////////
// CCustconApp NXÃè

inline bool strequ(LPCTSTR a, LPCTSTR b)
{
    return !_tcscmp(a, b);
}

BOOL CCustconApp::InitInstance()
{
#ifdef _AFXDLL
    Enable3dControls();         // L DLL  MFC gÍçáÕÇR[ƒÇB
#else
    Enable3dControlsStatic();   // MFC ∆ê√ìI…ÉNÍçáÕÇR[ƒÇB
#endif

    //
    // Parse command line
    //

    if (strequ(m_lpCmdLine, _T("-e"))) {
        gExMode = 1;
    }

    CCustconDlg dlg;
    m_pMainWnd = &dlg;
    dlg.DoModal();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\custcon.h ===
//////////////////////////////////////////////////////////////////////
//
// custcon.h : CUSTCON AvP[VÃÉC wb_[ t@C≈ÇB
//

#if !defined(AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // C V{

/////////////////////////////////////////////////////////////////////////////
// CCustconApp:
// ÃÉNXÃìÃí`…ä÷ÇƒÇ custcon.cpp t@CQ∆ÇƒÇB
//

class CCustconApp : public CWinApp
{
public:
    CCustconApp();

// I[o[Ch
    // ClassWizard Õâz÷êÃÉI[o[Chê∂ê‹ÇB
    //{{AFX_VIRTUAL(CCustconApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Cve[V

    //{{AFX_MSG(CCustconApp)
        //  - ClassWizard ÕÇÃà íu…Éo÷ê«â‹ÇÕçÌèú‹ÇB
        //        Ãà íu…êR[h“èW»Ç≈ÇB
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

extern int gExMode;     // default mode

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio ÕëOsÃíO…í«âÃêÈåæ}‹ÇB

#endif // !defined(AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\custcondlg.h ===
//////////////////////////////////////////////////////////////////////
//
// custconDlg.h : wb_[ t@C
//

#if !defined(AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg dialog

class CCustconDlg : public CDialog
{
// \z
public:
    CCustconDlg(CWnd* pParent = NULL);  // WÃÉRXgN^

// Dialog Data
    //{{AFX_DATA(CCustconDlg)
    enum { IDD = IDD_CUSTCON_DIALOG };
    CEdit   m_wordDelimCtrl;
    //}}AFX_DATA

    // ClassWizard Õâz÷êÃÉI[o[Chê∂ê‹ÇB
    //{{AFX_VIRTUAL(CCustconDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV ÃÉT|[g
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_VIRTUAL

// Cve[V
protected:
    HICON m_hIcon;

    // ÍÇΩbZ[W }bv÷ê
    //{{AFX_MSG(CCustconDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnApply();
    afx_msg void OnDefaultValue();
    afx_msg void OnChangeWordDelim();
    afx_msg void OnUseExtendedEditKey();
    afx_msg void OnTrimLeadingZeros();
    afx_msg void OnReset();
    //}}AFX_MSG
    afx_msg void OnSelChange(UINT id);
    DECLARE_MESSAGE_MAP()

protected:
    void InitContents(BOOL isDefault);
    void CharInUse(UINT id, TCHAR c);
    void CharReturn(UINT id, TCHAR c);

    bool Update();

    int m_cWordDelimChanging;
    void EnableApply(BOOL fEnable = TRUE);

protected:
    CFont m_font;   // font for word delimiter edit control
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio ÕëOsÃíO…í«âÃêÈåæ}‹ÇB

#endif // !defined(AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\custcondlg.cpp ===
//////////////////////////////////////////////////////////////////////
//
// custconDlg.cpp : Implementation file
// 1998 Jun, Hiro Yamamoto
//
//

#include "stdafx.h"
#include "custcon.h"
#include "custconDlg.h"
#include "Registry.h"
#include "AboutDlg.h"
#include "KeyDef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IDC_CTRL_END    IDC_PAUSE

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg _CAO

CCustconDlg::CCustconDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CCustconDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CCustconDlg)
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

    m_cWordDelimChanging = 0;
}

void CCustconDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustconDlg)
    DDX_Control(pDX, IDC_WORD_DELIM, m_wordDelimCtrl);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCustconDlg, CDialog)
    //{{AFX_MSG_MAP(CCustconDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_APPLY, OnApply)
    ON_BN_CLICKED(IDC_DEFAULT_VALUE, OnDefaultValue)
    ON_EN_CHANGE(IDC_WORD_DELIM, OnChangeWordDelim)
    ON_BN_CLICKED(IDC_USE_EXTENDED_EDIT_KEY, OnUseExtendedEditKey)
    ON_BN_CLICKED(IDC_TRIM_LEADING_ZEROS, OnTrimLeadingZeros)
    ON_BN_CLICKED(IDC_RESET, OnReset)
    //}}AFX_MSG_MAP
    ON_CONTROL_RANGE(CBN_SELCHANGE, IDC_A, IDC_Z, OnSelChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg members

BOOL CCustconDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // "o[W..." j[⁄ÇVXe j[÷í«â‹ÇB

    // IDM_ABOUTBOX ÕÉR}h j[ÃîÕàÕÇ≈Ç»ÇŒÇ»Ç‹ÇB
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // ÃÉ_CAOpÃÉACR›íËÇµ‹ÇBt[[NÕÉAvP[VÃÉC
    // EBhE_CAO≈Ç»ÇÕéI…ê›íËÇµ‹ÇB
    SetIcon(m_hIcon, TRUE);         // ÂÇ´ACR›í
    SetIcon(m_hIcon, FALSE);        // ACR›í

    InitContents(FALSE);    // use default value

    ASSERT(m_wordDelimCtrl.GetSafeHwnd());
    m_wordDelimCtrl.LimitText(63);

    CWnd* wnd = GetDlgItem(IDC_WORD_DELIM);
    ASSERT(wnd);
    CFont* font = wnd->GetFont();
    LOGFONT lf;
    VERIFY( font->GetLogFont(&lf) );
    _tcscpy(lf.lfFaceName, _T("Courier New"));
    VERIFY( m_font.CreateFontIndirect(&lf) );
    wnd->SetFont(&m_font);

    return TRUE;  // TRUE ‘Ç∆ÉRg[…ê›íËÇµtH[JXÕé‹ÇB
}

void CCustconDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// _CAO{bNX…ç≈è{^«â»ÇŒÅAACR`ÊÇ∑
// R[h»â…ãLqKv‹ÇBMFC AvP[V document/view
// fgƒÇÃÇ≈ÅAÃèÕÉt[[N…ÇËé©I…è‹ÇB

void CCustconDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // `pÃÉfoCX ReLXg

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // NCAgÃã`ÃàÃí
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // ACR`ÊÇµ‹ÇB
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// VXeÕÅA[U[≈èEBhEhbOƒÇ‘ÅA
// J[\\ÈÇΩﬂÇ…ÇƒÇ—èo‹ÇB
HCURSOR CCustconDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CCustconDlg::OnOK()
{
    if (!Update()) {
        GetDlgItem(IDCANCEL)->EnableWindow();
        return;
    }
    CDialog::OnOK();
}

void CCustconDlg::OnCancel()
{
    if (GetDlgItem(IDCANCEL)->IsWindowEnabled())
        CDialog::OnCancel();
}

enum {
    CMD_NOTCMDCOMMAND = 0,
    CMD_FILENAME_COMPLETION = 1,
} CmdExeFunction;

static const struct InternalKeyDef {
    LPCTSTR text;
    WORD mod;
    BYTE vkey;
    BYTE cmd;   // not zero if this functionality is actually of cmd.exe.
} texts[] = {
    { _T(" "),                  0,                  0, },
    { _T("Left"),               0,                  VK_LEFT, },
    { _T("Right"),              0,                  VK_RIGHT, },
    { _T("Up"),                 0,                  VK_UP, },
    { _T("Down"),               0,                  VK_DOWN, },
    { _T("Beginning of line"),  0,                  VK_HOME, },
    { _T("End of line"),        0,                  VK_END, },
    { _T("Del char fwd"),       0,                  VK_DELETE, },
    { _T("Del char bwd"),       0,                  VK_BACK, },
    { _T("Del line"),           0,                  VK_ESCAPE, },
    { _T("Pause"),              0,                  VK_PAUSE, },
    { _T("History call"),       0,                  VK_F8, },

    { _T("Word left"),          LEFT_CTRL_PRESSED,  VK_LEFT, },
    { _T("Word right"),         LEFT_CTRL_PRESSED,  VK_RIGHT, },
    { _T("Del line bwd"),       LEFT_CTRL_PRESSED,  VK_HOME, },
    { _T("Del line fwd"),       LEFT_CTRL_PRESSED,  VK_END, },
    { _T("Del word bwd"),       LEFT_CTRL_PRESSED,  VK_BACK, },
    { _T("Del word fwd"),       LEFT_CTRL_PRESSED,  VK_DELETE, },

    { _T("Complete(*) filename"),
                                LEFT_CTRL_PRESSED,  _T('I'),    CMD_FILENAME_COMPLETION, },
};

#define COMPLETION_TEXT_INDEX   (array_size(texts) - 1)

void CCustconDlg::InitContents(BOOL isDefault)
{
    static bool is1st = true;

    CConRegistry reg;

    UINT chkByDefault = gExMode ? 1 : 0;

    CheckDlgButton(IDC_USE_EXTENDED_EDIT_KEY, isDefault ? chkByDefault : reg.ReadMode() != 0);
    CheckDlgButton(IDC_TRIM_LEADING_ZEROS, isDefault ? chkByDefault : reg.ReadTrimLeadingZeros() != 0);

    if (is1st) {
        //
        // Setup comobo boxes
        //
        for (UINT id = IDC_A; id <= IDC_Z; ++id) {
            CComboBox* combo = (CComboBox*)GetDlgItem(id);
            if (combo) {
                for (int i = 0; i < array_size(texts); ++i) {
                    int n = combo->AddString(texts[i].text);
                    combo->SetItemDataPtr(n, (void*)&texts[i]);
                }
            }
        }
    }

    const ExtKeyDef* pKeyDef = gExMode == 0 ? gaDefaultKeyDef : gaDefaultKeyDef2;
    ExtKeyDefBuf regKeyDef;
    CmdExeFunctions cmdExeFunctions = { 0x9, };
    if (!isDefault) {
        if (reg.ReadCustom(&regKeyDef))
            pKeyDef = regKeyDef.table;

        reg.ReadCmdFunctions(&cmdExeFunctions);
    }
    for (UINT i = 0; i <= 'Z' - 'A'; ++i, ++pKeyDef) {
        CComboBox* combo = (CComboBox*)GetDlgItem(i + IDC_A);
        if (combo == NULL)
            continue;
        if (cmdExeFunctions.dwFilenameCompletion == i + 1) {
            //
            // If this is filename completion key
            //
            TRACE1("i=%d matches.\n", i);
            VERIFY( combo->SelectString(-1, texts[COMPLETION_TEXT_INDEX].text) >= 0);
        }
        else {
            for (int j = 0; j < array_size(texts); ++j) {
                if (pKeyDef->keys[0].wVirKey == texts[j].vkey && pKeyDef->keys[0].wMod == texts[j].mod) {
                    VERIFY( combo->SelectString(-1, texts[j].text) >= 0);
                }
            }
        }
    }

    static const TCHAR defaultDelim[] = _T("\\" L"+!:=/.<>[];|&");
    LPCTSTR p = defaultDelim;
    CString delimInReg;
    if (!isDefault) {
        delimInReg = reg.ReadWordDelim();
        if (delimInReg != CConRegistry::m_err)
            p = delimInReg;
    }
    ++m_cWordDelimChanging;
    m_wordDelimCtrl.SetWindowText(p);
    --m_cWordDelimChanging;

    is1st = false;
}

bool RunCmd()
{
    STARTUPINFO startupInfo = {
        sizeof startupInfo,
        NULL, /*lpDesktop=*/NULL, /*lpTitle=*/_T("Update cmd"),
        0, 0, 0, 0,
        /*dwXCountChars=*/10, /*dwYCountChars=*/10,
        /*dwFillAttribute=*/0,
        /*dwFlags=*/STARTF_USEFILLATTRIBUTE | STARTF_USECOUNTCHARS | STARTF_USESHOWWINDOW,
        /*wShowWindow=*/SW_HIDE,
        /*cbReserved2=*/0,
    };
    PROCESS_INFORMATION processInfo;

    TCHAR path[_MAX_PATH];
    TCHAR cmd[] = _T("cmd /c echo hello");
    GetSystemDirectory(path, _MAX_PATH);
    _tcscat(path, _T("\\cmd.exe"));

    if (!CreateProcess(
            path, 
            cmd,
            NULL, NULL,
            FALSE,
            CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &startupInfo,
            &processInfo)) {
        DWORD err = GetLastError();
        TRACE1("error code = %d\n", err);
        AfxMessageBox(_T("Could not run cmd.exe"));
        return false;
    }

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    return true;
}


bool CCustconDlg::Update()
{
    CConRegistry reg;

    //
    // To cheat the registry manager to skip the write when
    // values match, set the opposite value first and then
    // set the right one.
    //
    DWORD dwUseExKey = IsDlgButtonChecked(IDC_USE_EXTENDED_EDIT_KEY);
    if (!reg.WriteMode(!dwUseExKey) || !reg.WriteMode(dwUseExKey)) {
        return false;
    }

    if (!reg.WriteTrimLeadingZeros(IsDlgButtonChecked(IDC_TRIM_LEADING_ZEROS)))
        return false;

    //
    // Write custom extended keys
    //
    ExtKeyDefBuf value;

    memset(&value, 0, sizeof value);

    CmdExeFunctions cmdExeFunctions = { 0, };
    DWORD cmdFilenameCompletion = 0;

    for (int i = 0; i <= 'Z' - 'A'; ++i) {
        CComboBox* combo = (CComboBox*)GetDlgItem(IDC_A + i);
        if (combo == NULL)
            continue;
        int n = combo->GetCurSel();
        ASSERT(n >= 0);

        const InternalKeyDef* ikeydef = (const InternalKeyDef*)combo->GetItemDataPtr(n);
        ASSERT(ikeydef);

        switch (ikeydef->cmd) {
        case CMD_NOTCMDCOMMAND:
            value.table[i].keys[0].wMod = ikeydef->mod;
            value.table[i].keys[0].wVirKey = ikeydef->vkey;
            if (value.table[i].keys[0].wVirKey == VK_BACK && value.table[i].keys[0].wMod) {
                value.table[i].keys[0].wUnicodeChar = EXTKEY_ERASE_PREV_WORD;   // for back space special !
            }
            if (value.table[i].keys[0].wVirKey) {
                value.table[i].keys[1].wMod = LEFT_CTRL_PRESSED;
                value.table[i].keys[1].wVirKey = value.table[i].keys[0].wVirKey;
            }
            break;

        case CMD_FILENAME_COMPLETION:
            cmdExeFunctions.dwFilenameCompletion = i + 1;  // Ctrl + something
            break;
        }
    }
    BYTE* lpb = (BYTE*)&value.table[0];
    ASSERT(value.dwCheckSum == 0);
    for (i = 0; i < sizeof value.table; ++i) {
        value.dwCheckSum += lpb[i];
    }
    if (!reg.WriteCustom(&value) || !reg.WriteCmdFunctions(&cmdExeFunctions)) {
        return false;
    }

    CString buf;
    GetDlgItem(IDC_WORD_DELIM)->GetWindowText(buf);
    reg.WriteWordDelim(buf);

    EnableApply(FALSE);

    return RunCmd();
}


//
// Control exclusive selection etc.
//
void CCustconDlg::OnSelChange(UINT id)
{
    CComboBox* myself = (CComboBox*)GetDlgItem(id);
    ASSERT(myself);
    const InternalKeyDef* mykeydef = (const InternalKeyDef*)myself->GetItemDataPtr(myself->GetCurSel());
    if (mykeydef->cmd != CMD_NOTCMDCOMMAND) {
        for (unsigned i = 0; i <= 'Z' - 'A'; ++i) {
            if (IDC_A + i != id) {
                CComboBox* combo = (CComboBox*)GetDlgItem(IDC_A + i);
                if (combo == NULL)
                    continue;
                int n = combo->GetCurSel();
                ASSERT(n >= 0);

                const InternalKeyDef* ikeydef = (const InternalKeyDef*)combo->GetItemDataPtr(n);
                ASSERT(ikeydef);

                switch (ikeydef->cmd) {
                case CMD_NOTCMDCOMMAND:
                    break;

                default:
                    if (ikeydef->cmd == mykeydef->cmd) {
                        //
                        // Cmd function is exclusive.
                        //
                        combo->SetCurSel(0);
                    }
                    break;
                }
            }
        }
    }
    EnableApply();
}

//
// Enable or disable Apply button, if it's not yet.
//

void CCustconDlg::EnableApply(BOOL fEnable)
{
    CWnd* apply = GetDlgItem(IDC_APPLY);
    ASSERT(apply);
    if (apply->IsWindowEnabled() != fEnable)
        apply->EnableWindow(fEnable);
}

//
// "Apply" button hanlder.
//
// Firstly check and write the registry entry,
// then invoke dummy console window to let console know
// the change and let it update itself.
//

void CCustconDlg::OnApply()
{
    if (!Update())
        return;
    CWnd* wnd = GetDlgItem(IDCANCEL);
    ASSERT(wnd);
    wnd->EnableWindow(FALSE);
    CButton* ok = (CButton*)GetDlgItem(IDOK);
    ASSERT(ok);
    ok->SetWindowText(_T("Cl&ose"));
}

void CCustconDlg::OnDefaultValue()
{
    InitContents(TRUE);
    EnableApply();
}


//
// If user changes the setttings, enable "Apply" button
//

void CCustconDlg::OnChangeWordDelim()
{
    if (!m_cWordDelimChanging)
        EnableApply();
}

void CCustconDlg::OnUseExtendedEditKey()
{
    EnableApply();
}

void CCustconDlg::OnTrimLeadingZeros()
{
    EnableApply();
}

void CCustconDlg::OnReset()
{
    for (UINT id = IDC_A; id <= IDC_Z; ++id) {
        CComboBox* combo = (CComboBox*)GetDlgItem(id);
        if (combo) {
            combo->SetCurSel(0);
        }
    }
    GetDlgItem(IDC_WORD_DELIM)->SetWindowText(_T(""));
    CheckDlgButton(IDC_USE_EXTENDED_EDIT_KEY, 0);
    CheckDlgButton(IDC_TRIM_LEADING_ZEROS, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\keydef.cpp ===
//
// KeyDef.h
//

#include "stdafx.h"
#include "Keydef.h"


const ExtKeyDef gaDefaultKeyDef['Z' - 'A' + 1] = {
    {   // A
        0,                  VK_HOME,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_HOME,        0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_LEFT,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Alt
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_DELETE,      0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // E
        0,                  VK_END,         0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // F
        0,                  VK_RIGHT,       0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // G
        0,
    },
    {   // H
        0,
    },
    {   // I
        LEFT_CTRL_PRESSED,  _T('I'),        0,      // Ctrl
    },
    {   // J
        0,
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        0x7f,    // Ctrl
    },
    {   // X
        0,
    },
    {   // Y
        0,
    },
    {   // Z
        0,
    },
};

const ExtKeyDef gaDefaultKeyDef2['Z' - 'A' + 1] = {
    {   // A
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Ctrl
        0,                  0,              0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_HOME,        0,      // Ctrl
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_RIGHT,       0,      // Ctrl
    },
    {   // E
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // F
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Ctrl
    },
    {   // G
        0,                  VK_DELETE,      0,      // Ctrl
    },
    {   // H
        0,
    },
    {   // I
        0,
    },
    {   // J
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,                  VK_END,         0,      // Ctrl
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_LEFT,        0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        0x7f,   // Ctrl
    },
    {   // X
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // Y
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // Z
        0,
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\registry.h ===
//////////////////////////////////////////////////////////////////////
//
// Registry.h: Registry NXÃÉC^[tFCX
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_)
#define AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

struct CmdExeFunctions {
    DWORD dwFilenameCompletion;
};


class CConRegistry
{
public:
    CConRegistry();
    virtual ~CConRegistry();

public:
    static const CString m_err;
public:
    bool ReadCustom(ExtKeyDefBuf*);
    bool WriteCustom(const ExtKeyDefBuf*);

    DWORD ReadMode();
    bool WriteMode(DWORD);

    CString ReadWordDelim();
    bool WriteWordDelim(const CString&);

    DWORD ReadTrimLeadingZeros();
    bool WriteTrimLeadingZeros(DWORD);


    bool ReadCmdFunctions(CmdExeFunctions*);
    bool WriteCmdFunctions(const CmdExeFunctions*);

protected:
    void WriteError(LPCTSTR subkey);
    CString ReadString(LPCTSTR subkey);
    bool WriteString(LPCTSTR subkey, const CString& str);
    DWORD ReadDWORD(LPCTSTR subkey);
    bool WriteDWORD(LPCTSTR subkey, DWORD value);
protected:
    HKEY m_hkey;
    HKEY m_cmdKey;
};


#endif // !defined(AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\registry.cpp ===
//////////////////////////////////////////////////////////////////////
//
// Registry.cpp: Registry NXÃÉCve[V
//
// 1998 Jun, Hiro Yamamoto
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "custcon.h"
#include "Registry.h"
#include "KeyDef.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// \z/
//////////////////////////////////////////////////////////////////////

CConRegistry::CConRegistry()
{
    if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Console"), 0, KEY_ALL_ACCESS, &m_hkey) != ERROR_SUCCESS ||
            RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Command Processor"), 0, KEY_ALL_ACCESS, &m_cmdKey) != ERROR_SUCCESS) {
        AfxMessageBox(IDP_FAILED_TO_OPEN_REGISTRY);
        AfxAbort(); // exodus
    }
}

CConRegistry::~CConRegistry()
{
    ASSERT(m_hkey);
    VERIFY( RegCloseKey(m_hkey) == ERROR_SUCCESS );
    VERIFY( RegCloseKey(m_cmdKey) == ERROR_SUCCESS );
}

const CString CConRegistry::m_err(_T("\xffff"));

//////////////////////////////////////////////////////////////////////
// Members
//////////////////////////////////////////////////////////////////////

CString CConRegistry::ReadString(LPCTSTR subkey)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return m_err;

    DWORD size = 0;
    DWORD type;
    if (RegQueryValueEx(m_hkey, subkey, NULL, &type, NULL, &size) != ERROR_SUCCESS) {
        TRACE2("Reg::ReadString() error accessing \"%s\". err=%d\n", subkey, ::GetLastError());
        return m_err;
    }
    if (type != REG_SZ) {
        TRACE1("Reg::ReadString() -- type(%d) is not REG_SZ.\n", type);
        return m_err;
    }
    CString tmp;
    LPTSTR buf = tmp.GetBuffer(size);
    VERIFY( RegQueryValueEx(m_hkey, subkey, NULL, &type, (LPBYTE)buf, &size) == ERROR_SUCCESS );
    tmp.ReleaseBuffer();
    return tmp;
}

bool CConRegistry::WriteString(LPCTSTR subkey, const CString& value)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    if (RegSetValueEx(m_hkey, subkey, 0, REG_SZ, (LPBYTE)(LPCTSTR)value, (value.GetLength() + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        WriteError(subkey);
        return false;
    }
    return true;
}

DWORD CConRegistry::ReadDWORD(LPCTSTR subkey)
{
    DWORD value;
    DWORD type;
    DWORD size = sizeof value;
    if (RegQueryValueEx(m_hkey, subkey, NULL, &type, (LPBYTE)&value, &size) != ERROR_SUCCESS) {
        return 0;
    }
    if (type != REG_DWORD)
        return 0;
    return value;
}

bool CConRegistry::WriteDWORD(LPCTSTR subkey, DWORD value)
{
    if (RegSetValueEx(m_hkey, subkey, 0, REG_DWORD, (LPBYTE)&value, sizeof value) != ERROR_SUCCESS) {
        WriteError(subkey);
        return false;
    }
    return true;
}

void CConRegistry::WriteError(LPCTSTR subkey)
{
    CString buf;
    buf.Format(_T("Registry write operation (%s) failed.\r\nErr code=%d"), subkey, ::GetLastError());
    AfxMessageBox(buf);
}

//////////////////////////////////////////////////////////

bool CConRegistry::ReadCustom(ExtKeyDefBuf* buf)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    DWORD size;
    DWORD type;
    if (RegQueryValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, NULL, &type, NULL, &size) != ERROR_SUCCESS) {
        TRACE2("Reg::ReadCuston() error accessing \"%s\". err=%d\n", CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, ::GetLastError());
        return false;
    }
    if (type != REG_BINARY) {
        TRACE1("Reg::ReadString() -- type(%d) is not REG_SZ.\n", type);
        return false;
    }
    if (size != sizeof *buf) {
        TRACE1("Reg:ReadCuston() -- size(%d) is different.\n", size);
        return false;
    }

    VERIFY( RegQueryValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, NULL, &type, (LPBYTE)buf, &size) == ERROR_SUCCESS );

    return true;
}

bool CConRegistry::WriteCustom(const ExtKeyDefBuf* buf)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    if (RegSetValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, 0, REG_BINARY, (LPBYTE)buf, sizeof *buf) != ERROR_SUCCESS) {
        WriteError(CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM);
        return false;
    }

    return true;
}


DWORD CConRegistry::ReadMode()
{
    return ReadDWORD(CONSOLE_REGISTRY_EXTENDEDEDITKEY);
}

bool CConRegistry::WriteMode(DWORD value)
{
    return WriteDWORD(CONSOLE_REGISTRY_EXTENDEDEDITKEY, value);
}


CString CConRegistry::ReadWordDelim()
{
    return ReadString(CONSOLE_REGISTRY_WORD_DELIM);
}

bool CConRegistry::WriteWordDelim(const CString& value)
{
    return WriteString(CONSOLE_REGISTRY_WORD_DELIM, value);
}


DWORD CConRegistry::ReadTrimLeadingZeros()
{
    return ReadDWORD(CONSOLE_REGISTRY_TRIMZEROHEADINGS);
}

bool CConRegistry::WriteTrimLeadingZeros(DWORD value)
{
    return WriteDWORD(CONSOLE_REGISTRY_TRIMZEROHEADINGS, value);
}

#define CMD_REGISTRY_FILENAME_COMPLETION    _T("CompletionChar")

bool CConRegistry::ReadCmdFunctions(CmdExeFunctions* func)
{
    DWORD size = sizeof(func->dwFilenameCompletion);
    DWORD type;
    return RegQueryValueEx(m_cmdKey, CMD_REGISTRY_FILENAME_COMPLETION, NULL, &type, (LPBYTE)&func->dwFilenameCompletion, &size) == ERROR_SUCCESS;
}

bool CConRegistry::WriteCmdFunctions(const CmdExeFunctions* func)
{
    return RegSetValueEx(m_cmdKey, CMD_REGISTRY_FILENAME_COMPLETION, 0, REG_DWORD, (LPBYTE)&func->dwFilenameCompletion, sizeof func->dwFilenameCompletion) == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\keydef.h ===
//
// keyDef.h
//


#ifndef KEYDEF_H
#define KEYDEF_H

extern const ExtKeyDef gaDefaultKeyDef['Z' - 'A' + 1];
extern const ExtKeyDef gaDefaultKeyDef2['Z' - 'A' + 1];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\stdafx.cpp ===
// stdafx.cpp : WCN[ht@C‹ÇﬁÉ\[X t@C
//  custcon.pch : vRpCœÉwb_[
//  stdafx.obj : vRpCœÉ^Cv

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\stdafx.h ===
//////////////////////////////////////////////////////////////////////
// stdafx.h : WÃÉVXe CN[h t@CA
//            ‹ÇÕéQ∆âÒêîÇA¬Ç‹ÇœçX»Ç
//            vWFNgpÃÉCN[h t@CLq‹ÇB
//

#if !defined(AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Windows wb_[w«égp»ÇX^btO‹ÇB

#include <afxwin.h>         // MFC ÃÉRA—ïWR|[lg
#include <afxext.h>         // MFC Ãäg
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC  Windows R Rg[ T|[g
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "winconp.h"

#ifndef array_size
#define array_size(x)   (sizeof(x) / sizeof(x[0]))
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio ÕëOsÃíO…í«âÃêÈåæ}‹ÇB

#endif // !defined(AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\custcon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by custcon.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CUSTCON_FORM                101
#define IDD_CUSTCON_DIALOG              102
#define IDD_CUSTCON_FORM1               102
#define IDS_VERSION_TEMPLATE            102
#define IDD_CUSTCON_DIALOG1             103
#define IDP_FAILED_TO_OPEN_REGISTRY     103
#define IDD_CUSTCON_DIALOG2             104
#define IDD_CUSTCON_DIALOG_FULLOPEN     104
#define IDD_CUSTCON_DIALOG3             105
#define IDR_MAINFRAME                   128
#define IDR_CUSTCOTYPE                  129
#define IDD_DIALOG1                     129
#define IDD_DIALOG2                     130
#define IDC_ENABLE_ESC                  1000
#define IDC_ENABLE_END                  1001
#define IDC_ENABLE_HOME                 1002
#define IDC_ENABLE_LEFT                 1003
#define IDC_ENABLE_UP                   1004
#define IDC_ENABLE_RIGHT                1005
#define IDC_ENABLE_DOWN                 1006
#define IDC_ENABLE_DELETE               1007
#define IDC_ENABLE_F8                   1008
#define IDC_ENABLE_CTRL_LEFT            1009
#define IDC_ENABLE_CTRL_RIGHT           1010
#define IDC_ENABLE_DELETE_EOL           1011
#define IDC_ENABLE_DELETE_WORD_FWD      1012
#define IDC_ENABLE_DELETE_WORD_BWD      1013
#define IDC_APPLY                       1015
#define IDC_DEFAULT_VALUE               1016
#define IDC_USE_EXTENDED_EDIT_KEY       1017
#define IDC_CHECK1                      1020
#define IDC_CHECK2                      1021
#define IDC_RESET                       1021
#define IDC_CHECK3                      1022
#define IDC_MAIN_TITLE                  1022
#define IDC_CHECK4                      1023
#define IDC_CHECK5                      1024
#define IDC_CHECK6                      1025
#define IDC_CHECK7                      1026
#define IDC_CHECK8                      1027
#define IDC_CHECK9                      1028
#define IDC_CHECK10                     1029
#define IDC_CHECK11                     1030
#define IDC_CHECK12                     1031
#define IDC_CHECK13                     1032
#define IDC_CHECK14                     1033
#define IDC_CHECK15                     1034
#define IDC_CHECK16                     1035
#define IDC_CHECK17                     1036
#define IDC_CHECK18                     1037
#define IDC_CHECK19                     1038
#define IDC_CHECK20                     1039
#define IDC_CHECK21                     1040
#define IDC_CHECK22                     1041
#define IDC_CHECK23                     1042
#define IDC_CHECK24                     1043
#define IDC_CHECK25                     1044
#define IDC_ESC                         2000
#define IDC_END                         2001
#define IDC_HOME                        2002
#define IDC_LEFT                        2003
#define IDC_UP                          2004
#define IDC_RIGHT                       2005
#define IDC_DOWN                        2006
#define IDC_DELETE                      2007
#define IDC_F8                          2008
#define IDC_CTRL_LEFT                   2009
#define IDC_CTRL_RIGHT                  2010
#define IDC_DELETE_EOL                  2011
#define IDC_DELETE_WORD_FWD             2012
#define IDC_DELETE_WORD_BWD             2013
#define IDC_PAUSE                       2014
#define IDC_ALT_END                     3001
#define IDC_ALT_HOME                    3002
#define IDC_ALT_LEFT                    3003
#define IDC_ALT_RIGHT                   3005
#define IDC_ALT_CTRL_LEFT               3009
#define IDC_ALT_CTRL_RIGHT              3010
#define IDC_WORD_DELIM                  4000
#define IDC_TRIM_LEADING_ZEROS          4001
#define IDC_A                           5000
#define IDC_B                           5001
#define IDC_C                           5002
#define IDC_D                           5003
#define IDC_E                           5004
#define IDC_F                           5005
#define IDC_G                           5006
#define IDC_H                           5007
#define IDC_I                           5008
#define IDC_J                           5009
#define IDC_K                           5010
#define IDC_L                           5011
#define IDC_M                           5012
#define IDC_N                           5013
#define IDC_O                           5014
#define IDC_P                           5015
#define IDC_Q                           5016
#define IDC_R                           5017
#define IDC_S                           5018
#define IDC_T                           5019
#define IDC_U                           5020
#define IDC_V                           5021
#define IDC_W                           5022
#define IDC_X                           5023
#define IDC_Y                           5024
#define IDC_Z                           5025
#define IDC_CTRL_A                      6000
#define IDC_CTRL_B                      6001
#define IDC_CTRL_C                      6002
#define IDC_CTRL_D                      6003
#define IDC_CTRL_E                      6004
#define IDC_CTRL_F                      6005
#define IDC_CTRL_G                      6006
#define IDC_CTRL_H                      6007
#define IDC_CTRL_I                      6008
#define IDC_CTRL_J                      6009
#define IDC_CTRL_K                      6010
#define IDC_CTRL_L                      6011
#define IDC_CTRL_M                      6012
#define IDC_CTRL_N                      6013
#define IDC_CTRL_O                      6014
#define IDC_CTRL_P                      6015
#define IDC_CTRL_Q                      6016
#define IDC_CTRL_R                      6017
#define IDC_CTRL_S                      6018
#define IDC_CTRL_T                      6019
#define IDC_CTRL_U                      6020
#define IDC_CTRL_V                      6021
#define IDC_CTRL_W                      6022
#define IDC_CTRL_X                      6023
#define IDC_CTRL_Y                      6024
#define IDC_CTRL_Z                      6025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbmon\dbmon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbmon.c

Abstract:

    A simple program to print strings passed to OutputDebugString when
    the app printing the strings is not being debugged.

Author:

    Kent Forschmiedt (kentf) 30-Sep-1994

Revision History:

--*/
#define UNICODE
#define _UNICODE
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int _cdecl
wmain(
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HANDLE AckEvent;
    HANDLE ReadyEvent;
    HANDLE SharedFile;
    LPVOID SharedMem;
    LPSTR  String;
    DWORD  ret;
    DWORD  LastPid;
    LPDWORD pThisPid;
    BOOL    DidCR;

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = &sd;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        fwprintf(stderr,L"unable to InitializeSecurityDescriptor, err == %d\n",
            GetLastError());
        exit(1);
    }

    if(!SetSecurityDescriptorDacl(&sd, TRUE, (PACL)NULL, FALSE)) {
        fwprintf(stderr,L"unable to SetSecurityDescriptorDacl, err == %d\n",
            GetLastError());
        exit(1);
    }

    AckEvent = CreateEvent(&sa, FALSE, FALSE, L"DBWIN_BUFFER_READY");

    if (!AckEvent) {
        fwprintf(stderr,
                L"dbmon: Unable to create synchronization object, err == %d\n",
                GetLastError());
        exit(1);
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        fputws(L"dbmon: already running\n", stderr);
        exit(1);
    }

    ReadyEvent = CreateEvent(&sa, FALSE, FALSE, L"DBWIN_DATA_READY");

    if (!ReadyEvent) {
        fwprintf(stderr,
                L"dbmon: Unable to create synchronization object, err == %d\n",
                GetLastError());
        exit(1);
    }

    SharedFile = CreateFileMapping(
                        (HANDLE)-1,
                        &sa,
                        PAGE_READWRITE,
                        0,
                        4096,
                        L"DBWIN_BUFFER");

    if (!SharedFile) {
        fwprintf(stderr,
                L"dbmon: Unable to create file mapping object, err == %d\n",
                GetLastError());
        exit(1);
    }

    SharedMem = MapViewOfFile(
                        SharedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        512);

    if (!SharedMem) {
        fwprintf(stderr,
                L"dbmon: Unable to map shared memory, err == %d\n",
                GetLastError());
        exit(1);
    }

    String = (LPSTR)SharedMem + sizeof(DWORD);
    pThisPid = SharedMem;

    LastPid = 0xffffffff;
    DidCR = TRUE;

    SetEvent(AckEvent);

    for (;;) {

        ret = WaitForSingleObject(ReadyEvent, INFINITE);

        if (ret != WAIT_OBJECT_0) {

            fwprintf(stderr, L"dbmon: wait failed; err == %d\n", GetLastError());
            exit(1);

        } else {

            if (LastPid != *pThisPid) {
                LastPid = *pThisPid;
                if (!DidCR) {
                    putchar('\n');
                    DidCR = TRUE;
                }
            }

            if (DidCR) {
                printf("%3u: ", LastPid);
            }

            fputs(String, stdout);
            DidCR = (*String && (String[strlen(String) - 1] == '\n'));
            SetEvent(AckEvent);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbwin32\dbdbg32.cpp ===
#include <windows.h>
#include <malloc.h>
#include <stddef.h>
#include <process.h>
#define _DBDBG32_
#include "dbwin32.h"

ProcessList::ProcessList() : GrowableList(sizeof(ProcessInfo))
{
}

ProcessList::~ProcessList()
{
}

BOOL ProcessList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, sizeof(DWORD)));
}

ThreadList::ThreadList() : GrowableList(sizeof(ThreadInfo))
{
}

ThreadList::~ThreadList()
{
}

BOOL ThreadList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, sizeof(ThreadInfo)));
}

DllList::DllList() : GrowableList(sizeof(DllInfo))
{
}

DllList::~DllList()
{
}

BOOL DllList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, (sizeof(DWORD) + sizeof(LPVOID))));
}

void __cdecl AttachThread(void *pv)
{
	AttachInfo *pai = (AttachInfo *)pv;

	if (DebugActiveProcess(pai->dwProcess))
		DebugThread(pai->hwndFrame, pai->dwProcess);
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(pai->hwndFrame, "Unable to attach to process.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	delete pai;
}

void __cdecl ExecThread(void *pv)
{
	ExecInfo *pei = (ExecInfo *)pv;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.wShowWindow = SW_SHOWDEFAULT;
	pi.hProcess = NULL;
	if (CreateProcess(NULL, pei->lpszCommandLine, NULL, NULL, TRUE,
			DEBUG_PROCESS | CREATE_NEW_CONSOLE,	NULL, NULL, &si, &pi))
		{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		DebugThread(pei->hwndFrame, pi.dwProcessId);
		}
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(pei->hwndFrame, "Unable to execute process.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	free((void *)(pei->lpszCommandLine));
	delete pei;
}

void __cdecl SystemThread(void *pv)
{
	BOOL fFailed = TRUE;
	DWORD dwRet;
	HANDLE hevtBuffer = NULL, hevtData = NULL;
	HANDLE hfileShared = NULL;
	HWND hwndFrame = (HWND)pv;
	LPVOID lpvBuffer = NULL;
	LPSTR lpszText = NULL;
	DEBUG_EVENT DebugEvent;

	hevtBuffer = CreateEvent(NULL, FALSE, FALSE, "DBWIN_BUFFER_READY");
	if (hevtBuffer)
		hevtData = CreateEvent(NULL, FALSE, FALSE, "DBWIN_DATA_READY");
	if (hevtBuffer && hevtData)
		hfileShared = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
				4096, "DBWIN_BUFFER");
	if (hevtBuffer && hevtData && hfileShared)
		lpvBuffer = MapViewOfFile(hfileShared, FILE_MAP_READ, 0, 0, 512);
	if (hevtBuffer && hevtData && hfileShared && lpvBuffer)
		{
		fFailed = FALSE;
		lpszText = (LPSTR)lpvBuffer + sizeof(DWORD);
		DebugEvent.dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;
		DebugEvent.dwProcessId = DebugEvent.dwThreadId = 0;
		SetEvent(hevtBuffer);
		}
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(hwndFrame, "Unable to open System Window.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	while (!fFailed)
		{
		dwRet = WaitForSingleObject(hevtData, INFINITE);
		if (dwRet != WAIT_OBJECT_0)
			{
			SendText(hwndFrame, &DebugEvent, 0,
					"--------        DbWin32 ERROR!       --------\r\n",
					DBO_OUTPUTDEBUGSTRING);
			SendText(hwndFrame, &DebugEvent, 0,
					"-------- Shutting down System Window --------\r\n",
					DBO_OUTPUTDEBUGSTRING);
			fFailed = TRUE;
			}
		else
			{
			SendText(hwndFrame, &DebugEvent, 0, lpszText,
					DBO_OUTPUTDEBUGSTRING);
			SetEvent(hevtBuffer);
			}
		}
	if (hfileShared)
		CloseHandle(hfileShared);
	if (hevtData)
		CloseHandle(hevtData);
	if (hevtBuffer)
		CloseHandle(hevtBuffer);
}

void __cdecl DebugThread(HWND hwndFrame, DWORD dwProcess)
{
    char DisplayBuffer[BUF_SIZE];
    WORD wEvent;
    DWORD dwContinue;
    SIZE_T dwRead;
    ProcessList pl;
    ProcessInfo pi;
    ThreadList tl;
    ThreadInfo ti;
    DllList dl;
    DllInfo di;
    int iItem;
    BOOL fDone = FALSE;
    DEBUG_EVENT DebugEvent;
    EXCEPTION_DEBUG_INFO *pException = &DebugEvent.u.Exception;
    CREATE_THREAD_DEBUG_INFO *pCreateThread = &DebugEvent.u.CreateThread;
    CREATE_PROCESS_DEBUG_INFO *pCreateProcessInfo = &DebugEvent.u.CreateProcessInfo;
    EXIT_THREAD_DEBUG_INFO *pExitThread = &DebugEvent.u.ExitThread;
    EXIT_PROCESS_DEBUG_INFO *pExitProcess = &DebugEvent.u.ExitProcess;
    LOAD_DLL_DEBUG_INFO *pLoadDll = &DebugEvent.u.LoadDll;
    UNLOAD_DLL_DEBUG_INFO *pUnloadDll = &DebugEvent.u.UnloadDll;
    OUTPUT_DEBUG_STRING_INFO *pDebugString = &DebugEvent.u.DebugString;
    RIP_INFO *pRipInfo = &DebugEvent.u.RipInfo;

    while (!fDone && WaitForDebugEvent(&DebugEvent, INFINITE))
    {
        *DisplayBuffer = '\0';
        dwContinue = DBG_CONTINUE;
        switch (DebugEvent.dwDebugEventCode)
        {
        case EXCEPTION_DEBUG_EVENT:
            ProcessExceptionEvent(pException, DisplayBuffer);
            if (pException->ExceptionRecord.ExceptionCode !=
                    EXCEPTION_BREAKPOINT)
            {
                dwContinue = DBG_EXCEPTION_NOT_HANDLED;
            }
            wEvent = DBO_EXCEPTIONS;
            break;
        case CREATE_THREAD_DEBUG_EVENT:
            ti.dwProcess = DebugEvent.dwProcessId;
            ti.dwThread = DebugEvent.dwThreadId;
            tl.InsertItem(&ti);
            wsprintf(DisplayBuffer, "Create Thread: PID 0x%X - TID 0x%X\r\n",
                     ti.dwProcess, ti.dwThread);
            wEvent = DBO_THREADCREATE;
            break;
        case CREATE_PROCESS_DEBUG_EVENT:
            ti.dwProcess = pi.dwProcess = DebugEvent.dwProcessId;
            ti.dwThread = DebugEvent.dwThreadId;
            tl.InsertItem(&ti);
            pi.hProcess = pCreateProcessInfo->hProcess;
            GetModuleName(pCreateProcessInfo->hFile, pi.hProcess,
                            (DWORD_PTR)pCreateProcessInfo->lpBaseOfImage, pi.rgchModule);
            pl.InsertItem(&pi);
            wsprintf(DisplayBuffer, "Create Process: PID 0x%X - %s\r\n",
                            pi.dwProcess, pi.rgchModule);
            wEvent = DBO_PROCESSCREATE;
            break;
        case EXIT_THREAD_DEBUG_EVENT:
            ti.dwProcess = DebugEvent.dwProcessId;
            ti.dwThread = DebugEvent.dwThreadId;
            tl.RemoveItem(&ti);
            wsprintf(DisplayBuffer, "Exit Thread: PID 0x%X - TID 0x%X - dwReturnCode %d\r\n",
                     ti.dwProcess, ti.dwThread, pExitThread->dwExitCode);
            wEvent = DBO_THREADEXIT;
            break;
        case EXIT_PROCESS_DEBUG_EVENT:
            pi.dwProcess = DebugEvent.dwProcessId;
            if (pl.FindItem(&pi, &iItem))
            {
                pl.RemoveItem(iItem);
            }
            wsprintf(DisplayBuffer, "Exit Process: PID 0x%X - %s - dwReturnCode %d\r\n",
                     pi.dwProcess, pi.rgchModule, pExitProcess->dwExitCode);
            if (pi.dwProcess == dwProcess)
            {
                fDone = TRUE;
            }
            wEvent = DBO_PROCESSEXIT;
            break;
        case LOAD_DLL_DEBUG_EVENT:
            di.dwProcess = pi.dwProcess = DebugEvent.dwProcessId;
            if (pl.FindItem(&pi))
            {
                di.lpBaseOfDll = pLoadDll->lpBaseOfDll;
                GetModuleName(pLoadDll->hFile, pi.hProcess, (DWORD_PTR)di.lpBaseOfDll,
                              di.rgchModule);
                dl.InsertItem(&di);
                wsprintf(DisplayBuffer, "DLL Load: %s\r\n", di.rgchModule);
                wEvent = DBO_DLLLOAD;
            }
            break;
        case UNLOAD_DLL_DEBUG_EVENT:
            di.dwProcess = DebugEvent.dwProcessId;
            di.lpBaseOfDll = pUnloadDll->lpBaseOfDll;
            if (dl.FindItem(&di, &iItem))
            {
                dl.RemoveItem(iItem);
            }
            wsprintf(DisplayBuffer, "Dll Unload: %s\r\n", di.rgchModule);
            wEvent = DBO_DLLUNLOAD;
            break;
        case OUTPUT_DEBUG_STRING_EVENT:
            pi.dwProcess = DebugEvent.dwProcessId;
            if (!pl.FindItem(&pi) ||
               (!ReadProcessMemory(pi.hProcess,
                            pDebugString->lpDebugStringData, DisplayBuffer,
                            pDebugString->nDebugStringLength, &dwRead)))
            {
                dwRead = 0;
            }
            DisplayBuffer[dwRead] = '\0';
            wEvent = DBO_OUTPUTDEBUGSTRING;
            break;
        case RIP_EVENT:
            wsprintf(DisplayBuffer, "RIP: dwError %d - dwType %d\r\n",
                            pRipInfo->dwError, pRipInfo->dwType);
            wEvent = DBO_RIP;
            break;
        // No events should reach here.
        default:
            wsprintf(DisplayBuffer, "Unknown Event: 0x%X\r\n",
                            DebugEvent.dwDebugEventCode);
            wEvent = DBO_ALL;
            break;
        }

        if (*DisplayBuffer)
                SendText(hwndFrame, &DebugEvent, dwProcess, DisplayBuffer, wEvent);
        if (DebugEvent.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
                PostMessage(hwndFrame, WM_ENDTHREAD, (WPARAM)ti.dwThread,
                                ti.dwProcess);
        if (DebugEvent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
                {
                if (fDone)
                        {
                        for (iItem = tl.Count(); iItem > 0; iItem--)
                                {
                                tl.GetItem(iItem - 1, &ti);
                                PostMessage(hwndFrame, WM_ENDTHREAD, (WPARAM)ti.dwThread, ti.dwProcess);
                                }
                        for (iItem = pl.Count(); iItem > 0; iItem--)
                                {
                                pl.GetItem(iItem - 1, &pi);
                                PostMessage(hwndFrame, WM_ENDTHREAD, 0, pi.dwProcess);
                                }
                        }
                PostMessage(hwndFrame, WM_ENDTHREAD, 0, DebugEvent.dwProcessId);
                }
        ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinue);
    }
}

void SendText(HWND hwndFrame, DEBUG_EVENT *pDebugEvent, DWORD dwParentProcess,
		LPCSTR lpszText, WORD wEvent)
{
    char rgchText[BUF_SIZE], *pch = rgchText;
    StringInfo *psi;

    psi = new StringInfo;
    // Niceify the text
    if (pDebugEvent->dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
    {
        psi->cLines = 0;
        while (*lpszText != '\0')
        {
            if ((*lpszText == 0x0d) || (*lpszText == 0x0a))
            {
                *pch++ = 0x0d;
                *pch++ = 0x0a;
                while ((*lpszText == 0x0d) || (*lpszText == 0x0a))
                        lpszText++;
                psi->cLines++;
            }
            else
            {
                *pch++ = *lpszText++;
            }
        }
        *pch = '\0';
        psi->lpszText = _strdup(rgchText);
    }
    else
    {
        psi->cLines = 1;
        psi->lpszText = _strdup(lpszText);
    }
    psi->dwProcess = pDebugEvent->dwProcessId;
    psi->dwThread = pDebugEvent->dwThreadId;
    psi->dwParentProcess = dwParentProcess;
    PostMessage(hwndFrame, WM_SENDTEXT, wEvent, (LPARAM)psi);
}

void ProcessExceptionEvent(EXCEPTION_DEBUG_INFO *pException, LPSTR lpszBuf)
{
	if (pException->dwFirstChance)
		strcpy(lpszBuf, "First");
	else
		strcpy(lpszBuf, "Second");
	strcat(lpszBuf, " chance exception: ");
	switch (pException->ExceptionRecord.ExceptionCode)
		{
	//--standard exceptions
	case EXCEPTION_ACCESS_VIOLATION:
		strcat(lpszBuf, "Access Violation");
		break;
	case EXCEPTION_DATATYPE_MISALIGNMENT:
		strcat(lpszBuf, "Datatype Misalignment");
		break;
	case EXCEPTION_BREAKPOINT:
		strcat(lpszBuf, "Breakpoint");
		break;
	case EXCEPTION_SINGLE_STEP:
		strcat(lpszBuf, "Single Step");
		break;
	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
		strcat(lpszBuf, "Array Bound Exceeded");
		break;
	case EXCEPTION_FLT_DENORMAL_OPERAND:
		strcat(lpszBuf, "FP-Denormal Operand");
		break;
	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
		strcat(lpszBuf, "FP-Divide By Zero");
		break;
	case EXCEPTION_FLT_INEXACT_RESULT:
		strcat(lpszBuf, "FP-Inexact Result");
		break;
	case EXCEPTION_FLT_INVALID_OPERATION:
		strcat(lpszBuf, "FP-Invalid Operation");
		break;
	case EXCEPTION_FLT_OVERFLOW:
		strcat(lpszBuf, "FP-Overflow");
		break;
	case EXCEPTION_FLT_STACK_CHECK:
		strcat(lpszBuf, "FP-Stack Check");
		break;
	case EXCEPTION_FLT_UNDERFLOW:
		strcat(lpszBuf, "FP-Underflow");
		break;
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
		strcat(lpszBuf, "INT-Divide By Zero");
		break;
	case EXCEPTION_INT_OVERFLOW:
		strcat(lpszBuf, "INT-Overflow");
		break;
	case EXCEPTION_PRIV_INSTRUCTION:
		strcat(lpszBuf, "Privileged Instruction");
		break;
	case EXCEPTION_IN_PAGE_ERROR:
		strcat(lpszBuf, "In Page Error");
		break;
	//-- Debug exceptions
	case DBG_TERMINATE_THREAD:
		strcat(lpszBuf, "DBG-Terminate Thread");
		break;
	case DBG_TERMINATE_PROCESS:
		strcat(lpszBuf, "DBG-Terminate Process");
		break;
	case DBG_CONTROL_C:
		strcat(lpszBuf, "DBG-Control+C");
		break;
	case DBG_CONTROL_BREAK:
		strcat(lpszBuf, "DBG-Control+Break");
		break;
	//-- RPC exceptions (some)
	case RPC_S_UNKNOWN_IF:
		strcat(lpszBuf, "RPC-Unknown Interface");
		break;
	case RPC_S_SERVER_UNAVAILABLE:
		strcat(lpszBuf, "RPC-Server Unavailable");
		break;
	//-- VDM exceptions (minimal information)
	case EXCEPTION_VDM_EVENT:  // see dbwin32.h for definition
		strcat(lpszBuf, "VDM");
		break;
	default:
		char rgchTmp[25];
		wsprintf(rgchTmp, "Unknown-[0x%X]", pException->ExceptionRecord.ExceptionCode);
		strcat(lpszBuf, rgchTmp);
		break;
		}
	strcat(lpszBuf, "\r\n");
}

#define IMAGE_SECOND_HEADER_OFFSET (15 * sizeof(ULONG))
#define IMAGE_EXPORT_TABLE_RVA_OFFSET (30 * sizeof(DWORD))
#define IMAGE_NAME_RVA_OFFSET offsetof(IMAGE_EXPORT_DIRECTORY, Name)

void GetModuleName(HANDLE hFile, HANDLE hProcess, DWORD_PTR BaseOfImage, LPSTR lpszBuf)
{
    DWORD dwRead = 0;
    WORD DosSignature;
    DWORD NtSignature, PeHeader, ExportTableRVA, NameRVA;

    strcpy(lpszBuf, "<unknown>");
    if (!hFile)
        return;
    if (GetFileType(hFile) != FILE_TYPE_DISK)
        return;
    SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &DosSignature, sizeof(DosSignature), &dwRead, NULL))
        return;
    if (DosSignature != IMAGE_DOS_SIGNATURE)
        return;
    SetFilePointer(hFile, IMAGE_SECOND_HEADER_OFFSET, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &PeHeader, sizeof(PeHeader), &dwRead, NULL))
        return;
    SetFilePointer(hFile, PeHeader, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &NtSignature, sizeof(NtSignature), &dwRead, NULL))
        return;
    if (NtSignature != IMAGE_NT_SIGNATURE)
            return;
    SetFilePointer(hFile, PeHeader + IMAGE_EXPORT_TABLE_RVA_OFFSET, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &ExportTableRVA, sizeof(ExportTableRVA), &dwRead, NULL))
        return;
    if (!ExportTableRVA)
        return;
    ReadProcessMemory(hProcess, (LPVOID)(BaseOfImage + ExportTableRVA +
                    IMAGE_NAME_RVA_OFFSET), &NameRVA, sizeof(NameRVA), NULL);
    ReadProcessMemory(hProcess, (LPVOID)(BaseOfImage + NameRVA), lpszBuf, MODULE_SIZE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbwin32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dbwin32.rc
//
#define IDR_MAIN                        1000
#define CMD_FILERUN                     1001
#define CMD_FILEATTACH                  1002
#define CMD_FILESYSTEM					1003
#define CMD_FILEEXIT                    1004
#define CMD_OPTIONS                     1101
#define CMD_ABOUT                       1201
#define IDR_CHILD                       2000
#define CMD_FILESAVEBUFFER              2001
#define CMD_EDITCOPY                    2101
#define CMD_EDITCLEARBUFFER             2102
#define CMD_EDITSELECTALL               2103
#define IDR_ABOUTDLG                    3000
#define IDR_ATTACHDLG                   4000
#define IDC_PROCESS                     4001
#define IDR_RUNDLG                      5000
#define IDC_COMMANDLINE                 5001
#define IDC_BROWSE						5002
#define IDR_OPTIONSDLG                  6000
#define IDC_ONTOP                       6001
#define IDC_MINIMIZE                    6002
#define IDC_NONE                        6003
#define IDC_CLOSE                       6004
#define IDC_NEWPROCESS                  6005
#define IDC_NEWTHREAD                   6006
#define IDC_FILTER_OUTPUT               6007
#define IDC_FILTER_EXCEPTIONS           6008
#define IDC_FILTER_PROCESSCREATE        6009
#define IDC_FILTER_PROCESSEXIT          6010
#define IDC_FILTER_THREADCREATE         6011
#define IDC_FILTER_THREADEXIT           6012
#define IDC_FILTER_DLLLOAD              6013
#define IDC_FILTER_DLLUNLOAD            6014
#define IDC_FILTER_RIP                  6015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         112
#define _APS_NEXT_CONTROL_VALUE         6032
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbwin32\dbwin32.h ===
#define INITIAL_LIST_SIZE 32
#define LIST_CHUNK_SIZE 10

#define WM_SENDTEXT WM_USER
#define WM_ENDTHREAD (WM_USER+1)

#define DBO_OUTPUTDEBUGSTRING	0x0001
#define DBO_EXCEPTIONS			0x0002
#define DBO_PROCESSCREATE		0x0004
#define DBO_PROCESSEXIT			0x0008
#define DBO_THREADCREATE		0x0010
#define DBO_THREADEXIT			0x0020
#define DBO_DLLLOAD				0x0040
#define DBO_DLLUNLOAD			0x0080
#define DBO_RIP					0x0100
#define DBO_ALL					0xFFFF

struct AttachInfo
{
	DWORD dwProcess;
	HWND hwndFrame;
};

struct ExecInfo
{
	LPSTR lpszCommandLine;
	HWND hwndFrame;
};

struct SystemWindowInfo
{
	HWND hwndFrame;
};

struct StringInfo
{
	DWORD dwProcess;
	DWORD dwThread;
	DWORD dwParentProcess;
	LPCSTR lpszText;
	int cLines;
};

class GrowableList
{
public:
	GrowableList(int cbSizeIn);
	virtual ~GrowableList();

	int Count();
	BOOL FindItem(void *pvFind, int *piFound = NULL);
	void GetItem(int iItem, void *pvItem);
	void InsertItem(void *pvItem);
	void RemoveItem(void *pvItem);
	void RemoveItem(int iItem);

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2) = 0;

	int cbSize;
	int cItemsCur;
	int cItemsMax;
	void *pvData;
};

void __cdecl AttachThread(void *pv);
void __cdecl ExecThread(void *pv);
void __cdecl SystemThread(void *pv);

#ifdef _DBDBG32_

#define EXCEPTION_VDM_EVENT 0x40000005L

#define BUF_SIZE 1024
#define MODULE_SIZE 32

struct ProcessInfo
{
	DWORD dwProcess;
	HANDLE hProcess;
	char rgchModule[MODULE_SIZE];
};

class ProcessList : public GrowableList
{
public:
	ProcessList();
	~ProcessList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

struct ThreadInfo
{
	DWORD dwProcess;
	DWORD dwThread;
};

class ThreadList : public GrowableList
{
public:
	ThreadList();
	~ThreadList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

struct DllInfo
{
	DWORD dwProcess;
	LPVOID lpBaseOfDll;
	char rgchModule[MODULE_SIZE];
};

class DllList : public GrowableList
{
public:
	DllList();
	~DllList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

void __cdecl DebugThread(HWND hwndFrame, DWORD dwProcess);
void SendText(HWND hwndFrame, DEBUG_EVENT *pDebugEvent, DWORD dwParentProcess,
		LPCSTR lpszText, WORD wEvent);

void ProcessExceptionEvent(EXCEPTION_DEBUG_INFO *pException, LPSTR lpszBuf);

void GetModuleName(HANDLE hFile, HANDLE hProcess, DWORD_PTR BaseOfImage, LPSTR lpszBuf);

#endif	// _DBDBG32_

#ifdef _DBWIN32_

#define MAX_LINES 500

#define MAX_HISTORY 5

#define INACTIVE_MINIMIZE 0
#define INACTIVE_NONE 1
#define INACTIVE_CLOSE 2

struct DbWin32Options
{
	RECT rcWindow;
	int nShowCmd;
	BOOL fOnTop;
	BOOL fChildMax;
	int nInactive;
	BOOL fNewOnProcess;
	BOOL fNewOnThread;
	WORD wFilter;
	CString rgstCommandLine[MAX_HISTORY];
};

class DbWin32Child;

struct WindowInfo
{
	DWORD dwProcess;
	DWORD dwThread;
	DbWin32Child *pwndChild;
};

class WindowList : public GrowableList
{
public:
	WindowList();
	~WindowList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

class DbWin32App : public CWinApp
{
public:
	DbWin32App();
	~DbWin32App();

	void ReadOptions();
	void WriteOptions(WINDOWPLACEMENT *pwpl);

protected:
	virtual BOOL InitInstance();

	DbWin32Options dbo;
};

class DbWin32Edit : public CEdit
{
public:
	DbWin32Edit();
	~DbWin32Edit();

	BOOL Create(CWnd *pwndParent);
};

class DbWin32Child : public CMDIChildWnd
{
public:
	DbWin32Child(WORD wFilterIn);
	~DbWin32Child();

	void AddText(WORD wEvent, LPCSTR lpszText, int cLines, BOOL fSetTitle);

protected:
	DbWin32Edit wndEdit;
	CFont fontCur;
	WORD wFilter;

private:
	// Windows messages
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd *pwndActivate, CWnd *pwndDeactivate);
	afx_msg BOOL OnNcActivate(BOOL bActivate);
	// Command handlers
	afx_msg void OnFileSaveBuffer();
	afx_msg void OnEditCopy();
	afx_msg void OnEditClearBuffer();
	afx_msg void OnEditSelectAll();
	// Idle update handlers
	// Notification messages
	afx_msg void OnMaxText();
	DECLARE_MESSAGE_MAP()
};

class DbWin32Frame : public CMDIFrameWnd
{
public:
	DbWin32Frame(DbWin32Options *pdbo);
	~DbWin32Frame();

	void ExecProcess(LPCSTR lpszCommandLine);

	void ChildMaximized(BOOL fMax);

	void FileSystem();

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT &cs);

	WindowList wl;
	DbWin32Child *pwndSystem;
	DbWin32Options *pdbo;
	BOOL fInCreate;
	BOOL fNT351;

private:
	// Windows messages
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSendText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnEndThread(WPARAM wParam, LPARAM lParam);
	// Command handlers
	afx_msg void OnFileRun();
	afx_msg void OnFileAttach();
	afx_msg void OnFileSystem();
	afx_msg void OnFileExit();
	afx_msg void OnOptions();
	afx_msg void OnAbout();
	// Idle update handlers
	afx_msg void OnUpdateFileSystem(CCmdUI *pCmdUI);
	DECLARE_MESSAGE_MAP()
};

class DbWin32RunDlg : public CDialog
{
public:
	DbWin32RunDlg(CString *pstIn);
	~DbWin32RunDlg();

	CString &GetCommandLine();

protected:
	virtual BOOL OnInitDialog();

	CString *pst;
	CString stCommandLine;

private:
	// Windows messages
	afx_msg void OnEditChange();
	afx_msg void OnSelChange();
	afx_msg void OnBrowse();
	// Command handlers
	// Idle update handlers
	DECLARE_MESSAGE_MAP()
};

class DbWin32AttachDlg : public CDialog
{
public:
	DbWin32AttachDlg(WindowList *pwlIn);
	~DbWin32AttachDlg();

	DWORD GetSelectedProcess();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	WindowList *pwl;
	DWORD dwProcess;

private:
	// Windows messages
	afx_msg void OnDoubleClick();
	// Command handlers
	// Idle update handlers
	DECLARE_MESSAGE_MAP()
};

class DbWin32OptionsDlg : public CDialog
{
public:
	DbWin32OptionsDlg(DbWin32Options *pdboIn);
	~DbWin32OptionsDlg();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	DbWin32Options *pdbo;

private:
	afx_msg void OnClicked();
	DECLARE_MESSAGE_MAP()
};

inline CString &DbWin32RunDlg::GetCommandLine()
{
	return(stCommandLine);
}

inline DWORD DbWin32AttachDlg::GetSelectedProcess()
{
	return(dwProcess);
}

#endif // _DBWIN32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbwin32\dbwin32.cpp ===
#pragma warning(disable:4135)
#include <afxwin.h>
#include <afxdlgs.h>
#pragma warning(default:4135)
#include <process.h>
#include "resource.h"
#define _DBWIN32_
#include "dbwin32.h"

char szCompany[] = "Microsoft";
char szApplication[] = "DbWin32";
char szIniSection1[] = "Window";
char szIniSection2[] = "Options";
char szKey1[] = "X";
char szKey2[] = "Y";
char szKey3[] = "Width";
char szKey4[] = "Height";
char szKey5[] = "State";
char szKey6[] = "OnTop";
char szKey7[] = "ChildMaximized";
char szKey8[] = "InactiveWindows";
char szKey9[] = "NewWindowOnProcess";
char szKey10[] = "NewWindowOnThread";
char szKey11[] = "EventFilter";
char *rgpszHistoryKeys[MAX_HISTORY] = {"LastCommandLine1", "LastCommandLine2",
		"LastCommandLine3", "LastCommandLine4", "LastCommandLine5"};

GrowableList::GrowableList(int cbSizeIn)
{
	cbSize = cbSizeIn;
	cItemsCur = 0;
	cItemsMax = INITIAL_LIST_SIZE;
	pvData = malloc(cbSize * INITIAL_LIST_SIZE);
}

GrowableList::~GrowableList()
{
	free(pvData);
}

int GrowableList::Count()
{
	return(cItemsCur);
}

BOOL GrowableList::FindItem(void *pvItem, int *piFound)
{
	int iItem;
	BYTE *pbItem;

	for (iItem = 0, pbItem = (BYTE *)pvData; ((iItem < cItemsCur) &&
			!IsEqual(pvItem, pbItem)); iItem++, pbItem += cbSize);
	if (iItem == cItemsCur)
		return(FALSE);
	memcpy(pvItem, pbItem, cbSize);
	if (piFound)
		*piFound = iItem;
	return(TRUE);
}

void GrowableList::GetItem(int iItem, void *pvItem)
{
	BYTE *pbItem = (BYTE *)pvData;

	pbItem += (cbSize * iItem);
	memcpy(pvItem, pbItem, cbSize);
}

void GrowableList::InsertItem(void *pvItem)
{
    void *pvNew;
    BYTE *pbNew;

    if (!FindItem(pvItem))
    {
        if (cItemsCur == cItemsMax)
        {
            cItemsMax += LIST_CHUNK_SIZE;
            pvNew = malloc(cbSize * cItemsMax);
            if (!pvNew)
            {
                return;
            }
            memcpy(pvNew, pvData, (cbSize * (cItemsMax - LIST_CHUNK_SIZE)));
            free(pvData);
            pvData = pvNew;
        }
        pbNew = (BYTE *)pvData;
        pbNew += (cbSize * cItemsCur);
        cItemsCur++;
        memcpy(pbNew, pvItem, cbSize);
    }
}

void GrowableList::RemoveItem(void *pvItem)
{
	int iItem;

	if (FindItem(pvItem, &iItem))
		RemoveItem(iItem);
}

void GrowableList::RemoveItem(int iItem)
{
	BYTE *pbSrc, *pbDest;

	if (iItem != (cItemsCur - 1))
		{
		pbDest = (BYTE *)pvData;
		pbDest += (cbSize * iItem);
		pbSrc = pbDest + cbSize;
		memmove(pbDest, pbSrc, (cbSize * (cItemsCur - iItem - 1)));
		}
	cItemsCur--;
}

WindowList::WindowList() : GrowableList(sizeof(WindowInfo))
{
}

WindowList::~WindowList()
{
}

BOOL WindowList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, (2 * sizeof(DWORD))));
}

DbWin32App::DbWin32App()
{
}

DbWin32App::~DbWin32App()
{
}

BOOL DbWin32App::InitInstance()
{
	if (!CWinApp::InitInstance())
		return(FALSE);
	SetRegistryKey(szCompany);
	m_pszProfileName = szApplication;
	Enable3dControls();
	m_pMainWnd = new DbWin32Frame(&dbo);
	((DbWin32Frame *)m_pMainWnd)->LoadFrame(IDR_MAIN, WS_OVERLAPPEDWINDOW | WS_VISIBLE);
	if (m_lpCmdLine && *m_lpCmdLine)
		((DbWin32Frame *)m_pMainWnd)->ExecProcess(m_lpCmdLine);
	else
		((DbWin32Frame *)m_pMainWnd)->FileSystem();
	return(TRUE);
}

void DbWin32App::ReadOptions()
{
	int	wMaxWidth, wMaxHeight, iKey;

	wMaxWidth = GetSystemMetrics(SM_CXSCREEN);
	wMaxHeight = GetSystemMetrics(SM_CYSCREEN);
	dbo.rcWindow.left = GetProfileInt(szIniSection1, szKey1, wMaxWidth/5);
	dbo.rcWindow.top = GetProfileInt(szIniSection1, szKey2, wMaxHeight/5);
	dbo.rcWindow.right = GetProfileInt(szIniSection1, szKey3, wMaxWidth/2)-1;
	dbo.rcWindow.bottom = GetProfileInt(szIniSection1, szKey4, wMaxHeight/2)-1;
	if (dbo.rcWindow.right < 0)
		dbo.rcWindow.right = wMaxWidth/2;
	if (dbo.rcWindow.bottom < 0)
		dbo.rcWindow.bottom = wMaxHeight/2;
	if (dbo.rcWindow.left < 0 || dbo.rcWindow.left > wMaxWidth)
		dbo.rcWindow.left = wMaxWidth/5;
	dbo.rcWindow.right += dbo.rcWindow.left;
	if (dbo.rcWindow.right > wMaxWidth)
		dbo.rcWindow.right = wMaxWidth;
	if (dbo.rcWindow.top < 0 || dbo.rcWindow.top > wMaxHeight)
		dbo.rcWindow.top = wMaxHeight /5;
	dbo.rcWindow.bottom += dbo.rcWindow.top;
	if (dbo.rcWindow.bottom > wMaxHeight)
		dbo.rcWindow.bottom = wMaxHeight;
	dbo.nShowCmd = GetProfileInt(szIniSection1, szKey5, 0);
	if (dbo.nShowCmd < 0)
		dbo.nShowCmd = WS_MINIMIZE;
	else if (dbo.nShowCmd > 0)
		dbo.nShowCmd = WS_MAXIMIZE;
	dbo.fOnTop = GetProfileInt(szIniSection1, szKey6, FALSE);
	dbo.fChildMax = GetProfileInt(szIniSection1, szKey7, FALSE);
	dbo.nInactive = GetProfileInt(szIniSection2, szKey8, INACTIVE_MINIMIZE);
	dbo.fNewOnProcess = GetProfileInt(szIniSection2, szKey9, TRUE);
	dbo.fNewOnThread = GetProfileInt(szIniSection2, szKey10, FALSE);
	dbo.wFilter = (WORD)GetProfileInt(szIniSection2, szKey11, DBO_ALL);
	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		dbo.rgstCommandLine[iKey] = GetProfileString(szIniSection2,
				rgpszHistoryKeys[iKey]);
}

void DbWin32App::WriteOptions(WINDOWPLACEMENT *pwpl)
{
	int wState, iKey;

	if (pwpl)
		{
		if (pwpl->showCmd == SW_SHOWMAXIMIZED)
			wState = 1;
		else if (pwpl->showCmd == SW_SHOWMINIMIZED)
			wState = -1;
		else
			wState = 0;
		WriteProfileInt(szIniSection1, szKey1, (int) pwpl->rcNormalPosition.left);
		WriteProfileInt(szIniSection1, szKey2, (int) pwpl->rcNormalPosition.top);
		WriteProfileInt(szIniSection1, szKey3,
				pwpl->rcNormalPosition.right-pwpl->rcNormalPosition.left+1);
		WriteProfileInt(szIniSection1, szKey4,
				pwpl->rcNormalPosition.bottom-pwpl->rcNormalPosition.top+1);
		WriteProfileInt(szIniSection1, szKey5, wState);
		}
	WriteProfileInt(szIniSection1, szKey6, dbo.fOnTop);
	WriteProfileInt(szIniSection1, szKey7, dbo.fChildMax);
	WriteProfileInt(szIniSection2, szKey8, dbo.nInactive);
	WriteProfileInt(szIniSection2, szKey9, dbo.fNewOnProcess);
	WriteProfileInt(szIniSection2, szKey10, dbo.fNewOnThread);
	WriteProfileInt(szIniSection2, szKey11, dbo.wFilter);
	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		WriteProfileString(szIniSection2, rgpszHistoryKeys[iKey],
				dbo.rgstCommandLine[iKey]);
}

static NEAR DbWin32App theApp;

DbWin32Edit::DbWin32Edit()
{
}

DbWin32Edit::~DbWin32Edit()
{
}

BOOL DbWin32Edit::Create(CWnd *pwndParent)
{
	CRect rc;

	return(CEdit::Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL |
			WS_HSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE,
			rc, pwndParent, 100));
}

BEGIN_MESSAGE_MAP(DbWin32Child, CMDIChildWnd)
	// Windows messages
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_MDIACTIVATE()
	ON_WM_NCACTIVATE()
	// Command handlers
	ON_COMMAND(CMD_FILESAVEBUFFER, OnFileSaveBuffer)
	ON_COMMAND(CMD_EDITCOPY, OnEditCopy)
	ON_COMMAND(CMD_EDITCLEARBUFFER, OnEditClearBuffer)
	ON_COMMAND(CMD_EDITSELECTALL, OnEditSelectAll)
	// Idle update handlers
	// Notification messages
	ON_EN_MAXTEXT(100, OnMaxText)
END_MESSAGE_MAP()

DbWin32Child::DbWin32Child(WORD wFilterIn)
{
	wFilter = wFilterIn;
}

DbWin32Child::~DbWin32Child()
{
}

void DbWin32Child::AddText(WORD wEvent, LPCSTR lpszText, int cLines, BOOL fSetTitle)
{
	int cLinesNew;
	CString st;

	if (!m_hWnd)
		return;
	if (fSetTitle && !strncmp(lpszText, "Create Process", 14))
		{
		st = lpszText;
		SetWindowText(st.Mid(16, st.GetLength() - 18));
		}
	if (fSetTitle && !strncmp(lpszText, "Create Thread", 13))
		{
		st = lpszText;
		SetWindowText(st.Mid(15, st.GetLength() - 17));
		}
	if (wEvent & wFilter)
		{
		cLinesNew = wndEdit.GetLineCount() + cLines;
		if (cLinesNew > MAX_LINES)
			{
			wndEdit.SetSel(0, wndEdit.LineIndex(cLinesNew + 50 - MAX_LINES), TRUE);
			wndEdit.ReplaceSel("");
			}
		wndEdit.SetSel(0x7FFF7FFF);
		wndEdit.ReplaceSel(lpszText);
		wndEdit.SetSel(0x7FFF7FFF);
		}
}

int DbWin32Child::OnCreate(LPCREATESTRUCT lpcs)
{
	LOGFONT lf;

	if (CMDIChildWnd::OnCreate(lpcs) == -1)
		return(-1);
	m_hMenuShared = ::LoadMenu(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_CHILD));
	wndEdit.Create(this);
	SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
	fontCur.CreateFontIndirect(&lf);
	wndEdit.SetFont(&fontCur);
	wndEdit.ShowWindow(SW_SHOWNORMAL);
	return(0);
}

void DbWin32Child::OnSize(UINT nType, int cx, int cy)
{
	CRect rc;

	((DbWin32Frame *)GetMDIFrame())->ChildMaximized(nType == SIZE_MAXIMIZED);
	GetClientRect(rc);
	rc.InflateRect(1, 1);
	wndEdit.MoveWindow(rc, TRUE);
	CMDIChildWnd::OnSize(nType, cx, cy);
}

void DbWin32Child::OnMDIActivate(BOOL fActivate, CWnd *pwndActivate, CWnd *pwndDeactivate)
{
	if (fActivate)
		wndEdit.SetFocus();
	CMDIChildWnd::OnMDIActivate(fActivate, pwndActivate, pwndDeactivate);
}

BOOL DbWin32Child::OnNcActivate(BOOL fActivate)
{
	if (fActivate)
		wndEdit.SetFocus();
	return(CMDIChildWnd::OnNcActivate(fActivate));
}

void DbWin32Child::OnFileSaveBuffer()
{
	CFile file;
	int cch;
	void *pv;
	CFileDialog dlgFile(FALSE, NULL, NULL, OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY |
			OFN_PATHMUSTEXIST, "All|*.*||", GetMDIFrame());

	if (dlgFile.DoModal() == IDOK)
		if (file.Open(dlgFile.GetPathName(), CFile::modeCreate | CFile::modeWrite))
			{
			cch = wndEdit.GetWindowTextLength();
			if (cch)
				{
				pv = GlobalAlloc(GMEM_FIXED, cch + 1);
				if (pv)
					{
					cch = wndEdit.GetWindowText((LPTSTR)pv, cch + 1);
					file.Write(pv, cch);
					file.Close();
					GlobalFree(pv);
					}
				}
			}
}

void DbWin32Child::OnEditCopy()
{
	wndEdit.Copy();
}

void DbWin32Child::OnEditClearBuffer()
{
	OnEditSelectAll();
	wndEdit.ReplaceSel("");
}

void DbWin32Child::OnEditSelectAll()
{
	wndEdit.SetSel(0, -1, FALSE);
}

void DbWin32Child::OnMaxText()
{
	MessageBox("Help! I'm out of space!", "DbWin32", MB_ICONEXCLAMATION | MB_OK);
}

BEGIN_MESSAGE_MAP(DbWin32Frame, CMDIFrameWnd)
	// Windows messages
	ON_WM_DESTROY()
	ON_MESSAGE(WM_SENDTEXT, OnSendText)
	ON_MESSAGE(WM_ENDTHREAD, OnEndThread)
	// Command handlers
	ON_COMMAND(CMD_FILERUN, OnFileRun)
	ON_COMMAND(CMD_FILEATTACH, OnFileAttach)
	ON_COMMAND(CMD_FILESYSTEM, OnFileSystem)
	ON_COMMAND(CMD_FILEEXIT, OnFileExit)
	ON_COMMAND(CMD_OPTIONS, OnOptions)
	ON_COMMAND(CMD_ABOUT, OnAbout)
	// Idle update handlers
	ON_UPDATE_COMMAND_UI(CMD_FILESYSTEM, OnUpdateFileSystem)
END_MESSAGE_MAP()

DbWin32Frame::DbWin32Frame(DbWin32Options *pdboIn)
{
	OSVERSIONINFO osvi;

	pwndSystem = NULL;
	pdbo = pdboIn;
	fInCreate = FALSE;
	fNT351 = FALSE;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osvi))
		{
		if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && ((osvi.dwMajorVersion > 3) || (osvi.dwMinorVersion > 5)))
			fNT351 = TRUE;
		}
}

DbWin32Frame::~DbWin32Frame()
{
}

void DbWin32Frame::ExecProcess(LPCSTR lpszCommandLine)
{
	int iKey;
	ExecInfo *pei;

	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		if (pdbo->rgstCommandLine[iKey] == lpszCommandLine)
			break;
	if (iKey == MAX_HISTORY)
		{
		for (iKey = MAX_HISTORY - 1; iKey > 0; iKey--)
			pdbo->rgstCommandLine[iKey] = pdbo->rgstCommandLine[iKey-1];
		pdbo->rgstCommandLine[0] = lpszCommandLine;
		}
	pei = new ExecInfo;
	pei->lpszCommandLine = _strdup(lpszCommandLine);
	pei->hwndFrame = GetSafeHwnd();
	_beginthread(ExecThread, 0, pei);
}

void DbWin32Frame::ChildMaximized(BOOL fMax)
{
	if (!fInCreate)
		pdbo->fChildMax = fMax;
}

void DbWin32Frame::FileSystem()
{
	if (fNT351)
		OnFileSystem();
}

BOOL DbWin32Frame::PreCreateWindow(CREATESTRUCT &cs)
{
	((DbWin32App *)AfxGetApp())->ReadOptions();
	cs.cy = (int)(pdbo->rcWindow.bottom - pdbo->rcWindow.top);
	cs.cx = (int)(pdbo->rcWindow.right - pdbo->rcWindow.left);
	cs.y = (int)pdbo->rcWindow.top;
	cs.x = (int)pdbo->rcWindow.left;
	cs.style |= pdbo->nShowCmd;
	if (pdbo->fOnTop)
		cs.dwExStyle |= WS_EX_TOPMOST;
	return(CMDIFrameWnd::PreCreateWindow(cs));
}

void DbWin32Frame::OnDestroy()
{
	WINDOWPLACEMENT wpl;

	wpl.length = sizeof(WINDOWPLACEMENT);
	wpl.rcNormalPosition.top = wpl.rcNormalPosition.left = 0;
	if (GetWindowPlacement(&wpl))
		((DbWin32App *)AfxGetApp())->WriteOptions(&wpl);
	else
		((DbWin32App *)AfxGetApp())->WriteOptions(NULL);
}

LRESULT DbWin32Frame::OnSendText(WPARAM wParam, LPARAM lParam)
{
	StringInfo *psi = (StringInfo *)lParam;
	WindowInfo wi;
	BOOL fCreated = FALSE;

	wi.dwProcess = psi->dwProcess;
	wi.dwThread = psi->dwThread;
	if (!wi.dwProcess && !wi.dwThread)
		wi.pwndChild = pwndSystem;
	else
		{
		wi.pwndChild = NULL;
		if (!wl.FindItem(&wi))
			if (pdbo->fNewOnThread)
				fCreated = TRUE;
			else
				{
				wi.dwThread = 0;
				if (!wl.FindItem(&wi))
					if (pdbo->fNewOnProcess)
						fCreated = TRUE;
					else
						{
						wi.dwProcess = psi->dwParentProcess;
						if (!wl.FindItem(&wi))
							fCreated = TRUE;
						}
				}
		if (fCreated)
			{
			wi.pwndChild = new DbWin32Child(pdbo->wFilter);
			fInCreate = TRUE;
			wi.pwndChild->LoadFrame(IDR_CHILD,
					WS_OVERLAPPEDWINDOW | WS_VISIBLE, this);
			fInCreate = FALSE;
			if (pdbo->fChildMax)
				MDIMaximize(wi.pwndChild);
			wl.InsertItem(&wi);
			}
		}
	ASSERT(wi.pwndChild);
	wi.pwndChild->AddText((WORD)wParam, psi->lpszText, psi->cLines, fCreated);
	free((void *)(psi->lpszText));
	delete psi;
	return(0);
}

LRESULT DbWin32Frame::OnEndThread(WPARAM wParam, LPARAM lParam)
{
	CString st;
	WindowInfo wi;
	int iItem;

	wi.dwProcess = (DWORD)lParam;
	wi.dwThread = (DWORD)wParam;
	if (wl.FindItem(&wi, &iItem))
		{
		wi.pwndChild->GetWindowText(st);
		st += " [Inactive]";
		wi.pwndChild->SetWindowText(st);
		switch (pdbo->nInactive)
			{
		case INACTIVE_CLOSE:
			wi.pwndChild->MDIDestroy();
			break;
		case INACTIVE_NONE:
			break;
		default:
			wi.pwndChild->ShowWindow(SW_MINIMIZE);
			break;
			}
		wl.RemoveItem(iItem);
		}
	return(0L);
}

void DbWin32Frame::OnFileRun()
{
	DbWin32RunDlg dlgRun(pdbo->rgstCommandLine);

	if (dlgRun.DoModal() == IDOK)
		ExecProcess(dlgRun.GetCommandLine());
}

void DbWin32Frame::OnFileAttach()
{
	AttachInfo *pai;
	DbWin32AttachDlg dlgAttach(&wl);

	if (dlgAttach.DoModal() == IDOK)
		{
		pai = new AttachInfo;
		pai->dwProcess = dlgAttach.GetSelectedProcess();
		pai->hwndFrame = GetSafeHwnd();
		_beginthread(AttachThread, 0, pai);
		}
}

void DbWin32Frame::OnFileSystem()
{
	if (!fNT351)
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox("Not available on this platform.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		return;
		}
	if (pwndSystem)
		{
		MDIActivate(pwndSystem);
		return;
		}
	pwndSystem = new DbWin32Child(DBO_OUTPUTDEBUGSTRING);
	fInCreate = TRUE;
	pwndSystem->LoadFrame(IDR_CHILD, WS_OVERLAPPEDWINDOW | WS_VISIBLE, this);
	fInCreate = FALSE;
	pwndSystem->SetWindowText("System Window");
	if (pdbo->fChildMax)
		MDIMaximize(pwndSystem);
	_beginthread(SystemThread, 0, GetSafeHwnd());
}

void DbWin32Frame::OnFileExit()
{
	OnClose();
}

void DbWin32Frame::OnOptions()
{
	DbWin32OptionsDlg dlgOptions(pdbo);

	dlgOptions.DoModal();
}

void DbWin32Frame::OnAbout()
{
	CDialog dlgAbout(IDR_ABOUTDLG);

	dlgAbout.DoModal();
}

void DbWin32Frame::OnUpdateFileSystem(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(!pwndSystem && fNT351);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dbwin32\dbdlg32.cpp ===
#pragma warning(disable:4135)
#include <afxwin.h>
#pragma warning(default:4135)
#include <afxdlgs.h>
#include "resource.h"
#define _DBWIN32_
#include "dbwin32.h"

BEGIN_MESSAGE_MAP(DbWin32RunDlg, CDialog)
	// Windows messages
	ON_CBN_EDITCHANGE(IDC_COMMANDLINE, OnEditChange)
	ON_CBN_SELCHANGE(IDC_COMMANDLINE, OnSelChange)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	// Command handlers
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32RunDlg::DbWin32RunDlg(CString *pstIn) : CDialog(IDR_RUNDLG)
{
	pst = pstIn;
}

DbWin32RunDlg::~DbWin32RunDlg()
{
}

BOOL DbWin32RunDlg::OnInitDialog()
{
	int iSt;
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);

	for (iSt = 0; iSt < MAX_HISTORY; iSt++)
		if (!pst[iSt].IsEmpty())
			pcb->AddString(pst[iSt]);
	if (pcb->GetCount())
		{
		pcb->SetCurSel(0);
		OnSelChange();
		}
	return(CDialog::OnInitDialog());
}

void DbWin32RunDlg::OnEditChange()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CButton *pbutton = (CButton *)GetDlgItem(IDOK);

	pcb->GetWindowText(stCommandLine);
	pbutton->EnableWindow(!stCommandLine.IsEmpty());
}

void DbWin32RunDlg::OnSelChange()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CButton *pbutton = (CButton *)GetDlgItem(IDOK);

	pcb->GetLBText(pcb->GetCurSel(), stCommandLine);
	pbutton->EnableWindow(!stCommandLine.IsEmpty());
}

void DbWin32RunDlg::OnBrowse()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CFileDialog fdlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
			OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST, "Executable Files|*.exe||",
			this);

	if (fdlg.DoModal() == IDOK)
		{
		pcb->SetWindowText(fdlg.GetPathName());
		OnEditChange();
		}
}

struct EnumInfo
{
	CListBox *plb;
	WindowList *pwl;
	DWORD dwProcessCur;
};

BOOL CALLBACK EnumProc(HWND hWnd, LPARAM lParam)
{
	int iItem;
	DWORD dwProcess;
	char szTitle[256];
	WindowInfo wi;
	EnumInfo *pei = (EnumInfo *)lParam;

	if (hWnd)
		{
		GetWindowText(hWnd, szTitle, sizeof(szTitle));
		if (*szTitle)
			{
			GetWindowThreadProcessId(hWnd, &dwProcess);
			if (dwProcess != pei->dwProcessCur)
				{
				wi.dwProcess = 0;
				for (iItem = 0; (iItem < pei->pwl->Count()) &&
						(wi.dwProcess != dwProcess); iItem++)
					pei->pwl->GetItem(iItem, &wi);
				if (iItem == pei->pwl->Count())
					{
					iItem = pei->plb->AddString(szTitle);
					pei->plb->SetItemData(iItem, dwProcess);
					}
				}
			}
		}
	return(TRUE);
}

BEGIN_MESSAGE_MAP(DbWin32AttachDlg, CDialog)
	// Windows messages
	ON_LBN_DBLCLK(IDC_PROCESS, OnDoubleClick)
	// Command handlers
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32AttachDlg::DbWin32AttachDlg(WindowList *pwlIn) : CDialog(IDR_ATTACHDLG)
{
	pwl = pwlIn;
}

DbWin32AttachDlg::~DbWin32AttachDlg()
{
}

BOOL DbWin32AttachDlg::OnInitDialog()
{
	EnumInfo ei;
	CListBox *plb = (CListBox *)GetDlgItem(IDC_PROCESS);

	CDialog::OnInitDialog();
	plb->ResetContent();
	ei.plb = plb;
	ei.pwl = pwl;
	ei.dwProcessCur = GetCurrentProcessId();
	EnumWindows(EnumProc, (LPARAM)&ei);
	plb->SetCurSel(0);
	return(TRUE);
}

void DbWin32AttachDlg::OnOK()
{
	CListBox *plb = (CListBox *)GetDlgItem(IDC_PROCESS);

	dwProcess = (DWORD)plb->GetItemData(plb->GetCurSel());
	CDialog::OnOK();
}

void DbWin32AttachDlg::OnDoubleClick()
{
	OnOK();
}

BEGIN_MESSAGE_MAP(DbWin32OptionsDlg, CDialog)
	// Windows messages
	// Command handlers
	ON_CONTROL(BN_CLICKED, IDC_NEWPROCESS, OnClicked)
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32OptionsDlg::DbWin32OptionsDlg(DbWin32Options *pdboIn) : CDialog(IDR_OPTIONSDLG)
{
	pdbo = pdboIn;
}

DbWin32OptionsDlg::~DbWin32OptionsDlg()
{
}

BOOL DbWin32OptionsDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	((CButton *)GetDlgItem(IDC_NEWPROCESS))->SetCheck(pdbo->fNewOnProcess ? 1 : 0);
	((CButton *)GetDlgItem(IDC_NEWTHREAD))->SetCheck(pdbo->fNewOnThread ? 1 : 0);
	GetDlgItem(IDC_NEWTHREAD)->EnableWindow(pdbo->fNewOnProcess);
	((CButton *)GetDlgItem(IDC_ONTOP))->SetCheck(pdbo->fOnTop ? 1 : 0);
	((CButton *)GetDlgItem(IDC_MINIMIZE))->SetCheck((pdbo->nInactive == INACTIVE_MINIMIZE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_NONE))->SetCheck((pdbo->nInactive == INACTIVE_NONE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_CLOSE))->SetCheck((pdbo->nInactive == INACTIVE_CLOSE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_OUTPUT))->SetCheck((pdbo->wFilter & DBO_OUTPUTDEBUGSTRING) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_EXCEPTIONS))->SetCheck((pdbo->wFilter & DBO_EXCEPTIONS) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_PROCESSCREATE))->SetCheck((pdbo->wFilter & DBO_PROCESSCREATE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_PROCESSEXIT))->SetCheck((pdbo->wFilter & DBO_PROCESSEXIT) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_THREADCREATE))->SetCheck((pdbo->wFilter & DBO_THREADCREATE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_THREADEXIT))->SetCheck((pdbo->wFilter & DBO_THREADEXIT) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_DLLLOAD))->SetCheck((pdbo->wFilter & DBO_DLLLOAD) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_DLLUNLOAD))->SetCheck((pdbo->wFilter & DBO_DLLUNLOAD) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_RIP))->SetCheck((pdbo->wFilter & DBO_RIP) ? 1 : 0);
	return(TRUE);
}

void DbWin32OptionsDlg::OnOK()
{
	pdbo->fNewOnProcess = ((CButton *)GetDlgItem(IDC_NEWPROCESS))->GetCheck();
	pdbo->fNewOnThread = ((CButton *)GetDlgItem(IDC_NEWTHREAD))->GetCheck();
	pdbo->fOnTop = ((CButton *)GetDlgItem(IDC_ONTOP))->GetCheck();
	if (((CButton *)GetDlgItem(IDC_NONE))->GetCheck())
		pdbo->nInactive = INACTIVE_NONE;
	else if (((CButton *)GetDlgItem(IDC_CLOSE))->GetCheck())
		pdbo->nInactive = INACTIVE_CLOSE;
	else
		pdbo->nInactive = INACTIVE_MINIMIZE;
	pdbo->wFilter = 0;
	if (((CButton *)GetDlgItem(IDC_FILTER_OUTPUT))->GetCheck())
		pdbo->wFilter = DBO_OUTPUTDEBUGSTRING;
	if (((CButton *)GetDlgItem(IDC_FILTER_EXCEPTIONS))->GetCheck())
		pdbo->wFilter |= DBO_EXCEPTIONS;
	if (((CButton *)GetDlgItem(IDC_FILTER_PROCESSCREATE))->GetCheck())
		pdbo->wFilter |= DBO_PROCESSCREATE;
	if (((CButton *)GetDlgItem(IDC_FILTER_PROCESSEXIT))->GetCheck())
		pdbo->wFilter |= DBO_PROCESSEXIT;
	if (((CButton *)GetDlgItem(IDC_FILTER_THREADCREATE))->GetCheck())
		pdbo->wFilter |= DBO_THREADCREATE;
	if (((CButton *)GetDlgItem(IDC_FILTER_THREADEXIT))->GetCheck())
		pdbo->wFilter |= DBO_THREADEXIT;
	if (((CButton *)GetDlgItem(IDC_FILTER_DLLLOAD))->GetCheck())
		pdbo->wFilter |= DBO_DLLLOAD;
	if (((CButton *)GetDlgItem(IDC_FILTER_DLLUNLOAD))->GetCheck())
		pdbo->wFilter |= DBO_DLLUNLOAD;
	if (((CButton *)GetDlgItem(IDC_FILTER_RIP))->GetCheck())
		pdbo->wFilter |= DBO_RIP;
	CDialog::OnOK();
}

void DbWin32OptionsDlg::OnClicked()
{
	BOOL fNewOnProcess = ((CButton *)GetDlgItem(IDC_NEWPROCESS))->GetCheck();

	((CButton *)GetDlgItem(IDC_NEWTHREAD))->SetCheck(0);
	GetDlgItem(IDC_NEWTHREAD)->EnableWindow(fNewOnProcess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\product.inc ===
C_DEFINES=$(C_DEFINES) /DNO_DEBUGGER_RPC_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\conio.cpp ===
//----------------------------------------------------------------------------
//
// Console input and output.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <stdarg.h>
#include <process.h>

#include "conio.hpp"
#include "engine.hpp"
#include "main.hpp"

#define CONTROL_A   1
#define CONTROL_B   2
#define CONTROL_D   4
#define CONTROL_E   5
#define CONTROL_F   6
#define CONTROL_K   11
#define CONTROL_P   16
#define CONTROL_R   18
#define CONTROL_V   22
#define CONTROL_W   23
#define CONTROL_X   24

HANDLE g_ConInput, g_ConOutput;
HANDLE g_PromptInput;
HANDLE g_AllowInput;

ConInputCallbacks g_ConInputCb;
ConOutputCallbacks g_ConOutputCb;

BOOL g_IoInitialized;
BOOL g_ConInitialized;
char g_Buffer[MAX_COMMAND];
LONG g_Lines;

HANDLE g_PipeWrite;
OVERLAPPED g_PipeWriteOverlapped;

CRITICAL_SECTION g_InputLock;
BOOL g_InputStarted;

// Input thread interfaces for direct input thread calls.
IDebugClient* g_ConClient;
IDebugControl* g_ConControl;

//----------------------------------------------------------------------------
//
// Default input callbacks implementation, provides IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefInputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugInputCallbacks))
    {
        *Interface = (IDebugInputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefInputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefInputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Console input callbacks.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ConInputCallbacks::StartInput(
    THIS_
    IN ULONG BufferSize
    )
{
    if (!g_IoInitialized || g_IoMode == IO_NONE)
    {
        // Ignore input requests.
        return S_OK;
    }

    EnterCriticalSection(&g_InputLock);

    if (g_ConControl == NULL)
    {
        // If we're not remoted we aren't running a separate input
        // thread so we need to block here until we get some input.
        while (!ConIn(g_Buffer, sizeof(g_Buffer), TRUE))
        {
            ; // Wait.
        }
        g_DbgControl->ReturnInput(g_Buffer);
    }
    else if (ConIn(g_Buffer, sizeof(g_Buffer), FALSE))
    {
        g_ConControl->ReturnInput(g_Buffer);
    }
    else
    {
        g_InputStarted = TRUE;
        
#ifndef KERNEL
        // Wake up the input thread if necessary.
        SetEvent(g_AllowInput);
#endif
    }

    LeaveCriticalSection(&g_InputLock);
    return S_OK;
}

STDMETHODIMP
ConInputCallbacks::EndInput(
    THIS
    )
{
    g_InputStarted = FALSE;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Console output callbacks.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ConOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    ConOutStr(Text);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Functions
//
//----------------------------------------------------------------------------

void
InitializeIo(PCSTR InputFile)
{
    __try
    {
        InitializeCriticalSection(&g_InputLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ErrorExit("Unable to initialize lock\n");
    }
    
    // The input file may not exist so there's no
    // check for failure.
    g_InputFile = fopen(InputFile, "r");

    g_IoInitialized = TRUE;
}
    
void
CreateConsole(void)
{
    if (g_ConInitialized)
    {
        return;
    }
    
    // Set this early to prevent an init call from Exit in
    // case an Exit call is made inside this routine.
    g_ConInitialized = TRUE;
    
#ifdef INHERIT_CONSOLE
    
    g_ConInput = GetStdHandle(STD_INPUT_HANDLE);
    g_ConOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    
#else

    SECURITY_ATTRIBUTES Security;
    
    if (!AllocConsole())
    {
        ErrorExit("AllocConsole failed, %d\n", GetLastError());
    }

    ZeroMemory(&Security, sizeof(Security));
    Security.nLength = sizeof(Security);
    Security.bInheritHandle = TRUE;

    g_ConInput = CreateFile( "CONIN$",
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Security,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );
    if (g_ConInput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Create CONIN$ failed, %d\n", GetLastError());
    }

    g_ConOutput = CreateFile( "CONOUT$",
                              GENERIC_WRITE | GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              &Security,
                              OPEN_EXISTING,
                              0,
                              NULL
                              );
    if (g_ConOutput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Create CONOUT$ failed, %d\n", GetLastError());
    }
    
#endif

    g_PromptInput = g_ConInput;
}

void
ReadPromptInputChars(PSTR Buffer, ULONG BufferSize)
{
    ULONG Len;
    ULONG Read;
    
    // Reading from another source.  Read character by
    // character until a line is read.
    Len = 0;
    while (Len < BufferSize)
    {
        if (!ReadFile(g_PromptInput, &Buffer[Len], sizeof(Buffer[0]),
                      &Read, NULL) ||
            Read != sizeof(Buffer[0]))
        {
            OutputDebugString("Unable to read input\n");
            ExitDebugger(E_FAIL);
        }
                
        if (Buffer[Len] == '\n')
        {
            InterlockedDecrement(&g_Lines);
            break;
        }

        // Ignore carriage returns.
        if (Buffer[Len] != '\r')
        {
            // Prevent buffer overflow.
            if (Len == BufferSize - 1)
            {
                break;
            }
                    
            Len++;
        }
    }

    Buffer[Len] = '\0';
}

BOOL
CheckForControlCommands(PDEBUG_CLIENT Client, PDEBUG_CONTROL Control,
                        char Char)
{
    HRESULT Hr;
    ULONG OutMask;
    PCHAR DebugAction;
    ULONG EngOptions;
    
    switch(Char)
    {
    case CONTROL_B:
    case CONTROL_X:
        if (Client)
        {
            // Tell server about disconnect or
            // force servers to get cleaned up.
            Client->EndSession(g_RemoteClient ?
                               DEBUG_END_DISCONNECT : DEBUG_END_REENTRANT);
        }
        ExitProcess(S_OK);

    case CONTROL_F:
        //
        // Force a breakin like Ctrl-C would do.
        // The advantage is this will work when kd is being debugged.
        //

        Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
        return TRUE;

    case CONTROL_P:
        // Launch cdb on this debugger.
        char PidStr[32];
        sprintf(PidStr, "\"cdb -p %d\"", GetCurrentProcessId());
        _spawnlp(_P_NOWAIT,
                 "cmd.exe", "/c", "start",
                 "remote", "/s", PidStr, "cdb_pipe",
                 NULL);
        return TRUE;

    case CONTROL_V:
        Client->GetOtherOutputMask(g_DbgClient, &OutMask);
        OutMask ^= DEBUG_OUTPUT_VERBOSE;
        Client->SetOtherOutputMask(g_DbgClient, OutMask);
        Control->SetLogMask(OutMask);
        ConOut("Verbose mode %s.\n",
               (OutMask & DEBUG_OUTPUT_VERBOSE) ? "ON" : "OFF");
        return TRUE;

    case CONTROL_W:
        Hr = Control->OutputVersionInformation(DEBUG_OUTCTL_AMBIENT);
        if (Hr == HRESULT_FROM_WIN32(ERROR_BUSY))
        {
            ConOut("Engine is busy, try again\n");
        }
        else if (Hr != S_OK)
        {
            ConOut("Unable to show version information, 0x%X\n", Hr);
        }
        return TRUE;

#ifdef KERNEL
            
    case CONTROL_A:
        Client->SetKernelConnectionOptions("cycle_speed");
        return TRUE;

    case CONTROL_D:
        Client->GetOtherOutputMask(g_DbgClient, &OutMask);
        OutMask ^= DEBUG_IOUTPUT_KD_PROTOCOL;
        Client->SetOtherOutputMask(g_DbgClient, OutMask);
        Control->SetLogMask(OutMask);
        return TRUE;

    case CONTROL_K:
        //
        // Toggle between the following possibilities-
        //
        // (0) no breakin
        // (1) -b style (same as Control-C up the wire)
        // (2) -d style (stop on first dll load).
        //
        // NB -b and -d could both be on the command line
        // but become mutually exclusive via this method.
        // (Maybe should be a single enum type).
        //

        Control->GetEngineOptions(&EngOptions);
        if (EngOptions & DEBUG_ENGOPT_INITIAL_BREAK)
        {
            //
            // Was type 1, go to type 2.
            //

            EngOptions |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
            EngOptions &= ~DEBUG_ENGOPT_INITIAL_BREAK;

            DebugAction = "breakin on first symbol load";
        }
        else if (EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK)
        {
            //
            // Was type 2, go to type 0.
            //
            
            EngOptions &= ~DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
            DebugAction = "NOT breakin";
        }
        else
        {
            //
            // Was type 0, go to type 1.
            //

            EngOptions |= DEBUG_ENGOPT_INITIAL_BREAK;
            DebugAction = "request initial breakpoint";
        }
        Control->SetEngineOptions(EngOptions);
        ConOut("Will %s at next boot.\n", DebugAction);
        return TRUE;

    case CONTROL_R:
        Client->SetKernelConnectionOptions("resync");
        return TRUE;

#endif // #ifdef KERNEL
    }

    return FALSE;
}

BOOL
ConIn(PSTR Buffer, ULONG BufferSize, BOOL Wait)
{
    if (g_InitialCommand != NULL)
    {
        ConOut("%s: Reading initial command '%s'\n",
               g_DebuggerName, g_InitialCommand);
        CopyString(Buffer, g_InitialCommand, BufferSize);
        g_InitialCommand = NULL;
        return TRUE;
    }

    while (g_InputFile && g_InputFile != stdin)
    {
        if (fgets(Buffer, BufferSize, g_InputFile))
        {
            ULONG Len = strlen(Buffer);
            
            ConOut("%s", Buffer);
            if (Len > 0 && Buffer[Len - 1] == '\n')
            {
                Buffer[Len - 1] = 0;
            }
            else
            {
                ConOut("\n");
            }
            return TRUE;
        }
        else
        {
            fclose(g_InputFile);
            if (g_NextOldInputFile > 0)
            {
                g_InputFile = g_OldInputFiles[--g_NextOldInputFile];
            }
            else
            {
                g_InputFile = stdin;
            }
        }
    }
    if (g_InputFile == NULL)
    {
        g_InputFile = stdin;
    }

    switch(g_IoMode)
    {
    case IO_NONE:
        return FALSE;
        
    case IO_DEBUG:
    case IO_DEBUG_DEFER:
        if (!Wait)
        {
            return FALSE;
        }
        
        g_NtDllCalls.DbgPrompt("", Buffer,
                               min(BufferSize, MAX_DBG_PROMPT_COMMAND));
        break;

    case IO_CONSOLE:
        ULONG Len;
    
        if (g_PromptInput == g_ConInput)
        {
            if (!Wait)
            {
                return FALSE;
            }
            
            // Reading from the console so we can assume we'll
            // read a line.
            for (;;)
            {
                if (!ReadFile(g_PromptInput, Buffer, BufferSize, &Len, NULL))
                {
                    OutputDebugString("Unable to read input\n");
                    ExitDebugger(E_FAIL);
                }

                // At a minimum a read should have CRLF.  If it
                // doesn't assume that something weird happened
                // and ignore the read.
                if (Len >= 2)
                {
                    break;
                }

                Sleep(50);
            }
        
            // Remove CR LF.
            Len -= 2;
            Buffer[Len] = '\0';

            // Edit out any special characters.
            for (ULONG i = 0; i < Len; i++)
            {
                if (CheckForControlCommands(g_DbgClient, g_DbgControl,
                                            Buffer[i]))
                {
                    Buffer[i] = ' ';
                }
            }
        }
        else
        {
#ifndef KERNEL
            if (g_Lines == 0)
            {
                // Allow the input thread to read the console.
                SetEvent(g_AllowInput);
            }
#endif

            while (g_Lines == 0)
            {
                if (!Wait)
                {
                    return FALSE;
                }
                
                // Wait for the input thread to notify us that
                // a line of input is available.  While we're waiting,
                // let the engine process callbacks provoked by
                // other clients.
                HRESULT Hr = g_DbgClient->DispatchCallbacks(INFINITE);
                if (Hr != S_OK)
                {
                    OutputDebugString("Unable to dispatch callbacks\n");
                    ExitDebugger(Hr);
                }

                // Some other client may have started execution in
                // which case we want to stop waiting for input.
                if (g_ExecStatus != DEBUG_STATUS_BREAK)
                {
#ifndef KERNEL
                    // XXX drewb - Need a way to turn input off.
#endif
                    
                    return FALSE;
                }
            }

            ReadPromptInputChars(Buffer, BufferSize);
        }
        break;
    }

    return TRUE;
}

#define KD_OUT_LIMIT 510

void
ConOutStr(PCSTR Str)
{
    int Len;
    
    switch(g_IoMode)
    {
    case IO_NONE:
        // Throw it away.
        break;

    case IO_DEBUG:
    case IO_DEBUG_DEFER:
        //
        // Send the output to the kernel debugger but note that we
        // want any control C processing to be done locally rather
        // than in the kernel.
        //
        // The kernel silently truncates DbgPrints longer than
        // 512 characters so use multiple calls if necessary.
        //

        Len = strlen(Str);
        if (Len > KD_OUT_LIMIT)
        {
            while (Len > 0)
            {
                if (g_NtDllCalls.DbgPrint("%.*s", KD_OUT_LIMIT,
                                          Str) == STATUS_BREAKPOINT &&
                    g_DbgControl != NULL)
                {
                    g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
                }

                Len -= KD_OUT_LIMIT;
                Str += KD_OUT_LIMIT;
            }
        }
        else
        {
            if (g_NtDllCalls.DbgPrint("%s", Str) == STATUS_BREAKPOINT &&
                g_DbgControl != NULL)
            {
                g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            }
        }
        break;

    case IO_CONSOLE:
        if (g_ConOutput != NULL)
        {
            ULONG Written;
            WriteFile(g_ConOutput, Str, strlen(Str), &Written, NULL);
        }
        else
        {
            OutputDebugString(Str);
        }
        break;
    }
}

void
ConOut(PCSTR Format, ...)
{
    va_list Args;
    
    // If no attempt has been made to create a console
    // go ahead and try now.
    if (g_IoMode == IO_CONSOLE && !g_ConInitialized)
    {
        CreateConsole();
    }
    
    va_start(Args, Format);
    _vsnprintf(g_Buffer, DIMA(g_Buffer), Format, Args);
    g_Buffer[DIMA(g_Buffer) - 1] = 0;
    va_end(Args);

    ConOutStr(g_Buffer);
}

void
ConClear(void)
{
    if (g_IoMode != IO_CONSOLE)
    {
        return;
    }
    
    // If no attempt has been made to create a console
    // go ahead and try now.
    if (g_IoMode == IO_CONSOLE && !g_ConInitialized)
    {
        CreateConsole();
    }

    HANDLE Console;
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenInfo;
    DWORD Done;
    DWORD Chars;
          
    Console = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!GetConsoleScreenBufferInfo(Console,  &ConsoleScreenInfo))
    {
        return;
    }
    
    ConsoleScreenInfo.dwCursorPosition.X = 0;
    ConsoleScreenInfo.dwCursorPosition.Y = 0;
    
    Chars = ConsoleScreenInfo.dwSize.Y * ConsoleScreenInfo.dwSize.X;
    
    FillConsoleOutputCharacterA(Console, ' ', Chars,
                                ConsoleScreenInfo.dwCursorPosition,
                                &Done);
    FillConsoleOutputAttribute(Console, ConsoleScreenInfo.wAttributes,
                               Chars, ConsoleScreenInfo.dwCursorPosition,
                               &Done);
    SetConsoleCursorPosition(Console, ConsoleScreenInfo.dwCursorPosition);
}

void
ExitDebugger(ULONG Code)
{
    if (g_DbgClient != NULL)
    {
        if (g_RemoteClient)
        {
            // Disconnect from server.
            g_DbgClient->EndSession(DEBUG_END_DISCONNECT);
        }
        else
        {
            g_DbgClient->EndSession(DEBUG_END_PASSIVE);
            // Force servers to get cleaned up.
            g_DbgClient->EndSession(DEBUG_END_REENTRANT);
        }
    }

    ExitProcess(Code);
}

void
ErrorExit(PCSTR Format, ...)
{
    if (Format != NULL)
    {
        DWORD Len;
        va_list Args;

        // If no attempt has been made to create a console
        // go ahead and try now.
        if (g_IoRequested == IO_CONSOLE && !g_ConInitialized)
        {
            CreateConsole();
        }
            
        va_start(Args, Format);
        Len = _vsnprintf(g_Buffer, DIMA(g_Buffer), Format, Args);
        va_end(Args);
        g_Buffer[DIMA(g_Buffer) - 1] = 0;
        if ((int)Len < 0 || Len == DIMA(g_Buffer))
        {
            Len = DIMA(g_Buffer) - 1;
        }

        if (g_ConOutput != NULL)
        {
            WriteFile(g_ConOutput, g_Buffer, Len, &Len, NULL);
        }
        else
        {
            OutputDebugString(g_Buffer);
        }
    }

#ifndef INHERIT_CONSOLE
    if (g_IoRequested == IO_CONSOLE)
    {
        ConOut("%s: exiting - press enter ---", g_DebuggerName);
        g_InitialCommand = NULL;
        g_InputFile = NULL;
        ConIn(g_Buffer, sizeof(g_Buffer), TRUE);
    }
#endif
    
    ExitDebugger(E_FAIL);
}

DWORD WINAPI
InputThreadLoop(PVOID Param)
{
    DWORD Read;
    BOOL Status;
    UCHAR Char;
    BOOL NewLine = TRUE;
    BOOL SpecialChar = FALSE;
    HANDLE ConIn = g_ConInput;
    HRESULT Hr;
    BOOL ShowInputError = TRUE;
    BOOL PipeInput;

    // Create interfaces usable on this thread.
    if ((Hr = g_DbgClient->CreateClient(&g_ConClient)) != S_OK ||
        (Hr = g_ConClient->QueryInterface(IID_IDebugControl,
                                          (void **)&g_ConControl)) != S_OK)
    {
        ConOut("%s: Unable to create input thread interfaces, 0x%X\n",
               g_DebuggerName, Hr);
        // Force servers to get cleaned up or disconnect from server.
        g_DbgClient->EndSession(g_RemoteClient ?
                                DEBUG_END_DISCONNECT : DEBUG_END_REENTRANT);
        ExitProcess(E_FAIL);
    }
    
    PipeInput = GetFileType(ConIn) == FILE_TYPE_PIPE;
    
    //
    // Capture all typed input immediately.
    // Stuff the characters into an anonymous pipe, from which
    // ConIn will read them.
    //

    for (;;)
    {
#ifndef KERNEL
        // The debugger should only read the console when the
        // debuggee isn't running to avoid eating up input 
        // intended for the debuggee.
        if (!g_RemoteClient && NewLine)
        {
            if (WaitForSingleObject(g_AllowInput,
                                    INFINITE) != WAIT_OBJECT_0)
            {
                ConOut("%s: Failed to wait for input window, %d\n",
                       GetLastError());
            }
            
            NewLine = FALSE;
        }
#endif

        //
        // The CRT does GetFileType's on all standard I/O handles
        // when initializing.  GetFileType counts as a synchronous
        // I/O so if the handle happens to be a pipe and the pipe
        // already has a sync I/O on it the GetFileType will block
        // until the first I/O is satisfied.
        // 
        // When this separate I/O thread is running it's normally
        // blocked in a ReadFile, causing any GetFileType call
        // on the handle to also block until there's some input.
        // In order to avoid this we detect that the input is
        // a pipe and use PeekNamedPipe to delay the ReadFile
        // until there's some input available.
        //
    
        if (PipeInput)
        {
            for (;;)
            {
                ULONG Avail;
                
                if (PeekNamedPipe(ConIn, NULL, 0, NULL, &Avail, NULL) &&
                    Avail > 0)
                {
                    break;
                }

                Sleep(10);
            }
        }
        
        Status = ReadFile(ConIn, &Char, sizeof(Char), &Read, NULL);
        if (!Status || Read != sizeof(Char))
        {
            if (ShowInputError &&
                GetLastError() != ERROR_OPERATION_ABORTED &&
                GetLastError() != ERROR_IO_PENDING)
            {
                ConOut("%s: Could not read from console, %d\n",
                       g_DebuggerName, GetLastError());
                ShowInputError = FALSE;
            }

            // The most common cause of a console read failure
            // is killing remote with @K.  Give things some
            // time to kill this process.
            // If this is a remote server it's possible that
            // the debugger was run without a valid console
            // and is just being accessed via remoting.
            // Sleep longer in that case since errors will
            // probably always occur.
            Sleep(!g_RemoteClient && g_RemoteOptions != NULL ?
                  1000 : 50);
            continue;
        }

        // We successfully got some input so if it
        // fails later we should show a fresh error.
        ShowInputError = TRUE;
        
        if (CheckForControlCommands(g_ConClient, g_ConControl, Char))
        {
            SpecialChar = TRUE;
            continue;
        }
            
        if (SpecialChar && Char == '\r')
        {
            // If we get a CR immediately after a special
            // char turn it into a space so that it doesn't cause
            // a command repeat.
            Char = ' ';
        }
            
        SpecialChar = FALSE;

        ULONG Len;
        Status = WriteFile(g_PipeWrite, &Char, sizeof(Char), &Len,
                           &g_PipeWriteOverlapped);
        if (!Status && GetLastError() != ERROR_IO_PENDING)
        {
            ConOut("%s: Could not write to pipe, %d\n",
                   g_DebuggerName, GetLastError());
        }
        else if (Char == '\n')
        {
            EnterCriticalSection(&g_InputLock);
            
            InterlockedIncrement(&g_Lines);
                
            // If input is needed send it directly
            // to the engine.
            if (g_InputStarted)
            {
                ReadPromptInputChars(g_Buffer, sizeof(g_Buffer));
                g_ConControl->ReturnInput(g_Buffer);
                g_InputStarted = FALSE;
            }
            else
            {
                // Wake up the engine thread when a line of
                // input is present.
                g_ConClient->ExitDispatch(g_DbgClient);
            }
            
            LeaveCriticalSection(&g_InputLock);
                
            NewLine = TRUE;
        }
    }

    return 0;
}

void
CreateInputThread(void)
{
    HANDLE Thread;
    DWORD ThreadId;
    CHAR PipeName[256];

    if (g_PipeWrite != NULL)
    {
        // Input thread already exists.
        return;
    }

#ifndef KERNEL
    g_AllowInput = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_AllowInput == NULL)
    {
        ErrorExit("Unable to create input event, %d\n", GetLastError());
    }
#endif
    
    _snprintf(PipeName,
              sizeof(PipeName),
              "\\\\.\\pipe\\Dbg%d",
              GetCurrentProcessId());
    PipeName[sizeof(PipeName) - 1] = 0;

    g_PipeWrite = CreateNamedPipe(PipeName,
                                  PIPE_ACCESS_DUPLEX |
                                  FILE_FLAG_OVERLAPPED,
                                  PIPE_TYPE_BYTE | PIPE_READMODE_BYTE |
                                  PIPE_WAIT,
                                  2,
                                  2000,
                                  2000,
                                  NMPWAIT_WAIT_FOREVER,
                                  NULL);
    if (g_PipeWrite == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Failed to create input pipe, %d\n",
                  GetLastError());
    }

    g_PromptInput = CreateFile(PipeName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
    if (g_PromptInput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Failed to create read pipe, %d\n",
                  GetLastError());
    }

    Thread = CreateThread(NULL,
                          16000, // THREAD_STACK_SIZE
                          InputThreadLoop,
                          NULL,
                          THREAD_SET_INFORMATION,
                          &ThreadId);
    if (Thread == NULL)
    {
        ErrorExit("Failed to create input thread, %d\n",
                  GetLastError());
    }
    else
    {
        if (!SetThreadPriority(Thread, THREAD_PRIORITY_ABOVE_NORMAL))
        {
            ErrorExit("Failed to raise the input thread priority, %d\n",
                      GetLastError());
        }
    }

    CloseHandle(Thread);

    // Wait for thread initialization.  Callbacks are
    // already registered so we need to dispatch them
    // while waiting.
    while (g_ConControl == NULL)
    {
        g_DbgClient->DispatchCallbacks(50);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\breakin\breakin.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define STACKSIZE 32768

typedef BOOL (* LPDEBUG_BREAK_PROCESS_ROUTINE) (
    HANDLE Process
    );


VOID
DebugPriv(
         VOID
         )
{
    HANDLE Token ;
    UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ) ];
    PTOKEN_PRIVILEGES Privs ;

    if (OpenProcessToken( GetCurrentProcess(),
                          MAXIMUM_ALLOWED,
                          &Token )) {
        Privs = (PTOKEN_PRIVILEGES) Buf ;

        Privs->PrivilegeCount = 1 ;
        Privs->Privileges[0].Luid.LowPart = 20L ;
        Privs->Privileges[0].Luid.HighPart = 0 ;
        Privs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

        AdjustTokenPrivileges( Token,
                               FALSE,
                               Privs,
                               0,
                               NULL,
                               NULL );

        CloseHandle( Token );
    }
}

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    LPTHREAD_START_ROUTINE DbgBreakPoint;
    LPDEBUG_BREAK_PROCESS_ROUTINE DebugBreakProcessRoutine;
    HANDLE ntdll, kernel32;
    ULONG ProcessId;
    ULONG ThreadId;
    HANDLE Process;
    HANDLE Thread;

    if (argc != 2) {
        usage:
        fprintf(stderr, "usage: breakin <pid>\n");
        exit(1);
    }

    ProcessId = atoi(argv[1]);

    if (ProcessId == 0) {
        goto usage;
    }

    DebugPriv();

    Process = OpenProcess(
                         PROCESS_ALL_ACCESS,
                         FALSE,
                         ProcessId
                         );
    if (Process) {

        kernel32 = GetModuleHandle("kernel32.dll");

        if (kernel32) {

            DebugBreakProcessRoutine = (LPDEBUG_BREAK_PROCESS_ROUTINE)GetProcAddress(kernel32, "DebugBreakProcess");

            if (DebugBreakProcessRoutine) {

                if (!(*DebugBreakProcessRoutine)(Process)) {

                    printf("DebugBreakProcess failed %d\n", GetLastError());
                }

                CloseHandle(Process);

                return 0;
            }
        }
        
        ntdll = GetModuleHandle("ntdll.dll");

        if (ntdll) {

            DbgBreakPoint = (LPTHREAD_START_ROUTINE)GetProcAddress(ntdll, "DbgBreakPoint");

            if (DbgBreakPoint) {

                Thread = CreateRemoteThread(
                                           Process,
                                           NULL,
                                           STACKSIZE,
                                           DbgBreakPoint,
                                           NULL,
                                           0,
                                           &ThreadId
                                           );
                if (Thread){
                    CloseHandle(Thread);
                }
            }
        }

        CloseHandle(Process);

    } else {

        printf("Open process failed %d\n", GetLastError());
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\dc\dc.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

	dc.cpp

 Abstract:

	Command line utility for dumping importing information from DLL's
	and executables.

	Command Line Options:
	/v			Verbose mode
	/s:Func		Only display functions matching search string "Func"
	/o:File		Send output to File
	/f			Sort by function, not by module.

 History:

    05/10/2000 t-michkr  Created

--*/

#include <windows.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

// For some reason, this is needed to compile in
// the sdktools tree.
#define strdup		_strdup
#define stricmp		_stricmp
#define strnicmp	_strnicmp

// Structure containing all info relevent to an imported function.
struct SFunction
{
	// The name this function is imported by.
	char* m_szName;

	// Ordinal number, Win3.1 compatibility.
	int m_iOrdinal;

	// Lookup index into a DLL's export table
	// for quick patching.
	int m_iHint;

	// Starting address of the function.
	DWORD m_dwAddress;

	// Whether or not it is a delayed import.
	bool m_fDelayedImport;

	// Forwarded function name
	char* m_szForward;

	// Link to next function
	SFunction* m_pNext;

	SFunction()
	{
		m_szName = m_szForward = 0;
		m_iOrdinal = m_iHint = -1;
		m_dwAddress = static_cast<DWORD>(-1);
		m_fDelayedImport = false;
		m_pNext = 0;
	}
};

// A module used by the executable (ie, DLL's)
struct SModule
{
	// The name of this module
	char* m_szName;

	// All functions imported from this module
	SFunction* m_pFunctions;

	// Link to next module
	SModule* m_pNext;

	SModule()
	{
		m_szName = 0;
		m_pFunctions = 0;
		m_pNext = 0;
	}
};

// All modules imported by the executable.
SModule* g_pModules = 0;

void InsertFunctionSorted(SModule* pMod, SFunction* pFunc)
{

	// Special case, insert at front
	if(pMod->m_pFunctions == 0 
		|| stricmp(pMod->m_pFunctions->m_szName, pFunc->m_szName) > 0)
	{
		pFunc->m_pNext = pMod->m_pFunctions;
		pMod->m_pFunctions = pFunc;
		return;
	}

	SFunction* pfPrev = pMod->m_pFunctions;
	SFunction* pfTemp = pMod->m_pFunctions->m_pNext;
	while(pfTemp)
	{
		if(stricmp(pfTemp->m_szName, pFunc->m_szName) > 0)
		{
			pFunc->m_pNext = pfTemp;
			pfPrev->m_pNext = pFunc;
			return;
		}
		pfPrev = pfTemp;
		pfTemp = pfTemp->m_pNext;
	}

	// Insert at end.
	pFunc->m_pNext = 0;
	pfPrev->m_pNext = pFunc;
}

void InsertModuleSorted(SModule* pMod)
{
	// Special case, insert at front
	if(g_pModules == 0 
		|| stricmp(g_pModules->m_szName, pMod->m_szName) > 0)
	{
		pMod->m_pNext = g_pModules;
		g_pModules = pMod;		
		return;
	}

	SModule* pmPrev = g_pModules;
	SModule* pmTemp = g_pModules->m_pNext;
	while(pmTemp)
	{
		if(stricmp(pmTemp->m_szName, pMod->m_szName) > 0)
		{
			pMod->m_pNext = pmTemp;
			pmPrev->m_pNext = pMod;
			return;
		}
		pmPrev = pmTemp;
		pmTemp = pmTemp->m_pNext;
	}

	// Insert at end.
	pMod->m_pNext = 0;
	pmPrev->m_pNext = pMod;
}

// Print a message about the last error that occurred.
void PrintLastError()
{
	// Get the message string
	void* pvMsgBuf;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |  
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(), 
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		reinterpret_cast<PTSTR>(&pvMsgBuf),0, 0);

	// Print it.
	fprintf(stderr, "%s\n", pvMsgBuf);
	
	// Free the buffer.
	LocalFree(pvMsgBuf);
}

/*************************************************************************
*   LinkName2Name
*
*************************************************************************/
void
LinkName2Name(
    char* szLinkName,
    char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
  
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;
	char szFunction[1024];
	char szClass[1024];

    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", szFunction, szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", szFunction, szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", szClass, szFunction);
    } else {
        sprintf(szName, "%s", szFunction);
    }
}

// Get function forwarding information for
// imported functions.
// This is done by loading the module and sniffing
// its export table.
bool GetForwardFunctions(SModule* pModule)
{
	// Open the DLL module.
	char szFileName[1024];
	char* pstr;

	// Search the path and windows directories for it.
	if(SearchPath(0, pModule->m_szName, 0, 1024, szFileName, &pstr)==0)
		return false;

	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
		0, OPEN_EXISTING, 0, 0);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		PrintLastError();
		return false;
	}

	HANDLE hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);

	if(hMap == 0)
	{
		PrintLastError();
		return false;
	}

	void* pvFileBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(!pvFileBase)
	{
		PrintLastError();
		return false;
	}

	// Get the MS-DOS compatible header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(pvFileBase);
	if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
	{
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}

	// Get the NT header
	PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
		reinterpret_cast<DWORD>(pvFileBase) + pidh->e_lfanew);

	if(pinth->Signature != IMAGE_NT_SIGNATURE)
	{
		// Not a valid Win32 executable, may be a Win16 or OS/2 exe
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}


	// Get the other headers
	PIMAGE_FILE_HEADER pifh = &pinth->FileHeader;
	PIMAGE_OPTIONAL_HEADER pioh = &pinth->OptionalHeader;
	PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinth);

	// If no exports, we're done.
	if(pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)
		return true;

	DWORD dwVAImageDir = 
		pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

	
	// Locate the section with this image directory.
	for(int i = 0; i < pifh->NumberOfSections; i++)
	{
		if( (dwVAImageDir >= pish[i].VirtualAddress) &&
			(dwVAImageDir < (pish[i].VirtualAddress + pish[i].SizeOfRawData)))
		{
			pish = &pish[i];
			break;
		}
	}

	if(i == pifh->NumberOfSections)
	{
		fprintf(stderr, "Could not locate export directory section\n");
		return false;
	}

	DWORD dwBase = reinterpret_cast<DWORD>(pvFileBase) + 
		pish->PointerToRawData - pish->VirtualAddress;

	PIMAGE_EXPORT_DIRECTORY pied = 
		reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(dwBase + dwVAImageDir);

	DWORD* pdwNames = reinterpret_cast<DWORD*>(dwBase + 
		pied->AddressOfNames);

	WORD* pwOrdinals = reinterpret_cast<WORD*>(dwBase +
		pied->AddressOfNameOrdinals);

	DWORD* pdwAddresses = reinterpret_cast<DWORD*>(dwBase + 
		pied->AddressOfFunctions);

	for(unsigned hint = 0; hint < pied->NumberOfNames; hint++)
	{
		char* szFunction = reinterpret_cast<PSTR>(dwBase + pdwNames[hint]);

		// Duck out early if this function isn't used in the executable.
		SFunction* pFunc = pModule->m_pFunctions;
		while(pFunc)
		{
			if(strcmp(pFunc->m_szName, szFunction)==0)
				break;

			pFunc = pFunc->m_pNext;
		}

		if(pFunc == 0)
			continue;

		int ordinal = pied->Base + static_cast<DWORD>(pwOrdinals[hint]);
		DWORD dwAddress = pdwAddresses[ordinal-pied->Base];

		// Check if this function has been forwarded to another DLL
		if( ((dwAddress) >= dwVAImageDir) && 
			((dwAddress) < 
			(dwVAImageDir + pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)))
		{
			char* szForward = reinterpret_cast<char*>(dwBase + dwAddress);

			pFunc->m_szForward = strdup(szForward);
		}
	}
	UnmapViewOfFile(pvFileBase);

	CloseHandle(hMap);
	CloseHandle(hFile);
	return true;
}

// Look through the import directory, and build a list of all imported functions
bool ParseImportDirectory(PIMAGE_FILE_HEADER pifh, PIMAGE_OPTIONAL_HEADER pioh, 
						  PIMAGE_SECTION_HEADER pish, void* pvFileBase,
						  bool fDelayed)
{	
	// Get which directory we want (normal imports or delayed imports)
	DWORD dwDir = (fDelayed) ? 
			IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT : IMAGE_DIRECTORY_ENTRY_IMPORT;

	// Bail if no imports
	if(pioh->DataDirectory[dwDir].Size == 0)
		return true;
	
	// Locate the import directory in the image.
	PIMAGE_SECTION_HEADER pishImportDirectory = 0;

	DWORD dwVAImageDir = pioh->DataDirectory[dwDir].VirtualAddress;
	for(int i = 0; i < pifh->NumberOfSections; i++)
	{
		if((dwVAImageDir >= pish[i].VirtualAddress) &&
			dwVAImageDir < (pish[i].VirtualAddress + pish[i].SizeOfRawData))
		{
			// This is it.
			pishImportDirectory = &pish[i];
			break;
		}
	}

	if(pishImportDirectory == 0)
	{
		fprintf(stderr, "Cannot locate %s%s\n",((fDelayed) ? "delayed " : ""),
			"import directory section");

		return false;
	}

	// Get the base address for the image.
	DWORD dwBase = reinterpret_cast<DWORD>(pvFileBase) 
		+ pishImportDirectory->PointerToRawData 
		- pishImportDirectory->VirtualAddress;

	// Get the import descriptor array
	PIMAGE_IMPORT_DESCRIPTOR piid = 
		reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(dwBase + dwVAImageDir);

	// Loop through all imported modules
	while(piid->FirstThunk || piid->OriginalFirstThunk)
	{
		SModule* psm = new SModule;
		psm->m_szName = strdup(reinterpret_cast<char*>(dwBase + piid->Name));

		// Check if it is already in the list
		SModule* pTemp = g_pModules;
		while(pTemp)
		{
			if(strcmp(pTemp->m_szName, psm->m_szName) == 0)
				break;

			pTemp = pTemp->m_pNext;
		}

		// If not, insert it
		if(pTemp == 0)
		{
			InsertModuleSorted(psm);
		}
		else
		{
			// Otherwise, get rid of it.
			pTemp = g_pModules;
			while(pTemp)
			{
				if(strcmp(pTemp->m_szName, psm->m_szName)==0)
					break;

				pTemp = pTemp->m_pNext;
			}
			assert(pTemp);
			free(psm->m_szName);
			delete psm;
			psm = pTemp;
		}

		// Get the function imports from this module.
		PIMAGE_THUNK_DATA pitdf = 0;
		PIMAGE_THUNK_DATA pitda = 0;
		
		// Check for MS or Borland format
		if(piid->OriginalFirstThunk)
		{
			// MS format, function array is in original first thunk.
			pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase +
				piid->OriginalFirstThunk);

			// If the time stamp is set, the module has been bound,
			// and first thunk is the bound address array.
			if(piid->TimeDateStamp)
			{
				pitda = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase +
					piid->FirstThunk);
			}
		}
		else
		{
			// Borland format uses first thunk for function array
			pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase + 
				piid->FirstThunk);
		}

		while(pitdf->u1.Ordinal)
		{
			SFunction* psf = new SFunction;			

			if(IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
			{
				psf->m_iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));
				psf->m_iHint = -1;

				char szTemp[1024];
				sprintf(szTemp, "Unnamed%6d", psf->m_iOrdinal);
				
				psf->m_szName = strdup(szTemp);
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME piibn = 
					reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(dwBase + 
					(DWORD)(pitdf->u1.AddressOfData));
				char* szName = reinterpret_cast<char*>(piibn->Name);
				char szBuffer[512];
				LinkName2Name(szName, szBuffer);
				psf->m_szName = strdup(szBuffer);				

				psf->m_iOrdinal = -1;
				psf->m_iHint = piibn->Hint;
			}

			psf->m_fDelayedImport = fDelayed;
			psf->m_dwAddress = pitda ? (DWORD) pitda->u1.Function : 
				reinterpret_cast<DWORD>(INVALID_HANDLE_VALUE);
		
			// Do a sorted insert of the function
			InsertFunctionSorted(psm, psf);
			
			// Go to next function
			pitdf++;

			if(pitda)
				pitda++;
		}		

		// Go to next entry
		piid++;		
	}

	return true;
}

bool GetImports(char* szExecutable)
{
	// Open the file
	HANDLE hFile = CreateFile(szExecutable, GENERIC_READ, FILE_SHARE_READ, 0,
		OPEN_EXISTING, 0, 0);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		PrintLastError();
		return false;
	}

	// Map this file into memory
	HANDLE hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
	if(hMap == 0)
	{
		PrintLastError();
		return false;
	}

	void* pvFileBase;
	pvFileBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(pvFileBase == 0)
	{
		PrintLastError();
		return false;
	}

	// Get the MS-DOS compatible header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(pvFileBase);
	if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
	{
		fprintf(stderr,"File is not a valid executable\n");
		return false;
	}

	// Get the NT header
	PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
		reinterpret_cast<DWORD>(pvFileBase) + pidh->e_lfanew);

	if(pinth->Signature != IMAGE_NT_SIGNATURE)
	{
		// Not a valid Win32 executable, may be a Win16 or OS/2 exe
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}


	// Get the other headers
	PIMAGE_FILE_HEADER pifh = &pinth->FileHeader;
	PIMAGE_OPTIONAL_HEADER pioh = &pinth->OptionalHeader;
	PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinth);

	// Get normal imports
	if(!ParseImportDirectory(pifh, pioh, pish, pvFileBase, false))
	{
		return false;
	}
	
	// Get delayed imports
	if(!ParseImportDirectory(pifh, pioh, pish, pvFileBase, true))
	{
		return false;
	}

	// Resolve forwarded functions
	SModule* pModule = g_pModules;
	while(pModule)
	{
		GetForwardFunctions(pModule);
		pModule = pModule->m_pNext;
	}

	// We're done with the file.
	if(!UnmapViewOfFile(pvFileBase))
	{
		PrintLastError();
		return false;
	}

	CloseHandle(hMap);
	CloseHandle(hFile);

	return true;
}

// Return true if function name matches search string, false otherwise.
bool MatchFunction(const char* szFunc, const char* szSearch)
{
	if(strcmp(szSearch, "*") == 0)
		return true;

	while(*szSearch != '\0' && *szFunc != '\0')
	{
		// If we get a ?, we don't care and move on to the next
		// character.
		if(*szSearch == '?')
		{
			szSearch++;
			szFunc++;
			continue;
		}

		// If we have a wildcard, move to next search string and search for substring
		if(*szSearch == '*')
		{
			const char* szCurrSearch;
			szSearch++;

			if(*szSearch == '\0')
				return true;

			// Don't change starting point.
			szCurrSearch = szSearch;
			for(;;)
			{
				// We're done if we hit another wildcard
				if(*szCurrSearch == '*' ||
					*szCurrSearch == '?')
				{
					// Update the permanent search position.
					szSearch = szCurrSearch;
					break;
				}
				// At end of both strings, return true.
				if((*szCurrSearch == '\0') && (*szFunc == '\0'))
					return true;

				// We never found it
				if(*szFunc == '\0')						
					return false;

				// If it doesn't match, start over
				if(toupper(*szFunc) != toupper(*szCurrSearch))
				{
					// If mismatch on first character
					// of search string, move to next
					// character in function string.
					if(szCurrSearch == szSearch)
						szFunc++;
					else
						szCurrSearch = szSearch;
				}
				else
				{
					szFunc++;
					szCurrSearch++;
				}
			}
		}
		else
		{
			if(toupper(*szFunc) != toupper(*szSearch))
			{
				return false;
			}

			szFunc++;
			szSearch++;
		}
	}

	if((*szFunc == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
		return true;
	else
		return false;
}

void PrintModule(SModule* pMod, char* szSearch, bool fVerbose, FILE* pfOut)
{
	bool fModNamePrinted = false;

	SFunction* pFunc = pMod->m_pFunctions;
	while(pFunc)
	{
		if(!MatchFunction(pFunc->m_szName, szSearch))
		{
			pFunc = pFunc->m_pNext;
			continue;
		}

		if(!fModNamePrinted)
		{
			fModNamePrinted = true;
			fprintf(pfOut, "\n%s:\n", pMod->m_szName);

			if(fVerbose)
				fprintf(pfOut, "%-42s%-8s%-5s%-12s%s\n", "Function", "Ordinal", 
					"Hint", "Address", "Delayed");
		}

		if(fVerbose)
		{
			fprintf(pfOut,"%-45s", (pFunc->m_szForward == 0)
				? pFunc->m_szName : pFunc->m_szForward);

			if(pFunc->m_iOrdinal==-1)
				fprintf(pfOut, "%-5s", "N/A");
			else
				fprintf(pfOut, "%-5d", pFunc->m_iOrdinal);					

			if(pFunc->m_iHint == -1)
				fprintf(pfOut, "%-5s", "N/A");
			else
				fprintf(pfOut, "%-5d", pFunc->m_iHint);


			if(pFunc->m_dwAddress == static_cast<DWORD>(-1))
				fprintf(pfOut, "%-12s", "Not Bound");
			else
				fprintf(pfOut, "%-#12x", pFunc->m_dwAddress);

			fprintf(pfOut,"%s\n", pFunc->m_fDelayedImport ? "Yes" : "No");
			
		}
		else
			fprintf(pfOut, "%s\n", pFunc->m_szName);

		pFunc = pFunc->m_pNext;
	}
}

int _cdecl main(int argc, char** argv)
{
	if(argc < 2)
	{
		fprintf(stderr,"Usage: dc executable [/v /s: func /f]\n");
		return 0;
	}

	// Parse command line
	char* szFileName = argv[1];
	if( (strnicmp(szFileName, "/?", 2) == 0) || 
		(strncmp(szFileName, "/h", 2) == 0))
	{
		printf("Usage: dc executable [/v /s: func /f]\n");
		printf("executable:\t\tName of executable file to check\n");
		printf("/v:\t\t\tVerbose\n");
		printf("/s: func\t\tDisplay all functions matching func search string");
		printf(", * and ? allowed.\n");
		printf("/f:\t\t\tDisplay alphabetically by function, not module.\n");
		printf("/o: File\t\tRedirect all output to File.\n");
		return 0;
	}

	FILE* pfOutput = 0;	

	// If no extension, just add .exe
	if(strchr(szFileName, '.') == 0)		
	{
		szFileName = new char[strlen(argv[1]) + 5];
		strcpy(szFileName, argv[1]);
		strcat(szFileName, ".exe");
	}

	bool fVerbose = false;
	bool fUseStdout = true;
	char* szSearch = "*";
	bool fSortByFunction = false;

	// Get flags.
	for(int i = 2; i < argc; i++)
	{
		char* szFlag = argv[i];
		if(stricmp(szFlag, "/v") == 0)
		{
			fVerbose = true;
		}
		else if(strnicmp(szFlag, "/s:", 3) == 0)
		{
			if((i == argc-1) && (strlen(szFlag) <= 3))
			{
				fprintf(stderr,"Missing search string\n");
				return 0;
			}

			if(strlen(szFlag) > 3)
			{
				szSearch = strdup(&szFlag[3]);
			}
			else
			{
				szSearch = argv[i+1];
				i++;
			}
		}
		else if(stricmp(szFlag, "/f") == 0)
		{
			fSortByFunction = true;
		}
		else if( (strnicmp(szFlag, "/h",2) == 0) ||
			(strnicmp(szFlag, "/?",2) == 0))
		{
			printf("Usage: dc executable [/v /s: func /f]\n");
			printf("executable:\t\tName of executable file to check\n");
			printf("/v:\t\t\tVerbose\n");
			printf("/s: func\t\tDisplay all functions matching func search string");
			printf(", * and ? allowed.\n");
			printf("/f:\t\t\tDisplay alphabetically by function, not module.\n");
			printf("/o: File\t\tRedirect all output to File.\n");
			return 0;
		}
		else if(strnicmp(szFlag, "/o:", 3) == 0)
		{
			fUseStdout = false;
			if( (i == argc-1) && (strlen(szFlag) <= 3))
			{
				fprintf(stderr, "Missing output file name\n");
				return 0;
			}
			if(strlen(szFlag) > 3)
			{
				pfOutput = fopen(&szFlag[3], "wt");
			}
			else
			{
				pfOutput = fopen(argv[i+1], "wt");
				i++;
			}
		}
		else
		{
			fprintf(stderr,"Unknown command line option, %s\n", szFlag);
			return 0;
		}

	}

	if(fUseStdout)
		pfOutput = stdout;

	if(!pfOutput)
	{
		fprintf(stderr,"Unable to open output file\n");
		return 0;
	}

	// We wrap this code in a try block, because
	// we map the file into memory.  If the file
	// is invalid and if the pointers in it are garbage,
	// we should get an access violation, which is caught.
	try
	{
		if(!GetImports(szFileName))
		{
			return 0;
		}
	}
	catch(...)
	{
		fprintf(stderr, "Invalid executable file\n");
		return 0;
	}

	if(fSortByFunction)
	{
		// Create a global list of functions
		SModule* pGlobal = new SModule;
		pGlobal->m_szName = "All Imported Functions";

		SModule* pMod = g_pModules;
		while(pMod)
		{
			SFunction* pFunc = pMod->m_pFunctions;
			while(pFunc)
			{
				// Create a copy of this function
				// This is a shallow copy, but
				// it should be ok, since we don't
				// delete the original
				SFunction* pNew = new SFunction;
				memcpy(pNew, pFunc, sizeof(*pFunc));

				InsertFunctionSorted(pGlobal, pNew);				
		
				pFunc = pFunc->m_pNext;
			}
			pMod = pMod->m_pNext;
		}		

		PrintModule(pGlobal, szSearch, fVerbose, pfOutput);
	
	}
	else
	{
		SModule* pMod = g_pModules;
		while(pMod)
		{
			PrintModule(pMod, szSearch, fVerbose, pfOutput);
			pMod = pMod->m_pNext;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\conio.hpp ===
//----------------------------------------------------------------------------
//
// Console input and output.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __CONIO_HPP__
#define __CONIO_HPP__

class DefInputCallbacks :
    public IDebugInputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

class ConInputCallbacks : public DefInputCallbacks
{
public:
    // IDebugInputCallbacks.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        );
    STDMETHOD(EndInput)(
        THIS
        );
};

class DefOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

class ConOutputCallbacks : public DefOutputCallbacks
{
public:
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

// Maximum command string.  DbgPrompt has a limit of 512
// characters so that would be one potential limit.  We
// have users who want to use longer command lines, though,
// such as Autodump which scripts the debugger with very long
// sx commands.  The other obvious limit is MAX_SYMBOL_LEN
// since it makes sense that you should be able to give a
// command with a full symbol name, so use that.
#define MAX_COMMAND 4096
#define MAX_DBG_PROMPT_COMMAND 512

extern HANDLE g_ConInput, g_ConOutput;
extern HANDLE g_PromptInput;
extern HANDLE g_PipeWrite;
extern ConInputCallbacks g_ConInputCb;
extern ConOutputCallbacks g_ConOutputCb;
extern IDebugClient* g_ConClient;
extern IDebugControl* g_ConControl;

void InitializeIo(PCSTR InputFile);
void CreateConsole(void);
BOOL ConIn(PSTR Buffer, ULONG BufferSize, BOOL Wait);
void ConOut(PCSTR Format, ...);
void ConOutStr(PCSTR Str);
void ConClear(void);
void DECLSPEC_NORETURN ExitDebugger(ULONG Code);
void DECLSPEC_NORETURN ErrorExit(PCSTR Format, ...);
void CreateInputThread(void);

#endif // #ifndef __CONIO_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\engine.cpp ===
//----------------------------------------------------------------------------
//
// Debug engine glue.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "main.hpp"

// Global execution control.
BOOL g_Exit;

BOOL g_CanOpenUnicodeDump;

ULONG g_PlatformId;

// Debug engine interfaces.
IDebugClient* g_DbgClient;
IDebugClient2* g_DbgClient2;
IDebugClient3* g_DbgClient3;
IDebugClient4* g_DbgClient4;
IDebugControl* g_DbgControl;
IDebugControl3* g_DbgControl3;
IDebugSymbols* g_DbgSymbols;
IDebugRegisters* g_DbgRegisters;

ULONG g_ExecStatus;
ULONG g_LastProcessExitCode;
BOOL g_Restarting;

#define NTDLL_CALL_NAMES \
    (sizeof(g_NtDllCallNames) / sizeof(g_NtDllCallNames[0]))

// These names must match the ordering in the NTDLL_CALLS structure.
char* g_NtDllCallNames[] =
{
    "DbgPrint",
    "DbgPrompt",
};

#define NTDLL_CALL_PROCS (sizeof(g_NtDllCalls) / sizeof(FARPROC))

NTDLL_CALLS g_NtDllCalls;

#ifdef OCAKD
void
UpdateDbForBadDumpFile(PSTR FilePath);
#endif

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );

    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
};

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXIT_PROCESS | DEBUG_EVENT_CHANGE_ENGINE_STATE;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ExitProcess(
    THIS_
    IN ULONG ExitCode
    )
{
    g_LastProcessExitCode = ExitCode;
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
        g_ExecStatus = (ULONG)Argument;

        // If this notification came from a wait completing
        // we want to wake up the input thread so that new
        // commands can be processed.  If it came from inside
        // a wait we don't want to ask for input as the engine
        // may go back to running at any time.
        if ((Argument & DEBUG_STATUS_INSIDE_WAIT) == 0)
        {
            if (g_IoMode == IO_NONE ||
                g_IoMode == IO_DEBUG_DEFER)
            {
                // Wake up the main loop.
                g_DbgClient->ExitDispatch(g_DbgClient);
            }
            else if (g_ConClient != NULL)
            {
                g_ConClient->ExitDispatch(g_DbgClient);
            }
        }
    }

    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

ULONG NTAPI
Win9xDbgPrompt(char *Prompt, char *Buffer, ULONG BufferLen)
{
    ULONG Len;

    // XXX drewb - Is there a real equivalent of DbgPrompt?

    if (BufferLen == 0)
    {
        return 0;
    }
    Buffer[0] = 0;

    printf("%s", Prompt);
    if (fgets(Buffer, BufferLen, stdin))
    {
        Len = strlen(Buffer);
        while (Len > 0 && isspace(Buffer[Len - 1]))
        {
            Len--;
        }

        if (Len > 0)
        {
            Buffer[Len] = 0;
        }
    }
    else
    {
        Len = 0;
    }

    return Len;
}

ULONG __cdecl
Win9xDbgPrint( char *Text, ... )
{
    char Temp[1024];
    va_list Args;

    va_start(Args, Text);
    _vsnprintf(Temp, DIMA(Temp), Text, Args);
    Temp[DIMA(Temp) - 1] = 0;
    va_end(Args);
    OutputDebugString(Temp);

    return 0;
}

void
InitDynamicCalls(void)
{
    HINSTANCE NtDll;
    ULONG i;
    char** Name;
    FARPROC* Proc;

    if (g_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        g_NtDllCalls.DbgPrint = Win9xDbgPrint;
        g_NtDllCalls.DbgPrompt = Win9xDbgPrompt;
        return;
    }

    //
    // Dynamically link NT calls.
    //

    if (NTDLL_CALL_NAMES != NTDLL_CALL_PROCS)
    {
        ErrorExit("NtDllCalls mismatch\n");
    }

    NtDll = LoadLibrary("ntdll.dll");
    if (NtDll == NULL)
    {
        ErrorExit("%s: Unable to load ntdll\n", g_DebuggerName);
    }

    Name = g_NtDllCallNames;
    Proc = (FARPROC*)&g_NtDllCalls;

    for (i = 0; i < NTDLL_CALL_PROCS; i++)
    {
        *Proc = GetProcAddress(NtDll, *Name);
        if (*Proc == NULL)
        {
            ErrorExit("%s: Unable to link ntdll!%s\n",
                      g_DebuggerName, *Name);
        }

        Proc++;
        Name++;
    }

    // If DbgPrintReturnControlC exists use it instead of
    // normal DbgPrint.
    FARPROC DpRetCc;

    DpRetCc = GetProcAddress(NtDll, "DbgPrintReturnControlC");
    if (DpRetCc != NULL)
    {
        Proc = (FARPROC*)&g_NtDllCalls.DbgPrint;
        *Proc = DpRetCc;
    }
}

void
DefaultEngineInitialize(void)
{
    HRESULT Hr;
    OSVERSIONINFO OsVersionInfo;

    g_CanOpenUnicodeDump = FALSE;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx(&OsVersionInfo);
    g_PlatformId = OsVersionInfo.dwPlatformId;

    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugControl,
                                          (void **)&g_DbgControl)) != S_OK ||
        (Hr = g_DbgClient->QueryInterface(IID_IDebugSymbols,
                                          (void **)&g_DbgSymbols)) != S_OK ||
        (Hr = g_DbgClient->QueryInterface(IID_IDebugRegisters,
                                          (void **)&g_DbgRegisters)) != S_OK)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    // Queries for higher-version interfaces.  These can
    // fail if this executable is run against an older engine.
    // This is highly unlikely since everything is shipped
    // as a set, but handle it anyway.
    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugClient2,
                                          (void **)&g_DbgClient2)) != S_OK &&
        Hr != E_NOINTERFACE &&
        Hr != RPC_E_VERSION_MISMATCH)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugClient3,
                                          (void **)&g_DbgClient3)) != S_OK &&
        Hr != E_NOINTERFACE &&
        Hr != RPC_E_VERSION_MISMATCH)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugClient4,
                                          (void **)&g_DbgClient4)) != S_OK &&
        Hr != E_NOINTERFACE &&
        Hr != RPC_E_VERSION_MISMATCH)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugControl3,
                                          (void **)&g_DbgControl3)) != S_OK &&
        Hr != E_NOINTERFACE &&
        Hr != RPC_E_VERSION_MISMATCH)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    if (g_DbgClient4 && g_CommandLineCharSize == sizeof(WCHAR))
    {
        g_CanOpenUnicodeDump = TRUE;
    }

    g_DbgClient->SetInputCallbacks(&g_ConInputCb);
    g_DbgClient->SetOutputCallbacks(&g_ConOutputCb);
    g_DbgClient->SetEventCallbacks(&g_EventCb);

    if (!g_RemoteClient)
    {
        //
        // Check environment variables to determine if any logfile needs to be
        // opened.
        //

        PSTR LogFile;
        BOOL Append;

        LogFile = getenv("_NT_DEBUG_LOG_FILE_APPEND");
        if (LogFile != NULL)
        {
            Append = TRUE;
        }
        else
        {
            Append = FALSE;
            LogFile = getenv("_NT_DEBUG_LOG_FILE_OPEN");
        }
        if (LogFile != NULL)
        {
            g_DbgControl->OpenLogFile(LogFile, Append);
        }
    }

    InitDynamicCalls();
}

void
CreateEngine(PCSTR RemoteOptions)
{
    HRESULT Hr;

    if ((Hr = DebugCreate(IID_IDebugClient,
                          (void **)&g_DbgClient)) != S_OK)
    {
        ErrorExit("DebugCreate failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    if (RemoteOptions != NULL)
    {
        if ((Hr = g_DbgClient->StartServer(RemoteOptions)) != S_OK)
        {
            ErrorExit("StartServer failed, %s\n    \"%s\"\n",
                      FormatStatusCode(Hr), FormatStatus(Hr));
        }
    }

    DefaultEngineInitialize();
}

void
ConnectEngine(PCSTR RemoteOptions)
{
    HRESULT Hr;

    if ((Hr = DebugConnect(RemoteOptions, IID_IDebugClient,
                           (void **)&g_DbgClient)) != S_OK)
    {
        ErrorExit("DebugCreate failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    DefaultEngineInitialize();
}

void
InitializeSession(void)
{
    HRESULT Hr;
    ULONG i;

    if (g_NumDumpFiles)
    {
        if (g_NumDumpInfoFiles)
        {
            if (g_DbgClient2 == NULL)
            {
#ifdef OCAKD
                UpdateDbForBadDumpFile(g_DumpFilesAnsi[0]);
#endif
                ErrorExit("Debugger does not support extra dump files\n");
            }

            for (i = 0; i < g_NumDumpInfoFiles; i++)
            {
                if (g_CanOpenUnicodeDump)
                {
                    if ((Hr = g_DbgClient4->AddDumpInformationFileWide
                         ((PWSTR)g_DumpInfoFiles[i], 0,
                          g_DumpInfoTypes[i])) != S_OK)
                    {
#ifdef OCAKD
                        UpdateDbForBadDumpFile(g_DumpFilesAnsi[0]);
#endif
                        ErrorExit("Unable to use '%ws', %s\n    \"%s\"\n",
                                  g_DumpInfoFiles[i],
                                  FormatStatusCode(Hr), FormatStatus(Hr));
                    }
                }
                else
                {
                    if ((Hr = g_DbgClient2->AddDumpInformationFile
                         ((PSTR)g_DumpInfoFiles[i],
                          g_DumpInfoTypes[i])) != S_OK)
                    {
#ifdef OCAKD
                        UpdateDbForBadDumpFile(g_DumpFilesAnsi[0]);
#endif
                        ErrorExit("Unable to use '%s', %s\n    \"%s\"\n",
                                  g_DumpInfoFiles[i],
                                  FormatStatusCode(Hr), FormatStatus(Hr));
                    }
                }
            }
        }

        for (i = 0; i < g_NumDumpFiles; i++)
        {
            if (g_CanOpenUnicodeDump)
            {
                Hr = g_DbgClient4->OpenDumpFileWide((PWSTR)g_DumpFiles[i], 0);
            }
            else
            {
                Hr = g_DbgClient->OpenDumpFile((PSTR)g_DumpFiles[i]);
            }
            if (Hr != S_OK)
            {
                break;
            }
        }
    }
    else if (g_CommandLinePtr != NULL ||
             g_PidToDebug != 0 ||
             g_ProcNameToDebug != NULL)
    {
        ULONG64 Server = 0;

        if (g_ProcessServer != NULL)
        {
            Hr = g_DbgClient->ConnectProcessServer(g_ProcessServer,
                                                   &Server);
            if (Hr != S_OK)
            {
                ErrorExit("Unable to connect to process server, %s\n"
                          "    \"%s\"\n", FormatStatusCode(Hr),
                          FormatStatus(Hr));
            }
        }

        ULONG Pid;

        if (g_ProcNameToDebug != NULL)
        {
            Hr = g_DbgClient->GetRunningProcessSystemIdByExecutableName
                (Server, g_ProcNameToDebug, DEBUG_GET_PROC_ONLY_MATCH, &Pid);
            if (Hr != S_OK)
            {
                if (Hr == S_FALSE)
                {
                    ErrorExit("There is more than one '%s' process running.  "
                              "Find the process ID\nof the instance you "
                              "are interested in and use -p <pid>.\n",
                              g_ProcNameToDebug);
                }
                else
                {
                    ErrorExit("Unable to find process '%s', %s\n    \"%s\"\n",
                              g_ProcNameToDebug, FormatStatusCode(Hr),
                              FormatStatus(Hr));
                }
            }
        }
        else
        {
            Pid = g_PidToDebug;
        }

        if (g_CommandLineCharSize == sizeof(WCHAR))
        {
            if (g_DbgClient3 == NULL)
            {
                ErrorExit("%s: dbgeng.dll is out of sync with %s.exe\n",
                          g_DebuggerName, g_DebuggerName);
            }

            Hr = g_DbgClient3->CreateProcessAndAttachWide(Server,
                                                          (PWSTR)g_CommandLinePtr,
                                                          g_CreateFlags,
                                                          Pid,
                                                          g_AttachProcessFlags);
        }
        else
        {
            Hr = g_DbgClient->CreateProcessAndAttach(Server,
                                                     (PSTR)g_CommandLinePtr,
                                                     g_CreateFlags,
                                                     Pid,
                                                     g_AttachProcessFlags);
        }

        if (g_DetachOnExitRequired &&
            g_DbgClient->
            AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT) != S_OK)
        {
            ErrorExit("%s: The system does not support detach on exit\n",
                      g_DebuggerName);
        }
        else if (g_DetachOnExitImplied)
        {
            // The detach-on-exit is not required so don't check for
            // failures.  This is necessary for the -- case where
            // detach-on-exit is implied but must work on systems
            // with and without the detach-on-exit support.
            g_DbgClient->AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT);
        }

        if (Server != 0)
        {
            g_DbgClient->DisconnectProcessServer(Server);
        }
    }
    else
    {
        Hr = g_DbgClient->AttachKernel(g_AttachKernelFlags, g_ConnectOptions);
    }
    if (Hr != S_OK)
    {
#ifdef OCAKD
        UpdateDbForBadDumpFile(g_DumpFilesAnsi[0]);
#endif
        ErrorExit("Debuggee initialization failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
}

BOOL WINAPI
InterruptHandler(
    IN ULONG CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT || CtrlType == CTRL_BREAK_EVENT)
    {
        PDEBUG_CONTROL Control =
            g_RemoteClient ? g_ConControl : g_DbgControl;
        if (Control != NULL)
        {
            Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
        }
        else
        {
            ConOut("Debugger not initialized, cannot interrupt\n");
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    )

/*++

Routine Description:

    The CreatePipeEx API is used to create an anonymous pipe I/O device.
    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
    both handles.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    static ULONG PipeSerialNumber;
    HANDLE ReadPipeHandle, WritePipeHandle;
    DWORD dwError;
    char PipeNameBuffer[ MAX_PATH ];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    //  Set the default timeout to 120 seconds
    //

    if (nSize == 0) {
        nSize = 4096;
        }

    sprintf( PipeNameBuffer,
             "\\\\.\\Pipe\\Win32PipesEx.%08x.%08x",
             GetCurrentProcessId(),
             PipeSerialNumber++
           );

    ReadPipeHandle = CreateNamedPipeA(
                         PipeNameBuffer,
                         PIPE_ACCESS_INBOUND | dwReadMode,
                         PIPE_TYPE_BYTE | PIPE_WAIT,
                         1,             // Number of pipes
                         nSize,         // Out buffer size
                         nSize,         // In buffer size
                         120 * 1000,    // Timeout in ms
                         lpPipeAttributes
                         );

    if (ReadPipeHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(
                        PipeNameBuffer,
                        GENERIC_WRITE,
                        0,                         // No sharing
                        lpPipeAttributes,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
                        NULL                       // Template file
                      );

    if (INVALID_HANDLE_VALUE == WritePipeHandle) {
        dwError = GetLastError();
        CloseHandle( ReadPipeHandle );
        SetLastError(dwError);
        return FALSE;
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}

void
StartRemote(
    PCSTR Args
    )

/*++

Routine Description:

    "remotes" the current debugger by starting a copy of remote.exe in a
    special mode that causes it to attach to us, the debugger, as its
    "child" process.

Arguments:

    Args - Name of the pipe to use for this remote session, e.g. "ntsd" means
           to connect one would use "remote /c machinename ntsd".

Return Value:

    None.

--*/

{
    static BOOL fRemoteIsRunning;
    HANDLE hRemoteChildProcess;
    HANDLE hOrgStdIn;
    HANDLE hOrgStdOut;
    HANDLE hOrgStdErr;
    HANDLE hNewStdIn;
    HANDLE hRemoteWriteChildStdIn;
    HANDLE hNewStdOut;
    HANDLE hRemoteReadChildStdOut;
    HANDLE hNewStdErr;
    SECURITY_ATTRIBUTES sa;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char szCmd[MAX_PATH];

    if (Args == NULL)
    {
        goto DotRemoteUsage;
    }

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    if (!Args[0])
    {
        goto DotRemoteUsage;
    }

    if (g_PipeWrite != NULL)
    {
        ConOut("An input thread has already been started so .remote\n");
        ConOut("cannot be used.  Either start the debugger with\n");
        ConOut("remote.exe, such as remote /s \"kd\" pipe; or use\n");
        ConOut("debugger remoting with -server/-client/.server.\n");
        return;
    }

    if (fRemoteIsRunning)
    {
        ConOut(".remote: can't .remote twice.\n");
        goto Cleanup;
    }

    if (g_IoMode != IO_CONSOLE)
    {
        ConOut(".remote: can't .remote when using -d.  "
               "Remote the kernel debugger instead.\n");
        goto Cleanup;
    }

    ConOut("Starting remote with pipename '%s'\n", Args);

    //
    // We'll pass remote.exe inheritable handles to this process,
    // our standard in/out handles (for it to use as stdin/stdout),
    // and pipe handles for it to write to our new stdin and read
    // from our new stdout.
    //

    //
    // Get an inheritable handle to our process.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               GetCurrentProcess(),           // src handle
               GetCurrentProcess(),           // targ process
               &hRemoteChildProcess,          // targ handle
               0,                             // access
               TRUE,                          // inheritable
               DUPLICATE_SAME_ACCESS          // options
               ))
    {
        ConOut(".remote: Unable to duplicate process handle.\n");
        goto Cleanup;
    }

    //
    // Get inheritable copies of our current stdin, stdout, stderr which
    // we'll use for same for remote.exe when we spawn it.
    //

    hOrgStdIn = g_ConInput;
    hOrgStdOut = g_ConOutput;
    hOrgStdErr = GetStdHandle(STD_ERROR_HANDLE);

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    //
    // Create remote->ntsd pipe, our end of which will be our
    // new stdin.  The remote.exe end needs to be opened
    // for overlapped I/O, so yet another copy of MyCreatePipeEx
    // spreads through our source base.
    //

    if ( ! MyCreatePipeEx(
               &hNewStdIn,                 // read handle
               &hRemoteWriteChildStdIn,    // write handle
               &sa,                        // security
               0,                          // size
               0,                          // read handle overlapped?
               FILE_FLAG_OVERLAPPED        // write handle overlapped?
               ))
    {
        ConOut(".remote: Unable to create stdin pipe.\n");
        CloseHandle(hRemoteChildProcess);
        goto Cleanup;
    }

    //
    // We don't want remote.exe to inherit our end of the pipe
    // so duplicate it to a non-inheritable one.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdIn,                     // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdIn,                    // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS |
               DUPLICATE_CLOSE_SOURCE         // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        goto Cleanup;
    }

    //
    // Create ntsd->remote pipe, our end of which will be our
    // new stdout and stderr.
    //

    if ( ! MyCreatePipeEx(
               &hRemoteReadChildStdOut,    // read handle
               &hNewStdOut,                // write handle
               &sa,                        // security
               0,                          // size
               FILE_FLAG_OVERLAPPED,       // read handle overlapped?
               0                           // write handle overlapped?
               ))
    {
        ConOut(".remote: Unable to create stdout pipe.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        goto Cleanup;
    }

    //
    // We don't want remote.exe to inherit our end of the pipe
    // so duplicate it to a non-inheritable one.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdOut,                    // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdOut,                   // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS |
               DUPLICATE_CLOSE_SOURCE         // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        goto Cleanup;
    }

    //
    // Duplicate our new stdout to a new stderr.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdOut,                    // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdErr,                   // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS          // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        CloseHandle(hNewStdOut);
        goto Cleanup;
    }

    //
    // We now have all the handles we need.  Let's launch remote.
    //

    PrintString(
        szCmd,
        DIMA(szCmd),
        "remote.exe /a %d %d %d %s %s",
        HandleToUlong(hRemoteChildProcess),
        HandleToUlong(hRemoteWriteChildStdIn),
        HandleToUlong(hRemoteReadChildStdOut),
        g_DebuggerName,
        Args
        );

    ZeroMemory(&si, sizeof(si));
    si.cb            = sizeof(si);
    si.dwFlags       = STARTF_USESTDHANDLES;
    si.hStdInput     = hOrgStdIn;
    si.hStdOutput    = hOrgStdOut;
    si.hStdError     = hOrgStdErr;
    si.wShowWindow   = SW_SHOW;

    //
    // Create Child Process
    //

    if ( ! CreateProcess(
               NULL,
               szCmd,
               NULL,
               NULL,
               TRUE,
               GetPriorityClass( GetCurrentProcess() ),
               NULL,
               NULL,
               &si,
               &pi))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            ConOut("remote.exe not found\n");
        }
        else
        {
            ConOut("CreateProcess(%s) failed, error %d.\n",
                   szCmd, GetLastError());
        }

        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        CloseHandle(hNewStdOut);
        CloseHandle(hNewStdErr);
        goto Cleanup;
    }

    CloseHandle(hRemoteChildProcess);
    CloseHandle(hRemoteWriteChildStdIn);
    CloseHandle(hRemoteReadChildStdOut);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    //
    // Switch to using the new handles.  Might be nice to
    // start a thread here to watch for remote.exe dying
    // and switch back to the old handles.
    //

    // CloseHandle(hOrgStdIn);
    if (g_PromptInput == g_ConInput)
    {
        g_PromptInput = hNewStdIn;
    }
    g_ConInput = hNewStdIn;
    SetStdHandle(STD_INPUT_HANDLE, hNewStdIn);

    // CloseHandle(hOrgStdOut);
    g_ConOutput = hNewStdOut;
    SetStdHandle(STD_OUTPUT_HANDLE, hNewStdOut);

    // CloseHandle(hOrgStdErr);
    SetStdHandle(STD_ERROR_HANDLE, hNewStdErr);

    fRemoteIsRunning = TRUE;

    ConOut("%s: now running under remote.exe pipename %s\n",
           g_DebuggerName, Args);

  Cleanup:
    return;

DotRemoteUsage:
    ConOut("Usage: .remote pipename\n");
}

BOOL
UiCommand(PSTR Command)
{
    char Term;
    PSTR Scan, Arg;

    //
    // Check and see if this is a UI command
    // vs. a command that should go to the engine.
    //

    while (isspace(*Command))
    {
        Command++;
    }
    Scan = Command;
    while (*Scan && !isspace(*Scan))
    {
        Scan++;
    }
    Term = *Scan;
    *Scan = 0;

    // Advance to next nonspace char for arguments.
    if (Term != 0)
    {
        Arg = Scan + 1;
        while (isspace(*Arg))
        {
            Arg++;
        }
        if (*Arg == 0)
        {
            Arg = NULL;
        }
    }
    else
    {
        Arg = NULL;
    }

    if (!_strcmpi(Command, ".cls"))
    {
        ConClear();
    }
    else if (!_strcmpi(Command, ".hh"))
    {
        if (GetFileType(g_ConInput) == FILE_TYPE_PIPE)
        {
            ConOut("%s is running under remote.exe /s.  .hh is blocked to\n"
                   "prevent remote clients from starting help "
                   "on the server machine.\n"
                   "Run \"start <dbgdir>\\debugger.chm\" "
                   "to view the documentation.\n",
                   g_DebuggerName);
        }
        else if (Arg == NULL)
        {
            OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
        }
        else if (!_strnicmp(Arg, "dbgerr", 6))
        {
            OpenHelpKeyword(Arg, TRUE);
        }
        else
        {
            OpenHelpKeyword(Arg, FALSE);
        }
    }
    else if (!_strcmpi(Command, ".remote"))
    {
        StartRemote(Arg);
    }
    else if (!_strcmpi(Command, ".restart"))
    {
        if (g_RemoteClient)
        {
            ConOut("Only the primary debugger can restart\n");
        }
        else if ((g_PidToDebug != 0 ||
                  g_ProcNameToDebug != NULL) &&
                 g_AttachProcessFlags == DEBUG_ATTACH_DEFAULT)
        {
            ConOut("Process attaches cannot be restarted.  If you want to\n"
                   "restart the process, use !peb to get what command line\n"
                   "to use and other initialization information.\n");
        }
        else
        {
            g_DbgClient->EndSession(DEBUG_END_ACTIVE_TERMINATE);
            g_Restarting = TRUE;
        }
    }
    else if (!_strcmpi(Command, ".server"))
    {
        // We need to start a separate input thread when
        // using remoting but we do not actually handle
        // the command.
        CreateInputThread();
        *Scan = Term;
        return FALSE;
    }
    else if ((g_IoMode == IO_DEBUG ||
              g_IoMode == IO_DEBUG_DEFER) &&
             (!_strnicmp(Command, ".sympath", 8) ||
              !_strnicmp(Command, "!sympath", 8)))
    {
        // We want to display a usage note in -d mode
        // but we do not actually handle the command.
        ConOut("NOTE: The symbol path for this %s is relative to where\n"
               "%s.exe is running, not where kd.exe is running.\n",
               g_DebuggerName, g_DebuggerName);
        *Scan = Term;
        return FALSE;
    }
    else if (Command[0] == '$' && Command[1] == '<')
    {
        *Scan = Term;
        if (g_NextOldInputFile >= MAX_INPUT_NESTING)
        {
            ConOut("Scripts too deeply nested\n");
        }
        else
        {
            FILE* Script = fopen(Command + 2, "r");
            if (Script == NULL)
            {
                ConOut("Unable to open '%s'\n", Command + 2);
            }
            else
            {
                g_OldInputFiles[g_NextOldInputFile++] = g_InputFile;
                g_InputFile = Script;
            }
        }
    }
    else if (!_strcmpi(Command, ".remote_exit"))
    {
        if (!g_RemoteClient)
        {
            ConOut("Not a remote client\n");
        }
        else
        {
            if (g_DbgClient)
            {
                // Tell server about disconnect or
                // force servers to get cleaned up.
                g_DbgClient->EndSession(DEBUG_END_DISCONNECT);
            }
            ExitProcess(S_OK);
        }
    }
    else
    {
        *Scan = Term;
        return FALSE;
    }

    return TRUE;
}

BOOL
MainLoop(void)
{
    HRESULT Hr;
    BOOL SessionEnded = FALSE;
    ULONG64 InstructionOffset;
    DEBUG_STACK_FRAME StkFrame;
    ULONG Class, Qual;

    if (!SetConsoleCtrlHandler(InterruptHandler, TRUE))
    {
        ConOut("Warning: unable to set Control-C handler.\n");
    }

    // Get initial status.
    g_DbgControl->GetExecutionStatus(&g_ExecStatus);
    g_DbgControl->GetDebuggeeType(&Class, &Qual);

    while (!g_Exit)
    {
        BOOL InputDeferMessageDone;

        if (!g_RemoteClient)
        {
            Hr = g_DbgControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

            if (FAILED(Hr))
            {
                // The debug session may have ended.  If so, just exit.
                if (g_DbgControl->GetExecutionStatus(&g_ExecStatus) == S_OK &&
                    g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
                {
                    SessionEnded = TRUE;
                    break;
                }

                // Inform the user of the failure and force
                // command processing.
                ConOut("WaitForEvent failed, %s\n    \"%s\"\n",
                       FormatStatusCode(Hr), FormatStatus(Hr));
                g_ExecStatus = DEBUG_STATUS_BREAK;
            }

            // By far the most likely reason for WaitForEvent to
            // fail on a dump is bad symbols, which would produce
            // further errors when trying to use processor state.
            // Avoid doing so in the dump case.
            if (FAILED(Hr) && g_NumDumpFiles)
            {
                ConOut("When WaitForEvent fails on dump files the "
                       "current state is not displayed.\n");
                ConOut("If you are having symbol problems you will "
                       "need to restart the debugger\n"
                       "after you correct the symbol path.  "
                       ".restart can also be used.\n");
            }
            else
            {
                if (Class != DEBUG_CLASS_KERNEL ||
                    (Qual != DEBUG_DUMP_SMALL && Qual != DEBUG_DUMP_DEFAULT &&
                     Qual != DEBUG_DUMP_FULL))
                {
                    // Dump registers and such.
                    g_DbgControl->OutputCurrentState(DEBUG_OUTCTL_ALL_CLIENTS,
                                                     DEBUG_CURRENT_DEFAULT);
                }

            }

        }

        InputDeferMessageDone = FALSE;

        while (!g_Exit && g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            ULONG Inputs;

            // If we're in debug-defer mode we defer to
            // any other input clients in order to avoid
            // using DbgPrompt and pausing the machine.
            // Check if there are other input clients.
            if (g_IoMode == IO_DEBUG_DEFER)
            {
                if (g_DbgControl->Input(NULL, DEBUG_ANY_ID, &Inputs) != S_OK)
                {
                    Inputs = 1;
                }
                else if (Inputs > 1 && !InputDeferMessageDone)
                {
                    OutputDebugString("Debuggee break, "
                                      "deferring to remote clients\n");
                    InputDeferMessageDone = TRUE;
                }
            }

            if (g_IoMode == IO_NONE ||
                (g_IoMode == IO_DEBUG_DEFER && Inputs > 1))
            {
                // This is a pure remoting server with no
                // local user or a debug-defer server with
                // alternate input clients.  Just wait for a remote
                // client to get things running again.
                Hr = g_DbgClient->DispatchCallbacks(INFINITE);
                if (Hr != S_OK)
                {
                    OutputDebugString("Unable to dispatch callbacks\n");
                    ExitDebugger(Hr);
                }
            }
            else
            {
                char Command[MAX_COMMAND];

                g_DbgControl->OutputPrompt(DEBUG_OUTCTL_THIS_CLIENT |
                                           DEBUG_OUTCTL_NOT_LOGGED, " ");
                if (ConIn(Command, sizeof(Command), TRUE))
                {
                    if (g_RemoteClient)
                    {
                        // Identify self before command.
                        g_DbgClient->
                            OutputIdentity(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                           DEBUG_OUTPUT_IDENTITY_DEFAULT,
                                           "[%s] ");
                    }

                    g_DbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                               " %s\n", Command);

                    // Intercept and handle UI commands.
                    if (!UiCommand(Command))
                    {
                        // Must be an engine command.
                        g_DbgControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                              Command,
                                              DEBUG_EXECUTE_NOT_LOGGED);
                    }
                }
            }
        }

        if (g_Restarting)
        {
            InitializeSession();
            g_Restarting = FALSE;
            continue;
        }

        if (Class != DEBUG_CLASS_USER_WINDOWS)
        {
            // The kernel debugger doesn't exit when the machine reboots.
            g_Exit = FALSE;
        }
        else
        {
            g_Exit = g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE;
            if (g_Exit)
            {
                SessionEnded = TRUE;
                break;
            }
        }

        if (g_RemoteClient)
        {
            Hr = g_DbgClient->DispatchCallbacks(INFINITE);
            if (Hr != S_OK)
            {
                OutputDebugString("Unable to dispatch callbacks\n");
                ExitDebugger(Hr);
            }
        }
    }

    return SessionEnded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\engine.hpp ===
//----------------------------------------------------------------------------
//
// Debug engine glue.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __ENGINE_HPP__
#define __ENGINE_HPP__

// Certain calls are dynamically linked so that the user-mode
// code can be used on Win9x.
struct NTDLL_CALLS
{
    ULONG (__cdecl* DbgPrint)
        (PCH Format, ...);
    ULONG (NTAPI* DbgPrompt)
        (PCH Prompt, PCH Response, ULONG MaximumResponseLength);
};

extern NTDLL_CALLS g_NtDllCalls;

extern BOOL g_Exit;
extern BOOL g_CanOpenUnicodeDump;
extern ULONG g_PlatformId;
extern IDebugClient* g_DbgClient;
extern IDebugClient2* g_DbgClient2;
extern IDebugClient3* g_DbgClient3;
extern IDebugClient4* g_DbgClient4;
extern IDebugControl* g_DbgControl;
extern IDebugControl3* g_DbgControl3;
extern IDebugSymbols* g_DbgSymbols;
extern ULONG g_ExecStatus;
extern ULONG g_LastProcessExitCode;

void CreateEngine(PCSTR RemoteOptions);
void ConnectEngine(PCSTR RemoteOptions);
void InitializeSession(void);
BOOL MainLoop(void);

#endif // #ifndef __ENGINE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\ini.cpp ===
//----------------------------------------------------------------------------
//
// .ini file support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "ini.hpp"
#include "main.hpp"

#define INI_SECTION_DEFAULT "dbgeng"

static char *(g_Tokens[]) =
{
    "debugchildren",
    "debugoutput",
    "stopfirst",
    "verboseoutput",
    "lazyload",
    "true",
    "false",
    "$u0",
    "$u1",
    "$u2",
    "$u3",
    "$u4",
    "$u5",
    "$u6",
    "$u7",
    "$u8",
    "$u9",
    "stoponprocessexit",
    "sxd",
    "sxe",
    "inifile",
    "setdll",
    "lines",
    "srcopt",
    "srcpath+"
};

int
GetIniToken(
    PSTR* ppsz,
    PSTR limit
    )
{
    PSTR psz = *ppsz;
    int  token;

    while ((*psz == ' ' || *psz == '\t' || *psz == ':') &&
           *psz && psz < limit)
    {
        psz++;
    }
    if (psz >= limit)
    {
        return 0;
    }
    *ppsz = psz;
    while (*psz != ' ' && *psz != '\t' && *psz != ':' && *psz != '\n' &&
           *psz != '\r'&& *psz && psz < limit)
    {
        *psz = (char)tolower(*psz);
        psz++;
    }
    *psz = 0;
    if (**ppsz == '[')
    {
        return NTINI_END;
    }
    
    for (token = 1; token < NTINI_INVALID; token++)
    {
        if (!strcmp(*ppsz, g_Tokens[token-1]))
        {
            break;
        }
    }
    *ppsz = psz + 1;
    return token;
}

BOOL
FindIniSection(FILE* File, PSTR Section)
{
    char Ch, Tst;
    ULONG Index = 0;
    
    Ch = *Section;
    while (Ch && !feof(File))
    {
        Tst = (char)fgetc(File);
        if ((char)tolower(Ch) == (char)tolower(Tst))
        {
            Ch = Section[++Index];
        }
        else
        {
            Ch = Section[Index = 0];
        }
    }

    return Ch == 0;
}

void
ReadIniFile(
    PULONG debugType
    )
{
    FILE*       file;
    char        pszName[256];
    char        rchBuf[_MAX_PATH];
    PSTR        pszMark;
    PSTR        pchCur;
    DWORD       length;
    int         index;
    int         token, value;

    length = GetEnvironmentVariable(INI_DIR,
                                    pszName,
                                    sizeof(pszName) - sizeof(INI_FILE));
    if (length == 0)
    {
        return;
    }

    strcpy(pszName + length, INI_FILE);

    if (!(file = fopen(pszName, "r")))
    {
        return;
    }

    // Look for a section specific to this debugger first.
    if (!FindIniSection(file, g_DebuggerName))
    {
        // Didn't find a specific section, look for
        // the generic debugger settings section.
        rewind(file);
        if (!FindIniSection(file, INI_SECTION_DEFAULT))
        {
            fclose(file);
            return;
        }
    }

    // Now just read the lines in
    do
    {
        PSTR psz = rchBuf;

        if (!fgets(rchBuf, sizeof(rchBuf), file))
        {
            break;
        }

        for (index = 0; rchBuf[index] && rchBuf[index] > 26; index++)
        {
            ;
        }
        rchBuf[index] = 0;

        token = GetIniToken(&psz, rchBuf + sizeof(rchBuf));
        if (token >= NTINI_USERREG0 && token <= NTINI_USERREG9)
        {
            while ((*psz == ' ' || *psz == '\t' || *psz == ':') && *psz)
            {
                psz++;
            }
            if (*psz)
            {
                g_DbgControl->SetTextMacro(token - NTINI_USERREG0, psz);
            }
            continue;
        }

        switch (token)
        {
        case NTINI_SXD:
        case NTINI_SXE:
            ExecuteCmd("sx", *(psz - 2), ' ', psz);
            continue;
        case NTINI_INIFILE:
            g_InitialInputFile = (PSTR)calloc(1, strlen(psz) + 1);
            if (!g_InitialInputFile)
            {
                ErrorExit("%s: Input file memory allocation failed\n",
                          g_DebuggerName);
            }
            strcpy(g_InitialInputFile, psz);
            continue;
        case NTINI_DEFAULTEXT:
            ULONG64 Handle;
            
            g_DbgControl->AddExtension(psz, DEBUG_EXTENSION_AT_ENGINE,
                                       &Handle);
            continue;
        case NTINI_SRCOPT:
            while ((*psz == ' ' || *psz == '\t' || *psz == ':') && *psz)
            {
                psz++;
            }
            ExecuteCmd("l+", 0, 0, psz);
            continue;
        case NTINI_SRCPATHA:
            ExecuteCmd(".srcpath+", 0, ' ', psz);
            continue;
        }

        value = GetIniToken(&psz, rchBuf + sizeof(rchBuf)) != NTINI_FALSE;
        switch (token)
        {
        case NTINI_STOPONPROCESSEXIT:
            if (value)
            {
                g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            break;
        case NTINI_DEBUGCHILDREN:
            if (value)
            {
                *debugType = DEBUG_PROCESS;
            }
            break;
        case NTINI_DEBUGOUTPUT:
            if (value)
            {
                g_IoMode = IO_DEBUG;
            }
            else
            {
                g_IoMode = IO_CONSOLE;
            }
            break;
        case NTINI_STOPFIRST:
            if (value)
            {
                g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            break;
        case NTINI_VERBOSEOUTPUT:
            ULONG OutMask;
            g_DbgClient->GetOutputMask(&OutMask);
            if (value)
            {
                OutMask |= DEBUG_OUTPUT_VERBOSE;
            }
            else
            {
                OutMask &= ~DEBUG_OUTPUT_VERBOSE;
            }
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            break;
        case NTINI_LAZYLOAD:
            if (value)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_DEFERRED_LOADS);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
            }
            break;
        case NTINI_LINES:
            if (value)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_LOAD_LINES);
            }
            break;
        }
    }
    while (token != NTINI_END);
    fclose(file);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\sources.inc ===
TARGETNAME = $(DEBUGGER_NAME)
TARGETPATH = obj
TARGETTYPE = PROGRAM

INCLUDES = ..;..\..\dbg-common

C_DEFINES = $(C_DEFINES) \
        -DDEBUGGER_NAME=\"$(DEBUGGER_NAME)\"
        
SOURCES = \
        ..\conio.cpp\
        ..\engine.cpp\
        ..\ini.cpp\
        ..\main.cpp\
        $(DEBUGGER_NAME).rc

NO_NTDLL = 1

USE_MSVCRT = 1
!if "$(DEBUGGER_NAME)" == "ntsd"
UMTYPE = windows
# Avoid running out of stack during stress
LINKER_STACKCOMMITSIZE=65536
!else
UMTYPE = console
C_DEFINES = $(C_DEFINES) -DINHERIT_CONSOLE
!endif

TARGETLIBS = $(TARGETLIBS) \
        $(SDK_LIB_PATH)\dbgeng.lib\
        $(SDK_LIB_PATH)\uuid.lib\
        $(SDK_LIB_PATH)\user32.lib\
        $(SDK_LIB_PATH)\version.lib\
        $(SDK_LIB_PATH)\htmlhelp.lib\
        $(SDK_LIB_PATH)\wininet.lib\
        $(DEBUGGER_LIBS)\*\dbglib.lib

PRECOMPILED_INCLUDE = ..\pch.cpp

DELAYLOAD = user32.dll
DLOAD_ERROR_HANDLER = Downlevel_DelayLoadFailureHook
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\main.hpp ===
//----------------------------------------------------------------------------
//
// Command-line parsing and main routine.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __MAIN_HPP__
#define __MAIN_HPP__

#define MAX_INPUT_NESTING 32
#define MAX_DUMP_FILES 64

enum
{
    IO_CONSOLE,
    IO_DEBUG,
    IO_DEBUG_DEFER,
    IO_NONE,
};

extern BOOL g_RemoteClient;
extern BOOL g_DetachOnExitRequired;
extern BOOL g_DetachOnExitImplied;
extern BOOL g_SetInterruptAfterStart;

extern PVOID g_DumpFiles[MAX_DUMP_FILES];
extern PSTR g_DumpFilesAnsi[MAX_DUMP_FILES];
extern ULONG g_NumDumpFiles;
extern PVOID g_DumpInfoFiles[MAX_DUMP_FILES];
extern ULONG g_DumpInfoTypes[MAX_DUMP_FILES];
extern ULONG g_NumDumpInfoFiles;
extern PSTR g_InitialCommand;
extern PSTR g_ConnectOptions;
extern PVOID g_CommandLinePtr;
extern ULONG g_CommandLineCharSize;
extern PSTR g_RemoteOptions;
extern PSTR g_ProcessServer;
extern PSTR g_ProcNameToDebug;

extern ULONG g_IoRequested;
extern ULONG g_IoMode;
extern ULONG g_CreateFlags;
extern ULONG g_AttachKernelFlags;
extern ULONG g_PidToDebug;
extern ULONG g_AttachProcessFlags;

extern PSTR g_DebuggerName;
extern PSTR g_InitialInputFile;
extern FILE* g_InputFile;
extern FILE* g_OldInputFiles[];
extern ULONG g_NextOldInputFile;

void ExecuteCmd(PSTR Cmd, char CmdExtra, char Sep, PSTR Args);

#endif // #ifndef __MAIN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\pch.cpp ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windows.h>
#include <dbghelp.h>
#define INITGUID
#include <dbgeng.h>

#include <dhhelp.h>
#include <cmnutil.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\ocakd\ocakd.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    ocakd.h

Abstract:
    header for ocakd

Environment:

    User Mode.

--*/


#include "pch.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\ini.hpp ===
//----------------------------------------------------------------------------
//
// .ini file support.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef _INI_HPP_
#define _INI_HPP_

#define INI_DIR         "Init"
#define INI_FILE        "\\TOOLS.INI"

#define NTINI_DEBUGCHILDREN         1
#define NTINI_DEBUGOUTPUT           2
#define NTINI_STOPFIRST             3
#define NTINI_VERBOSEOUTPUT         4
#define NTINI_LAZYLOAD              5
#define NTINI_TRUE                  6
#define NTINI_FALSE                 7
#define NTINI_USERREG0              8
#define NTINI_USERREG1              9
#define NTINI_USERREG2              10
#define NTINI_USERREG3              11
#define NTINI_USERREG4              12
#define NTINI_USERREG5              13
#define NTINI_USERREG6              14
#define NTINI_USERREG7              15
#define NTINI_USERREG8              16
#define NTINI_USERREG9              17
#define NTINI_STOPONPROCESSEXIT     18
#define NTINI_SXD                   19
#define NTINI_SXE                   20
#define NTINI_INIFILE               21
#define NTINI_DEFAULTEXT            22
#define NTINI_LINES                 23
#define NTINI_SRCOPT                24
#define NTINI_SRCPATHA              25
#define NTINI_INVALID               26
#define NTINI_END                   27

void ReadIniFile(PULONG DebugType);

#endif // #ifndef _INI_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\ocakd\ocakd.cpp ===
//----------------------------------------------------------------------------
//
// Debug engine glue.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "main.hpp"

#include "extsfns.h"
#include "..\..\exts\extdll\crdb.h"
#include <strsafe.h>
// To get _open to work
#include <crt\io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>



PCHAR
GetLogFileName(
    void
    )
{
    static CHAR szLogFileName[MAX_PATH+50];
    PCHAR ExeDir;

    ExeDir = &szLogFileName[0];

    *ExeDir = 0;
    // Get the directory the debugger executable is in.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH))
    {
        // Error.  Use the current directory.
        StringCchCopy(ExeDir, sizeof(szLogFileName), ".");
    } else
    {
        // Remove the executable name.
        PCHAR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }
    }
    StringCchCat(ExeDir, sizeof(szLogFileName), "\\FailedAddCrash.log");
    return &szLogFileName[0];

}

HRESULT
NotifyCallerMQ(
    ULONG SourceId,
    PCHAR szBaseURL,
    PCHAR szGuid,
    PCHAR szMQConnectStr
    )
{
    HRESULT Hr;
    typedef HRESULT (WINAPI* MQSENDMSGPROC)(LPWSTR, LPWSTR, LPWSTR);
    MQSENDMSGPROC pSendMQMessageText;
    CHAR MQExtPath[MAX_PATH], *pBase;
    HMODULE hMod;
    WCHAR wszGuid[50], wszMQConnectStr[100];
    WCHAR wszMQMessage[300], wszSolnParams[] = L"";


    if ((StringCbPrintfW(wszGuid, sizeof(wszGuid), L"%S", szGuid) != S_OK) ||
        (StringCbPrintfW(wszMQConnectStr, sizeof(wszMQConnectStr), L"%S", szMQConnectStr) != S_OK) ||
        (StringCbPrintfW(wszMQMessage, sizeof(wszMQMessage), L"%Ssid=-1&State=0", szBaseURL) != S_OK))
    {
        return E_FAIL;
    }
    if (SourceId == CiSrcCER)
    {
        Hr = StringCbPrintfW(wszMQMessage, sizeof(wszMQMessage),
                             L"%Ssid=-1&State=0&szSBucket=BAD_DUMPFILE&iSBucket=-1&szGBucket=BAD_DUMPFILE&iGBucket=-1&gsid=-1",
                             szBaseURL
                             );
        if (FAILED(Hr))
        {
            return E_FAIL;
        }
    }


    if (!GetModuleFileName(NULL, MQExtPath, sizeof(MQExtPath)))
    {
        return E_FAIL;
    }

    pBase = strrchr(MQExtPath, '\\');
    if (!pBase)
    {
        return E_FAIL;
    }
    *pBase = '\0';
    Hr = StringCchCat(MQExtPath, sizeof(MQExtPath), "\\winext\\mqext.dll");
    if (FAILED(Hr))
    {
        return Hr;
    }
    hMod = LoadLibrary(MQExtPath);

    if (hMod == NULL)
    {
        return E_FAIL;
    }
    if ((pSendMQMessageText = (MQSENDMSGPROC) GetProcAddress(hMod, "_EFN_SendMQMessageText")) != NULL)
    {
        return pSendMQMessageText(wszMQConnectStr, wszGuid, wszMQMessage);
    }
    FreeLibrary(hMod);
    return S_OK;
}

void
UpdateDbForBadDumpFile(PSTR FilePath)
{
    HANDLE hFile;
    HMODULE Ext = NULL;
    CHAR ExtCommand[MAX_PATH], *CmdBreak;
    CI_SOURCE Source = CiSrcErClient;
    CRASH_INSTANCE Crash = {0};
    BOOL NoUpdateCustomer = FALSE;
    DBADDCRACHDIRECT FuncAddCrash;
    DEBUG_TRIAGE_FOLLOWUP_INFO UrlInfo;
    CHAR szURL[100];
    EXT_TRIAGE_FOLLOWUP pTriageFollowup;
    CHAR szGuid[50] = {0}, szMQConnectStr[100] = {0};
    PCHAR args;

    // Load ext.dll

    Ext = LoadLibrary("winext\\ext.dll");
    if (!Ext)
    {
        ConOut("Cannot load ext.dll.\n");
    }

    if (!g_InitialCommand)
    {
        goto error;
    }

    StringCchCopy(ExtCommand, sizeof(ExtCommand), g_InitialCommand);
    CmdBreak = strchr(ExtCommand, ';');
    if (CmdBreak)
    {
        *CmdBreak = 0;

    }
    args = strstr(ExtCommand, "!dbaddcrash");
    if (!args)
    {
        goto error;
    }
    args+=11;
    while (*args)
    {
        if (*args ==  ' ' || *args == '\t')
        {
            ++args;
            continue;
        }
        else if (*args == '-' || *args == '/')
        {
            ++args;
            switch (*args)
            {
            case 'g': // GUID identifying this crash, return bucket along with this
                ++args;
                while (*args == ' ') ++args;
                if (!sscanf(args,"%50s", szGuid))
                {
                    szGuid[0] = 0;
                }
                args+=strlen(szGuid);
                break;
            case 'm':
                if (!strncmp(args, "mail", 4))
                {
                    Crash.bSendMail = TRUE;
                    args+=4;
                }
                break;
            case 'n':
                if (!strncmp(args, "nocust", 6))
                {
                    NoUpdateCustomer = TRUE;
                    Crash.bUpdateCustomer = FALSE;
                    args+=6;
                }
                break;
            case 'o':
                ++args;
                break;
            case 'p':
            {
                CHAR Path[240];
                ++args;
                while (*args == ' ') ++args;
                if (!sscanf(args,"%240s", Path))
                {
                    Path[0] = 0;
                }
                args+=strlen(Path);
                break;
            }
            case 'r':
                if (!strncmp(args, "retriage", 8))
                {
                    Crash.bResetBucket = TRUE;
                    args+=8;
                }
                break;
            case 's': // queue connection string to send bucketid back
                if (!strncmp(args, "source", 6))
                {
                    args+=6;
                    while (*args == ' ') ++args;

                    if (isdigit(*args))
                    {
                        Source = (CI_SOURCE) atoi(args);
                        if (Source > (ULONG) CiSrcMax)
                        {
                            Source = CiSrcErClient;
                        }
                        while (isdigit(*args)) ++args;
                    }
                } else
                {
                    ++args;
                    while (*args == ' ') ++args;
                    if (!sscanf(args,"%100s", szMQConnectStr))
                    {
                        szMQConnectStr[0] = 0;
                    }
                    args+=strlen(szMQConnectStr);
                }
                break;
            default:
                ++args;

                while (*args ==  ' ' || *args == '\t' )
                {
                    ++args;
                }
                while (*args && *args != '/' && *args != '-')
                {
                    ++args;
                }
                break;
            }
        }
        else
        {
            break;
        }
    }

    //
    // If the dump file was not visible, then we got passed a bad name or
    // the serve ris down - these are errors that need to be reported.
    //

    hFile = CreateFile(FilePath,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE |
                       FILE_SHARE_DELETE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        Crash.Bucket = "NO_DUMPFILE";
        Crash.DefaultBucket = "NO_DUMPFILE";
    } else
    {
        Crash.Bucket = "BAD_DUMPFILE";
        Crash.DefaultBucket = "BAD_DUMPFILE";
    }

    CloseHandle(hFile);

    ConOut("Running Extension: '%s'\n", ExtCommand);


    FuncAddCrash = (DBADDCRACHDIRECT) GetProcAddress(Ext, "_EFN_DbAddCrashDirect");
    if (!FuncAddCrash)
    {
        ConOut("Cannot find _EFN_DbAddCrashDirect\n");
        goto error;
    }

    // Build CRASH_INSTANCE
    Crash.CrashTime  = -1;
    Crash.UpTime = -1;
    Crash.uCpu = -1;
    Crash.Build = 0;
    Crash.SourceId = Source;
    Crash.Followup = "ignore";
    Crash.Path = g_DumpFilesAnsi[0];
    Crash.FailureType = DEBUG_FLR_KERNEL;
    Crash.StopCode = -1;
    Crash.FaultyDriver = "";
    Crash.MesgGuid = szGuid;
    Crash.MqConnectStr = szMQConnectStr;
    Crash.SolutionId = 79;
    Crash.SolutionType = CiSolFixed;

    if (Crash.bResetBucket && !NoUpdateCustomer)
    {
        // Update customer info for only for retriage
        Crash.bUpdateCustomer = TRUE;
    }
    //
    // Get the failed dump file name
    //

    CHAR DumpFileName[MAX_PATH];

    g_DbgClient4->GetDumpFile(DEBUG_DUMP_FILE_LOAD_FAILED_INDEX,
                              DumpFileName, sizeof(DumpFileName),
                              NULL, NULL, NULL);

    Crash.OriginalDumpFileName = DumpFileName;

    //
    // extract the incident ID from the cab name
    // there are 2 types of filenames we could have to support.
    // The old version is id@*.*
    // The new version is id.*
    //

    CHAR FileName[MAX_PATH];

    if (FAILED(FuncAddCrash(&Crash, g_DbgControl3)))
    {

error:

        ConOut("Dump file could not be processed - logged to %s\n", GetLogFileName());

        szURL[0] = 0;
        pTriageFollowup = (EXT_TRIAGE_FOLLOWUP) GetProcAddress(Ext, "_EFN_GetTriageFollowupFromSymbol");
        if (pTriageFollowup)
        {
            UrlInfo.SizeOfStruct = sizeof(UrlInfo);
            UrlInfo.OwnerName = szURL;
            UrlInfo.OwnerNameSize = sizeof(szURL);
            (*pTriageFollowup)(g_DbgClient, "debugger-params!solutionurl", &UrlInfo);
        }
        if (szURL[0] && szMQConnectStr[0] && szGuid[0])
        {
            NotifyCallerMQ(Source, szURL, szGuid, szMQConnectStr);
        }
        int   g_LogFile;

        g_LogFile = _open(GetLogFileName(), O_APPEND | O_CREAT | O_RDWR,
                          S_IREAD | S_IWRITE);

        if (g_LogFile != -1)
        {
            if (FilePath != NULL)
            {
                _write(g_LogFile, FilePath, strlen(FilePath));
            } else
            {
                _write(g_LogFile, "No File provided", strlen("No File provided"));

            }
            _write(g_LogFile, "\n", strlen("\n"));
            _close(g_LogFile);
        }
    }
    if (Ext)
    {
        FreeLibrary(Ext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\condbg\main.cpp ===
//----------------------------------------------------------------------------
//
// Command-line parsing and main routine.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "ini.hpp"
#include "main.hpp"

// Values set from command-line arguments.
BOOL g_RemoteClient;
BOOL g_DetachOnExitRequired;
BOOL g_DetachOnExitImplied;
BOOL g_SetInterruptAfterStart;

PVOID g_DumpFiles[MAX_DUMP_FILES];
PSTR g_DumpFilesAnsi[MAX_DUMP_FILES];
ULONG g_NumDumpFiles;
PVOID g_DumpInfoFiles[MAX_DUMP_FILES];
ULONG g_DumpInfoTypes[MAX_DUMP_FILES];
ULONG g_NumDumpInfoFiles;
PSTR g_InitialCommand;
PSTR g_ConnectOptions;
PVOID g_CommandLinePtr;
ULONG g_CommandLineCharSize;
PSTR g_RemoteOptions;
PSTR g_ProcessServer;
PSTR g_ProcNameToDebug;

ULONG g_IoRequested = IO_CONSOLE;
ULONG g_IoMode;
ULONG g_CreateFlags = DEBUG_ONLY_THIS_PROCESS;
ULONG g_AttachKernelFlags = DEBUG_ATTACH_KERNEL_CONNECTION;
ULONG g_PidToDebug;
ULONG64 g_EventToSignal;
ULONG g_HistoryLines = 10000;
ULONG g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;

PSTR g_DebuggerName = DEBUGGER_NAME;
PSTR g_InitialInputFile = "ntsd.ini";
FILE* g_InputFile;
FILE* g_OldInputFiles[MAX_INPUT_NESTING];
ULONG g_NextOldInputFile;

// Command line temporaries.
int g_Argc;
PSTR* g_Argv;
PSTR g_CurArg = "program name";
PVOID g_CmdPtrStart, g_CmdPtr, g_PrevCmdPtr;

void
ExecuteCmd(PSTR Cmd, char CmdExtra, char Sep, PSTR Args)
{
    PSTR CmdLine;
    char Buffer[MAX_PATH * 2];

    if (!CopyString(Buffer, Cmd, DIMA(Buffer)))
    {
        return;
    }
    CmdLine = Buffer + strlen(Buffer);
    if (CmdLine + strlen(Args) + 2 > Buffer + sizeof(Buffer))
    {
        ConOut("Command too long\n");
        return;
    }
    if (CmdExtra)
    {
        *CmdLine++ = CmdExtra;
    }
    if (Sep)
    {
        *CmdLine++ = Sep;
    }
    strcpy(CmdLine, Args);

    g_DbgControl->Execute(DEBUG_OUTCTL_IGNORE, Buffer,
                          DEBUG_EXECUTE_NOT_LOGGED);
}

char g_BlanksForPadding[] =
    "                                           "
    "                                           "
    "                                           ";

enum
{
    UM = 1,
    KM = 2,
    AM = 3,
};

struct CMD_OPTION
{
    ULONG Flags;
    PSTR Option;
    PSTR Desc;
};

CMD_OPTION g_CmdOptions[] =
{
    UM, "<command-line>", "command to run under the debugger",
    AM, "-?", "displays command line help text",
    UM, "--", "equivalent to -G -g -o -p -1 -d -pd",
    UM, "-2", "creates a separate console window for debuggee",
    AM, "-a<DllName>", "adds a default extension DLL",
    KM, "-b", "break into kernel when connection is established",
    AM, "-bonc", "request break in after session started",
    AM, "-c \"<command>\"", "executes the given debugger command "
        "at the first debugger prompt",
    AM, "-cf <file>", "specifies a script file to be processed "
        "at the first debugger prompt",
    AM, "-clines <#>",
        "number of lines of output history retrieved by a remote client",
    UM, "-d", "sends all debugger output to kernel debugger via DbgPrint\n"
        "input is requested from the kernel debugger via DbgPrompt\n"
        "-d cannot be used with debugger remoting\n"
        "-d can only be used when the kernel debugger is enabled",
    UM, "-ddefer", "sends all debugger output to kernel debugger "
        "via DbgPrint\n"
        "input is requested from the kernel debugger via DbgPrompt "
        "unless there are remote clients that can provide input\n"
        "-ddefer can only be used when the kernel debugger is enabled\n"
        "-ddefer should be used with -server",
    KM, "-d", "breaks into kernel on first module load",
    AM, "-ee <name>", "set default expression evaluator\n"
        "<name> can be MASM or C++",
    AM, "-failinc", "causes incomplete symbol and module loads to fail",
    UM, "-g", "ignores initial breakpoint in debuggee",
    UM, "-G", "ignores final breakpoint at process termination",
    UM, "-hd", "specifies that the debug heap should not be used "
        "for created processes.  This only works on Windows XP and later",
    AM, "-i <ImagePath>",
        "specifies the location of the executables that generated "
        "the fault (see _NT_EXECUTABLE_IMAGE_PATH)",
    UM, "-isd", "sets the CREATE_IGNORE_SYSTEM_DEFAULT flag in "
        "STARTUPINFO.dwFlags during CreateProcess",
    KM, "-k <Options>",
        "tells the debugger how to connect to the target\n"
        "com:modem connects through a modem\n"
        "com:port=id,baud=rate connects through a COM port\n"
        "    id: com port name, of the form com2 or \\\\.\\com12\n"
        "    rate: valid baudrate value, such as 57600\n"
        "1394:channel=chan connects over 1394\n"
        "     chan: 1394 channel number, must match channel used at boot",
    KM, "-kl", "tell the debugger to connect to the local machine",
    KM, "-kx <Options>",
        "tells the debugger to connect to an eXDI driver",
    AM, "-lines", "requests that line number information be used if present",
    AM, "-loga <logfile>", "appends to a log file",
    AM, "-logo <logfile>", "opens a new log file",
    KM, "-m", "serial port is a modem, watch for carrier detect",
    AM, "-myob", "ignores version mismatches in DBGHELP.DLL",
    AM, "-n", "enables verbose output from symbol handler",
    AM, "-noio", "disables all I/O for dedicated remoting servers",
    AM, "-noshell", "disables the .shell (!!) command",
    UM, "-o", "debugs all processes launched by debuggee",
    UM, "-p <pid>", "specifies the decimal process ID to attach to",
    UM, "-pb", "specifies that the debugger should not break in at attach",
    UM, "-pd", "specifies that the debugger should automatically detach",
    UM, "-pe", "specifies that any attach should be to an existing debug port",
    UM, "-pn <name>", "specifies the name of the process to attach to",
    UM, "-pr", "specifies that the debugger should resume on attach",
    UM, "-premote <transport>:server=<name>,<params>",
        "specifies the process server to connect to\n"
        "transport arguments are given as with remoting",
    UM, "-pt <#>", "specifies the interrupt timeout",
    UM, "-pv", "specifies that any attach should be noninvasive",
    UM, "-pvr",
        "specifies that any attach should be noninvasive and nonsuspending",
    AM, "-QR \\\\<machine>", "queries for remote servers",
    UM, "-r <BreakErrorLevel>",
        "specifies the (0-3) error level to break on (see SetErrorLevel)",
    KM, "-r", "display registers",
    AM, "-remote <transport>:server=<name>,<params>",
        "lets you connect to a debugger session started with -server\n"
        "must be the first argument if present\n"
        "  transport: tcp | npipe | ssl | spipe | 1394 | com\n"
        "  name: machine name on which the debug server was created\n"
        "  params: parameters the debugger server was created with\n"
        "    for tcp use:  port=<socket port #>\n"
        "    for npipe use:  pipe=<name of pipe>\n"
        "    for 1394 use:  channel=<channel #>\n"
        "    for com use:  port=<COM port>,baud=<baud rate>,\n"
        "                  channel=<channel #>\n"
        "    for ssl and spipe see the documentation\n"
        "  example: ... -remote npipe:server=yourmachine,pipe=foobar",
    UM, "-robp", "allows breakpoints to be set in read-only memory",
    UM, "-rtl", "uses RtlCreateUserProcess instead of Win32 CreateProcess",
    AM, "-s", "disables lazy symbol loading",
    AM, "-sdce", "pops up dialogs for critical errors",
    AM, "-secure", "disallows operations dangerous for the host",
    AM, "-server <transport>:<params>",
        "creates a debugger session other people can connect to\n"
        "must be the first argument if present\n"
        "  transport: tcp | npipe | ssl | spipe | 1394 | com\n"
        "  params: connection parameterization\n"
        "    for tcp use:  port=<socket port #>\n"
        "    for npipe use:  pipe=<name of pipe>\n"
        "    for 1394 use:  channel=<channel #>\n"
        "    for com use:  port=<COM port>,baud=<baud rate>,\n"
        "                  channel=<channel #>\n"
        "    for ssl and spipe see the documentation\n"
        "  example: ... -server npipe:pipe=foobar",
    AM, "-ses", "enables strict symbol loading",
    AM, "-sfce", "fails critical errors encountered during file searching",
    AM, "-sflags <flags>", "sets symbol flags from a numeric argument",
    AM, "-sicv", "ignores the CV record when symbol loading",
    AM, "-sins", "ignores the symbol path environment variables",
    AM, "-snc", "converts :: to __ in symbol names",
    AM, "-snul", "disables automatic symbol loading for unqualified names",
    AM, "-srcpath <SourcePath>", "specifies the source search path",
    AM, "-sup", "enables full public symbol searches",
    UM, "-t <PrintErrorLevel>",
        "specifies the (0-3) error level to display (see SetErrorLevel)",
    AM, "-v", "enables verbose output from debugger",
    UM, "-w", "specifies to debug 16 bit applications in a separate VDM",
    AM, "-wake <pid>", "wakes up a sleeping debugger and exits",
    UM, "-x", "sets second-chance break on AV exceptions",
    KM, "-x",
        "same as -b, except uses an initial command of eb NtGlobalFlag 9;g",
    UM, "-x{e|d|n|i} <event>", "sets the break status for the specified event",
    AM, "-y <SymbolsPath>",
        "specifies the symbol search path (see _NT_SYMBOL_PATH)",
    AM, "-z <CrashDmpFile>",
        "specifies the name of a crash dump file to debug",
    AM, "-zp <CrashPageFile>", "specifies the name of a page.dmp file "
        "to use with a crash dump",
};

void
Usage(void)
{
    int i;
    int Width = 78;

    // Dump an initial debug message about the invalid command
    // line.  This will show up on kd if kd is hooked up,
    // handling the case of an ntsd -d with bad parameters
    // where the console may not be useful.
    OutputDebugStringA(g_DebuggerName);
    OutputDebugStringA(": Bad command line: '");
    OutputDebugStringA(GetCommandLineA());
    OutputDebugStringA("'\n");

    ConOut("usage: %s [options]\n", g_DebuggerName);

    ConOut("\nOptions:\n\n");

    for (i = 0; i < DIMA(g_CmdOptions); i++)
    {
        int StartCol;

#ifdef KERNEL
        if (g_CmdOptions[i].Flags == UM)
        {
            continue;
        }
#else
        if (g_CmdOptions[i].Flags == KM)
        {
            continue;
        }
#endif

        ConOut("  %s ", g_CmdOptions[i].Option);
        StartCol = 3 + strlen(g_CmdOptions[i].Option);
        if (StartCol > 30)
        {
            ConOut("\n    ");
            StartCol = 4;
        }

        //
        // Split description up and indent every line.
        //

        int Col;
        PSTR Start, Scan, LastSpace;

        Start = g_CmdOptions[i].Desc;
        for (;;)
        {
            // Scan until we run out of room or hit a newline/end.
            Scan = Start;
            LastSpace = NULL;
            Col = StartCol;
            while (*Scan && *Scan != '\n' && Col < Width)
            {
                if (*Scan == ' ')
                {
                    LastSpace = Scan;
                    while (*(LastSpace + 1) == ' ')
                    {
                        LastSpace++;
                    }
                }
                Scan++;
                Col++;
            }

            if (*Scan && *Scan != '\n')
            {
                Scan = LastSpace;
            }

            ConOut("%.*s\n", (int)(Scan - Start), Start);

            if (!*Scan)
            {
                break;
            }

            ConOut("%.*s", StartCol, g_BlanksForPadding);
            Start = Scan + 1;
        }
    }

    ConOut("\n");

    ConOut("Environment Variables:\n\n");
    ConOut("    _NT_SYMBOL_PATH=[Drive:][Path]\n");
    ConOut("        Specify symbol image path.\n\n");
    ConOut("    _NT_ALT_SYMBOL_PATH=[Drive:][Path]\n");
    ConOut("        Specify an alternate symbol image path.\n\n");
    ConOut("    _NT_DEBUGGER_EXTENSION_PATH=[Drive:][Path]\n");
    ConOut("        Specify a path which should be searched first for extensions dlls\n\n");
    ConOut("    _NT_EXECUTABLE_IMAGE_PATH=[Drive:][Path]\n");
    ConOut("        Specify executable image path.\n\n");
    ConOut("    _NT_SOURCE_PATH=[Drive:][Path]\n");
    ConOut("        Specify source file path.\n\n");
    ConOut("    _NT_DEBUG_LOG_FILE_OPEN=filename\n");
    ConOut("        If specified, all output will be written to this file from offset 0.\n\n");
    ConOut("    _NT_DEBUG_LOG_FILE_APPEND=filename\n");
    ConOut("        If specified, all output will be APPENDed to this file.\n\n");
    ConOut("    _NT_DEBUG_HISTORY_SIZE=size\n");
    ConOut("        Specifies the size of a server's output history in kilobytes\n");

#ifdef KERNEL
    ConOut("    _NT_DEBUG_BUS=1394\n");
    ConOut("        Specifies the type of BUS the kernel debugger will use to communicate with the target\n\n");
    ConOut("    _NT_DEBUG_1394_CHANNEL=number\n");
    ConOut("        Specifies the channel to be used over the 1394 bus\n\n");
    ConOut("    _NT_DEBUG_PORT=com[1|2|...]\n");
    ConOut("        Specify which com port to use. (Default = com1)\n\n");
    ConOut("    _NT_DEBUG_BAUD_RATE=baud rate\n");
    ConOut("        Specify the baud rate used by debugging serial port. (Default = 19200)\n\n");
    ConOut("    _NT_DEBUG_CACHE_SIZE=x\n");
    ConOut("        If specified, gives the number of bytes cached on debugger side\n");
    ConOut("        of kernel debugger serial connection (default is 102400).\n\n");
    ConOut("    KDQUIET=anything\n" );
    ConOut("        If defined, disables obnoxious warning message displayed when user\n");
    ConOut("        presses Ctrl-C\n\n");
#endif

    ConOut("\n");
    ConOut("Control Keys:\n\n");
#ifdef KERNEL
    ConOut("     <Ctrl-A><Enter> Toggle BaudRate\n");
#endif
    ConOut("     <Ctrl-B><Enter> Quit debugger\n");
    ConOut("     <Ctrl-C>        Break into Target\n");
#ifdef KERNEL
    ConOut("     <Ctrl-D><Enter> Display debugger debugging information\n");
    ConOut("     <Ctrl-F><Enter> Force a break into the kernel (same as Ctrl-C)\n");
#else
    ConOut("     <Ctrl-F><Enter> Force a break into debuggee (same as Ctrl-C)\n");
#endif
#ifdef KERNEL
    ConOut("     <Ctrl-K><Enter> Toggle Initial Breakpoint\n");
#endif
    ConOut("     <Ctrl-P><Enter> Debug Current debugger\n");
#ifdef KERNEL
    ConOut("     <Ctrl-R><Enter> Resynchronize target and host\n");
#endif
    ConOut("     <Ctrl-V><Enter> Toggle Verbose mode\n");
    ConOut("     <Ctrl-W><Enter> Print version information\n");
}

void
SkipCommandWhite(void)
{
    if (g_CommandLineCharSize == sizeof(WCHAR))
    {
        while (*(PWSTR)g_CmdPtr == L' ' || *(PWSTR)g_CmdPtr == L'\t')
        {
            g_CmdPtr = (PVOID)((PWSTR)g_CmdPtr + 1);
        }
    }
    else
    {
        while (*(PSTR)g_CmdPtr == ' ' || *(PSTR)g_CmdPtr == '\t')
        {
            g_CmdPtr = (PVOID)((PSTR)g_CmdPtr + 1);
        }
    }
}

PSTR
GetArg(void)
{
    if (g_Argc == 0)
    {
        Usage();
        ErrorExit("Missing argument for %s\n", g_CurArg);
    }

    g_Argc--;
    g_CurArg = *g_Argv;
    g_Argv++;

    //
    // Move forward in the command string to skip over
    // the argument just consumed from argv.  This is complicated
    // by quoting that may be present in the command string
    // that was filtered by the CRT.
    //

    SkipCommandWhite();
    g_PrevCmdPtr = g_CmdPtr;

    int NumSlash;
    BOOL InQuote = FALSE;

    for (;;)
    {
        // Rules: 2N backslashes + " ==> N backslashes and begin/end quote
        // 2N+1 backslashes + " ==> N backslashes + literal "
        // N backslashes ==> N backslashes
        NumSlash = 0;
        while ((g_CommandLineCharSize == sizeof(WCHAR) &&
                *(PWSTR)g_CmdPtr == L'\\') ||
               (g_CommandLineCharSize == sizeof(CHAR) &&
                *(PSTR)g_CmdPtr == '\\'))
        {
            // Count number of backslashes for use below
            g_CmdPtr = (PVOID)((ULONG_PTR)g_CmdPtr + g_CommandLineCharSize);
            ++NumSlash;
        }
        if ((g_CommandLineCharSize == sizeof(WCHAR) &&
             *(PWSTR)g_CmdPtr == L'"') ||
            (g_CommandLineCharSize == sizeof(CHAR) &&
             *(PSTR)g_CmdPtr == '"'))
        {
            // If 2N backslashes before, start/end quote, otherwise
            // copy literally
            if (NumSlash % 2 == 0)
            {
                if (InQuote)
                {
                    if ((g_CommandLineCharSize == sizeof(WCHAR) &&
                         *((PWSTR)g_CmdPtr + 1) == L'"') ||
                        (g_CommandLineCharSize == sizeof(CHAR) &&
                         *((PSTR)g_CmdPtr + 1) == '"'))
                    {
                        // Double quote inside quoted string
                        g_CmdPtr = (PVOID)
                            ((ULONG_PTR)g_CmdPtr + g_CommandLineCharSize);
                    }
                }

                InQuote = !InQuote;
            }
        }

        // If at end of arg, break loop
        if ((g_CommandLineCharSize == sizeof(WCHAR) &&
             (*(PWSTR)g_CmdPtr == 0 ||
              (!InQuote &&
               (*(PWSTR)g_CmdPtr == L' ' || *(PWSTR)g_CmdPtr == L'\t')))) ||
            (g_CommandLineCharSize == sizeof(CHAR) &&
             (*(PSTR)g_CmdPtr == 0 ||
              (!InQuote &&
               (*(PSTR)g_CmdPtr == ' ' && *(PSTR)g_CmdPtr == '\t')))))
        {
            SkipCommandWhite();
            break;
        }

        g_CmdPtr = (PVOID)((ULONG_PTR)g_CmdPtr + g_CommandLineCharSize);
    }

    return g_CurArg;
}

PVOID
GetRawArg(BOOL ForceAnsi, PSTR* AnsiArg)
{
    PSTR Arg = GetArg();

    if (AnsiArg)
    {
        *AnsiArg = Arg;
    }

    if (ForceAnsi || g_CommandLineCharSize == sizeof(CHAR))
    {
        return Arg;
    }

    //
    // We have a Unicode command line and the GetArg
    // call just parsed through an argument on it.  g_PrevCmdPtr
    // points to the first char and g_CmdPtr points to the
    // terminating char.  Strip quotes and force a zero
    // terminator.
    //

    if (g_CmdPtr == g_CmdPtrStart)
    {
        // This shouldn't happen as we think we have an argument.
        ErrorExit("Missing argument for %s\n", g_CurArg);
    }

    PWSTR End = (PWSTR)g_CmdPtr - 1;
    while (*End == L' ' || *End == L'\t')
    {
        End--;
    }

    if (*End == L'"')
    {
        End--;
    }

    *(End + 1) = 0;

    if (*(PWCHAR)g_PrevCmdPtr == L'"')
    {
        return (PWCHAR)g_PrevCmdPtr + 1;
    }
    else
    {
        return g_PrevCmdPtr;
    }
}

void
ParseCommandLine(int Argc, PCHAR* Argv, PVOID CmdPtr)
{
    PSTR Arg;
    BOOL ShowUsage = FALSE;
    ULONG OutMask;
    ULONG SystemErrorBreak;
    ULONG SystemErrorOutput;
    BOOL CheckMoreArgs = FALSE;

    g_Argc = Argc;
    g_Argv = Argv;
    g_CmdPtrStart = CmdPtr;
    g_CmdPtr = g_CmdPtrStart;

    // Skip program name.
    GetArg();

    // Check for remote arguments.  They must
    // be the first arguments if present at all.
    if (g_Argc > 0)
    {
        if (!_strcmpi(*g_Argv, "-remote"))
        {
            GetArg();
            g_RemoteOptions = GetArg();
            g_RemoteClient = TRUE;
            ConnectEngine(g_RemoteOptions);
        }
        else if (!_strcmpi(*g_Argv, "-server"))
        {
            GetArg();
            g_RemoteOptions = GetArg();
        }
    }

    if (g_DbgClient == NULL)
    {
        // We didn't connect to a remote session so create
        // a new local session.
        CreateEngine(g_RemoteOptions);
    }

    if (!g_RemoteClient)
    {
        // Establish defaults.
#ifdef KERNEL
        g_DbgControl->SetEngineOptions(0);
#else
        g_DbgControl->SetEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK |
                                       DEBUG_ENGOPT_FINAL_BREAK);
#endif

        g_DbgSymbols->SetSymbolOptions(SYMOPT_CASE_INSENSITIVE |
                                       SYMOPT_UNDNAME |
                                       SYMOPT_OMAP_FIND_NEAREST |
                                       SYMOPT_DEFERRED_LOADS |
                                       SYMOPT_AUTO_PUBLICS |
                                       SYMOPT_NO_IMAGE_SEARCH |
                                       SYMOPT_FAIL_CRITICAL_ERRORS |
                                       SYMOPT_NO_PROMPTS);

        // Process the ini file for the base settings.
        ReadIniFile(&g_CreateFlags);
    }

    g_DbgClient->GetOutputMask(&OutMask);

    // Now process command line arguments.
    while (g_Argc > 0)
    {
        if (!CheckMoreArgs || !Arg[1])
        {
            Arg = GetArg();

            if (Arg[0] != '-' && Arg[0] != '/')
            {
                // Put argument back.
                g_Argv--;
                g_Argc++;
                g_CmdPtr = g_PrevCmdPtr;
                break;
            }

            // -remote and -server must be the first
            // arguments.  Check for them later to
            // give a specific error message.
            if (!_strcmpi(Arg, "-remote") ||
                !_strcmpi(Arg, "-server"))
            {
                ConOut("%s: %s must be the first argument\n",
                       g_DebuggerName, Arg);
                ShowUsage = TRUE;
                break;
            }
        }

        CheckMoreArgs = FALSE;
        Arg++;

        switch(tolower(Arg[0]))
        {
        case '?':
            ShowUsage = TRUE;
            break;

        case 'a':
            ULONG64 Handle;

            g_DbgControl->AddExtension(Arg + 1, DEBUG_EXTENSION_AT_ENGINE,
                                       &Handle);
            break;

        case 'b':
            if (!_stricmp(Arg, "bonc"))
            {
                g_SetInterruptAfterStart = TRUE;
                break;
            }
#ifdef KERNEL
            else
            {
                g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
                if (g_RemoteClient)
                {
                    // The engine may already be waiting so just ask
                    // for a breakin immediately.
                    g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
                }
                CheckMoreArgs = TRUE;
            }
#endif
            break;

        case 'c':
            if (!_stricmp(Arg, "clines"))
            {
                g_HistoryLines = atoi(GetArg());
            }
            else if (!_stricmp(Arg, "cf"))
            {
                g_InitialInputFile = GetArg();
            }
            else
            {
                g_InitialCommand = GetArg();
            }
            break;

        case 'e':
            if (!_stricmp(Arg, "ee"))
            {
                if (!g_DbgControl3)
                {
                    goto BadSwitch;
                }

                if (g_DbgControl3->
                    SetExpressionSyntaxByName(GetArg()) != S_OK)
                {
                    goto BadSwitch;
                }
            }
            else
            {
#ifndef KERNEL
                //
                // undocumented
                //

                if (g_RemoteClient)
                {
                    goto BadSwitch;
                }

                if (g_EventToSignal)
                {
                    ErrorExit("%s: Event to signal redefined\n",
                              g_DebuggerName);
                }

                // event to signal takes decimal argument
                Arg = GetArg();
                sscanf(Arg, "%I64d", &g_EventToSignal);
                if (!g_EventToSignal)
                {
                    ErrorExit("%s: bad EventToSignal '%s'\n",
                              g_DebuggerName, Arg);
                }
                g_DbgControl->SetNotifyEventHandle(g_EventToSignal);
                break;
#else
                goto BadSwitch;
#endif
            }
            break;

        case 'f':
            if (!_stricmp(Arg, "failinc"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION);
                g_DbgSymbols->
                    AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
            }
            else
            {
                goto BadSwitch;
            }
            break;

        case 'g':
            if (Arg[0] == 'g')
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            CheckMoreArgs = TRUE;
            break;

        case 'i':
            if (!_stricmp(Arg, "isd"))
            {
                g_CreateFlags |= CREATE_IGNORE_SYSTEM_DEFAULT;
            }
            else
            {
                g_DbgSymbols->SetImagePath(GetArg());
            }
            break;

        case 'l':
            if (_stricmp(Arg, "lines") == 0)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);
            }
            else if (!_stricmp(Arg, "loga") ||
                     !_stricmp(Arg, "logo"))
            {
                g_DbgControl->OpenLogFile(GetArg(), Arg[3] == 'a');
            }
            else
            {
                goto BadSwitch;
            }
            break;

        case 'm':
            if (_stricmp(Arg, "myob") == 0)
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION);
            }
#ifdef KERNEL
            else if (Arg[1] == 0 && !g_RemoteClient)
            {
                g_ConnectOptions = "com:modem";
            }
#endif
            else
            {
                goto BadSwitch;
            }
            break;

        case 'n':
            if (_strnicmp (Arg, "netsyms", 7) == 0)
            {
                //
                // undocumented
                // netsyms:{yes|no} allow or disallow loading symbols from a network path
                //

                Arg += 8;  // skip over ':' as well.
                if (_stricmp (Arg, "no") == 0)
                {
                    g_DbgControl->
                        RemoveEngineOptions(DEBUG_ENGOPT_ALLOW_NETWORK_PATHS);
                    g_DbgControl->
                        AddEngineOptions(DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS);
                }
                else if (_stricmp (Arg, "yes") == 0)
                {
                    g_DbgControl->RemoveEngineOptions
                        (DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS);
                    g_DbgControl->
                        AddEngineOptions(DEBUG_ENGOPT_ALLOW_NETWORK_PATHS);
                }
                break;
            }
            else if (g_RemoteOptions != NULL && !g_RemoteClient &&
                     !_stricmp(Arg, "noio"))
            {
                g_IoRequested = IO_NONE;
            }
            else if (!_stricmp(Arg, "noshell"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS);
            }
            else if (Arg[1] == 0)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_DEBUG);
                break;
            }
            else
            {
                goto BadSwitch;
            }
            break;

        case 'q':
            if (Arg[0] != 'Q' || Arg[1] != 'R')
            {
                goto BadSwitch;
            }

            Arg = GetArg();
            ConOut("Servers on %s:\n", Arg);
            if (g_DbgClient->OutputServers(DEBUG_OUTCTL_ALL_CLIENTS, Arg,
                                           DEBUG_SERVERS_ALL) != S_OK)
            {
                ConOut("Unable to query %s\n", Arg);
            }
            ExitDebugger(0);

        case 's':
            if (!_stricmp(Arg, "srcpath"))
            {
                g_DbgSymbols->SetSourcePath(GetArg());
            }
            else if (!_stricmp(Arg, "sdce"))
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
            }
            else if (!_stricmp(Arg, "secure"))
            {
                if (g_DbgSymbols->
                    AddSymbolOptions(SYMOPT_SECURE) != S_OK)
                {
                    ConOut("Unable to secure operation\n");
                    ExitDebugger(0);
                }
            }
            else if (!_stricmp(Arg, "ses"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
            }
            else if (!_stricmp(Arg, "sfce"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
            }
            else if (!_stricmp(Arg, "sflags"))
            {
                g_DbgSymbols->SetSymbolOptions(strtoul(GetArg(), NULL, 0));
            }
            else if (!_stricmp(Arg, "sicv"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_IGNORE_CVREC);
            }
            else if (!_stricmp(Arg, "sins"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_IGNORE_NT_SYMPATH);
            }
            else if (!_stricmp(Arg, "snc"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_NO_CPP);
            }
            else if (!_stricmp(Arg, "snul"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_NO_UNQUALIFIED_LOADS);
            }
            else if (!_stricmp(Arg, "sup"))
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_AUTO_PUBLICS |
                                                  SYMOPT_NO_PUBLICS);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
                CheckMoreArgs = TRUE;
            }
            break;

        case 'v':
            OutMask |= DEBUG_OUTPUT_VERBOSE;
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            CheckMoreArgs = TRUE;
            break;

        case 'y':
            g_DbgSymbols->SetSymbolPath(GetArg());
            break;

        case 'z':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            if (Arg[1] == 'p')
            {
                if (g_NumDumpInfoFiles == MAX_DUMP_FILES)
                {
                    ConOut("%s: Too many dump files, %s ignored\n",
                           g_DebuggerName, GetArg());
                }
                else
                {
                    g_DumpInfoFiles[g_NumDumpInfoFiles] =
                        GetRawArg(!g_CanOpenUnicodeDump, NULL);
                    g_DumpInfoTypes[g_NumDumpInfoFiles] =
                        DEBUG_DUMP_FILE_PAGE_FILE_DUMP;
                    g_NumDumpInfoFiles++;
                }
            }
            else if (Arg[1])
            {
                goto BadSwitch;
            }
            else
            {
                if (g_NumDumpFiles == MAX_DUMP_FILES)
                {
                    ConOut("%s: Too many dump files, %s ignored\n",
                           g_DebuggerName, GetArg());
                }
                else
                {
                    g_DumpFiles[g_NumDumpFiles] =
                        GetRawArg(!g_CanOpenUnicodeDump,
                                  &g_DumpFilesAnsi[g_NumDumpFiles]);
                    g_NumDumpFiles++;
                }
            }
            break;

#ifndef KERNEL
        case '2':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            g_CreateFlags |= CREATE_NEW_CONSOLE;
            break;

        case '-':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            // '--' is the equivalent of -G -g -o -p -1 -netsyms:no -d -pd

            if (g_PidToDebug || g_ProcNameToDebug != NULL)
            {
                ErrorExit("%s: attach process redefined\n", g_DebuggerName);
            }

            g_CreateFlags |= DEBUG_PROCESS;
            g_CreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            g_DbgSymbols->AddSymbolOptions(SYMOPT_DEFERRED_LOADS);
            g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK |
                                              DEBUG_ENGOPT_FINAL_BREAK);
            g_IoRequested = IO_DEBUG;
            g_PidToDebug = CSRSS_PROCESS_ID;
            g_ProcNameToDebug = NULL;
            g_DetachOnExitImplied = TRUE;
            break;

        case 'd':
            if (!g_RemoteClient &&
                !_stricmp(Arg, "ddefer"))
            {
                g_IoRequested = IO_DEBUG_DEFER;
                break;
            }

            if (g_RemoteOptions != NULL)
            {
                ErrorExit("%s: Cannot use -d with debugger remoting\n",
                          g_DebuggerName);
            }

            g_IoRequested = IO_DEBUG;
            CheckMoreArgs = TRUE;
            break;

        case 'h':
            if (Arg[1] == 'd')
            {
                g_CreateFlags |= DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
            }
            else
            {
                goto BadSwitch;
            }
            break;

        case 'o':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            g_CreateFlags |= DEBUG_PROCESS;
            g_CreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            CheckMoreArgs = TRUE;
            break;

        case 'p':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            if (!_stricmp(Arg, "premote"))
            {
                g_ProcessServer = GetArg();
                break;
            }
            else if (Arg[1] == 'b')
            {
                g_AttachProcessFlags |= DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK;
                break;
            }
            else if (Arg[1] == 'd')
            {
                g_DetachOnExitRequired = TRUE;
                break;
            }
            else if (Arg[1] == 'e')
            {
                g_AttachProcessFlags = DEBUG_ATTACH_EXISTING;
                break;
            }
            else if (Arg[1] == 'r')
            {
                g_AttachProcessFlags |= DEBUG_ATTACH_INVASIVE_RESUME_PROCESS;
                break;
            }
            else if (Arg[1] == 't')
            {
                g_DbgControl->SetInterruptTimeout(atoi(GetArg()));
                break;
            }
            else if (Arg[1] == 'v')
            {
                g_AttachProcessFlags = DEBUG_ATTACH_NONINVASIVE;
                if (Arg[2] == 'r')
                {
                    g_AttachProcessFlags |=
                        DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND;
                }
                break;
            }

            if (g_PidToDebug || g_ProcNameToDebug != NULL)
            {
                ErrorExit("%s: attach process redefined\n", g_DebuggerName);
            }

            if (Arg[1] == 'n')
            {
                // Process name.
                g_ProcNameToDebug = GetArg();
                g_PidToDebug = 0;
            }
            else
            {
                // pid debug takes decimal argument
                g_ProcNameToDebug = NULL;

                Arg = GetArg();
                if (Arg[0] == '-' && Arg[1] == '1' && Arg[2] == 0)
                {
                    g_IoRequested = IO_DEBUG;
                    g_PidToDebug = CSRSS_PROCESS_ID;
                }
                else
                {
                    PSTR End;

                    if (Arg[0] == '0' &&
                        (Arg[1] == 'x' || Arg[1] == 'X'))
                    {
                        g_PidToDebug = strtoul(Arg, &End, 0);
                    }
                    else
                    {
                        g_PidToDebug = strtoul(Arg, &End, 10);
                    }
                }

                if (!g_PidToDebug)
                {
                    ErrorExit("%s: bad pid '%s'\n", g_DebuggerName, Arg);
                }
            }
            break;

        case 'r':
            if (!_stricmp(Arg, "robp"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS);
                break;
            }
            else if (!_stricmp(Arg, "rtl"))
            {
                g_CreateFlags |= DEBUG_CREATE_PROCESS_THROUGH_RTL;
                break;
            }
            else if (Arg[1] != 0)
            {
                goto BadSwitch;
            }

            // Rip flags takes single-char decimal argument
            Arg = GetArg();
            SystemErrorBreak = strtoul(Arg, &Arg, 10);
            if (SystemErrorBreak > 3)
            {
                ErrorExit("%s: bad Rip level '%ld'\n",
                          g_DebuggerName, SystemErrorBreak);
                SystemErrorBreak = 0;
            }
            else
            {
                SystemErrorOutput = SystemErrorBreak;
            }
            g_DbgControl->SetSystemErrorControl(SystemErrorOutput,
                                                SystemErrorBreak);
            break;

        case 't':
            // Rip flags takes single-char decimal argument
            Arg = GetArg();
            SystemErrorOutput = strtoul(Arg, &Arg, 10);
            if (SystemErrorOutput > 3)
            {
                ErrorExit("%s: bad Rip level '%ld'\n",
                          g_DebuggerName, SystemErrorOutput);
                SystemErrorOutput = 0;
            }
            g_DbgControl->SetSystemErrorControl(SystemErrorOutput,
                                                SystemErrorBreak);
            break;

        case 'x':
            if (Arg[1] == 0)
            {
                g_DbgControl->Execute(DEBUG_OUTCTL_IGNORE, "sxd av",
                                      DEBUG_EXECUTE_NOT_LOGGED);
            }
            else
            {
                // Turn "-x. arg" into "sx. arg" and execute
                // it to update the engine state.
                ExecuteCmd("sx", Arg[1], ' ', GetArg());
            }
            break;

        case 'w':
            if (!_stricmp(Arg, "wake"))
            {
                ULONG Pid = strtoul(GetArg(), &Arg, 10);
                if (!SetPidEvent(Pid, OPEN_EXISTING))
                {
                    ErrorExit("Process %d is not a sleeping debugger\n", Pid);
                }
                else
                {
                    ExitDebugger(0);
                }
            }

            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            g_CreateFlags |= CREATE_SEPARATE_WOW_VDM;
            CheckMoreArgs = TRUE;
            break;

#else // #ifndef KERNEL

        case 'd':
            g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_MODULE_BREAK);
            CheckMoreArgs = TRUE;
            break;

        case 'k':
            if (tolower(Arg[1]) == 'l')
            {
                g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
            }
            else if (tolower(Arg[1]) == 'x')
            {
                g_AttachKernelFlags = DEBUG_ATTACH_EXDI_DRIVER;
                g_ConnectOptions = GetArg();
            }
            else
            {
                g_ConnectOptions = GetArg();
            }
            break;

        case 'p':
            goto BadSwitch;

        case 'r':
            OutMask ^= DEBUG_OUTPUT_PROMPT_REGISTERS;
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            CheckMoreArgs = TRUE;
            break;

        case 'w':
            if (!_stricmp(Arg, "wake"))
            {
                ULONG Pid = strtoul(GetArg(), &Arg, 10);
                if (!SetPidEvent(Pid, OPEN_EXISTING))
                {
                    ErrorExit("Process %d is not a sleeping debugger\n", Pid);
                }
                else
                {
                    ExitDebugger(0);
                }
            }
            goto BadSwitch;

        case 'x':
            g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            g_InitialCommand = "eb nt!NtGlobalFlag 9;g";
            CheckMoreArgs = TRUE;
            break;

#endif // #ifndef KERNEL

        default:
        BadSwitch:
            ConOut("%s: Invalid switch '%c'\n", g_DebuggerName, Arg[0]);
            ShowUsage = TRUE;
            break;
        }
    }

#ifndef KERNEL
    if (g_RemoteClient)
    {
        if (g_Argc > 0)
        {
            ShowUsage = TRUE;
        }
    }
    else if (g_Argc > 0)
    {
        // Assume remaining arguments are a process execution
        // command line.
        g_CommandLinePtr = g_CmdPtr;
    }
    else if ((g_PidToDebug == 0) && (g_ProcNameToDebug == NULL) &&
             (g_NumDumpFiles == 0))
    {
        // User-mode debuggers require a dump file,
        // process attachment or created process.
        ShowUsage = TRUE;
    }
#else
    if (g_Argc > 0)
    {
        // Kernel debuggers can't start user-mode processes.
        ShowUsage = TRUE;
    }
#endif

    if (ShowUsage)
    {
        Usage();
        ErrorExit(NULL);
    }
}

int
__cdecl
main (
    int Argc,
    PCHAR* Argv
    )
{
    HRESULT Hr;
    PVOID CmdPtr;

    MakeHelpFileName("debugger.chm");

    CmdPtr = GetCommandLineW();
    if (CmdPtr)
    {
        g_CommandLineCharSize = sizeof(WCHAR);
    }
    else
    {
        CmdPtr = GetCommandLineA();
        g_CommandLineCharSize = sizeof(CHAR);
    }
    ParseCommandLine(Argc, Argv, CmdPtr);

    InitializeIo(g_InitialInputFile);

#ifndef KERNEL
    if (g_NumDumpFiles == 0)
    {
        // Increase the priority for live debugging so
        // that the debugger is responsive for break-in.
        SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    }
#endif

    g_IoMode = g_IoRequested;
    switch(g_IoMode)
    {
    case IO_DEBUG:
    case IO_DEBUG_DEFER:
        if (g_DbgClient2 != NULL)
        {
            if (g_DbgClient2->IsKernelDebuggerEnabled() != S_OK)
            {
                Usage();
                ErrorExit(NULL);
            }
        }

        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        break;

    case IO_CONSOLE:
        CreateConsole();
        break;
    }

    if (g_IoMode != IO_NONE)
    {
        // XXX drewb - Win9x doesn't support named pipes so
        // the separate input thread currently can't be used.
        // This makes remoting work very poorly and so should
        // be fixed by creating a simple internal pipe implementation.
        if (g_PlatformId == VER_PLATFORM_WIN32_NT)
        {
            // Don't bother creating a separate thread for non-remoted
            // ntsd and cdb.  This avoids problems with .remote
            // and multiple threads reading the console.
#ifndef KERNEL
            if (g_RemoteOptions != NULL)
#endif
            {
                CreateInputThread();
            }
        }
        else if (g_RemoteOptions != NULL)
        {
            ErrorExit("Remoting with I/O is "
                      "not currently supported on Win9x\n");
        }
    }

    if (!g_RemoteClient)
    {
        if (g_RemoteOptions)
        {
            ConOut("Server started with '%s'\n", g_RemoteOptions);
        }

        InitializeSession();
    }
    else
    {
        ConOut("Connected to server with '%s'\n", g_RemoteOptions);
        // Use a heuristic of 45 characters per line.
        g_DbgClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT,
                                    g_HistoryLines * 45);
    }

    if (g_SetInterruptAfterStart)
    {
        g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
    }

    ULONG Code = S_OK;

    if (MainLoop())
    {
        // The session ended so return the exit code of the
        // last process that exited.
        Code = g_LastProcessExitCode;
    }

    ExitDebugger(Code);
    return Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\cab.cpp ===
//----------------------------------------------------------------------------
//
// CAB file manipulation for dump files and dump CABs.
//
// Copyright (C) Microsoft Corporation, 2001-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"
#pragma hdrstop

#ifndef _WIN32_WCE

#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <share.h>
#include <errno.h>

#include <fci.h>
#include <fdi.h>

#include "cmnutil.hpp"

#define CAB_HR(Code) MAKE_HRESULT(SEVERITY_ERROR, 0xfd1, ((Code) & 0xffff))

HFCI g_AddCab;
ERF g_AddCabErr;
ULONG g_CabTmpSequence;

FNALLOC(CabAlloc)
{
    return malloc(cb);
}

FNFREE(CabFree)
{
    free(pv);
}

PSTR
CabPathTail(PSTR Path)
{
    PSTR Tail = strrchr(Path, '\\');
    if (Tail == NULL)
    {
        Tail = strrchr(Path, '/');
        if (Tail == NULL)
        {
            Tail = strrchr(Path, ':');
        }
    }
    return Tail ? Tail + 1 : Path;
}

//----------------------------------------------------------------------------
//
// Expanding dump files from CAB files.
//
//----------------------------------------------------------------------------

struct FDI_CB_STATE
{
    PSTR DmpFile;
    ULONG DmpFileLen;
    PSTR DstDir;
    ULONG FileFlags;
    INT_PTR DmpFh;
    PCSTR MatchFile;
};

FNOPEN(FdiOpen)
{
    return _open(pszFile, oflag, pmode);
}

FNREAD(FdiRead)
{
    return _read((int)hf, pv, cb);
}

FNWRITE(FdiWrite)
{
    return _write((int)hf, pv, cb);
}

FNCLOSE(FdiClose)
{
    return _close((int)hf);
}

FNSEEK(FdiSeek)
{
    return _lseek((int)hf, dist, seektype);
}

INT_PTR
FdiCommonNotify(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin, BOOL bMatchExt)
{
    FDI_CB_STATE* CbState = (FDI_CB_STATE*)pfdin->pv;
    PSTR Scan;

    switch(fdint)
    {
    case fdintCOPY_FILE:
        if (CbState->DmpFh >= 0)
        {
            return 0;
        }

        // Match the file extension if needed
        Scan = strrchr(pfdin->psz1, '.');
        if (Scan == NULL ||
            (bMatchExt  && (_stricmp(Scan, CbState->MatchFile) != 0)) )
        {
            return 0;
        }

        // Match the file name if if needed
        Scan = CabPathTail(pfdin->psz1);
        if (!bMatchExt && (_stricmp(Scan, CbState->MatchFile) != 0))
        {
            return 0;
        }

        // Add in the process ID to the filename to
        // make it possible to expand the same CAB from
        // multiple processes at once.
        if (*CbState->DstDir)
        {
            if (_snprintf(CbState->DmpFile, CbState->DmpFileLen,
                          "%s\\%08x%x_%s",
                          CbState->DstDir, GetCurrentProcessId(),
                          g_CabTmpSequence++, Scan) < 0)
            {
                return 0;
            }
        }
        else
        {
            if (_snprintf(CbState->DmpFile, CbState->DmpFileLen,
                          "%08x%x_%s",
                          GetCurrentProcessId(), g_CabTmpSequence++,
                          Scan) < 0)
            {
                return 0;
            }
        }

        CbState->DmpFh = FdiOpen(CbState->DmpFile,
                                 _O_BINARY | _O_WRONLY | CbState->FileFlags,
                                 _S_IREAD | _S_IWRITE);
        return CbState->DmpFh;

    case fdintCLOSE_FILE_INFO:
        // Leave the file open.
        return TRUE;
    }

    return 0;
}

FNFDINOTIFY(FdiNotifyFileExt)
{
    return FdiCommonNotify(fdint, pfdin, 1);
}

FNFDINOTIFY(FdiNotifyFileName)
{
    return FdiCommonNotify(fdint, pfdin, 0);
}


HRESULT
ExpandDumpCab(PCSTR CabFile, ULONG FileFlags, PCSTR FileToOpen,
              PSTR DmpFile, ULONG DmpFileLen, INT_PTR* DmpFh)
{
    FDI_CB_STATE CbState;
    HFDI Context;
    ERF Err;
    BOOL Status;
    PSTR Env;

    Env = getenv("TMP");
    if (Env == NULL)
    {
        Env = getenv("TEMP");
        if (Env == NULL)
        {
            Env = "";
        }
    }

    CbState.DmpFile = DmpFile;
    CbState.DmpFileLen = DmpFileLen;
    CbState.DstDir = Env;
    CbState.FileFlags = FileFlags;
    CbState.DmpFh = -1;
    CbState.MatchFile = FileToOpen;

    Context = FDICreate(CabAlloc, CabFree,
                        FdiOpen, FdiRead, FdiWrite, FdiClose, FdiSeek,
                        cpuUNKNOWN, &Err);
    if (Context == NULL)
    {
        return CAB_HR(Err.erfOper);
    }

    if (FileToOpen == NULL)
    {
        // try to open .mdmp or .dmp extension files
        CbState.MatchFile = ".mdmp";
        Status = FDICopy(Context, "", (PSTR)CabFile, 0,
                         FdiNotifyFileExt, NULL, &CbState);

        if (!Status || (CbState.DmpFh < 0))
        {
            CbState.MatchFile = ".dmp";
            Status = FDICopy(Context, "", (PSTR)CabFile, 0,
                             FdiNotifyFileExt, NULL, &CbState);
        }
    } else
    {
        Status = FDICopy(Context, "", (PSTR)CabFile, 0,
                         FdiNotifyFileName, NULL, &CbState);
    }

    if (!Status)
    {
        return CAB_HR(Err.erfOper);
    }

    *DmpFh = CbState.DmpFh;
    return (CbState.DmpFh >= 0) ? S_OK : E_NOINTERFACE;
}


//----------------------------------------------------------------------------
//
// Placing files into a CAB.
//
//----------------------------------------------------------------------------

// We don't really care about specific error codes.
#define CrtErr() EBADF

FNFCIFILEPLACED(FciFilePlaced)
{
    // Not watching for anything.
    return 0;
}

FNFCIGETTEMPFILE(FciGetTempFile)
{
    CHAR TempPath[MAX_PATH];
    DWORD Len;

    Len = GetTempPathA(sizeof(TempPath), TempPath);
    if (Len == 0 || Len >= sizeof(TempPath))
    {
        TempPath[0] = '.';
        TempPath[1] = '\0';
    }

    if (GetTempFileNameA(TempPath, "dbg", 0, pszTempName))
    {
        DeleteFileA(pszTempName);
    }

    return TRUE;
}

FNFCIGETNEXTCABINET(FciGetNextCabinet)
{
    // No multi-cabinet activity expected, just fail.
    return FALSE;
}

FNFCISTATUS(FciStatus)
{
    // No status tracking.
    return TRUE;
}

FNFCIGETOPENINFO(FciGetOpenInfo)
{
    WIN32_FIND_DATAA FindData;
    HANDLE FindHandle;
    FILETIME Local;

    FindHandle = FindFirstFileA(pszName, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE)
    {
        return -1;
    }
    FindClose(FindHandle);

    FileTimeToLocalFileTime(&FindData.ftLastWriteTime, &Local);
    FileTimeToDosDateTime(&Local, pdate, ptime);
    *pattribs = (WORD)(FindData.dwFileAttributes &
                       (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN |
                        FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE));

    return _open(pszName, _O_RDONLY | _O_BINARY);
}

FNFCIOPEN(FciOpen)
{
    int Result;

    Result = _open(pszFile, oflag, pmode);
    if (Result == -1)
    {
        *err = CrtErr();
    }

    return Result;
}

FNFCIREAD(FciRead)
{
    UINT Result;

    Result = (UINT)_read((int)hf, memory, cb);
    if (Result != cb)
    {
        *err = CrtErr();
    }

    return Result;
}

FNFCIWRITE(FciWrite)
{
    UINT Result;

    Result = (UINT)_write((int)hf, memory, cb);
    if (Result != cb)
    {
        *err = CrtErr();
    }

    return Result;
}

FNFCICLOSE(FciClose)
{
    int Result;

    Result = _close((int)hf);
    if (Result == -1)
    {
        *err = CrtErr();
    }

    return Result;
}

FNFCISEEK(FciSeek)
{
    long Result;

    Result = _lseek((int)hf, dist, seektype);
    if (Result == -1)
    {
        *err = CrtErr();
    }

    return Result;
}

FNFCIDELETE(FciDelete)
{
    int Result;

    Result = _unlink(pszFile);
    if (Result == -1)
    {
        *err = CrtErr();
    }

    return Result;
}

HRESULT
CreateDumpCab(PCSTR FileName)
{
    CCAB Cab;
    PSTR Tail;

    if (g_AddCab)
    {
        return E_UNEXPECTED;
    }

    ZeroMemory(&Cab, sizeof(Cab));

    //
    // Split filename into path and tail components
    // for szCabPath and szCab.
    //

    if (!CopyString(Cab.szCabPath, FileName, DIMA(Cab.szCabPath)))
    {
        return E_INVALIDARG;
    }
    Tail = CabPathTail(Cab.szCabPath);
    if (Tail > Cab.szCabPath)
    {
        if (!CopyString(Cab.szCab, Tail, DIMA(Cab.szCab)))
        {
            return E_INVALIDARG;
        }
        *Tail = 0;
    }
    else
    {
        if (!CopyString(Cab.szCab, FileName, DIMA(Cab.szCab)))
        {
            return E_INVALIDARG;
        }
        Cab.szCabPath[0] = 0;
    }

    g_AddCab = FCICreate(&g_AddCabErr, FciFilePlaced, CabAlloc, CabFree,
                         FciOpen, FciRead, FciWrite, FciClose,
                         FciSeek, FciDelete, FciGetTempFile,
                         &Cab, NULL);
    if (!g_AddCab)
    {
        return CAB_HR(g_AddCabErr.erfOper);
    }

    return S_OK;
}

HRESULT
AddToDumpCab(PCSTR FileName)
{
    if (!g_AddCab)
    {
        return E_UNEXPECTED;
    }

    if (!FCIAddFile(g_AddCab, (PSTR)FileName, CabPathTail((PSTR)FileName),
                    FALSE, FciGetNextCabinet, FciStatus,
                    FciGetOpenInfo, tcompTYPE_LZX | tcompLZX_WINDOW_HI))
    {
        return CAB_HR(g_AddCabErr.erfOper);
    }

    return S_OK;
}

void
CloseDumpCab(void)
{
    if (!g_AddCab)
    {
        return;
    }

    FCIFlushCabinet(g_AddCab, FALSE, FciGetNextCabinet, FciStatus);
    FCIDestroy(g_AddCab);
    g_AddCab = NULL;
}

#endif // #ifndef _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\alloc.cpp ===
//----------------------------------------------------------------------------
//
// Specialized allocators.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifdef NT_NATIVE
#include "ntnative.h"
#endif

#include "cmnutil.hpp"
#include "alloc.hpp"

//----------------------------------------------------------------------------
//
// FixedSizeStackAllocator.
//
//----------------------------------------------------------------------------

FixedSizeStackAllocator::FixedSizeStackAllocator(ULONG ChunkSize,
                                                 ULONG ChunksPerBlock,
                                                 BOOL KeepLastBlock)
{
    C_ASSERT((sizeof(FixedSizeStackBlock) & 7) == 0);
    
    if (ChunkSize == 0)
    {
        ChunkSize = sizeof(ULONG64);
    }
    else
    {
        ChunkSize = (ChunkSize + 7) & ~7;
    }
    if (ChunksPerBlock == 0)
    {
        ChunksPerBlock = 32;
    }

    m_ChunkSize = ChunkSize;
    m_KeepLastBlock = KeepLastBlock;
    m_BlockSize = ChunkSize * ChunksPerBlock + sizeof(FixedSizeStackBlock);
    m_NumAllocs = 0;
    m_Blocks = NULL;
}

FixedSizeStackAllocator::~FixedSizeStackAllocator(void)
{
    m_KeepLastBlock = FALSE;
    FreeAll();
}

void
FixedSizeStackAllocator::FreeAll(void)
{
    FixedSizeStackBlock* Block;
    
    while (m_Blocks)
    {
        Block = m_Blocks;
        if (!Block->Next && m_KeepLastBlock)
        {
            Block->MemLimit = (PUCHAR)(Block + 1);
            break;
        }
        
        m_Blocks = m_Blocks->Next;
        RawFree(Block);
    }

    m_NumAllocs = 0;
}

void*
FixedSizeStackAllocator::RawAlloc(ULONG Bytes)
{
    return malloc(Bytes);
}

void
FixedSizeStackAllocator::RawFree(void* Mem)
{
    free(Mem);
}

FixedSizeStackBlock*
FixedSizeStackAllocator::AllocBlock(void)
{
    FixedSizeStackBlock* Block = (FixedSizeStackBlock*)RawAlloc(m_BlockSize);
    if (!Block)
    {
        return NULL;
    }

    Block->Next = m_Blocks;
    Block->MemLimit = (PUCHAR)(Block + 1);
    m_Blocks = Block;
    return Block;
}

void
FixedSizeStackAllocator::FreeBlock(void)
{
    FixedSizeStackBlock* Block = m_Blocks;
    if (!Block->Next && m_KeepLastBlock)
    {
        // Sometimes it's desirable to keep the last block
        // around to avoid forcing an alloc the next time
        // the allocator is used.
        return;
    }
    
    m_Blocks = Block->Next;
    RawFree(Block);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\alloc.hpp ===
//----------------------------------------------------------------------------
//
// Specialized allocators.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __ALLOC_HPP__
#define __ALLOC_HPP__

//----------------------------------------------------------------------------
//
// FixedSizeStackAllocator.
//
// Parcels out memory chunks in strict LIFO allocation order.
// This could easily be generalized to mixed allocation sizes
// but then the size of each allocation would have to be tracked.
//
//----------------------------------------------------------------------------

struct FixedSizeStackBlock
{
    FixedSizeStackBlock* Next;
    PUCHAR MemLimit;
};

class FixedSizeStackAllocator
{
public:
    FixedSizeStackAllocator(ULONG ChunkSize, ULONG ChunksPerBlock,
                            BOOL KeepLastBlock);
    ~FixedSizeStackAllocator(void);

    void* Alloc(void)
    {
        if (!m_Blocks ||
            m_Blocks->MemLimit >= (PUCHAR)m_Blocks + m_BlockSize)
        {
            if (!AllocBlock())
            {
                return NULL;
            }
        }
        
        void* Mem = m_Blocks->MemLimit;
        m_Blocks->MemLimit += m_ChunkSize;
        m_NumAllocs++;
        
        return Mem;
    }
    
    void Free(void* Mem)
    {
        if (!Mem)
        {
            return;
        }

        DBG_ASSERT(m_Blocks->MemLimit - m_ChunkSize == (PUCHAR)Mem);

        m_NumAllocs--;
        m_Blocks->MemLimit = (PUCHAR)Mem;
        if (m_Blocks->MemLimit == (PUCHAR)(m_Blocks + 1))
        {
            FreeBlock();
        }
    }

    void FreeAll(void);

    ULONG NumAllocatedChunks(void)
    {
        return m_NumAllocs;
    }
    
protected:
    // Base methods use malloc/free.
    virtual void* RawAlloc(ULONG Bytes);
    virtual void RawFree(void* Mem);

private:
    FixedSizeStackBlock* AllocBlock(void);
    void FreeBlock(void);
    
    ULONG m_ChunkSize;
    BOOL m_KeepLastBlock;
    ULONG m_BlockSize;
    ULONG m_NumAllocs;
    FixedSizeStackBlock* m_Blocks;
};

#endif // #ifndef __ALLOC_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\cmnutil.hpp ===
//----------------------------------------------------------------------------
//
// General utility routines.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __CMNUTIL_HPP__
#define __CMNUTIL_HPP__

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE 3
#endif

#define AMD_VENDOR_ID_EBX   ('htuA')
#define AMD_VENDOR_ID_EDX   ('itne')
#define AMD_VENDOR_ID_ECX   ('DMAc')

#define INTEL_VENDOR_ID_EBX ('uneG')
#define INTEL_VENDOR_ID_EDX ('Ieni')
#define INTEL_VENDOR_ID_ECX ('letn')

#define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
#define DIMA(Array) DIMAT(Array, (Array)[0])

#define CSRSS_PROCESS_ID ((ULONG)-1)

// Converts an NTSTATUS into an HRESULT with success check.
#define CONV_NT_STATUS(Status) \
    (NT_SUCCESS(Status) ? S_OK : HRESULT_FROM_NT(Status))

// Converts a Win32 status into an HRESULT with a guarantee it's
// an error code.  This avoids problems with routines which
// don't set a last error.
#define WIN32_STATUS(Err) ((Err) == 0 ? E_FAIL : HRESULT_FROM_WIN32(Err))
#define WIN32_LAST_STATUS() WIN32_STATUS(GetLastError())

// Converts a BOOL into an HRESULT with success check.
#define CONV_W32_STATUS(Status) \
    ((Status) ? S_OK : WIN32_LAST_STATUS())

#define COM_THREAD_MODEL COINIT_APARTMENTTHREADED

#include "copystr.h"

//----------------------------------------------------------------------------
//
// Assertions.
//
//----------------------------------------------------------------------------

#if DBG

void DbgAssertionFailed(PCSTR File, int Line, PCSTR Str);

#define DBG_ASSERT(Expr) \
    if (!(Expr)) \
    { \
        DbgAssertionFailed(__FILE__, __LINE__, #Expr); \
    } \
    else 0

#else

#define DBG_ASSERT(Expr)

#endif

//----------------------------------------------------------------------------
//
// COM help.
//
//----------------------------------------------------------------------------

// Wrapper that can be locally implemented if necessary to
// remove usage of ole32.dll on platforms where IsEqualIID
// is not inlined.
#define DbgIsEqualIID(Id1, Id2) \
    IsEqualIID(Id1, Id2)

// Safely releases and NULLs an interface pointer.
#define RELEASE(pUnk) \
    ((pUnk) != NULL ? ((pUnk)->Release(), (pUnk) = NULL) : NULL)

// Transfers an interface pointer into a holder that may or
// may not already hold and interface.
#define TRANSFER(pOld, pNew) \
    (((pNew) != NULL ? (pNew)->AddRef() : 0), \
     ((pOld) != NULL ? (pOld)->Release() : 0), \
     (pOld) = (pNew))

//----------------------------------------------------------------------------
//
// Utility functions.
//
//----------------------------------------------------------------------------

extern PSECURITY_DESCRIPTOR g_AllAccessSecDesc;
extern SECURITY_ATTRIBUTES g_AllAccessSecAttr;

PSTR FormatStatusCode(HRESULT Status);

PSTR FormatAnyStatus(HRESULT Status, PVOID Arguments,
                     PBOOL IsNtStatus, PSTR* ErrorGroup);
#define FormatStatus(Status) \
    FormatAnyStatus(Status, NULL, NULL, NULL)
#define FormatStatusArgs(Status, Args) \
    FormatAnyStatus(Status, Args, NULL, NULL)

BOOL InstallAsAeDebug(PCSTR Append);

HANDLE CreatePidEvent(ULONG Pid, ULONG CreateOrOpen);
BOOL SetPidEvent(ULONG Pid, ULONG CreateOrOpen);

HRESULT EnableDebugPrivilege(void);

HRESULT FillDataBuffer(PVOID Data, ULONG DataLen,
                       PVOID Buffer, ULONG BufferLen, PULONG BufferUsed);
HRESULT FillStringBuffer(PCSTR String, ULONG StringLenIn,
                         PSTR Buffer, ULONG BufferLen, PULONG StringLenOut);
HRESULT AppendToStringBuffer(HRESULT Status, PCSTR String, BOOL First,
                             PSTR* Buffer, ULONG* BufferLen, PULONG LenOut);
HRESULT FillStringBufferW(PCWSTR String, ULONG StringLenIn,
                          PWSTR Buffer, ULONG BufferLen, PULONG StringLenOut);
HRESULT AppendToStringBufferW(HRESULT Status, PCWSTR String, BOOL First,
                              PWSTR* Buffer, ULONG* BufferLen, PULONG LenOut);

PSTR FindPathElement(PSTR Path, ULONG Element, PSTR* EltEnd);

void Win32ToNtTimeout(ULONG Win32Timeout, PLARGE_INTEGER NtTimeout);

HRESULT InitializeAllAccessSecObj(void);
void DeleteAllAccessSecObj(void);

#define BASE_YEAR_ADJUSTMENT 11644473600

// Convert to seconds and then from base year 1601 to base year 1970.
#define FileTimeToTimeDateStamp(FileTime)   \
    (ULONG)(((FileTime) / 10000000) - BASE_YEAR_ADJUSTMENT)

// Adjust date back to 1601 from 1970 and convert to 100 nanoseconds
#define TimeDateStampToFileTime(TimeDate)  \
    (((ULONG64)(TimeDate) + BASE_YEAR_ADJUSTMENT) * 10000000)

// Convert to seconds
#define FileTimeToTime(FileTime)   \
    (ULONG)((FileTime) / 10000000)

// Convert to seconds .
#define TimeToFileTime(TimeDate)   \
    ((ULONG64)(TimeDate) * 10000000)

HRESULT QueryVersionDataBuffer(PVOID VerData, PCSTR Item,
                               PVOID Buffer, ULONG BufferSize,
                               PULONG DataSize);
PVOID GetAllFileVersionInfo(PCWSTR VerFile);
BOOL  GetFileStringFileInfo(PCWSTR VerFile, PCSTR SubItem,
                            PSTR Buffer, ULONG BufferSize);

HRESULT ExpandDumpCab(PCSTR CabFile, ULONG FileFlags, PCSTR FileToOpen,
                      PSTR DmpFile, ULONG DmpFileLen, INT_PTR* DmpFh);

HRESULT CreateDumpCab(PCSTR FileName);
HRESULT AddToDumpCab(PCSTR FileName);
void CloseDumpCab(void);

enum FILE_IO_TYPE
{
    FIO_WIN32,
    FIO_WININET,
};

class PathFile
{
public:
    PathFile(FILE_IO_TYPE IoType)
    {
        m_IoType = IoType;
    }
    virtual ~PathFile(void);

    virtual HRESULT Open(PCSTR PathComponent, PCSTR PathAndFile,
                         ULONG SymOpt) = 0;
    virtual HRESULT QueryDataAvailable(PULONG Avail) = 0;
    virtual HRESULT GetLastWriteTime(PFILETIME Time) = 0;
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done) = 0;

    FILE_IO_TYPE m_IoType;
};

BOOL IsUrlPathComponent(PCSTR Path);

#ifndef NT_NATIVE

BOOL PathFileExists(PCSTR PathComponent, PCSTR PathAndFile,
                    ULONG SymOpt, FILE_IO_TYPE* IoType);
HRESULT OpenPathFile(PCSTR PathComponent, PCSTR PathAndFile,
                     ULONG SymOpt, PathFile** File);

#endif

HRESULT AnsiToWide(PCSTR Ansi, PWSTR* Wide);
void    FreeWide(PCWSTR Wide);
HRESULT WideToAnsi(PCWSTR Wide, PSTR* Ansi);
void    FreeAnsi(PCSTR Ansi);

void ImageNtHdr32To64(PIMAGE_NT_HEADERS32 Hdr32,
                      PIMAGE_NT_HEADERS64 Hdr64);

enum VALUE_FORMAT
{
    VALUE_DEFAULT,
    VALUE_INT8,
    VALUE_UINT8,
    VALUE_INT16,
    VALUE_UINT16,
    VALUE_INT32,
    VALUE_UINT32,
    VALUE_INT64,
    VALUE_UINT64,
    VALUE_FLT32,
    VALUE_FLT64,
};

typedef struct _VALUE_FORMAT_DESC
{
    PSTR Name;
    PSTR FmtStr;
    ULONG Size;
    BOOL Signed;
} VALUE_FORMAT_DESC, *PVALUE_FORMAT_DESC;

void GetValueFormatDesc(VALUE_FORMAT Format, PVALUE_FORMAT_DESC Desc);
PSTR ParseValueFormat(PSTR Str, VALUE_FORMAT* Format, PULONG Elts);
BOOL FormatValue(VALUE_FORMAT Format, PUCHAR Value, ULONG ValSize, ULONG Elts,
                 PSTR Buffer, ULONG BufferChars);

ULONG ProcArchToImageMachine(ULONG ProcArch);
ULONG ImageMachineToProcArch(ULONG ImageMachine);

#endif // #ifndef __CMNUTIL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\cordac.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Fri Sep 06 11:15:44 2002
 */
/* Compiler settings for cordac.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cordac_h__
#define __cordac_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorDataAccessServices_FWD_DEFINED__
#define __ICorDataAccessServices_FWD_DEFINED__
typedef interface ICorDataAccessServices ICorDataAccessServices;
#endif 	/* __ICorDataAccessServices_FWD_DEFINED__ */


#ifndef __ICorDataEnumMemoryRegions_FWD_DEFINED__
#define __ICorDataEnumMemoryRegions_FWD_DEFINED__
typedef interface ICorDataEnumMemoryRegions ICorDataEnumMemoryRegions;
#endif 	/* __ICorDataEnumMemoryRegions_FWD_DEFINED__ */


#ifndef __ICorDataAccess_FWD_DEFINED__
#define __ICorDataAccess_FWD_DEFINED__
typedef interface ICorDataAccess ICorDataAccess;
#endif 	/* __ICorDataAccess_FWD_DEFINED__ */


#ifndef __ICorDataStackWalk_FWD_DEFINED__
#define __ICorDataStackWalk_FWD_DEFINED__
typedef interface ICorDataStackWalk ICorDataStackWalk;
#endif 	/* __ICorDataStackWalk_FWD_DEFINED__ */


#ifndef __ICorDataThreads_FWD_DEFINED__
#define __ICorDataThreads_FWD_DEFINED__
typedef interface ICorDataThreads ICorDataThreads;
#endif 	/* __ICorDataThreads_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cordac_0000 */
/* [local] */ 

#if 0
typedef UINT32 mdToken;

typedef mdToken mdMethodDef;

#endif





typedef ULONG64 CORDATA_ADDRESS;

STDAPI CreateCorDataAccess(REFIID iid, ICorDataAccessServices* services, void** access);
typedef HRESULT (STDAPICALLTYPE* PFN_CreateCorDataAccess)(REFIID iid, ICorDataAccessServices* services, void** access);


extern RPC_IF_HANDLE __MIDL_itf_cordac_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordac_0000_v0_0_s_ifspec;

#ifndef __ICorDataAccessServices_INTERFACE_DEFINED__
#define __ICorDataAccessServices_INTERFACE_DEFINED__

/* interface ICorDataAccessServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDataAccessServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1ecab4f2-1303-4764-b388-f7bfbfa82647")
    ICorDataAccessServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
            /* [out] */ ULONG32 *machine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
            /* [out] */ ULONG32 *size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
            /* [string][in] */ LPCWSTR name,
            /* [out] */ CORDATA_ADDRESS *base) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
            /* [in] */ CORDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 request,
            /* [out] */ ULONG32 *done) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
            /* [in] */ CORDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 request,
            /* [out] */ ULONG32 *done) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTlsValue( 
            /* [in] */ ULONG32 index,
            /* [out] */ CORDATA_ADDRESS *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTlsValue( 
            /* [in] */ ULONG32 index,
            /* [in] */ CORDATA_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadId( 
            /* [out] */ ULONG32 *threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 threadId,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 threadId,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDataAccessServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDataAccessServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDataAccessServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDataAccessServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICorDataAccessServices * This,
            /* [out] */ ULONG32 *machine);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICorDataAccessServices * This,
            /* [out] */ ULONG32 *size);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICorDataAccessServices * This,
            /* [string][in] */ LPCWSTR name,
            /* [out] */ CORDATA_ADDRESS *base);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICorDataAccessServices * This,
            /* [in] */ CORDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 request,
            /* [out] */ ULONG32 *done);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICorDataAccessServices * This,
            /* [in] */ CORDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 request,
            /* [out] */ ULONG32 *done);
        
        HRESULT ( STDMETHODCALLTYPE *GetTlsValue )( 
            ICorDataAccessServices * This,
            /* [in] */ ULONG32 index,
            /* [out] */ CORDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTlsValue )( 
            ICorDataAccessServices * This,
            /* [in] */ ULONG32 index,
            /* [in] */ CORDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadId )( 
            ICorDataAccessServices * This,
            /* [out] */ ULONG32 *threadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDataAccessServices * This,
            /* [in] */ ULONG32 threadId,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDataAccessServices * This,
            /* [in] */ ULONG32 threadId,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        END_INTERFACE
    } ICorDataAccessServicesVtbl;

    interface ICorDataAccessServices
    {
        CONST_VTBL struct ICorDataAccessServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDataAccessServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDataAccessServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDataAccessServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDataAccessServices_GetMachineType(This,machine)	\
    (This)->lpVtbl -> GetMachineType(This,machine)

#define ICorDataAccessServices_GetPointerSize(This,size)	\
    (This)->lpVtbl -> GetPointerSize(This,size)

#define ICorDataAccessServices_GetImageBase(This,name,base)	\
    (This)->lpVtbl -> GetImageBase(This,name,base)

#define ICorDataAccessServices_ReadVirtual(This,address,buffer,request,done)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,request,done)

#define ICorDataAccessServices_WriteVirtual(This,address,buffer,request,done)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,request,done)

#define ICorDataAccessServices_GetTlsValue(This,index,value)	\
    (This)->lpVtbl -> GetTlsValue(This,index,value)

#define ICorDataAccessServices_SetTlsValue(This,index,value)	\
    (This)->lpVtbl -> SetTlsValue(This,index,value)

#define ICorDataAccessServices_GetCurrentThreadId(This,threadId)	\
    (This)->lpVtbl -> GetCurrentThreadId(This,threadId)

#define ICorDataAccessServices_GetThreadContext(This,threadId,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadId,contextFlags,contextSize,context)

#define ICorDataAccessServices_SetThreadContext(This,threadId,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadId,contextSize,context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetMachineType_Proxy( 
    ICorDataAccessServices * This,
    /* [out] */ ULONG32 *machine);


void __RPC_STUB ICorDataAccessServices_GetMachineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetPointerSize_Proxy( 
    ICorDataAccessServices * This,
    /* [out] */ ULONG32 *size);


void __RPC_STUB ICorDataAccessServices_GetPointerSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetImageBase_Proxy( 
    ICorDataAccessServices * This,
    /* [string][in] */ LPCWSTR name,
    /* [out] */ CORDATA_ADDRESS *base);


void __RPC_STUB ICorDataAccessServices_GetImageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_ReadVirtual_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ CORDATA_ADDRESS address,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [in] */ ULONG32 request,
    /* [out] */ ULONG32 *done);


void __RPC_STUB ICorDataAccessServices_ReadVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_WriteVirtual_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ CORDATA_ADDRESS address,
    /* [size_is][in] */ BYTE *buffer,
    /* [in] */ ULONG32 request,
    /* [out] */ ULONG32 *done);


void __RPC_STUB ICorDataAccessServices_WriteVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetTlsValue_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ ULONG32 index,
    /* [out] */ CORDATA_ADDRESS *value);


void __RPC_STUB ICorDataAccessServices_GetTlsValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_SetTlsValue_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ ULONG32 index,
    /* [in] */ CORDATA_ADDRESS value);


void __RPC_STUB ICorDataAccessServices_SetTlsValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetCurrentThreadId_Proxy( 
    ICorDataAccessServices * This,
    /* [out] */ ULONG32 *threadId);


void __RPC_STUB ICorDataAccessServices_GetCurrentThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_GetThreadContext_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICorDataAccessServices_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccessServices_SetThreadContext_Proxy( 
    ICorDataAccessServices * This,
    /* [in] */ ULONG32 threadId,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICorDataAccessServices_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDataAccessServices_INTERFACE_DEFINED__ */


#ifndef __ICorDataEnumMemoryRegions_INTERFACE_DEFINED__
#define __ICorDataEnumMemoryRegions_INTERFACE_DEFINED__

/* interface ICorDataEnumMemoryRegions */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDataEnumMemoryRegions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b09a7a62-dc77-4e5a-96c6-3ae64870d3cc")
    ICorDataEnumMemoryRegions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion( 
            /* [in] */ CORDATA_ADDRESS address,
            /* [in] */ ULONG32 size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDataEnumMemoryRegionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDataEnumMemoryRegions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDataEnumMemoryRegions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDataEnumMemoryRegions * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegion )( 
            ICorDataEnumMemoryRegions * This,
            /* [in] */ CORDATA_ADDRESS address,
            /* [in] */ ULONG32 size);
        
        END_INTERFACE
    } ICorDataEnumMemoryRegionsVtbl;

    interface ICorDataEnumMemoryRegions
    {
        CONST_VTBL struct ICorDataEnumMemoryRegionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDataEnumMemoryRegions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDataEnumMemoryRegions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDataEnumMemoryRegions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDataEnumMemoryRegions_EnumMemoryRegion(This,address,size)	\
    (This)->lpVtbl -> EnumMemoryRegion(This,address,size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDataEnumMemoryRegions_EnumMemoryRegion_Proxy( 
    ICorDataEnumMemoryRegions * This,
    /* [in] */ CORDATA_ADDRESS address,
    /* [in] */ ULONG32 size);


void __RPC_STUB ICorDataEnumMemoryRegions_EnumMemoryRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDataEnumMemoryRegions_INTERFACE_DEFINED__ */


#ifndef __ICorDataAccess_INTERFACE_DEFINED__
#define __ICorDataAccess_INTERFACE_DEFINED__

/* interface ICorDataAccess */
/* [unique][uuid][object] */ 

typedef 
enum CorDataStackWalkFlags
    {	DAC_STACK_ALL_FRAMES	= 0,
	DAC_STACK_COR_FRAMES	= 0x1,
	DAC_STACK_COR_METHOD_FRAMES	= 0x2
    } 	CorDataStackWalkFlags;

typedef 
enum CorDataEnumMemoryFlags
    {	DAC_ENUM_MEM_DEFAULT	= 0
    } 	CorDataEnumMemoryFlags;


EXTERN_C const IID IID_ICorDataAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6222a81f-3aab-4926-a583-8495743523fb")
    ICorDataAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCorCode( 
            /* [in] */ CORDATA_ADDRESS address) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILOffsetFromTargetAddress( 
            /* [in] */ CORDATA_ADDRESS address,
            /* [out] */ CORDATA_ADDRESS *moduleBase,
            /* [out] */ mdMethodDef *methodDef,
            /* [out] */ ULONG32 *offset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeSymbolForTargetAddress( 
            /* [in] */ CORDATA_ADDRESS address,
            /* [size_is][string][out] */ LPWSTR symbol,
            /* [in] */ ULONG32 symbolChars,
            /* [out] */ CORDATA_ADDRESS *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStackWalk( 
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ CorDataStackWalkFlags flags,
            /* [out] */ ICorDataStackWalk **walk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegions( 
            /* [in] */ ICorDataEnumMemoryRegions *callback,
            /* [in] */ CorDataEnumMemoryFlags flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDataAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDataAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDataAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDataAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            ICorDataAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsCorCode )( 
            ICorDataAccess * This,
            /* [in] */ CORDATA_ADDRESS address);
        
        HRESULT ( STDMETHODCALLTYPE *GetILOffsetFromTargetAddress )( 
            ICorDataAccess * This,
            /* [in] */ CORDATA_ADDRESS address,
            /* [out] */ CORDATA_ADDRESS *moduleBase,
            /* [out] */ mdMethodDef *methodDef,
            /* [out] */ ULONG32 *offset);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeSymbolForTargetAddress )( 
            ICorDataAccess * This,
            /* [in] */ CORDATA_ADDRESS address,
            /* [size_is][string][out] */ LPWSTR symbol,
            /* [in] */ ULONG32 symbolChars,
            /* [out] */ CORDATA_ADDRESS *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *StartStackWalk )( 
            ICorDataAccess * This,
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ CorDataStackWalkFlags flags,
            /* [out] */ ICorDataStackWalk **walk);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegions )( 
            ICorDataAccess * This,
            /* [in] */ ICorDataEnumMemoryRegions *callback,
            /* [in] */ CorDataEnumMemoryFlags flags);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICorDataAccess * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        END_INTERFACE
    } ICorDataAccessVtbl;

    interface ICorDataAccess
    {
        CONST_VTBL struct ICorDataAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDataAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDataAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDataAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDataAccess_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define ICorDataAccess_IsCorCode(This,address)	\
    (This)->lpVtbl -> IsCorCode(This,address)

#define ICorDataAccess_GetILOffsetFromTargetAddress(This,address,moduleBase,methodDef,offset)	\
    (This)->lpVtbl -> GetILOffsetFromTargetAddress(This,address,moduleBase,methodDef,offset)

#define ICorDataAccess_GetCodeSymbolForTargetAddress(This,address,symbol,symbolChars,displacement)	\
    (This)->lpVtbl -> GetCodeSymbolForTargetAddress(This,address,symbol,symbolChars,displacement)

#define ICorDataAccess_StartStackWalk(This,corThreadId,flags,walk)	\
    (This)->lpVtbl -> StartStackWalk(This,corThreadId,flags,walk)

#define ICorDataAccess_EnumMemoryRegions(This,callback,flags)	\
    (This)->lpVtbl -> EnumMemoryRegions(This,callback,flags)

#define ICorDataAccess_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDataAccess_Flush_Proxy( 
    ICorDataAccess * This);


void __RPC_STUB ICorDataAccess_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_IsCorCode_Proxy( 
    ICorDataAccess * This,
    /* [in] */ CORDATA_ADDRESS address);


void __RPC_STUB ICorDataAccess_IsCorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_GetILOffsetFromTargetAddress_Proxy( 
    ICorDataAccess * This,
    /* [in] */ CORDATA_ADDRESS address,
    /* [out] */ CORDATA_ADDRESS *moduleBase,
    /* [out] */ mdMethodDef *methodDef,
    /* [out] */ ULONG32 *offset);


void __RPC_STUB ICorDataAccess_GetILOffsetFromTargetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_GetCodeSymbolForTargetAddress_Proxy( 
    ICorDataAccess * This,
    /* [in] */ CORDATA_ADDRESS address,
    /* [size_is][string][out] */ LPWSTR symbol,
    /* [in] */ ULONG32 symbolChars,
    /* [out] */ CORDATA_ADDRESS *displacement);


void __RPC_STUB ICorDataAccess_GetCodeSymbolForTargetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_StartStackWalk_Proxy( 
    ICorDataAccess * This,
    /* [in] */ ULONG32 corThreadId,
    /* [in] */ CorDataStackWalkFlags flags,
    /* [out] */ ICorDataStackWalk **walk);


void __RPC_STUB ICorDataAccess_StartStackWalk_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_EnumMemoryRegions_Proxy( 
    ICorDataAccess * This,
    /* [in] */ ICorDataEnumMemoryRegions *callback,
    /* [in] */ CorDataEnumMemoryFlags flags);


void __RPC_STUB ICorDataAccess_EnumMemoryRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataAccess_Request_Proxy( 
    ICorDataAccess * This,
    /* [in] */ ULONG32 reqCode,
    /* [in] */ ULONG32 inBufferSize,
    /* [size_is][in] */ BYTE *inBuffer,
    /* [in] */ ULONG32 outBufferSize,
    /* [size_is][out] */ BYTE *outBuffer);


void __RPC_STUB ICorDataAccess_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDataAccess_INTERFACE_DEFINED__ */


#ifndef __ICorDataStackWalk_INTERFACE_DEFINED__
#define __ICorDataStackWalk_INTERFACE_DEFINED__

/* interface ICorDataStackWalk */
/* [unique][uuid][object] */ 

typedef 
enum CorDataFrameType
    {	DAC_FRAME_UNRECOGNIZED	= 0,
	DAC_FRAME_COR_FRAME	= DAC_FRAME_UNRECOGNIZED + 1,
	DAC_FRAME_COR_METHOD_FRAME	= DAC_FRAME_COR_FRAME + 1
    } 	CorDataFrameType;


EXTERN_C const IID IID_ICorDataStackWalk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e2140180-6101-4b12-beaf-c74dcda31a65")
    ICorDataStackWalk : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCorFrame( 
            /* [out] */ CORDATA_ADDRESS *corFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameDescription( 
            /* [out] */ CorDataFrameType *type,
            /* [size_is][string][out] */ LPWSTR text,
            /* [in] */ ULONG32 textChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFrameContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnwindFrame( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDataStackWalkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDataStackWalk * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDataStackWalk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDataStackWalk * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorFrame )( 
            ICorDataStackWalk * This,
            /* [out] */ CORDATA_ADDRESS *corFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameDescription )( 
            ICorDataStackWalk * This,
            /* [out] */ CorDataFrameType *type,
            /* [size_is][string][out] */ LPWSTR text,
            /* [in] */ ULONG32 textChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameContext )( 
            ICorDataStackWalk * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameContext )( 
            ICorDataStackWalk * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *UnwindFrame )( 
            ICorDataStackWalk * This);
        
        END_INTERFACE
    } ICorDataStackWalkVtbl;

    interface ICorDataStackWalk
    {
        CONST_VTBL struct ICorDataStackWalkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDataStackWalk_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDataStackWalk_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDataStackWalk_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDataStackWalk_GetCorFrame(This,corFrame)	\
    (This)->lpVtbl -> GetCorFrame(This,corFrame)

#define ICorDataStackWalk_GetFrameDescription(This,type,text,textChars)	\
    (This)->lpVtbl -> GetFrameDescription(This,type,text,textChars)

#define ICorDataStackWalk_GetFrameContext(This,contextSize,context)	\
    (This)->lpVtbl -> GetFrameContext(This,contextSize,context)

#define ICorDataStackWalk_SetFrameContext(This,contextSize,context)	\
    (This)->lpVtbl -> SetFrameContext(This,contextSize,context)

#define ICorDataStackWalk_UnwindFrame(This)	\
    (This)->lpVtbl -> UnwindFrame(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDataStackWalk_GetCorFrame_Proxy( 
    ICorDataStackWalk * This,
    /* [out] */ CORDATA_ADDRESS *corFrame);


void __RPC_STUB ICorDataStackWalk_GetCorFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataStackWalk_GetFrameDescription_Proxy( 
    ICorDataStackWalk * This,
    /* [out] */ CorDataFrameType *type,
    /* [size_is][string][out] */ LPWSTR text,
    /* [in] */ ULONG32 textChars);


void __RPC_STUB ICorDataStackWalk_GetFrameDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataStackWalk_GetFrameContext_Proxy( 
    ICorDataStackWalk * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICorDataStackWalk_GetFrameContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataStackWalk_SetFrameContext_Proxy( 
    ICorDataStackWalk * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICorDataStackWalk_SetFrameContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataStackWalk_UnwindFrame_Proxy( 
    ICorDataStackWalk * This);


void __RPC_STUB ICorDataStackWalk_UnwindFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDataStackWalk_INTERFACE_DEFINED__ */


#ifndef __ICorDataThreads_INTERFACE_DEFINED__
#define __ICorDataThreads_INTERFACE_DEFINED__

/* interface ICorDataThreads */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDataThreads;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24d34d86-52fc-4e64-b2fb-f4d14070ae44")
    ICorDataThreads : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCorThread( 
            /* [out] */ ULONG32 *corThreadId,
            /* [out] */ CORDATA_ADDRESS *corThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberCorThreads( 
            /* [out] */ ULONG32 *numThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCorThreads( 
            /* [in] */ CORDATA_ADDRESS startThread,
            /* [out] */ ULONG32 *corThreadId,
            /* [out] */ ULONG32 *runningOnSysThreadId,
            /* [out] */ CORDATA_ADDRESS *nextThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCorThreadContext( 
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCorThreadContext( 
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDataThreadsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDataThreads * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDataThreads * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDataThreads * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentCorThread )( 
            ICorDataThreads * This,
            /* [out] */ ULONG32 *corThreadId,
            /* [out] */ CORDATA_ADDRESS *corThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberCorThreads )( 
            ICorDataThreads * This,
            /* [out] */ ULONG32 *numThreads);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCorThreads )( 
            ICorDataThreads * This,
            /* [in] */ CORDATA_ADDRESS startThread,
            /* [out] */ ULONG32 *corThreadId,
            /* [out] */ ULONG32 *runningOnSysThreadId,
            /* [out] */ CORDATA_ADDRESS *nextThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetCorThreadContext )( 
            ICorDataThreads * This,
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetCorThreadContext )( 
            ICorDataThreads * This,
            /* [in] */ ULONG32 corThreadId,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        END_INTERFACE
    } ICorDataThreadsVtbl;

    interface ICorDataThreads
    {
        CONST_VTBL struct ICorDataThreadsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDataThreads_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDataThreads_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDataThreads_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDataThreads_GetCurrentCorThread(This,corThreadId,corThread)	\
    (This)->lpVtbl -> GetCurrentCorThread(This,corThreadId,corThread)

#define ICorDataThreads_GetNumberCorThreads(This,numThreads)	\
    (This)->lpVtbl -> GetNumberCorThreads(This,numThreads)

#define ICorDataThreads_EnumCorThreads(This,startThread,corThreadId,runningOnSysThreadId,nextThread)	\
    (This)->lpVtbl -> EnumCorThreads(This,startThread,corThreadId,runningOnSysThreadId,nextThread)

#define ICorDataThreads_GetCorThreadContext(This,corThreadId,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetCorThreadContext(This,corThreadId,contextFlags,contextSize,context)

#define ICorDataThreads_SetCorThreadContext(This,corThreadId,contextSize,context)	\
    (This)->lpVtbl -> SetCorThreadContext(This,corThreadId,contextSize,context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDataThreads_GetCurrentCorThread_Proxy( 
    ICorDataThreads * This,
    /* [out] */ ULONG32 *corThreadId,
    /* [out] */ CORDATA_ADDRESS *corThread);


void __RPC_STUB ICorDataThreads_GetCurrentCorThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataThreads_GetNumberCorThreads_Proxy( 
    ICorDataThreads * This,
    /* [out] */ ULONG32 *numThreads);


void __RPC_STUB ICorDataThreads_GetNumberCorThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataThreads_EnumCorThreads_Proxy( 
    ICorDataThreads * This,
    /* [in] */ CORDATA_ADDRESS startThread,
    /* [out] */ ULONG32 *corThreadId,
    /* [out] */ ULONG32 *runningOnSysThreadId,
    /* [out] */ CORDATA_ADDRESS *nextThread);


void __RPC_STUB ICorDataThreads_EnumCorThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataThreads_GetCorThreadContext_Proxy( 
    ICorDataThreads * This,
    /* [in] */ ULONG32 corThreadId,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICorDataThreads_GetCorThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDataThreads_SetCorThreadContext_Proxy( 
    ICorDataThreads * This,
    /* [in] */ ULONG32 corThreadId,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICorDataThreads_SetCorThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDataThreads_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\cmnutil.cpp ===
//----------------------------------------------------------------------------
//
// General utility routines.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifndef _WIN32_WCE
#include <common.ver>
#include <dbghelp.h>
#else
#include <winver.h>
#define VER_VERSION_TRANSLATION 0x0000, 0x04B0
#endif

#include <wininet.h>
#include <lmerr.h>
#include "symsrv.h"

#define NTDLL_APIS
#include "dllimp.h"
#include "cmnutil.hpp"

#ifdef NT_NATIVE
#include "ntnative.h"
#endif

#define COPYSTR_MOD 
#include "copystr.h"

// Formatted codes are pretty small and there's usually only
// one in a message.
#define MAX_FORMAT_CODE_STRINGS 2
#define MAX_FORMAT_CODE_BUFFER 64

char g_FormatCodeBuffer[MAX_FORMAT_CODE_STRINGS][MAX_FORMAT_CODE_BUFFER];
ULONG g_NextFormatCodeBuffer = MAX_FORMAT_CODE_STRINGS;

// Security attributes with a NULL DACL to explicitly
// allow anyone access.
PSECURITY_DESCRIPTOR g_AllAccessSecDesc;
SECURITY_ATTRIBUTES g_AllAccessSecAttr;

PSTR
FormatStatusCode(HRESULT Status)
{
    PSTR Buf;
    DWORD Len = 0;

    g_NextFormatCodeBuffer = (g_NextFormatCodeBuffer + 1) &
        (MAX_FORMAT_CODE_STRINGS - 1);
    Buf = g_FormatCodeBuffer[g_NextFormatCodeBuffer];

    if ((LONG)Status & FACILITY_NT_BIT)
    {
        sprintf(Buf, "NTSTATUS 0x%08X", Status & ~FACILITY_NT_BIT);
    }
    else if (HRESULT_FACILITY(Status) == FACILITY_WIN32)
    {
        sprintf(Buf, "Win32 error %d", HRESULT_CODE(Status));
    }
    else
    {
        sprintf(Buf, "HRESULT 0x%08X", Status);
    }

    return Buf;
}

#ifndef NT_NATIVE

// Generally there's only one status per output message so
// only keep space for a small number of strings.  Each string
// can be verbose plus it can contain inserts which may be large
// so each string buffer needs to be roomy.
#define MAX_FORMAT_STATUS_STRINGS 2
#define MAX_FORMAT_STATUS_BUFFER 1024

char g_FormatStatusBuffer[MAX_FORMAT_STATUS_STRINGS][MAX_FORMAT_STATUS_BUFFER];
ULONG g_NextFormatStatusBuffer = MAX_FORMAT_STATUS_STRINGS;

PSTR
FormatAnyStatus(HRESULT Status, PVOID Arguments,
                PBOOL IsNtStatus, PSTR* ErrorGroup)
{
    PSTR Buf;
    DWORD Len = 0;
    PVOID Source;
    PSTR SourceDll;
    DWORD Flags;
    BOOL _IsNtStatus = FALSE;
    PSTR _ErrorGroup;
    BOOL FreeLib = FALSE;

    g_NextFormatStatusBuffer = (g_NextFormatStatusBuffer + 1) &
        (MAX_FORMAT_STATUS_STRINGS - 1);
    Buf = g_FormatStatusBuffer[g_NextFormatStatusBuffer];

    // By default, get error text from the system error list.
    Flags = FORMAT_MESSAGE_FROM_SYSTEM;

    // If this is an NT code and ntdll is around,
    // allow messages to be retrieved from it also.
    if ((IsNtStatus && *IsNtStatus) ||
        ((ULONG)Status & FACILITY_NT_BIT) ||
        ((ULONG)Status & 0xc0000000) == 0xc0000000)
    {
        Status &= ~FACILITY_NT_BIT;
        _IsNtStatus = TRUE;
        _ErrorGroup = "NTSTATUS";
        SourceDll = "ntdll.dll";
    }
    else if ((ULONG)Status >= NERR_BASE && (ULONG)Status <= MAX_NERR)
    {
        _ErrorGroup = "NetAPI";
        SourceDll = "netmsg.dll";
    }
    else if (((ULONG)Status >= WSABASEERR &&
              (ULONG)Status <= WSABASEERR + 150) ||
             ((ULONG)Status >= WSABASEERR + 1000 &&
              (ULONG)Status <= WSABASEERR + 1050))
    {
        _ErrorGroup = "WinSock";
        SourceDll = "wsock32.dll";
    }
    else
    {
        _ErrorGroup = ((ULONG)Status & 0x80000000) ? "HRESULT" : "Win32";
        SourceDll = NULL;
    }

    if (IsNtStatus)
    {
        *IsNtStatus = _IsNtStatus;
    }
    if (ErrorGroup)
    {
        *ErrorGroup = _ErrorGroup;
    }

    // Use the currently loaded DLL if possible, otherwise load it.
    if (SourceDll)
    {
        if (!(Source = (PVOID)GetModuleHandle(SourceDll)))
        {
            Source = (PVOID)LoadLibrary(SourceDll);
            FreeLib = TRUE;
        }
        if (Source)
        {
            Flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    else
    {
        Source = NULL;
    }

    // If the caller passed in arguments allow format inserts
    // to be processed.
    if (Arguments != NULL)
    {
        Len = FormatMessage(Flags | FORMAT_MESSAGE_ARGUMENT_ARRAY, Source,
                            Status, 0, Buf, MAX_FORMAT_STATUS_BUFFER,
                            (va_list*)Arguments);
    }

    // If no arguments were passed or FormatMessage failed when
    // used with arguments try it without format inserts.
    if (Len == 0)
    {
        PMESSAGE_RESOURCE_ENTRY MessageEntry;

        MessageEntry = NULL;
        if (Source &&
            g_NtDllCalls.RtlFindMessage &&
            NT_SUCCESS(g_NtDllCalls.
                       RtlFindMessage(Source, PtrToUlong(RT_MESSAGETABLE),
                                      0, (ULONG)Status, &MessageEntry)) &&
            MessageEntry)
        {
            if (MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)
            {
                _snprintf(Buf, MAX_FORMAT_STATUS_BUFFER,
                          "%ws", (PWSTR)MessageEntry->Text);
                Buf[MAX_FORMAT_STATUS_BUFFER - 1] = 0;
            }
            else
            {
                CopyString(Buf, (PSTR)MessageEntry->Text,
                           MAX_FORMAT_STATUS_BUFFER);
            }

            Len = strlen(Buf);
        }
        else
        {
            Len = FormatMessage(Flags | FORMAT_MESSAGE_IGNORE_INSERTS, Source,
                                Status, 0, Buf, MAX_FORMAT_STATUS_BUFFER,
                                NULL);
        }
    }

    if (Source && FreeLib)
    {
        FreeLibrary((HMODULE)Source);
    }

    if (Len > 0)
    {
        PSTR Scan;

        //
        // Eliminate unprintable characters and trim trailing spaces.
        //

        Scan = Buf;
        while (*Scan)
        {
            if (!isprint(*Scan))
            {
                *Scan = ' ';
            }

            Scan++;
        }

        while (Len > 0 && isspace(Buf[Len - 1]))
        {
            Buf[--Len] = 0;
        }
    }

    if (Len > 0)
    {
        return Buf;
    }
    else
    {
        return "<Unable to get error code text>";
    }
}

HINSTANCE g_hsrv = 0;
HTTPOPENFILEHANDLE g_httpOpenFileHandle = NULL;
HTTPQUERYDATAAVAILABLE g_httpQueryDataAvailable = NULL;
HTTPREADFILE g_httpReadFile = NULL;
HTTPCLOSEHANDLE g_httpCloseHandle;

BOOL
HttpOpenFileHandle(
    IN  LPCSTR prefix,
    IN  LPCSTR fullpath,
    IN  DWORD  options,
    OUT HINTERNET *hsite,
    OUT HINTERNET *hfile
    )
{
    BOOL   rc = FALSE;
    CHAR   buf[_MAX_PATH];
    LPSTR  site;
    LPSTR  path;

    if (!g_hsrv)
    {
        g_hsrv = LoadLibrary("symsrv.dll");
        g_httpOpenFileHandle = (HTTPOPENFILEHANDLE)GetProcAddress(g_hsrv, "httpOpenFileHandle");
        if (!g_httpOpenFileHandle)
        {
            g_hsrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
        g_httpQueryDataAvailable = (HTTPQUERYDATAAVAILABLE)GetProcAddress(g_hsrv, "httpQueryDataAvailable");
        if (!g_httpQueryDataAvailable)
        {
            g_hsrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
        g_httpReadFile = (HTTPREADFILE)GetProcAddress(g_hsrv, "httpReadFile");
        if (!g_httpReadFile)
        {
            g_hsrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
        g_httpCloseHandle = (HTTPCLOSEHANDLE)GetProcAddress(g_hsrv, "httpCloseHandle");
        if (!g_httpCloseHandle)
        {
            g_hsrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
    }

    if (!g_httpOpenFileHandle)
    {
        return rc;
    }

    CopyString(buf, fullpath, DIMA(buf));
    if (prefix && *prefix)
    {
        if (!strstr(buf, prefix))
        {
            return rc;
        }
        site = buf;
        path = buf + strlen(prefix);
        *path++ = 0;
    }
    else
    {
        site = NULL;
        path = buf;
    }

    rc = g_httpOpenFileHandle(site, path, options, hsite, hfile);
    if (!rc)
    {
        if (GetLastError() == ERROR_INVALID_NAME)
        {
            g_hsrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            g_httpOpenFileHandle = NULL;
        }
    }

    return rc;
}

BOOL
InstallAsAeDebug(PCSTR Append)
{
    PCSTR KeyName;
    HKEY Key;
    LONG Status;
    char Value[MAX_PATH * 2];

    Value[0] = '"';
        
    if (GetModuleFileName(NULL, Value + 1, DIMA(Value) - 1) == 0)
    {
        return FALSE;
    }

    if (!CatString(Value, "\" -p %ld -e %ld -g", DIMA(Value)))
    {
        return FALSE;
    }

    if (Append != NULL)
    {
        if (!CatString(Value, " ", DIMA(Value)) ||
            !CatString(Value, Append, DIMA(Value)))
        {
            return FALSE;
        }
    }

    // AeDebug is always under Windows NT even on Win9x.
    KeyName = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug";

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KeyName,
                            0, NULL, 0, KEY_READ | KEY_WRITE, NULL,
                            &Key, NULL);
    if (Status == ERROR_SUCCESS)
    {
        Status = RegSetValueEx(Key, "Debugger", 0, REG_SZ,
                               (PUCHAR)Value, strlen(Value) + 1);
        if (Status == ERROR_SUCCESS)
        {
            Status = RegSetValueEx(Key, "Auto", 0, REG_SZ,
                                   (PUCHAR)"1", 2);
        }
        RegCloseKey(Key);
    }

    return Status == ERROR_SUCCESS;
}

HANDLE
CreatePidEvent(ULONG Pid, ULONG CreateOrOpen)
{
    HANDLE Event;
    char Name[32];

    sprintf(Name, "DbgEngEvent_%08X", Pid);
    Event = CreateEvent(NULL, FALSE, FALSE, Name);
    if (Event != NULL)
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
            if (CreateOrOpen == CREATE_NEW)
            {
                CloseHandle(Event);
                Event = NULL;
            }
        }
        else if (CreateOrOpen == OPEN_EXISTING)
        {
            CloseHandle(Event);
            Event = NULL;
        }
    }
    return Event;
}

BOOL
SetPidEvent(ULONG Pid, ULONG CreateOrOpen)
{
    BOOL Status;
    HANDLE Event = CreatePidEvent(Pid, CreateOrOpen);
    if (Event != NULL)
    {
        Status = SetEvent(Event);
        CloseHandle(Event);
    }
    else
    {
        Status = FALSE;
    }
    return Status;
}

HRESULT
EnableDebugPrivilege(void)
{
    OSVERSIONINFO OsVer;

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (!GetVersionEx(&OsVer))
    {
        return WIN32_LAST_STATUS();
    }
    if (OsVer.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        return S_OK;
    }

#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT           Status = S_OK;
    HANDLE            Token;
    PTOKEN_PRIVILEGES NewPrivileges;
    LUID              LuidPrivilege;
    static            s_PrivilegeEnabled = FALSE;

    if (s_PrivilegeEnabled)
    {
        return S_OK;
    }

    //
    // Make sure we have access to adjust and to get the
    // old token privileges
    //
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &Token))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Exit;
    }

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege);

    NewPrivileges = (PTOKEN_PRIVILEGES)
        calloc(1, sizeof(TOKEN_PRIVILEGES) +
               (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Token;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    if (!AdjustTokenPrivileges( Token, FALSE,
                                NewPrivileges, 0, NULL, NULL ))
    {
        Status = WIN32_LAST_STATUS();
    }

    free(NewPrivileges);
 EH_Token:
    CloseHandle(Token);
 EH_Exit:
    if (Status == S_OK)
    {
        s_PrivilegeEnabled = TRUE;
    }
    return Status;
#endif // #ifdef _WIN32_WCE
}

#else // #ifndef NT_NATIVE

HRESULT
EnableDebugPrivilege(void)
{
    HRESULT           Status = S_OK;
    HANDLE            Token;
    PTOKEN_PRIVILEGES NewPrivileges;
    LUID              LuidPrivilege;
    NTSTATUS          NtStatus;
    static            s_PrivilegeEnabled = FALSE;

    if (s_PrivilegeEnabled)
    {
        return S_OK;
    }

    //
    // Make sure we have access to adjust and to get the
    // old token privileges
    //
    if (!NT_SUCCESS(NtStatus =
                    NtOpenProcessToken(NtCurrentProcess(),
                                       TOKEN_ADJUST_PRIVILEGES,
                                       &Token)))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Exit;
    }

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(SE_DEBUG_PRIVILEGE);

    NewPrivileges = (PTOKEN_PRIVILEGES)
        RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY,
                        sizeof(TOKEN_PRIVILEGES) +
                        (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Token;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    if (!NT_SUCCESS(NtStatus =
                    NtAdjustPrivilegesToken(Token,
                                            FALSE,
                                            NewPrivileges,
                                            0, NULL, NULL)))
    {
        Status = HRESULT_FROM_NT(NtStatus);
    }

    free(NewPrivileges);
 EH_Token:
    NtClose(Token);
 EH_Exit:
    if (Status == S_OK)
    {
        s_PrivilegeEnabled = TRUE;
    }
    return Status;
}

#endif // #ifndef NT_NATIVE

//
// Copies the input data to the output buffer.
// Handles optionality of the buffer pointer and output length
// parameter.  Trims the data to fit the buffer.
// Returns S_FALSE if only a part of the data is copied.
//
HRESULT
FillDataBuffer(PVOID Data, ULONG DataLen,
               PVOID Buffer, ULONG BufferLen, PULONG BufferUsed)
{
    ULONG Len;
    HRESULT Status;

    if (DataLen > BufferLen && Buffer != NULL)
    {
        Len = BufferLen;
        Status = S_FALSE;
    }
    else
    {
        Len = DataLen;
        Status = S_OK;
    }

    if (Buffer != NULL && BufferLen > 0 && Data != NULL && Len > 0)
    {
        memcpy(Buffer, Data, Len);
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = DataLen;
    }

    return Status;
}

//
// Copies the input string to the output buffer.
// Handles optionality of the buffer pointer and output length
// parameter.  Trims the string to fit the buffer and guarantees
// termination of the string in the buffer if anything fits.
// Returns S_FALSE if only a partial string is copied.
//
// If the input string length is zero the routine strlens.
//
HRESULT
FillStringBuffer(PCSTR String, ULONG StringLenIn,
                 PSTR Buffer, ULONG BufferLen, PULONG StringLenOut)
{
    ULONG Len;
    HRESULT Status;

    if (StringLenIn == 0)
    {
        if (String != NULL)
        {
            StringLenIn = strlen(String) + 1;
        }
        else
        {
            StringLenIn = 1;
        }
    }

    if (BufferLen == 0)
    {
        Len = 0;
        Status = Buffer != NULL ? S_FALSE : S_OK;
    }
    else if (StringLenIn >= BufferLen)
    {
        Len = BufferLen - 1;
        Status = StringLenIn > BufferLen ? S_FALSE : S_OK;
    }
    else
    {
        Len = StringLenIn - 1;
        Status = S_OK;
    }

    if (Buffer != NULL && BufferLen > 0)
    {
        if (String != NULL)
        {
            memcpy(Buffer, String, Len);
        }

        Buffer[Len] = 0;
    }

    if (StringLenOut != NULL)
    {
        *StringLenOut = StringLenIn;
    }

    return Status;
}

HRESULT
AppendToStringBuffer(HRESULT Status, PCSTR String, BOOL First,
                     PSTR* Buffer, ULONG* BufferLen, PULONG LenOut)
{
    ULONG Len = strlen(String) + 1;
    BOOL ForceTerminate;

    if (LenOut)
    {
        // If this is the first string we need to add
        // on space for the terminator.  For later
        // strings we only need to add the string
        // characters.
        *LenOut += First ? Len : Len - 1;
    }

    // If there's no buffer we can skip writeback and pointer update.
    if (!*Buffer || !*BufferLen)
    {
        return Status;
    }

    // Fit as much of the string into the buffer as possible.
    if (Len > *BufferLen)
    {
        Status = S_FALSE;
        Len = *BufferLen - 1;
        ForceTerminate = TRUE;
    }
    else
    {
        ForceTerminate = FALSE;
    }
    memcpy(*Buffer, String, Len);
    if (ForceTerminate)
    {
        (*Buffer)[Len] = 0;
        Len++;
    }

    // Update the buffer pointer to point to the terminator
    // for further appends.  Update the size similarly.
    *Buffer += Len - 1;
    *BufferLen -= Len - 1;

    return Status;
}

HRESULT
FillStringBufferW(PCWSTR String, ULONG StringLenIn,
                  PWSTR Buffer, ULONG BufferLen, PULONG StringLenOut)
{
    ULONG Len;
    HRESULT Status;

    if (StringLenIn == 0)
    {
        if (String != NULL)
        {
            StringLenIn = (wcslen(String) + 1) * sizeof(WCHAR);
        }
        else
        {
            StringLenIn = sizeof(WCHAR);
        }
    }

    // Ignore partial character storage space in the buffer.
    BufferLen &= ~(sizeof(WCHAR) - 1);

    if (BufferLen < sizeof(WCHAR))
    {
        Len = 0;
        Status = Buffer != NULL ? S_FALSE : S_OK;
    }
    else if (StringLenIn >= BufferLen)
    {
        Len = BufferLen - sizeof(WCHAR);
        Status = StringLenIn > BufferLen ? S_FALSE : S_OK;
    }
    else
    {
        Len = StringLenIn - sizeof(WCHAR);
        Status = S_OK;
    }

    if (Buffer != NULL && BufferLen > 0)
    {
        if (String != NULL)
        {
            memcpy(Buffer, String, Len);
        }

        Buffer[Len / sizeof(WCHAR)] = 0;
    }

    if (StringLenOut != NULL)
    {
        *StringLenOut = StringLenIn;
    }

    return Status;
}

HRESULT
AppendToStringBufferW(HRESULT Status, PCWSTR String, BOOL First,
                      PWSTR* Buffer, ULONG* BufferLen, PULONG LenOut)
{
    ULONG Len = (wcslen(String) + 1) * sizeof(WCHAR);

    if (LenOut)
    {
        // If this is the first string we need to add
        // on space for the terminator.  For later
        // strings we only need to add the string
        // characters.
        *LenOut += First ? Len : Len - sizeof(WCHAR);
    }

    // If there's no buffer we can skip writeback and pointer update.
    if (!*Buffer)
    {
        return Status;
    }

    ULONG RoundBufLen = *BufferLen & ~(sizeof(WCHAR) - 1);

    // Fit as much of the string into the buffer as possible.
    if (Len > RoundBufLen)
    {
        Status = S_FALSE;
        Len = RoundBufLen;
    }
    memcpy(*Buffer, String, Len);

    // Update the buffer pointer to point to the terminator
    // for further appends.  Update the size similarly.
    *Buffer += Len / sizeof(WCHAR) - 1;
    *BufferLen -= Len - sizeof(WCHAR);

    return Status;
}

PSTR
FindPathElement(PSTR Path, ULONG Element, PSTR* EltEnd)
{
    PSTR Elt, Sep;

    if (Path == NULL)
    {
        return NULL;
    }

    Elt = Path;
    for (;;)
    {
        Sep = strchr(Elt, ';');
        if (Sep == NULL)
        {
            Sep = Elt + strlen(Elt);
        }

        if (Element == 0)
        {
            break;
        }

        if (*Sep == 0)
        {
            // No more elements.
            return NULL;
        }

        Elt = Sep + 1;
        Element--;
    }

    *EltEnd = Sep;
    return Elt;
}

void
Win32ToNtTimeout(ULONG Win32Timeout, PLARGE_INTEGER NtTimeout)
{
    if (Win32Timeout == INFINITE)
    {
        NtTimeout->LowPart = 0;
        NtTimeout->HighPart = 0x80000000;
    }
    else
    {
        NtTimeout->QuadPart = UInt32x32To64(Win32Timeout, 10000);
        NtTimeout->QuadPart *= -1;
    }
}

HRESULT
InitializeAllAccessSecObj(void)
{
    if (g_AllAccessSecDesc != NULL)
    {
        // Already initialized.
        return S_OK;
    }

#ifdef _WIN32_WCE
    return S_OK;
#else
    HRESULT Status;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID WorldSid;

    if (!AllocateAndInitializeSid(&WorldAuthority, 1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &WorldSid))
    {
        Status = WIN32_LAST_STATUS();
        if (Status == HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED))
        {
            // This platform doesn't support security, such as Win9x.
            return S_OK;
        }

        goto EH_Fail;
    }

    ULONG AclSize;

    AclSize = sizeof(ACL) +
        (sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG)) +
        (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) +
        2 * GetLengthSid(WorldSid);

    g_AllAccessSecDesc =
        (PSECURITY_DESCRIPTOR)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (g_AllAccessSecDesc == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Sid;
    }

    PACL Acl;

    Acl = (PACL)((PUCHAR)g_AllAccessSecDesc + SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!InitializeAcl(Acl, AclSize, ACL_REVISION) ||
        !AddAccessDeniedAce(Acl, ACL_REVISION, WRITE_DAC | WRITE_OWNER,
                            WorldSid) ||
        !AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL,
                             WorldSid) ||
        !InitializeSecurityDescriptor(g_AllAccessSecDesc,
                                      SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorDacl(g_AllAccessSecDesc, TRUE, Acl, FALSE))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Desc;
    }

    FreeSid(WorldSid);

    g_AllAccessSecAttr.nLength = sizeof(g_AllAccessSecAttr);
    g_AllAccessSecAttr.lpSecurityDescriptor = g_AllAccessSecDesc;
    g_AllAccessSecAttr.bInheritHandle = FALSE;

    return S_OK;

 EH_Desc:
    free(g_AllAccessSecDesc);
    g_AllAccessSecDesc = NULL;
 EH_Sid:
    FreeSid(WorldSid);
 EH_Fail:
    return Status;
#endif // #ifdef _WIN32_WCE
}

void
DeleteAllAccessSecObj(void)
{
    free(g_AllAccessSecDesc);
    g_AllAccessSecDesc = NULL;
    ZeroMemory(&g_AllAccessSecAttr, sizeof(g_AllAccessSecAttr));
}

HRESULT
QueryVersionDataBuffer(PVOID VerData, PCSTR Item,
                       PVOID Buffer, ULONG BufferSize, PULONG DataSize)
{
#ifndef NT_NATIVE
    PVOID Val;
    UINT ValSize;

    if (!::VerQueryValue(VerData, (PSTR)Item, &Val, &ValSize))
    {
        return WIN32_LAST_STATUS();
    }
    else if (!ValSize)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_DATA);
    }
    
    return FillDataBuffer(Val, ValSize,
                          Buffer, BufferSize, DataSize);
#else // #ifndef NT_NATIVE
    return E_UNEXPECTED;
#endif // #ifndef NT_NATIVE
}

PVOID
GetAllFileVersionInfo(PCWSTR VerFile)
{
#ifndef NT_NATIVE
    char VerFileA[MAX_PATH];
    DWORD VerHandle;
    DWORD VerSize = ::GetFileVersionInfoSizeW((PWSTR)VerFile, &VerHandle);
    if (VerSize == 0)
    {
        if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED ||
            !WideCharToMultiByte(CP_ACP, 0, VerFile, -1,
                                 VerFileA, sizeof(VerFileA),
                                 NULL, NULL) ||
            !(VerSize = ::GetFileVersionInfoSizeA(VerFileA, &VerHandle)))
        {
            return NULL;
        }
    }
    else
    {
        VerFileA[0] = 0;
    }

    PVOID Buffer = malloc(VerSize);
    if (Buffer == NULL)
    {
        return NULL;
    }

    if ((VerFileA[0] &&
         !::GetFileVersionInfoA(VerFileA, VerHandle, VerSize, Buffer)) ||
        (!VerFileA[0] &&
         !::GetFileVersionInfoW((PWSTR)VerFile, VerHandle, VerSize, Buffer)))
    {
        free(Buffer);
        Buffer = NULL;
    }

    return Buffer;
#else // #ifndef NT_NATIVE
    return NULL;
#endif // #ifndef NT_NATIVE
}

BOOL
GetFileStringFileInfo(PCWSTR VerFile, PCSTR SubItem,
                      PSTR Buffer, ULONG BufferSize)
{
#ifndef NT_NATIVE
    BOOL Status = FALSE;
    PVOID AllInfo = GetAllFileVersionInfo(VerFile);
    if (AllInfo == NULL)
    {
        return Status;
    }

    // XXX drewb - Probably should do a more clever
    // enumeration of languages.
    char ValName[128];
    int PrintChars;
    PrintChars = _snprintf(ValName, DIMA(ValName),
                           "\\StringFileInfo\\%04x%04x\\%s",
                           VER_VERSION_TRANSLATION, SubItem);
    if (PrintChars < 0 || PrintChars == DIMA(ValName))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Status = SUCCEEDED(QueryVersionDataBuffer(AllInfo, ValName,
                                              Buffer, BufferSize, NULL));

    free(AllInfo);
    return Status;
#else // #ifndef NT_NATIVE
    return FALSE;
#endif // #ifndef NT_NATIVE
}

BOOL
IsUrlPathComponent(PCSTR Path)
{
    return
        strncmp(Path, "ftp://", 6) == 0 ||
        strncmp(Path, "http://", 7) == 0 ||
        strncmp(Path, "https://", 8) == 0 ||
        strncmp(Path, "gopher://", 9) == 0;
}

#ifndef NT_NATIVE

BOOL
PathFileExists(PCSTR PathComponent, PCSTR PathAndFile,
               ULONG SymOpt, FILE_IO_TYPE* IoType)
{
    BOOL Exists = FALSE;

    if (IsUrlPathComponent(PathAndFile))
    {
        PathFile* File;

        if (OpenPathFile(PathComponent, PathAndFile, SymOpt, &File) == S_OK)
        {
            *IoType = File->m_IoType;
            delete File;
            Exists = TRUE;
        }
    }
    else
    {
#ifndef _WIN32_WCE
        DWORD OldMode;

        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        }
#endif

        *IoType = FIO_WIN32;
        Exists = GetFileAttributes(PathAndFile) != -1;

#ifndef _WIN32_WCE
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            SetErrorMode(OldMode);
        }
#endif
    }

    return Exists;
}

PathFile::~PathFile(void)
{
}

class Win32PathFile : public PathFile
{
public:
    Win32PathFile(void)
        : PathFile(FIO_WIN32)
    {
        m_Handle = NULL;
    }
    virtual ~Win32PathFile(void)
    {
        if (m_Handle)
        {
            CloseHandle(m_Handle);
        }
    }

    virtual HRESULT Open(PCSTR PathComponent, PCSTR PathAndFile,
                         ULONG SymOpt)
    {
        HRESULT Status;

#ifndef _WIN32_WCE
        DWORD OldMode;

        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        }
#endif

        m_Handle = CreateFile(PathAndFile, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (m_Handle == NULL || m_Handle == INVALID_HANDLE_VALUE)
        {
            m_Handle = NULL;
            Status = WIN32_LAST_STATUS();
        }
        else
        {
            Status = S_OK;
        }

#ifndef _WIN32_WCE
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            SetErrorMode(OldMode);
        }
#endif

        return Status;
    }
    virtual HRESULT QueryDataAvailable(PULONG Avail)
    {
        LARGE_INTEGER Cur, End;

        Cur.HighPart = 0;
        End.HighPart = 0;
        if ((Cur.LowPart =
             SetFilePointer(m_Handle, 0, &Cur.HighPart, FILE_CURRENT)) ==
            INVALID_SET_FILE_POINTER ||
            (End.LowPart =
             SetFilePointer(m_Handle, 0, &End.HighPart, FILE_END)) ==
            INVALID_SET_FILE_POINTER ||
            SetFilePointer(m_Handle, Cur.LowPart, &Cur.HighPart, FILE_BEGIN) ==
            INVALID_SET_FILE_POINTER)
        {
            return WIN32_LAST_STATUS();
        }

        End.QuadPart -= Cur.QuadPart;
        if (End.HighPart < 0)
        {
            // Shouldn't be possible, but check anyway.
            return E_FAIL;
        }

        // Limit max data available to 32-bit quantity.
        if (End.HighPart > 0)
        {
            *Avail = 0xffffffff;
        }
        else
        {
            *Avail = End.LowPart;
        }
        return S_OK;
    }
    virtual HRESULT GetLastWriteTime(PFILETIME Time)
    {
        // If we can't get the write time try and get
        // the create time.
        if (!GetFileTime(m_Handle, NULL, NULL, Time))
        {
            if (!GetFileTime(m_Handle, Time, NULL, NULL))
            {
                return WIN32_LAST_STATUS();
            }
        }

        return S_OK;
    }
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done)
    {
        if (!ReadFile(m_Handle, Buffer, BufferLen, Done, NULL))
        {
            return WIN32_LAST_STATUS();
        }

        return S_OK;
    }

private:
    HANDLE m_Handle;
};

class WinInetPathFile : public PathFile
{
public:
    WinInetPathFile(void)
        : PathFile(FIO_WININET)
    {
        m_SiteHandle = NULL;
        m_Handle = NULL;
        m_InitialDataLen = 0;
    }
    virtual ~WinInetPathFile(void)
    {
        if (m_Handle && g_httpCloseHandle)
        {
            g_httpCloseHandle(m_Handle);
        }
    }

    virtual HRESULT Open(PCSTR PathComponent, PCSTR PathAndFile,
                         ULONG SymOpt)
    {
        HRESULT Status;

        if (!HttpOpenFileHandle(PathComponent, PathAndFile, 0, &m_SiteHandle, &m_Handle))
        {
            Status = WIN32_LAST_STATUS();
            goto Fail;
        }

        return S_OK;

    Fail:
        m_InitialDataLen = 0;

        if (m_Handle && g_httpCloseHandle)
        {
            g_httpCloseHandle(m_Handle);
            m_Handle = NULL;
        }

        return Status;
    }
    virtual HRESULT QueryDataAvailable(PULONG Avail)
    {
        if (m_InitialDataLen > 0)
        {
            *Avail = m_InitialDataLen;
            return S_OK;
        }

        if (!g_httpQueryDataAvailable)
        {
            return ERROR_MOD_NOT_FOUND;
        }
        if (!g_httpQueryDataAvailable(m_Handle, Avail, 0, 0))
        {
            return WIN32_LAST_STATUS();
        }

        return S_OK;
    }
    virtual HRESULT GetLastWriteTime(PFILETIME Time)
    {
        // Don't know of a way to get this.
        return E_NOTIMPL;
    }
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done)
    {
        *Done = 0;

        if (m_InitialDataLen > 0)
        {
            ULONG Len = min(BufferLen, m_InitialDataLen);
            if (Len > 0)
            {
                memcpy(Buffer, m_InitialData, Len);
                Buffer = (PVOID)((PUCHAR)Buffer + Len);
                BufferLen -= Len;
                *Done += Len;
                m_InitialDataLen -= Len;
                if (m_InitialDataLen > 0)
                {
                    memmove(m_InitialData, m_InitialData + Len,
                            m_InitialDataLen);
                }
            }
        }

        if (BufferLen > 0)
        {
            ULONG _Done;

            if (!g_httpReadFile)
            {
                return ERROR_MOD_NOT_FOUND;
            }
            if (!g_httpReadFile(m_Handle, Buffer, BufferLen, &_Done))
            {
                return WIN32_LAST_STATUS();
            }

            *Done += _Done;
        }

        return S_OK;
    }

private:
    HANDLE m_Handle, m_SiteHandle;
    BYTE m_InitialData[16];
    ULONG m_InitialDataLen;
};

HRESULT
OpenPathFile(PCSTR PathComponent, PCSTR PathAndFile,
             ULONG SymOpt, PathFile** File)
{
    HRESULT Status;
    PathFile* Attempt;

    if (IsUrlPathComponent(PathAndFile))
    {
        Attempt = new WinInetPathFile;
    }
    else
    {
        Attempt = new Win32PathFile;
    }

    if (Attempt == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = Attempt->Open(PathComponent, PathAndFile, SymOpt);
        if (Status != S_OK)
        {
            delete Attempt;
        }
        else
        {
            *File = Attempt;
        }
    }

    return Status;
}

#endif // #ifndef NT_NATIVE

HRESULT
AnsiToWide(PCSTR Ansi, PWSTR* Wide)
{
#ifndef NT_NATIVE

    ULONG Len = strlen(Ansi) + 1;
    PWSTR WideBuf = (PWSTR)malloc(Len * sizeof(WCHAR));
    if (WideBuf == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (!MultiByteToWideChar(CP_ACP, 0, Ansi, Len, WideBuf, Len))
    {
        free(WideBuf);
        return WIN32_LAST_STATUS();
    }

    *Wide = WideBuf;
    return S_OK;

#else // #ifndef NT_NATIVE

    NTSTATUS Status;
    STRING AnsiStr;
    UNICODE_STRING UnicodeStr;

    RtlInitString(&AnsiStr, Ansi);
    Status = RtlAnsiStringToUnicodeString(&UnicodeStr, &AnsiStr, TRUE);
    if (!NT_SUCCESS(Status))
    {
        return HRESULT_FROM_NT(Status);
    }

    *Wide = UnicodeStr.Buffer;
    return S_OK;

#endif // #ifndef NT_NATIVE
}

void
FreeWide(PCWSTR Wide)
{
#ifndef NT_NATIVE
    free((PVOID)Wide);
#else
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Wide);
#endif
}

HRESULT
WideToAnsi(PCWSTR Wide, PSTR* Ansi)
{
#ifndef NT_NATIVE

    ULONG Len = wcslen(Wide) + 1;
    // Allow each Unicode character to convert into two multibyte characters.
    PSTR AnsiBuf = (PSTR)malloc(Len * 2);
    if (AnsiBuf == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, Wide, Len, AnsiBuf, Len*2, NULL, NULL))
    {
        free(AnsiBuf);
        return WIN32_LAST_STATUS();
    }

    *Ansi = AnsiBuf;
    return S_OK;

#else // #ifndef NT_NATIVE

    NTSTATUS Status;
    STRING AnsiStr;
    UNICODE_STRING UnicodeStr;

    RtlInitUnicodeString(&UnicodeStr, Wide);
    Status = RtlUnicodeStringToAnsiString(&AnsiStr, &UnicodeStr, TRUE);
    if (!NT_SUCCESS(Status))
    {
        return HRESULT_FROM_NT(Status);
    }

    *Ansi = AnsiStr.Buffer;
    return S_OK;

#endif // #ifndef NT_NATIVE
}

void
FreeAnsi(PCSTR Ansi)
{
#ifndef NT_NATIVE
    free((PVOID)Ansi);
#else
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)Ansi);
#endif
}

void
ImageNtHdr32To64(PIMAGE_NT_HEADERS32 Hdr32,
                 PIMAGE_NT_HEADERS64 Hdr64)
{
#define CP(x) Hdr64->x = Hdr32->x
#define SE64(x) Hdr64->x = (ULONG64) (LONG64) (LONG) Hdr32->x
    ULONG i;

    CP(Signature);
    CP(FileHeader);
    CP(OptionalHeader.Magic);
    CP(OptionalHeader.MajorLinkerVersion);
    CP(OptionalHeader.MinorLinkerVersion);
    CP(OptionalHeader.SizeOfCode);
    CP(OptionalHeader.SizeOfInitializedData);
    CP(OptionalHeader.SizeOfUninitializedData);
    CP(OptionalHeader.AddressOfEntryPoint);
    CP(OptionalHeader.BaseOfCode);
    SE64(OptionalHeader.ImageBase);
    CP(OptionalHeader.SectionAlignment);
    CP(OptionalHeader.FileAlignment);
    CP(OptionalHeader.MajorOperatingSystemVersion);
    CP(OptionalHeader.MinorOperatingSystemVersion);
    CP(OptionalHeader.MajorImageVersion);
    CP(OptionalHeader.MinorImageVersion);
    CP(OptionalHeader.MajorSubsystemVersion);
    CP(OptionalHeader.MinorSubsystemVersion);
    CP(OptionalHeader.Win32VersionValue);
    CP(OptionalHeader.SizeOfImage);
    CP(OptionalHeader.SizeOfHeaders);
    CP(OptionalHeader.CheckSum);
    CP(OptionalHeader.Subsystem);
    CP(OptionalHeader.DllCharacteristics);
    // Sizes are not sign extended, just copied.
    CP(OptionalHeader.SizeOfStackReserve);
    CP(OptionalHeader.SizeOfStackCommit);
    CP(OptionalHeader.SizeOfHeapReserve);
    CP(OptionalHeader.SizeOfHeapCommit);
    CP(OptionalHeader.LoaderFlags);
    CP(OptionalHeader.NumberOfRvaAndSizes);
    for (i = 0; i < DIMA(Hdr32->OptionalHeader.DataDirectory); i++)
    {
        CP(OptionalHeader.DataDirectory[i]);
    }
#undef CP
#undef SE64
}

VALUE_FORMAT_DESC g_ValueFormatDesc[] =
{
    "", "", 0, FALSE,
    "ib", "%d", 1, TRUE, "ub", "%02x", 1, FALSE,
    "iw", "%d", 2, TRUE, "uw", "%04x", 2, FALSE,
    "id", "%d", 4, TRUE, "ud", "%08x", 4, FALSE,
    "iq", "%I64d", 8, TRUE, "uq", "%016I64x", 8, FALSE,
    "f", "%12.6g", 4, TRUE,
    "d", "%22.12g", 8, TRUE,
};

void
GetValueFormatDesc(VALUE_FORMAT Format, PVALUE_FORMAT_DESC Desc)
{
    *Desc = g_ValueFormatDesc[Format];
}

PSTR
ParseValueFormat(PSTR Str, VALUE_FORMAT* Format, PULONG Elts)
{
    VALUE_FORMAT Try;

    while (*Str == ' ' || *Str == '\t')
    {
        Str++;
    }
    
    *Elts = 0;
    while (*Str >= '0' && *Str <= '9')
    {
        *Elts = (*Elts * 10) + (*Str - '0');
        Str++;
    }

    for (Try = VALUE_INT8; Try <= VALUE_FLT64; Try = (VALUE_FORMAT)(Try + 1))
    {
        if (!_stricmp(Str, g_ValueFormatDesc[Try].Name))
        {
            *Format = Try;
            return Str + strlen(g_ValueFormatDesc[Try].Name);
        }
    }

    return NULL;
}

BOOL
FormatValue(VALUE_FORMAT Format, PUCHAR Value, ULONG ValSize, ULONG Elts,
            PSTR Buffer, ULONG BufferChars)
{
    PVALUE_FORMAT_DESC Desc = &g_ValueFormatDesc[Format];
    ULONG i;

    if (!BufferChars)
    {
        return FALSE;
    }

    if (Elts == 0)
    {
        Elts = ValSize / Desc->Size;
    }
    
    // Start at the top of the value so that
    // individual elements come out from high to low.
    Value += Elts * Desc->Size;
    
    for (i = 0; i < Elts; i++)
    {
        PSTR FmtStr;
        ULONG64 RawElt;

        if (i > 0)
        {
            if (!BufferChars)
            {
                return FALSE;
            }

            *Buffer++ = ' ';
            BufferChars--;
        }
        
        Value -= Desc->Size;

        if (Format == VALUE_FLT32)
        {
            // Need to convert to double for printf.
            double Tmp = *(float*)Value;
            RawElt = *(PULONG64)&Tmp;
        }
        else
        {
            RawElt = 0;
            memcpy(&RawElt, Value, Desc->Size);
        }
        
        if (!PrintString(Buffer, BufferChars, Desc->FmtStr, RawElt))
        {
            return FALSE;
        }

        ULONG Len = strlen(Buffer);
        BufferChars -= Len;
        Buffer += Len;
    }

    return TRUE;
}

ULONG
ProcArchToImageMachine(ULONG ProcArch)
{
    switch(ProcArch)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        return IMAGE_FILE_MACHINE_I386;
    case PROCESSOR_ARCHITECTURE_IA64:
        return IMAGE_FILE_MACHINE_IA64;
    case PROCESSOR_ARCHITECTURE_AMD64:
        return IMAGE_FILE_MACHINE_AMD64;
    case PROCESSOR_ARCHITECTURE_ARM:
        return IMAGE_FILE_MACHINE_ARM;
    case PROCESSOR_ARCHITECTURE_ALPHA:
        return IMAGE_FILE_MACHINE_ALPHA;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        return IMAGE_FILE_MACHINE_AXP64;
    default:
        return IMAGE_FILE_MACHINE_UNKNOWN;
    }
}

ULONG
ImageMachineToProcArch(ULONG ImageMachine)
{
    switch(ImageMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return PROCESSOR_ARCHITECTURE_INTEL;
    case IMAGE_FILE_MACHINE_IA64:
        return PROCESSOR_ARCHITECTURE_IA64;
    case IMAGE_FILE_MACHINE_AMD64:
        return PROCESSOR_ARCHITECTURE_AMD64;
    case IMAGE_FILE_MACHINE_ARM:
        return PROCESSOR_ARCHITECTURE_ARM;
    case IMAGE_FILE_MACHINE_ALPHA:
        return PROCESSOR_ARCHITECTURE_ALPHA;
    case IMAGE_FILE_MACHINE_AXP64:
        return PROCESSOR_ARCHITECTURE_ALPHA64;
    default:
        return PROCESSOR_ARCHITECTURE_UNKNOWN;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\arminst.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1997  Microsoft Corporation

Module Name:

    arminst.h

Abstract:

    ARM instruction definitions.

Author:

    Janet Schneider 31-March-1997

Revision History:

--*/

#ifndef _ARMINST_
#define _ARMINST_

//
// Define ARM instruction format structures.
//

#define COND_EQ    0x00000000L // Z set
#define COND_NE    0x10000000L // Z clear
#define COND_CS    0x20000000L // C set    // aka HS
#define COND_CC    0x30000000L // C clear  // aka LO
#define COND_MI    0x40000000L // N set
#define COND_PL    0x50000000L // N clear
#define COND_VS    0x60000000L // V set
#define COND_VC    0x70000000L // V clear
#define COND_HI    0x80000000L // C set and Z clear
#define COND_LS    0x90000000L // C clear or Z set
#define COND_GE    0xa0000000L // N == V
#define COND_LT    0xb0000000L // N != V
#define COND_GT    0xc0000000L // Z clear, and N == V
#define COND_LE    0xd0000000L // Z set, and N != V
#define COND_AL    0xe0000000L // Always execute
#define COND_NV    0xf0000000L // Never - undefined
#define COND_MASK  COND_NV
#define COND_SHIFT 28

#define OP_AND  0x0 // 0000
#define OP_EOR  0x1 // 0001
#define OP_SUB  0x2 // 0010
#define OP_RSB  0x3 // 0011
#define OP_ADD  0x4 // 0100
#define OP_ADC  0x5 // 0101
#define OP_SBC  0x6 // 0110
#define OP_RSC  0x7 // 0111
#define OP_TST  0x8 // 1000
#define OP_TEQ  0x9 // 1001
#define OP_CMP  0xa // 1010
#define OP_CMN  0xb // 1011
#define OP_ORR  0xc // 1100
#define OP_MOV  0xd // 1101
#define OP_BIC  0xe // 1110
#define OP_MVN  0xf // 1111

#define MOV_PC_LR_MASK  0x0de0f00eL // All types of mov - i, is, rs
#define MOV_PC_LR       0x01a0f00eL
#define MOV_PC_X_MASK   0x0de0f000L
#define MOV_PC_X        0x01a0f000L

#define DATA_PROC_MASK  0x0c00f000L
#define DP_PC_INSTR     0x0000f000L // Data process instr w/PC as destination
#define DP_R11_INSTR    0x0000b000L // Data process instr w/R11 as destination

#define ADD_SP_MASK     0x0de0f000L
#define ADD_SP_INSTR    0x0080d000L // Add instr with SP as destination

#define SUB_SP_MASK     0x0de0f000L
#define SUB_SP_INSTR    0x0040d000L // Sub instr with SP as destination

#define BX_MASK         0x0ffffff0L // Branch and exchange instr sets
#define BX_INSTR        0x012fff10L // return (LR) or call (Rn != LR)

#define LDM_PC_MASK     0x0e108000L
#define LDM_PC_INSTR    0x08108000L // Load multiple with PC bit set

#define LDM_LR_MASK     0x0e104000L
#define LDM_LR_INSTR    0x08104000L // Load multiple with LR bit set

#define STRI_LR_SPU_MASK    0x073de000L // Load or Store of LR with stack update
#define STRI_LR_SPU_INSTR   0x052de000L // Store LR (with immediate offset, update SP)

#define STM_MASK        0x0e100000L
#define STM_INSTR       0x08000000L // Store multiple instruction

#define B_BL_MASK       0x0f000000L // Regular branches
#define B_INSTR         0x0a000000L
#define BL_INSTR        0x0b000000L

#define LDR_MASK        0x0f3ff000L
#define LDR_PC_INSTR    0x051fc000L // Load an address from PC + offset to R12
#define LDR_THUNK_1     0xe59fc000L // ldr r12, [pc]
#define LDR_THUNK_2     0xe59cf000L // ldr pc, [r12]

typedef union _ARMI {

    struct {
        ULONG operand2  : 12;
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG s         : 1;
        ULONG opcode    : 4;
        ULONG bits      : 3; // Specifies immediate (001) or register (000)
        ULONG cond      : 4;
    } dataproc; // Data processing, PSR transfer

    struct {
        //
        // Type 1 - Immediate
        //
        ULONG immediate : 8;
        ULONG rotate    : 4;
        ULONG dpbits    : 20;
    } dpi;

    struct {
        //
        //  Form: Shift or rotate by immediate
        //
        //  Type    bits    Name
        //
        //  2       (000)   Register (Shift is 0)
        //  3       (000)   Logical shift left by immediate
        //  5       (010)   Logical shift right by immediate
        //  7       (100)   Arithmetic shift right by immediate
        //  9       (110)   Rotate right by immediate
        //
        ULONG rm        : 4;
        ULONG bits      : 3;
        ULONG shift     : 5;
        ULONG dpbits    : 20;
    } dpshi;

    struct {
        //
        //  Form: Shift or rotate by register
        //
        //  Type    bits    Name
        //  4       (0001)  Logical shift left by register
        //  6       (0011)  Logical shift right by register
        //  8       (0101)  Arithmetic shift right by register
        //  10      (0111)  Rotate right by register
        //
        ULONG rm        : 4;
        ULONG bits      : 4;
        ULONG rs        : 4;
        ULONG dpbits    : 20;
    } dpshr;

    struct {
        //
        //  Type 11 - Rotate right with extended
        //
        ULONG rm        : 4;
        ULONG bits      : 8;    // (00000110)
        ULONG dpbits    : 20;
    } dprre;

    struct {
        ULONG bits1     : 12;   // (000000000000)
        ULONG rd        : 4;
        ULONG bits2     : 6;    // (001111)
        ULONG ps        : 1;    // spsr = 1, cpsr = 0
        ULONG bits3     : 5;    // (00010)
        ULONG cond      : 4;
    } dpmrs;

    struct {
        ULONG operand   : 12;
        ULONG bits1     : 4;   // (1111)
        ULONG fc        : 1;   // control fields = 1
        ULONG fx        : 1;   // extension fields = 1
        ULONG fs        : 1;   // status fields = 1
        ULONG ff        : 1;   // flags fields = 1
        ULONG bits2     : 2;   // (10)
        ULONG pd        : 1;   // spsr = 1, cpsr = 0
        ULONG bits3     : 2;   // (10)
        ULONG i         : 1;   // immedate = 1, register = 0
        ULONG bits4     : 2;   // (00)
        ULONG cond      : 4;
    } dpmsr;

    struct {
        ULONG rm        : 4;
        ULONG bits1     : 8;    // (00001001)
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG bits2     : 2;    // (00)
        ULONG b         : 1;
        ULONG bits3     : 5;    // (00010)
        ULONG cond      : 4;
    } swp;  // Swap instructions
    
    struct {
        ULONG rm        : 4;
        ULONG bits1     : 4;    // (1001)
        ULONG rs        : 4;
        ULONG rn        : 4;
        ULONG rd        : 4;
        ULONG s         : 1;
        ULONG a         : 1;
        ULONG sgn       : 1;
        ULONG lng       : 1;
        ULONG bits2     : 4;    // (0000)
        ULONG cond      : 4;
    } mul;  // Multiply and multiply-accumulate
    
    struct {
        ULONG rn        : 4;
        ULONG bits      : 24;
        ULONG cond      : 4;
    } bx;  // Branch and exchange instruction sets

    struct {
        ULONG offset    : 24;
        ULONG h         : 1;
        ULONG bits      : 7;    // (1111101)
    } blxi;  // blx immediate

    struct {
        ULONG immed1    : 4;
        ULONG bits1     : 4;    // (0111)
        ULONG immed2    : 12;
        ULONG bits2     : 12;   // (111000010010)
    } bkpt;
    
    struct {
        ULONG any1      : 4;
        ULONG bits1     : 1;    // (1)
        ULONG any2      : 20;
        ULONG bits2     : 3;    // (011)
        ULONG cond      : 4;
    } ud;  // Undefined instruction
    
    struct {
        ULONG operand1  : 4;
        ULONG bits1     : 1;    // (1)
        ULONG h         : 1;    // halfword = 1, byte = 0
        ULONG s         : 1;    // signed = 1, unsigned = 0
        ULONG bits2     : 1;    // (1)
        ULONG operand2  : 4;
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG l         : 1;    // load = 1, store = 0
        ULONG w         : 1;    // update base register bit
        ULONG i         : 1;    // immediate = 1, register = 0
        ULONG u         : 1;    // increment = 1, decrement = 0
        ULONG p         : 1;    // pre-indexing = 1, post-indexing = 0
        ULONG bits3     : 3;    // (000)
        ULONG cond      : 4;
    } miscdt;  // Misc data transfer

    struct {
        ULONG offset    : 12;
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG l         : 1;    // load = 1, store = 0
        ULONG w         : 1;    // update base register bit
        ULONG b         : 1;    // unsigned byte = 1, word = 0
        ULONG u         : 1;    // increment = 1, decrement = 0
        ULONG p         : 1;    // pre-indexing = 1, post-indexing = 0
        ULONG i         : 1;    // immediate = 1, register = 0
        ULONG bits      : 2;
        ULONG cond      : 4;
    } ldr;  // Load register

    struct {
        ULONG reglist   : 16;
        ULONG rn        : 4;
        ULONG l         : 1;    // load = 1, store = 0
        ULONG w         : 1;    // update base register after transfer
        ULONG s         : 1;
        ULONG u         : 1;    // increment = 1, decrement = 0
        ULONG p         : 1;    // before = 1, after = 0
        ULONG bits      : 3;
        ULONG cond      : 4;
    } ldm;    // Load multiple

    struct {
        ULONG offset    : 24;
        ULONG link      : 1;
        ULONG bits      : 3;
        ULONG cond      : 4;
    } bl;   // Branch, Branch and link

    struct {
        ULONG rm        : 4;
        ULONG bits1     : 8;    // (11110001)
        ULONG rd        : 4;
        ULONG bits2     : 12;   // (000101101111)
        ULONG cond      : 4;
    } clz;
    
    struct {
        ULONG crm       : 4;
        ULONG bits1     : 1;    // (0)
        ULONG cp        : 3;
        ULONG cpn       : 4;
        ULONG crd       : 4;
        ULONG crn       : 4;
        ULONG cpop      : 4;
        ULONG bits2     : 4;    // (1110)
        ULONG cond      : 4;
    } cpdo;
    
    struct {
        ULONG crm       : 4;
        ULONG bits1     : 1;    // (1)
        ULONG cp        : 3;
        ULONG cpn       : 4;
        ULONG rd        : 4;
        ULONG crn       : 4;
        ULONG l         : 1;    // load = 1, store = 0
        ULONG cpop      : 3;
        ULONG bits2     : 4;    // (1110)
        ULONG cond      : 4;
    } cprt;

    struct {
        ULONG offset    : 8;
        ULONG cpn       : 4;
        ULONG crd       : 4;
        ULONG rn        : 4;
        ULONG l         : 1;   // load = 1, store = 0
        ULONG w         : 1;   // write back = 1, no write back = 0
        ULONG n         : 1;   // long = 1, short = 0
        ULONG u         : 1;   // up = 1, down = 0
        ULONG p         : 1;   // pre = 1, post = 0
        ULONG bits      : 3;   // (011)
        ULONG cond      : 4;
    } cpdt;
    
    struct {
        ULONG crm       : 4;
        ULONG cpop      : 4;
        ULONG cpn       : 4;
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG bits      : 8;
        ULONG cond      : 4;
    } mcrr;

    struct {
        ULONG rm        : 4;
        ULONG bits1     : 8;    // (00000101)
        ULONG rd        : 4;
        ULONG rn        : 4;
        ULONG bits2     : 8;    // (00010010)
        ULONG cond      : 4;
    } qadd;
    
    struct {
        ULONG rm        : 4;
        ULONG bits1     : 1;    // (0)
        ULONG x         : 1;    // T = 1, B = 0
        ULONG y         : 1;    // T = 1, B = 0
        ULONG bits2     : 1;    // (1)
        ULONG rs        : 4;
        ULONG rn        : 4;
        ULONG rd        : 4;
        ULONG bits3     : 8;    // (00010000)
        ULONG cond      : 4;
    } smla;
    
    struct {
        ULONG rm        : 4;
        ULONG bits1     : 1;    // (0)
        ULONG x         : 1;    // T = 1, B = 0
        ULONG y         : 1;    // T = 1, B = 0
        ULONG bits2     : 1;    // (1)
        ULONG rs        : 4;
        ULONG rdlo      : 4;
        ULONG rdhi      : 4;
        ULONG bits3     : 8;    // (00010000)
        ULONG cond      : 4;
    } smlal;
    
    struct {
        ULONG rm        : 4;
        ULONG bits1     : 1;    // (0)
        ULONG x         : 1;    // T = 1, B = 0
        ULONG y         : 1;    // T = 1, B = 0
        ULONG bits2     : 1;    // (1)
        ULONG rs        : 4;
        ULONG bits3     : 4;    // (0000)
        ULONG rd        : 4;
        ULONG bits4     : 8;    // (00010010)
        ULONG cond      : 4;
    } smul;
    
    struct {
        ULONG comment   : 24;
        ULONG bits      : 4;    // (1111)
        ULONG cond      : 4;
    } swi;
    
    ULONG instruction;

} ARMI, *PARMI;


// Thumb instruction descriptions follow.

#define THUMB_B_COND_MASK	0xf000
#define THUMB_B_COND_INSTR	0xd000

#define THUMB_B_MASK		0xf800
#define THUMB_B_INSTR		0xe000

#define THUMB_BL_MASK		0xf000
#define THUMB_BL_INSTR		0xf000

#define THUMB_BX_MASK		0xff80
#define THUMB_BX_INSTR		0x4700

#define THUMB_ADD_HI_MASK	0xff00
#define THUMB_ADD_HI_INSTR	0x4400

#define THUMB_MOV_HI_MASK	0xff00
#define THUMB_MOV_HI_INSTR	0x4600

#define THUMB_POP_MASK		0xfe00
#define THUMB_POP_INSTR		0xbc00




typedef union _THUMBI {
	struct {
		USHORT reg_list:8;
		USHORT pc:1;	// pc==1 -> pop pc from list
		USHORT Op:7;
		USHORT Next:16;
	} pop_instr;
	struct {
		USHORT reg_list:8;
		USHORT lr:1;	// lr==1 -> push lr to list
		USHORT Op:7;
		USHORT Next:16;
	} push_instr;
	struct {
		USHORT target:8;	// sign-extend
		USHORT cond:4;
		USHORT Op:4;
		USHORT Next:16;
	} b_cond_instr;
	struct {
		USHORT target:11;	// sign-extend
		USHORT op:5;
		USHORT Next:16;
	} b_instr;
	struct {
		USHORT SBZ:3;
		USHORT Rm:3;
		USHORT hi_reg:1;	// hi_reg==1 -> use high register for Rm
		USHORT op:9;
		USHORT Next:16;
	} bx_instr;
	struct {
		USHORT target22_12:11;				// will not be sign-extended
		USHORT not_the_prefix:1;		// should be 0: is the prefix
		USHORT prefix_op:4;
		USHORT target11_1:11;				// will be sign-extended
		USHORT not_the_prefix2:1;		// should be 1: not the prefix
		USHORT main_op:4;
	} bl_instr;
	struct {
		USHORT Rd:3;
		USHORT Rm:3;
		USHORT hi_m:1;	// Rm is high register
		USHORT hi_d:1;	// Rd is high register
		USHORT func:2;	// 00->AddHi, 01->CmpHi, 10->MovHi, 11->Bx
		USHORT op:6;	// 010001 = 0x11
		USHORT Next:16;
	} spx_dp_instr;
	struct {
		USHORT imm:8;
		USHORT Rd:3;
		USHORT sp:1;	// 0-> rd = pc+imm, 1-> rd=sp+imm.
		USHORT op:4;
		USHORT Next:16;
	} add_sp_pc_instr;
	struct {
		USHORT imm:7;
		USHORT op:9;
		USHORT Next:16;
	} incr_sp_instr;

	ULONG instruction;

} THUMB_INSTRUCTION, *PTHUMB_INSTRUCTION;

#endif // _ARMINST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\copystr.h ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif

BOOL CopyNString(PSTR To, PCSTR From, ULONG FromChars, ULONG ToChars);
BOOL CatNString(PSTR To, PCSTR From, ULONG FromChars, ULONG ToChars);

#ifndef COPYSTR_NO_PRINTSTRING
BOOL __cdecl PrintString(PSTR To, ULONG ToChars, PCSTR Format, ...);
#endif

#define CopyString(To, From, ToChars) CopyNString(To, From, (ULONG)-1, ToChars)
#define CatString(To, From, ToChars) CatNString(To, From, (ULONG)-1, ToChars)
#define CopyNStrArray(To, From, FromChars) CopyNString(To, From, FromChars, DIMA(To))
#define CopyStrArray(To, From) CopyString(To, From, DIMA(To))
#define CatStrArray(To, From) CatString(To, From, DIMA(To))

#ifndef COPYSTR_NO_WCHAR

BOOL CopyNStringW(PWSTR To, PCWSTR From, ULONG FromChars, ULONG ToChars);
BOOL CatNStringW(PWSTR To, PCWSTR From, ULONG FromChars, ULONG ToChars);

#ifndef COPYSTR_NO_PRINTSTRING
BOOL __cdecl PrintStringW(PWSTR To, ULONG ToChars, PCWSTR Format, ...);
#endif

#define CopyStringW(To, From, ToChars) CopyNStringW(To, From, (ULONG)-1, ToChars)
#define CatStringW(To, From, ToChars) CatNStringW(To, From, (ULONG)-1, ToChars)
#define CopyNStrArrayW(To, From, FromChars) CopyNStringW(To, From, FromChars, DIMA(To))
#define CopyStrArrayW(To, From) CopyStringW(To, From, DIMA(To))
#define CatStrArrayW(To, From) CatStringW(To, From, DIMA(To))

#endif // #ifndef COPYSTR_NO_WCHAR

#ifdef COPYSTR_MOD

BOOL
CopyNString(PSTR To, PCSTR From, ULONG FromChars, ULONG ToChars)
{
    //
    // The CRT str'n'cpy doesn't guarantee termination of the
    // resulting string, so define a new function that does.
    // Returns TRUE for a full copy with terminator.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    BOOL Succ = TRUE;
    ULONG Len = strlen(From);

    if (FromChars == (ULONG)-1)
    {
        // This is a regular strcpy.  Don't fool with the length.
    }
    else if (FromChars > Len)
    {
        // The source string is smaller than the amount of characters
        // we were asked to copy.  Do it anyway, but return FALSE;
        Succ = FALSE;
    }
    else
    {
        // Set amount of characters to copy as in a normal strncpy.
        Len = FromChars;
    }

    if (Len >= ToChars)
    {
        Len = ToChars - 1;
        Succ = FALSE;
    }

    memcpy(To, From, Len);
    To[Len] = 0;

    return Succ;
}

BOOL
CatNString(PSTR To, PCSTR From, ULONG FromChars, ULONG ToChars)
{
    //
    // The CRT str'n'cat works with the number of characters to
    // append, which is usually inconvenient when filling
    // fixed-length buffers as you need to make sure to
    // subtract off the size of any existing content to
    // prevent buffer overflows.  Define a new function that
    // works with the absolute buffer size.
    // Returns TRUE for a full copy with terminator.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    ULONG ToLen = strlen(To);

    if (ToLen >= ToChars)
    {
        ULONG i;

        // To string is garbage.  Copy in a special
        // marker string.
        if (ToChars > 8)
        {
            ToChars = 8;
        }
        for (i = 0; i < ToChars - 1; i++)
        {
            To[i] = 'G';
        }
        To[i] = 0;
        return FALSE;
    }

    ToChars -= ToLen;

    BOOL Succ = TRUE;
    ULONG FromLen = strlen(From);

    if (FromChars != (ULONG)-1)
    {
        FromLen = min(FromLen, FromChars);
    }
    if (FromLen >= ToChars)
    {
        FromLen = ToChars - 1;
        Succ = FALSE;
    }

    memcpy(To + ToLen, From, FromLen);
    To[ToLen + FromLen] = 0;

    return Succ;
}

#ifndef COPYSTR_NO_PRINTSTRING

BOOL __cdecl
PrintString(PSTR To, ULONG ToChars, PCSTR Format, ...)
{
    va_list Args;
    int PrintChars;

    //
    // _snprintf leaves strings unterminated on overflow.
    // This wrapper guarantees termination.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    va_start(Args, Format);
    PrintChars = _vsnprintf(To, ToChars, Format, Args);
    if (PrintChars < 0 || PrintChars == ToChars)
    {
        va_end(Args);
        // Overflow, force termination.
        To[ToChars - 1] = 0;
        return FALSE;
    }
    else
    {
        va_end(Args);
        return TRUE;
    }
}

#endif // #ifndef COPYSTR_NO_PRINTSTRING

#ifndef COPYSTR_NO_WCHAR

BOOL
CopyNStringW(PWSTR To, PCWSTR From, ULONG FromChars, ULONG ToChars)
{
    //
    // The CRT str'n'cpy doesn't guarantee termination of the
    // resulting string, so define a new function that does.
    // Returns TRUE for a full copy with terminator.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    BOOL Succ = TRUE;
    ULONG Len = wcslen(From);

    if (FromChars == (ULONG)-1)
    {
        // This is a regular strcpy.  Don't fool with the length.
    }
    else if (FromChars > Len)
    {
        // The source string is smaller than the amount of characters
        // we were asked to copy.  Do it anyway, but return FALSE;
        Succ = FALSE;
    }
    else
    {
        // Set amount of characters to copy as in a normal strncpy.
        Len = FromChars;
    }

    if (Len >= ToChars)
    {
        Len = ToChars - 1;
        Succ = FALSE;
    }

    memcpy(To, From, Len * sizeof(WCHAR));
    To[Len] = 0;

    return Succ;
}

BOOL
CatNStringW(PWSTR To, PCWSTR From, ULONG FromChars, ULONG ToChars)
{
    //
    // The CRT str'n'cat works with the number of characters to
    // append, which is usually inconvenient when filling
    // fixed-length buffers as you need to make sure to
    // subtract off the size of any existing content to
    // prevent buffer overflows.  Define a new function that
    // works with the absolute buffer size.
    // Returns TRUE for a full copy with terminator.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    ULONG ToLen = wcslen(To);

    if (ToLen >= ToChars)
    {
        ULONG i;

        // To string is garbage.  Copy in a special
        // marker string.
        if (ToChars > 8)
        {
            ToChars = 8;
        }
        for (i = 0; i < ToChars - 1; i++)
        {
            To[i] = L'G';
        }
        To[i] = 0;
        return FALSE;
    }

    ToChars -= ToLen;

    BOOL Succ = TRUE;
    ULONG FromLen = wcslen(From);

    if (FromChars != (ULONG)-1)
    {
        FromLen = min(FromLen, FromChars);
    }
    if (FromLen >= ToChars)
    {
        FromLen = ToChars - 1;
        Succ = FALSE;
    }

    memcpy(To + ToLen, From, FromLen * sizeof(WCHAR));
    To[ToLen + FromLen] = 0;

    return Succ;
}

#ifndef COPYSTR_NO_PRINTSTRING

BOOL __cdecl
PrintStringW(PWSTR To, ULONG ToChars, PCWSTR Format, ...)
{
    va_list Args;
    int PrintChars;

    //
    // _snprintf leaves strings unterminated on overflow.
    // This wrapper guarantees termination.
    //

    if (ToChars == 0)
    {
        return FALSE;
    }

    va_start(Args, Format);
    PrintChars = _vsnwprintf(To, ToChars, Format, Args);
    if (PrintChars < 0 || PrintChars == ToChars)
    {
        va_end(Args);
        // Overflow, force termination.
        To[ToChars - 1] = 0;
        return FALSE;
    }
    else
    {
        va_end(Args);
        return TRUE;
    }
}

#endif // #ifndef COPYSTR_NO_PRINTSTRING

#endif // #ifndef COPYSTR_NO_WCHAR

#endif // #ifdef COPYSTR_MOD

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dhhelp.h ===
//----------------------------------------------------------------------------
//
// Help support.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef _DHHELP_H_
#define _DHHELP_H_

#include <dhtopics.h>

#define HELP_TOPIC_TABLE_OF_CONTENTS 1

enum
{
    HELP_SUCCESS,
    HELP_NO_SUCH_PAGE,
    HELP_FAILURE
};

extern CHAR g_HelpFileName[];

void MakeHelpFileName(PSTR File);
ULONG OpenHelpTopic(ULONG PageConstant);
ULONG OpenHelpIndex(PCSTR IndexText);
ULONG OpenHelpSearch(PCSTR SearchText);
ULONG OpenHelpKeyword(PCSTR Keyword, BOOL ShowErrorPopup);
BOOL SpawnHelp(ULONG Topic);

#endif // #ifndef _DHHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dbgver.h ===
//----------------------------------------------------------------------------
//
// Debugger package binary version information.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef OFFICIAL_BUILD
#include <ntverp.h>
#else

#define VER_PRODUCTMAJORVERSION     6
#define VER_PRODUCTMINORVERSION     1
#define VER_PRODUCTBUILD            10
#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_PRODUCTBETA_STR         ""

#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Debugging Tools for Windows(R)"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

#endif

#ifndef _WIN32_WCE
#include <common.ver>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dhtopics.h ===
#ifndef __VBHELP_A94F4F8D_9278_437B_ACAE_CC96D7BD3ECC_DEFINED__
#define __VBHELP_A94F4F8D_9278_437B_ACAE_CC96D7BD3ECC_DEFINED__

#define HELP_TOPIC_LEGAL_INFORMATION 1                          //  Legal Information
#define HELP_TOPIC_JUNK_03 2                                    //  Controlling Exceptions and Events
#define HELP_TOPIC_JUNK_02 3                                    //  Using Breakpoints
#define HELP_TOPIC_JUNK_07 4                                    //  Ending the Debugging Session
#define HELP_TOPIC_JUNK_06 5                                    //  Controlling Processes and Threads
#define HELP_TOPIC_JUNK_05 6                                    //  Crashing and Rebooting the Target Computer
#define HELP_TOPIC_JUNK_04 7                                    //  Synchronizing with the Target Computer
#define HELP_TOPIC_REMOTE_DEBUGGING 8                           //  Remote Debugging
#define HELP_TOPIC_REMOTE_DEBUGGING_THROUGH_THE_DEBUGGER 9      //  Remote Debugging Through the Debugger
#define HELP_TOPIC_REMOTE_DEBUGGING_THROUGH_REMOTE_EXE 10       //  Remote Debugging Through Remote.exe
#define HELP_TOPIC_COMMAND_LINE 11                              //  Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_CDB 12                          //  CDB Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_NTSD 13                         //  CDB Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_KD 14                           //  KD Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_WINDBG 15                       //  WinDbg Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_KDBGCTRL 16                     //  KDbgCtrl Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_DR_WATSON 17                    //  Dr. Watson Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_AUTODUMP 18                     //  Autodump+ Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_DBGRPC 19                       //  DbgRpc Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_SYMSTORE 20                     //  SymStore Command-Line Options
#define HELP_TOPIC_WINDOW_COMMAND 21                            //  The Command Window
#define HELP_TOPIC_WINDOW_WATCH 22                              //  The Watch Window
#define HELP_TOPIC_WINDOW_LOCALS 23                             //  The Locals Window
#define HELP_TOPIC_WINDOW_REGISTERS 24                          //  The Registers Window
#define HELP_TOPIC_POPUP_REGISTERS 25                           //  The Registers Window
#define HELP_TOPIC_WINDOW_MEMORY 26                             //  The Memory Window
#define HELP_TOPIC_WINDOW_CALLS 27                              //  The Calls Window
#define HELP_TOPIC_WINDOW_DISASSEMBLY 28                        //  The Disassembly Window
#define HELP_TOPIC_WINDOW_SOURCE 29                             //  Source Windows
#define HELP_TOPIC_POPUP_ATTACH_TO_PROCESS 30                   //  File | Attach to a Process
#define HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION 31           //  File | Connect to Remote Session
#define HELP_TOPIC_POPUP_KERNEL_DEBUGGING 32                    //  File | Kernel Debug
#define HELP_TOPIC_POPUP_SYMBOL_PATH 33                         //  File | Symbol File Path
#define HELP_TOPIC_POPUP_SOURCE_PATH 34                         //  File | Source File Path
#define HELP_TOPIC_POPUP_IMAGE_PATH 35                          //  File | Image File Path
#define HELP_TOPIC_POPUP_OPEN_WORKSPACE 36                      //  File | Open Workspace
#define HELP_TOPIC_POPUP_SAVE_WORKSPACE_AS 37                   //  File | Save Workspace As
#define HELP_TOPIC_POPUP_CLEAR_WORKSPACE 38                     //  File | Clear Workspace
#define HELP_TOPIC_POPUP_DELETE_WORKSPACES 39                   //  File | Delete Workspaces
#define HELP_TOPIC_POPUP_ADD_TO_COMMAND_OUTPUT 40               //  Edit | Add to Command Output
#define HELP_TOPIC_POPUP_GO_TO_ADDRESS 41                       //  Edit | Go to Address
#define HELP_TOPIC_POPUP_GO_TO_LINE 42                          //  Edit | Go to Line
#define HELP_TOPIC_POPUP_BREAKPOINTS 43                         //  Edit | Breakpoints
#define HELP_TOPIC_POPUP_LOG_FILE 44                            //  Edit | Open/Close Log File
#define HELP_TOPIC_POPUP_PROCESSES_AND_THREADS 45               //  View | Processes and Threads
#define HELP_TOPIC_POPUP_OPTIONS 46                             //  View | Options
#define HELP_TOPIC_POPUP_EVENT_FILTERS 47                       //  Debug | Event Filters
#define HELP_TOPIC_POPUP_MODULES 48                             //  Debug | Modules

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dbgimage.h ===
//----------------------------------------------------------------------------
//
// Image Support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

// taken from _MAX_PATH
#define NB_PATH_SIZE    260     /* max. length of full pathname */

// for reading debug directory info

#define NB10_SIG        ((DWORD)'01BN')
#define RSDS_SIG        ((DWORD)'SDSR')

typedef struct _NB10I              // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
    char    szPdb[NB_PATH_SIZE];
} NB10I, *PNB10I;

typedef struct _NB10I_HEADER       // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
} NB10IH, *PNB10IH;

typedef struct _RSDSI              // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
    char    szPdb[NB_PATH_SIZE * 3];
} RSDSI, *PRSDSI;

typedef struct _RSDSI_HEADER       // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
} RSDSIH, *PRSDSIH;

typedef union _CVDD
{
    DWORD   dwSig;
    NB10I   nb10i;
    RSDSI   rsdsi;
    NB10IH  nb10ih;
    RSDSIH  rsdsih;
} CVDD, *PCVDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dbhpriv.h ===
/*
 * private stuff in dbghelp
 */

#ifdef __cplusplus
extern "C" {
#endif

BOOL
IMAGEAPI
dbghelp(
    IN     HANDLE hp,
    IN OUT PVOID  data
    );

enum {
    dbhNone = 0,
    dbhModSymInfo,
    dbhDiaVersion,
    dbhLoadPdb,
    dbhNumFunctions
};

typedef struct _DBH_MODSYMINFO {
    DWORD   function;
    DWORD   sizeofstruct;
    DWORD64 addr;
    DWORD   type;
    char    file[MAX_PATH + 1];
} DBH_MODSYMINFO, *PDBH_MODSYMINFO;

typedef struct _DBH_DIAVERSION {
    DWORD   function;
    DWORD   sizeofstruct;
    DWORD   ver;
} DBH_DIAVERSION, *PDBH_DIAVERSION;

typedef struct _DBH_LOADPDB {
    DWORD   function;
    DWORD   sizeofstruct;
    char   *pdb;
} DBH_LOADPDB, *PDBH_LOADPDB;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dllimp.cpp ===
//----------------------------------------------------------------------------
//
// Certain calls are dynamically linked so that the user-mode
// DLL can be used on Win9x and NT4.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifndef _WIN32_WCE
#include <ntcsrdll.h>
#endif

#define NTDLL_APIS
#include "dllimp.h"
#include "cmnutil.hpp"

// These entries must match the ordering in the NTDLL_CALLS structure.
DYNAMIC_CALL_NAME g_NtDllCallNames[] =
{
    "CsrGetProcessId", FALSE,
    "DbgBreakPoint", TRUE,
    "DbgPrint", TRUE,
    "DbgPrompt", TRUE,
    "DbgUiConvertStateChangeStructure", FALSE,
    "DbgUiGetThreadDebugObject", FALSE,
    "DbgUiIssueRemoteBreakin", FALSE,
    "DbgUiSetThreadDebugObject", FALSE,
    "NtAllocateVirtualMemory", TRUE,
    "NtClose", TRUE,
    "NtCreateDebugObject", FALSE,
    "NtDebugActiveProcess", FALSE,
    "NtDebugContinue", FALSE,
    "NtFreeVirtualMemory", TRUE,
    "NtOpenProcess", TRUE,
    "NtOpenThread", TRUE,
    "NtQueryInformationProcess", TRUE,
    "NtQueryInformationThread", TRUE,
    "NtQueryObject", TRUE,
    "NtQuerySystemInformation", TRUE,
    "NtRemoveProcessDebug", FALSE,
    "NtResumeThread", TRUE,
    "NtSetInformationDebugObject", FALSE,
    "NtSetInformationProcess", FALSE,
    "NtSystemDebugControl", TRUE,
    "NtWaitForDebugEvent", FALSE,
    "RtlAnsiStringToUnicodeString", TRUE,
    "RtlCreateProcessParameters", FALSE,
    "RtlCreateUserProcess", FALSE,
    "RtlDestroyProcessParameters", FALSE,
    "RtlDosPathNameToNtPathName_U", TRUE,
    "RtlFindMessage", FALSE,
    "RtlFreeHeap", TRUE,
    "RtlFreeUnicodeString", TRUE,
    "RtlGetFunctionTableListHead", FALSE,
    "RtlGetUnloadEventTrace", FALSE,
    "RtlInitAnsiString", TRUE,
    "RtlInitUnicodeString", TRUE,
    "RtlTryEnterCriticalSection", TRUE,
    "RtlUnicodeStringToAnsiString", TRUE,
};

#define NTDLL_CALL_NAMES DIMA(g_NtDllCallNames)
#define NTDLL_CALL_PROCS DIMAT(g_NtDllCalls, FARPROC)
NTDLL_CALLS g_NtDllCalls;
DYNAMIC_CALLS_DESC g_NtDllCallsDesc =
{
    "ntdll.dll", NTDLL_CALL_NAMES,
    g_NtDllCallNames, (FARPROC*)&g_NtDllCalls, NULL, FALSE,
};

// These entries must match the ordering in the KERNEL32_CALLS structure.
DYNAMIC_CALL_NAME g_Kernel32CallNames[] =
{
    "CreateToolhelp32Snapshot", FALSE,
    "DebugActiveProcessStop", FALSE,
    "DebugBreak", TRUE,
    "DebugBreakProcess", FALSE,
    "DebugSetProcessKillOnExit", FALSE,
    "Module32First", FALSE,
    "Module32Next", FALSE,
    "OpenThread", FALSE,
    "Process32First", FALSE,
    "Process32Next", FALSE,
    "Thread32First", FALSE,
    "Thread32Next", FALSE,
};

#define KERNEL32_CALL_NAMES DIMA(g_Kernel32CallNames)
#define KERNEL32_CALL_PROCS DIMAT(g_Kernel32Calls, FARPROC)
KERNEL32_CALLS g_Kernel32Calls;
DYNAMIC_CALLS_DESC g_Kernel32CallsDesc =
{
    "kernel32.dll", KERNEL32_CALL_NAMES,
    g_Kernel32CallNames, (FARPROC*)&g_Kernel32Calls, NULL, FALSE,
};

// These entries must match the ordering in the USER32_CALLS structure.
DYNAMIC_CALL_NAME g_User32CallNames[] =
{
    "PrivateKDBreakPoint", FALSE,
    "GetThreadDesktop", FALSE,
    "SwitchDesktop", FALSE,
    "CloseDesktop", FALSE,
};

#define USER32_CALL_NAMES DIMA(g_User32CallNames)
#define USER32_CALL_PROCS DIMAT(g_User32Calls, FARPROC)
USER32_CALLS g_User32Calls;
DYNAMIC_CALLS_DESC g_User32CallsDesc =
{
    "user32.dll", USER32_CALL_NAMES,
    g_User32CallNames, (FARPROC*)&g_User32Calls, NULL, FALSE,
};

// These entries must match the ordering in the OLE32_CALLS structure.
DYNAMIC_CALL_NAME g_Ole32CallNames[] =
{
    "CLSIDFromString", TRUE,
    "CoCreateInstance", TRUE,
    "CoGetInterfaceAndReleaseStream", TRUE,
    "CoInitializeEx", TRUE,
    "CoMarshalInterThreadInterfaceInStream", TRUE,
    "CoUninitialize", TRUE,
    "CoUnmarshalInterface", TRUE,
    "CoCreateGuid", TRUE,
};

#define OLE32_CALL_NAMES DIMA(g_Ole32CallNames)
#define OLE32_CALL_PROCS DIMAT(g_Ole32Calls, FARPROC)
OLE32_CALLS g_Ole32Calls;
DYNAMIC_CALLS_DESC g_Ole32CallsDesc =
{
    "ole32.dll", OLE32_CALL_NAMES,
    g_Ole32CallNames, (FARPROC*)&g_Ole32Calls, NULL, FALSE,
};

// These entries must match the ordering in the OLEAUT32_CALLS structure.
DYNAMIC_CALL_NAME g_OleAut32CallNames[] =
{
    "SysAllocStringLen", TRUE,
    "SysFreeString", TRUE,
    "VariantClear", TRUE,
    "VariantCopy", TRUE,
    "VariantInit", TRUE,
};

#define OLEAUT32_CALL_NAMES DIMA(g_OleAut32CallNames)
#define OLEAUT32_CALL_PROCS DIMAT(g_OleAut32Calls, FARPROC)
OLEAUT32_CALLS g_OleAut32Calls;
DYNAMIC_CALLS_DESC g_OleAut32CallsDesc =
{
    "oleaut32.dll", OLEAUT32_CALL_NAMES,
    g_OleAut32CallNames, (FARPROC*)&g_OleAut32Calls, NULL, FALSE,
};

// These entries must match the ordering in the SHLWAPI_CALLS structure.
DYNAMIC_CALL_NAME g_ShlWapiCallNames[] =
{
    "PathIsDirectoryA", TRUE,
};

#define SHLWAPI_CALL_NAMES DIMA(g_ShlWapiCallNames)
#define SHLWAPI_CALL_PROCS DIMAT(g_ShlWapiCalls, FARPROC)
SHLWAPI_CALLS g_ShlWapiCalls;
DYNAMIC_CALLS_DESC g_ShlWapiCallsDesc =
{
    "shlwapi.dll", SHLWAPI_CALL_NAMES,
    g_ShlWapiCallNames, (FARPROC*)&g_ShlWapiCalls, NULL, FALSE,
};

#ifndef _WIN32_WCE

// These entries must match the ordering in the CRYPT32_CALLS structure.
DYNAMIC_CALL_NAME g_Crypt32CallNames[] =
{
    "CertFindCertificateInStore", FALSE,
    "CertFindChainInStore", FALSE,
    "CertFreeCertificateChain", FALSE,
    "CertFreeCertificateContext", FALSE,
    "CertGetCertificateChain", FALSE,
    "CertOpenStore", FALSE,
    "CertOpenSystemStoreA", FALSE,
    "CertVerifyCertificateChainPolicy", FALSE,
};

#define CRYPT32_CALL_NAMES DIMA(g_Crypt32CallNames)
#define CRYPT32_CALL_PROCS DIMAT(g_Crypt32Calls, FARPROC)
CRYPT32_CALLS g_Crypt32Calls;
DYNAMIC_CALLS_DESC g_Crypt32CallsDesc =
{
    "crypt32.dll", CRYPT32_CALL_NAMES,
    g_Crypt32CallNames, (FARPROC*)&g_Crypt32Calls, NULL, FALSE,
};

// These entries must match the ordering in the ADVAPI32_CALLS structure.
DYNAMIC_CALL_NAME g_Advapi32CallNames[] =
{
    "EnumServicesStatusExA", FALSE,
    "EnumServicesStatusExW", FALSE,
    "OpenSCManagerA", FALSE,
    "OpenSCManagerW", FALSE,
    "GetEventLogInformation", FALSE
};

#define ADVAPI32_CALL_NAMES DIMA(g_Advapi32CallNames)
#define ADVAPI32_CALL_PROCS DIMAT(g_Advapi32Calls, FARPROC)
ADVAPI32_CALLS g_Advapi32Calls;
DYNAMIC_CALLS_DESC g_Advapi32CallsDesc =
{
    "advapi32.dll", ADVAPI32_CALL_NAMES,
    g_Advapi32CallNames, (FARPROC*)&g_Advapi32Calls, NULL, FALSE,
};

#endif // #ifndef _WIN32_WCE

#ifndef NT_NATIVE

HRESULT
InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc)
{
    if (Desc->Initialized)
    {
        return S_OK;
    }

    C_ASSERT(NTDLL_CALL_NAMES == NTDLL_CALL_PROCS);
    C_ASSERT(KERNEL32_CALL_NAMES == KERNEL32_CALL_PROCS);
    C_ASSERT(USER32_CALL_NAMES == USER32_CALL_PROCS);
    C_ASSERT(OLE32_CALL_NAMES == OLE32_CALL_PROCS);
    C_ASSERT(OLEAUT32_CALL_NAMES == OLEAUT32_CALL_PROCS);
#ifndef _WIN32_WCE
    C_ASSERT(CRYPT32_CALL_NAMES == CRYPT32_CALL_PROCS);
    C_ASSERT(ADVAPI32_CALL_NAMES == ADVAPI32_CALL_PROCS);
#endif

    ZeroMemory(Desc->Procs, Desc->Count * sizeof(*Desc->Procs));

    Desc->Dll = LoadLibrary(Desc->DllName);
    if (Desc->Dll == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ULONG i;
    DYNAMIC_CALL_NAME* Name = Desc->Names;
    FARPROC* Proc = Desc->Procs;

    for (i = 0; i < Desc->Count; i++)
    {
        *Proc = GetProcAddress(Desc->Dll, Name->Name);
        if (*Proc == NULL && Name->Required)
        {
            return E_NOINTERFACE;
        }

        Proc++;
        Name++;
    }

    Desc->Initialized = TRUE;
    return S_OK;
}

#else // #ifndef NT_NATIVE

HRESULT
InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc)
{
    if (Desc != &g_NtDllCallsDesc)
    {
        ZeroMemory(Desc->Procs, Desc->Count * sizeof(*Desc->Procs));
        return E_NOINTERFACE;
    }

    C_ASSERT(NTDLL_CALL_NAMES == NTDLL_CALL_PROCS);

    g_NtDllCalls.CsrGetProcessId = CsrGetProcessId;
    g_NtDllCalls.DbgBreakPoint = DbgBreakPoint;
    g_NtDllCalls.DbgPrint = DbgPrint;
    g_NtDllCalls.DbgPrompt = DbgPrompt;
    g_NtDllCalls.DbgUiConvertStateChangeStructure =
        DbgUiConvertStateChangeStructure;
    g_NtDllCalls.DbgUiGetThreadDebugObject = DbgUiGetThreadDebugObject;
    g_NtDllCalls.DbgUiIssueRemoteBreakin = DbgUiIssueRemoteBreakin;
    g_NtDllCalls.DbgUiSetThreadDebugObject = DbgUiSetThreadDebugObject;
    g_NtDllCalls.NtAllocateVirtualMemory = NtAllocateVirtualMemory;
    g_NtDllCalls.NtClose = NtClose;
    g_NtDllCalls.NtCreateDebugObject = NtCreateDebugObject;
    g_NtDllCalls.NtDebugActiveProcess = NtDebugActiveProcess;
    g_NtDllCalls.NtDebugContinue = NtDebugContinue;
    g_NtDllCalls.NtFreeVirtualMemory = NtFreeVirtualMemory;
    g_NtDllCalls.NtOpenProcess = NtOpenProcess;
    g_NtDllCalls.NtOpenThread = NtOpenThread;
    g_NtDllCalls.NtQueryInformationProcess = NtQueryInformationProcess;
    g_NtDllCalls.NtQueryInformationThread = NtQueryInformationThread;
    g_NtDllCalls.NtQueryObject = NtQueryObject;
    g_NtDllCalls.NtQuerySystemInformation = NtQuerySystemInformation;
    g_NtDllCalls.NtRemoveProcessDebug = NtRemoveProcessDebug;
    g_NtDllCalls.NtResumeThread = NtResumeThread;
    g_NtDllCalls.NtSetInformationDebugObject = NtSetInformationDebugObject;
    g_NtDllCalls.NtSetInformationProcess = NtSetInformationProcess;
    g_NtDllCalls.NtSystemDebugControl = NtSystemDebugControl;
    g_NtDllCalls.NtWaitForDebugEvent = NtWaitForDebugEvent;
    g_NtDllCalls.RtlAnsiStringToUnicodeString = RtlAnsiStringToUnicodeString;
    g_NtDllCalls.RtlCreateProcessParameters = RtlCreateProcessParameters;
    g_NtDllCalls.RtlCreateUserProcess = RtlCreateUserProcess;
    g_NtDllCalls.RtlDestroyProcessParameters = RtlDestroyProcessParameters;
    g_NtDllCalls.RtlDosPathNameToNtPathName_U = RtlDosPathNameToNtPathName_U;
    g_NtDllCalls.RtlFindMessage = RtlFindMessage;
    g_NtDllCalls.RtlFreeHeap = RtlFreeHeap;
    g_NtDllCalls.RtlFreeUnicodeString = RtlFreeUnicodeString;
#ifndef _X86_
    g_NtDllCalls.RtlGetFunctionTableListHead = RtlGetFunctionTableListHead;
#endif
    g_NtDllCalls.RtlGetUnloadEventTrace = RtlGetUnloadEventTrace;
    g_NtDllCalls.RtlInitAnsiString = RtlInitAnsiString;
    g_NtDllCalls.RtlInitUnicodeString = RtlInitUnicodeString;
    g_NtDllCalls.RtlTryEnterCriticalSection = RtlTryEnterCriticalSection;
    g_NtDllCalls.RtlUnicodeStringToAnsiString = RtlUnicodeStringToAnsiString;
    return S_OK;
}

#endif // #ifndef NT_NATIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dhhelp.cpp ===
//----------------------------------------------------------------------------
//
// Help support.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifndef _WIN32_WCE

#include <htmlhelp.h>

#include "cmnutil.hpp"
#include "dhhelp.h"

CHAR g_HelpFileName[MAX_PATH] = "debugger.chm";

void
MakeHelpFileName(PSTR File)
{
    PSTR Tmp = NULL;

    //
    //  Get the file name for the base module.
    //

    if (GetModuleFileName(GetModuleHandle(NULL), g_HelpFileName,
                          DIMA(g_HelpFileName)))
    {
        // Remove the executable name.
        Tmp = strrchr(g_HelpFileName, '\\');
    }

    if (Tmp == NULL)
    {
        // Error.  Use the current directory.
        Tmp = g_HelpFileName;
        *Tmp++ = '.';
    }

    *Tmp = 0;
    CatString(g_HelpFileName, "\\", DIMA(g_HelpFileName));
    CatString(g_HelpFileName, File, DIMA(g_HelpFileName));
}

/*** OpenHelpTopic   -  opens the .chm and selects the specified topic
*
*   Purpose:
*       This opens the Help File and displays the specified page.
*       (This help file's name is stored as g_HelpFileName, but
*       this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you know exactly what
*       page is needed -- for instance, if a "Help" button is pressed.
*
*   Input:
*       PageConstant -- this is one of the topic constants defined
*                       in the header file generated when the .chm
*                       is built -- these constants will always
*                       be of the form "help_topic_xxxxx"
*
*   Returns:
*       0 - debugger.chm opened and page displayed correctly
*       1 - debugger.chm opened, but specified page not found
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpTopic(ULONG PageConstant)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Make "Contents" the active panel in debugger.chm

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_TOC,
                 0);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }

    //  Select the proper page

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_HELP_CONTEXT,
                 PageConstant);
    if (returnedHwnd == NULL)
    {
        return HELP_NO_SUCH_PAGE;
    }
    
    return HELP_SUCCESS;
}


/*** OpenHelpIndex   -  opens the .chm and searches for the specified text
*
*   Purpose:
*       This opens the Help File and looks up the specified text in
*       the Index.  (This help file's name is stored as g_HelpFileName,
*       but this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you don't know exactly
*       which page is needed -- for instance, if someone types
*       "help bp" or "help breakpoints" in the Command window.
*
*   Input:
*       IndexText  --  any text string  (even ""); this string will
*                      appear in the Index panel of the .chm
*
*   Returns:
*       0 - debugger.chm opened and index search displayed correctly
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpIndex(PCSTR IndexText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Index panel and clip IndexText into it.

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_INDEX,
                 (DWORD_PTR)IndexText);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

ULONG
OpenHelpSearch(PCSTR SearchText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;
    HH_FTS_QUERY Query;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Search panel.

    ZeroMemory(&Query, sizeof(Query));
    Query.cbStruct = sizeof(Query);
    Query.pszSearchQuery = SearchText;
    
    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_SEARCH,
                 (DWORD_PTR)&Query);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

ULONG
OpenHelpKeyword(PCSTR Keyword, BOOL ShowErrorPopup)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;
    HH_AKLINK helpfileLink;

    helpfileLink.cbStruct = sizeof(helpfileLink);
    helpfileLink.fReserved = FALSE;
    helpfileLink.pszKeywords = Keyword;
    helpfileLink.pszUrl = NULL;

    //  If ShowErrorPopup is TRUE, then entering an invalid keyword will cause
    //  an error message to be displayed.  If FALSE, it will cause the .chm to
    //  display the Index tab, and the keyword will be entered into the index
    //  box, just as with OpenHelpIndex.

    if (ShowErrorPopup)
    {
        helpfileLink.pszMsgText =
            "The text you entered is not in the index of this help file.";
        helpfileLink.pszMsgTitle = "HTML Help Error";
        helpfileLink.pszWindow = NULL;
        helpfileLink.fIndexOnFail = FALSE;
    }
    else
    {
        helpfileLink.pszMsgText = NULL;
        helpfileLink.pszMsgTitle = NULL;
        helpfileLink.pszWindow = NULL;
        helpfileLink.fIndexOnFail = TRUE;
    }

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Index panel and clip IndexText into it.

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_KEYWORD_LOOKUP,
                 (DWORD_PTR)&helpfileLink);
    if (returnedHwnd == NULL)
    {
        return HELP_NO_SUCH_PAGE;
    }
    
    return HELP_SUCCESS;
}

BOOL
SpawnHelp(ULONG Topic)
{
    CHAR StartHelpCommand[MAX_PATH + 32];
    PROCESS_INFORMATION ProcInfo = {0};
    STARTUPINFO SI = {0};

    // Start help with the given arguments.

    sprintf(StartHelpCommand, "hh.exe -mapid %d ", Topic);
    CatString(StartHelpCommand, g_HelpFileName, DIMA(StartHelpCommand));
        
    return CreateProcess(NULL,
                         StartHelpCommand,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_BREAKAWAY_FROM_JOB,
                         NULL,
                         NULL,
                         &SI,
                         &ProcInfo);
}

#endif // #ifndef _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\dllimp.h ===
//----------------------------------------------------------------------------
//
// Certain calls are dynamically linked so that the user-mode
// DLL can be used on Win9x and NT4.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __DLLIMP_H__
#define __DLLIMP_H__

#define SECURITY_WIN32

#include <security.h>
#ifndef _WIN32_WCE
#include <schannel.h>
#define __DI_CDECL__
#ifndef _NTDBG_
typedef int DEBUGOBJECTINFOCLASS;
#endif
#else
#define __DI_CDECL__ __cdecl
typedef int PROCESSINFOCLASS;
typedef int THREADINFOCLASS;
typedef int DEBUGOBJECTINFOCLASS;
typedef int OBJECT_INFORMATION_CLASS;
typedef int SYSTEM_INFORMATION_CLASS;
typedef int SYSDBG_COMMAND;
#endif
#include <tlhelp32.h>

struct DYNAMIC_CALL_NAME
{
    PCSTR Name;
    BOOL Required;
};
struct DYNAMIC_CALLS_DESC
{
    PCSTR DllName;
    ULONG Count;
    DYNAMIC_CALL_NAME* Names;
    FARPROC* Procs;
    HINSTANCE Dll;
    BOOL Initialized;
};

#ifdef NTDLL_APIS

// Calls from ntdll.dll.
typedef struct _NTDLL_CALLS
{
    HANDLE (NTAPI* CsrGetProcessId)
        (VOID);
    VOID (NTAPI* DbgBreakPoint)
        (VOID);
    ULONG (__DI_CDECL__* DbgPrint)
        (PCH Format, ...);
    ULONG (NTAPI* DbgPrompt)
        (PCH Prompt, PCH Response, ULONG MaximumResponseLength);
    NTSTATUS (NTAPI* DbgUiConvertStateChangeStructure)
        (IN struct _DBGUI_WAIT_STATE_CHANGE* StateChange,
         OUT struct _DEBUG_EVENT *DebugEvent);
    HANDLE (NTAPI* DbgUiGetThreadDebugObject)
        (VOID);
    NTSTATUS (NTAPI* DbgUiIssueRemoteBreakin)
        (IN HANDLE Process);
    VOID (NTAPI* DbgUiSetThreadDebugObject)
        (IN HANDLE DebugObject);
    NTSTATUS (NTAPI* NtAllocateVirtualMemory)
        (IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress,
         IN ULONG_PTR ZeroBits, IN OUT PSIZE_T RegionSize,
         IN ULONG AllocationType, IN ULONG Protect);
    NTSTATUS (NTAPI* NtClose)
        (IN HANDLE Handle);
    NTSTATUS (NTAPI* NtCreateDebugObject)
        (OUT HANDLE* DebugObjectHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes, IN ULONG Flags);
    NTSTATUS (NTAPI* NtDebugActiveProcess)
        (IN HANDLE ProcessHandle, IN HANDLE DebugObjectHandle);
    NTSTATUS (NTAPI* NtDebugContinue)
        (IN HANDLE DebugObjectHandle, IN PCLIENT_ID ClientId,
         IN NTSTATUS ContinueStatus);
    NTSTATUS (NTAPI* NtFreeVirtualMemory)
        (IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress,
         IN OUT PSIZE_T RegionSize, IN ULONG FreeType);
    NTSTATUS (NTAPI* NtOpenProcess)
        (OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         IN PCLIENT_ID ClientId OPTIONAL);
    NTSTATUS (NTAPI* NtOpenThread)
        (OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         IN PCLIENT_ID ClientId OPTIONAL);
    NTSTATUS (NTAPI* NtQueryInformationProcess)
        (IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass,
         OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQueryInformationThread)
        (IN HANDLE ThreadHandle, IN THREADINFOCLASS ThreadInformationClass,
         OUT PVOID ThreadInformation, IN ULONG ThreadInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQueryObject)
        (IN HANDLE Handle, IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
         OUT PVOID ObjectInformation, IN ULONG Length,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQuerySystemInformation)
        (IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
         OUT PVOID SystemInformation, IN ULONG SystemInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtRemoveProcessDebug)
        (IN HANDLE ProcessHandle, IN HANDLE DebugObjectHandle);
    NTSTATUS (NTAPI* NtResumeThread)
        (IN HANDLE ThreadHandle, OUT PULONG PreviousSuspendCount OPTIONAL);
    NTSTATUS (NTAPI* NtSetInformationDebugObject)
        (IN HANDLE DebugObjectHandle,
         IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
         IN PVOID DebugInformation, IN ULONG DebugInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtSetInformationProcess)
        (IN HANDLE ProcessHandle,
         IN PROCESSINFOCLASS ProcessInformationClass,
         IN PVOID ProcessInformation, IN ULONG ProcessInformationLength);
    NTSTATUS (NTAPI* NtSystemDebugControl)
        (IN SYSDBG_COMMAND Command, IN PVOID InputBuffer,
         IN ULONG InputBufferLength, OUT PVOID OutputBuffer,
         IN ULONG OutputBufferLength, OUT PULONG ReturnLength);
    NTSTATUS (NTAPI* NtWaitForDebugEvent)
        (IN HANDLE DebugObjectHandle, IN BOOLEAN Alertable,
         IN PLARGE_INTEGER Timeout OPTIONAL,
         OUT struct _DBGUI_WAIT_STATE_CHANGE* WaitStateChange);
    NTSTATUS (NTAPI* RtlAnsiStringToUnicodeString)
        (PUNICODE_STRING DestinationString, PCANSI_STRING SourceString,
         BOOLEAN AllocateDestinationString);
    NTSTATUS (NTAPI* RtlCreateProcessParameters)
        (struct _RTL_USER_PROCESS_PARAMETERS** ProcessParameters,
         PUNICODE_STRING ImagePathName,
         PUNICODE_STRING DllPath,
         PUNICODE_STRING CurrentDirectory,
         PUNICODE_STRING CommandLine,
         PVOID Environment,
         PUNICODE_STRING WindowTitle,
         PUNICODE_STRING DesktopInfo,
         PUNICODE_STRING ShellInfo,
         PUNICODE_STRING RuntimeData);
    NTSTATUS (NTAPI* RtlCreateUserProcess)
        (PUNICODE_STRING NtImagePathName, ULONG Attributes,
         struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters,
         PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
         PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
         HANDLE ParentProcess, BOOLEAN InheritHandles, HANDLE DebugPort,
         HANDLE ExceptionPort,
         struct _RTL_USER_PROCESS_INFORMATION* ProcessInformation);
    NTSTATUS (NTAPI* RtlDestroyProcessParameters)
        (struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters);
    BOOLEAN (NTAPI* RtlDosPathNameToNtPathName_U)
        (PCWSTR DosFileName, PUNICODE_STRING NtFileName,
         PWSTR *FilePart OPTIONAL,
         PVOID Reserved);
    NTSTATUS (NTAPI* RtlFindMessage)
        (PVOID DllHandle, ULONG MessageTableId, ULONG MessageLanguageId,
         ULONG MessageId, PMESSAGE_RESOURCE_ENTRY *MessageEntry);
    BOOLEAN (NTAPI* RtlFreeHeap)
        (IN PVOID HeapHandle, IN ULONG Flags, IN PVOID BaseAddress);
    VOID (NTAPI* RtlFreeUnicodeString)
        (PUNICODE_STRING UnicodeString);
    PLIST_ENTRY (NTAPI* RtlGetFunctionTableListHead)
        (VOID);
    PRTL_UNLOAD_EVENT_TRACE (NTAPI* RtlGetUnloadEventTrace)
        (VOID);
    VOID (NTAPI* RtlInitAnsiString)
        (PANSI_STRING DestinationString, char const *SourceString);
    VOID (NTAPI* RtlInitUnicodeString)
        (PUNICODE_STRING DestinationString, PCWSTR SourceString);
    BOOLEAN (NTAPI* RtlTryEnterCriticalSection)
        (PRTL_CRITICAL_SECTION CriticalSection);
    NTSTATUS (NTAPI* RtlUnicodeStringToAnsiString)
        (PANSI_STRING DestinationString, PCUNICODE_STRING SourceString,
         BOOLEAN AllocateDestinationString);
} NTDLL_CALLS;
extern NTDLL_CALLS g_NtDllCalls;
extern DYNAMIC_CALLS_DESC g_NtDllCallsDesc;

#endif

// Calls from kernel32.dll.
typedef struct _KERNEL32_CALLS
{
    HANDLE (WINAPI* CreateToolhelp32Snapshot)
        (DWORD dwFlags, DWORD th32ProcessID);
    BOOL (WINAPI* DebugActiveProcessStop)
        (DWORD ProcessId);
    VOID (WINAPI* DebugBreak)
        (VOID);
    BOOL (WINAPI* DebugBreakProcess)
        (HANDLE Process);
    BOOL (WINAPI* DebugSetProcessKillOnExit)
        (BOOL KillOnExit);
    BOOL (WINAPI* Module32First)
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
    BOOL (WINAPI* Module32Next)
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
    HANDLE (WINAPI* OpenThread)
        (DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
    BOOL (WINAPI* Process32First)
        (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
    BOOL (WINAPI* Process32Next)
        (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
    BOOL (WINAPI* Thread32First)
        (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
    BOOL (WINAPI* Thread32Next)
        (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
} KERNEL32_CALLS;
extern KERNEL32_CALLS g_Kernel32Calls;
extern DYNAMIC_CALLS_DESC g_Kernel32CallsDesc;

// Calls from user32.dll.
typedef struct _USER32_CALLS
{
    void  (WINAPI* PrivateKDBreakPoint) (void);
    HDESK (WINAPI* GetThreadDesktop) (DWORD dwThreadId);
    BOOL  (WINAPI* SwitchDesktop) (HDESK hDesktop);
    BOOL  (WINAPI* CloseDesktop) (HDESK hDesktop);
} USER32_CALLS;
extern USER32_CALLS g_User32Calls;
extern DYNAMIC_CALLS_DESC g_User32CallsDesc;

// Calls from ole32.dll.
typedef struct _OLE32_CALLS
{
    HRESULT (STDAPICALLTYPE* CLSIDFromString)
        (IN LPOLESTR lpsz, OUT LPCLSID pclsid);
    HRESULT (STDAPICALLTYPE* CoCreateInstance)
        (IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
         IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv);
    HRESULT (STDAPICALLTYPE* CoGetInterfaceAndReleaseStream)
        (IN LPSTREAM pStm, IN REFIID iid, OUT LPVOID FAR* ppv);
    HRESULT (STDAPICALLTYPE* CoInitializeEx)
        (void * pvReserved, DWORD dwCoInit);
    HRESULT (STDAPICALLTYPE* CoMarshalInterThreadInterfaceInStream)
        (IN REFIID riid, IN LPUNKNOWN pUnk, OUT LPSTREAM *ppStm);
    void (STDAPICALLTYPE* CoUninitialize)
        (void);
    HRESULT (STDAPICALLTYPE* CoUnmarshalInterface)
        (IN LPSTREAM pStm, IN REFIID riid, OUT LPVOID FAR* ppv);
    HRESULT (STDAPICALLTYPE* CoCreateGuid)(OUT GUID FAR *pguid);
} OLE32_CALLS;
extern OLE32_CALLS g_Ole32Calls;
extern DYNAMIC_CALLS_DESC g_Ole32CallsDesc;

// Calls from oleaut32.dll.
typedef struct _OLEAUT32_CALLS
{
    BSTR (STDAPICALLTYPE* SysAllocStringLen)
        (const OLECHAR *, UINT) ;
    void (STDAPICALLTYPE* SysFreeString)
        (BSTR Str);
    HRESULT (STDAPICALLTYPE *VariantClear)
        (VARIANTARG * pvarg);
    HRESULT (STDAPICALLTYPE *VariantCopy)
        (VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
    void (STDAPICALLTYPE *VariantInit)
        (VARIANTARG * pvarg);
} OLEAUT32_CALLS;
extern OLEAUT32_CALLS g_OleAut32Calls;
extern DYNAMIC_CALLS_DESC g_OleAut32CallsDesc;

// Calls from shlwapi.dll.
typedef struct _SHLWAPI_CALLS
{
    BOOL (STDAPICALLTYPE* PathIsDirectoryA)
        (LPCSTR pszPath);
} SHLWAPI_CALLS;
extern SHLWAPI_CALLS g_ShlWapiCalls;
extern DYNAMIC_CALLS_DESC g_ShlWapiCallsDesc;

#ifndef _WIN32_WCE

// Calls from security.dll.
extern SecurityFunctionTable g_SecurityFunc;

// Calls from crypt32.dll.
typedef struct _CRYPT32_CALLS
{
    PCCERT_CONTEXT (WINAPI* CertFindCertificateInStore)
        (IN HCERTSTORE hCertStore,
         IN DWORD dwCertEncodingType,
         IN DWORD dwFindFlags,
         IN DWORD dwFindType,
         IN const void *pvFindPara,
         IN PCCERT_CONTEXT pPrevCertContext);
    PCCERT_CHAIN_CONTEXT (WINAPI* CertFindChainInStore)
        (IN HCERTSTORE hCertStore,
         IN DWORD dwCertEncodingType,
         IN DWORD dwFindFlags,
         IN DWORD dwFindType,
         IN const void *pvFindPara,
         IN PCCERT_CHAIN_CONTEXT pPrevChainContext);
    VOID (WINAPI* CertFreeCertificateChain)
        (IN PCCERT_CHAIN_CONTEXT pChainContext);
    BOOL (WINAPI* CertFreeCertificateContext)
        (IN PCCERT_CONTEXT pCertContext);
    BOOL (WINAPI* CertGetCertificateChain)
        (IN OPTIONAL HCERTCHAINENGINE hChainEngine,
         IN PCCERT_CONTEXT pCertContext,
         IN OPTIONAL LPFILETIME pTime,
         IN OPTIONAL HCERTSTORE hAdditionalStore,
         IN PCERT_CHAIN_PARA pChainPara,
         IN DWORD dwFlags,
         IN LPVOID pvReserved,
         OUT PCCERT_CHAIN_CONTEXT* ppChainContext);
    HCERTSTORE (WINAPI* CertOpenStore)
        (IN LPCSTR lpszStoreProvider,
         IN DWORD dwEncodingType,
         IN HCRYPTPROV hCryptProv,
         IN DWORD dwFlags,
         IN const void *pvPara);
    HCERTSTORE (WINAPI* CertOpenSystemStoreA)
        (HCRYPTPROV      hProv,
         LPCSTR            szSubsystemProtocol);
    BOOL (WINAPI* CertVerifyCertificateChainPolicy)
        (IN LPCSTR pszPolicyOID,
         IN PCCERT_CHAIN_CONTEXT pChainContext,
         IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
         IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus);
} CRYPT32_CALLS;
extern CRYPT32_CALLS g_Crypt32Calls;
extern DYNAMIC_CALLS_DESC g_Crypt32CallsDesc;

// Calls from advapi32.dll.
typedef struct _ADVAPI32_CALLS
{
    BOOL (WINAPI* EnumServicesStatusExA)
        (SC_HANDLE                  hSCManager,
         SC_ENUM_TYPE               InfoLevel,
         DWORD                      dwServiceType,
         DWORD                      dwServiceState,
         LPBYTE                     lpServices,
         DWORD                      cbBufSize,
         LPDWORD                    pcbBytesNeeded,
         LPDWORD                    lpServicesReturned,
         LPDWORD                    lpResumeHandle,
         LPCSTR                     pszGroupName);
    BOOL (WINAPI* EnumServicesStatusExW)
        (SC_HANDLE                  hSCManager,
         SC_ENUM_TYPE               InfoLevel,
         DWORD                      dwServiceType,
         DWORD                      dwServiceState,
         LPBYTE                     lpServices,
         DWORD                      cbBufSize,
         LPDWORD                    pcbBytesNeeded,
         LPDWORD                    lpServicesReturned,
         LPDWORD                    lpResumeHandle,
         LPCWSTR                    pszGroupName);
    SC_HANDLE (WINAPI* OpenSCManagerA)
        (LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
    SC_HANDLE (WINAPI* OpenSCManagerW)
        (LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
    BOOL(WINAPI * GetEventLogInformation)
        (HANDLE     hEventLog,
         DWORD      dwInfoLevel,
         LPVOID     lpBuffer,
         DWORD      cbBufSize,
         LPDWORD    pcbBytesNeeded);
} ADVAPI32_CALLS;
extern ADVAPI32_CALLS g_Advapi32Calls;
extern DYNAMIC_CALLS_DESC g_Advapi32CallsDesc;

#endif // #ifndef _WIN32_WCE

HRESULT InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc);

#endif // #ifndef __DLLIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\float10.cpp ===
/***
*float10.c - floating point output for 10-byte long double
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Support conversion of a long double into a string
*
*Revision History:
*   07/15/91	GDP	Initial version in C (ported from assembly)
*   01/23/92	GDP	Support MIPS encoding for NaN
*   05-26-92       GWK     Windbg srcs
*
******************************************************************************/

#include "pch.hpp"

#include <math.h>

#include "float10.h"

typedef LONG s_long;
typedef ULONG u_long;
typedef SHORT s_short;
typedef USHORT u_short;

#define L_END

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200	  /* maximum temporary decimal exponent */
#define TMIN10 -5200	  /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS	0x3fff	  /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS	0x3ff	 /* exponent bias for double */
#define D_BIASM1 0x3fe	/* D_BIAS - 1 */
#define D_MAXEXP 0x7ff	/* maximum biased exponent */



/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
	( (manhi)==MSB_ULONG && (manlo)==0x0 )

#define _IS_MAN_IND(signbit, manhi, manlo) \
	((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
	( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
	(!( _IS_MAN_INF(signbit, manhi, manlo) || \
	   _IS_MAN_QNAN(signbit, manhi, manlo) ))

/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long UNALIGNED *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long UNALIGNED *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long UNALIGNED *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long UNALIGNED *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long UNALIGNED *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char *)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long UNALIGNED *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long UNALIGNED *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long UNALIGNED *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short *)(p) + 3)
#define UL_HI_D(p) ((u_long UNALIGNED *)(p) + 1)
#define UL_LO_D(p) ((u_long UNALIGNED *)(p))

#define PUT_INF_12(p,sign) \
		  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
		      *UL_MED_12(p) == 0 && \
		      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
		  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
		  *UL_MANHI_LD(p) = 0x8000; \
		  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
		  *UL_MANHI_LD(p) = 0; \
		  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
		      *UL_MANHI_LD(p) == 0 && \
		      *UL_MANLO_LD(p) == 0 )

/* Format: A 10 byte long double + 2 bytes of extra precision
 * If the extra precision is desired, the 10-byte long double
 * should be "unrounded" first.
 * This may change in later versions
 */

#ifdef L_END

_ULDBL12 _pow10pos[] = {
 /*P0001*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},
 /*P0002*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},
 /*P0003*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},
 /*P0004*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},
 /*P0005*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},
 /*P0006*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},
 /*P0007*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},
 /*P0008*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},
 /*P0016*/ {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},
 /*P0024*/ {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},
 /*P0032*/ {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},
 /*P0040*/ {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},
 /*P0048*/ {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},
 /*P0056*/ {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},
 /*P0064*/ {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},
 /*P0128*/ {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},
 /*P0192*/ {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},
 /*P0256*/ {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},
 /*P0320*/ {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},
 /*P0384*/ {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},
 /*P0448*/ {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},
 /*P0512*/ {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},
 /*P1024*/ {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},
 /*P1536*/ {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},
 /*P2048*/ {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},
 /*P2560*/ {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},
 /*P3072*/ {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},
 /*P3584*/ {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},
 /*P4096*/ {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}
};

_ULDBL12 _pow10neg[] = {
 /*N0001*/ {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},
 /*N0002*/ {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},
 /*N0003*/ {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},
 /*N0004*/ {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},
 /*N0005*/ {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},
 /*N0006*/ {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},
 /*N0007*/ {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},
 /*N0008*/ {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},
 /*N0016*/ {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},
 /*N0024*/ {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},
 /*N0032*/ {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},
 /*N0040*/ {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},
 /*N0048*/ {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},
 /*N0056*/ {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},
 /*N0064*/ {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},
 /*N0128*/ {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},
 /*N0192*/ {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},
 /*N0256*/ {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},
 /*N0320*/ {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},
 /*N0384*/ {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},
 /*N0448*/ {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},
 /*N0512*/ {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},
 /*N1024*/ {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},
 /*N1536*/ {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},
 /*N2048*/ {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},
 /*N2560*/ {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},
 /*N3072*/ {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},
 /*N3584*/ {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},
 /*N4096*/ {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}
};

#endif

int __addl(u_long x, u_long y, u_long UNALIGNED *sum)
{
    u_long r;
    int carry=0;
    r = x+y;
    if (r < x || r < y)
	carry++;
    *sum = r;
    return carry;
}

/***
*void __add_12(_ULDBL12 *x, _ULDBL12 *y) -	_ULDBL12 addition
*
*Purpose: add two _ULDBL12 numbers. The numbers are added
*   as 12-byte integers. Overflow is ignored.
*
*Entry: x,y: pointers to the operands
*
*Exit: *x receives the sum
*
*Exceptions:
*
*******************************************************************************/

void __add_12(_ULDBL12 *x, _ULDBL12 *y)
{
    int c0,c1,c2;
    c0 = __addl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x));
    if (c0) {
	c1 = __addl(*UL_MED_12(x),(u_long)1,UL_MED_12(x));
	if (c1) {
	    (*UL_HI_12(x))++;
	}
    }
    c2 = __addl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x));
    if (c2) {
	(*UL_HI_12(x))++;
    }
    /* ignore next carry -- assume no overflow will occur */
    (void) __addl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));
}





/***
*void __shl_12(_ULDBL12 *x) - _ULDBL12 shift left
*void __shr_12(_ULDBL12 *x) - _ULDBL12 shift right
*
*Purpose: Shift a _ULDBL12 number one bit to the left (right). The number
*   is shifted as a 12-byte integer. The MSB is lost.
*
*Entry: x: a pointer to the operand
*
*Exit: *x is shifted one bit to the left (or right)
*
*Exceptions:
*
*******************************************************************************/

void __shl_12(_ULDBL12 *p)
{
    u_long c0,c1;

    c0 = *UL_LO_12(p) & MSB_ULONG ? 1: 0;
    c1 = *UL_MED_12(p) & MSB_ULONG ? 1: 0;
    *UL_LO_12(p) <<= 1;
    *UL_MED_12(p) = *UL_MED_12(p)<<1 | c0;
    *UL_HI_12(p) = *UL_HI_12(p)<<1 | c1;
}

void __shr_12(_ULDBL12 *p)
{
    u_long c2,c1;
    c2 = *UL_HI_12(p) & 0x1 ? MSB_ULONG: 0;
    c1 = *UL_MED_12(p) & 0x1 ? MSB_ULONG: 0;
    *UL_HI_12(p) >>= 1;
    *UL_MED_12(p) = *UL_MED_12(p)>>1 | c2;
    *UL_LO_12(p) = *UL_LO_12(p)>>1 | c1;
}

/***
*void  __ld12mul(_ULDBL12 *px, _ULDBL12 *py) -
*   _ULDBL12 multiplication
*
*Purpose: multiply two _ULDBL12 numbers
*
*Entry: px,py: pointers to the _ULDBL12 operands
*
*Exit: *px contains the product
*
*Exceptions:
*
*******************************************************************************/

void  __ld12mul(_ULDBL12 *px, _ULDBL12 *py)
{
    u_short sign = 0;
    u_short sticky_bits = 0;
    _ULDBL12 tempman; /*this is actually a 12-byte mantissa,
			 not a 12-byte long double */
    int i;
    u_short expx, expy, expsum;
    int roffs,poffs,qoffs;
    int sticky;

    *UL_LO_12(&tempman) = 0;
    *UL_MED_12(&tempman) = 0;
    *UL_HI_12(&tempman) = 0;

    expx = *U_EXP_12(px);
    expy = *U_EXP_12(py);

    sign = (expx ^ expy) & (u_short)0x8000;
    expx &= 0x7fff;
    expy &= 0x7fff;
    expsum = expx+expy;
    if (expx >= LD_MAXEXP
	|| expy >= LD_MAXEXP
	|| expsum > LD_MAXEXP+ LD_BIASM1){
	/* overflow to infinity */
	PUT_INF_12(px,sign);
	return;
    }
    if (expsum <= LD_BIASM1-63) {
	/* underflow to zero */
	PUT_ZERO_12(px);
	return;
    }
    if (expx == 0) {
	/*
	 * If this is a denormal temp real then the mantissa
	 * was shifted right once to set bit 63 to zero.
	 */
	expsum++; /* Correct for this */
	if (ISZERO_12(px)) {
	    /* put positive sign */
	    *U_EXP_12(px) = 0;
	    return;
	}
    }
    if (expy == 0) {
	expsum++; /* because arg2 is denormal */
	if (ISZERO_12(py)) {
	    PUT_ZERO_12(px);
	    return;
	}
    }

    roffs = 0;
    for (i=0;i<5;i++) {
	int j;
	poffs = i<<1;
	qoffs = 8;
	for (j=5-i;j>0;j--) {
	    u_long prod;
#ifdef MIPS
	    /* a variable to hold temprary sums */
	    u_long sum;
#endif
	    int carry;
	    u_short *p, *q;
	    u_long UNALIGNED *r;
	    p = USHORT_12(px,poffs);
	    q = USHORT_12(py,qoffs);
	    r = ULONG_12(&tempman,roffs);
	    prod = (u_long)*p * (u_long)*q;
#ifdef MIPS
	    /* handle misalignment problems */
	    if (i&0x1){ /* i is odd */
                carry = __addl(*MIPSALIGN(r), prod, &sum);
                *MIPSALIGN(r) =  sum;
	    }
	    else /* i is even */
		carry = __addl(*r, prod, r);
#else
	    carry = __addl(*r,prod,r);
#endif
	    if (carry) {
		/* roffs should be less than 8 in this case */
		(*USHORT_12(&tempman,roffs+4))++;
	    }
	    poffs+=2;
	    qoffs-=2;
	}
	roffs+=2;
    }

    expsum -= LD_BIASM1;

    /* normalize */
    while ((s_short)expsum > 0 &&
	   ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {
	 __shl_12(&tempman);
	 expsum--;
    }

    if ((s_short)expsum <= 0) {
	expsum--;
        sticky = 0;
	while ((s_short)expsum < 0) {
	    if (*U_XT_12(&tempman) & 0x1)
		sticky++;
	    __shr_12(&tempman);
	    expsum++;
	}
	if (sticky)
	    *U_XT_12(&tempman) |= 0x1;
    }

    if (*U_XT_12(&tempman) > 0x8000 ||
	 ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {
	/* round up */
	if (*UL_MANLO_12(&tempman) == MAX_ULONG) {
	    *UL_MANLO_12(&tempman) = 0;
	    if (*UL_MANHI_12(&tempman) == MAX_ULONG) {
		*UL_MANHI_12(&tempman) = 0;
		if (*U_EXP_12(&tempman) == MAX_USHORT) {
		    /* 12-byte mantissa overflow */
		    *U_EXP_12(&tempman) = MSB_USHORT;
		    expsum++;
		}
		else
		    (*U_EXP_12(&tempman))++;
	    }
	    else
		(*UL_MANHI_12(&tempman))++;
	}
	else
	    (*UL_MANLO_12(&tempman))++;
    }


    /* check for exponent overflow */
    if (expsum >= 0x7fff){
	PUT_INF_12(px, sign);
	return;
    }

    /* put result in px */
    *U_XT_12(px) = *USHORT_12(&tempman,2);
    *UL_MANLO_12(px) = *UL_MED_12(&tempman);
    *UL_MANHI_12(px) = *UL_HI_12(&tempman);
    *U_EXP_12(px) = expsum | sign;
}



void __multtenpow12(_ULDBL12 *pld12, int pow, unsigned mult12)
{
    _ULDBL12 *pow_10p = _pow10pos-8;
    if (pow == 0)
	return;
    if (pow < 0) {
	pow = -pow;
	pow_10p = _pow10neg-8;
    }

    if (!mult12)
	*U_XT_12(pld12) = 0;


    while (pow) {
	int last3; /* the 3 LSBits of pow */
	_ULDBL12 unround;
	_ULDBL12 *py;

	pow_10p += 7;
	last3 = pow & 0x7;
	pow >>= 3;
	if (last3 == 0)
	    continue;
	py = pow_10p + last3;

#ifdef _ULDSUPPORT
	if (mult12) {
#endif
	    /* do an exact 12byte multiplication */
	    if (*U_XT_12(py) >= 0x8000) {
		/* copy number */
		unround = *py;
		/* unround adjacent byte */
		(*UL_MANLO_12(&unround))--;
		/* point to new operand */
		py = &unround;
	    }
	    __ld12mul(pld12,py);
#ifdef _ULDSUPPORT
	}
	else {
	    /* do a 10byte multiplication */
	    py = (_ULDBL12 *)TEN_BYTE_PART(py);
	    *(long double *)TEN_BYTE_PART(pld12) *=
		*(long double *)py;
	}
#endif
    }
}






/***
*void  __mtold12(char *manptr,unsigned manlen,_ULDBL12 *ld12) -
*   convert a mantissa into a _ULDBL12
*
*Purpose: convert a mantissa into a _ULDBL12. The mantissa is
*   in the form of an array of manlen BCD digits and is
*   considered to be an integer.
*
*Entry: manptr: the array containing the packed BCD digits of the mantissa
*	manlen: the size of the array
*	ld12: a pointer to the long double where the result will be stored
*
*Exit:
*	ld12 gets the result of the conversion
*
*Exceptions:
*
*******************************************************************************/

void  __mtold12(char *manptr,
			 unsigned manlen,
			 _ULDBL12 *ld12)
{
    _ULDBL12 tmp;
    u_short expn = LD_BIASM1+80;

    *UL_LO_12(ld12) = 0;
    *UL_MED_12(ld12) = 0;
    *UL_HI_12(ld12) = 0;
    for (;manlen>0;manlen--,manptr++){
	tmp = *ld12;
	__shl_12(ld12);
	__shl_12(ld12);
	__add_12(ld12,&tmp);
	__shl_12(ld12);	       /* multiply by 10 */
	*UL_LO_12(&tmp) = (u_long)*manptr;
	*UL_MED_12(&tmp) = 0;
	*UL_HI_12(&tmp) = 0;
	__add_12(ld12,&tmp);
    }

    /* normalize mantissa -- first shift word by word */
    while (*UL_HI_12(ld12) == 0) {
	*UL_HI_12(ld12) = *UL_MED_12(ld12) >> 16;
	*UL_MED_12(ld12) = *UL_MED_12(ld12) << 16 | *UL_LO_12(ld12) >> 16;
	(*UL_LO_12(ld12)) <<= 16;
	expn -= 16;
    }
    while ((*UL_HI_12(ld12) & 0x8000) == 0) {
	__shl_12(ld12);
	expn--;
    }
    *U_EXP_12(ld12) = expn;
}

#define STRCPY strcpy

#define PUT_ZERO_FOS(fos)	 \
		fos->exp = 1,	 \
		fos->sign = ' ', \
		fos->ManLen = 1, \
		fos->man[0] = '0',\
		fos->man[1] = 0;

#define SNAN_STR      "1#SNAN"
#define SNAN_STR_LEN  6
#define QNAN_STR      "1#QNAN"
#define QNAN_STR_LEN  6
#define INF_STR	      "1#INF"
#define INF_STR_LEN   5
#define IND_STR	      "1#IND"
#define IND_STR_LEN   5

/***
char * _uldtoa (_ULDOUBLE *px,
*               int maxchars,
*               char *ldtext)
*
*
*Purpose:
*   Return pointer to filled in string "ldtext" for
*   a given _UDOUBLE ponter px
*   with a maximum character width of maxchars
*
*Entry:
*   _ULDOUBLE * px:  a pointer to the long double to be converted into a string
*   int maxchars: number of digits allowed in the output format.
*
*   (default is 'e' format)
*
*   char * ldtext: a pointer to the output string
*
*Exit:
*    returns pointer to the output string
*
*Exceptions:
*
*******************************************************************************/


char * _uldtoa (_ULDOUBLE *px, int maxchars, char *ldtext)
{
    char        in_str[100];
    char        in_str2[100];
    char        cExp[100];
    FOS         foss;
    char *      lpszMan;
    char *      lpIndx;
    int         nErr;
    int         len1,  len2;

    maxchars -= 9;    /* sign, dot, E+0001 */

    nErr = $I10_OUTPUT (*px, maxchars, 0, &foss);

    lpszMan = foss.man;
 		  
    ldtext[0] = foss.sign;
    ldtext[1] = *lpszMan;
    ldtext[2] = '.';
    ldtext[3] = '\0';

    maxchars += 2;               /* sign, dot */

    lpszMan++;
    strcat (ldtext, lpszMan);

    len1 = strlen (ldtext);  // for 'e'


    strcpy (cExp, "e");

    foss.exp -= 1;              /* Adjust for the shift decimal shift above */
    _itoa (foss.exp, in_str, 10);

	 
    if (foss.exp < 0) {
        strcat (cExp, "-");

        strcpy (in_str2, &in_str[1]);
        strcpy (in_str, in_str2);
 		  
        while (strlen(in_str) < 4) {
            strcpy (in_str2, in_str);
            strcpy (in_str,"0");
            strcat (in_str,in_str2);
        }
    } else {
        while (strlen(in_str) < 4) {
            strcpy (in_str2, in_str);
            strcpy (in_str,"0");
            strcat (in_str,in_str2);
        }
    }

    if (foss.exp >= 0) {
        strcat (cExp, "+");
    }

    strcat (cExp, in_str);

    len2 = strlen (cExp);

    if (len1 == maxchars) {
        ;
    } 
    else if (len1 < maxchars) {
        do {
            strcat (ldtext,"0");
            len1++;
        } while (len1 < maxchars);
    }
    else {
        lpIndx = &ldtext[len1 - 1]; // point to last char and round
        do {
            *lpIndx = '\0';
            lpIndx--;
            len1--;           //NOTENOTE v-griffk we really need to round
        } while (len1 > maxchars);
    }
    
    strcat (ldtext, cExp);
    return ldtext;
}


/***
*int  _$i10_output(_ULDOUBLE ld,
*	    int ndigits,
*	    unsigned output_flags,
*	    FOS *fos) - output conversion of a 10-byte _ULDOUBLE
*
*Purpose:
*   Fill in a FOS structure for a given _ULDOUBLE
*
*Entry:
*   _ULDOUBLE ld:  The long double to be converted into a string
*   int ndigits: number of digits allowed in the output format.
*   unsigned output_flags: The following flags can be used:
*	SO_FFORMAT: Indicates 'f' format
*	(default is 'e' format)
*   FOS *fos: the structure that i10_output will fill in
*
*Exit:
*   modifies *fos
*   return 1 if original number was ok, 0 otherwise (infinity, NaN, etc)
*
*Exceptions:
*
*******************************************************************************/


int  $I10_OUTPUT(_ULDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS *fos)
{
    u_short expn;
    u_long manhi,manlo;
    u_short sign;

    /* useful constants (see algorithm explanation below) */
    u_short const log2hi = 0x4d10;
    u_short const log2lo = 0x4d;
    u_short const log4hi = 0x9a;
    u_long const c = 0x134312f4;
#if defined(L_END)
    _ULDBL12 ld12_one_tenth = {
	   {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}
    };
#elif defined(B_END)
    _ULDBL12 ld12_one_tenth = {
	   {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
    };
#endif

    _ULDBL12 ld12; /* space for a 12-byte long double */
    _ULDBL12 tmp12;
    u_short hh,ll; /* the bytes of the exponent grouped in 2 words*/
    u_short mm; /* the two MSBytes of the mantissa */
    s_long r; /* the corresponding power of 10 */
    s_short ir; /* ir = floor(r) */
    int retval = 1; /* assume valid number */
    char round; /* an additional character at the end of the string */
    char *p;
    int i;
    int ub_exp;
    int digcount;

    /* grab the components of the long double */
    expn = *U_EXP_LD(&ld);
    manhi = *UL_MANHI_LD(&ld);
    manlo = *UL_MANLO_LD(&ld);
    sign = expn & MSB_USHORT;
    expn &= 0x7fff;

    if (sign)
	fos->sign = '-';
    else
	fos->sign = ' ';

    if (expn==0 && manhi==0 && manlo==0) {
	PUT_ZERO_FOS(fos);
	return 1;
    }

    if (expn == 0x7fff) {
	fos->exp = 1; /* set a positive exponent for proper output */

	/* check for special cases */
	if (_IS_MAN_SNAN(sign, manhi, manlo)) {
	    /* signaling NAN */
	    STRCPY(fos->man,SNAN_STR);
	    fos->ManLen = SNAN_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_IND(sign, manhi, manlo)) {
	    /* indefinite */
	    STRCPY(fos->man,IND_STR);
	    fos->ManLen = IND_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_INF(sign, manhi, manlo)) {
	    /* infinity */
	    STRCPY(fos->man,INF_STR);
	    fos->ManLen = INF_STR_LEN;
	    retval = 0;
	}
	else {
	    /* quiet NAN */
	    STRCPY(fos->man,QNAN_STR);
	    fos->ManLen = QNAN_STR_LEN;
	    retval = 0;
	}
    }
    else {
       /*
	*    Algorithm for the decoding of a valid real number x
	*
	* In the  following  INT(r)  is	the largest integer less than or
	* equal to r (i.e. r rounded toward -infinity).	We want a result
	* r equal  to  1  + log(x), because then x = mantissa
	* * 10^(INT(r)) so that	.1  <=	mantissa  <  1.   Unfortunately,
	* we cannot  compute  s	exactly  so  we must alter the procedure
	* slightly.  We will  instead  compute	an  estimate  r	of  1  +
	* log(x) which	is  always  low.   This	will either result
	* in the correctly normalized number on	the  top  of  the  stack
	* or perhaps  a	number	which  is  a factor of 10 too large.  We
	* will then check to see that if  x  is	larger	 than  one
	* and if so multiply x by 1/10.
	*
	* We will  use	a  low	precision  (fixed  point 24 bit) estimate
	* of of 1 + log base 10 of x.  We  have	approximately  .mm
	* * 2^hhll  on	the  top of the stack where m, h, and l represent
	* hex digits,  mm  represents  the  high  2  hex  digits  of  the
	* mantissa, hh	represents the high 2 hex digits of the exponent,
	* and ll represents the low 2 hex digits of the exponent.   Since
	* .mm is  a  truncated	representation	of the mantissa, using it
	* in this  monotonically  increasing   polynomial   approximation
	* of the  logarithm  will  naturally  give  a  low result.  Let's
	* derive a formula for a lower	bound  r  on  1	+  log(x):
	*
	*      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
	*	  .9A20H < log(4)=.60205999...(base 10) < .9A21H
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) >= .mm * log(4) - log(4)
	*
	* Substituting in  truncated  hex  constants in the formula above
	* gives r = 1 + .4D104DH * hhll.  + .9AH *  .mm	-  .9A21H.   Now
	* multiplication of  hex  digits  5  and 6 of log(2) by ll has an
	* insignificant effect on the first 24	bits  of  the  result  so
	* it will  not	be  calculated.	 This  gives  the expression r =
	* 1 + .4D10H * hhll.  +	.4DH  *  .hh  +  .9A  *  .mm  -  .9A21H.
	* Finally we  must  add	terms to our formula to subtract out the
	* effect of the exponent bias.	We obtain the following	formula:
	*
	*			(implied decimal point)
	*   <				  >.<				   >
	*   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
	*   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
	* + <		  1		  >
	* + <			    .4D10H * hhll.			   >
	* +				    <	    .00004DH * hh00.	   >
	* +				    <	       .9AH * .mm	   >
	* -				    <		 .9A21H 	   >
	* - <			    .4D10H * 3FFEH			   >
	* -				    <	    .00004DH * 3F00H	   >
	*
	*  ==>	r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
	*
	* The difference  between  the	lower bound r and the upper bound
	* s is calculated as follows:
	*
	*  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
	*
	* so tenatively	s  =  r  +  log(4)  - [1/ln(10) - log(1/ln(4))],
	* but we must also add in terms to ensure we will have	an  upper
	* bound even  after  the  truncation  of various values.  Because
	* log(2) * hh00.  is truncated	to  .4D104DH  *	hh00.	we  must
	* add .0043H,  because	log(2)	*  ll.	is truncated to .4D10H *
	* ll.  we  must	add  .0005H,  because  <mantissa>  *  log(4)  is
	* truncated to .mm * .9AH we must add .009AH and .0021H.
	*
	* Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
	*	= r + .07A6H
	*  ==>	s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
	*
	* r is	equal  to  1  +	log(x) more than (10000H - 7A6H) /
	* 10000H = 97% of the time.
	*
	* In the above formula, a u_long is use to accomodate r, and
	* there is an implied decimal point in the middle.
	*/

	hh = expn >> 8;
	ll = expn & (u_short)0xff;
	mm = (u_short) (manhi >> 24);
	r = (s_long)log2hi*(s_long)expn + log2lo*hh + log4hi*mm - c;
	ir = (s_short)(r >> 16);

       /*
	*
	* We stated that we wanted to normalize x so that
	*
	*  .1 <= x < 1
	*
	* This was	a  slight  oversimplification.	 Actually  we  want a
	* number which when rounded to 16 significant digits  is  in  the
	* desired range.   To  do  this we must normalize x so that
	*
	*  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
	*
	* and then round.
	*
	* If we  had f = INT(1+log(x)) we could multiply by 10^(-f)
	* to get x into the desired range.	We do  not  quite  have
	* f but  we  do  have  INT(r)  from  the last step which is equal
	* to f 97% of the time and 1 less than f the rest  of  the	time.
	* We can  multiply	by  10^-[INT(r)] and if the result is greater
	* than 1 - 5*10^(-17) we can then multiply by 1/10.   This	final
	* result will lie in the proper range.
	*/

	/* convert _ULDOUBLE to _ULDBL12) */
	*U_EXP_12(&ld12) = expn;
	*UL_MANHI_12(&ld12) = manhi;
	*UL_MANLO_12(&ld12) = manlo;
	*U_XT_12(&ld12) = 0;

	/* multiply by 10^(-ir) */
	__multtenpow12(&ld12,-ir,1);

	/* if ld12 >= 1.0 then divide by 10.0 */
	if (*U_EXP_12(&ld12) >= 0x3fff) {
	    ir++;
	    __ld12mul(&ld12,&ld12_one_tenth);
	}

	fos->exp = ir;
	if (output_flags & SO_FFORMAT){
	    /* 'f' format, add exponent to ndigits */
	    ndigits += ir;
	    if (ndigits <= 0) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	if (ndigits > MAX_MAN_DIGITS)
	    ndigits = MAX_MAN_DIGITS;

	ub_exp = *U_EXP_12(&ld12) - 0x3ffe; /* unbias exponent */
	*U_EXP_12(&ld12) = 0;

	/*
	 * Now the mantissa has to be converted to fixed point.
	 * Then we will use the MSB of ld12 for generating
	 * the decimal digits. The next 11 bytes will hold
	 * the mantissa (after it has been converted to
	 * fixed point).
	 */

	for (i=0;i<8;i++)
	    __shl_12(&ld12); /* make space for an extra byte,
			      in case we shift right later */
	if (ub_exp < 0) {
	    int shift_count = (-ub_exp) & 0xff;
	    for (;shift_count>0;shift_count--)
		__shr_12(&ld12);
	}

	p = fos->man;
	for(digcount=ndigits+1;digcount>0;digcount--) {
	    tmp12 = ld12;
	    __shl_12(&ld12);
	    __shl_12(&ld12);
	    __add_12(&ld12,&tmp12);
	    __shl_12(&ld12);	/* ld12 *= 10 */

	    /* Now we have the first decimal digit in the msbyte of exponent */
	    *p++ = (char) (*UCHAR_12(&ld12,11) + '0');
	    *UCHAR_12(&ld12,11) = 0;
	}

	round = *(--p);
	p--; /* p points now to the last character of the string
		   excluding the rounding digit */
	if (round >= '5') {
	    /* look for a non-9 digit starting from the end of string */
	    for (;p>=fos->man && *p=='9';p--) {
		*p = '0';
	    }
	    if (p < fos->man){
		p++;
		fos->exp ++;
	    }
	    (*p)++;
	}
	else {
	    /* remove zeros */
	    for (;p>=fos->man && *p=='0';p--);
	    if (p < fos->man) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	fos->ManLen = (char) (p - fos->man + 1);
	fos->man[fos->ManLen] = '\0';
    }
    return retval;
}

/***
*strgtold.c - conversion of a string into a long double
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose: convert a fp constant into a 10 byte long double (IEEE format)
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*   4-03-92	GDP	Preserve sign of -0
*   4-30-92	GDP	Now returns _ULDBL12 instead of _ULDOUBLE
*   05-26-92       GWK     Windbg srcs
*
*******************************************************************************/

/* local macros */
#define ISNZDIGIT(x) ((x)>='1' && (x)<='9' )

//NOTENOTE the following takes the place of the isdigit() macro
//       which does not work for a yet to be determined reason
#define ISADIGIT(x) ((x)>='0' && (x)<='9' )

#define ISWHITE(x) ((x)==' ' || (x)=='\t' || (x)=='\n' || (x)=='\r' )




/****
*unsigned int __strgtold( _ULDBL12 *pld12,
*			  char * * pEndPtr,
*			  char * str,
*			  int Mult12 )
*
*Purpose:
*   converts a character string into a long double
*
*Entry:
*   pld12   - pointer to the _ULDBL12 where the result should go.
*   pEndStr - pointer to a far pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _ULDBL12 multiply should be used instead of
*		the long double mulitiply.
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int
__strgtold12(_ULDBL12 *pld12,
	    char * *p_end_ptr,
	    char *str,
	    int mult12)
{
    typedef enum {
	S_INIT,  /* initial state */
	S_EAT0L, /* eat 0's at the left of mantissa */
	S_SIGNM, /* just read sign of mantissa */
	S_GETL,  /* get integer part of mantissa */
	S_GETR,  /* get decimal part of mantissa */
	S_POINT, /* just found decimal point */
	S_E,	 /* just found	'E', or 'e', etc  */
	S_SIGNE, /* just read sign of exponent */
	S_EAT0E, /* eat 0's at the left of exponent */
	S_GETE,  /* get exponent */
	S_END	 /* final state */
    } state_t;

    /* this will accomodate the digits of the mantissa in BCD form*/
    static char buf[LD_MAX_MAN_LEN1];
    char *manp = buf;

    /* a temporary _ULDBL12 */
    _ULDBL12 tmpld12;

    u_short man_sign = 0; /* to be ORed with result */
    int exp_sign = 1; /* default sign of exponent (values: +1 or -1)*/
    /* number of decimal significant mantissa digits so far*/
    unsigned manlen = 0;
    int found_digit = 0;
    int overflow = 0;
    int underflow = 0;
    int pow = 0;
    int exp_adj = 0;  /* exponent adjustment */
    u_long ul0,ul1;
    u_short u,uexp;

    unsigned int result_flags = 0;

    state_t state = S_INIT;

    char c;  /* the current input symbol */
    char *p; /* a pointer to the next input symbol */
    char *savedp;

    for(savedp=p=str;ISWHITE(*p);p++); /* eat up white space */

    while (state != S_END) {
	c = *p++;
	switch (state) {
	case S_INIT:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '+':
		    state = S_SIGNM;
		    man_sign = 0x0000;
		    break;
		case '-':
		    state = S_SIGNM;
		    man_sign = 0x8000;
		    break;
		case '.':
		    state = S_POINT;
		    break;
		default:
		    state = S_END;
		    p--;
		    break;
		}
	    break;
	case S_EAT0L:
	    found_digit = 1;
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case 'E':
		case 'e':
		case 'D':
		case 'd':
		    state = S_E;
		    break;
		case '.':
		    state = S_GETR;
		    break;
		default:
		    state = S_END;
		    p--;
		}
	    break;
	case S_SIGNM:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '.':
		    state = S_POINT;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETL:
	    found_digit = 1;
	    for (;ISADIGIT(c);c=*p++) {
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		}
		else
		   exp_adj++;
	    }
	    switch (c) {
	    case '.':
		state = S_GETR;
		break;
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    default:
		state = S_END;
		p--;
	    }
	break;
	case S_GETR:
	    found_digit = 1;
	    if (manlen == 0)
		for (;c=='0';c=*p++)
		    exp_adj--;
	    for(;ISADIGIT(c);c=*p++){
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		    exp_adj--;
		}
	    }
	    switch (c){
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    default:
		state = S_END;
		p--;
	    }
	    break;
	case S_POINT:
	    if (ISADIGIT(c)){
		state = S_GETR;
		p--;
	    }
	    else{
		state = S_END;
		p = savedp;
	    }
	    break;
	case S_E:
	    savedp = p-2; /* savedp points to 'E' */
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	break;
	case S_EAT0E:
	    for(;c=='0';c=*p++);
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else {
		state = S_END;
		p--;
	    }
	    break;
	case S_SIGNE:
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETE:
	    {
		long longpow=0; /* TMAX10*10 should fit in a long */
		for(;ISADIGIT(c);c=*p++){
		    longpow = longpow*10 + (c - '0');
		    if (longpow > TMAX10){
			longpow = TMAX10+1; /* will force overflow */
			break;
		    }
		}
		pow = (int)longpow;
	    }
	    for(;ISADIGIT(c);c=*p++); /* eat up remaining digits */
	    state = S_END;
	    p--;
	    break;
	}  /* switch */
    }  /* while */

    *p_end_ptr = p;	/* set end pointer */

    /*
     * Compute result
     */

    if (found_digit && !overflow && !underflow) {
	if (manlen>LD_MAX_MAN_LEN){
	    if (buf[LD_MAX_MAN_LEN-1]>=5) {
	       /*
		* Round mantissa to MAX_MAN_LEN digits
		* It's ok to round 9 to 0ah
		*/
		buf[LD_MAX_MAN_LEN-1]++;
	    }
	    manlen = LD_MAX_MAN_LEN;
	    manp--;
	    exp_adj++;
	}
	if (manlen>0) {
	   /*
	    * Remove trailing zero's from mantissa
	    */
	    for(manp--;*manp==0;manp--) {
		/* there is at least one non-zero digit */
		manlen--;
		exp_adj++;
	    }
	    __mtold12(buf,manlen,&tmpld12);

	    if (exp_sign < 0)
		pow = -pow;
	    pow += exp_adj;
	    if (pow > TMAX10)
		overflow = 1;
	    else if (pow < TMIN10)
		underflow = 1;
	    else {
		__multtenpow12(&tmpld12,pow,mult12);

		u = *U_XT_12(&tmpld12);
		ul0 =*UL_MANLO_12(&tmpld12);
		ul1 = *UL_MANHI_12(&tmpld12);
		uexp = *U_EXP_12(&tmpld12);

	    }
	}
	else {
	    /* manlen == 0, so	return 0 */
	    u = (u_short)0;
	    ul0 = ul1 = uexp = 0;
	}
    }

    if (!found_digit) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_NODIGITS;
    }
    else if (overflow) {
	/* return +inf or -inf */
	uexp = (u_short)0x7fff;
	ul1 = 0x80000000;
	ul0 = 0;
	u = (u_short)0;
	result_flags |= SLD_OVERFLOW;
    }
    else if (underflow) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_UNDERFLOW;
    }

    /*
     * Assemble	result
     */

    *U_XT_12(pld12) = u;
    *UL_MANLO_12(pld12) = ul0;
    *UL_MANHI_12(pld12) = ul1;
    *U_EXP_12(pld12) = uexp | man_sign;

    return result_flags;
}

/***
* intrncvt.c - internal floating point conversions
*
*	Copyright (c) 1992-1992, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   All fp string conversion routines use the same core conversion code
*   that converts strings into an internal long double representation
*   with an 80-bit mantissa field. The mantissa is represented
*   as an array (man) of 32-bit unsigned longs, with man[0] holding
*   the high order 32 bits of the mantissa. The binary point is assumed
*   to be between the MSB and MSB-1 of man[0].
*
*   Bits are counted as follows:
*
*
*     +-- binary point
*     |
*     v 		 MSB	       LSB
*   ----------------	 ------------------	 --------------------
*   |0 1    .... 31|	 | 32 33 ...	63|	 | 64 65 ...	  95|
*   ----------------	 ------------------	 --------------------
*
*   man[0]		    man[1]		     man[2]
*
*   This file provides the final conversion routines from this internal
*   form to the single, double, or long double precision floating point
*   format.
*
*   All these functions do not handle NaNs (it is not necessary)
*
*
*Revision History:
*   04-29-92	GDP	written
*   05-26-92       GWK     Windbg srcs
*
*******************************************************************************/


#define INTRNMAN_LEN  3	      /* internal mantissa length in int's */

//
//  internal mantissaa representation
//  for string conversion routines
//

typedef u_long *intrnman;


typedef struct {
   int max_exp;      // maximum base 2 exponent (reserved for special values)
   int min_exp;      // minimum base 2 exponent (reserved for denormals)
   int precision;    // bits of precision carried in the mantissa
   int exp_width;    // number of bits for exponent
   int format_width; // format width in bits
   int bias;	     // exponent bias
} FpFormatDescriptor;



static FpFormatDescriptor
DoubleFormat = {
    0x7ff - 0x3ff,  //	1024, maximum base 2 exponent (reserved for special values)
    0x0   - 0x3ff,  // -1023, minimum base 2 exponent (reserved for denormals)
    53, 	    // bits of precision carried in the mantissa
    11, 	    // number of bits for exponent
    64, 	    // format width in bits
    0x3ff,	    // exponent bias
};

static FpFormatDescriptor
FloatFormat = {
    0xff - 0x7f,    //	128, maximum base 2 exponent (reserved for special values)
    0x0  - 0x7f,    // -127, minimum base 2 exponent (reserved for denormals)
    24, 	    // bits of precision carried in the mantissa
    8,		    // number of bits for exponent
    32, 	    // format width in bits
    0x7f,	    // exponent bias
};



//
// function prototypes
//

int _RoundMan (intrnman man, int nbit);
int _ZeroTail (intrnman man, int nbit);
int _IncMan (intrnman man, int nbit);
void _CopyMan (intrnman dest, intrnman src);
void _CopyMan (intrnman dest, intrnman src);
void _FillZeroMan(intrnman man);
void _Shrman (intrnman man, int n);

INTRNCVT_STATUS _ld12cvt(_ULDBL12 *pld12, void *d, FpFormatDescriptor *format);

/***
* _ZeroTail - check if a mantissa ends in 0's
*
*Purpose:
*   Return TRUE if all mantissa bits after nbit (including nbit) are 0,
*   otherwise return FALSE
*
*
*Entry:
*   man: mantissa
*   nbit: order of bit where the tail begins
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _ZeroTail (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;


    //
    //		     |<---- tail to be checked --->
    //
    //	--  ------------------------	       ----
    //	|...	|		  |  ...	  |
    //	--  ------------------------	       ----
    //	^	^    ^
    //	|	|    |<----nb----->
    //	man	nl   nbit
    //



    u_long bitmask = ~(MAX_ULONG << nb);

    if (man[nl] & bitmask)
	return 0;

    nl++;

    for (;nl < INTRNMAN_LEN; nl++)
	if (man[nl])
	    return 0;

    return 1;
}




/***
* _IncMan - increment mantissa
*
*Purpose:
*
*
*Entry:
*   man: mantissa in internal long form
*   nbit: order of bit that specifies the end of the part to be incremented
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _IncMan (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;

    //
    //	|<--- part to be incremented -->|
    //
    //	--	       ---------------------------     ----
    //	|...		  |			|   ...	  |
    //	--	       ---------------------------     ----
    //	^		  ^		^
    //	|		  |		|<--nb-->
    //	man		  nl		nbit
    //

    u_long one = (u_long) 1 << nb;
    int carry;

    carry = __addl(man[nl], one, &man[nl]);

    nl--;

    for (; nl >= 0 && carry; nl--) {
	carry = (u_long) __addl(man[nl], (u_long) 1, &man[nl]);
    }

    return carry;
}




/***
* _RoundMan -  round mantissa
*
*Purpose:
*   round mantissa to nbit precision
*
*
*Entry:
*   man: mantissa in internal form
*   precision: number of bits to be kept after rounding
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _RoundMan (intrnman man, int precision)
{
    int i,rndbit,nl,nb;
    u_long rndmask;
    int nbit;
    int retval = 0;

    //
    // The order of the n'th bit is n-1, since the first bit is bit 0
    // therefore decrement precision to get the order of the last bit
    // to be kept
    //
    nbit = precision - 1;

    rndbit = nbit+1;

    nl = rndbit / 32;
    nb = 31 - rndbit % 32;

    //
    // Get value of round bit
    //

    rndmask = (u_long)1 << nb;

    if ((man[nl] & rndmask) &&
	 !_ZeroTail(man, rndbit+1)) {

	//
	// round up
	//

	retval = _IncMan(man, nbit);
    }


    //
    // fill rest of mantissa with zeroes
    //

    man[nl] &= MAX_ULONG << nb;
    for(i=nl+1; i<INTRNMAN_LEN; i++) {
	man[i] = (u_long)0;
    }

    return retval;
}


/***
* _CopyMan - copy mantissa
*
*Purpose:
*    copy src to dest
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _CopyMan (intrnman dest, intrnman src)
{
    u_long *p, *q;
    int i;

    p = src;
    q = dest;

    for (i=0; i < INTRNMAN_LEN; i++) {
	*q++ = *p++;
    }
}



/***
* _FillZeroMan - fill mantissa with zeroes
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _FillZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	man[i] = (u_long)0;
}



/***
* _IsZeroMan - check if mantissa is zero
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _IsZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	if (man[i])
	    return 0;

    return 1;
}





/***
* _ShrMan - shift mantissa to the right
*
*Purpose:
*  shift man by n bits to the right
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ShrMan (intrnman man, int n)
{
    int i, n1, n2, mask;
    int carry_from_left;

    //
    // declare this as volatile in order to work around a C8
    // optimization bug
    //

    volatile int carry_to_right;

    n1 = n / 32;
    n2 = n % 32;

    mask = ~(MAX_ULONG << n2);


    //
    // first deal with shifts by less than 32 bits
    //

    carry_from_left = 0;
    for (i=0; i<INTRNMAN_LEN; i++) {

	carry_to_right = man[i] & mask;

	man[i] >>= n2;

	man[i] |= carry_from_left;

	carry_from_left = carry_to_right << (32 - n2);
    }


    //
    // now shift whole 32-bit ints
    //

    for (i=INTRNMAN_LEN-1; i>=0; i--) {
	if (i >= n1) {
	    man[i] = man[i-n1];
	}
	else {
	    man[i] = 0;
	}
    }
}




/***
* _ld12tocvt - _ULDBL12 floating point conversion
*
*Purpose:
*   convert a internal _LBL12 structure into an IEEE floating point
*   representation
*
*
*Entry:
*   pld12:  pointer to the _ULDBL12
*   format: pointer to the format descriptor structure
*
*Exit:
*   *d contains the IEEE representation
*   returns the INTRNCVT_STATUS
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12cvt(_ULDBL12 *pld12, void *d, FpFormatDescriptor *format)
{
    u_long man[INTRNMAN_LEN];
    u_long saved_man[INTRNMAN_LEN];
    u_long msw;
    unsigned int bexp;			// biased exponent
    int exp_shift;
    int exponent, sign;
    INTRNCVT_STATUS retval;

    exponent = (*U_EXP_12(pld12) & 0x7fff) - 0x3fff;   // unbias exponent
    sign = *U_EXP_12(pld12) & 0x8000;

    //
    // bexp is the final biased value of the exponent to be used
    // Each of the following blocks should provide appropriate
    // values for man, bexp and retval. The mantissa is also
    // shifted to the right, leaving space for the exponent
    // and sign to be inserted
    //


    if (exponent == 0 - 0x3fff) {

	// either a denormal or zero
	bexp = 0;
        _FillZeroMan(man);

	if (ISZERO_12(pld12)) {

	    retval = INTRNCVT_OK;
	}
	else {

	    // denormal has been flushed to zero

	    retval = INTRNCVT_UNDERFLOW;
	}
    }
    else {

	man[0] = *UL_MANHI_12(pld12);
	man[1] = *UL_MANLO_12(pld12);
	man[2] = *U_XT_12(pld12) << 16;

	// save mantissa in case it needs to be rounded again
	// at a different point (e.g., if the result is a denormal)

	_CopyMan(saved_man, man);

	if (_RoundMan(man, format->precision)) {
	    exponent ++;
	}

	if (exponent < format->min_exp - format->precision ) {

	    //
	    // underflow that produces a zero
	    //

	    _FillZeroMan(man);
	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;
	}

	else if (exponent <= format->min_exp) {

	    //
	    // underflow that produces a denormal
	    //
	    //

	    // The (unbiased) exponent will be MIN_EXP
	    // Find out how much the mantissa should be shifted
	    // One shift is done implicitly by moving the
	    // binary point one bit to the left, i.e.,
	    // we treat the mantissa as .ddddd instead of d.dddd
	    // (where d is a binary digit)

	    int shift = format->min_exp - exponent;

	    // The mantissa should be rounded again, so it
	    // has to be restored

	    _CopyMan(man,saved_man);

	    _ShrMan(man, shift);
	    _RoundMan(man, format->precision); // need not check for carry

	    // make room for the exponent + sign

	    _ShrMan(man, format->exp_width + 1);

	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;

	}

	else if (exponent >= format->max_exp) {

	    //
	    // overflow, return infinity
	    //

	    _FillZeroMan(man);
	    man[0] |= (1 << 31); // set MSB

	    // make room for the exponent + sign

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    bexp = format->max_exp + format->bias;

	    retval = INTRNCVT_OVERFLOW;
	}

	else {

	    //
	    // valid, normalized result
	    //

	    bexp = exponent + format->bias;


	    // clear implied bit

	    man[0] &= (~( 1 << 31));

	    //
	    // shift right to make room for exponent + sign
	    //

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    retval = INTRNCVT_OK;

	}
    }


    exp_shift = 32 - (format->exp_width + 1);
    msw =  man[0] |
	   (bexp << exp_shift) |
	   (sign ? 1<<31 : 0);

    if (format->format_width == 64) {

	*UL_HI_D(d) = msw;
	*UL_LO_D(d) = man[1];
    }

    else if (format->format_width == 32) {

	*(u_long *)d = msw;

    }

    return retval;
}


/***
* _ld12tod - convert _ULDBL12 to double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tod(_ULDBL12 *pld12, UDOUBLE *d)
{
    return _ld12cvt(pld12, d, &DoubleFormat);
}



/***
* _ld12tof - convert _ULDBL12 to float
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tof(_ULDBL12 *pld12, FLOAT *f)
{
    return _ld12cvt(pld12, f, &FloatFormat);
}


/***
* _ld12told - convert _ULDBL12 to 80 bit long double
*
*******************************************************************************/
void _ld12told(_ULDBL12 *pld12, _ULDOUBLE *pld)
{

    //
    // This implementation is based on the fact that the _ULDBL12 format is
    // identical to the long double and has 2 extra bytes of mantissa
    //

    u_short exp, sign;
    u_long man[INTRNMAN_LEN];

    exp = *U_EXP_12(pld12) & (u_short)0x7fff;
    sign = *U_EXP_12(pld12) & (u_short)0x8000;

    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;

    if (_RoundMan(man, 64))
	exp ++;

    *UL_MANHI_LD(pld) = man[0];
    *UL_MANLO_LD(pld) = man[1];
    *U_EXP_LD(pld) = sign | exp;
}

/***
* _ldtold12 - convert _ULDOUBLE to _ULDBL12
*
*******************************************************************************/
void _ldtold12(_ULDOUBLE *pld, _ULDBL12 *pld12)
{

    //
    // This implementation is based on the fact that the _ULDBL12 format is
    // identical to the long double and has 2 extra bytes of mantissa
    //

    memcpy(pld12, pld, 10);
    *U_XT_12(pld12) = 0;
}


void _atodbl(UDOUBLE *d, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12tod(&ld12, d);
}


void _atoldbl(_ULDOUBLE *ld, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12told(&ld12, ld);
}


void _atoflt(FLOAT *f, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12tof(&ld12, f);
}

double 
Float82ToDouble(const FLOAT128* FpReg82)
{
    double f = 0.0;

    FLOAT82_FORMAT* f82 = (FLOAT82_FORMAT*)FpReg82;
    ULONG64 mant = f82->significand;

    if (mant) 
    {
        int exp = (f82->exponent ? (f82->exponent - 0xffff) : -0x3ffe) - 63;

        // try to minimize abs(iExp)
        while (exp > 0 && mant && !(mant & (ULONG64(1)<<63)))
        {
            mant <<= 1;
            --exp;
        }
        while (exp < 0 && mant && !(mant & 1)) 
        {
            mant >>= 1;
            ++exp;
        }

        f = ldexp(double(mant), exp);
        if (f82->sign)
        {
            f = -f;
        }
    }
    return f;
}

void 
DoubleToFloat82(double f, FLOAT128* FpReg82)
{
    ZeroMemory(FpReg82, sizeof(FLOAT128));
    FLOAT82_FORMAT* f82 = (FLOAT82_FORMAT*)FpReg82;

    // Normalize
    int exp;
    f = frexp(f, &exp);
    
    if (f < 0) 
    {
        f82->sign = 1;
        f = -f;
    }

    // shift fraction into integer part
    ULONG64 mant;
    while (double(mant = ULONG64(f)) < f)
    {
        f = f * 2.0;
        --exp;
    }

    f82->exponent = exp + 0xffff + 0x3f;
    f82->significand = mant;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\float10.h ===
//----------------------------------------------------------------------------
//
// float10.h
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _FLOAT10_H_
#define _FLOAT10_H_

typedef struct {
	double x;
} UDOUBLE;


#pragma pack(4)
typedef UCHAR u_char;
typedef struct {
    u_char ld[10];
} _ULDOUBLE;
#pragma pack()

#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _ULDBL12;
#pragma pack()

#define MAX_MAN_DIGITS 21

#define MAX_10_LEN  30  //max length of string including NULL

// specifies '%f' format

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
		    short   exp;
		    char    sign;
		    char    ManLen;
		    char    man[MAX_MAN_DIGITS+1];
		    } FOS;

char * _uldtoa (_ULDOUBLE *px, int maxchars, char *ldtext);

int    $I10_OUTPUT(_ULDOUBLE ld, int ndigits,
                   unsigned output_flags, FOS	*fos);

//
// return values for strgtold12 routine
//

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

//
// return values for internal conversion routines
// (12-byte to long double, double, or float)
//

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;

unsigned int
__strgtold12(_ULDBL12 *pld12,
             char * *p_end_ptr,
             char *str,
             int mult12);

INTRNCVT_STATUS _ld12tod(_ULDBL12 *pld12, UDOUBLE *d);
void _ld12told(_ULDBL12 *pld12, _ULDOUBLE *pld);
void _ldtold12(_ULDOUBLE *pld, _ULDBL12 *pld12);

void _atodbl(UDOUBLE *d, char *str);
void _atoldbl(_ULDOUBLE *ld, char *str);

//
// Simple FLOAT86 utilities
//

typedef struct {
    ULONG64 significand : 64;
    UINT    exponent    : 17;
    UINT    sign        : 1;
} FLOAT82_FORMAT;

double 
Float82ToDouble(const FLOAT128* FpReg82);

void 
DoubleToFloat82(double f, FLOAT128* FpReg82);

#endif // #ifndef _FLOAT10_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <wcecompat.h>
#include <objbase.h>
#ifndef _WIN32_WCE
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\ntnative.cpp ===
//----------------------------------------------------------------------------
//
// Support routines for NT-native binaries.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifdef NT_NATIVE

#define _CRTIMP
#include <time.h>
#include <ntddser.h>

#include "ntnative.h"
#include "cmnutil.hpp"

void* __cdecl operator new(size_t Bytes)
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Bytes);
}

void __cdecl operator delete(void* Ptr)
{
    RtlFreeHeap(RtlProcessHeap(), 0, Ptr);
}

int __cdecl _purecall(void)
{
    return 0;
}

int __cdecl atexit(void (__cdecl* func)(void))
{
    return 1;
}

#define BASE_YEAR_ADJUSTMENT 11644473600

time_t __cdecl time(time_t* timer)
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do
    {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    // Convert to seconds.
    ULONG64 TimeDate = SystemTime.QuadPart / 10000000;
    // Convert from base year 1601 to base year 1970.
    return (ULONG)(TimeDate - BASE_YEAR_ADJUSTMENT);
}

#ifdef _X86_

LONG WINAPI
InterlockedIncrement(
    IN OUT LONG volatile *lpAddend
    )
{
    __asm
    {
        mov     ecx,lpAddend            ; get pointer to addend variable
        mov     eax,1                   ; set increment value
   lock xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
    }
}

LONG WINAPI
InterlockedDecrement(
    IN OUT LONG volatile *lpAddend
    )
{
    __asm
    {
        mov     ecx,lpAddend            ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value
   lock xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
    }
}

LONG WINAPI
InterlockedExchange(
   IN OUT LONG volatile *Target,
   IN LONG Value
   )
{
    __asm
    {
        mov     ecx, [Target]               ; (ecx) = Target
        mov     edx, [Value]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
   lock cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
    }
}

#endif // #ifdef _X86_

DWORD WINAPI
GetLastError(
    VOID
    )
{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID WINAPI
SetLastError(
    DWORD dwErrCode
    )
{
    NtCurrentTeb()->LastErrorValue = (LONG)dwErrCode;
}

void
BaseSetLastNTError(NTSTATUS NtStatus)
{
    SetLastError(RtlNtStatusToDosError(NtStatus));
}

void WINAPI
Sleep(DWORD Milliseconds)
{
    LARGE_INTEGER Timeout;

    Win32ToNtTimeout(Milliseconds, &Timeout);
    NtDelayExecution(FALSE, &Timeout);
}

HANDLE WINAPI
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle=NULL;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = LongToHandle(dwProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return Handle;
    }
    else
    {
        return NULL;
    }
}

BOOL
CloseHandle(
    HANDLE hObject
    )
{
    return NT_SUCCESS(NtClose(hObject));
}

int
WINAPI
MultiByteToWideChar(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    OUT LPWSTR  lpWideCharStr,
    IN int      cchWideChar)
{
    if (CodePage != CP_ACP || dwFlags != 0)
    {
        return 0;
    }

    UNICODE_STRING Wide;
    ANSI_STRING Ansi;

    RtlInitAnsiString(&Ansi, lpMultiByteStr);
    Wide.Buffer = lpWideCharStr;
    Wide.MaximumLength = (USHORT)cchWideChar;
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Wide, &Ansi, FALSE)))
    {
        return 0;
    }
    else
    {
        return Wide.Length / sizeof(WCHAR) + 1;
    }
}

int
WINAPI
WideCharToMultiByte(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCWSTR  lpWideCharStr,
    IN int      cchWideChar,
    OUT LPSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    IN LPCSTR   lpDefaultChar,
    OUT LPBOOL  lpUsedDefaultChar)
{
    if (CodePage != CP_ACP || dwFlags != 0 || lpDefaultChar != NULL ||
        lpUsedDefaultChar != NULL)
    {
        return 0;
    }

    UNICODE_STRING Wide;
    ANSI_STRING Ansi;

    RtlInitUnicodeString(&Wide, lpWideCharStr);
    Ansi.Buffer = lpMultiByteStr;
    Ansi.MaximumLength = (USHORT)cbMultiByte;
    if (!NT_SUCCESS(RtlUnicodeStringToAnsiString(&Ansi, &Wide, FALSE)))
    {
        return 0;
    }
    else
    {
        return Ansi.Length + 1;
    }
}

DWORD
WINAPI
SuspendThread(
    IN HANDLE hThread
    )
{
    DWORD PrevCount=0;
    NTSTATUS NtStatus;

    NtStatus = NtSuspendThread(hThread, &PrevCount);
    if (NT_SUCCESS(NtStatus))
    {
        return PrevCount;
    }
    else
    {
        BaseSetLastNTError(NtStatus);
        return -1;
    }
}

DWORD
WINAPI
ResumeThread(
    IN HANDLE hThread
    )
{
    DWORD PrevCount=0;
    NTSTATUS NtStatus;

    NtStatus = NtResumeThread(hThread, &PrevCount);
    if (NT_SUCCESS(NtStatus))
    {
        return PrevCount;
    }
    else
    {
        BaseSetLastNTError(NtStatus);
        return -1;
    }
}

DWORD
WINAPI
GetCurrentThreadId(void)
{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

DWORD
WINAPI
GetCurrentProcessId(void)
{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
}

HANDLE
WINAPI
GetCurrentProcess(void)
{
    return NtCurrentProcess();
}

BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesRead
    )
{
    NTSTATUS Status;
    SIZE_T NtNumberOfBytesRead=0;

    Status = NtReadVirtualMemory(hProcess,
                                 (PVOID)lpBaseAddress,
                                 lpBuffer,
                                 nSize,
                                 &NtNumberOfBytesRead
                                 );

    if ( lpNumberOfBytesRead != NULL )
    {
        *lpNumberOfBytesRead = NtNumberOfBytesRead;
    }

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
    )
{
    NTSTATUS Status, xStatus;
    ULONG OldProtect;
    SIZE_T RegionSize;
    PVOID Base;
    SIZE_T NtNumberOfBytesWritten;

    //
    // Set the protection to allow writes
    //

    RegionSize =  nSize;
    Base = lpBaseAddress;
    Status = NtProtectVirtualMemory(hProcess,
                                    &Base,
                                    &RegionSize,
                                    PAGE_EXECUTE_READWRITE,
                                    &OldProtect
                                    );
    if ( NT_SUCCESS(Status) )
    {
        //
        // See if previous protection was writable. If so,
        // then reset protection and do the write.
        // Otherwise, see if previous protection was read-only or
        // no access. In this case, don't do the write, just fail
        //

        if ( (OldProtect & PAGE_READWRITE) == PAGE_READWRITE ||
             (OldProtect & PAGE_WRITECOPY) == PAGE_WRITECOPY ||
             (OldProtect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE ||
             (OldProtect & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY )
        {
            Status = NtProtectVirtualMemory(hProcess,
                                            &Base,
                                            &RegionSize,
                                            OldProtect,
                                            &OldProtect
                                            );
            Status = NtWriteVirtualMemory(hProcess,
                                          lpBaseAddress,
                                          lpBuffer,
                                          nSize,
                                          &NtNumberOfBytesWritten
                                          );

            if ( lpNumberOfBytesWritten != NULL )
            {
                *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
            }

            if ( !NT_SUCCESS(Status) )
            {
                BaseSetLastNTError(Status);
                return FALSE;
            }
            NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
            return TRUE;
        }
        else
        {
            //
            // See if the previous protection was read only or no access. If
            // this is the case, restore the previous protection and return
            // an access violation error.
            //
            if ( (OldProtect & PAGE_NOACCESS) == PAGE_NOACCESS ||
                 (OldProtect & PAGE_READONLY) == PAGE_READONLY )
            {
                Status = NtProtectVirtualMemory(hProcess,
                                                &Base,
                                                &RegionSize,
                                                OldProtect,
                                                &OldProtect
                                                );
                BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                return FALSE;
            }
            else
            {
                //
                // The previous protection must have been code and the caller
                // is trying to set a breakpoint or edit the code. Do the write
                // and then restore the previous protection.
                //

                Status = NtWriteVirtualMemory(hProcess,
                                              lpBaseAddress,
                                              lpBuffer,
                                              nSize,
                                              &NtNumberOfBytesWritten
                                              );

                if ( lpNumberOfBytesWritten != NULL )
                {
                    *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                }

                xStatus = NtProtectVirtualMemory(hProcess,
                                                 &Base,
                                                 &RegionSize,
                                                 OldProtect,
                                                 &OldProtect
                                                 );
                if ( !NT_SUCCESS(Status) )
                {
                    BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                    return STATUS_ACCESS_VIOLATION;
                }
                NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
                return TRUE;
            }
        }
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )
{
    NTSTATUS Status;

    Status = NtDuplicateObject(hSourceProcessHandle,
                               hSourceHandle,
                               hTargetProcessHandle,
                               lpTargetHandle,
                               (ACCESS_MASK)dwDesiredAccess,
                               bInheritHandle ? OBJ_INHERIT : 0,
                               dwOptions
                               );
    if ( NT_SUCCESS(Status) )
    {
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return FALSE;
}

BOOL
APIENTRY
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    )
{
    NTSTATUS Status;

    Status = NtGetContextThread(hThread,lpContext);

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
APIENTRY
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    )
{
    NTSTATUS Status;

    Status = NtSetContextThread(hThread,(PCONTEXT)lpContext);

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
APIENTRY
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    )
{
#if defined(i386)

    DESCRIPTOR_TABLE_ENTRY DescriptorEntry;
    NTSTATUS Status;

    DescriptorEntry.Selector = dwSelector;
    Status = NtQueryInformationThread(hThread,
                                      ThreadDescriptorTableEntry,
                                      &DescriptorEntry,
                                      sizeof(DescriptorEntry),
                                      NULL
                                      );
    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *lpSelectorEntry = DescriptorEntry.Descriptor;
    return TRUE;

#else
    BaseSetLastNTError(STATUS_NOT_SUPPORTED);
    return FALSE;
#endif // i386
}

BOOL
WINAPI
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    )
{
    NTSTATUS Status;
    STRING Name;
    STRING Value;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &Name, TRUE);
    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    if (ARGUMENT_PRESENT( lpValue ))
    {
        RtlInitString( &Value, lpValue );
        Status = RtlAnsiStringToUnicodeString(&UnicodeValue, &Value, TRUE);
        if ( !NT_SUCCESS(Status) )
        {
            BaseSetLastNTError( Status );
            RtlFreeUnicodeString(&UnicodeName);
            return FALSE;
        }
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, &UnicodeValue);
        RtlFreeUnicodeString(&UnicodeValue);
    }
    else
    {
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, NULL);
    }
    RtlFreeUnicodeString(&UnicodeName);

    if (NT_SUCCESS( Status ))
    {
        return( TRUE );
    }
    else
    {
        BaseSetLastNTError( Status );
        return( FALSE );
    }
}

BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    )
{
    NTSTATUS Status;

    if ( hProcess == NULL )
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Status = NtTerminateProcess(hProcess,(NTSTATUS)uExitCode);
    if ( NT_SUCCESS(Status) )
    {
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    )
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       NULL
                                       );

    if ( NT_SUCCESS(Status) )
    {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

HANDLE
WINAPI
NtNativeCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags = 0;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    PUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityAnonymous;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    if (ARGUMENT_PRESENT(hTemplateFile))
    {
        return INVALID_HANDLE_VALUE;
    }

    switch ( dwCreationDisposition )
    {
    case CREATE_NEW        :
        CreateDisposition = FILE_CREATE;
        break;
    case CREATE_ALWAYS     :
        CreateDisposition = FILE_OVERWRITE_IF;
        break;
    case OPEN_EXISTING     :
        CreateDisposition = FILE_OPEN;
        break;
    case OPEN_ALWAYS       :
        CreateDisposition = FILE_OPEN_IF;
        break;
    case TRUNCATE_EXISTING :
        CreateDisposition = FILE_OPEN;
        if ( !(dwDesiredAccess & GENERIC_WRITE) )
        {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
        break;
    default :
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    RtlInitUnicodeString(&FileName,lpFileName);

    if (TranslatePath)
    {
        TranslationStatus = RtlDosPathNameToNtPathName_U(lpFileName,
                                                         &FileName,
                                                         NULL,
                                                         NULL
                                                         );

        if ( !TranslationStatus )
        {
            SetLastError(ERROR_PATH_NOT_FOUND);
            return INVALID_HANDLE_VALUE;
        }

        FreeBuffer = FileName.Buffer;
    }
    else
    {
        FreeBuffer = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS) ? 0 : OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT )
    {
        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING)
        {
            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;
        }
        else
        {
            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY)
        {
            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;
        }
        else
        {
            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL)(SQOSFlags >> 16);
    }
    else
    {
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) )
    {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle )
        {
            Obja.Attributes |= OBJ_INHERIT;
        }
    }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE )
    {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
    }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT )
    {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
    }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL )
    {
        CreateFlags |= FILE_OPEN_NO_RECALL;
    }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) )
    {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
    }
    else
    {
        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) )
        {
            CreateFlags |= FILE_DIRECTORY_FILE;
        }
    }

    Status = NtCreateFile(&Handle,
                          (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                          dwShareMode,
                          CreateDisposition,
                          CreateFlags,
                          NULL,
                          0
                          );

    if (FreeBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION )
        {
            SetLastError(ERROR_FILE_EXISTS);
        }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY )
        {
            SetLastError(ERROR_ACCESS_DENIED);
        }
        return INVALID_HANDLE_VALUE;
    }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information ==
          FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) )
    {
        SetLastError(ERROR_ALREADY_EXISTS);
    }
    else
    {
        SetLastError(0);
    }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING)
    {
        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &AllocationInfo,
                                      sizeof(AllocationInfo),
                                      FileAllocationInformation
                                      );
        if ( !NT_SUCCESS(Status) )
        {
            BaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
        }
    }

    return Handle;
}

HANDLE
WINAPI
NtNativeCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiFile;
    UNICODE_STRING WideFile;

    RtlInitAnsiString(&AnsiFile, lpFileName);
    Status = RtlAnsiStringToUnicodeString(&WideFile, &AnsiFile, TRUE);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    HANDLE File;

    File = NtNativeCreateFileW(WideFile.Buffer, dwDesiredAccess, dwShareMode,
                               lpSecurityAttributes, dwCreationDisposition,
                               dwFlagsAndAttributes, hTemplateFile,
                               TranslatePath);

    RtlFreeUnicodeString(&WideFile);
    return File;
}

HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return NtNativeCreateFileA(lpFileName, dwDesiredAccess, dwShareMode,
                               lpSecurityAttributes, dwCreationDisposition,
                               dwFlagsAndAttributes, hTemplateFile,
                               TRUE);
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )
{
    if ((dwIoControlCode >> 16) == FILE_DEVICE_FILE_SYSTEM ||
        lpOverlapped != NULL)
    {
        return FALSE;
    }

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    Status = NtDeviceIoControlFile(hDevice,
                                   NULL,
                                   NULL,             // APC routine
                                   NULL,             // APC Context
                                   &Iosb,
                                   dwIoControlCode,  // IoControlCode
                                   lpInBuffer,       // Buffer for data to the FS
                                   nInBufferSize,
                                   lpOutBuffer,      // OutputBuffer for data from the FS
                                   nOutBufferSize    // OutputBuffer Length
                                   );

    if ( Status == STATUS_PENDING)
    {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
        if ( NT_SUCCESS(Status))
        {
            Status = Iosb.Status;
        }
    }

    if ( NT_SUCCESS(Status) )
    {
        *lpBytesReturned = (DWORD)Iosb.Information;
        return TRUE;
    }
    else
    {
        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) )
        {
            *lpBytesReturned = (DWORD)Iosb.Information;
        }
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
    {
        *lpNumberOfBytesRead = 0;
    }

    if ( ARGUMENT_PRESENT( lpOverlapped ) )
    {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
            {
                __try
                {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    *lpNumberOfBytesRead = 0;
                }
            }
            return TRUE;
        }
        else if (Status == STATUS_END_OF_FILE)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
            {
                *lpNumberOfBytesRead = 0;
            }
            BaseSetLastNTError(Status);
            return FALSE;
        }
        else
        {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    else
    {
        Status = NtReadFile(hFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            NULL,
                            NULL
                        );

        if ( Status == STATUS_PENDING)
        {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status))
            {
                Status = IoStatusBlock.Status;
            }
        }

        if ( NT_SUCCESS(Status) )
        {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
        }
        else
        {
            if (Status == STATUS_END_OF_FILE)
            {
                *lpNumberOfBytesRead = 0;
                return TRUE;
            }
            else
            {
                if ( NT_WARNING(Status) )
                {
                    *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }
    }
}

BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) )
    {
        *lpNumberOfBytesWritten = 0;
    }

    if ( ARGUMENT_PRESENT( lpOverlapped ) )
    {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) )
            {
                __try
                {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    *lpNumberOfBytesWritten = 0;
                }
            }
            return TRUE;
        }
        else
        {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    else
    {
        Status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)lpBuffer,
                             nNumberOfBytesToWrite,
                             NULL,
                             NULL
                             );

        if ( Status == STATUS_PENDING)
        {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status))
            {
                Status = IoStatusBlock.Status;
            }
        }

        if ( NT_SUCCESS(Status))
        {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
        }
        else
        {
            if ( NT_WARNING(Status) )
            {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
}

SIZE_T
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{
    NTSTATUS Status;
    SIZE_T ReturnLength = 0;

    Status = NtQueryVirtualMemory( hProcess,
                                   (LPVOID)lpAddress,
                                   MemoryBasicInformation,
                                   (PMEMORY_BASIC_INFORMATION)lpBuffer,
                                   dwLength,
                                   &ReturnLength
                                 );
    if (NT_SUCCESS( Status ))
    {
        return( ReturnLength );
    }
    else
    {
        BaseSetLastNTError( Status );
        return( 0 );
    }
}

BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( hProcess,
                                     &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtProtectVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  flNewProtect,
                                                  lpflOldProtect
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

    __try {
        Status = NtAllocateVirtualMemory( hProcess,
                                          &lpAddress,
                                          0,
                                          &dwSize,
                                          flAllocationType,
                                          flProtect
                                        );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
        }
    else {
        BaseSetLastNTError( Status );
        return( NULL );
        }
}

BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;


    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( hProcess,
                                  &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtFreeVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  dwFreeType
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }

        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
    return CreateRemoteThread( NtCurrentProcess(),
                               lpThreadAttributes,
                               dwStackSize,
                               lpStartAddress,
                               lpParameter,
                               dwCreationFlags,
                               lpThreadId
                               );
}

HANDLE
APIENTRY
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    CLIENT_ID ClientId;

    Handle = NULL;

    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //
    if ((dwCreationFlags & STACK_SIZE_PARAM_IS_A_RESERVATION) ||
        dwStackSize != 0 || lpThreadAttributes != NULL)
    {
        return NULL;
    }

    Status = RtlCreateUserThread (hProcess,
                                  NULL,
                                  (dwCreationFlags & CREATE_SUSPENDED) ?
                                  TRUE : FALSE,
                                  0,
                                  0,
                                  0,
                                  (PUSER_THREAD_START_ROUTINE)lpStartAddress,
                                  lpParameter,
                                  &Handle,
                                  &ClientId);

    if ( ARGUMENT_PRESENT(lpThreadId) )
    {
        *lpThreadId = HandleToUlong(ClientId.UniqueThread);
    }

    return Handle;
}

#define DOS_LOCAL_PIPE_PREFIX   L"\\\\.\\pipe\\"
#define DOS_LOCAL_PIPE          L"\\DosDevices\\pipe\\"
#define DOS_REMOTE_PIPE         L"\\DosDevices\\UNC\\"

#define INVALID_PIPE_MODE_BITS  ~(PIPE_READMODE_BYTE    \
                                | PIPE_READMODE_MESSAGE \
                                | PIPE_WAIT             \
                                | PIPE_NOWAIT)

HANDLE
APIENTRY
NtNativeCreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    )

/*++


Parameters:

    lpName --Supplies the pipe name Documented in "Pipe Names" section
        earlier.  This must be a local name.

    dwOpenMode --Supplies the set of flags that define the mode which the
        pipe is to be opened with.  The open mode consists of access
        flags (one of three values) logically ORed with a writethrough
        flag (one of two values) and an overlapped flag (one of two
        values), as described below.

        dwOpenMode Flags:

        PIPE_ACCESS_DUPLEX --Pipe is bidirectional.  (This is
            semantically equivalent to calling CreateFile with access
            flags of GENERIC_READ | GENERIC_WRITE.)

        PIPE_ACCESS_INBOUND --Data goes from client to server only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_READ.)

        PIPE_ACCESS_OUTBOUND --Data goes from server to client only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_WRITE.)

        PIPE_WRITETHROUGH --The redirector is not permitted to delay the
            transmission of data to the named pipe buffer on the remote
            server. This disables a performance enhancement for
            applications that need synchronization with every write
            operation.

        FILE_FLAG_OVERLAPPED --Indicates that the system should
            initialize the file so that ReadFile, WriteFile and other
            operations that may take a significant time to process will
            return ERROR_IO_PENDING. An event will be set to the
            signalled state when the operation completes.

        FILE_FLAG_WRITETHROUGH -- No intermediate buffering.

        WRITE_DAC --            Standard security desired access
        WRITE_OWNER --          ditto
        ACCESS_SYSTEM_SECURITY -- ditto

    dwPipeMode --Supplies the pipe-specific modes (as flags) of the pipe.
        This parameter is a combination of a read-mode flag, a type flag,
        and a wait flag.

        dwPipeMode Flags:

        PIPE_WAIT --Blocking mode is to be used for this handle.

        PIPE_NOWAIT --Nonblocking mode is to be used for this handle.

        PIPE_READMODE_BYTE --Read pipe as a byte stream.

        PIPE_READMODE_MESSAGE --Read pipe as a message stream.  Note that
            this is not allowed with PIPE_TYPE_BYTE.

        PIPE_TYPE_BYTE --Pipe is a byte-stream pipe.  Note that this is
            not allowed with PIPE_READMODE_MESSAGE.

        PIPE_TYPE_MESSAGE --Pipe is a message-stream pipe.

    nMaxInstances --Gives the maximum number of instances for this pipe.
        Acceptable values are 1 to PIPE_UNLIMITED_INSTANCES-1 and
        PIPE_UNLIMITED_INSTANCES.

        nMaxInstances Special Values:

        PIPE_UNLIMITED_INSTANCES --Unlimited instances of this pipe can
            be created.

    nOutBufferSize --Specifies an advisory on the number of bytes to
        reserve for the outgoing buffer.

    nInBufferSize --Specifies an advisory on the number of bytes to
        reserve for the incoming buffer.

    nDefaultTimeOut -- Specifies an optional pointer to a timeout value
        that is to be used if a timeout value is not specified when
        waiting for an instance of a named pipe. This parameter is only
        meaningful when the first instance of a named pipe is created. If
        neither CreateNamedPipe or WaitNamedPipe specify a timeout 50
        milliseconds will be used.

    lpSecurityAttributes --An optional parameter that, if present and
        supported on the target system, supplies a security descriptor
        for the named pipe.  This parameter includes an inheritance flag
        for the handle.  If this parameter is not present, the handle is
        not inherited by child processes.

Return Value:

    Returns one of the following:

    INVALID_HANDLE_VALUE --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent named pipe operations.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    LARGE_INTEGER Timeout;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    ULONG DesiredAccess;
    ULONG ShareAccess;
    ULONG MaxInstances;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL DefaultAcl = NULL;

    if ((nMaxInstances == 0) ||
        (nMaxInstances > PIPE_UNLIMITED_INSTANCES)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
        }

    // Convert Win32 maximum Instances to Nt maximum instances.
    MaxInstances = (nMaxInstances == PIPE_UNLIMITED_INSTANCES)?
        0xffffffff : nMaxInstances;

    if (TranslatePath)
    {
        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                                         lpName,
                                                         &FileName,
                                                         NULL,
                                                         NULL
                                                         );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            return INVALID_HANDLE_VALUE;
        }

        FreeBuffer = FileName.Buffer;
    }
    else
    {
        RtlInitUnicodeString(&FileName, lpName);
        FreeBuffer = NULL;
    }        

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    if (Obja.SecurityDescriptor == NULL) {

        //
        // Apply default security if none specified (bug 131090)
        //

        Status = RtlDefaultNpAcl( &DefaultAcl );
        if (NT_SUCCESS( Status )) {
            RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
            RtlSetDaclSecurityDescriptor( &SecurityDescriptor, TRUE, DefaultAcl, FALSE );
            Obja.SecurityDescriptor = &SecurityDescriptor;
        } else {
            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            BaseSetLastNTError(Status);
            return INVALID_HANDLE_VALUE;
        }
    }

    //  End of code common with fileopcr.c CreateFile()

    CreateFlags = (dwOpenMode & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwOpenMode & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT);

    //
    //  Determine the timeout. Convert from milliseconds to an Nt delta time
    //

    if ( nDefaultTimeOut ) {
        Timeout.QuadPart = - (LONGLONG)UInt32x32To64( 10 * 1000, nDefaultTimeOut );
        }
    else {
        //  Default timeout is 50 Milliseconds
        Timeout.QuadPart =  -10 * 1000 * 50;
        }

    //  Check no reserved bits are set by mistake.

    if (( dwOpenMode & ~(PIPE_ACCESS_DUPLEX |
                         FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH |
                         FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC |
                         WRITE_OWNER | ACCESS_SYSTEM_SECURITY ))||

        ( dwPipeMode & ~(PIPE_NOWAIT | PIPE_READMODE_MESSAGE |
                         PIPE_TYPE_MESSAGE ))) {

            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    //
    //  Translate the open mode into a sharemode to restrict the clients access
    //  and derive the appropriate local desired access.
    //

    switch ( dwOpenMode & PIPE_ACCESS_DUPLEX ) {
        case PIPE_ACCESS_INBOUND:
            ShareAccess = FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ;
            break;

        case PIPE_ACCESS_OUTBOUND:
            ShareAccess = FILE_SHARE_READ;
            DesiredAccess = GENERIC_WRITE;
            break;

        case PIPE_ACCESS_DUPLEX:
            ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        default:
            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    DesiredAccess |= SYNCHRONIZE |
         ( dwOpenMode & (WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY ));

    Status = NtCreateNamedPipeFile (
        &Handle,
        DesiredAccess,
        &Obja,
        &IoStatusBlock,
        ShareAccess,
        (dwOpenMode & FILE_FLAG_FIRST_PIPE_INSTANCE) ?
            FILE_CREATE : FILE_OPEN_IF, // Create first instance or subsequent
        CreateFlags,                    // Create Options
        dwPipeMode & PIPE_TYPE_MESSAGE ?
            FILE_PIPE_MESSAGE_TYPE : FILE_PIPE_BYTE_STREAM_TYPE,
        dwPipeMode & PIPE_READMODE_MESSAGE ?
            FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE,
        dwPipeMode & PIPE_NOWAIT ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION,
        MaxInstances,                   // Max instances
        nInBufferSize,                  // Inbound quota
        nOutBufferSize,                 // Outbound quota
        (PLARGE_INTEGER)&Timeout
        );

    if ( Status == STATUS_NOT_SUPPORTED ||
         Status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than NPFS).  Map the error to something reasonable.
        //

        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (FreeBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    }
    if (DefaultAcl != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    return Handle;
}

HANDLE
APIENTRY
NtNativeCreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    )

/*++
    Ansi thunk to CreateNamedPipeW.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return INVALID_HANDLE_VALUE;
        }

    return NtNativeCreateNamedPipeW(
            (LPCWSTR)Unicode->Buffer,
            dwOpenMode,
            dwPipeMode,
            nMaxInstances,
            nOutBufferSize,
            nInBufferSize,
            nDefaultTimeOut,
            lpSecurityAttributes,
            TranslatePath);
}

BOOL
APIENTRY
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    The ConnectNamedPipe function is used by the server side of a named pipe
    to wait for a client to connect to the named pipe with a CreateFile
    request. The handle provided with the call to ConnectNamedPipe must have
    been previously returned by a successful call to CreateNamedPipe. The pipe
    must be in the disconnected, listening or connected states for
    ConnectNamedPipe to succeed.

    The behavior of this call depends on the blocking/nonblocking mode selected
    with the PIPE_WAIT/PIPE_NOWAIT flags when the server end of the pipe was
    created with CreateNamedPipe.

    If blocking mode is specified, ConnectNamedPipe will change the state from
    disconnected to listening and block. When a client connects with a
    CreateFile, the state will be changed from listening to connected and the
    ConnectNamedPipe returns TRUE. When the file handle is created with
    FILE_FLAG_OVERLAPPED on a blocking mode pipe, the lpOverlapped parameter
    can be specified. This allows the caller to continue processing while the
    ConnectNamedPipe API awaits a connection. When the pipe enters the
    signalled state the event is set to the signalled state.

    When nonblocking is specified ConnectNamedPipe will not block. On the
    first call the state will change from disconnected to listening. When a
    client connects with an Open the state will be changed from listening to
    connected. The ConnectNamedPipe will return FALSE (with GetLastError
    returning ERROR_PIPE_LISTENING) until the state is changed to the listening
    state.

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

    lpOverlapped - Supplies an overlap structure to be used with the request.
        If NULL then the API will not return until the operation completes. When
        FILE_FLAG_OVERLAPPED is specified when the handle was created,
        ConnectNamedPipe may return ERROR_IO_PENDING to allow the caller to
        continue processing while the operation completes. The event (or File
        handle if hEvent=NULL) will be set to the not signalled state before
        ERROR_IO_PENDING is returned. The event will be set to the signalled
        state upon completion of the request. GetOverlappedResult is used to
        determine the error status.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if ( lpOverlapped ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        }
    Status = NtFsControlFile(
                hNamedPipe,
                (lpOverlapped==NULL)? NULL : lpOverlapped->hEvent,
                NULL,   // ApcRoutine
                lpOverlapped ? ((ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped) : NULL,
                (lpOverlapped==NULL) ? &Iosb : (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                FSCTL_PIPE_LISTEN,
                NULL,   // InputBuffer
                0,      // InputBufferLength,
                NULL,   // OutputBuffer
                0       // OutputBufferLength
                );

    if ( lpOverlapped == NULL && Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = Iosb.Status;
            }
        }

    if (NT_SUCCESS( Status ) && Status != STATUS_PENDING ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

    Ansi thunk to WaitNamedPipeW

--*/
{
    ANSI_STRING Ansi;
    UNICODE_STRING UnicodeString;
    BOOL b;

    RtlInitAnsiString(&Ansi, lpNamedPipeName);
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString, &Ansi, TRUE))) {
        return FALSE;
    }

    b = WaitNamedPipeW( UnicodeString.Buffer, nTimeOut );

    RtlFreeUnicodeString(&UnicodeString);

    return b;

}

BOOL
APIENTRY
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

Routine Description:

    The WaitNamedPipe function waits for a named pipe to become available.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

    nTimeOut Special Values:

        NMPWAIT_WAIT_FOREVER
            No timeout.

        NMPWAIT_USE_DEFAULT_WAIT
            Use default timeout set in call to CreateNamedPipe.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    RTL_PATH_TYPE PathType;
    ULONG WaitPipeLength;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitPipe;
    PWSTR FreeBuffer;
    UNICODE_STRING FileSystem;
    UNICODE_STRING PipeName;
    UNICODE_STRING OriginalPipeName;
    UNICODE_STRING ValidUnicodePrefix;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    LPWSTR Pwc;
    ULONG Index;

    //
    //  Open a handle either to the redirector or the NPFS depending on
    //  the start of the pipe name. Split lpNamedPipeName into two
    //  halves as follows:
    //      \\.\pipe\pipename       \\.\pipe\ and pipename
    //      \\server\pipe\pipename  \\ and server\pipe\pipename
    //

    if (!RtlCreateUnicodeString( &OriginalPipeName, lpNamedPipeName)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }

    //
    //  Change all the forward slashes into backward slashes.
    //

    for ( Index =0; Index < (OriginalPipeName.Length/sizeof(WCHAR)); Index++ ) {
        if (OriginalPipeName.Buffer[Index] == L'/') {
            OriginalPipeName.Buffer[Index] = L'\\';
            }
        }

    PipeName = OriginalPipeName;

    PathType = RtlDetermineDosPathNameType_U(lpNamedPipeName);

    FreeBuffer = NULL;

    switch ( PathType ) {
    case RtlPathTypeLocalDevice:

            //  Name should be of the form \\.\pipe\pipename (IgnoreCase)

            RtlInitUnicodeString( &ValidUnicodePrefix, DOS_LOCAL_PIPE_PREFIX);

            if (RtlPrefixString((PSTRING)&ValidUnicodePrefix,
                    (PSTRING)&PipeName,
                    TRUE) == FALSE) {
                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Skip first 9 characters "\\.\pipe\"
            PipeName.Buffer+=9;
            PipeName.Length-=9*sizeof(WCHAR);

            RtlInitUnicodeString( &FileSystem, DOS_LOCAL_PIPE);

            break;

        case RtlPathTypeUncAbsolute:
            //  Name is of the form \\server\pipe\pipename

            //  Find the pipe name.

            for ( Pwc = &PipeName.Buffer[2]; *Pwc != 0; Pwc++) {
                if ( *Pwc == L'\\') {
                    //  Found backslash after servername
                    break;
                    }
                }

            if ( (*Pwc != 0) &&
                 ( _wcsnicmp( Pwc + 1, L"pipe\\", 5 ) == 0 ) ) {

                // Temporarily, break this up into 2 strings
                //    string1 = \\server\pipe
                //    string2 = the-rest

                Pwc += (sizeof (L"pipe\\") / sizeof( WCHAR ) ) - 1;

            } else {

                // This is not a valid remote path name.

                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Pwc now points to the first path seperator after \\server\pipe.
            //  Attempt to open \DosDevices\Unc\Servername\Pipe.

            PipeName.Buffer = &PipeName.Buffer[2];
            PipeName.Length = (USHORT)((PCHAR)Pwc - (PCHAR)PipeName.Buffer);
            PipeName.MaximumLength = PipeName.Length;

            FileSystem.MaximumLength =
                (USHORT)sizeof( DOS_REMOTE_PIPE ) +
                PipeName.MaximumLength;

            FileSystem.Buffer = (PWSTR)RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    FileSystem.MaximumLength
                                    );

            if ( !FileSystem.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                RtlFreeUnicodeString(&OriginalPipeName);
                return FALSE;
                }
            FreeBuffer = FileSystem.Buffer;

            RtlCopyMemory(
                FileSystem.Buffer,
                DOS_REMOTE_PIPE,
                sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR)
                );

            FileSystem.Length = sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR);

            RtlAppendUnicodeStringToString( &FileSystem, &PipeName );

            // Set up pipe name, skip leading backslashes.

            RtlInitUnicodeString( &PipeName, (PWCH)Pwc + 1 );

            break;

        default:
            BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
            RtlFreeUnicodeString(&OriginalPipeName);
            return FALSE;
        }


    InitializeObjectAttributes(
        &Obja,
        &FileSystem,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    WaitPipeLength =
        FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + PipeName.Length;
    WaitPipe = (PFILE_PIPE_WAIT_FOR_BUFFER)
        RtlAllocateHeap(RtlProcessHeap(), 0, WaitPipeLength);
    if ( !WaitPipe ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        NtClose(Handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
        }

    if ( nTimeOut == NMPWAIT_USE_DEFAULT_WAIT ) {
        WaitPipe->TimeoutSpecified = FALSE;
        }
    else {
        if ( nTimeOut == NMPWAIT_WAIT_FOREVER ) {
            WaitPipe->Timeout.LowPart = 0;
            WaitPipe->Timeout.HighPart =0x80000000;
            }
        else {
            //
            //  Convert from milliseconds to an Nt delta time.
            //

            WaitPipe->Timeout.QuadPart =
                                - (LONGLONG)UInt32x32To64( 10 * 1000, nTimeOut );
            }
        WaitPipe->TimeoutSpecified = TRUE;
        }

    WaitPipe->NameLength = PipeName.Length;

    RtlCopyMemory(
        WaitPipe->Name,
        PipeName.Buffer,
        PipeName.Length
        );

    RtlFreeUnicodeString(&OriginalPipeName);

    Status = NtFsControlFile(Handle,
                        NULL,
                        NULL,           // APC routine
                        NULL,           // APC Context
                        &Iosb,
                        FSCTL_PIPE_WAIT,// IoControlCode
                        WaitPipe,       // Buffer for data to the FS
                        WaitPipeLength,
                        NULL,           // OutputBuffer for data from the FS
                        0               // OutputBuffer Length
                        );

    RtlFreeHeap(RtlProcessHeap(),0,WaitPipe);

    NtClose(Handle);

    if (NT_SUCCESS( Status ) ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    )
/*++

Routine Description:

    The PeekNamedPipe function copies a named pipe's data into a buffer for
    preview without removing it. The results of a PeekNamedPipe are similar to
    a ReadFile on the pipe except more information is returned, the function
    never blocks and if the pipe handle is reading in message mode, a partial
    message can be returned.

    A partial message peek'd on a message mode pipe will return TRUE.

    It is not an error if all of the pointers passed to this function are
    null. However, there is no reason for calling it this way.

    The NT peek call has the received data immediately after the state
    information so this routine needs to allocate an intermediate buffer
    large enough for the state information plus data.

Arguments:

    hNamedPipe - Supplies a handle to a named pipe.

    lpBuffer - If non-null, pointer to buffer to read data into.

    nBufferSize - Size of input buffer, in bytes. (Ignored if lpBuffer
        is null.)

    lpBytesRead - If non-null, this points to a DWORD which will be set
        with the number of bytes actually read.

    lpTotalBytesAvail - If non-null, this points to a DWORD which receives
        a value giving the number of bytes that were available to be read.

    lpBytesLeftThisMessage - If non-null, this points to a DWORD which
        will be set to the number of bytes left in this message. (This will
        be zero for a byte-stream pipe.)

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    PFILE_PIPE_PEEK_BUFFER PeekBuffer;
    DWORD IOLength;

    // Allocate enough for the users data and FILE_PIPE_PEEK_BUFFER

    IOLength = nBufferSize + FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);
    PeekBuffer = (PFILE_PIPE_PEEK_BUFFER)
        RtlAllocateHeap(RtlProcessHeap(), 0, IOLength);
    if (PeekBuffer == NULL) {
        BaseSetLastNTError (STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;
    }

    __try {

        Status = NtFsControlFile(hNamedPipe,
                    NULL,
                    NULL,           // APC routine
                    NULL,           // APC Context
                    &Iosb,          // I/O Status block
                    FSCTL_PIPE_PEEK,// IoControlCode
                    NULL,           // Buffer for data to the FS
                    0,              // Length.
                    PeekBuffer,     // OutputBuffer for data from the FS
                    IOLength        // OutputBuffer Length
                    );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        //
        //  Buffer overflow simply means that lpBytesLeftThisMessage != 0
        //

        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            Status = STATUS_SUCCESS;
        }

        //
        //  Peek is complete, package up data for caller ensuring that
        //  the PeekBuffer is deleted even if an invalid pointer was given.
        //

        if ( NT_SUCCESS(Status)) {

            __try {

                if ( ARGUMENT_PRESENT( lpTotalBytesAvail ) ) {
                    *lpTotalBytesAvail = PeekBuffer->ReadDataAvailable;
                    }

                if ( ARGUMENT_PRESENT( lpBytesRead ) ) {
                    *lpBytesRead = (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }

                if ( ARGUMENT_PRESENT( lpBytesLeftThisMessage ) ) {
                    *lpBytesLeftThisMessage =
                        PeekBuffer->MessageLength -
                        (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }

                if ( ARGUMENT_PRESENT( lpBuffer ) ) {
                    RtlCopyMemory(
                        lpBuffer,
                        PeekBuffer->Data,
                        Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                    }
                }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = STATUS_ACCESS_VIOLATION;
                }
            }
        }

    __finally {

        if ( PeekBuffer != NULL ) {
            RtlFreeHeap(RtlProcessHeap(),0,PeekBuffer);
            }
        }

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {

        if (dwMilliseconds == INFINITE)
        {
            pTimeOut = NULL;
        }
        else
        {
            Win32ToNtTimeout(dwMilliseconds, &TimeOut);
            pTimeOut = &TimeOut;
        }
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    if (nCount > 8) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0xffffffff;
    }

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        HandleArray = Handles;

        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();

        if (dwMilliseconds == INFINITE)
        {
            pTimeOut = NULL;
        }
        else
        {
            Win32ToNtTimeout(dwMilliseconds, &TimeOut);
            pTimeOut = &TimeOut;
        }
    rewait:
        Status = NtWaitForMultipleObjects(
                     (CHAR)nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

HANDLE
APIENTRY
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateEventW(
                lpEventAttributes,
                bManualReset,
                bInitialState,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if (lpName != NULL || lpEventAttributes != NULL)
    {
        return FALSE;
    }

    pObja = NULL;

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        BaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}

BOOL
WINAPI
CancelIo(
    HANDLE hFile
    )

/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Simply cancel the I/O for the specified file.
    //

    Status = NtCancelIoFile(hFile, &IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }

}

BOOL
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    )

/*++

Routine Description:

    In case of a communications error, such as a buffer overrun or
    framing error, the communications software will abort all
    read and write operations on the communication port.  No further
    read or write operations will be accepted until this function
    is called.

Arguments:

    hFile - Specifies the communication device to be adjusted.

    lpErrors - Points to the DWORD that is to receive the mask of the
               error that occured.

    lpStat - Points to the COMMSTAT structure that is to receive
             the device status.  The structure contains information
             about the communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_STATUS LocalStat;

    RtlZeroMemory(&LocalStat, sizeof(SERIAL_STATUS));

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_COMMSTATUS,
                 NULL,
                 0,
                 &LocalStat,
                 sizeof(LocalStat)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (lpStat) {

        //
        // All is well up to this point.  Translate the NT values
        // into win32 values.
        //

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_CTS) {

            lpStat->fCtsHold = TRUE;

        } else {

            lpStat->fCtsHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DSR) {

            lpStat->fDsrHold = TRUE;

        } else {

            lpStat->fDsrHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DCD) {

            lpStat->fRlsdHold = TRUE;

        } else {

            lpStat->fRlsdHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_XON) {

            lpStat->fXoffHold = TRUE;

        } else {

            lpStat->fXoffHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_XOFF_SENT) {

            lpStat->fXoffSent = TRUE;

        } else {

            lpStat->fXoffSent = FALSE;

        }

        lpStat->fEof = LocalStat.EofReceived;
        lpStat->fTxim = LocalStat.WaitForImmediate;
        lpStat->cbInQue = LocalStat.AmountInInQueue;
        lpStat->cbOutQue = LocalStat.AmountInOutQueue;

    }

    if (lpErrors) {

        *lpErrors = 0;

        if (LocalStat.Errors & SERIAL_ERROR_BREAK) {

            *lpErrors = *lpErrors | CE_BREAK;

        }

        if (LocalStat.Errors & SERIAL_ERROR_FRAMING) {

            *lpErrors = *lpErrors | CE_FRAME;

        }

        if (LocalStat.Errors & SERIAL_ERROR_OVERRUN) {

            *lpErrors = *lpErrors | CE_OVERRUN;

        }

        if (LocalStat.Errors & SERIAL_ERROR_QUEUEOVERRUN) {

            *lpErrors = *lpErrors | CE_RXOVER;

        }

        if (LocalStat.Errors & SERIAL_ERROR_PARITY) {

            *lpErrors = *lpErrors | CE_RXPARITY;

        }

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    )

/*++

Routine Description:

    The communication device is not initialized until SetupComm is
    called.  This function allocates space for receive and transmit
    queues.  These queues are used by the interrupt-driven transmit/
    receive software and are internal to the provider.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwInQueue - Specifies the recommended size of the provider's
                internal receive queue in bytes.  This value must be
                even.  A value of -1 indicates that the default should
                be used.

    dwOutQueue - Specifies the recommended size of the provider's
                 internal transmit queue in bytes.  This value must be
                 even.  A value of -1 indicates that the default should
                 be used.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_QUEUE_SIZE NewSizes = {0};

    //
    // Make sure that the sizes are even.
    //

    if (dwOutQueue != ((DWORD)-1)) {

        if (((dwOutQueue/2)*2) != dwOutQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    if (dwInQueue != ((DWORD)-1)) {

        if (((dwInQueue/2)*2) != dwInQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    NewSizes.InSize = dwInQueue;
    NewSizes.OutSize = dwOutQueue;


    if (!(SyncEvent = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_SET_QUEUE_SIZE,
                 &NewSizes,
                 sizeof(SERIAL_QUEUE_SIZE),
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function fills the buffer pointed to by the lpDCB parameter with
    the device control block of the communication device specified by hFile
    parameter.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpDCB - Points to the DCB data structure that is to receive the current
            device control block.  The structure defines the control settings
            for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    //
    // Make sure the windows mapping is the same as the NT mapping.
    //

    ASSERT((ONESTOPBIT == STOP_BIT_1) &&
           (ONE5STOPBITS == STOP_BITS_1_5) &&
           (TWOSTOPBITS == STOP_BITS_2));

    ASSERT((NOPARITY == NO_PARITY) &&
           (ODDPARITY == ODD_PARITY) &&
           (EVENPARITY == EVEN_PARITY) &&
           (MARKPARITY == MARK_PARITY) &&
           (SPACEPARITY == SPACE_PARITY));

    //
    // Zero out the dcb.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpDCB, sizeof(DCB));

    lpDCB->DCBlength = sizeof(DCB);
    lpDCB->fBinary = TRUE;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_BAUD_RATE,
                 NULL,
                 0,
                 &LocalBaud,
                 sizeof(LocalBaud)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->BaudRate = LocalBaud.BaudRate;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_LINE_CONTROL,
                 NULL,
                 0,
                 &LineControl,
                 sizeof(LineControl)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->Parity = LineControl.Parity;
    lpDCB->ByteSize = LineControl.WordLength;
    lpDCB->StopBits = LineControl.StopBits;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_CHARS,
                 NULL,
                 0,
                 &Chars,
                 sizeof(Chars)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->XonChar = Chars.XonChar;
    lpDCB->XoffChar = Chars.XoffChar;
    lpDCB->ErrorChar = Chars.ErrorChar;
    lpDCB->EofChar = Chars.EofChar;
    lpDCB->EvtChar = Chars.EventChar;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_HANDFLOW,
                 NULL,
                 0,
                 &HandFlow,
                 sizeof(HandFlow)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {

        lpDCB->fOutxCtsFlow = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {

        lpDCB->fOutxDsrFlow = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) {

        lpDCB->fOutX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) {

        lpDCB->fInX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_NULL_STRIPPING) {

        lpDCB->fNull = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_ERROR_CHAR) {

        lpDCB->fErrorChar = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE) {

        lpDCB->fTXContinueOnXoff = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {

        lpDCB->fAbortOnError = TRUE;

    }

    switch (HandFlow.FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            lpDCB->fRtsControl = RTS_CONTROL_DISABLE;
            break;
        case SERIAL_RTS_CONTROL:
            lpDCB->fRtsControl = RTS_CONTROL_ENABLE;
            break;
        case SERIAL_RTS_HANDSHAKE:
            lpDCB->fRtsControl = RTS_CONTROL_HANDSHAKE;
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            lpDCB->fRtsControl = RTS_CONTROL_TOGGLE;
            break;
    }

    switch (HandFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            lpDCB->fDtrControl = DTR_CONTROL_DISABLE;
            break;
        case SERIAL_DTR_CONTROL:
            lpDCB->fDtrControl = DTR_CONTROL_ENABLE;
            break;
        case SERIAL_DTR_HANDSHAKE:
            lpDCB->fDtrControl = DTR_CONTROL_HANDSHAKE;
            break;
    }

    lpDCB->fDsrSensitivity =
        (HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY)?(TRUE):(FALSE);
    lpDCB->XonLim = (WORD)HandFlow.XonLimit;
    lpDCB->XoffLim = (WORD)HandFlow.XoffLimit;

    CloseHandle(SyncEvent);
    return TRUE;
}

BOOL
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    )

/*++

Routine Description:

    This function directs the communication-device specified by the
    hFile parameter to carry out the extended function specified by
    the dwFunc parameter.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwFunc - Specifies the function code of the extended function.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG ControlCode;
    HANDLE Event;

    switch (dwFunc) {

        case SETXOFF: {
            ControlCode = IOCTL_SERIAL_SET_XOFF;
            break;
        }

        case SETXON: {
            ControlCode = IOCTL_SERIAL_SET_XON;
            break;
        }

        case SETRTS: {
            ControlCode = IOCTL_SERIAL_SET_RTS;
            break;
        }

        case CLRRTS: {
            ControlCode = IOCTL_SERIAL_CLR_RTS;
            break;
        }

        case SETDTR: {
            ControlCode = IOCTL_SERIAL_SET_DTR;
            break;
        }

        case CLRDTR: {
            ControlCode = IOCTL_SERIAL_CLR_DTR;
            break;
        }

        case RESETDEV: {
            ControlCode = IOCTL_SERIAL_RESET_DEVICE;
            break;
        }

        case SETBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_ON;
            break;
        }

        case CLRBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
            break;
        }
        default: {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;


        }
    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 ControlCode,
                 NULL,
                 0,
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(Event);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(Event);
    return TRUE;

}

BOOL
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    The SetCommState function sets a communication device to the state
    specified in the lpDCB parameter.  The device is identified by the
    hFile parameter.  This function reinitializes all hardwae and controls
    as specified byt the lpDCB, but does not empty the transmit or
    receive queues.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpDCB - Points to a DCB structure that contains the desired
            communications setting for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow = {0};
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Keep a copy of what the DCB was like before we started
    // changing things.  If some error occurs we can use
    // it to restore the old setup.
    //
    DCB OldDcb;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.  While it would be very
    // strange to be setting the comm state while IO is active
    // we need to make sure we don't compound the problem by
    // returning before this API's IO is actually finished.  This
    // can happen because the file handle is set on the completion
    // of any IO.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    if (GetCommState(
            hFile,
            &OldDcb
            )) {

        //
        // Try to set the baud rate.  If we fail here, we just return
        // because we never actually got to set anything.
        //

        if (!(SyncEvent = CreateEvent(
                              NULL,
                              TRUE,
                              FALSE,
                              NULL
                              ))) {

            return FALSE;

        }

        LocalBaud.BaudRate = lpDCB->BaudRate;
        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_BAUD_RATE,
                     &LocalBaud,
                     sizeof(LocalBaud),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        LineControl.StopBits = lpDCB->StopBits;
        LineControl.Parity = lpDCB->Parity;
        LineControl.WordLength = lpDCB->ByteSize;
        LocalBaud.BaudRate = lpDCB->BaudRate;
        Chars.XonChar   = lpDCB->XonChar;
        Chars.XoffChar  = lpDCB->XoffChar;
        Chars.ErrorChar = lpDCB->ErrorChar;
        Chars.BreakChar = lpDCB->ErrorChar;
        Chars.EofChar   = lpDCB->EofChar;
        Chars.EventChar = lpDCB->EvtChar;

        HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
        switch (lpDCB->fRtsControl) {
            case RTS_CONTROL_DISABLE:
                break;
            case RTS_CONTROL_ENABLE:
                HandFlow.FlowReplace |= SERIAL_RTS_CONTROL;
                break;
            case RTS_CONTROL_HANDSHAKE:
                HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;
                break;
            case RTS_CONTROL_TOGGLE:
                HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        HandFlow.ControlHandShake &= ~SERIAL_DTR_MASK;
        switch (lpDCB->fDtrControl) {
            case DTR_CONTROL_DISABLE:
                break;
            case DTR_CONTROL_ENABLE:
                HandFlow.ControlHandShake |= SERIAL_DTR_CONTROL;
                break;
            case DTR_CONTROL_HANDSHAKE:
                HandFlow.ControlHandShake |= SERIAL_DTR_HANDSHAKE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        if (lpDCB->fDsrSensitivity) {

            HandFlow.ControlHandShake |= SERIAL_DSR_SENSITIVITY;

        }

        if (lpDCB->fOutxCtsFlow) {

            HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;

        }

        if (lpDCB->fOutxDsrFlow) {

            HandFlow.ControlHandShake |= SERIAL_DSR_HANDSHAKE;

        }

        if (lpDCB->fOutX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_TRANSMIT;

        }

        if (lpDCB->fInX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_RECEIVE;

        }

        if (lpDCB->fNull) {

            HandFlow.FlowReplace |= SERIAL_NULL_STRIPPING;

        }

        if (lpDCB->fErrorChar) {

            HandFlow.FlowReplace |= SERIAL_ERROR_CHAR;
        }

        if (lpDCB->fTXContinueOnXoff) {

            HandFlow.FlowReplace |= SERIAL_XOFF_CONTINUE;

        }

        if (lpDCB->fAbortOnError) {

            HandFlow.ControlHandShake |= SERIAL_ERROR_ABORT;

        }

        //
        // For win95 compatiblity, if we are setting with
        // xxx_control_XXXXXXX then set the modem status line
        // to that state.
        //

        if (lpDCB->fRtsControl == RTS_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETRTS
                );

        } else if (lpDCB->fRtsControl == RTS_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRRTS
                );

        }
        if (lpDCB->fDtrControl == DTR_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETDTR
                );

        } else if (lpDCB->fDtrControl == DTR_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRDTR
                );

        }




        HandFlow.XonLimit = lpDCB->XonLim;
        HandFlow.XoffLimit = lpDCB->XoffLim;


        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_LINE_CONTROL,
                     &LineControl,
                     sizeof(LineControl),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_CHARS,
                     &Chars,
                     sizeof(Chars),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_HANDFLOW,
                     &HandFlow,
                     sizeof(HandFlow),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }
        CloseHandle(SyncEvent);
        return TRUE;

    }

    return FALSE;

}

BOOL
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function establishes the timeout characteristics for all
    read and write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure containing timeout parameters.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    To.ReadIntervalTimeout = lpCommTimeouts->ReadIntervalTimeout;
    To.ReadTotalTimeoutMultiplier = lpCommTimeouts->ReadTotalTimeoutMultiplier;
    To.ReadTotalTimeoutConstant = lpCommTimeouts->ReadTotalTimeoutConstant;
    To.WriteTotalTimeoutMultiplier = lpCommTimeouts->WriteTotalTimeoutMultiplier;
    To.WriteTotalTimeoutConstant = lpCommTimeouts->WriteTotalTimeoutConstant;


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_TIMEOUTS,
                     &To,
                     sizeof(To),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
APIENTRY
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
{
    NTSTATUS Status;

    Status = RtlCreateSecurityDescriptor (
                pSecurityDescriptor,
                dwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl OPTIONAL,
    BOOL bDaclDefaulted OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlSetDaclSecurityDescriptor (
        pSecurityDescriptor,
        (BOOLEAN)bDaclPresent,
        pDacl,
        (BOOLEAN)bDaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    )
/*++

Routine Description:

    InitializeAcl creates a new ACL in the caller supplied memory
    buffer.  The ACL contains zero ACEs; therefore, it is an empty ACL
    as opposed to a nonexistent ACL.  That is, if the ACL is now set
    to an object it will implicitly deny access to everyone.

Arguments:

    pAcl - Supplies the buffer containing the ACL being initialized

    nAclLength - Supplies the length of the ace buffer in bytes

    dwAclRevision - Supplies the revision for this Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCreateAcl (
                pAcl,
                nAclLength,
                dwAclRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID being denied access.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

PVOID
APIENTRY
FreeSid(
    PSID pSid
    )

/*++

Routine Description:

    This function is used to free a SID previously allocated using
    AllocateAndInitializeSid().


Arguments:

    Sid - Pointer to the SID to free.

Return Value:

    None.


--*/
{
    return(RtlFreeSid( pSid ));
}

DWORD
APIENTRY
GetLengthSid (
    PSID pSid
    )
/*++

Routine Description:

    This routine returns the length, in bytes, of a structurally valid SID.

Arguments:

    pSid - Points to the SID whose length is to be returned.  The
        SID's structure is assumed to be valid.

Return Value:

    DWORD - The length, in bytes, of the SID.

--*/
{
    SetLastError(0);
    return RtlLengthSid (
                pSid
                );
}

BOOL
APIENTRY
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    )

/*++

Routine Description:

    This function allocates and initializes a sid with the specified
    number of sub-authorities (up to 8).  A sid allocated with this
    routine must be freed using FreeSid().


Arguments:

    pIdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    nSubAuthorityCount - The number of sub-authorities to place in the SID.
        This also identifies how many of the SubAuthorityN parameters
        have meaningful values.  This must contain a value from 0 through
        8.

    nSubAuthority0-7 - Provides the corresponding sub-authority value to
        place in the SID.  For example, a SubAuthorityCount value of 3
        indicates that SubAuthority0, SubAuthority1, and SubAuthority0
        have meaningful values and the rest are to be ignored.

    Sid - Receives a pointer to the allocated and initialized SID data
        structure.

Return Value:


    ERROR_NO_MEMORY - The attempt to allocate memory for the SID
        failed.

    ERROR_INVALID_SID - The number of sub-authorities specified did
        not fall in the valid range for this api (0 through 8).

--*/
{
    NTSTATUS Status;

    Status = RtlAllocateAndInitializeSid (
                 pIdentifierAuthority,
                 (UCHAR)nSubAuthorityCount,
                 (ULONG)nSubAuthority0,
                 (ULONG)nSubAuthority1,
                 (ULONG)nSubAuthority2,
                 (ULONG)nSubAuthority3,
                 (ULONG)nSubAuthority4,
                 (ULONG)nSubAuthority5,
                 (ULONG)nSubAuthority6,
                 (ULONG)nSubAuthority7,
                 pSid
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}

ULONG
APIENTRY
GetTickCount(void)
{
    return NtGetTickCount();
}

LPSTR
WINAPI
GetCommandLineA(
    VOID
    )
{
    // Purely to allow linkage, not expected to be used.
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}

LPWSTR
WINAPI
GetCommandLineW(
    VOID
    )
{
    return NtCurrentPeb()->ProcessParameters->CommandLine.Buffer;
}

#endif // #ifdef NT_NATIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\pparse.cpp ===
//----------------------------------------------------------------------------
//
// Simple parameter string parsing.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include "cmnutil.hpp"
#include "pparse.hpp"

//----------------------------------------------------------------------------
//
// ParameterStringParser.
//
//----------------------------------------------------------------------------

ParameterStringParser::ParameterStringParser(void)
{
    m_Name = NULL;
}

BOOL
ParameterStringParser::ParseParameters(PCSTR ParamString)
{
    if (ParamString == NULL)
    {
        // Nothing to parse.
        return TRUE;
    }

    PCSTR Scan = ParamString;

    // Skip <name>: if present.
    while (*Scan && *Scan != ':')
    {
        Scan++;
    }
    if (*Scan == ':')
    {
        Scan++;
    }
    else
    {
        Scan = ParamString;
    }

    //
    // Scan options string for comma-delimited parameters
    // and pass them into the parameter handling method.
    //

    char Param[MAX_PARAM_NAME];
    char Value[MAX_PARAM_VALUE];
    PSTR ValStr;
    PSTR Str;

    for (;;)
    {
        while (*Scan && isspace(*Scan))
        {
            Scan++;
        }
        if (!*Scan)
        {
            break;
        }

        Str = Param;
        while (*Scan && *Scan != ',' && *Scan != '=' &&
               (Str - Param) < MAX_PARAM_NAME)
        {
            *Str++ = *Scan++;
        }
        if (Str >= Param + MAX_PARAM_NAME)
        {
            return FALSE;
        }

        // Terminate option name and default value to nothing.
        *Str++ = 0;
        ValStr = NULL;

        if (*Scan == '=')
        {
            // Parameter has a value, scan it.
            Scan++;
            while (*Scan && isspace(*Scan))
            {
                Scan++;
            }

            Str = Value;
            while (*Scan && *Scan != ',' &&
                   (Str - Value) < MAX_PARAM_VALUE)
            {
                *Str++ = *Scan++;
            }
            if (Str >= Value + MAX_PARAM_VALUE)
            {
                return FALSE;
            }

            *Str++ = 0;
            ValStr = Value;
        }

        if (*Scan)
        {
            // Skip comma for next iteration.
            Scan++;
        }

        // Set the value in the parser.
        if (!SetParameter(Param, ValStr))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ParameterStringParser::GetParameters(PSTR Buffer, ULONG BufferSize)
{
    ULONG Len;
    BOOL Ret = FALSE;

    // Reserve space for the terminator.
    if (BufferSize < 1)
    {
        return FALSE;
    }
    BufferSize--;

    if (m_Name != NULL)
    {
        Len = strlen(m_Name);
        if (BufferSize < Len + 1)
        {
            goto EH_Exit;
        }

        memcpy(Buffer, m_Name, Len);
        Buffer += Len;
        *Buffer++ = ':';
        BufferSize -= Len + 1;
    }

    ULONG Params;
    ULONG i;
    char Name[MAX_PARAM_NAME];
    char Value[MAX_PARAM_VALUE];
    BOOL NeedComma;

    Params = GetNumberParameters();
    NeedComma = FALSE;
    for (i = 0; i < Params; i++)
    {
        Name[0] = 0;
        Value[0] = 0;
        GetParameter(i, Name, DIMA(Name), Value, DIMA(Value));

        Len = strlen(Name);
        if (Len == 0)
        {
            continue;
        }

        if (BufferSize < Len)
        {
            goto EH_Exit;
        }

        if (NeedComma)
        {
            if (BufferSize < 1)
            {
                goto EH_Exit;
            }

            *Buffer++ = ',';
            BufferSize--;
        }

        memcpy(Buffer, Name, Len);
        Buffer += Len;
        BufferSize -= Len;
        NeedComma = TRUE;

        Len = strlen(Value);
        if (Len == 0)
        {
            continue;
        }

        if (BufferSize < Len + 1)
        {
            goto EH_Exit;
        }

        *Buffer++ = '=';
        memcpy(Buffer, Value, Len);
        Buffer += Len;
        BufferSize -= Len + 1;
    }

    Ret = TRUE;

 EH_Exit:
    *Buffer++ = 0;
    return Ret;
}

ULONG
ParameterStringParser::GetParser(PCSTR ParamString,
                                 ULONG NumNames, PCSTR* Names)
{
    if (ParamString == NULL)
    {
        return PARSER_INVALID;
    }

    //
    // Parse out <name>: and look up the name.
    //

    PCSTR Scan = ParamString;
    while (*Scan && *Scan != ':')
    {
        Scan++;
    }

    ULONG Len = (ULONG)(Scan - ParamString);
    if (*Scan != ':' || Len < 1)
    {
        return PARSER_INVALID;
    }

    ULONG i;
    for (i = 0; i < NumNames; i++)
    {
        if (strlen(Names[i]) == Len &&
            !_memicmp(Names[i], ParamString, Len))
        {
            return i;
        }
    }

    return PARSER_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\ntnative.h ===
//----------------------------------------------------------------------------
//
// NT native/Win32 mapping layer.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __NTNATIVE_H__
#define __NTNATIVE_H__

#define InitializeCriticalSection(Crit) RtlInitializeCriticalSection(Crit)
#define DeleteCriticalSection(Crit)     RtlDeleteCriticalSection(Crit)
#define EnterCriticalSection(Crit)      RtlEnterCriticalSection(Crit)
#define LeaveCriticalSection(Crit)      RtlLeaveCriticalSection(Crit)

#define malloc(Bytes) RtlAllocateHeap(RtlProcessHeap(), 0, Bytes)
#define free(Ptr)     RtlFreeHeap(RtlProcessHeap(), 0, Ptr)

HANDLE
WINAPI
NtNativeCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    );

HANDLE
APIENTRY
NtNativeCreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    );

#endif // #ifndef __NTNATIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\uminiprov.hpp ===
//----------------------------------------------------------------------------
//
// User-mode minidump OS call provider interfaces.
//
// Copyright (C) Microsoft Corporation, 2002.
//
//----------------------------------------------------------------------------

#ifndef __UMINIPROV_HPP__
#define __UMINIPROV_HPP__

class MiniDumpProviderCallbacks
{
public:
    virtual HRESULT EnumMemory(ULONG64 Offset, ULONG Size) = 0;
};

class MiniDumpSystemProvider
{
public:
    virtual void Release(void) = 0;

    virtual HRESULT GetCurrentTimeDate(OUT PULONG TimeDate) = 0;
    
    virtual HRESULT GetCpuType(OUT PULONG Type,
                               OUT PBOOL BackingStore) = 0;
    virtual HRESULT GetCpuInfo(OUT PUSHORT Architecture,
                               OUT PUSHORT Level,
                               OUT PUSHORT Revision,
                               OUT PUCHAR NumberOfProcessors,
                               OUT union _CPU_INFORMATION* Info) = 0;

    virtual void GetContextSizes(OUT PULONG Size,
                                 OUT PULONG RegScanStart,
                                 OUT PULONG RegScanCount) = 0;
    virtual void GetPointerSize(OUT PULONG Size) = 0;
    virtual void GetPageSize(OUT PULONG Size) = 0;
    virtual void GetFunctionTableSizes(OUT PULONG TableSize,
                                       OUT PULONG EntrySize) = 0;
    virtual void GetInstructionWindowSize(OUT PULONG Size) = 0;

    virtual HRESULT GetOsInfo(OUT PULONG PlatformId,
                              OUT PULONG Major,
                              OUT PULONG Minor,
                              OUT PULONG BuildNumber,
                              OUT PUSHORT ProductType,
                              OUT PUSHORT SuiteMask) = 0;

    virtual HRESULT GetOsCsdString(OUT PWSTR Buffer,
                                   IN ULONG BufferChars) = 0;

    virtual HRESULT OpenMapping(IN PCWSTR FilePath,
                                OUT PULONG Size,
                                OUT PWSTR LongPath,
                                IN ULONG LongPathChars,
                                OUT PVOID* Mapping) = 0;
    virtual void    CloseMapping(PVOID Mapping) = 0;

    virtual HRESULT GetImageHeaderInfo(IN HANDLE Process,
                                       IN PCWSTR FilePath,
                                       IN ULONG64 ImageBase,
                                       OUT PULONG Size,
                                       OUT PULONG CheckSum,
                                       OUT PULONG TimeDateStamp) = 0;
    virtual HRESULT GetImageVersionInfo(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        OUT VS_FIXEDFILEINFO* Info) = 0;
    virtual HRESULT GetImageDebugRecord(IN HANDLE Process,
                                        IN PCWSTR FilePath,
                                        IN ULONG64 ImageBase,
                                        IN ULONG RecordType,
                                        OUT OPTIONAL PVOID Data,
                                        IN OUT PULONG DataLen) = 0;
    virtual HRESULT EnumImageDataSections(IN HANDLE Process,
                                          IN PCWSTR FilePath,
                                          IN ULONG64 ImageBase,
                                          IN MiniDumpProviderCallbacks*
                                          Callback) = 0;

    virtual HRESULT OpenThread(IN ULONG DesiredAccess,
                               IN BOOL InheritHandle,
                               IN ULONG ThreadId,
                               OUT PHANDLE Handle) = 0;
    virtual void    CloseThread(IN HANDLE Handle) = 0;
    virtual ULONG   GetCurrentThreadId(void) = 0;
    virtual ULONG   SuspendThread(IN HANDLE Thread) = 0;
    virtual ULONG   ResumeThread(IN HANDLE Thread) = 0;
    virtual HRESULT GetThreadContext(IN HANDLE Thread,
                                     OUT PVOID Context,
                                     IN ULONG ContextSize,
                                     OUT PULONG64 CurrentPc,
                                     OUT PULONG64 CurrentStack,
                                     OUT PULONG64 CurrentStore) = 0;
    virtual HRESULT GetTeb(IN HANDLE Thread,
                           OUT PULONG64 Offset,
                           OUT PULONG Size) = 0;
    virtual HRESULT GetThreadInfo(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  OUT PULONG64 Teb,
                                  OUT PULONG SizeOfTeb,
                                  OUT PULONG64 StackBase,
                                  OUT PULONG64 StackLimit,
                                  OUT PULONG64 StoreBase,
                                  OUT PULONG64 StoreLimit) = 0;

    virtual HRESULT GetPeb(IN HANDLE Process,
                           OUT PULONG64 Offset,
                           OUT PULONG Size) = 0;
    virtual HRESULT GetProcessTimes(IN HANDLE Process,
                                    OUT LPFILETIME Create,
                                    OUT LPFILETIME User,
                                    OUT LPFILETIME Kernel) = 0;
    // Returns success if any data is read.
    virtual HRESULT ReadVirtual(IN HANDLE Process,
                                IN ULONG64 Offset,
                                OUT PVOID Buffer,
                                IN ULONG Request,
                                OUT PULONG Done) = 0;
    virtual HRESULT ReadAllVirtual(IN HANDLE Process,
                                   IN ULONG64 Offset,
                                   OUT PVOID Buffer,
                                   IN ULONG Request) = 0;
    virtual HRESULT QueryVirtual(IN HANDLE Process,
                                 IN ULONG64 Offset,
                                 OUT PULONG64 Base,
                                 OUT PULONG64 Size,
                                 OUT PULONG Protect,
                                 OUT PULONG State,
                                 OUT PULONG Type) = 0;

    virtual HRESULT StartProcessEnum(IN HANDLE Process,
                                     IN ULONG ProcessId) = 0;
    virtual HRESULT EnumThreads(OUT PULONG ThreadId) = 0;
    virtual HRESULT EnumModules(OUT PULONG64 Base,
                                OUT PWSTR Path,
                                IN ULONG PathChars) = 0;
    virtual HRESULT EnumFunctionTables(OUT PULONG64 MinAddress,
                                       OUT PULONG64 MaxAddress,
                                       OUT PULONG64 BaseAddress,
                                       OUT PULONG EntryCount,
                                       OUT PVOID RawTable,
                                       IN ULONG RawTableSize,
                                       OUT PVOID* RawEntryHandle) = 0;
    virtual HRESULT EnumFunctionTableEntries(IN PVOID RawTable,
                                             IN ULONG RawTableSize,
                                             IN PVOID RawEntryHandle,
                                             OUT PVOID RawEntries,
                                             IN ULONG RawEntriesSize) = 0;
    virtual HRESULT EnumFunctionTableEntryMemory(IN ULONG64 TableBase,
                                                 IN PVOID RawEntries,
                                                 IN ULONG Index,
                                                 OUT PULONG64 Start,
                                                 OUT PULONG Size) = 0;
    virtual HRESULT EnumUnloadedModules(OUT PWSTR Path,
                                        IN ULONG PathChars,
                                        OUT PULONG64 BaseOfModule,
                                        OUT PULONG SizeOfModule,
                                        OUT PULONG CheckSum,
                                        OUT PULONG TimeDateStamp) = 0;
    virtual void    FinishProcessEnum(void) = 0;

    virtual HRESULT StartHandleEnum(IN HANDLE Process,
                                    IN ULONG ProcessId,
                                    OUT PULONG Count) = 0;
    virtual HRESULT EnumHandles(OUT PULONG64 Handle,
                                OUT PULONG Attributes,
                                OUT PULONG GrantedAccess,
                                OUT PULONG HandleCount,
                                OUT PULONG PointerCount,
                                OUT PWSTR TypeName,
                                IN ULONG TypeNameChars,
                                OUT PWSTR ObjectName,
                                IN ULONG ObjectNameChars) = 0;
    virtual void    FinishHandleEnum(void) = 0;

    virtual HRESULT EnumPebMemory(IN HANDLE Process,
                                  IN ULONG64 PebOffset,
                                  IN ULONG PebSize,
                                  IN MiniDumpProviderCallbacks* Callback) = 0;
    virtual HRESULT EnumTebMemory(IN HANDLE Process,
                                  IN HANDLE Thread,
                                  IN ULONG64 TebOffset,
                                  IN ULONG TebSize,
                                  IN MiniDumpProviderCallbacks* Callback) = 0;

    virtual HRESULT GetCorDataAccess(IN PWSTR AccessDllName,
                                     IN struct ICorDataAccessServices*
                                     Services,
                                     OUT struct ICorDataAccess**
                                     Access) = 0;
    virtual void    ReleaseCorDataAccess(IN struct ICorDataAccess*
                                         Access) = 0;
};

class MiniDumpOutputProvider
{
public:
    virtual void Release(void) = 0;

    // S_OK return indicates this provider can stream an
    // arbitrary amount of data.  Any other return indicates this
    // provider requires a size bound.
    virtual HRESULT SupportsStreaming(void) = 0;
    
    // MaxSize of zero indicates no size information available.
    virtual HRESULT Start(IN ULONG64 MaxSize) = 0;

    // Uses Win32 FILE_ defines for How.
    virtual HRESULT Seek(IN ULONG How,
                         IN LONG64 Amount,
                         OUT OPTIONAL PULONG64 NewOffset) = 0;
    
    // WriteAll must write the entire request to succeed.
    virtual HRESULT WriteAll(IN PVOID Buffer,
                             IN ULONG Request) = 0;
    
    virtual void Finish(void) = 0;
};

class MiniDumpAllocationProvider
{
public:
    virtual void Release(void) = 0;

    // Allocated memory is always zero-filled.
    virtual PVOID Alloc(ULONG Size) = 0;
    virtual PVOID Realloc(PVOID Mem, ULONG NewSize) = 0;
    virtual void  Free(PVOID Mem) = 0;
};

extern "C"
{
    
HRESULT WINAPI
MiniDumpCreateLiveSystemProvider(OUT MiniDumpSystemProvider** Prov);

HRESULT WINAPI
MiniDumpCreateFileOutputProvider(IN HANDLE FileHandle,
                                 OUT MiniDumpOutputProvider** Prov);

HRESULT WINAPI
MiniDumpCreateLiveAllocationProvider(OUT MiniDumpAllocationProvider** Prov);

HRESULT
WINAPI
MiniDumpProvideDump(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN MiniDumpSystemProvider* SysProv,
    IN MiniDumpOutputProvider* OutProv,
    IN MiniDumpAllocationProvider* AllocProv,
    IN ULONG DumpType,
    IN CONST struct _MINIDUMP_EXCEPTION_INFORMATION64* ExceptionParam, OPTIONAL
    IN CONST struct _MINIDUMP_USER_STREAM_INFORMATION* UserStreamParam, OPTIONAL
    IN CONST struct _MINIDUMP_CALLBACK_INFORMATION* CallbackParam OPTIONAL
    );

};

#endif // #ifndef __UMINIPROV_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\symsrv.h ===
/*
 * symsrv.h
 */

#ifndef SYMSTORE_DOT_H

#define SYMSTORE_DOT_H

#ifdef __cplusplus
 extern "C" {
#endif

BOOL
WINAPI
SymbolServer(
    IN  PCSTR params,   // server and cache path
    IN  PCSTR filename, // name of file to search for
    IN  PVOID id,       // first number in directory name
    IN  DWORD val2,     // second number in directory name
    IN  DWORD val3,     // third number in directory name
    OUT PSTR  path      // return validated file path here
    );

BOOL WINAPI SymbolServerClose();

BOOL
WINAPI
SymbolServerSetOptions(
    UINT_PTR options,
    ULONG64  data
    );

UINT_PTR WINAPI SymbolServerGetOptions();

void
WINAPI
AppendHexStringWithDWORD(
    PSTR sz,
    DWORD value
);


void
WINAPI
AppendHexStringWithGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    );


void
WINAPI
AppendHexStringWithOldGUID(
    IN OUT PSTR sz,
    IN GUID *guid
    );

void
WINAPI
EnsureTrailingBackslash(
    char *sz
);

BOOL
WINAPI
httpOpenFileHandle(
    IN  LPCSTR srv,
    IN  LPCSTR path,
    IN  DWORD  options,
    OUT HANDLE *hsite,
    OUT HANDLE *hfile
    );

BOOL
WINAPI
httpQueryDataAvailable(
    IN HANDLE hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

BOOL
WINAPI
httpReadFile(
    IN HANDLE hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT DWORD_PTR lpdwNumberOfBytesRead
    );

BOOL
WINAPI
httpCloseHandle(
    IN HANDLE hInternet
    );


typedef BOOL (WINAPI *HTTPOPENFILEHANDLE)(LPCSTR, LPCSTR, DWORD, HANDLE *, HANDLE *);
typedef BOOL (WINAPI *HTTPQUERYDATAAVAILABLE)(HANDLE, LPDWORD, DWORD, DWORD_PTR);
typedef BOOL (WINAPI *HTTPREADFILE)(HANDLE, LPVOID, DWORD, LPDWORD);
typedef BOOL (WINAPI *HTTPCLOSEHANDLE)(HANDLE);


#ifdef __cplusplus
 }
#endif

#endif // #ifdef SYMSTORE_DOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\pparse.hpp ===
//----------------------------------------------------------------------------
//
// Simple parameter string parsing.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __PPARSE_HPP__
#define __PPARSE_HPP__

//----------------------------------------------------------------------------
//
// ParameterStringParser.
//
//----------------------------------------------------------------------------

#define MAX_PARAM_NAME 32
#define MAX_PARAM_VALUE 256

#define PARSER_INVALID 0xffffffff

class ParameterStringParser
{
public:
    PCSTR m_Name;

    ParameterStringParser(void);
    
    virtual ULONG GetNumberParameters(void) = 0;
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize) = 0;
    
    virtual void ResetParameters(void) = 0;
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value) = 0;

    BOOL ParseParameters(PCSTR ParamString);
    BOOL GetParameters(PSTR Buffer, ULONG BufferSize);
    
    // Scan the names array for the <name> part of
    // a <name>:<parameters> string.
    static ULONG GetParser(PCSTR ParamString, ULONG NumNames, PCSTR* Names);
};    

#endif // #ifndef __PPARSE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\srcsrv.h ===
/*
 * srcsrv.h
 */

#define SRCSRVOPT_DEBUG  0x1

BOOL
WINAPI
SrcSrvInit(
    HANDLE hProcess,
    LPCSTR path
    );

typedef BOOL (WINAPI *PSRCSRVINITPROC)(HANDLE, LPCSTR);

BOOL
WINAPI
SrcSrvCleanup(
    HANDLE hProcess
    );

typedef BOOL (WINAPI *PSRCSRVCLEANUPPROC)(HANDLE);

BOOL
WINAPI
SrcSrvSetTargetPath(
    HANDLE hProcess,
    LPCSTR path
    );

typedef BOOL (WINAPI *PSRCSRVSETTARGETPATHPROC)(HANDLE, LPCSTR);

DWORD
WINAPI
SrcSrvSetOptions(
    DWORD opts
    );

typedef DWORD (WINAPI *PSRCSRVSETOPTIONSPROC)(DWORD);

DWORD
WINAPI
SrcSrvGetOptions(
    );

typedef DWORD (WINAPI *PSRCSRVGETOPTIONSPROC)();

BOOL
WINAPI
SrcSrvLoadModule(
    HANDLE  hProcess,
    LPCSTR  name,
    DWORD64 base,
    PVOID   stream,
    DWORD   size
    );

typedef BOOL (WINAPI *PSRCSRVLOADMODULEPROC)(HANDLE, LPCSTR, DWORD64, PVOID, DWORD);

BOOL
WINAPI
SrcSrvUnloadModule(
    HANDLE  hProcess,
    DWORD64 base
    );

typedef BOOL (WINAPI *PSRCSRVUNLOADMODULEPROC)(HANDLE, DWORD64);

typedef BOOL (CALLBACK WINAPI *PSRCSRVCALLBACKPROC)(UINT_PTR action, DWORD64 data, DWORD64 context);

#define SRCSRVACTION_TRACE 0x1

BOOL
WINAPI
SrcSrvRegisterCallback(
    HANDLE              hProcess,
    PSRCSRVCALLBACKPROC callback,
    DWORD64             context
    );

typedef BOOL (WINAPI *PSRCSRVREGISTERCALLBACKPROC)(HANDLE, PSRCSRVCALLBACKPROC, DWORD64);

BOOL
WINAPI
SrcSrvGetFile(
    HANDLE  hProcess,
    DWORD64 base,
    LPCSTR  filename,
    LPSTR   target,
    DWORD   trgsize
    );

typedef BOOL (WINAPI *PSRCSRVGETFILEPROC)(HANDLE, DWORD64, LPCSTR, LPSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbg-common\wcecompat.h ===
//----------------------------------------------------------------------------
//
// Windows CE/Win32 compatibility definitions.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __WCECOMPAT_H__
#define __WCECOMPAT_H__

#ifdef _WIN32_WCE

#ifndef DBG_COMMAND_EXCEPTION
#define DBG_COMMAND_EXCEPTION ((LONG)0x40010009L)
#endif

#ifndef STDMETHODV
#define STDMETHODV(Method) STDMETHOD(Method)
#endif

#ifndef INLINE
#define INLINE __inline
#endif

#ifndef FORCEINLINE
#define FORCEINLINE INLINE
#endif

#ifndef TH32CS_SNAPMODULE32
#define TH32CS_SNAPMODULE32 0
#endif

#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER 0xffffffff
#endif

#define CREATE_UNICODE_ENVIRONMENT        0x00000400
#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

typedef LONG NTSTATUS;

#define NT_SUCCESS(Status) ((Status) >= 0)

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, ANSI_STRING, *PSTRING, *PANSI_STRING;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef const UNICODE_STRING* PCUNICODE_STRING;
typedef const ANSI_STRING* PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

#define WSA_FLAG_OVERLAPPED 0
#define WSA_IO_PENDING 0

typedef OVERLAPPED WSAOVERLAPPED;
typedef WSAOVERLAPPED *LPWSAOVERLAPPED;

#define OpenThread(dwDesiredAccess, bInheritHandle, dwThreadId) \
    ((HANDLE)(dwThreadId))
#define IsProcessorFeaturePresent(ProcessorFeature) FALSE
#define VirtualQueryEx(hProcess, lpAddress, lpBuffer, dwLength) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), 0)
#define CancelIo(Handle) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)
#define GetOverlappedResult(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)

#define WSASocket(af, type, protocol, lpProtocolInfo, g, dwFlags) \
    socket(af, type, protocol)
#define WSAGetOverlappedResult(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait, Flags) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)

INLINE
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}

#define UlongToHandle(ul) ULongToHandle(ul)

#else

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE 3
#endif

#endif // #ifdef _WIN32_WCE

#endif // #ifndef __WCECOMPAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <wcecompat.h>
#include <objbase.h>
#ifndef _WIN32_WCE
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#endif

#define NTDLL_APIS
#include <dllimp.h>
#include <cmnutil.hpp>

#include <dbgrpc.hpp>
#include <portio.h>

#ifdef NT_NATIVE
#include <ntnative.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\dbgrpc.cpp ===
//----------------------------------------------------------------------------
//
// Remoting support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <lmcons.h>

#define DBGRPC_SIGNATURE 'CPRD'
#define DBGRPC_PROTOCOL_VERSION 2

enum
{
    SEQ_HANDSHAKE = 0xffff0000,
    SEQ_IDENTITY,
    SEQ_PASSWORD,
    SEQ_CALL_HEADER,
};

#define DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN 0x00000001

struct DbgRpcHandshake
{
    ULONG Signature;
    ULONG ProtocolVersion;
    GUID DesiredObject;
    DbgRpcObjectId RemoteObject;
    ULONG IdentityLength;
    ULONG PasswordLength;
    ULONG Flags;
    ULONG Reserved1;
    ULONG64 Reserved2[10];
};

ULONG g_DbgRpcCallSequence;

CRITICAL_SECTION g_DbgRpcLock;

#define CreateUserThread(Start, Param, Tid) \
    CreateThread(NULL, 0, Start, Param, 0, Tid)
#ifdef NT_NATIVE
#define ExitUserThread(Code) RtlExitUserThread(Code)
#else
#define ExitUserThread(Code) return Code
#endif

//----------------------------------------------------------------------------
//
// Basic initialization.
//
//----------------------------------------------------------------------------

BOOL
DbgRpcOneTimeInitialization(void)
{
#if NO_DEBUGGER_RPC_BUILD

    return FALSE;

#else

    static BOOL s_Initialized = FALSE;

    if (s_Initialized)
    {
        return TRUE;
    }

#ifndef NT_NATIVE
    WSADATA WsData;

    if (WSAStartup(MAKEWORD(2, 0), &WsData) != 0)
    {
        return FALSE;
    }
#endif

    if (InitializeAllAccessSecObj() != S_OK)
    {
        return FALSE;
    }

    __try
    {
        InitializeCriticalSection(&g_DbgRpcLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
    
    DbgRpcInitializeClient();

    s_Initialized = TRUE;
    return TRUE;

#endif // #if NO_DEBUGGER_RPC_BUILD
}

//----------------------------------------------------------------------------
//
// DbgRpcReceiveCalls.
//
//----------------------------------------------------------------------------

HRESULT
DbgRpcReceiveCalls(DbgRpcConnection* Conn, DbgRpcCall* Call, PUCHAR* InOutData)
{
    HRESULT Status;
    ULONG RetSeq = Call->Sequence;

    DBG_ASSERT((Call->Flags & DBGRPC_RETURN) == 0 &&
               *InOutData == NULL);

    // If this thread isn't the owner of the connection we
    // cannot read the socket as that could create a
    // race condition with the owner thread reading
    // the socket.
    // If this is a locked call, where a higher-level lock
    // prevents socket contention, we can allow it.
    if ((Call->Flags & DBGRPC_LOCKED) == 0 &&
        Conn->m_ThreadId != GetCurrentThreadId())
    {
        return RPC_E_WRONG_THREAD;
    }

    for (;;)
    {
        DbgRpcCall ReadCall;

        if (Conn->m_Trans->Read(SEQ_CALL_HEADER, &ReadCall,
                                sizeof(ReadCall)) != sizeof(ReadCall))
        {
            DRPC_ERR(("%X: Unable to receive call header\n",
                      GetCurrentThreadId()));
            return RPC_E_CLIENT_DIED;
        }

        ULONG Size;
        PUCHAR Data;

        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            Size = ReadCall.OutSize;
        }
        else
        {
            Size = ReadCall.InSize;
            ReadCall.Status = S_OK;
        }

        if (Size > 0)
        {
            Data = (PUCHAR)Conn->Alloc(Size);
            if (Data == NULL)
            {
                DRPC_ERR(("%X: Unable to allocate call body\n",
                          GetCurrentThreadId()));
                return E_OUTOFMEMORY;
            }

            if (Conn->m_Trans->Read(ReadCall.Sequence, Data, Size) != Size)
            {
                DRPC_ERR(("%X: Unable to receive call body\n",
                          GetCurrentThreadId()));
                Conn->Free(Data);
                return RPC_E_CLIENT_DIED;
            }
        }
        else
        {
            Data = NULL;
        }

#ifdef DBG_RPC
        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            DRPC(("%X: %X: Return %s (%X), ret 0x%X, out %d\n",
                  GetCurrentThreadId(), ReadCall.Sequence,
                  DbgRpcGetStubName(ReadCall.StubIndex),
                  ReadCall.StubIndex, ReadCall.Status, ReadCall.OutSize));
        }
        else
        {
            DRPC(("%X: %X: Request %s (%X), fl %X, in %d\n",
                  GetCurrentThreadId(), ReadCall.Sequence,
                  DbgRpcGetStubName(ReadCall.StubIndex),
                  ReadCall.StubIndex, ReadCall.Flags, ReadCall.InSize));
        }
#endif

        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            if (ReadCall.Sequence != RetSeq)
            {
#if DBG
                DRPC_ERR(("%X: %X: Non-seq ret 0x%X for %s (%X)\n",
                          GetCurrentThreadId(), ReadCall.Sequence,
                          ReadCall.Status,
                          DbgRpcGetStubName(ReadCall.StubIndex),
                          ReadCall.StubIndex));
#else
                DRPC_ERR(("%X: %X: Non-seq ret 0x%X for (%X)\n",
                          GetCurrentThreadId(), ReadCall.Sequence,
                          ReadCall.Status, ReadCall.StubIndex));
#endif
                // This return is for some call other than the current
                // call, which means that RPC is messed up.
                // Discard the return and hope for the best.
                Conn->FreeData(Data);
                continue;
            }

            *Call = ReadCall;
            *InOutData = Data;
            return Call->Status;
        }

        PUCHAR OutData;
        if (ReadCall.OutSize > 0)
        {
            DBG_ASSERT((ReadCall.Flags & DBGRPC_NO_RETURN) == 0);

            OutData = (PUCHAR)Conn->Alloc(ReadCall.OutSize);
            if (OutData == NULL)
            {
                if (Data)
                {
                    Conn->Free(Data);
                }
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            OutData = NULL;
        }

        if (ReadCall.Flags & DBGRPC_NO_RETURN)
        {
            Conn->m_Flags |= DBGRPC_IN_ASYNC_CALL;
        }

        DbgRpcStubFunction StubFn = DbgRpcGetStub(ReadCall.StubIndex);
        if (StubFn != NULL)
        {
            ReadCall.Status = StubFn((IUnknown*)ReadCall.ObjectId,
                                     Conn, &ReadCall, Data, OutData);
        }
        else
        {
            ReadCall.Status = RPC_E_INVALIDMETHOD;
        }

        Conn->m_Flags &= ~DBGRPC_IN_ASYNC_CALL;

        DRPC(("%X: %X: Called %s (%X), ret 0x%X, out %d\n",
              GetCurrentThreadId(), ReadCall.Sequence,
              DbgRpcGetStubName(ReadCall.StubIndex),
              ReadCall.StubIndex, ReadCall.Status, ReadCall.OutSize));

        Status = S_OK;
        if ((ReadCall.Flags & DBGRPC_NO_RETURN) == 0)
        {
            ReadCall.Flags |= DBGRPC_RETURN;

            // Take a lock here to make sure that the header
            // and body are sequential in the stream.
            EnterCriticalSection(&g_DbgRpcLock);

            if (Conn->m_Trans->Write(ReadCall.Sequence,
                                     &ReadCall, sizeof(ReadCall)) !=
                sizeof(ReadCall) ||
                (ReadCall.OutSize > 0 &&
                 Conn->m_Trans->Write(ReadCall.Sequence,
                                      OutData, ReadCall.OutSize) !=
                 ReadCall.OutSize))
            {
                Status = RPC_E_CANTTRANSMIT_CALL;
            }

            LeaveCriticalSection(&g_DbgRpcLock);
        }

        if (OutData) 
        {
            Conn->FreeData(OutData);
        }

        if (Data)
        {
            Conn->FreeData(Data);
        }

        if (Status != S_OK)
        {
            return Status;
        }
    }
}

//----------------------------------------------------------------------------
//
// DbgRpcConnection.
//
//----------------------------------------------------------------------------

DbgRpcConnection* g_DbgRpcConns;

DbgRpcConnection::DbgRpcConnection(DbgRpcTransport* Trans)
{
    m_Trans = Trans;
    m_Next = NULL;
    m_ThreadId = GetCurrentThreadId();
    m_Buffer = PTR_ALIGN2(PUCHAR, m_UnalignedBuffer,
                          DBGRPC_CONN_BUFFER_ALIGN);
    m_BufferUsed = 0;
    m_Flags = 0;
    m_Objects = 0;
}

DbgRpcConnection::~DbgRpcConnection(void)
{
    Disconnect();
}

PUCHAR
DbgRpcConnection::StartCall(DbgRpcCall* Call, DbgRpcObjectId ObjectId,
                            ULONG StubIndex, ULONG InSize, ULONG OutSize)
{
    PUCHAR Data;

    if (InSize > 0)
    {
        Data = (PUCHAR)Alloc(InSize);
        if (Data == NULL)
        {
            return NULL;
        }
    }
    else
    {
        // Have to return a non-zero pointer but
        // it doesn't need to be valid since it should
        // never be used.
        Data = DBGRPC_NO_DATA;
    }

    Call->ObjectId = ObjectId;
    DBG_ASSERT(StubIndex < 0x10000);
    Call->StubIndex = (USHORT)StubIndex;
    Call->Flags = 0;
    Call->InSize = InSize;
    Call->OutSize = OutSize;
    Call->Status = S_OK;
    Call->Sequence = InterlockedIncrement((PLONG)&g_DbgRpcCallSequence);
    Call->Reserved1 = 0;

    return Data;
}

HRESULT
DbgRpcConnection::SendReceive(DbgRpcCall* Call, PUCHAR* InOutData)
{
    //
    // Send call and in-parameter data.
    //

    DRPC(("%X: %X: Calling %s (%X), in %d, out %d\n",
          GetCurrentThreadId(), Call->Sequence,
          DbgRpcGetStubName(Call->StubIndex),
          Call->StubIndex, Call->InSize, Call->OutSize));

    // Allow async callouts from within async calls so
    // that things like output and notifications get
    // delivered when they happen to occur while in
    // an async call.
    if ((m_Flags & DBGRPC_IN_ASYNC_CALL) &&
        !(Call->Flags & DBGRPC_NO_RETURN))
    {
        return RPC_E_CANTCALLOUT_INASYNCCALL;
    }

    // Take a lock here to make sure that the header
    // and body are sequential in the stream.
    EnterCriticalSection(&g_DbgRpcLock);

    if (m_Trans->Write(SEQ_CALL_HEADER, Call, sizeof(*Call)) != sizeof(*Call))
    {
        LeaveCriticalSection(&g_DbgRpcLock);
        return RPC_E_CANTTRANSMIT_CALL;
    }
    if (Call->InSize > 0)
    {
        if (m_Trans->Write(Call->Sequence, *InOutData, Call->InSize) !=
            Call->InSize)
        {
            LeaveCriticalSection(&g_DbgRpcLock);
            return RPC_E_CANTTRANSMIT_CALL;
        }

        // In data is no longer necessary.
        Free(*InOutData);
    }

    LeaveCriticalSection(&g_DbgRpcLock);

    // Clear out data pointer in case of later failures.
    *InOutData = NULL;

    HRESULT Status;

    if (Call->Flags & DBGRPC_NO_RETURN)
    {
        Status = S_OK;
    }
    else
    {
        USHORT StubIndex = Call->StubIndex;

        Status = DbgRpcReceiveCalls(this, Call, InOutData);

        if (Call->StubIndex != StubIndex)
        {
#if DBG
            DRPC_ERR(("%X: %X: Call to %s (%X) returned from %s (%d)\n",
                      GetCurrentThreadId(), Call->Sequence,
                      DbgRpcGetStubName(StubIndex), StubIndex,
                      DbgRpcGetStubName(Call->StubIndex),
                      Call->StubIndex));
#else
            DRPC_ERR(("%X: %X: Mismatched call return\n",
                      GetCurrentThreadId(), Call->Sequence));
#endif
            Status = RPC_E_INVALID_DATAPACKET;
        }
    }

    return Status;
}

PVOID
DbgRpcConnection::MallocAligned(ULONG Size)
{
    PVOID Data, Align;

    // Not enough buffer space left so allocate.  malloc
    // only gives out 8-byte-aligned memory so tweak things
    // to get it aligned.
    Data = malloc(Size + DBGRPC_CONN_BUFFER_ALIGN);
    if (Data != NULL)
    {
        if ((ULONG_PTR)Data & (DBGRPC_CONN_BUFFER_ALIGN - 1))
        {
            Align = PTR_ALIGN2(PVOID, Data, DBGRPC_CONN_BUFFER_ALIGN);
        }
        else
        {
            Align = (PVOID)((PUCHAR)Data + DBGRPC_CONN_BUFFER_ALIGN);
        }

        *((PVOID*)Align - 1) = Data;
    }
    else
    {
        Align = NULL;
    }

    return Align;
}

void
DbgRpcConnection::FreeAligned(PVOID Ptr)
{
    free(*((PVOID*)Ptr - 1));
}

PVOID
DbgRpcConnection::Alloc(ULONG Size)
{
    PVOID Data = NULL;

    // Keep every allocated chunk aligned.
    Size = INT_ALIGN2(Size, DBGRPC_CONN_BUFFER_ALIGN);
#if DBG
    Size += DBGRPC_CONN_BUFFER_ALIGN;
#endif

    // Don't burn up large parts of the buffer on big chunks
    // as that may force many smaller chunks into dynamic
    // allocations because the buffer is full.
    // Only allow the owning thread to allocate from the
    // local buffer to avoid usage conflicts between
    // threads.
    if (Size <= DBGRPC_CONN_BUFFER_DYNAMIC_LIMIT &&
        GetCurrentThreadId() == m_ThreadId)
    {
        if (m_BufferUsed + Size <= DBGRPC_CONN_BUFFER_SIZE)
        {
            // Data is allocated in strict LIFO order so
            // we just need to mark the end of the buffer as used.
            Data = &m_Buffer[m_BufferUsed];
            m_BufferUsed += Size;

#if DBG
            *(PULONG)Data = Size;
            Data = (PUCHAR)Data + DBGRPC_CONN_BUFFER_ALIGN;
#endif
        }
    }

    if (Data == NULL)
    {
        Data = MallocAligned(Size);
    }

    return Data;
}

void
DbgRpcConnection::Free(PVOID Ptr)
{
    if (Ptr >= m_Buffer && Ptr < m_Buffer + DBGRPC_CONN_BUFFER_SIZE)
    {
#if DBG
        Ptr = (PUCHAR)Ptr - DBGRPC_CONN_BUFFER_ALIGN;
        // Assert that this allocation is at the end of the buffer.
        DBG_ASSERT((ULONG)((PUCHAR)Ptr - m_Buffer) + *(PULONG)Ptr ==
                   m_BufferUsed);
#endif
        
        // Data was allocated in the connection buffer.
        // Data is allocated in strict LIFO order so
        // we just need to back up prior to the data.
        m_BufferUsed = (ULONG)((PUCHAR)Ptr - m_Buffer);
    }
    else
    {
        // Data was dynamically allocated.
        FreeAligned(Ptr);
    }
}

void
DbgRpcConnection::Disconnect(void)
{
    delete m_Trans;
    m_Trans = NULL;
}

DbgRpcConnection*
DbgRpcGetConnection(ULONG Tid)
{
    DbgRpcConnection* Conn;

    EnterCriticalSection(&g_DbgRpcLock);

    for (Conn = g_DbgRpcConns; Conn != NULL; Conn = Conn->m_Next)
    {
        if (Conn->m_ThreadId == Tid)
        {
            break;
        }
    }

    LeaveCriticalSection(&g_DbgRpcLock);
    return Conn;
}

void
DbgRpcAddConnection(DbgRpcConnection* Conn)
{
    EnterCriticalSection(&g_DbgRpcLock);

    Conn->m_Next = g_DbgRpcConns;
    g_DbgRpcConns = Conn;

    LeaveCriticalSection(&g_DbgRpcLock);
}

void
DbgRpcRemoveConnection(DbgRpcConnection* Conn)
{
    EnterCriticalSection(&g_DbgRpcLock);

    DbgRpcConnection* Prev = NULL;
    DbgRpcConnection* Cur;
    for (Cur = g_DbgRpcConns; Cur != NULL; Cur = Cur->m_Next)
    {
        if (Cur == Conn)
        {
            break;
        }

        Prev = Cur;
    }

    DBG_ASSERT(Cur != NULL);

    if (Prev == NULL)
    {
        g_DbgRpcConns = Conn->m_Next;
    }
    else
    {
        Prev->m_Next = Conn->m_Next;
    }

    LeaveCriticalSection(&g_DbgRpcLock);
}

void
DbgRpcDeleteConnection(DbgRpcConnection* Conn)
{
    DbgRpcRemoveConnection(Conn);

    // It's possible that another thread is in the middle
    // of using the connection for an async send.  Disconnect
    // the connection to force any pending calls to fail.
    // The connection is already removed from the list
    // so there shouldn't be any further usage.
    Conn->Disconnect();

    // Give up some time to let things fail.  This
    // could be made more deterministic by tracking
    // connection usage but it doesn't seem necessary.
    Sleep(1000);

    delete Conn;
}

//----------------------------------------------------------------------------
//
// DbgRpcProxy.
//
//----------------------------------------------------------------------------

DbgRpcProxy::DbgRpcProxy(ULONG InterfaceIndex)
{
    m_Conn = NULL;
    m_InterfaceIndex = InterfaceIndex;
    m_LocalRefs = 0;
    m_RemoteRefs = 1;
    m_ObjectId = 0;
    m_OwningThread = GetCurrentThreadId();
}

DbgRpcProxy::~DbgRpcProxy(void)
{
    // If this proxy was attached to a connection detach it.
    if (m_Conn)
    {
        DRPC_REF(("Conn %p obj %2d proxy %p\n",
                  m_Conn, m_Conn->m_Objects - 1, this));
        if (InterlockedDecrement((PLONG)&m_Conn->m_Objects) == 0)
        {
            DbgRpcDeleteConnection(m_Conn);
        }
    }
}

IUnknown*
DbgRpcProxy::InitializeProxy(DbgRpcConnection* Conn,
                             DbgRpcObjectId ObjectId,
                             IUnknown* ExistingProxy)
{
    //
    // The current debugger remoting does not preserve
    // object identity as this simplifies proxy
    // management.  Nobody currently needs it, so
    // we're not bothering with it.  If object identity
    // becomes important this routine is the place
    // to implement proxy lookup and sharing.
    //
    
    // Handle NULL object case where proxy is unnecessary.
    if (ObjectId == 0)
    {
        DbgRpcDeleteProxy(this);
        return NULL;
    }
    
    m_Conn = Conn;
    if (m_Conn != NULL)
    {
        InterlockedIncrement((PLONG)&m_Conn->m_Objects);
        DRPC_REF(("Conn %p obj %2d proxy %p\n",
                  m_Conn, m_Conn->m_Objects, this));
    }
    
    m_ObjectId = ObjectId;
    return ExistingProxy;
}

//----------------------------------------------------------------------------
//
// DbgRpcClientObject.
//
//----------------------------------------------------------------------------

void
DbgRpcClientObject::RpcFinalize(void)
{
    // Do-nothing convenience implementation.
}

//----------------------------------------------------------------------------
//
// Registration functions.
//
//----------------------------------------------------------------------------

struct DbgRpcActiveServer
{
    DbgRpcActiveServer* Next;
    ULONG Id;
    DbgRpcTransport* Trans;
    DbgRpcClientObjectFactory* Factory;
    ULONG RegTid;
    ULONG RegIndex;
    BOOL Disabled;
};

DbgRpcActiveServer* g_DbgRpcActiveServers;

ULONG
DbgRpcNextActiveServerId(void)
{
    DbgRpcActiveServer* Server;
    ULONG Id;
    
    //
    // Assumes the RPC lock is held.
    //

    Id = 0;
    for (;;)
    {
        for (Server = g_DbgRpcActiveServers; Server; Server = Server->Next)
        {
            if (Server->Id == Id)
            {
                Id++;
                break;
            }
        }

        if (!Server)
        {
            break;
        }
    }

    return Id;
}

void
DbgRpcDescribeActiveServer(DbgRpcActiveServer* Server,
                           PSTR Buffer, ULONG BufferSize)
{
    DBG_ASSERT(BufferSize >= 2 * MAX_PARAM_VALUE);

    if (Server->Disabled)
    {
        CopyString(Buffer, "<Disabled, exit pending>", BufferSize);
    }
    else
    {
        PSTR Tail;

        Server->Factory->GetServerTypeName(Buffer, BufferSize);
        CatString(Buffer, " - ", BufferSize);
        Tail = Buffer + strlen(Buffer);
        Server->Trans->
            GetParameters(Tail, BufferSize - (ULONG)(Tail - Buffer));
    }
}

PVOID
DbgRpcEnumActiveServers(PVOID Cookie,
                        PULONG Id, PSTR Buffer, ULONG BufferSize)
{
    DbgRpcActiveServer* Server = (DbgRpcActiveServer*)Cookie;

    if (!DbgRpcOneTimeInitialization())
    {
        return NULL;
    }
    
    EnterCriticalSection(&g_DbgRpcLock);
        
    Server = !Server ? g_DbgRpcActiveServers : Server->Next;
    if (!Server)
    {
        LeaveCriticalSection(&g_DbgRpcLock);
        return NULL;
    }

    *Id = Server->Id;
    DbgRpcDescribeActiveServer(Server, Buffer, BufferSize);

    LeaveCriticalSection(&g_DbgRpcLock);
    return Server;
}

void
DbgRpcSystemRegisterActiveServer(DbgRpcActiveServer* Server)
{
    // Start by assuming failure and no system registration.
    Server->RegTid = 0;
    Server->RegIndex = 0;
    
#ifndef NT_NATIVE
    char Desc[2 * MAX_PARAM_VALUE];

    DbgRpcDescribeActiveServer(Server, Desc, sizeof(Desc));
    
    HKEY Key;
    LONG Status;
    char ValName[32];
    ULONG Index;

    // No servers will survive a reboot so create a volatile
    // key to ensure that even if the key isn't cleaned up
    // at process exit it'll go away at the next reboot.
    if ((Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DEBUG_SERVER_KEY,
                                 0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                 NULL, &Key, NULL)) != ERROR_SUCCESS)
    {
        DRPC_ERR(("%X: Unable to register server '%s'\n",
                  GetCurrentThreadId(), Desc));
        return;
    }

    // Prefix the value name with the thread ID to ensure that
    // every thread currently running has its own namespace.  This
    // makes it impossible for two threads to attempt to write
    // the same value at the same time.
    sprintf(ValName, "%08X.", GetCurrentThreadId());

    // Find an unused value and store the server information.
    Index = 0;
    for (;;)
    {
        DWORD Len;
        
        sprintf(ValName + 9, "%08X", Index);
        
        if (RegQueryValueEx(Key, ValName, NULL, NULL, NULL,
                            &Len) != ERROR_SUCCESS)
        {
            break;
        }

        Index++;
    }

    if ((Status = RegSetValueEx(Key, ValName, 0, REG_SZ, (LPBYTE)Desc,
                                strlen(Desc) + 1)) != ERROR_SUCCESS)
    {
        DRPC_ERR(("%X: Unable to register server '%s'\n",
                  GetCurrentThreadId(), Desc));
    }
    else
    {
        Server->RegTid = GetCurrentThreadId();
        Server->RegIndex = Index;
    }
    
    RegCloseKey(Key);
#endif // #ifndef NT_NATIVE
}

void
DbgRpcSystemDeregisterActiveServer(DbgRpcActiveServer* Server)
{
    if (!Server->RegTid)
    {
        return;
    }
    
#ifndef NT_NATIVE
    HKEY Key;
    LONG Status;

    if ((Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DEBUG_SERVER_KEY,
                                 0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                 NULL, &Key, NULL)) != ERROR_SUCCESS)
    {
        return;
    }
       
    char ValName[32];
        
    sprintf(ValName, "%08X.%08X", Server->RegTid, Server->RegIndex);
    RegDeleteValue(Key, ValName);
    Server->RegTid = 0;
    Server->RegIndex = 0;

    RegCloseKey(Key);
#endif // #ifndef NT_NATIVE
}

void
DbgRpcRegisterActiveServer(DbgRpcActiveServer* Server)
{
    DbgRpcActiveServer* Cur;
    DbgRpcActiveServer* Prev;
    
    EnterCriticalSection(&g_DbgRpcLock);

    //
    // Put entry in list sorted by ID.
    //
    
    Server->Id = DbgRpcNextActiveServerId();
    Prev = NULL;
    for (Cur = g_DbgRpcActiveServers; Cur; Cur = Cur->Next)
    {
        if (Cur->Id > Server->Id)
        {
            break;
        }

        Prev = Cur;
    }
    Server->Next = Cur;
    if (!Prev)
    {
        g_DbgRpcActiveServers = Server;
    }
    else
    {
        Prev->Next = Server;
    }

    DbgRpcSystemRegisterActiveServer(Server);
    
    LeaveCriticalSection(&g_DbgRpcLock);
}

void
DbgRpcDeregisterActiveServer(DbgRpcActiveServer* Server)
{
    DbgRpcActiveServer* Cur;
    DbgRpcActiveServer* Prev;
    
    EnterCriticalSection(&g_DbgRpcLock);

    Prev = NULL;
    for (Cur = g_DbgRpcActiveServers; Cur; Cur = Cur->Next)
    {
        if (Cur == Server)
        {
            break;
        }

        Prev = Cur;
    }

    if (Cur)
    {
        if (!Prev)
        {
            g_DbgRpcActiveServers = Server->Next;
        }
        else
        {
            Prev->Next = Server->Next;
        }
    }
        
    DbgRpcSystemDeregisterActiveServer(Server);
    
    LeaveCriticalSection(&g_DbgRpcLock);
}

HRESULT
DbgRpcDisableServer(ULONG Id)
{
    HRESULT Status;
    DbgRpcActiveServer* Cur;
    
    EnterCriticalSection(&g_DbgRpcLock);

    for (Cur = g_DbgRpcActiveServers; Cur; Cur = Cur->Next)
    {
        if (Cur->Id == Id)
        {
            break;
        }
    }

    if (Cur)
    {
        // Let the accept thread know that the server has been disabled.
        Cur->Disabled = TRUE;

        // Immediately remove the system registration as
        // this server will accept no more connections.
        // The active server entry will be cleaned up when
        // the accept thread exits.
        DbgRpcSystemDeregisterActiveServer(Cur);

        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }
    
    LeaveCriticalSection(&g_DbgRpcLock);
    return Status;
}

void
DbgRpcDeregisterServers(void)
{
    // Deregister handles the case of a stale pointer value
    // so there's no need to lock in this loop.
    while (g_DbgRpcActiveServers)
    {
        DbgRpcDeregisterActiveServer(g_DbgRpcActiveServers);
    }
}

//----------------------------------------------------------------------------
//
// Initialization functions.
//
//----------------------------------------------------------------------------

DbgRpcConnection*
DbgRpcCreateClientObject(DbgRpcTransport* Trans,
                         DbgRpcClientObjectFactory* Factory,
                         PSTR TransIdentity,
                         DbgRpcClientObject** ClientObject)
{
    DbgRpcConnection* Conn = new DbgRpcConnection(Trans);
    if (Conn == NULL)
    {
        DRPC_ERR(("%X: Unable to allocate client connection\n",
                  GetCurrentThreadId()));
        delete Trans;
        return NULL;
    }

    DRPC(("%X: Read handshake\n",
          GetCurrentThreadId()));
    
    DbgRpcHandshake Shake;
    
    if (Trans->Read(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        DRPC_ERR(("%X: Unable to read handshake from remote client\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    DRPC(("%X: Read handshake, sig %X, ver %X, obj %I64X, id %d, pwd %d\n",
          GetCurrentThreadId(), Shake.Signature, Shake.ProtocolVersion,
          Shake.RemoteObject, Shake.IdentityLength, Shake.PasswordLength));
    
    if (Shake.Signature != DBGRPC_SIGNATURE ||
        Shake.ProtocolVersion != DBGRPC_PROTOCOL_VERSION ||
        Shake.RemoteObject != 0 ||
        Shake.IdentityLength > DBGRPC_MAX_IDENTITY ||
        (Shake.PasswordLength != 0 &&
         Shake.PasswordLength != MAX_PASSWORD_BUFFER))
    {
        DRPC_ERR(("%X: Invalid handshake from remote client\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    char ClientIdentity[DBGRPC_MAX_IDENTITY];
    
    if (Shake.IdentityLength > 0)
    {
        if (Trans->Read(SEQ_IDENTITY, ClientIdentity, Shake.IdentityLength) !=
            Shake.IdentityLength)
        {
            DRPC_ERR(("%X: Unable to read identity from remote client\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        ClientIdentity[Shake.IdentityLength - 1] = 0;
    }
    else
    {
        strcpy(ClientIdentity, "OldRpc\\NoIdentity");
    }

    //
    // Format the raw transport identity into something
    // that'll look better appended to the reported identity.
    //
    
    if (Shake.PasswordLength > 0)
    {
        if (!Trans->m_PasswordGiven)
        {
            DRPC_ERR(("%X: Password not given but client sent one\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        UCHAR Pwd[MAX_PASSWORD_BUFFER];

        if (Trans->Read(SEQ_PASSWORD, Pwd, Shake.PasswordLength) !=
            Shake.PasswordLength)
        {
            DRPC_ERR(("%X: Unable to read password from remote client\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        if (memcmp(Pwd, Trans->m_HashedPassword, MAX_PASSWORD_BUFFER) != 0)
        {
            DRPC_ERR(("%X: Client sent incorrect password\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }
    }
    else if (Trans->m_PasswordGiven)
    {
        DRPC_ERR(("%X: Password given but client didn't send one\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    if (Shake.Flags & DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN)
    {
        Conn->m_Flags |= DBGRPC_FULL_REMOTE_UNKNOWN;
    }
    
    DbgRpcClientObject* Object;
    PVOID ObjInterface;

    if (Factory->CreateInstance(&Shake.DesiredObject, &Object) != S_OK)
    {
        DRPC_ERR(("%X: Unable to create client object instance\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }
    if (Object->RpcInitialize(ClientIdentity, TransIdentity,
                              &ObjInterface) != S_OK)
    {
        DRPC_ERR(("%X: Unable to initialize client object\n",
                  GetCurrentThreadId()));
        goto EH_Object;
    }
    
    ZeroMemory(&Shake, sizeof(Shake));
    Shake.Signature = DBGRPC_SIGNATURE;
    Shake.ProtocolVersion = DBGRPC_PROTOCOL_VERSION;
    Shake.RemoteObject = (DbgRpcObjectId)ObjInterface;
    Shake.Flags = DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN;
    if (Trans->Write(SEQ_HANDSHAKE,
                     &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        DRPC_ERR(("%X: Unable to write handshake to remote client\n",
                  GetCurrentThreadId()));
        goto EH_Object;
    }

    DRPC(("%X: Object %p created\n",
          GetCurrentThreadId(), Object));

    Object->RpcFinalize();
    *ClientObject = Object;
    DbgRpcAddConnection(Conn);
    return Conn;

 EH_Object:
    Object->RpcUninitialize();
 EH_Conn:
    delete Conn;
    return NULL;
}

struct ClientThreadData
{
    DbgRpcTransport* Trans;
    DbgRpcClientObjectFactory* Factory;
    char Identity[DBGRPC_MAX_IDENTITY];
};

DWORD WINAPI
DbgRpcClientThread(PVOID ThreadParam)
{
    DbgRpcClientObject* Object;
    ClientThreadData* ThreadData = (ClientThreadData*)ThreadParam;
    DbgRpcTransport* Trans = ThreadData->Trans;
    DbgRpcClientObjectFactory* Factory = ThreadData->Factory;
    
    DbgRpcConnection* Conn =
        DbgRpcCreateClientObject(Trans, Factory,
                                 ThreadData->Identity, &Object);
    
    // Don't need this information any more.
    delete ThreadParam;
    
    if (Conn == NULL)
    {
        ExitUserThread(0);
    }

    if (DbgRpcServerThreadInitialize() != S_OK)
    {
        ExitUserThread(0);
    }
    
    DRPC(("%X: Created connection %p\n",
          GetCurrentThreadId(), Conn));

    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Take a reference on the connection to ensure that
    // it stays alive as long as this thread does.
    Conn->m_Objects++;
    
    for (;;)
    {
        Data = NULL;
        ZeroMemory(&Call, sizeof(Call));
        Status = DbgRpcReceiveCalls(Conn, &Call, &Data);
        Conn->FreeData(Data);
        if (Status != S_OK)
        {
            DRPC_ERR(("%X: Client thread call receive failed, 0x%X\n",
                      GetCurrentThreadId(), Status));
            if (Status == RPC_E_CLIENT_DIED)
            {
                break;
            }
        }
    }

    DRPC(("%X: Removing connection %p\n",
          GetCurrentThreadId(), Conn));

    Object->RpcUninitialize();
    DbgRpcDeleteConnection(Conn);
    DbgRpcServerThreadUninitialize();
    ExitUserThread(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

#define WAIT_START_LOOPS 200
#define WAIT_START_DELAY 50

struct ServerThreadData
{
    DbgRpcTransport* Trans;
    DbgRpcClientObjectFactory* Factory;
    BOOL WaitStart;
};

DWORD WINAPI
DbgRpcServerThread(PVOID ThreadParam)
{
    ServerThreadData* ServerData = (ServerThreadData*)ThreadParam;
    DbgRpcActiveServer Server;
    ULONG Attempts = 0;

    ZeroMemory(&Server, sizeof(Server));
    Server.Trans = ServerData->Trans;
    Server.Factory = ServerData->Factory;

    HRESULT Status;
    ClientThreadData* ClientData = NULL;

    if (!Server.Trans->m_Hidden)
    {
        // Register this server for people browsing for servers.
        DbgRpcRegisterActiveServer(&Server);
    }

    if (ServerData->WaitStart)
    {
        // If the creator is waiting for startup, signal
        // that startup is complete and then wait
        // for acknowledgement.
        ServerData->WaitStart = FALSE;
        while (!ServerData->WaitStart)
        {
            Sleep(WAIT_START_DELAY);
        }
    }
    
    // Values are now cached locally so free passed-in data.
    delete ServerData;
    
    while (!Server.Disabled)
    {
        if (ClientData == NULL)
        {
            ClientData = new ClientThreadData;
            if (ClientData == NULL)
            {
                DRPC_ERR(("%X: Unable to allocate ClientThreadData\n",
                          GetCurrentThreadId()));
                Sleep(100);
                continue;
            }
        }
        
        Status = Server.Trans->AcceptConnection(&ClientData->Trans,
                                                ClientData->Identity,
                                                DIMA(ClientData->Identity));
        Attempts++;

        // If this server has been disabled we don't want
        // to accept any more connections.
        if (Status == S_OK && Server.Disabled)
        {
            delete ClientData->Trans;
            Status = RPC_E_REMOTE_DISABLED;
        }
        
        if (Status == S_OK)
        {
            DWORD Tid;

            ClientData->Factory = Server.Factory;
            HANDLE Thread = CreateUserThread(DbgRpcClientThread,
                                             ClientData, &Tid);
            if (Thread == NULL)
            {
                DRPC_ERR(("%X: Client thread create failed, %d\n",
                          GetCurrentThreadId(), GetLastError()));
                Sleep(100);
            }
            else
            {
                Attempts = 0;
                CloseHandle(Thread);
                ClientData = NULL;
            }

            if (Server.Trans->m_ClientConnect)
            {
                if (Server.Trans->m_ClientConnectAttempts == 0)
                {
                    // If this is a client connect server
                    // it can't accept any more connections,
                    // so this thread is done.
                    break;
                }
                
                Server.Trans->m_ClientConnectAttempts--;
            }
        }
        else if (!Server.Disabled)
        {
            DRPC_ERR(("%X: Accept failed, %X\n",
                      GetCurrentThreadId(), Status));

            if (Server.Trans->m_ClientConnect)
            {
                Sleep(500);
            }
            else
            {
                Sleep(100);
            }
        }
    }

    DbgRpcDeregisterActiveServer(&Server);
    delete Server.Trans;
    
    ExitUserThread(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

HRESULT
DbgRpcCreateServer(PCSTR Options, DbgRpcClientObjectFactory* Factory,
                   BOOL Wait)
{
    DbgRpcTransport* Trans;
    HRESULT Status;

    if (!DbgRpcOneTimeInitialization())
    {
        return E_FAIL;
    }

    Trans = DbgRpcInitializeTransport(Options);
    if (Trans == NULL)
    {
        return E_INVALIDARG;
    }

    Status = Trans->CreateServer();
    if (Status != S_OK)
    {
        goto EH_Trans;
    }

    ServerThreadData* ThreadData;

    ThreadData = new ServerThreadData;
    if (ThreadData == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Trans;
    }

    ThreadData->Trans = Trans;
    ThreadData->Factory = Factory;
    ThreadData->WaitStart = Wait;
    
    DWORD Tid;
    HANDLE Thread;
    Thread = CreateUserThread(DbgRpcServerThread, ThreadData, &Tid);
    if (Thread == NULL)
    {
        Status = WIN32_LAST_STATUS();
        delete ThreadData;
        goto EH_Trans;
    }

    CloseHandle(Thread);

    if (Wait)
    {
        ULONG Loops = WAIT_START_LOOPS;
        
        // Wait for the client thread to signal startup and
        // then acknowledge the signal.  There's a timeout
        // just in case the thread faults or something.
        while (ThreadData->WaitStart && Loops-- > 0)
        {
            Sleep(WAIT_START_DELAY);
        }
        ThreadData->WaitStart = TRUE;
    }
        
    return S_OK;

 EH_Trans:
    delete Trans;
    return Status;
}

#define MIN_CLIENT_IDENTITY (DBGRPC_MAX_IDENTITY * 3 / 4)

void
GetClientIdentity(PSTR Identity, ULONG IdentitySize)
{
#if !defined(NT_NATIVE) && !defined(_WIN32_WCE)
    char CompName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG CompSize;
    char UserName[UNLEN + 1];
    ULONG UserSize;

    CompSize = sizeof(CompName);
    if (!GetComputerName(CompName, &CompSize))
    {
        sprintf(CompName, "CErr%d", GetLastError());
        CompSize = strlen(CompName);
    }
    else if (CompSize == 0)
    {
        strcpy(CompName, "NoComp");
        CompSize = 6;
    }
    if (CompSize > DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1)
    {
        CompSize = DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1;
    }
    CompName[CompSize] = 0;

    UserSize = sizeof(UserName);
    if (!GetUserName(UserName, &UserSize))
    {
        sprintf(UserName, "UErr%d", GetLastError());
        UserSize = strlen(UserName);
    }
    else if (UserSize == 0)
    {
        strcpy(UserName, "NoUser");
        UserSize = 6;
    }
    if (UserSize > DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1)
    {
        UserSize = DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1;
    }
    UserName[UserSize] = 0;

    CopyString(Identity, CompName, IdentitySize);
    CatString(Identity, "\\", IdentitySize);
    CatString(Identity, UserName, IdentitySize);
#else
    CopyString(Identity, "NtNative", IdentitySize);
#endif // #if !defined(NT_NATIVE) && !defined(_WIN32_WCE)
}

HRESULT
DbgRpcCreateServerConnection(DbgRpcTransport* Trans,
                             const GUID* DesiredObject,
                             IUnknown** ClientObject)
{
    HRESULT Status;

    DbgRpcConnection* Conn = new DbgRpcConnection(Trans);
    if (Conn == NULL)
    {
        delete Trans;
        return E_OUTOFMEMORY;
    }

    IUnknown* Object;
    DbgRpcProxy* Proxy;
    ULONG IfUnique;

    Status = DbgRpcPreallocProxy(*DesiredObject, (void **)&Object,
                                 &Proxy, &IfUnique);
    if (Status != S_OK)
    {
        goto EH_Conn;
    }

    Status = Trans->ConnectServer();
    if (Status != S_OK)
    {
        goto EH_Proxy;
    }

    char Identity[DBGRPC_MAX_IDENTITY];
    
    GetClientIdentity(Identity, DIMA(Identity));
    
    DbgRpcHandshake Shake;
    
    ZeroMemory(&Shake, sizeof(Shake));
    Shake.Signature = DBGRPC_SIGNATURE;
    Shake.ProtocolVersion = DBGRPC_PROTOCOL_VERSION;
    Shake.DesiredObject = *DesiredObject;
    Shake.IdentityLength = sizeof(Identity);
    Shake.PasswordLength = Trans->m_PasswordGiven ? MAX_PASSWORD_BUFFER : 0;
    Shake.Flags = DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN;
    if (Trans->Write(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }
    if (Trans->Write(SEQ_IDENTITY, Identity, Shake.IdentityLength) !=
        Shake.IdentityLength)
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }
    if (Trans->m_PasswordGiven &&
        Trans->Write(SEQ_PASSWORD,
                     Trans->m_HashedPassword, Shake.PasswordLength) !=
        Shake.PasswordLength)
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }

    if (Trans->Read(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }

    DRPC(("%X: Read handshake, sig %X, ver %X\n",
          GetCurrentThreadId(), Shake.Signature, Shake.ProtocolVersion));
    
    if (Shake.Signature != DBGRPC_SIGNATURE ||
        Shake.ProtocolVersion != DBGRPC_PROTOCOL_VERSION ||
        Shake.RemoteObject == 0)
    {
        Status = RPC_E_VERSION_MISMATCH;
        goto EH_Proxy;
    }

    if (Shake.Flags & DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN)
    {
        Conn->m_Flags |= DBGRPC_FULL_REMOTE_UNKNOWN;
    }
    
    DbgRpcAddConnection(Conn);
    *ClientObject = Proxy->InitializeProxy(Conn, Shake.RemoteObject, Object);

    DRPC(("%X: Object %I64X proxied by %p\n",
          GetCurrentThreadId(), Shake.RemoteObject, *ClientObject));
    
    return S_OK;

 EH_Proxy:
    DbgRpcDeleteProxy(Proxy);
 EH_Conn:
    delete Conn;
    return Status;
}

HRESULT
DbgRpcConnectServer(PCSTR Options, const GUID* DesiredObject,
                    IUnknown** ClientObject)
{
    DbgRpcTransport* Trans;

    if (!DbgRpcOneTimeInitialization())
    {
        return E_FAIL;
    }

    Trans = DbgRpcInitializeTransport(Options);
    if (Trans == NULL)
    {
        return E_INVALIDARG;
    }

    return DbgRpcCreateServerConnection(Trans, DesiredObject, ClientObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\dbgrpc.hpp ===
//----------------------------------------------------------------------------
//
// Remoting support.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGRPC_HPP__
#define __DBGRPC_HPP__

#include <wincrypt.h>
#include <security.h>
#ifdef _WIN32_WCE
#include <winsock.h>
#else
#include <winsock2.h>
#include <schannel.h>
#endif

#include <pparse.hpp>
#include <portio.h>

#define DEBUG_SERVER_KEY "Software\\Microsoft\\Debug Engine\\Servers"

#define INT_ALIGN2(Val, Pow2) \
    (((Val) + (Pow2) - 1) & ~((Pow2) - 1))
#define PTR_ALIGN2(Type, Ptr, Pow2) \
    ((Type)INT_ALIGN2((ULONG64)(Ptr), Pow2))

#define DBGRPC_MAX_IDENTITY 128

typedef ULONG64 DbgRpcObjectId;

//
// Stub functions are indexed out of per-interface tables.
// The function indices are encoded as part interface index
// and part method index.
//

#define DBGRPC_STUB_INDEX_INTERFACE_SHIFT 8
#define DBGRPC_STUB_INDEX_INTERFACE_MAX \
    ((1 << (8 * sizeof(USHORT) - DBGRPC_STUB_INDEX_INTERFACE_SHIFT)) - 1)
#define DBGRPC_STUB_INDEX_METHOD_MAX \
    ((1 << DBGRPC_STUB_INDEX_INTERFACE_SHIFT) - 1)

#define DBGRPC_STUB_INDEX(Interface, Method) \
    ((USHORT)(((Interface) << DBGRPC_STUB_INDEX_INTERFACE_SHIFT) | (Method)))
#define DBGRPC_STUB_INDEX_INTERFACE(StubIndex) \
    ((StubIndex) >> DBGRPC_STUB_INDEX_INTERFACE_SHIFT)
#define DBGRPC_STUB_INDEX_METHOD(StubIndex) \
    ((StubIndex) & DBGRPC_STUB_INDEX_METHOD_MAX)

//
// Interface indices for stub indices are given here
// rather than generated as they must stay constant
// for compatibility.
//
// IMPORTANT: New interfaces must be added at the end of
// the section for that header.  New headers must be
// well separated from each other to allow expansion.
//

enum
{
    // The first dbgeng interface must always be zero.
    DBGRPC_SIF_IDebugAdvanced,
    DBGRPC_SIF_IDebugBreakpoint,
    DBGRPC_SIF_IDebugClient,
    DBGRPC_SIF_IDebugControl,
    DBGRPC_SIF_IDebugDataSpaces,
    DBGRPC_SIF_IDebugEventCallbacks,
    DBGRPC_SIF_IDebugInputCallbacks,
    DBGRPC_SIF_IDebugOutputCallbacks,
    DBGRPC_SIF_IDebugRegisters,
    DBGRPC_SIF_IDebugSymbolGroup,
    DBGRPC_SIF_IDebugSymbols,
    DBGRPC_SIF_IDebugSystemObjects,
    DBGRPC_SIF_IDebugClient2,
    DBGRPC_SIF_IDebugControl2,
    DBGRPC_SIF_IDebugDataSpaces2,
    DBGRPC_SIF_IDebugSymbols2,
    DBGRPC_SIF_IDebugSystemObjects2,
    DBGRPC_SIF_IDebugClient3,
    DBGRPC_SIF_IDebugSystemObjects3,
    DBGRPC_SIF_IDebugControl3,
    DBGRPC_SIF_IDebugDataSpaces3,
    DBGRPC_SIF_IDebugClient4,
    // Add new dbgeng interfaces here.
    DBGRPC_SIF_DBGENG_AFTER_LAST,

    DBGRPC_SIF_IUserDebugServices = 192,
    // Add new dbgsvc interfaces here.
    DBGRPC_SIF_DBGSVC_AFTER_LAST,
};

#define DBGRPC_SIF_DBGENG_FIRST 0
#define DBGRPC_SIF_DBGENG_LAST  (DBGRPC_SIF_DBGENG_AFTER_LAST - 1)

#define DBGRPC_SIF_DBGSVC_FIRST DBGRPC_SIF_IUserDebugServices
#define DBGRPC_SIF_DBGSVC_LAST  (DBGRPC_SIF_DBGSVC_AFTER_LAST - 1)

#define DBGRPC_RETURN           0x0001
#define DBGRPC_NO_RETURN        0x0002
#define DBGRPC_LOCKED           0x0004

struct DbgRpcCall
{
    DbgRpcObjectId ObjectId;
    USHORT StubIndex;
    USHORT Flags;
    ULONG InSize;
    ULONG OutSize;
    HRESULT Status;
    ULONG Sequence;
    ULONG Reserved1;
};

//
// These functions and tables are automatically generated.
//

typedef HRESULT (*DbgRpcStubFunction)
    (IUnknown* If, class DbgRpcConnection* Conn, DbgRpcCall* Call,
     PUCHAR InData, PUCHAR OutData);

struct DbgRpcStubFunctionTable
{
    DbgRpcStubFunction* Functions;
    ULONG Count;
};

// These functions are provided by a caller of dbgrpc with
// implementations specific to the caller.
void DbgRpcInitializeClient(void);
DbgRpcStubFunction DbgRpcGetStub(USHORT StubIndex);
#if DBG
PCSTR DbgRpcGetStubName(USHORT StubIndex);
#endif
HRESULT DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                            class DbgRpcProxy** Proxy, PULONG IfUnique);
void DbgRpcDeleteProxy(class DbgRpcProxy* Proxy);
HRESULT DbgRpcServerThreadInitialize(void);
void DbgRpcServerThreadUninitialize(void);
void DbgRpcError(char* Format, ...);

//----------------------------------------------------------------------------
//
// DbgRpcTransport.
//
//----------------------------------------------------------------------------

#define MAX_SERVER_NAME MAX_PARAM_VALUE
#define MAX_PASSWORD_BUFFER 32

enum
{
    TRANS_TCP,
    TRANS_NPIPE,
    TRANS_SSL,
    TRANS_SPIPE,
    TRANS_1394,
    TRANS_COM,
    TRANS_COUNT
};

extern PCSTR g_DbgRpcTransportNames[TRANS_COUNT];

class DbgRpcTransport : public ParameterStringParser
{
public:
    DbgRpcTransport(void)
    {
        m_ServerName[0] = 0;
        m_PasswordGiven = FALSE;
        m_Hidden = FALSE;
        m_ClientConnect = FALSE;
        m_ClientConnectAttempts = 0;
    }
    virtual ~DbgRpcTransport(void);

    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void) = 0;

    virtual HRESULT CreateServer(void) = 0;
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize) = 0;

    virtual HRESULT ConnectServer(void) = 0;

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len) = 0;
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len) = 0;

    void CloneData(DbgRpcTransport* Trans);

    char m_ServerName[MAX_SERVER_NAME];
    BOOL m_PasswordGiven;
    BOOL m_Hidden;
    BOOL m_ClientConnect;
    ULONG m_ClientConnectAttempts;
    UCHAR m_HashedPassword[MAX_PASSWORD_BUFFER];
};

class DbgRpcTcpTransport : public DbgRpcTransport
{
public:
    DbgRpcTcpTransport(void);
    virtual ~DbgRpcTcpTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    HRESULT InitOl(void);
    void GetAddressIdentity(PSOCKADDR_STORAGE Addr,
                            int AddrLength,
                            PSTR Identity,
                            ULONG IdentitySize);
    HRESULT CreateServerSocket(void);
    HRESULT AcceptSocketConnection(SOCKET ServSock);
    HRESULT ConnectSocket(void);
    
    SOCKADDR_STORAGE m_Addr;
    int m_AddrLength;
    SOCKET m_Sock;
    WSAOVERLAPPED m_OlRead, m_OlWrite;
    ULONG m_TopPort;
    char m_ClientConnectName[MAX_SERVER_NAME];
    SOCKADDR_STORAGE m_ClientConnectAddr;
    int m_ClientConnectAddrLength;
};

#ifndef _WIN32_WCE

class DbgRpcNamedPipeTransport : public DbgRpcTransport
{
public:
    DbgRpcNamedPipeTransport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_NPIPE];
        m_Handle = NULL;
        ZeroMemory(&m_ReadOlap, sizeof(m_ReadOlap));
        ZeroMemory(&m_WriteOlap, sizeof(m_WriteOlap));
    }
    virtual ~DbgRpcNamedPipeTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    char m_Pipe[MAX_PARAM_VALUE];
    HANDLE m_Handle;
    OVERLAPPED m_ReadOlap, m_WriteOlap;
};

// This class is a generic schannel-based wrapper for
// a normal transport.

#define DBGRPC_SCHAN_BUFFER 16384

class DbgRpcSecureChannelTransport : public DbgRpcTransport
{
public:
    DbgRpcSecureChannelTransport(ULONG ThisTransport,
                                 ULONG BaseTransport);
    virtual ~DbgRpcSecureChannelTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    // DbgRpcSecureChannelTransport.
    HRESULT GetSizes(void);
    HRESULT AuthenticateClientConnection(void);
    HRESULT InitiateServerConnection(LPSTR pszServerName);
    HRESULT AuthenticateServerConnection(void);
    void GetNewClientCredentials(void);
    void DisconnectFromClient(void);
    void DisconnectFromServer(void);

    ULONG StreamRead(ULONG Seq, PVOID Buffer, ULONG MaxSize)
    {
        ULONG Size;

        if (m_Stream->Read(Seq, &Size, sizeof(Size)) != sizeof(Size) ||
            Size > MaxSize)
        {
            return 0;
        }
        return m_Stream->Read(Seq, Buffer, Size);
    }
    ULONG StreamWrite(ULONG Seq, PVOID Buffer, ULONG Size)
    {
        if (m_Stream->Write(Seq, &Size, sizeof(Size)) != sizeof(Size))
        {
            return 0;
        }
        return m_Stream->Write(Seq, Buffer, Size);
    }

    ULONG m_ThisTransport;
    ULONG m_BaseTransport;
    DbgRpcTransport* m_Stream;
    SCHANNEL_CRED m_ScCreds;
    CredHandle m_Creds;
    BOOL m_OwnCreds;
    CtxtHandle m_Context;
    BOOL m_OwnContext;
    ULONG m_Protocol;
    char m_User[64];
    BOOL m_MachineStore;
    UCHAR m_Buffer[DBGRPC_SCHAN_BUFFER];
    ULONG m_BufferUsed;
    SecPkgContext_StreamSizes m_Sizes;
    ULONG m_MaxChunk;
    BOOL m_Server;
};

class DbgRpc1394Transport : public DbgRpcTransport
{
public:
    DbgRpc1394Transport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_1394];
        m_Handle = NULL;
    }
    virtual ~DbgRpc1394Transport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    ULONG m_AcceptChannel;
    ULONG m_StreamChannel;
    HANDLE m_Handle;
};

class DbgRpcComTransport : public DbgRpcTransport
{
public:
    DbgRpcComTransport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_COM];
        m_Handle = NULL;
        ZeroMemory(&m_ReadOlap, sizeof(m_ReadOlap));
        ZeroMemory(&m_WriteOlap, sizeof(m_WriteOlap));
        m_Timeout = INFINITE;
    }
    virtual ~DbgRpcComTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    USHORT ScanQueue(UCHAR Chan, PVOID Buffer, USHORT Len);
    USHORT ScanPort(UCHAR Chan, PVOID Buffer, USHORT Len,
                    BOOL ScanForAck, UCHAR AckChan);
    USHORT ChanRead(UCHAR Chan, PVOID Buffer, USHORT Len);
    USHORT ChanWrite(UCHAR Chan, PVOID Buffer, USHORT Len);

    char m_PortName[MAX_PARAM_VALUE];
    ULONG m_BaudRate;
    UCHAR m_AcceptChannel;
    UCHAR m_StreamChannel;
    HANDLE m_Handle;
    OVERLAPPED m_ReadOlap, m_WriteOlap;
    COM_PORT_TYPE m_PortType;
    ULONG m_Timeout;

    static HRESULT InitializeChannels(void);
    
    static BOOL s_ChanInitialized;
    static CRITICAL_SECTION s_QueueLock;
    static HANDLE s_QueueChangedEvent;
    static LONG s_PortReadOwned;
    static CRITICAL_SECTION s_PortWriteLock;
    static CRITICAL_SECTION s_WriteAckLock;
    static HANDLE s_WriteAckEvent;
    static struct DbgRpcComQueue* s_QueueHead;
    static struct DbgRpcComQueue* s_QueueTail;
};

#endif // #ifndef _WIN32_WCE

//----------------------------------------------------------------------------
//
// DbgRpcConnection.
//
//----------------------------------------------------------------------------

// Special value indicating no data was actually allocated.
// NULL is not used to make it easy to catch access.
#define DBGRPC_NO_DATA ((PUCHAR)(ULONG64)-1)

#define DBGRPC_CONN_BUFFER_SIZE 4096
#define DBGRPC_CONN_BUFFER_ALIGN 16
#define DBGRPC_CONN_BUFFER_DYNAMIC_LIMIT 1024

#define DBGRPC_IN_ASYNC_CALL       0x00000001
#define DBGRPC_FULL_REMOTE_UNKNOWN 0x00000002

class DbgRpcConnection
{
public:
    DbgRpcConnection(class DbgRpcTransport* Trans);
    ~DbgRpcConnection(void);
    
    PUCHAR StartCall(DbgRpcCall* Call, DbgRpcObjectId ObjectId,
                     ULONG StubIndex, ULONG InSize, ULONG OutSize);
    HRESULT SendReceive(DbgRpcCall* Call, PUCHAR* InOutData);
    void FreeData(PUCHAR Data)
    {
        if (Data != NULL && Data != DBGRPC_NO_DATA)
        {
            Free(Data);
        }
    }

    PVOID MallocAligned(ULONG Size);
    void FreeAligned(PVOID Ptr);
    PVOID Alloc(ULONG Size);
    void Free(PVOID Ptr);

    void Disconnect(void);
    
    class DbgRpcTransport* m_Trans;
    DbgRpcConnection* m_Next;
    ULONG m_ThreadId;
    UCHAR m_UnalignedBuffer[DBGRPC_CONN_BUFFER_SIZE +
                            DBGRPC_CONN_BUFFER_ALIGN];
    PUCHAR m_Buffer;
    ULONG m_BufferUsed;
    ULONG m_Flags;
    ULONG m_Objects;
};

//----------------------------------------------------------------------------
//
// DbgRpcProxy.
//
//----------------------------------------------------------------------------

class DbgRpcProxy
{
public:
    DbgRpcProxy(ULONG InterfaceIndex);
    ~DbgRpcProxy(void);

    IUnknown* InitializeProxy(DbgRpcConnection* Conn,
                              DbgRpcObjectId ObjectId,
                              IUnknown* ExistingProxy);

    DbgRpcConnection* m_Conn;
    DbgRpcObjectId m_ObjectId;
    ULONG m_InterfaceIndex;
    ULONG m_OwningThread;
    ULONG m_LocalRefs, m_RemoteRefs;
};

//----------------------------------------------------------------------------
//
// DbgRpcClientObject.
//
//----------------------------------------------------------------------------

class DbgRpcClientObject
{
public:
    virtual HRESULT RpcInitialize(PSTR ClientIdentity, PSTR TransIdentity,
                                  PVOID* Interface) = 0;
    // Base implementation does nothing.
    virtual void    RpcFinalize(void);
    virtual void    RpcUninitialize(void) = 0;
};

//----------------------------------------------------------------------------
//
// DbgRpcClientObjectFactory.
//
//----------------------------------------------------------------------------

class DbgRpcClientObjectFactory
{
public:
    virtual HRESULT CreateInstance(const GUID* DesiredObject,
                                   DbgRpcClientObject** Object) = 0;
    virtual void GetServerTypeName(PSTR Buffer, ULONG BufferSize) = 0;
};

#define DBGRPC_SIMPLE_FACTORY(Class, Guid, Name, CtorArgs)                    \
class Class##Factory : public DbgRpcClientObjectFactory                       \
{                                                                             \
public:                                                                       \
    virtual HRESULT CreateInstance(const GUID* DesiredObject,                 \
                                   DbgRpcClientObject** Object);              \
    virtual void GetServerTypeName(PSTR Buffer, ULONG BufferSize);            \
};                                                                            \
HRESULT                                                                       \
Class##Factory::CreateInstance(const GUID* DesiredObject,                     \
                               DbgRpcClientObject** Object)                   \
{                                                                             \
    if (DbgIsEqualIID(Guid, *DesiredObject))                                  \
    {                                                                         \
        *Object = (DbgRpcClientObject*)new Class CtorArgs;                    \
        return *Object != NULL ? S_OK : E_OUTOFMEMORY;                        \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        return E_NOINTERFACE;                                                 \
    }                                                                         \
}                                                                             \
void                                                                          \
Class##Factory::GetServerTypeName(PSTR Buffer, ULONG BufferSize)              \
{                                                                             \
    CopyString(Buffer, Name, BufferSize);                                     \
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

extern CRITICAL_SECTION g_DbgRpcLock;

DbgRpcTransport*
DbgRpcNewTransport(ULONG Trans);
DbgRpcTransport*
DbgRpcInitializeTransport(PCSTR Options);

PVOID
DbgRpcEnumActiveServers(PVOID Cookie,
                        PULONG Id, PSTR Buffer, ULONG BufferSize);
HRESULT
DbgRpcDisableServer(ULONG Id);
void
DbgRpcDeregisterServers(void);
HRESULT
DbgRpcCreateServerConnection(DbgRpcTransport* Trans,
                             const GUID* DesiredObject,
                             IUnknown** ClientObject);
HRESULT
DbgRpcCreateServer(PCSTR Options, DbgRpcClientObjectFactory* Factory,
                   BOOL Wait);
HRESULT
DbgRpcConnectServer(PCSTR Options, const GUID* DesiredObject,
                    IUnknown** ClientObject);

DbgRpcConnection*
DbgRpcGetConnection(ULONG ThreadId);

#define DRPC_ERR(Args) g_NtDllCalls.DbgPrint Args

#if 0
#define DBG_RPC
#define DRPC(Args) g_NtDllCalls.DbgPrint Args
#else
#define DRPC(Args)
#endif

#if 0
#define DRPC_REF(Args) g_NtDllCalls.DbgPrint Args
#else
#define DRPC_REF(Args)
#endif

#endif // #ifndef __DBGRPC_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\portio.h ===
//----------------------------------------------------------------------------
//
// Non-network I/O support.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __PORTIO_H__
#define __PORTIO_H__

enum COM_PORT_TYPE
{
    COM_PORT_STANDARD,
    COM_PORT_MODEM,
    COM_PORT_PIPE,
    COM_PORT_SOCKET,
};

#define NET_COM_PORT(Type) \
    ((Type) == COM_PORT_PIPE || (Type) == COM_PORT_SOCKET)

typedef struct _COM_PORT_PARAMS
{
    COM_PORT_TYPE Type;
    PSTR PortName;
    ULONG BaudRate;
    ULONG Timeout;
    ULONG IpPort;
} COM_PORT_PARAMS, *PCOM_PORT_PARAMS;

HRESULT CreateOverlappedPair(LPOVERLAPPED Read, LPOVERLAPPED Write);
BOOL ComPortRead(HANDLE Port, COM_PORT_TYPE Type, ULONG Timeout,
                 PVOID Buffer, ULONG Len, PULONG Done,
                 LPOVERLAPPED Olap);
BOOL ComPortWrite(HANDLE Port, COM_PORT_TYPE Type,
                  PVOID Buffer, ULONG Len, PULONG Done,
                  LPOVERLAPPED Olap);
BOOL SetComPortName(PCSTR Name, PSTR Buffer, ULONG BufferSize);
ULONG SelectComPortBaud(ULONG NewRate);
HRESULT SetComPortBaud(HANDLE Port, ULONG NewRate, PULONG RateSet);
HRESULT OpenComPort(PCOM_PORT_PARAMS Params,
                    PHANDLE Handle, PULONG BaudSet);

HRESULT Create1394Channel(PSTR Symlink, ULONG Channel,
                          PSTR Name, ULONG NameSize, PHANDLE Handle);
HRESULT Open1394Channel(PSTR Symlink, ULONG Channel,
                        PSTR Name, ULONG NameSize, PHANDLE Handle);

HRESULT InitIpAddress(PCSTR MachineName, ULONG Port,
                      PSOCKADDR_STORAGE Addr, int* AddrLen);

#endif // #ifndef __PORTIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\portio.cpp ===
//----------------------------------------------------------------------------
//
// Non-network I/O support.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <ws2tcpip.h>

#ifndef _WIN32_WCE
#include <kdbg1394.h>
#include <ntdd1394.h>
#endif

//----------------------------------------------------------------------------
//
// COM.
//
//----------------------------------------------------------------------------

HRESULT
CreateOverlappedPair(LPOVERLAPPED Read, LPOVERLAPPED Write)
{
    ZeroMemory(Read, sizeof(*Read));
    ZeroMemory(Write, sizeof(*Write));
    
    Read->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Read->hEvent == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    Write->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Write->hEvent == NULL)
    {
        CloseHandle(Read->hEvent);
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

BOOL
ComPortRead(HANDLE Port, COM_PORT_TYPE Type, ULONG Timeout,
            PVOID Buffer, ULONG Len, PULONG Done,
            LPOVERLAPPED Olap)
{
    BOOL Status;

    if (Type == COM_PORT_SOCKET)
    {
#if defined(NT_NATIVE) || defined(_WIN32_WCE)
        return FALSE;
#else
        WSABUF Buf;
        DWORD Flags;

        // Handle timeouts first.
        if (Timeout != 0 && Timeout != INFINITE)
        {
            FD_SET FdSet;
            struct timeval TimeVal;

            FD_ZERO(&FdSet);
            FD_SET((SOCKET)Port, &FdSet);
            TimeVal.tv_sec = Timeout / 1000;
            TimeVal.tv_usec = (Timeout % 1000) * 1000;
            if (select(1, &FdSet, NULL, NULL, &TimeVal) < 1)
            {
                return FALSE;
            }
        }
        
        Buf.len = Len;
        Buf.buf = (PSTR)Buffer;
        Flags = 0;
        if (WSARecv((SOCKET)Port, &Buf, 1, Done, &Flags,
                    (LPWSAOVERLAPPED)Olap, NULL) != SOCKET_ERROR)
        {
            return TRUE;
        }
        if (WSAGetLastError() != WSA_IO_PENDING)
        {
            return FALSE;
        }
        return WSAGetOverlappedResult((SOCKET)Port, (LPWSAOVERLAPPED)Olap,
                                      Done, Timeout > 0 ? TRUE : FALSE,
                                      &Flags);
#endif // #if defined(NT_NATIVE) || defined(_WIN32_WCE)
    }
    
    Status = ReadFile(Port, Buffer, Len, Done, Olap);
    if (!Status)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            if (Type == COM_PORT_PIPE)
            {
                // We need to explicitly handle timeouts for
                // pipe reading.  First we wait for the I/O to
                // complete.  There's no need to check for
                // success or failure as I/O success will
                // be checked later.
                WaitForSingleObject(Olap->hEvent, Timeout);

                // Cancel any pending I/Os.  If the I/O already
                // completed this won't do anything.
                CancelIo(Port);

                // Now query the resulting I/O status.  If it was
                // cancelled this will return an error.
                Status = GetOverlappedResult(Port, Olap, Done, FALSE);
            }
            else
            {
                Status = GetOverlappedResult(Port, Olap, Done, TRUE);
            }
        }
        else if (Type != COM_PORT_PIPE)
        {
            DWORD TrashErr;
            COMSTAT TrashStat;
            
            // Device could be locked up.  Clear it just in case.
            ClearCommError(Port, &TrashErr, &TrashStat);
        }
    }

    return Status;
}

BOOL
ComPortWrite(HANDLE Port, COM_PORT_TYPE Type,
             PVOID Buffer, ULONG Len, PULONG Done,
             LPOVERLAPPED Olap)
{
    BOOL Status;

    if (Type == COM_PORT_SOCKET)
    {
#if defined(NT_NATIVE) || defined(_WIN32_WCE)
        return FALSE;
#else
        WSABUF Buf;
        DWORD Flags;

        Buf.len = Len;
        Buf.buf = (PSTR)Buffer;
        if (WSASend((SOCKET)Port, &Buf, 1, Done, 0,
                    (LPWSAOVERLAPPED)Olap, NULL) != SOCKET_ERROR)
        {
            return TRUE;
        }
        if (WSAGetLastError() != WSA_IO_PENDING)
        {
            return FALSE;
        }
        return WSAGetOverlappedResult((SOCKET)Port, (LPWSAOVERLAPPED)Olap,
                                      Done, TRUE, &Flags);
#endif // #if defined(NT_NATIVE) || defined(_WIN32_WCE)
    }
    
    Status = WriteFile(Port, Buffer, Len, Done, Olap);
    if (!Status)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            Status = GetOverlappedResult(Port, Olap, Done, TRUE);
        }
        else if (Type != COM_PORT_PIPE)
        {
            DWORD TrashErr;
            COMSTAT TrashStat;
            
            // Device could be locked up.  Clear it just in case.
            ClearCommError(Port, &TrashErr, &TrashStat);
        }
    }

    return Status;
}

BOOL
SetComPortName(PCSTR Name, PSTR Buffer, ULONG BufferSize)
{
    if (*Name == 'c' || *Name == 'C')
    {
        return
            CopyString(Buffer, "\\\\.\\", BufferSize) &&
            CatString(Buffer, Name, BufferSize);
    }
    else if (*Name >= '0' && *Name <= '9')
    {
        PCSTR Scan = Name + 1;
        
        while (*Scan >= '0' && *Scan <= '9')
        {
            Scan++;
        }
        if (*Scan == 0)
        {
            // The name was all digits so assume it's
            // a plain com port number.
#ifndef NT_NATIVE
            if (!CopyString(Buffer, "\\\\.\\com", BufferSize))
            {
                return FALSE;
            }
#else
            if (!CopyString(Buffer, "\\Device\\Serial", BufferSize))
            {
                return FALSE;
            }
#endif
            return CatString(Buffer, Name, BufferSize);
        }
        else
        {
            return CopyString(Buffer, Name, BufferSize);
        }
    }
    else
    {
        return CopyString(Buffer, Name, BufferSize);
    }
}

ULONG
SelectComPortBaud(ULONG NewRate)
{
#define NUM_RATES 4
    static DWORD s_Rates[NUM_RATES] = {19200, 38400, 57600, 115200};
    static DWORD s_CurRate = NUM_RATES;

    DWORD i;

    if (NewRate > 0)
    {
        for (i = 0; NewRate > s_Rates[i] && i < NUM_RATES - 1; i++)
        {
            // Empty.
        }
        s_CurRate = (NewRate < s_Rates[i]) ? i : i + 1;
    }
    else
    {
        s_CurRate++;
    }

    if (s_CurRate >= NUM_RATES)
    {
        s_CurRate = 0;
    }

    return s_Rates[s_CurRate];
}

HRESULT
SetComPortBaud(HANDLE Port, ULONG NewRate, PULONG RateSet)
{
    ULONG OldRate;
    DCB LocalDcb;

    if (Port == NULL)
    {
        return E_FAIL;
    }

    if (!GetCommState(Port, &LocalDcb))
    {
        return WIN32_LAST_STATUS();
    }

    OldRate = LocalDcb.BaudRate;

    if (!NewRate)
    {
        NewRate = SelectComPortBaud(OldRate);
    }

    LocalDcb.BaudRate = NewRate;
    LocalDcb.ByteSize = 8;
    LocalDcb.Parity = NOPARITY;
    LocalDcb.StopBits = ONESTOPBIT;
    LocalDcb.fDtrControl = DTR_CONTROL_ENABLE;
    LocalDcb.fRtsControl = RTS_CONTROL_ENABLE;
    LocalDcb.fBinary = TRUE;
    LocalDcb.fOutxCtsFlow = FALSE;
    LocalDcb.fOutxDsrFlow = FALSE;
    LocalDcb.fOutX = FALSE;
    LocalDcb.fInX = FALSE;

    if (!SetCommState(Port, &LocalDcb))
    {
        return WIN32_LAST_STATUS();
    }

    *RateSet = NewRate;
    return S_OK;
}

HRESULT
OpenComPort(PCOM_PORT_PARAMS Params,
            PHANDLE Handle, PULONG BaudSet)
{
    HRESULT Status;
    HANDLE ComHandle;

    if (Params->Type == COM_PORT_SOCKET)
    {
#if defined(NT_NATIVE) || defined(_WIN32_WCE)
        return E_NOTIMPL;
#else
        WSADATA WsData;
        SOCKET Sock;
        SOCKADDR_STORAGE Addr;
        int AddrLen;

        if (WSAStartup(MAKEWORD(2, 0), &WsData) != 0)
        {
            return E_FAIL;
        }

        if ((Status = InitIpAddress(Params->PortName, Params->IpPort,
                                    &Addr, &AddrLen)) != S_OK)
        {
            return Status;
        }
        
        Sock = WSASocket(Addr.ss_family, SOCK_STREAM, 0, NULL, 0,
                         WSA_FLAG_OVERLAPPED);
        if (Sock == INVALID_SOCKET)
        {
            return E_FAIL;
        }

        if (connect(Sock, (struct sockaddr *)&Addr, AddrLen) == SOCKET_ERROR)
        {
            closesocket(Sock);
            return E_FAIL;
        }

        int On = TRUE;
        setsockopt(Sock, IPPROTO_TCP, TCP_NODELAY,
                   (PSTR)&On, sizeof(On));

        *Handle = (HANDLE)Sock;
        return S_OK;
#endif // #if defined(NT_NATIVE) || defined(_WIN32_WCE)
    }
    
#ifndef NT_NATIVE
    ComHandle = CreateFile(Params->PortName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                           NULL);
#else
    ComHandle = NtNativeCreateFileA(Params->PortName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    OPEN_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_OVERLAPPED,
                                    NULL,
                                    FALSE);
#endif
    if (ComHandle == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    if (Params->Type == COM_PORT_PIPE)
    {
        *Handle = ComHandle;
        return S_OK;
    }
    
    if (!SetupComm(ComHandle, 4096, 4096))
    {
        CloseHandle(ComHandle);
        return WIN32_LAST_STATUS();
    }

    if ((Status = SetComPortBaud(ComHandle, Params->BaudRate,
                                 BaudSet)) != S_OK)
    {
        CloseHandle(ComHandle);
        return Status;
    }

    COMMTIMEOUTS To;
    
    if (Params->Timeout)
    {
        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0;
        To.ReadTotalTimeoutConstant = Params->Timeout;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = Params->Timeout;
    }
    else
    {
        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0xffffffff;
        To.ReadTotalTimeoutConstant = 0xffffffff;
        To.WriteTotalTimeoutMultiplier = 0xffffffff;
        To.WriteTotalTimeoutConstant = 0xffffffff;
    }

    if (!SetCommTimeouts(ComHandle, &To))
    {
        CloseHandle(ComHandle);
        return WIN32_LAST_STATUS();
    }

    *Handle = ComHandle;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// 1394.
//
//----------------------------------------------------------------------------

HRESULT
Create1394Channel(PSTR Symlink, ULONG Channel,
                  PSTR Name, ULONG NameSize, PHANDLE Handle)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    char BusName[] = "\\\\.\\1394BUS0";
    HANDLE hDevice;
    
    //
    // we need to make sure the 1394vdbg driver is up and loaded.
    // send the ADD_DEVICE ioctl to eject the VDO
    // Assume one 1394 host controller...
    //

    hDevice = CreateFile(BusName,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );

    if (hDevice != INVALID_HANDLE_VALUE)
    {
        PSTR DeviceId;
        ULONG ulStrLen;
        PIEEE1394_API_REQUEST pApiReq;
        PIEEE1394_VDEV_PNP_REQUEST pDevPnpReq;
        DWORD dwBytesRet;

        DRPC(("%s open sucessful\n", BusName));

        if (!_stricmp(Symlink, "channel"))
        {
            DeviceId = "VIRTUAL_HOST_DEBUGGER";
        }
        else
        {
            DeviceId = "HOST_DEBUGGER";
        }
        ulStrLen = strlen(DeviceId) + 1;
        
        pApiReq = (PIEEE1394_API_REQUEST)
            malloc(sizeof(IEEE1394_API_REQUEST) + ulStrLen);
        if (pApiReq == NULL)
        {
            CloseHandle(hDevice);
            return E_OUTOFMEMORY;
        }

        pApiReq->RequestNumber = IEEE1394_API_ADD_VIRTUAL_DEVICE;
        pApiReq->Flags = IEEE1394_REQUEST_FLAG_PERSISTENT |
            IEEE1394_REQUEST_FLAG_USE_LOCAL_HOST_EUI;

        pDevPnpReq = &pApiReq->u.RemoveVirtualDevice;

        pDevPnpReq->fulFlags = 0;

        pDevPnpReq->Reserved = 0;
        pDevPnpReq->InstanceId.QuadPart = 0;
        memcpy(&pDevPnpReq->DeviceId, DeviceId, ulStrLen);

        // Failure of this call is not fatal.
        DeviceIoControl( hDevice,
                         IOCTL_IEEE1394_API_REQUEST,
                         pApiReq,
                         sizeof(IEEE1394_API_REQUEST) + ulStrLen,
                         NULL,
                         0,
                         &dwBytesRet,
                         NULL
                         );

        if (pApiReq)
        {
            free(pApiReq);
        }
        
        CloseHandle(hDevice);
    }
    else
    {
        DRPC(("%s open failed\n", BusName));

        return WIN32_LAST_STATUS();
    }

    return Open1394Channel(Symlink, Channel, Name, NameSize, Handle);
#endif // #ifdef _WIN32_WCE
}

HRESULT
Open1394Channel(PSTR Symlink, ULONG Channel,
                PSTR Name, ULONG NameSize, PHANDLE Handle)
{
    if (_snprintf(Name, NameSize, "\\\\.\\DBG1394_%s%02d",
                  Symlink, Channel) < 0)
    {
        return E_INVALIDARG;
    }
    _strupr(Name);
    
    *Handle = CreateFile(Name,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );

    if (*Handle == INVALID_HANDLE_VALUE)
    {
        DRPC(("%s open failed\n", Name));

        *Handle = NULL;
        return WIN32_LAST_STATUS();
    }

    DRPC(("%s open Successful\n", Name));

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Sockets.
//
//----------------------------------------------------------------------------

HRESULT
InitIpAddress(PCSTR MachineName, ULONG Port,
              PSOCKADDR_STORAGE Addr, int* AddrLen)
{
#ifdef NT_NATIVE
    return E_NOTIMPL;
#else
    ADDRINFO *Info;
    int Err;

    if (Port)
    {
        ZeroMemory(Addr, sizeof(*Addr));
    }
    else
    {
        // If a port wasn't given save the existing
        // one so it doesn't get lost when we update
        // the address.
        Port = ntohs(SS_PORT(Addr));
    }
    
    // Skip leading \\ if they were given.
    if (MachineName[0] == '\\' && MachineName[1] == '\\')
    {
        MachineName += 2;
    }

    //
    // Note that this file has a problem in some cases since when a
    // hostname is specified, it throws away all the addresses after
    // the first one.  Instead, when connecting, each should be tried
    // in order until one succeeds.
    //

    if ((Err = getaddrinfo(MachineName, NULL, NULL, &Info)) != NO_ERROR)
    {
        return HRESULT_FROM_WIN32(Err);
    }

    CopyMemory(Addr, Info->ai_addr, Info->ai_addrlen);
    *AddrLen = Info->ai_addrlen;
    freeaddrinfo(Info);

    // Restore original port or put in passed-in port.
    SS_PORT(Addr) = htons((USHORT)Port);
    
    return S_OK;
#endif // #ifdef NT_NATIVE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\schan.cpp ===
//----------------------------------------------------------------------------
//
// Secure channel support.
// Code lifted from the SDK sample security\ssl.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifndef _WIN32_WCE

HMODULE g_hSecurity;
SecurityFunctionTable g_SecurityFunc;

HCERTSTORE g_hMyCertStore;

enum
{
    SEQ_INTERNAL = 0xffffff00
};

//----------------------------------------------------------------------------
//
// Basic schannel support functions.
//
//----------------------------------------------------------------------------

void
DbgDumpBuffers(PCSTR Name, SecBufferDesc* Desc)
{
#if 0
    ULONG i;
    
    g_NtDllCalls.DbgPrint("%s desc %p has %d buffers\n",
                          Name, Desc, Desc->cBuffers);
    for (i = 0; i < Desc->cBuffers; i++)
    {
        g_NtDllCalls.DbgPrint("  type %d, %X bytes at %p\n",
                              Desc->pBuffers[i].BufferType,
                              Desc->pBuffers[i].cbBuffer,
                              Desc->pBuffers[i].pvBuffer);
    }
#endif
}

#if 0
#define DSCHAN(Args) g_NtDllCalls.DbgPrint Args
#define DumpBuffers(Name, Desc) DbgDumpBuffers(Name, Desc)
#else
#define DSCHAN(Args)
#define DumpBuffers(Name, Desc)
#endif

#if 0
#define DSCHAN_IO(Args) g_NtDllCalls.DbgPrint Args
#define DumpBuffersIo(Name, Desc) DbgDumpBuffers(Name, Desc)
#else
#define DSCHAN_IO(Args)
#define DumpBuffersIo(Name, Desc)
#endif

HRESULT
LoadSecurityLibrary(void)
{
    HRESULT Status;

    if ((Status = InitDynamicCalls(&g_Crypt32CallsDesc)) != S_OK)
    {
        return Status;
    }
    
    PSecurityFunctionTable  pSecurityFunc;
    INIT_SECURITY_INTERFACE pInitSecurityInterface;

    if (g_hSecurity != NULL)
    {
        // Already loaded.
        return S_OK;
    }

    if (g_Crypt32Calls.CertOpenStore == NULL)
    {
        // Unable to load crypt32.dll.
        return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
    }
    
    g_hSecurity = LoadLibrary("security.dll");
    if (g_hSecurity == NULL)
    {
        goto EH_Fail;
    }

    pInitSecurityInterface = (INIT_SECURITY_INTERFACE)
        GetProcAddress(g_hSecurity, "InitSecurityInterfaceA");
    if (pInitSecurityInterface == NULL)
    {
        goto EH_Dll;
    }

    pSecurityFunc = pInitSecurityInterface();
    if (pSecurityFunc == NULL)
    {
        goto EH_Dll;
    }

    memcpy(&g_SecurityFunc, pSecurityFunc, sizeof(g_SecurityFunc));

    return S_OK;

 EH_Dll:
    FreeLibrary(g_hSecurity);
    g_hSecurity = NULL;
 EH_Fail:
    return WIN32_LAST_STATUS();
}

HRESULT
CreateCredentials(LPSTR pszUserName,
                  BOOL fMachineStore,
                  BOOL Server,
                  ULONG dwProtocol,
                  SCHANNEL_CRED* ScCreds,
                  PCredHandle phCreds)
{
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    PCCERT_CONTEXT  pCertContext = NULL;

    // Open the "MY" certificate store.
    if (g_hMyCertStore == NULL)
    {
        if (fMachineStore)
        {
            g_hMyCertStore = g_Crypt32Calls.
                CertOpenStore(CERT_STORE_PROV_SYSTEM,
                              X509_ASN_ENCODING,
                              0,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              L"MY");
        }
        else
        {
            g_hMyCertStore = g_Crypt32Calls.
                CertOpenSystemStore(0, "MY");
        }

        if (!g_hMyCertStore)
        {
            Status = WIN32_LAST_STATUS();
            goto Exit;
        }
    }

    //
    // If a user name is specified, then attempt to find a client
    // certificate. Otherwise, just create a NULL credential.
    //

    if (pszUserName != NULL && *pszUserName)
    {
        // Find certificate. Note that this sample just searches for a 
        // certificate that contains the user name somewhere in the subject
        // name.  A real application should be a bit less casual.
        pCertContext = g_Crypt32Calls.
            CertFindCertificateInStore(g_hMyCertStore, 
                                       X509_ASN_ENCODING, 
                                       0,
                                       CERT_FIND_SUBJECT_STR_A,
                                       pszUserName,
                                       NULL);
        if (pCertContext == NULL)
        {
            Status = WIN32_LAST_STATUS();
            goto Exit;
        }
    }


    //
    // Build Schannel credential structure. Currently, this sample only
    // specifies the protocol to be used (and optionally the certificate, 
    // of course). Real applications may wish to specify other parameters 
    // as well.
    //

    ZeroMemory(ScCreds, sizeof(*ScCreds));

    ScCreds->dwVersion = SCHANNEL_CRED_VERSION;

    if (pCertContext != NULL)
    {
        ScCreds->cCreds = 1;
        ScCreds->paCred = &pCertContext;
    }

    ScCreds->grbitEnabledProtocols = dwProtocol;

    if (!Server)
    {
        if (pCertContext != NULL)
        {
            ScCreds->dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
        }
        else
        {
            ScCreds->dwFlags |= SCH_CRED_USE_DEFAULT_CREDS;
        }
        ScCreds->dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
    }


    //
    // Create an SSPI credential.
    //

    //
    // NOTE: In theory, an application could enumerate the security packages 
    // until it finds one with attributes it likes. Some applications 
    // (such as IIS) enumerate the packages and call AcquireCredentialsHandle 
    // on each until it finds one that accepts the SCHANNEL_CRED structure. 
    // If an application has its heart set on using SSL, like this sample
    // does, then just hardcoding the UNISP_NAME package name when calling 
    // AcquireCredentialsHandle is not a bad thing.
    //

    Status = g_SecurityFunc.AcquireCredentialsHandle(
                        NULL,                   // Name of principal
                        UNISP_NAME_A,           // Name of package
                        Server ?                // Flags indicating use
                        SECPKG_CRED_INBOUND :
                        SECPKG_CRED_OUTBOUND,
                        NULL,                   // Pointer to logon ID
                        ScCreds,                // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        phCreds,                // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)

    //
    // Free the certificate context. Schannel has already made its own copy.
    //

    if (pCertContext)
    {
        g_Crypt32Calls.CertFreeCertificateContext(pCertContext);
    }

 Exit:
    DSCHAN(("CreateCredentials returns %X\n", Status));
    return Status;
}

HRESULT
VerifyRemoteCertificate(PCtxtHandle Context,
                        PSTR pszServerName,
                        DWORD dwCertFlags)
{
    SSL_EXTRA_CERT_CHAIN_POLICY_PARA SslPara;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChain = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HRESULT Status;
    PWSTR pwszServerName;
    DWORD cchServerName;
    
    // Read the remote certificate.
    if ((Status = g_SecurityFunc.
         QueryContextAttributes(Context,
                                SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                &pCert)) != S_OK)
    {
        goto Exit;
    }

    if (pCert == NULL)
    {
        Status = SEC_E_WRONG_PRINCIPAL;
        goto EH_Cert;
    }

    if (pszServerName != NULL && *pszServerName)
    {
        //
        // Convert server name to unicode.
        //

        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName,
                                            -1, NULL, 0);
        pwszServerName = (PWSTR)
            LocalAlloc(LMEM_FIXED, cchServerName * sizeof(WCHAR));
        if (pwszServerName == NULL)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto EH_Cert;
        }
        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName,
                                            -1, pwszServerName, cchServerName);
        if (cchServerName == 0)
        {
            Status = SEC_E_WRONG_PRINCIPAL;
            goto EH_Name;
        }
    }
    else
    {
        pwszServerName = NULL;
    }

    //
    // Build certificate chain.
    //

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    if (!g_Crypt32Calls.CertGetCertificateChain(NULL,
                                                pCert,
                                                NULL,
                                                pCert->hCertStore,
                                                &ChainPara,
                                                0,
                                                NULL,
                                                &pChain))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Name;
    }


    //
    // Validate certificate chain.
    // 

    ZeroMemory(&SslPara, sizeof(SslPara));
    SslPara.cbStruct           = sizeof(SslPara);
    SslPara.dwAuthType         = pwszServerName == NULL ?
        AUTHTYPE_CLIENT : AUTHTYPE_SERVER;
    SslPara.fdwChecks          = dwCertFlags;
    SslPara.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &SslPara;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if (!g_Crypt32Calls.CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_SSL,
                                                         pChain,
                                                         &PolicyPara,
                                                         &PolicyStatus))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Chain;
    }

    if (PolicyStatus.dwError)
    {
        Status = PolicyStatus.dwError;
    }
    else
    {
        Status = S_OK;
    }

 EH_Chain:
    g_Crypt32Calls.CertFreeCertificateChain(pChain);
 EH_Name:
    if (pwszServerName != NULL)
    {
        LocalFree(pwszServerName);
    }
 EH_Cert:
    g_Crypt32Calls.CertFreeCertificateContext(pCert);
 Exit:
    DSCHAN(("VerifyRemoteCertificate returns %X\n", Status));
    return Status;
}

//----------------------------------------------------------------------------
//
// Schannel wrapper transport.
//
//----------------------------------------------------------------------------

#define SecHandleIsValid(Handle) \
    ((Handle)->dwLower != -1 || (Handle)->dwUpper != -1)

DbgRpcSecureChannelTransport::
DbgRpcSecureChannelTransport(ULONG ThisTransport,
                             ULONG BaseTransport)
{
    m_Name = g_DbgRpcTransportNames[ThisTransport];
    m_ThisTransport = ThisTransport;
    m_BaseTransport = BaseTransport;
    m_Stream = NULL;
    SecInvalidateHandle(&m_Creds);
    m_OwnCreds = FALSE;
    SecInvalidateHandle(&m_Context);
    m_OwnContext = FALSE;
    m_BufferUsed = 0;
    m_Server = FALSE;
}

DbgRpcSecureChannelTransport::~DbgRpcSecureChannelTransport(void)
{
    if (SecHandleIsValid(&m_Context))
    {
        if (m_Server)
        {
            DisconnectFromClient();
        }
        else
        {
            DisconnectFromServer();
        }
    }
    
    delete m_Stream;
    if (m_OwnContext && SecHandleIsValid(&m_Context))
    {
        g_SecurityFunc.DeleteSecurityContext(&m_Context);
    }
    if (m_OwnCreds && SecHandleIsValid(&m_Creds))
    {
        g_SecurityFunc.FreeCredentialsHandle(&m_Creds);
    }
}

ULONG
DbgRpcSecureChannelTransport::GetNumberParameters(void)
{
    return 2 + (m_Stream != NULL ? m_Stream->GetNumberParameters() : 0);
}

void
DbgRpcSecureChannelTransport::GetParameter(ULONG Index,
                                           PSTR Name, ULONG NameSize,
                                           PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_Protocol)
        {
            CopyString(Name, "Proto", NameSize);
            switch(m_Protocol)
            {
            case SP_PROT_PCT1:
                CopyString(Name, "PCT1", NameSize);
                break;
            case SP_PROT_SSL2:
                CopyString(Name, "SSL2", NameSize);
                break;
            case SP_PROT_SSL3:
                CopyString(Name, "SSL3", NameSize);
                break;
            case SP_PROT_TLS1:
                CopyString(Name, "TLS1", NameSize);
                break;
            }
        }
        break;
    case 1:
        if (m_User[0])
        {
            CopyString(Name, m_MachineStore ? "MachUser" : "CertUser",
                       NameSize);
            CopyString(Value, m_User, ValueSize);
        }
        break;
    default:
        if (m_Stream != NULL)
        {
            m_Stream->GetParameter(Index - 2,
                                   Name, NameSize, Value, ValueSize);
        }
        break;
    }
}

void
DbgRpcSecureChannelTransport::ResetParameters(void)
{
    m_Protocol = 0;
    m_User[0] = 0;
    m_MachineStore = FALSE;

    if (m_Stream == NULL)
    {
        m_Stream = DbgRpcNewTransport(m_BaseTransport);
    }
    
    if (m_Stream != NULL)
    {
        m_Stream->ResetParameters();
    }
}

BOOL
DbgRpcSecureChannelTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (m_Stream == NULL)
    {
        // Force all initialization to fail.
        return FALSE;
    }
    
    if (!_stricmp(Name, "proto"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the protocol name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        if (!_stricmp(Value, "pct1"))
        {
            m_Protocol = SP_PROT_PCT1;
        }
        else if (!_stricmp(Value, "ssl2"))
        {
            m_Protocol = SP_PROT_SSL2;
        }
        else if (!_stricmp(Value, "ssl3"))
        {
            m_Protocol = SP_PROT_SSL3;
        }
        else if (!_stricmp(Value, "tls1"))
        {
            m_Protocol = SP_PROT_TLS1;
        }
        else
        {
            DbgRpcError("%s parameters: unknown protocol '%s'\n", Value,
                        m_Name);
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "machuser"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the user name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        if (!CopyString(m_User, Value, DIMA(m_User)))
        {
            return FALSE;
        }
        m_MachineStore = TRUE;
    }
    else if (!_stricmp(Name, "certuser"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the user name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        if (!CopyString(m_User, Value, DIMA(m_User)))
        {
            return FALSE;
        }
        m_MachineStore = FALSE;
    }
    else
    {
        if (!m_Stream->SetParameter(Name, Value))
        {
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcSecureChannelTransport::Clone(void)
{
    DbgRpcTransport* Stream = m_Stream->Clone();
    if (Stream == NULL)
    {
        return NULL;
    }
    DbgRpcSecureChannelTransport* Trans =
        new DbgRpcSecureChannelTransport(m_ThisTransport, m_BaseTransport);
    if (Trans != NULL)
    {
        Trans->m_Stream = Stream;
        Trans->m_Creds = m_Creds;
        Trans->m_OwnCreds = FALSE;
        Trans->m_Context = m_Context;
        Trans->m_OwnContext = FALSE;
        Trans->m_Protocol = m_Protocol;
        strcpy(Trans->m_User, m_User);
        Trans->m_MachineStore = m_MachineStore;
        Trans->m_Sizes = m_Sizes;
        Trans->m_MaxChunk = m_MaxChunk;
        Trans->m_Server = m_Server;
    }
    else
    {
        delete Stream;
    }
    return Trans;
}

HRESULT
DbgRpcSecureChannelTransport::CreateServer(void)
{
    HRESULT Status;

    if ((Status = LoadSecurityLibrary()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateCredentials(m_User, m_MachineStore, TRUE,
                                    m_Protocol, &m_ScCreds, &m_Creds)) != S_OK)
    {
        return Status;
    }
    m_OwnCreds = TRUE;

    if ((Status = m_Stream->CreateServer()) != S_OK)
    {
        return Status;
    }

    m_Server = TRUE;
    return S_OK;
}

HRESULT
DbgRpcSecureChannelTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                               PSTR Identity,
                                               ULONG IdentitySize)
{
    HRESULT Status;
    DbgRpcTransport* Stream;
    
    if ((Status = m_Stream->
         AcceptConnection(&Stream, Identity, IdentitySize)) != S_OK)
    {
        return Status;
    }
    DbgRpcSecureChannelTransport* Trans =
        new DbgRpcSecureChannelTransport(m_ThisTransport, m_BaseTransport);
    if (Trans == NULL)
    {
        delete Stream;
        return E_OUTOFMEMORY;
    }
    Trans->m_Stream = Stream;
    Trans->m_Creds = m_Creds;
    Trans->m_OwnCreds = FALSE;
    Trans->m_Server = TRUE;

    if ((Status = Trans->AuthenticateClientConnection()) != S_OK)
    {
        goto EH_Trans;
    }

    if ((Status = Trans->GetSizes()) != S_OK)
    {
        goto EH_Trans;
    }
    
    // Attempt to validate client certificate.
    if ((Status = VerifyRemoteCertificate(&Trans->m_Context, NULL, 0)) != S_OK)
    {
        goto EH_Trans;
    }

    *ClientTrans = Trans;
    return S_OK;

 EH_Trans:
    delete Trans;
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::ConnectServer(void)
{
    HRESULT Status = m_Stream->ConnectServer();
    if (Status != S_OK)
    {
        return Status;
    }

    if ((Status = LoadSecurityLibrary()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateCredentials(m_User, m_MachineStore, FALSE,
                                    m_Protocol, &m_ScCreds, &m_Creds)) != S_OK)
    {
        return Status;
    }
    m_OwnCreds = TRUE;

    if ((Status = InitiateServerConnection(m_Stream->m_ServerName)) != S_OK)
    {
        return Status;
    }

    if ((Status = AuthenticateServerConnection()) != S_OK)
    {
        return Status;
    }

    if ((Status = GetSizes()) != S_OK)
    {
        return Status;
    }
    
    // Attempt to validate server certificate.
    if ((Status = VerifyRemoteCertificate(&m_Context,
                                          m_Stream->m_ServerName, 0)) != S_OK)
    {
        // If this fails with CERT_E_CN_NO_MATCH it's most
        // likely that the server name wasn't given as a fully
        // qualified machine name.  We may just want to ignore that error.
        return Status;
    }

    return S_OK;
}

ULONG
DbgRpcSecureChannelTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    SecBufferDesc Message;
    SecBuffer Buffers[4];
    DWORD Status;
    ULONG Complete;

    DSCHAN_IO(("Start read(%X) with %X bytes cached\n",
               Len, m_BufferUsed));
    
    //
    // Initialize security buffer structs
    //

    Message.ulVersion = SECBUFFER_VERSION;
    Message.cBuffers = 4;
    Message.pBuffers = Buffers;

    //
    // Receive the data from the client.
    //

    Complete = 0;

    while (Complete < Len)
    {
        do
        {
            // Pass in the data we have so far.
            Buffers[0].pvBuffer = m_Buffer;
            Buffers[0].cbBuffer = m_BufferUsed;
            Buffers[0].BufferType = SECBUFFER_DATA;

            // Provide extra buffers for header, trailer
            // and possibly extra data.
            Buffers[1].BufferType = SECBUFFER_EMPTY;
            Buffers[2].BufferType = SECBUFFER_EMPTY;
            Buffers[3].BufferType = SECBUFFER_EMPTY;

            Status = g_SecurityFunc.DecryptMessage(&m_Context, &Message,
                                                   Seq, NULL);
            
            DSCHAN_IO(("Read DecryptMessage on %X bytes returns %X\n",
                       m_BufferUsed, Status));
            DumpBuffersIo("Read", &Message);
            
            if (Status == SEC_E_INCOMPLETE_MESSAGE)
            {
                DSCHAN_IO(("  Missing %X bytes\n", Buffers[1].cbBuffer));

                ULONG Read = StreamRead(Seq, m_Buffer + m_BufferUsed,
                                        sizeof(m_Buffer) - m_BufferUsed);
                if (Read == 0)
                {
                    return Complete;
                }

                m_BufferUsed += Read;
            }
            else if (Status == SEC_I_RENEGOTIATE)
            {
                // The server wants to perform another handshake
                // sequence.

                if ((Status = AuthenticateServerConnection()) != S_OK)
                {
                    break;
                }
            }
        }
        while (Status == SEC_E_INCOMPLETE_MESSAGE);

        if (Status != S_OK)
        {
            break;
        }

        // Buffers 0,1,2 should be header, data, trailer.
        DBG_ASSERT(Buffers[1].BufferType == SECBUFFER_DATA);

        DSCHAN_IO(("  %X bytes of %X read\n",
                   Buffers[1].cbBuffer, Len));
        
        memcpy((PUCHAR)Buffer + Complete,
               Buffers[1].pvBuffer, Buffers[1].cbBuffer);
        Complete += Buffers[1].cbBuffer;

        // Check for extra data in buffer 3.
        if (Buffers[3].BufferType == SECBUFFER_EXTRA)
        {
            DSCHAN_IO(("  %X bytes extra\n"));
            
            memmove(m_Buffer, Buffers[3].pvBuffer, Buffers[3].cbBuffer);
            m_BufferUsed = Buffers[3].cbBuffer;
        }
        else
        {
            m_BufferUsed = 0;
        }
    }

    DSCHAN_IO(("  Read returns %X bytes\n", Complete));
    return Complete;
}

ULONG
DbgRpcSecureChannelTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    SecBufferDesc Message;
    SecBuffer Buffers[3];
    DWORD Status;
    ULONG Complete;

    DSCHAN_IO(("Start write(%X) with %X bytes cached\n",
               Len, m_BufferUsed));
    
    Message.ulVersion = SECBUFFER_VERSION;
    Message.cBuffers = 3;
    Message.pBuffers = Buffers;

    Complete = 0;
    
    while (Complete < Len)
    {
        ULONG Chunk;
        
        //
        // Set up header, data and trailer buffers so
        // that EncryptMessage has room for everything
        // in one contiguous buffer.
        //

        Buffers[0].pvBuffer = m_Buffer + m_BufferUsed;
        Buffers[0].cbBuffer = m_Sizes.cbHeader;
        Buffers[0].BufferType = SECBUFFER_STREAM_HEADER;

        //
        // Data is encrypted in-place so copy data
        // from the user's buffer into the working buffer.
        // Part of the working buffer may be taken up
        // by queued data so work with what's left.
        //
        
        if (Len > m_MaxChunk - m_BufferUsed)
        {
            Chunk = m_MaxChunk - m_BufferUsed;
        }
        else
        {
            Chunk = Len;
        }

        DSCHAN_IO(("  write %X bytes of %X\n", Chunk, Len));
        
        Buffers[1].pvBuffer =
            (PUCHAR)Buffers[0].pvBuffer + Buffers[0].cbBuffer;
        Buffers[1].cbBuffer = Chunk;
        Buffers[1].BufferType = SECBUFFER_DATA;
        memcpy(Buffers[1].pvBuffer, (PUCHAR)Buffer + Complete, Chunk);
    
        Buffers[2].pvBuffer =
            (PUCHAR)Buffers[1].pvBuffer + Buffers[1].cbBuffer;
        Buffers[2].cbBuffer = m_Sizes.cbTrailer;
        Buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;

        Status = g_SecurityFunc.EncryptMessage(&m_Context, 0, &Message, Seq);
        if (Status != S_OK)
        {
            break;
        }

        DumpBuffersIo("Write encrypt", &Message);
        
        ULONG Total, Written;
        
        Total = Buffers[0].cbBuffer + Buffers[1].cbBuffer +
            Buffers[2].cbBuffer;
        Written = StreamWrite(Seq, Buffers[0].pvBuffer, Total);
        if (Written != Total)
        {
            break;
        }

        Complete += Chunk;
    }

    DSCHAN_IO(("  Write returns %X bytes\n", Complete));
    return Complete;
}

HRESULT
DbgRpcSecureChannelTransport::GetSizes(void)
{
    HRESULT Status;
    
    //
    // Find out how big the header will be:
    //
    
    if ((Status = g_SecurityFunc.
         QueryContextAttributes(&m_Context, SECPKG_ATTR_STREAM_SIZES,
                                &m_Sizes)) != S_OK)
    {
        return Status;
    }

    // Compute the largest chunk that can be encrypted at
    // once in the transport's data buffer.
    m_MaxChunk = sizeof(m_Buffer) - (m_Sizes.cbHeader + m_Sizes.cbTrailer);
    if (m_MaxChunk > m_Sizes.cbMaximumMessage)
    {
        m_MaxChunk = m_Sizes.cbMaximumMessage;
    }

    return S_OK;
}
    
HRESULT
DbgRpcSecureChannelTransport::AuthenticateClientConnection(void)
{
    TimeStamp            tsExpiry;
    SECURITY_STATUS      Status;
    SecBufferDesc        InBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    SecBuffer            OutBuffers[1];
    BOOL                 fInitContext = TRUE;
    DWORD                dwSSPIFlags, dwSSPIOutFlags;
    ULONG                Seq;

    Status = SEC_E_SECPKG_NOT_FOUND; //default error if we run out of packages

    dwSSPIFlags = ASC_REQ_SEQUENCE_DETECT     |
                  ASC_REQ_REPLAY_DETECT       |
                  ASC_REQ_CONFIDENTIALITY     |
                  ASC_REQ_EXTENDED_ERROR      |
                  ASC_REQ_ALLOCATE_MEMORY     |
                  ASC_REQ_STREAM              |
                  ASC_REQ_MUTUAL_AUTH;

    //
    // Set buffers for AcceptSecurityContext call
    //

    InBuffer.cBuffers = 2;
    InBuffer.pBuffers = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = SEC_I_CONTINUE_NEEDED;
    m_BufferUsed = 0;

    while ( Status == SEC_I_CONTINUE_NEEDED ||
            Status == SEC_E_INCOMPLETE_MESSAGE ||
            Status == SEC_I_INCOMPLETE_CREDENTIALS) 
    {
        if (0 == m_BufferUsed || Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            ULONG Read = StreamRead(SEQ_INTERNAL, m_Buffer + m_BufferUsed,
                                    sizeof(m_Buffer) - m_BufferUsed);
            if (Read == 0)
            {
                Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
                goto Exit;
            }
            else
            {
                m_BufferUsed += Read;
            }
        }


        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        InBuffers[0].pvBuffer = m_Buffer;
        InBuffers[0].cbBuffer = m_BufferUsed;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;


        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        OutBuffers[0].pvBuffer   = NULL;
        OutBuffers[0].cbBuffer   = 0;
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;

        Status = g_SecurityFunc.AcceptSecurityContext(
                        &m_Creds,
                        (fInitContext ? NULL : &m_Context),
                        &InBuffer,
                        dwSSPIFlags,
                        SECURITY_NATIVE_DREP,
                        (fInitContext ? &m_Context : NULL),
                        &OutBuffer,
                        &dwSSPIOutFlags,
                        &tsExpiry);

        DSCHAN(("ASC on %X bytes returns %X\n",
                m_BufferUsed, Status));
        DumpBuffers("ASC in", &InBuffer);
        DumpBuffers("ASC out", &OutBuffer);

        if (SUCCEEDED(Status))
        {
            fInitContext = FALSE;
            m_OwnContext = TRUE;
        }

        if ( Status == SEC_E_OK ||
             Status == SEC_I_CONTINUE_NEEDED ||
             (FAILED(Status) &&
              (0 != (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR))))
        {
            if  (OutBuffers[0].cbBuffer != 0    &&
                 OutBuffers[0].pvBuffer != NULL )
            {
                ULONG Written;
                
                DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
                //
                // Send response to server if there is one
                //
                Written = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                                      OutBuffers[0].cbBuffer);

                g_SecurityFunc.FreeContextBuffer( OutBuffers[0].pvBuffer );
                OutBuffers[0].pvBuffer = NULL;

                if (Written != OutBuffers[0].cbBuffer)
                {
                    Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
                    goto Exit;
                }
            }
        }


        if ( Status == SEC_E_OK )
        {
            if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
            {
                DSCHAN_IO(("  ASC returns with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                m_BufferUsed = 0;
            }

            goto Exit;
        }
        else if (FAILED(Status) && (Status != SEC_E_INCOMPLETE_MESSAGE))
        {
            goto Exit;
        }

        if ( Status != SEC_E_INCOMPLETE_MESSAGE &&
             Status != SEC_I_INCOMPLETE_CREDENTIALS)
        {
            if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
            {
                DSCHAN_IO(("  ASC loops with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                //
                // prepare for next receive
                //

                m_BufferUsed = 0;
            }
        }
    }

 Exit:
    DSCHAN(("AuthClient returns %X\n", Status));
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::InitiateServerConnection(LPSTR pszServerName)
{
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    DWORD           cbData;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM            |
                  ISC_REQ_MUTUAL_AUTH;

    //
    //  Initiate a ClientHello message and generate a token.
    //

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.InitializeSecurityContextA(
                    &m_Creds,
                    NULL,
                    pszServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &m_Context,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);

    DSCHAN(("First ISC returns %X\n", Status));
    DumpBuffers("First ISC out", &OutBuffer);
            
    if (Status != SEC_I_CONTINUE_NEEDED)
    {
        goto Exit;
    }

    m_OwnContext = TRUE;
    
    // Send response to server if there is one.
    if (OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
    {
        DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
        cbData = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer);
        if(cbData == 0)
        {
            g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
            if (m_OwnContext)
            {
                g_SecurityFunc.DeleteSecurityContext(&m_Context);
                SecInvalidateHandle(&m_Context);
            }
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto Exit;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }

    Status = S_OK;

 Exit:
    DSCHAN(("InitServer returns %X\n", Status));
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::AuthenticateServerConnection(void)
{
    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[2];
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    DWORD           cbData;
    ULONG           ReadNeeded;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    m_BufferUsed = 0;
    ReadNeeded = 1;


    // 
    // Loop until the handshake is finished or an error occurs.
    //

    Status = SEC_I_CONTINUE_NEEDED;

    while(Status == SEC_I_CONTINUE_NEEDED        ||
          Status == SEC_E_INCOMPLETE_MESSAGE     ||
          Status == SEC_I_INCOMPLETE_CREDENTIALS) 
    {

        //
        // Read data from server.
        //

        if (0 == m_BufferUsed || Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            if (ReadNeeded > 0)
            {
                cbData = StreamRead(SEQ_INTERNAL, m_Buffer + m_BufferUsed,
                                    sizeof(m_Buffer) - m_BufferUsed);
                if(cbData == 0)
                {
                    Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
                    break;
                }

                m_BufferUsed += cbData;
            }
            else
            {
                ReadNeeded = 1;
            }
        }


        //
        // Set up the input buffers. Buffer 0 is used to pass in data
        // received from the server. Schannel will consume some or all
        // of this. Leftover data (if any) will be placed in buffer 1 and
        // given a buffer type of SECBUFFER_EXTRA.
        //

        InBuffers[0].pvBuffer   = m_Buffer;
        InBuffers[0].cbBuffer   = m_BufferUsed;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers       = 2;
        InBuffer.pBuffers       = InBuffers;
        InBuffer.ulVersion      = SECBUFFER_VERSION;

        //
        // Set up the output buffers. These are initialized to NULL
        // so as to make it less likely we'll attempt to free random
        // garbage later.
        //

        OutBuffers[0].pvBuffer  = NULL;
        OutBuffers[0].BufferType= SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer  = 0;

        OutBuffer.cBuffers      = 1;
        OutBuffer.pBuffers      = OutBuffers;
        OutBuffer.ulVersion     = SECBUFFER_VERSION;

        //
        // Call InitializeSecurityContext.
        //

        Status = g_SecurityFunc.InitializeSecurityContextA(
                                          &m_Creds,
                                          &m_Context,
                                          NULL,
                                          dwSSPIFlags,
                                          0,
                                          SECURITY_NATIVE_DREP,
                                          &InBuffer,
                                          0,
                                          NULL,
                                          &OutBuffer,
                                          &dwSSPIOutFlags,
                                          &tsExpiry);

        DSCHAN(("ISC on %X bytes returns %X\n",
                m_BufferUsed, Status));
        DumpBuffers("ISC in", &InBuffer);
        DumpBuffers("ISC out", &OutBuffer);
        
        //
        // If InitializeSecurityContext was successful (or if the error was 
        // one of the special extended ones), send the contends of the output
        // buffer to the server.
        //

        if(Status == SEC_E_OK                ||
           Status == SEC_I_CONTINUE_NEEDED   ||
           FAILED(Status) && (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR))
        {
            if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
            {
                DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
                cbData = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                                     OutBuffers[0].cbBuffer);
                if(cbData == 0)
                {
                    g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
                    if (m_OwnContext)
                    {
                        g_SecurityFunc.DeleteSecurityContext(&m_Context);
                        SecInvalidateHandle(&m_Context);
                    }
                    Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
                    goto Exit;
                }

                // Free output buffer.
                g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
                OutBuffers[0].pvBuffer = NULL;
            }
        }


        //
        // If InitializeSecurityContext returned SEC_E_INCOMPLETE_MESSAGE,
        // then we need to read more data from the server and try again.
        //

        if(Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            continue;
        }


        //
        // If InitializeSecurityContext returned SEC_E_OK, then the 
        // handshake completed successfully.
        //

        if(Status == SEC_E_OK)
        {
            //
            // If the "extra" buffer contains data, this is encrypted application
            // protocol layer stuff. It needs to be saved. The application layer
            // will later decrypt it with DecryptMessage.
            //

            if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
            {
                DSCHAN_IO(("  ISC returns with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                m_BufferUsed = 0;
            }

            //
            // Bail out to quit
            //

            break;
        }


        //
        // Check for fatal error.
        //

        if(FAILED(Status))
        {
            break;
        }


        //
        // If InitializeSecurityContext returned SEC_I_INCOMPLETE_CREDENTIALS,
        // then the server just requested client authentication. 
        //

        if(Status == SEC_I_INCOMPLETE_CREDENTIALS)
        {
            DSCHAN(("Get new client credentials\n"));
                   
            //
            // Display trusted issuers info. 
            //

            GetNewClientCredentials();

            //
            // Now would be a good time perhaps to prompt the user to select
            // a client certificate and obtain a new credential handle, 
            // but I don't have the energy nor inclination.
            //
            // As this is currently written, Schannel will send a "no 
            // certificate" alert to the server in place of a certificate. 
            // The server might be cool with this, or it might drop the 
            // connection.
            // 

            // Go around again.
            ReadNeeded = 0;
            Status = SEC_I_CONTINUE_NEEDED;
            continue;
        }


        //
        // Copy any leftover data from the "extra" buffer, and go around
        // again.
        //

        if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
        {
            DSCHAN(("  ISC loops with %X extra bytes\n",
                    InBuffers[1].cbBuffer));
            
            memmove(m_Buffer,
                    m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                    InBuffers[1].cbBuffer);
            m_BufferUsed = InBuffers[1].cbBuffer;
        }
        else
        {
            m_BufferUsed = 0;
        }
    }

    // Delete the security context in the case of a fatal error.
    if(FAILED(Status))
    {
        if (m_OwnContext)
        {
            g_SecurityFunc.DeleteSecurityContext(&m_Context);
            SecInvalidateHandle(&m_Context);
        }
    }

 Exit:
    DSCHAN(("AuthServer returns %X\n", Status));
    return Status;
}

void
DbgRpcSecureChannelTransport::GetNewClientCredentials(void)
{
    CredHandle hCreds;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    PCCERT_CONTEXT  pCertContext;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;

    //
    // Read list of trusted issuers from schannel.
    //

    Status = g_SecurityFunc.QueryContextAttributes(&m_Context,
                                    SECPKG_ATTR_ISSUER_LIST_EX,
                                    (PVOID)&IssuerListInfo);
    if (Status != SEC_E_OK)
    {
        goto Exit;
    }

    //
    // Enumerate the client certificates.
    //

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while(TRUE)
    {
        // Find a certificate chain.
        pChainContext = g_Crypt32Calls.
            CertFindChainInStore(g_hMyCertStore,
                                 X509_ASN_ENCODING,
                                 0,
                                 CERT_CHAIN_FIND_BY_ISSUER,
                                 &FindByIssuerPara,
                                 pChainContext);
        if(pChainContext == NULL)
        {
            break;
        }

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // Create schannel credential.
        m_ScCreds.cCreds = 1;
        m_ScCreds.paCred = &pCertContext;

        Status = g_SecurityFunc.AcquireCredentialsHandleA(
                            NULL,                   // Name of principal
                            UNISP_NAME_A,           // Name of package
                            SECPKG_CRED_OUTBOUND,   // Flags indicating use
                            NULL,                   // Pointer to logon ID
                            &m_ScCreds,             // Package specific data
                            NULL,                   // Pointer to GetKey() func
                            NULL,                   // Value to pass to GetKey()
                            &hCreds,                // (out) Cred Handle
                            &tsExpiry);             // (out) Lifetime (optional)
        if(Status != SEC_E_OK)
        {
            continue;
        }

        // Destroy the old credentials.
        if (m_OwnCreds)
        {
            g_SecurityFunc.FreeCredentialsHandle(&m_Creds);
        }

        // XXX drewb - This doesn't really work if this
        // isn't the credential owner.
        m_Creds = hCreds;
        break;
    }

 Exit:
    DSCHAN(("GetNewClientCredentials returns %X\n", Status));
}
    
void
DbgRpcSecureChannelTransport::DisconnectFromClient(void)
{
    DWORD           dwType;
    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbData;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    DWORD           Status;

    //
    // Notify schannel that we are about to close the connection.
    //

    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.ApplyControlToken(&m_Context, &OutBuffer);
    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    //
    // Build an SSL close notify message.
    //

    dwSSPIFlags = ASC_REQ_SEQUENCE_DETECT     |
                  ASC_REQ_REPLAY_DETECT       |
                  ASC_REQ_CONFIDENTIALITY     |
                  ASC_REQ_EXTENDED_ERROR      |
                  ASC_REQ_ALLOCATE_MEMORY     |
                  ASC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.AcceptSecurityContext(
                    &m_Creds,
                    &m_Context,
                    NULL,
                    dwSSPIFlags,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    
    DSCHAN(("DisASC returns %X\n", Status));
    DumpBuffers("DisASC out", &OutBuffer);

    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    pbMessage = (PBYTE)OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;

    //
    // Send the close notify message to the client.
    //

    if (pbMessage != NULL && cbMessage != 0)
    {
        DSCHAN(("  write back %X bytes\n", cbMessage));
        
        cbData = StreamWrite(SEQ_INTERNAL, pbMessage, cbMessage);
        if (cbData == 0)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto cleanup;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(pbMessage);
    }
    
cleanup:
    DSCHAN(("DisconnectFromClient returns %X\n", Status));
}

void
DbgRpcSecureChannelTransport::DisconnectFromServer(void)
{
    DWORD           dwType;
    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbData;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    DWORD           Status;

    //
    // Notify schannel that we are about to close the connection.
    //

    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.ApplyControlToken(&m_Context, &OutBuffer);
    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    //
    // Build an SSL close notify message.
    //

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.InitializeSecurityContextA(
                    &m_Creds,
                    &m_Context,
                    NULL,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &m_Context,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    
    DSCHAN(("DisISC returns %X\n", Status));
    DumpBuffers("DisISC out", &OutBuffer);

    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    pbMessage = (PBYTE)OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;


    //
    // Send the close notify message to the server.
    //

    if(pbMessage != NULL && cbMessage != 0)
    {
        DSCHAN(("  write back %X bytes\n", cbMessage));
        
        cbData = StreamWrite(SEQ_INTERNAL, pbMessage, cbMessage);
        if (cbData == 0)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto cleanup;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(pbMessage);
    }
    
cleanup:
    DSCHAN(("DisconnectFromServer returns %X\n", Status));
}

#endif // #ifndef _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgrpc\trans.cpp ===
//----------------------------------------------------------------------------
//
// DbgRpc transports.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <ws2tcpip.h>

// Crypto hashing requires a crypto provider to be available
// (this may not always be the case on Win9x or NT4) so just go with Base64.
#define HashPassword(Password, Buffer) Base64HashPassword(Password, Buffer)

#ifdef _WIN32_WCE
#define SYNC_SOCKETS
#endif

#ifndef NT_NATIVE

BOOL
CryptoHashPassword(PCSTR Password, PUCHAR Buffer)
{
    BOOL Status = FALSE;
    HCRYPTPROV Prov;
    HCRYPTHASH Hash;
    ULONG HashSize;

    if (!CryptAcquireContext(&Prov, NULL, MS_DEF_PROV, PROV_RSA_FULL,
                             CRYPT_VERIFYCONTEXT))
    {
        goto EH_Fail;
    }
    if (!CryptCreateHash(Prov, CALG_MD5, NULL, 0, &Hash))
    {
        goto EH_Prov;
    }
    if (!CryptHashData(Hash, (PBYTE)Password, strlen(Password), 0))
    {
        goto EH_Hash;
    }
    
    ZeroMemory(Buffer, MAX_PASSWORD_BUFFER);
    HashSize = MAX_PASSWORD_BUFFER;
    if (!CryptGetHashParam(Hash, HP_HASHVAL, Buffer, &HashSize, 0))
    {
        goto EH_Hash;
    }
    
    Status = TRUE;

 EH_Hash:
    CryptDestroyHash(Hash);
 EH_Prov:
    CryptReleaseContext(Prov, 0);
 EH_Fail:
    if (!Status)
    {
        DRPC_ERR(("Unable to hash password, %d\n", GetLastError()));
    }
    return Status;
}

#endif // #ifndef NT_NATIVE

UCHAR g_Base64Table[64] =
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P',
    'Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f',
    'g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v',
    'w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL
Base64HashPassword(PCSTR Password, PUCHAR Buffer)
{
    ULONG Len = strlen(Password);
    if ((Len * 4 + 2) / 3 > MAX_PASSWORD_BUFFER)
    {
        DRPC_ERR(("Unable to hash password\n"));
        return FALSE;
    }
    
    ZeroMemory(Buffer, MAX_PASSWORD_BUFFER);

    ULONG Collect;
    
    while (Len >= 3)
    {
        //
        // Collect three characters and turn them
        // into four output bytes.
        //
        
        Collect = *Password++;
        Collect = (Collect << 8) | *Password++;
        Collect = (Collect << 8) | *Password++;

        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 6) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 0) & 0x3f];

        Len -= 3;
    }

    switch(Len)
    {
    case 2:
        Collect = *Password++;
        Collect = (Collect << 8) | *Password++;
        Collect <<= 8;
        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 6) & 0x3f];
        *Buffer++ = '=';
        break;
        
    case 1:
        Collect = *Password++;
        Collect <<= 16;
        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = '=';
        *Buffer++ = '=';
        break;
    }
    
    return TRUE;
}

//----------------------------------------------------------------------------
//
// DbgRpcTransport.
//
//----------------------------------------------------------------------------

PCSTR g_DbgRpcTransportNames[TRANS_COUNT] =
{
    "tcp", "npipe", "ssl", "spipe", "1394", "com",
};

DbgRpcTransport::~DbgRpcTransport(void)
{
    // Nothing to do.
}

ULONG
DbgRpcTransport::GetNumberParameters(void)
{
    return 3;
}

void
DbgRpcTransport::GetParameter(ULONG Index,
                              PSTR Name, ULONG NameSize,
                              PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_ServerName[0])
        {
            CopyString(Name, "Server", NameSize);
            CopyString(Value, m_ServerName, ValueSize);
        }
        break;
    case 1:
        if (m_PasswordGiven)
        {
            CopyString(Name, "Password", NameSize);
            CopyString(Value, "*", ValueSize);
        }
        break;
    case 2:
        if (m_Hidden)
        {
            CopyString(Name, "Hidden", NameSize);
        }
        break;
    }
}

void
DbgRpcTransport::ResetParameters(void)
{
    m_PasswordGiven = FALSE;
    m_Hidden = FALSE;
    m_ServerName[0] = 0;
    m_ClientConnect = FALSE;
    m_ClientConnectAttempts = 0;
}

BOOL
DbgRpcTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Password"))
    {
        if (Value == NULL)
        {
            DbgRpcError("Remoting password was not specified correctly\n");
            return FALSE;
        }

        if (!HashPassword(Value, m_HashedPassword))
        {
            return FALSE;
        }
        
        m_PasswordGiven = TRUE;
    }
    else if (!_stricmp(Name, "Hidden"))
    {
        m_Hidden = TRUE;
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

void
DbgRpcTransport::CloneData(DbgRpcTransport* Trans)
{
    strcpy(Trans->m_ServerName, m_ServerName);
    Trans->m_PasswordGiven = m_PasswordGiven;
    Trans->m_Hidden = m_Hidden;
    memcpy(Trans->m_HashedPassword, m_HashedPassword,
           sizeof(m_HashedPassword));
    Trans->m_ClientConnect = m_ClientConnect;
    Trans->m_ClientConnectAttempts = m_ClientConnectAttempts;
}

//----------------------------------------------------------------------------
//
// DbgRpcTcpTransport.
//
//----------------------------------------------------------------------------

#ifndef NT_NATIVE

DbgRpcTcpTransport::DbgRpcTcpTransport(void)
{
    m_Name = g_DbgRpcTransportNames[TRANS_TCP];
    m_Sock = INVALID_SOCKET;
    ZeroMemory(&m_OlRead, sizeof(m_OlRead));
    ZeroMemory(&m_OlWrite, sizeof(m_OlWrite));
}

DbgRpcTcpTransport::~DbgRpcTcpTransport(void)
{
    if (m_Sock != INVALID_SOCKET)
    {
        shutdown(m_Sock, 2);
        closesocket(m_Sock);
        m_Sock = INVALID_SOCKET;
    }
#ifndef SYNC_SOCKETS
    if (m_OlRead.hEvent != NULL)
    {
        WSACloseEvent(m_OlRead.hEvent);
        ZeroMemory(&m_OlRead, sizeof(m_OlRead));
    }
    if (m_OlWrite.hEvent != NULL)
    {
        WSACloseEvent(m_OlWrite.hEvent);
        ZeroMemory(&m_OlWrite, sizeof(m_OlWrite));
    }
#endif
}

ULONG
DbgRpcTcpTransport::GetNumberParameters(void)
{
    return 4 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcTcpTransport::GetParameter(ULONG Index,
                                 PSTR Name, ULONG NameSize,
                                 PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (SS_PORT(&m_Addr))
        {
            CopyString(Name, "Port", NameSize);
            PrintString(Value, ValueSize, "%d", ntohs(SS_PORT(&m_Addr)));
            if (m_TopPort)
            {
                ULONG Used = strlen(Value);
                PrintString(Value + Used, ValueSize - Used,
                            ":%d", m_TopPort);
            }
        }
        break;
    case 1:
        if (m_AddrLength == sizeof(SOCKADDR_IN6))
        {
            CopyString(Name, "IpVersion", NameSize);
            Value[0] = '6';
            Value[1] = 0;
        }
        break;
    case 2:
        if (m_ClientConnectName[0])
        {
            CopyString(Name, "CliCon", NameSize);
            CopyString(Value, m_ClientConnectName, ValueSize);
        }
        break;
    case 3:
        if (m_ClientConnectAttempts)
        {
            CopyString(Name, "CliConLim", NameSize);
            PrintString(Value, ValueSize, "%d", m_ClientConnectAttempts);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 4,
                                      Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgRpcTcpTransport::ResetParameters(void)
{
    ZeroMemory(&m_Addr, sizeof(m_Addr));
    m_Addr.ss_family = AF_INET;
    m_AddrLength = sizeof(SOCKADDR_IN);
    m_TopPort = 0;
    
    m_ClientConnectName[0] = 0;
    // ClientConnectAddr parameters are taken from m_Addr
    // when clicon is used.

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcTcpTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "ipversion"))
    {
        ULONG Version;

        if (Value == NULL || sscanf(Value, "%d", &Version) != 1)
        {
            DbgRpcError("TCP parameters: "
                        "the IP version was not specified correctly\n");
            return FALSE; 
        }

        switch(Version)
        {
        case 4:
            m_Addr.ss_family = AF_INET;
            m_AddrLength = sizeof(SOCKADDR_IN);
            break;
        case 6:
            m_Addr.ss_family = AF_INET6;
            m_AddrLength = sizeof(SOCKADDR_IN6);
            break;
        default:
            DbgRpcError("TCP parameters: IP version must "
                        "be 4 or 6\n");
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "port"))
    {
        if (Value == NULL)
        {
            DbgRpcError("TCP parameters: "
                        "the port number was not specified correctly\n");
            return FALSE;
        }

        ULONG Port;

        // Allow a range of ports to be specified if so desired.
        switch(sscanf(Value, "%i:%i", &Port, &m_TopPort))
        {
        case 0:
            Port = 0;
            // Fall through.
        case 1:
            m_TopPort = 0;
            break;
        }

        if (Port > 0xffff || m_TopPort > 0xffff)
        {
            DbgRpcError("TCP parameters: port numbers are "
                        "limited to 16 bits\n");
            return FALSE;
        }
        
        SS_PORT(&m_Addr) = htons((USHORT)Port);
    }
    else if (!_stricmp(Name, "server"))
    {
        if (Value == NULL)
        {
            DbgRpcError("TCP parameters: "
                        "the server name was not specified correctly\n");
            return FALSE;
        }

        if (InitIpAddress(Value, 0, &m_Addr, &m_AddrLength) != S_OK)
        {
            DbgRpcError("TCP parameters: "
                        "the specified server (%s) does not exist\n",
                        Value);
            return FALSE;
        }

        if (!CopyString(m_ServerName, Value, DIMA(m_ServerName)))
        {
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "clicon"))
    {
        if (Value == NULL)
        {
            DbgRpcError("TCP parameters: "
                        "the client name was not specified correctly\n");
            return FALSE;
        }

        m_ClientConnectAddr = m_Addr;
        if (InitIpAddress(Value, 0, &m_ClientConnectAddr,
                          &m_ClientConnectAddrLength) != S_OK)
        {
            DbgRpcError("TCP parameters: "
                        "the specified server (%s) does not exist\n",
                        Value);
            return FALSE;
        }

        if (!CopyString(m_ClientConnectName, Value,
                        DIMA(m_ClientConnectName)))
        {
            return FALSE;
        }

        m_ClientConnect = TRUE;
        // A client-connect server will only do one
        // connection outward and cannot receive connections
        // so there's no point in advertising it.
        m_Hidden = TRUE;
        // Normally the debugger creates two separate clients.
        m_ClientConnectAttempts = 2;
    }
    else if (!_stricmp(Name, "cliconlim"))
    {
        if (Value == NULL ||
            sscanf(Value, "%i", &m_ClientConnectAttempts) != 1)
        {
            DbgRpcError("TCP parameters: the client connect limit "
                        "was not specified correctly\n");
            return FALSE;
        }
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("TCP parameters: %s is not a valid parameter\n", Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcTcpTransport::Clone(void)
{
    DbgRpcTcpTransport* Trans = new DbgRpcTcpTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        Trans->m_Addr = m_Addr;
        Trans->m_AddrLength = m_AddrLength;
        Trans->m_TopPort = m_TopPort;
        memcpy(Trans->m_ClientConnectName, m_ClientConnectName,
               sizeof(Trans->m_ClientConnectName));
        Trans->m_ClientConnectAddr = m_ClientConnectAddr;
        Trans->m_ClientConnectAddrLength = m_ClientConnectAddrLength;
    }
    return Trans;
}

HRESULT
DbgRpcTcpTransport::CreateServer(void)
{
    if (m_ClientConnectName[0])
    {
        // If the server is going to initiate connection
        // to the client there's nothing to do here.
        return S_OK;
    }
    else
    {
        return CreateServerSocket();
    }
}

HRESULT
DbgRpcTcpTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize)
{
    HRESULT Status;
    DbgRpcTcpTransport* Trans;
    
    if (!(Trans = new DbgRpcTcpTransport))
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);

    if (m_ClientConnectName[0])
    {
        //
        // The server needs to initiate connection
        // to the client instead of accepting.
        //

        Trans->m_Addr = m_ClientConnectAddr;
        Trans->m_AddrLength = m_ClientConnectAddrLength;

        Status = Trans->ConnectSocket();
    }
    else
    {
        Status = Trans->AcceptSocketConnection(m_Sock);
    }

    if (Status != S_OK)
    {
        delete Trans;
        return Status;
    }

    GetAddressIdentity(&Trans->m_Addr,
                       Trans->m_AddrLength,
                       Identity,
                       IdentitySize);
    *ClientTrans = Trans;
    return S_OK;
}

HRESULT
DbgRpcTcpTransport::ConnectServer(void)
{
    HRESULT Status;
    
    if (m_ClientConnectName[0])
    {
        //
        // We need to keep the server socket open
        // to allow multiple connects.  There's no
        // good way to keep it associated with other
        // data on the client, though, as from the
        // client's point of view it's just doing multiple
        // separate connections.  For now just keep
        // a global around.
        //

        static SOCKET s_ServSock = INVALID_SOCKET;

        EnterCriticalSection(&g_DbgRpcLock);

        if (s_ServSock == INVALID_SOCKET)
        {
            if ((Status = CreateServerSocket()) != S_OK)
            {
                LeaveCriticalSection(&g_DbgRpcLock);
                return Status;
            }

            s_ServSock = m_Sock;
        }
        
        LeaveCriticalSection(&g_DbgRpcLock);

        return AcceptSocketConnection(s_ServSock);
    }
    else
    {
        return ConnectSocket();
    }
}

ULONG
DbgRpcTcpTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done;

    Done = 0;
    while (Len > 0)
    {
#ifndef SYNC_SOCKETS
        if (!WSAResetEvent(m_OlRead.hEvent))
        {
            break;
        }

        WSABUF SockBuf;
        ULONG SockDone;
        ULONG SockFlags;

        SockBuf.buf = (PSTR)Buffer;
        SockBuf.len = Len;
        SockFlags = 0;
        
        if (WSARecv(m_Sock, &SockBuf, 1, &SockDone, &SockFlags,
                    &m_OlRead, NULL) == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSA_IO_PENDING)
            {
                if (!WSAGetOverlappedResult(m_Sock, &m_OlRead, &SockDone,
                                            TRUE, &SockFlags))
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }
#else
        int SockDone;

        SockDone = recv(m_Sock, (PSTR)Buffer, Len, 0);
#endif

        if (SockDone == 0)
        {
            // Socket connection was broken.
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + SockDone);
        Len -= SockDone;
        Done += SockDone;
    }

    return Done;
}

ULONG
DbgRpcTcpTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done;

    Done = 0;
    while (Len > 0)
    {
#ifndef SYNC_SOCKETS
        if (!WSAResetEvent(m_OlWrite.hEvent))
        {
            break;
        }

        WSABUF SockBuf;
        ULONG SockDone;
        ULONG SockFlags;

        SockBuf.buf = (PSTR)Buffer;
        SockBuf.len = Len;
        SockFlags = 0;
        
        if (WSASend(m_Sock, &SockBuf, 1, &SockDone, SockFlags,
                    &m_OlWrite, NULL) == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSA_IO_PENDING)
            {
                if (!WSAGetOverlappedResult(m_Sock, &m_OlWrite, &SockDone,
                                            TRUE, &SockFlags))
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }
#else
        int SockDone;

        SockDone = send(m_Sock, (PSTR)Buffer, Len, 0);
        if (SockDone <= 0)
        {
            break;
        }
#endif

        Buffer = (PVOID)((PUCHAR)Buffer + SockDone);
        Len -= SockDone;
        Done += SockDone;
    }

    return Done;
}

HRESULT
DbgRpcTcpTransport::InitOl(void)
{
#ifndef SYNC_SOCKETS
    m_OlRead.hEvent = WSACreateEvent();
    if (m_OlRead.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }
    m_OlWrite.hEvent = WSACreateEvent();
    if (m_OlWrite.hEvent == NULL)
    {
        WSACloseEvent(m_OlRead.hEvent);
        m_OlRead.hEvent = NULL;
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }
#endif
    return S_OK;
}

void
DbgRpcTcpTransport::GetAddressIdentity(PSOCKADDR_STORAGE Addr,
                                       int AddrLength,
                                       PSTR Identity,
                                       ULONG IdentitySize)
{
    if (Addr->ss_family == AF_INET ||
        Addr->ss_family == AF_INET6)
    {
        CopyString(Identity, "tcp ", IdentitySize);

        struct hostent* Host =
#if 0
            // This lookup is really slow and doesn't seem to work
            // very often so just don't bother.
            gethostbyaddr((PCSTR)Addr, AddrLength, Addr->ss_family);
#else
            NULL;
#endif
        if (Host != NULL)
        {
            CatString(Identity, Host->h_name, IdentitySize);
            CatString(Identity, " ", IdentitySize);
        }

        int IdLen = strlen(Identity);
        char ServerAndPort[INET6_ADDRSTRLEN + 19];
        DWORD SapLen = sizeof(ServerAndPort);
        
        if (WSAAddressToStringA((struct sockaddr *)Addr, AddrLength, NULL,
                                ServerAndPort, &SapLen) == SOCKET_ERROR)
        {
            PrintString(Identity + IdLen, IdentitySize - IdLen,
                        "<Addr Failure>, port %d",
                        ntohs(SS_PORT(&m_Addr)));
        }
        else
        {
            CatString(Identity, ServerAndPort, IdentitySize);
        }
    }
    else
    {
        PrintString(Identity, IdentitySize, "tcp family %d, bytes %d",
                    Addr->ss_family, AddrLength);
    }
}

HRESULT
DbgRpcTcpTransport::CreateServerSocket(void)
{
    HRESULT Status;

    //
    // We must create our sockets overlapped so that
    // we can control waiting for I/O completion.
    // If we leave the waiting to Winsock by using
    // synchronous sockets it uses an alertable wait
    // which can cause our event notification APCs to
    // be received in the middle of reading packets.
    //
    
    m_Sock = WSASocket(m_Addr.ss_family, SOCK_STREAM, 0, NULL, 0,
                       WSA_FLAG_OVERLAPPED);
    if (m_Sock == INVALID_SOCKET)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Fail;
    }

    for (;;)
    {
        if (bind(m_Sock, (struct sockaddr *)&m_Addr,
                 m_AddrLength) != SOCKET_ERROR)
        {
            break;
        }

        ULONG Port = ntohs(SS_PORT(&m_Addr));
        
        Status = WIN32_STATUS(WSAGetLastError());
        if (Status == HRESULT_FROM_WIN32(WSAEADDRINUSE) &&
            m_TopPort > Port)
        {
            // The user has given a range of ports and
            // we haven't checked them all yet, so go
            // around again.
            SS_PORT(&m_Addr) = htons((USHORT)(Port + 1));
        }
        else
        {
            goto EH_Sock;
        }
    }

    //
    // Retrieve the port actually used in case port
    // zero was used to let TCP pick a port.
    //
    
    SOCKADDR_STORAGE Name;
    int Len;

    Len = sizeof(Name);
    if (getsockname(m_Sock, (struct sockaddr *)&Name, &Len) != 0)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Sock;
    }

    // Copy just the port as we do not want
    // to update the rest of the address.
    SS_PORT(&m_Addr) = SS_PORT(&Name);
        
    // Turn off linger-on-close.
    int On;
    On = TRUE;
    setsockopt(m_Sock, SOL_SOCKET, SO_DONTLINGER,
               (char *)&On, sizeof(On));

    if (listen(m_Sock, SOMAXCONN) == SOCKET_ERROR)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Sock;
    }

    return S_OK;

 EH_Sock:
    closesocket(m_Sock);
    m_Sock = INVALID_SOCKET;
 EH_Fail:
    return Status;
}

HRESULT
DbgRpcTcpTransport::AcceptSocketConnection(SOCKET ServSock)
{
    DRPC(("%X: Waiting to accept connection on socket %p\n",
          GetCurrentThreadId(), ServSock));
    
    m_AddrLength = sizeof(m_Addr);
    m_Sock = accept(ServSock, (struct sockaddr *)&m_Addr, &m_AddrLength);
    if (m_Sock == INVALID_SOCKET)
    {
        DRPC(("%X: Accept failed, %X\n",
              GetCurrentThreadId(), WSAGetLastError()));
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    HRESULT Status = InitOl();
    if (Status != S_OK)
    {
        DRPC(("%X: InitOl failed, %X\n",
              GetCurrentThreadId(), Status));
        return Status;
    }
    
    int On = TRUE;
    setsockopt(m_Sock, IPPROTO_TCP, TCP_NODELAY,
               (PSTR)&On, sizeof(On));

    DRPC(("%X: Accept connection on socket %p\n",
          GetCurrentThreadId(), m_Sock));

    return S_OK;
}

HRESULT
DbgRpcTcpTransport::ConnectSocket(void)
{
    //
    // We must create our sockets overlapped so that
    // we can control waiting for I/O completion.
    // If we leave the waiting to Winsock by using
    // synchronous sockets it uses an alertable wait
    // which can cause our event notification APCs to
    // be received in the middle of reading packets.
    //
    
    m_Sock = WSASocket(m_Addr.ss_family, SOCK_STREAM, 0, NULL, 0,
                       WSA_FLAG_OVERLAPPED);
    if (m_Sock != INVALID_SOCKET)
    {
        if (connect(m_Sock, (struct sockaddr *)&m_Addr,
                    m_AddrLength) == SOCKET_ERROR ||
            InitOl() != S_OK)
        {
            closesocket(m_Sock);
            m_Sock = INVALID_SOCKET;
        }
        else
        {
            int On = TRUE;
            setsockopt(m_Sock, IPPROTO_TCP, TCP_NODELAY,
                       (PSTR)&On, sizeof(On));

            DRPC(("%X: Connect on socket %p\n",
                  GetCurrentThreadId(), m_Sock));
        }
    }

    return m_Sock != INVALID_SOCKET ? S_OK : RPC_E_SERVER_DIED;
}

#endif // #ifndef NT_NATIVE

//----------------------------------------------------------------------------
//
// DbgRpcNamedPipeTransport.
//
//----------------------------------------------------------------------------

#ifndef _WIN32_WCE

DbgRpcNamedPipeTransport::~DbgRpcNamedPipeTransport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }
    if (m_ReadOlap.hEvent != NULL)
    {
        CloseHandle(m_ReadOlap.hEvent);
    }
    if (m_WriteOlap.hEvent != NULL)
    {
        CloseHandle(m_WriteOlap.hEvent);
    }
}

ULONG
DbgRpcNamedPipeTransport::GetNumberParameters(void)
{
    return 1 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcNamedPipeTransport::GetParameter(ULONG Index,
                                       PSTR Name, ULONG NameSize,
                                       PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_Pipe[0])
        {
            CopyString(Name, "Pipe", NameSize);
            CopyString(Value, m_Pipe, ValueSize);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1,
                                      Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgRpcNamedPipeTransport::ResetParameters(void)
{
    m_Pipe[0] = 0;
    m_Handle = NULL;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcNamedPipeTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "server"))
    {
        if (Value == NULL)
        {
            DbgRpcError("NPIPE parameters: "
                        "the server name was not specified correctly\n");
            return FALSE;
        }

        // Skip leading \\ if they were given.
        if (Value[0] == '\\' && Value[1] == '\\')
        {
            Value += 2;
        }
        
        if (!CopyString(m_ServerName, Value, DIMA(m_ServerName)))
        {
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "pipe"))
    {
        if (Value == NULL)
        {
            DbgRpcError("NPIPE parameters: "
                        "the pipe name was not specified correctly\n");
            return FALSE;
        }

        // Use the value as a printf format string so that
        // users can create unique names using the process and
        // thread IDs in their own format.
        PrintString(m_Pipe, DIMA(m_Pipe), Value,
                    GetCurrentProcessId(), GetCurrentThreadId());
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("NPIPE parameters: %s is not a valid parameter\n",
                        Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcNamedPipeTransport::Clone(void)
{
    DbgRpcNamedPipeTransport* Trans = new DbgRpcNamedPipeTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        strcpy(Trans->m_Pipe, m_Pipe);
    }
    return Trans;
}

HRESULT
DbgRpcNamedPipeTransport::CreateServer(void)
{
    HANDLE Pipe;
    char PipeName[MAX_PARAM_VALUE + 16];
#ifndef NT_NATIVE
    strcpy(PipeName, "\\\\.\\pipe\\");
#else
    strcpy(PipeName, "\\Device\\NamedPipe\\");
#endif
    strcat(PipeName, m_Pipe);

    // Check and see if this pipe already exists.
    // This might mess up whoever created the pipe if
    // there is one but it's better than creating a
    // duplicate pipe and having clients get messed up.
#ifndef NT_NATIVE
    Pipe = CreateFile(PipeName, FILE_READ_DATA | FILE_WRITE_DATA,
                      0, NULL, OPEN_EXISTING, 0, NULL);
#else
    Pipe = NtNativeCreateFileA(PipeName,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               0, NULL, OPEN_EXISTING, 0, NULL, FALSE);
#endif
    if (Pipe != INVALID_HANDLE_VALUE)
    {
        // Pipe is already in use.
        DRPC_ERR(("%X: Pipe %s is already in use\n",
                  GetCurrentThreadId(), PipeName));
        CloseHandle(Pipe);
        return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
    }
        
    return S_OK;
}

HRESULT
DbgRpcNamedPipeTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                           PSTR Identity, ULONG IdentitySize)
{
    DbgRpcNamedPipeTransport* Trans = new DbgRpcNamedPipeTransport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);

    char PipeName[MAX_PARAM_VALUE + 16];
#ifndef NT_NATIVE
    strcpy(PipeName, "\\\\.\\pipe\\");
#else
    strcpy(PipeName, "\\Device\\NamedPipe\\");
#endif
    strcat(PipeName, m_Pipe);

#ifndef NT_NATIVE
    Trans->m_Handle =
        CreateNamedPipe(PipeName,
                        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                        PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE,
                        PIPE_UNLIMITED_INSTANCES, 4096, 4096, INFINITE,
                        &g_AllAccessSecAttr);
#else
    Trans->m_Handle =
        NtNativeCreateNamedPipeA(PipeName,
                                 PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                 PIPE_WAIT | PIPE_READMODE_BYTE |
                                 PIPE_TYPE_BYTE,
                                 PIPE_UNLIMITED_INSTANCES, 4096, 4096,
                                 INFINITE,
                                 &g_AllAccessSecAttr, FALSE);
#endif
    if (Trans->m_Handle == INVALID_HANDLE_VALUE)
    {
        Trans->m_Handle = NULL;
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;

    if ((Status = CreateOverlappedPair(&Trans->m_ReadOlap,
                                       &Trans->m_WriteOlap)) != S_OK)
    {
        delete Trans;
        return Status;
    }
    
    DRPC(("%X: Waiting to accept connection on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));

    if (!ConnectNamedPipe(Trans->m_Handle, &Trans->m_ReadOlap))
    {
        if (GetLastError() == ERROR_PIPE_CONNECTED)
        {
            goto Connected;
        }
        else if (GetLastError() == ERROR_IO_PENDING)
        {
            DWORD Unused;
            
            if (GetOverlappedResult(Trans->m_Handle, &Trans->m_ReadOlap,
                                    &Unused, TRUE))
            {
                goto Connected;
            }
        }
        
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        
        delete Trans;
        return WIN32_LAST_STATUS();
    }

 Connected:
    DRPC(("%X: Accept connection on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));

    *ClientTrans = Trans;
    PrintString(Identity, IdentitySize, "npipe %s", m_Pipe);
    
    return S_OK;
}

HRESULT
DbgRpcNamedPipeTransport::ConnectServer(void)
{
    HRESULT Status;
    char PipeName[2 * MAX_PARAM_VALUE + 16];
    sprintf(PipeName, "\\\\%s\\pipe\\%s", m_ServerName, m_Pipe);

    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }
    
    for (;;)
    {
        m_Handle = CreateFile(PipeName, FILE_READ_DATA | FILE_WRITE_DATA,
                              0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED,
                              NULL);
        if (m_Handle != INVALID_HANDLE_VALUE)
        {
            break;
        }
        m_Handle = NULL;

        if (GetLastError() != ERROR_PIPE_BUSY)
        {
            return WIN32_LAST_STATUS();
        }

        if (!WaitNamedPipe(PipeName, NMPWAIT_WAIT_FOREVER))
        {
            return WIN32_LAST_STATUS();
        }
    }

    DRPC(("%X: Connect on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));
    
    return S_OK;
}

ULONG
DbgRpcNamedPipeTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!ReadFile(m_Handle, Buffer, Len, &Ret, &m_ReadOlap))
        {
            if (GetLastError() != ERROR_IO_PENDING ||
                !GetOverlappedResult(m_Handle, &m_ReadOlap, &Ret, TRUE))
            {
                break;
            }
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

ULONG
DbgRpcNamedPipeTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!WriteFile(m_Handle, Buffer, Len, &Ret, &m_WriteOlap))
        {
            if (GetLastError() != ERROR_IO_PENDING ||
                !GetOverlappedResult(m_Handle, &m_WriteOlap, &Ret, TRUE))
            {
                break;
            }
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

#endif // #ifndef _WIN32_WCE

//----------------------------------------------------------------------------
//
// DbgRpc1394Transport.
//
//----------------------------------------------------------------------------

#ifndef _WIN32_WCE

#define TRANS1394_SYMLINK "Instance"

DbgRpc1394Transport::~DbgRpc1394Transport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }
}

ULONG
DbgRpc1394Transport::GetNumberParameters(void)
{
    return 1 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpc1394Transport::GetParameter(ULONG Index,
                                  PSTR Name, ULONG NameSize,
                                  PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_AcceptChannel != 0)
        {
            CopyString(Name, "Channel", NameSize);
            PrintString(Value, ValueSize, "%d", m_AcceptChannel);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1,
                                      Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgRpc1394Transport::ResetParameters(void)
{
    m_AcceptChannel = 0;
    m_StreamChannel = 0;
    m_Handle = NULL;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpc1394Transport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Channel"))
    {
        if (Value == NULL)
        {
            DbgRpcError("1394 parameters: "
                        "the channel was not specified correctly\n");
            return FALSE;
        }

        m_AcceptChannel = atol(Value);
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("1394 parameters: %s is not a valid parameter\n",
                        Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpc1394Transport::Clone(void)
{
    DbgRpc1394Transport* Trans = new DbgRpc1394Transport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        Trans->m_AcceptChannel = m_AcceptChannel;
    }
    return Trans;
}

HRESULT
DbgRpc1394Transport::CreateServer(void)
{
    char Name[64];
    m_StreamChannel = m_AcceptChannel;
    return Create1394Channel(TRANS1394_SYMLINK, m_AcceptChannel,
                             Name, DIMA(Name), &m_Handle);
}

#define DBGRPC_1394_CONNECT '4931'

struct DbgRpc1394Connect
{
    ULONG Signature;
    ULONG Flags;
    ULONG StreamChannel;
    ULONG Reserved[5];
};
    
HRESULT
DbgRpc1394Transport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                      PSTR Identity, ULONG IdentitySize)
{
    DbgRpc1394Transport* Trans = new DbgRpc1394Transport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);
    
    DRPC(("%X: Waiting to accept connection on channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel));

    DbgRpc1394Connect Conn, CheckConn;
    ULONG Done;

    ZeroMemory(&CheckConn, sizeof(CheckConn));
    CheckConn.Signature = DBGRPC_1394_CONNECT;
    
    if (!ReadFile(m_Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        DRPC(("%X: Accept information invalid\n",
              GetCurrentThreadId()));
        delete Trans;
        return E_FAIL;
    }

    char StreamName[64];
    HRESULT Status;

    Conn.StreamChannel = m_StreamChannel + 1;
    if ((Status = Open1394Channel(TRANS1394_SYMLINK,
                                  Conn.StreamChannel,
                                  StreamName, DIMA(StreamName),
                                  &Trans->m_Handle)) != S_OK)
    {
        DRPC(("%X: Accept failed, 0x%X\n",
              GetCurrentThreadId(), Status));
        delete Trans;
        return Status;
    }

    if (!WriteFile(m_Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    
    Trans->m_AcceptChannel = m_AcceptChannel;
    Trans->m_StreamChannel = Conn.StreamChannel;
    m_StreamChannel++;
    
    DRPC(("%X: Accept connection on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, Conn.StreamChannel));

    *ClientTrans = Trans;
    PrintString(Identity, IdentitySize, "1394 %d", m_AcceptChannel);
    
    return S_OK;
}

HRESULT
DbgRpc1394Transport::ConnectServer(void)
{
    char Name[64];
    HRESULT Status;
    HANDLE Handle;
    ULONG Done;

    if ((Status = Create1394Channel(TRANS1394_SYMLINK, m_AcceptChannel,
                                    Name, DIMA(Name), &Handle)) != S_OK)
    {
        return Status;
    }

    DbgRpc1394Connect Conn, CheckConn;

    ZeroMemory(&Conn, sizeof(Conn));
    Conn.Signature = DBGRPC_1394_CONNECT;
    CheckConn = Conn;

    if (!WriteFile(Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        CloseHandle(Handle);
        return WIN32_LAST_STATUS();
    }
    if (!ReadFile(Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        CloseHandle(Handle);
        return WIN32_LAST_STATUS();
    }
    
    CloseHandle(Handle);

    CheckConn.StreamChannel = Conn.StreamChannel;
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        return E_FAIL;
    }

    if ((Status = Open1394Channel(TRANS1394_SYMLINK,
                                  Conn.StreamChannel, Name, DIMA(Name),
                                  &m_Handle)) != S_OK)
    {
        return Status;
    }

    m_StreamChannel = Conn.StreamChannel;
    
    DRPC(("%X: Connect on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, m_StreamChannel));
    
    return S_OK;
}

ULONG
DbgRpc1394Transport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!ReadFile(m_Handle, Buffer, Len, &Ret, NULL))
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

ULONG
DbgRpc1394Transport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!WriteFile(m_Handle, Buffer, Len, &Ret, NULL))
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

#endif // #ifndef _WIN32_WCE

//----------------------------------------------------------------------------
//
// DbgRpcComTransport.
//
//----------------------------------------------------------------------------

#ifndef _WIN32_WCE

DbgRpcComTransport::~DbgRpcComTransport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
    }
    if (m_ReadOlap.hEvent != NULL)
    {
        CloseHandle(m_ReadOlap.hEvent);
    }
    if (m_WriteOlap.hEvent != NULL)
    {
        CloseHandle(m_WriteOlap.hEvent);
    }
}

ULONG
DbgRpcComTransport::GetNumberParameters(void)
{
    return 3 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcComTransport::GetParameter(ULONG Index,
                                 PSTR Name, ULONG NameSize,
                                 PSTR Value, ULONG ValueSize)
{
    switch(Index)
    {
    case 0:
        if (m_PortName[0])
        {
            CopyString(Name, "Port", NameSize);
            CopyString(Value, m_PortName, ValueSize);
        }
        break;
    case 1:
        if (m_BaudRate)
        {
            CopyString(Name, "Baud", NameSize);
            PrintString(Value, ValueSize, "%d", m_BaudRate);
        }
        break;
    case 2:
        if (m_AcceptChannel)
        {
            CopyString(Name, "Channel", NameSize);
            PrintString(Value, ValueSize, "%d", m_AcceptChannel);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1,
                                      Name, NameSize, Value, ValueSize);
        break;
    }
}

void
DbgRpcComTransport::ResetParameters(void)
{
    m_PortName[0] = 0;
    m_BaudRate = 0;
    m_AcceptChannel = 0;
    m_StreamChannel = 0;
    m_Handle = NULL;
    m_PortType = COM_PORT_STANDARD;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcComTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Port"))
    {
        if (Value == NULL)
        {
            DbgRpcError("COM parameters: "
                        "the port was not specified correctly\n");
            return FALSE;
        }

        if (!SetComPortName(Value, m_PortName, DIMA(m_PortName)))
        {
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "Baud"))
    {
        if (Value == NULL)
        {
            DbgRpcError("COM parameters: "
                        "the baud rate was not specified correctly\n");
            return FALSE;
        }

        m_BaudRate = atol(Value);
    }
    else if (!_stricmp(Name, "Channel"))
    {
        ULONG ValChan;

        if (Value == NULL ||
            (ValChan = atol(Value)) > 0xfe)
        {
            DbgRpcError("COM parameters: "
                        "the channel was not specified correctly\n");
            return FALSE;
        }

        m_AcceptChannel = (UCHAR)ValChan;
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("COM parameters: %s is not a valid parameter\n", Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcComTransport::Clone(void)
{
    DbgRpcComTransport* Trans = new DbgRpcComTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        strcpy(Trans->m_PortName, m_PortName);
        Trans->m_BaudRate = m_BaudRate;
        Trans->m_AcceptChannel = m_AcceptChannel;
        Trans->m_PortType = m_PortType;
        // The serial port can only be opened once so
        // just dup the handle for the new transport.
        if (!DuplicateHandle(GetCurrentProcess(), m_Handle,
                             GetCurrentProcess(), &Trans->m_Handle,
                             0, FALSE, DUPLICATE_SAME_ACCESS))
        {
            delete Trans;
            Trans = NULL;
        }
    }
    return Trans;
}

HRESULT
DbgRpcComTransport::CreateServer(void)
{
    HRESULT Status;

    if ((Status = InitializeChannels()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }

    m_StreamChannel = m_AcceptChannel;

    COM_PORT_PARAMS ComParams;
    
    ZeroMemory(&ComParams, sizeof(ComParams));
    ComParams.Type = m_PortType;
    ComParams.PortName = m_PortName;
    ComParams.BaudRate = m_BaudRate;
    return OpenComPort(&ComParams, &m_Handle, &m_BaudRate);
}

#define DBGRPC_COM_CONNECT 'mCrD'

struct DbgRpcComConnect
{
    ULONG Signature;
    ULONG Flags;
    ULONG StreamChannel;
    ULONG Reserved[5];
};
    
HRESULT
DbgRpcComTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity, ULONG IdentitySize)
{
    // Check for channel number overflow.
    if (m_StreamChannel == 0xff)
    {
        return E_OUTOFMEMORY;
    }
    
    DbgRpcComTransport* Trans = new DbgRpcComTransport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);
    
    DRPC(("%X: Waiting to accept connection on port %s baud %d channel %d\n",
          GetCurrentThreadId(), m_PortName, m_BaudRate, m_AcceptChannel));

    DbgRpcComConnect Conn, CheckConn;

    ZeroMemory(&CheckConn, sizeof(CheckConn));
    CheckConn.Signature = DBGRPC_COM_CONNECT;
    
    if (ChanRead(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        DRPC(("%X: Accept information invalid\n",
              GetCurrentThreadId()));
        delete Trans;
        return E_FAIL;
    }

    Conn.StreamChannel = m_StreamChannel + 1;
    if (ChanWrite(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    // Duplicate the handle so that every transport instance
    // has its own to close.
    if (!DuplicateHandle(GetCurrentProcess(), m_Handle,
                         GetCurrentProcess(), &Trans->m_Handle,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;
    
    if ((Status = CreateOverlappedPair(&Trans->m_ReadOlap,
                                       &Trans->m_WriteOlap)) != S_OK)
    {
        DRPC(("%X: Accept failed, 0x%X\n",
              GetCurrentThreadId(), Status));
        delete Trans;
        return Status;
    }

    strcpy(Trans->m_PortName, m_PortName);
    Trans->m_BaudRate = m_BaudRate;
    Trans->m_AcceptChannel = m_AcceptChannel;
    Trans->m_StreamChannel = (UCHAR)Conn.StreamChannel;
    Trans->m_PortType = m_PortType;
    m_StreamChannel++;
    
    DRPC(("%X: Accept connection on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, Conn.StreamChannel));

    *ClientTrans = Trans;
    PrintString(Identity, IdentitySize, "COM %s@%d chan %d",
                m_PortName, m_BaudRate, m_AcceptChannel);
    
    return S_OK;
}

HRESULT
DbgRpcComTransport::ConnectServer(void)
{
    HRESULT Status;

    if ((Status = InitializeChannels()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }

    // If this is a clone it'll already have a handle.
    // Otherwise this is the first connecting transport
    // so it needs to really open the COM port.
    if (m_Handle == NULL)
    {
        COM_PORT_PARAMS ComParams;
    
        ZeroMemory(&ComParams, sizeof(ComParams));
        ComParams.Type = m_PortType;
        ComParams.PortName = m_PortName;
        ComParams.BaudRate = m_BaudRate;
        if ((Status = OpenComPort(&ComParams, &m_Handle, &m_BaudRate)) != S_OK)
        {
            return Status;
        }
    }

    DbgRpcComConnect Conn, CheckConn;

    ZeroMemory(&Conn, sizeof(Conn));
    Conn.Signature = DBGRPC_COM_CONNECT;
    CheckConn = Conn;

    if (ChanWrite(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return WIN32_LAST_STATUS();
    }
    if (ChanRead(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return WIN32_LAST_STATUS();
    }
    
    CheckConn.StreamChannel = Conn.StreamChannel;
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return E_FAIL;
    }

    m_StreamChannel = (UCHAR)Conn.StreamChannel;
    
    DRPC(("%X: Connect on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, m_StreamChannel));
    
    return S_OK;
}

#if 0
#define DCOM(Args) g_NtDllCalls.DbgPrint Args
#else
#define DCOM(Args)
#endif

#define DBGRPC_COM_FAILURE 0xffff

#define DBGRPC_COM_HEAD_SIG 0xdc
#define DBGRPC_COM_TAIL_SIG 0xcd

// In order to avoid overflowing the serial port when
// used at boot time, restrict the maximum size of
// a single chunk of data written.  This must be
// less than 0xffff.
#ifdef NT_NATIVE
#define DBGRPC_COM_MAX_CHUNK (16 - sizeof(DbgRpcComStream))
#else
#define DBGRPC_COM_MAX_CHUNK 0xfffe
#endif

struct DbgRpcComStream
{
    UCHAR Signature;
    UCHAR Channel;
    USHORT Len;
};

struct DbgRpcComQueue
{
    DbgRpcComQueue* Next;
    PUCHAR Data;
    UCHAR Channel;
    USHORT Len;
};

BOOL DbgRpcComTransport::s_ChanInitialized;
CRITICAL_SECTION DbgRpcComTransport::s_QueueLock;
HANDLE DbgRpcComTransport::s_QueueChangedEvent;
LONG DbgRpcComTransport::s_PortReadOwned;
CRITICAL_SECTION DbgRpcComTransport::s_PortWriteLock;
CRITICAL_SECTION DbgRpcComTransport::s_WriteAckLock;
HANDLE DbgRpcComTransport::s_WriteAckEvent;
DbgRpcComQueue* DbgRpcComTransport::s_QueueHead;
DbgRpcComQueue* DbgRpcComTransport::s_QueueTail;

ULONG
DbgRpcComTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;

    while (Len > 0)
    {
        USHORT Chunk = (USHORT)min(Len, DBGRPC_COM_MAX_CHUNK);
        USHORT ChunkDone = ChanRead(m_StreamChannel, Buffer, Chunk);

        Done += ChunkDone;
        Buffer = (PUCHAR)Buffer + ChunkDone;
        Len -= ChunkDone;
        
        if (ChunkDone < Chunk)
        {
            break;
        }
    }

    return Done;
}

ULONG
DbgRpcComTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;

    while (Len > 0)
    {
        USHORT Chunk = (USHORT)min(Len, DBGRPC_COM_MAX_CHUNK);
        USHORT ChunkDone = ChanWrite(m_StreamChannel, Buffer, Chunk);

        Done += ChunkDone;
        Buffer = (PUCHAR)Buffer + ChunkDone;
        Len -= ChunkDone;
        
        if (ChunkDone < Chunk)
        {
            break;
        }
    }

    return Done;
}

USHORT
DbgRpcComTransport::ScanQueue(UCHAR Chan, PVOID Buffer, USHORT Len)
{
    USHORT Done = 0;
    
    EnterCriticalSection(&s_QueueLock);
        
    DbgRpcComQueue* Ent;
    DbgRpcComQueue* Next;
    DbgRpcComQueue* Prev;

    Prev = NULL;
    for (Ent = s_QueueHead; Ent != NULL && Len > 0; Ent = Next)
    {
        Next = Ent->Next;
        
        DCOM(("%03X:    Queue entry %p->%p %d,%d\n",
              GetCurrentThreadId(),
              Ent, Next, Ent->Channel, Ent->Len));
        
        if (Ent->Channel == Chan)
        {
            // Found some input for this channel.
            if (Len < Ent->Len)
            {
                DCOM(("%03X:    Eat %d, leave %d\n",
                      GetCurrentThreadId(), Len, Ent->Len - Len));
                
                memcpy(Buffer, Ent->Data, Len);
                Ent->Data += Len;
                Ent->Len -= Len;
                Done += Len;
                Len = 0;
            }
            else
            {
                DCOM(("%03X:    Eat all %d\n",
                      GetCurrentThreadId(), Len));
                
                memcpy(Buffer, Ent->Data, Ent->Len);
                Buffer = (PVOID)((PUCHAR)Buffer + Ent->Len);
                Done += Ent->Len;
                Len -= Ent->Len;

                // Remove used-up entry from list.
                if (Prev == NULL)
                {
                    s_QueueHead = Ent->Next;
                }
                else
                {
                    Prev->Next = Ent->Next;
                }
                if (s_QueueTail == Ent)
                {
                    s_QueueTail = Prev;
                }
                free(Ent);
                continue;
            }
        }

        Prev = Ent;
    }
    
    LeaveCriticalSection(&s_QueueLock);
    return Done;
}

USHORT
DbgRpcComTransport::ScanPort(UCHAR Chan, PVOID Buffer, USHORT Len,
                             BOOL ScanForAck, UCHAR AckChan)
{
    DbgRpcComStream Stream;
    ULONG ReadDone;
    USHORT Ret = 0;

    if (ScanForAck)
    {
        DCOM(("%03X:  Waiting to read header (ack chan %d)\n",
              GetCurrentThreadId(), AckChan));
    }
    else
    {
        DCOM(("%03X:  Waiting to read header\n",
              GetCurrentThreadId()));
    }

 Rescan:
    for (;;)
    {
        if (!ComPortRead(m_Handle, m_PortType, m_Timeout,
                         &Stream, sizeof(Stream), &ReadDone,
                         &m_ReadOlap) ||
            ReadDone != sizeof(Stream))
        {
            return DBGRPC_COM_FAILURE;
        }

        // If a write ack came through release the waiting writer.
        if (Stream.Signature == DBGRPC_COM_TAIL_SIG &&
            Stream.Len == DBGRPC_COM_FAILURE)
        {
            DCOM(("%03X:    Read write ack for chan %d\n",
                  GetCurrentThreadId(), Stream.Channel));
            
            if (ScanForAck)
            {
                if (AckChan == Stream.Channel)
                {
                    return (USHORT)ReadDone;
                }
                else
                {
                    DCOM(("%03X:    Read mismatched write ack, "
                          "read chan %d waiting for chan %d\n",
                          GetCurrentThreadId(), Stream.Channel, AckChan));
                    return DBGRPC_COM_FAILURE;
                }
            }
            
            SetEvent(s_WriteAckEvent);
        }
        else if (Stream.Signature != DBGRPC_COM_HEAD_SIG ||
                 Stream.Len == DBGRPC_COM_FAILURE)
        {
            return DBGRPC_COM_FAILURE;
        }
        else
        {
            break;
        }
    }

    DCOM(("%03X:  Read %d,%d\n",
          GetCurrentThreadId(), Stream.Channel, Stream.Len));
    
    // If the data available is for this channel
    // read it directly into the buffer.
    if (!ScanForAck && Stream.Channel == Chan)
    {
        Ret = min(Stream.Len, Len);
        DCOM(("%03X:  Read direct body %d\n",
              GetCurrentThreadId(), Ret));
        if (!ComPortRead(m_Handle, m_PortType, m_Timeout,
                         Buffer, Ret, &ReadDone, &m_ReadOlap) ||
            ReadDone != Ret)
        {
            return DBGRPC_COM_FAILURE;
        }

        Stream.Len -= Ret;
    }

    // If the data is for another channel or there's
    // more than we need queue the remainder for
    // later use.
    if (Stream.Len > 0)
    {
        DbgRpcComQueue* Ent =
            (DbgRpcComQueue*)malloc(sizeof(*Ent) + Stream.Len);
        if (Ent == NULL)
        {
            return DBGRPC_COM_FAILURE;
        }

        Ent->Next = NULL;
        Ent->Channel = Stream.Channel;
        Ent->Len = Stream.Len;
        Ent->Data = (PUCHAR)Ent + sizeof(*Ent);

        DCOM(("%03X:  Read queue body %d\n",
              GetCurrentThreadId(), Ent->Len));

        if (!ComPortRead(m_Handle, m_PortType, m_Timeout,
                         Ent->Data, Ent->Len, &ReadDone,
                         &m_ReadOlap) ||
            ReadDone != Ent->Len)
        {
            free(Ent);
            return DBGRPC_COM_FAILURE;
        }

        DCOM(("%03X:  Queue add %p %d,%d\n",
              GetCurrentThreadId(), Ent, Ent->Channel, Ent->Len));
        
        EnterCriticalSection(&s_QueueLock);

        if (s_QueueHead == NULL)
        {
            s_QueueHead = Ent;
        }
        else
        {
            s_QueueTail->Next = Ent;
        }
        s_QueueTail = Ent;
        
        LeaveCriticalSection(&s_QueueLock);
    }

    //
    // Acknowledge full receipt of the data.
    //
    
    Stream.Signature = DBGRPC_COM_TAIL_SIG;
    Stream.Channel = Stream.Channel;
    Stream.Len = DBGRPC_COM_FAILURE;
    
    EnterCriticalSection(&s_PortWriteLock);
    
    if (!ComPortWrite(m_Handle, m_PortType, &Stream, sizeof(Stream),
                      &ReadDone, &m_ReadOlap))
    {
        ReadDone = 0;
    }
    else
    {
        DCOM(("%03X:    Wrote write ack for chan %d\n",
              GetCurrentThreadId(), Stream.Channel));
    }

    LeaveCriticalSection(&s_PortWriteLock);
    
    if (ReadDone != sizeof(Stream))
    {
        return DBGRPC_COM_FAILURE;
    }

    // Don't exit if we're waiting for an ack as
    // we haven't received it yet.
    if (ScanForAck)
    {
        SetEvent(s_QueueChangedEvent);
        goto Rescan;
    }
    
    return Ret;
}

USHORT
DbgRpcComTransport::ChanRead(UCHAR Chan, PVOID Buffer, USHORT InLen)
{
    USHORT Done = 0;
    USHORT Len = InLen;
    
    // The virtual channels require that all reads and writes
    // be complete.  A partial read or write will not match
    // its channel header and will throw everything off.

    DCOM(("%03X:ChanRead %d,%d\n",
          GetCurrentThreadId(), Chan, Len));
    
    while (Len > 0)
    {
        USHORT Queued;
        
        // First check and see if input for this channel
        // is already present in the queue.
        Queued = ScanQueue(Chan, Buffer, Len);
        Done += Queued;
        Buffer = (PVOID)((PUCHAR)Buffer + Queued);
        Len -= Queued;

        if (Queued > 0)
        {
            DCOM(("%03X:  Scan pass 1 gets %d from queue\n",
                  GetCurrentThreadId(), Queued));
        }
        
        if (Len == 0)
        {
            break;
        }

        //
        // There wasn't enough queued input so try and
        // read some more from the port.
        //

        if (InterlockedExchange(&s_PortReadOwned, TRUE) == TRUE)
        {
            // Somebody else owns the port so we can't
            // read it.  Just wait for the queue to change
            // so we can check for data again.

            // Set things to wait.
            ResetEvent(s_QueueChangedEvent);

            // There's a chance that the queue changed just before
            // the event was reset and therefore that event set
            // has been lost.  Time out of this wait to ensure
            // that nothing ever gets hung up indefinitely here.
            if (WaitForSingleObject(s_QueueChangedEvent, 250) ==
                WAIT_FAILED)
            {
                DCOM(("%03X:  Change wait failed\n",
                      GetCurrentThreadId()));
                return 0;
            }

            continue;
        }
        
        // We now own the port.  The queue may have changed
        // during the time we were acquiring ownership, though,
        // so check it again.
        Queued = ScanQueue(Chan, Buffer, Len);
        Done += Queued;
        Buffer = (PVOID)((PUCHAR)Buffer + Queued);
        Len -= Queued;

        if (Queued > 0)
        {
            DCOM(("%03X:  Scan pass 2 gets %d from queue\n",
                  GetCurrentThreadId(), Queued));
        }
        
        if (Len > 0)
        {
            // Still need more input and we're now the
            // owner of the port, so read.
            USHORT Port = ScanPort(Chan, Buffer, Len, FALSE, 0);
            if (Port == DBGRPC_COM_FAILURE)
            {
                // Critical error, fail immediately.
                InterlockedExchange(&s_PortReadOwned, FALSE);
                SetEvent(s_QueueChangedEvent);
                DCOM(("%03X:  Critical failure\n",
                      GetCurrentThreadId()));
                return 0;
            }
            
            Done += Port;
            Buffer = (PVOID)((PUCHAR)Buffer + Port);
            Len -= Port;

            if (Port > 0)
            {
                DCOM(("%03X:  Scan %d from port\n",
                      GetCurrentThreadId(), Port));
            }
        }
        
        InterlockedExchange(&s_PortReadOwned, FALSE);
        SetEvent(s_QueueChangedEvent);
    }

    DCOM(("%03X:  ChanRead %d,%d returns %d\n",
          GetCurrentThreadId(), Chan, InLen, Done));
    return Done;
}

USHORT
DbgRpcComTransport::ChanWrite(UCHAR Chan, PVOID Buffer, USHORT InLen)
{
    USHORT Len = InLen;
    
    DCOM(("%03X:ChanWrite %d,%d\n",
          GetCurrentThreadId(), Chan, Len));

    ULONG Done;
    DbgRpcComStream Stream;

    // The virtual channels require that all reads and writes
    // be complete.  A partial read or write will not match
    // its channel header and will throw everything off.

    Stream.Signature = DBGRPC_COM_HEAD_SIG;
    Stream.Channel = Chan;
    Stream.Len = Len;

    // The write ack lock restricts things to a single
    // unacknowledged write.  The port write lock
    // ensures that the multiple pieces of a write
    // are sequential in the stream.
    EnterCriticalSection(&s_WriteAckLock);
    EnterCriticalSection(&s_PortWriteLock);

    if (!ComPortWrite(m_Handle, m_PortType, &Stream, sizeof(Stream), &Done,
                      &m_WriteOlap) ||
        Done != sizeof(Stream) ||
        !ComPortWrite(m_Handle, m_PortType, Buffer, Len,
                      &Done, &m_WriteOlap) ||
        Done != Len)
    {
        Done = 0;
    }
    
    LeaveCriticalSection(&s_PortWriteLock);

    //
    // Wait for data ack.  This prevents too much data from
    // being written to the serial port at once by limiting
    // the amount of outstanding data to a single chunk's worth.
    //

    for (;;)
    {
        if (InterlockedExchange(&s_PortReadOwned, TRUE) == TRUE)
        {
            HANDLE Waits[2];
            ULONG Wait;

            // Somebody else owns the port so wait for their signal.
            // Also wait for a port ownership change as we may
            // need to switch to a direct port read.
            Waits[0] = s_WriteAckEvent;
            Waits[1] = s_QueueChangedEvent;
            
            // Set things to wait.
            ResetEvent(s_QueueChangedEvent);
            
            Wait = WaitForMultipleObjects(2, Waits, FALSE, 250);
            if (Wait == WAIT_OBJECT_0)
            {
                break;
            }
            else if (Wait == WAIT_FAILED)
            {
                DCOM(("%03X:  Write ack wait failed, %d\n",
                      GetCurrentThreadId(), GetLastError()));
                Done = 0;
                break;
            }
        }
        else
        {
            USHORT AckDone;
        
            // We now own the port so directly read the ack.
            // However, before we do we need to make one last
            // check and see if somebody else read our ack
            // in the time leading up to us acquiring port
            // ownership.
            if (WaitForSingleObject(s_WriteAckEvent, 0) != WAIT_OBJECT_0)
            {
                AckDone = ScanPort(Chan, &Stream, sizeof(Stream),
                                   TRUE, Chan);
                if (AckDone == DBGRPC_COM_FAILURE)
                {
                    DCOM(("%03X:  Failed scan for write ack\n",
                          GetCurrentThreadId()));
                    Done = 0;
                }
            }
        
            InterlockedExchange(&s_PortReadOwned, FALSE);
            SetEvent(s_QueueChangedEvent);
            break;
        }
    }
    
    LeaveCriticalSection(&s_WriteAckLock);
    
    DCOM(("%03X:  ChanWrite %d,%d returns %d\n",
          GetCurrentThreadId(), Chan, InLen, Done));
    return (USHORT)Done;
}

HRESULT
DbgRpcComTransport::InitializeChannels(void)
{
    if (s_ChanInitialized)
    {
        return S_OK;
    }

    if ((s_QueueChangedEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    if ((s_WriteAckEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    __try
    {
        InitializeCriticalSection(&s_QueueLock);
        InitializeCriticalSection(&s_PortWriteLock);
        InitializeCriticalSection(&s_WriteAckLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return E_OUTOFMEMORY;
    }

    s_ChanInitialized = TRUE;
    return S_OK;
}

#endif // #ifndef _WIN32_WCE

//----------------------------------------------------------------------------
//
// Transport functions.
//
//----------------------------------------------------------------------------

DbgRpcTransport*
DbgRpcNewTransport(ULONG Trans)
{
    switch(Trans)
    {
#ifdef _WIN32_WCE
    case TRANS_TCP:
        return new DbgRpcTcpTransport;
#else
#ifndef NT_NATIVE
    case TRANS_TCP:
        return new DbgRpcTcpTransport;
    case TRANS_SSL:
        return new DbgRpcSecureChannelTransport(Trans, TRANS_TCP);
    case TRANS_SPIPE:
        return new DbgRpcSecureChannelTransport(Trans, TRANS_NPIPE);
#endif
    case TRANS_NPIPE:
        return new DbgRpcNamedPipeTransport;
    case TRANS_1394:
        return new DbgRpc1394Transport;
    case TRANS_COM:
        return new DbgRpcComTransport;
#endif // #ifdef _WIN32_WCE
    default:
        return NULL;
    }
}

DbgRpcTransport*
DbgRpcCreateTransport(PCSTR Options)
{
    ULONG Trans = ParameterStringParser::
        GetParser(Options, TRANS_COUNT, g_DbgRpcTransportNames);
    return DbgRpcNewTransport(Trans);
}

DbgRpcTransport*
DbgRpcInitializeTransport(PCSTR Options)
{
    DbgRpcTransport* Trans = DbgRpcCreateTransport(Options);
    if (Trans != NULL)
    {
        // Clean out any old parameter state.
        Trans->ResetParameters();

        if (!Trans->ParseParameters(Options))
        {
            delete Trans;
            return NULL;
        }
    }

    return Trans;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsrv\sources.inc ===
TARGETPATH = obj
TARGETTYPE = PROGRAM

INCLUDES = $(INCLUDES);.;..\..\dbg-common

SOURCES = \
        ..\dbgsrv.rc\
        ..\dbgsrv.cpp

UMENTRY = main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsrv\dbgsrv.cpp ===
//----------------------------------------------------------------------------
//
// Starts a process server and sleeps forever.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include <stdio.h>

#ifdef _DBGSRV_

#include <dbgeng.h>

#else

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#ifdef _NTDBGSRV_
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <wcecompat.h>

#define INITGUID
#include <objbase.h>

#ifndef _WIN32_WCE
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#endif

#define NTDLL_APIS
#include <dllimp.h>
#include <dbgrpc.hpp>
#include <dbgsvc.h>
#include <dbgsvc.hpp>

#ifdef _NTDBGSRV_
// The .CRT section is generated when static intializers,
// such as global class instances, exist.  It needs to
// be merged into .data to avoid a linker warning.
#pragma comment(linker, "/merge:.CRT=.data")
#endif

#endif // #ifdef _DBGSRV_

#include <cmnutil.hpp>

#if defined(_NTDBGSRV_)
#define APP_NAME "ntdbgsrv"
#elif defined(_MDBGSRV_)
#define APP_NAME "mdbgsrv"
#elif defined(_DBGSRV_)
#define APP_NAME "dbgsrv"
#else
#error Bad build type.
#endif

void DECLSPEC_NORETURN
PanicExit(char* Title, char* Msg)
{
#if defined(_NTDBGSRV_)

    if (Title)
    {
        DbgPrint("%s: %s", Title, Msg);
    }
    else
    {
        DbgPrint("%s", Msg);
    }
    
    NtTerminateProcess(NtCurrentProcess(), (NTSTATUS)1);

#elif defined(_MDBGSRV_)

    if (Title)
    {
        OutputDebugStringA(Title);
        OutputDebugStringA(": ");
    }
    OutputDebugStringA(Msg);
    
#ifdef _WIN32_WCE
    exit(1);
#else
    ExitProcess(1);
#endif

#elif defined(_DBGSRV_)

    MessageBox(GetDesktopWindow(), Msg, Title, MB_OK);
    exit(1);

#else
#error Bad build type.
#endif
}

void DECLSPEC_NORETURN
PanicVa(char* Title, char* Format, va_list Args)
{
    char Msg[256];

    _vsnprintf(Msg, sizeof(Msg), Format, Args);
    Msg[sizeof(Msg) - 1] = 0;
    PanicExit(Title, Msg);
}

void
PanicMessage(char* Title, char* Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    PanicVa(Title, Format, Args);
    va_end(Args);
}

void DECLSPEC_NORETURN
PanicStatus(HRESULT Status, char* Format, ...)
{
    va_list Args;
    char Msg[256];
    char Err[32];

    va_start(Args, Format);
    _vsnprintf(Msg, sizeof(Msg), Format, Args);
    Msg[sizeof(Msg) - 1] = 0;
    va_end(Args);

    sprintf(Err, "Error 0x%08X", Status);

    PanicExit(Err, Msg);
}

#ifndef _DBGSRV_

#if DBG
void
DbgAssertionFailed(PCSTR File, int Line, PCSTR Str)
{
    PanicMessage("Assertion failed", "%s(%d)\n  %s\n",
                 File, Line, Str);
}
#endif

//----------------------------------------------------------------------------
//
// Proxy and stub support.
//
//----------------------------------------------------------------------------

// Generated headers.
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

void
DbgRpcInitializeClient(void)
{
    DbgRpcInitializeStubTables_dbgsvc(DBGRPC_SIF_DBGSVC_FIRST);
}
    
DbgRpcStubFunction
DbgRpcGetStub(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;

    if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
        If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return NULL;
    }
    if (Mth >= Table[If].Count)
    {
        return NULL;
    }

    return Table[If].Functions[Mth];
}

#if DBG
PCSTR
DbgRpcGetStubName(USHORT StubIndex)
{
    USHORT If = (USHORT) DBGRPC_STUB_INDEX_INTERFACE(StubIndex);
    USHORT Mth = (USHORT) DBGRPC_STUB_INDEX_METHOD(StubIndex);
    DbgRpcStubFunctionTable* Table;
    PCSTR** Names;

    if (If >= DBGRPC_SIF_DBGSVC_FIRST &&
        If >= DBGRPC_SIF_DBGSVC_LAST)
    {
        Table = g_DbgRpcStubs_dbgsvc;
        Names = g_DbgRpcStubNames_dbgsvc;
        If -= DBGRPC_SIF_DBGSVC_FIRST;
    }
    else
    {
        return "!InvalidInterface!";
    }
    if (Mth >= Table[If].Count)
    {
        return "!InvalidStubIndex!";
    }

    return Names[If][Mth];
}
#endif // #if DBG

HRESULT
DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                    DbgRpcProxy** Proxy, PULONG IfUnique)
{
    return DbgRpcPreallocProxy_dbgsvc(InterfaceId, Interface,
                                      Proxy, IfUnique);
}

void
DbgRpcDeleteProxy(class DbgRpcProxy* Proxy)
{
    // All proxies used here are similar simple single
    // vtable proxy objects so IDebugClient can represent them all.
    delete (ProxyIUserDebugServices*)Proxy;
}

HRESULT
DbgRpcServerThreadInitialize(void)
{
    // Nothing to do.
    return S_OK;
}

void
DbgRpcServerThreadUninitialize(void)
{
    // Nothing to do.
}

void
DbgRpcError(char* Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    PanicVa(NULL, Format, Args);
    va_end(Args);
}

DBGRPC_SIMPLE_FACTORY(LiveUserDebugServices, __uuidof(IUserDebugServices), \
                      "Remote Process Server", (TRUE))
LiveUserDebugServicesFactory g_LiveUserDebugServicesFactory;

#ifdef _NTDBGSRV_

#ifdef  _M_IA64

#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCZ",long,read)
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIZ",long,read)

#define _CRTALLOC(x) __declspec(allocate(x))

#else   /* ndef _M_IA64 */

#define _CRTALLOC(x)

#endif  /* ndef _M_IA64 */

typedef void (__cdecl *_PVFV)(void);

extern "C"
{

// C initializers collect here.
#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };
#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };
    
// C++ initializers collect here.
#pragma data_seg(".CRT$XCA")
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };
#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

};

void __cdecl
_initterm (_PVFV * pfbegin, _PVFV * pfend)
{
    /*
     * walk the table of function pointers from the bottom up, until
     * the end is encountered.  Do not skip the first entry.  The initial
     * value of pfbegin points to the first valid entry.  Do not try to
     * execute what pfend points to.  Only entries before pfend are valid.
     */
    while ( pfbegin < pfend )
    {
        /*
         * if current table entry is non-NULL, call thru it.
         */
        if ( *pfbegin != NULL )
        {
            (**pfbegin)();
        }
        ++pfbegin;
    }
}

#endif // #ifdef _NTDBGSRV_

void
Run(PSTR Options, PWSTR CreateCmd, ULONG CreateFlags)
{
    HRESULT Status;
    
#ifdef _NTDBGSRV_
    DbgPrint("Running %s with '%s'\n", APP_NAME, Options);
#else
    OutputDebugStringA("Running ");
    OutputDebugStringA(APP_NAME);
    OutputDebugStringA(" with '");
    OutputDebugStringA(Options);
    OutputDebugStringA("'\n");
#endif

    if ((Status = InitDynamicCalls(&g_NtDllCallsDesc)) != S_OK)
    {
        PanicStatus(Status, "InitDynamicCalls\n");
    }
    
    ULONG Flags;
    
    if ((Status = g_LiveUserDebugServices.Initialize(&Flags)) != S_OK)
    {
        PanicStatus(Status, "LiveUserDebugServices::Initialize\n");
    }

    //
    // Create the server.
    //
    
    if ((Status = DbgRpcCreateServer(Options,
                                     &g_LiveUserDebugServicesFactory,
                                     FALSE)) != S_OK)
    {
        PanicStatus(Status, "StartProcessServer\n");
    }

    //
    // If there's a creation request create the process.
    //

    if (CreateCmd)
    {
        ULONG ProcId, ThreadId;
        ULONG64 ProcHandle, ThreadHandle;

        if ((Status = g_LiveUserDebugServices.
             CreateProcessW(CreateCmd, CreateFlags, TRUE, NULL,
                            &ProcId, &ThreadId,
                            &ProcHandle, &ThreadHandle)) != S_OK)
        {
            PanicStatus(Status, "CreateProcessW\n");
        }
        g_LiveUserDebugServices.CloseHandle(ProcHandle);
        g_LiveUserDebugServices.CloseHandle(ThreadHandle);
    }

    //
    // Wait forever for the server to exit.
    //
    
    for (;;)
    {
        Sleep(1000);
            
        if (g_UserServicesUninitialized)
        {
            break;
        }
    }

    DbgRpcDeregisterServers();
}

#else // #ifndef _DBGSRV_

void
Run(PSTR Options, PWSTR CreateCmd, ULONG CreateFlags)
{
    HRESULT Status;
    PDEBUG_CLIENT BaseClient;
    PDEBUG_CLIENT3 Client;

    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&BaseClient)) != S_OK)
    {
        PanicStatus(Status, "DebugCreate\n");
    }
    if ((Status = BaseClient->QueryInterface(__uuidof(IDebugClient3),
                                             (void**)&Client)) != S_OK)
    {
        PanicStatus(Status, "dbgeng version 3 is required\n");
    }
    BaseClient->Release();

    //
    // Create the server.
    //
    
    if ((Status = Client->
         StartProcessServer(DEBUG_CLASS_USER_WINDOWS, Options, NULL)) != S_OK)
    {
        PanicStatus(Status, "StartProcessServer\n");
    }

    //
    // If there's a creation request create the process.
    //

    if (CreateCmd)
    {
        if ((Status = Client->
             CreateProcessWide(0, CreateCmd, CreateFlags)) != S_OK)
        {
            Client->Release();
            PanicStatus(Status, "CreateProcessWide\n");
        }
    }
        
    //
    // Wait forever for the server to exit.
    //
    
    Client->WaitForProcessServerEnd(INFINITE);

    Client->EndSession(DEBUG_END_REENTRANT);
    Client->Release();
}

#endif // #ifndef _DBGSRV_

void __cdecl
main(int Argc, char** Argv)
{
    HRESULT Status;
    PSTR Options = NULL;
    BOOL Usage = FALSE;
    BOOL CreateSuspended = FALSE;
    BOOL CreateArgs = FALSE;
    int ArgChars;

#ifdef _NTDBGSRV_
    // Manually invoke C and C++ initializers.
    _initterm( __xi_a, __xi_z );
    _initterm( __xc_a, __xc_z );
#endif

    ArgChars = strlen(Argv[0]);
    
    while (--Argc > 0)
    {
        Argv++;

        if (Argc > 1 && !strcmp(*Argv, "-t"))
        {
            ArgChars += strlen(*Argv) + 1;
            Options = *++Argv;
            Argc--;
        }
        else if (!strcmp(*Argv, "-c"))
        {
            // Ignore the remainder of the command line.
            CreateArgs = TRUE;
            break;
        }
        else if (!strcmp(*Argv, "-cs"))
        {
            // Ignore the remainder of the command line.
            CreateSuspended = TRUE;
            CreateArgs = TRUE;
            break;
        }
        else if (!strcmp(*Argv, "-x"))
        {
            // Ignore the remainder of the command line.
            break;
        }
        else
        {
            if (**Argv == '-' ||
                Argc != 1)
            {
                Usage = TRUE;
            }
            else
            {
                Options = *Argv;
            }
            break;
        }

        ArgChars += strlen(*Argv) + 1;
    }

    if (Usage || !Options)
    {
        PanicExit("Invalid Command Line",
                  "Usage: dbgsrv [-t <transport>] [-x] [-c[s] <args...>]\n"
                  "       transport: tcp | npipe | ssl | spipe | 1394 | com\n"
                  "           for tcp use: port=<socket port #>\n"
                  "           for npipe use: pipe=<name of pipe>\n"
                  "           for 1394 use: channel=<channel #>\n"
                  "           for com use: port=<COM port>,baud=<baud rate>,\n"
                  "                        channel=<channel #>\n"
                  "           for ssl and spipe see the documentation\n"
                  "\n"
                  "Example: " APP_NAME " -t npipe:pipe=foobar\n");
    }

    //
    // If there are process creation args on the
    // end of the command line locate them in the
    // real command line.
    //

    PWSTR CreateCmd = NULL;
    ULONG CreateFlags = 0;

    if (CreateArgs)
    {
        if (CreateSuspended)
        {
            CreateFlags |= CREATE_SUSPENDED;
        }
        
        CreateCmd = GetCommandLineW();
        if (!CreateCmd)
        {
            PSTR CmdA = GetCommandLineA();
            if (!CmdA)
            {
                PanicStatus(E_FAIL, "Unable to get command line\n");
            }

            if ((Status = AnsiToWide(CmdA, &CreateCmd)) != S_OK)
            {
                PanicStatus(Status, "AnsiToWide\n");
            }
        }
        
        CreateCmd += ArgChars;
        while (*CreateCmd &&
               ((CreateCmd[0] != L' '  && CreateCmd[0] != L'\t') ||
                CreateCmd[1] != L'-' ||
                CreateCmd[2] != L'c' ||
                (!CreateSuspended &&
                 (CreateCmd[3] != L' '  && CreateCmd[3] != L'\t')) ||
                (CreateSuspended &&
                 (CreateCmd[3] != L's' ||
                  (CreateCmd[4] != L' '  && CreateCmd[4] != L'\t')))))
        {
            CreateCmd++;
        }
        if (!*CreateCmd)
        {
            PanicExit("Invalid Command Line", "Unable to locate -c[s]");
        }

        if (CreateSuspended)
        {
            CreateCmd += 4;
        }
        else
        {
            CreateCmd += 3;
        }
        while (*CreateCmd == L' ' || *CreateCmd == L'\t')
        {
            CreateCmd++;
        }
    }
    
    Run(Options, CreateCmd, CreateFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\makefile.inc ===
$O\dbgsvc_p.hpp $O\dbgsvc_p.cpp $O\dbgsvc_s.hpp $O\dbgsvc_s.cpp: \
            ..\dbgsvc.h ..\..\dbg-common\rremgen.pl
        perl ..\..\dbg-common\rremgen.pl -g $O ..\dbgsvc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\dbgsvc.hpp ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGSVC_HPP__
#define __DBGSVC_HPP__

//----------------------------------------------------------------------------
//
// UserDebugServices.
//
//----------------------------------------------------------------------------

class UserDebugServices
    : public IUserDebugServices,
      public DbgRpcClientObject
{
public:
    UserDebugServices(void);
    virtual ~UserDebugServices(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        );

    // DbgRpcClientObject.
    virtual HRESULT RpcInitialize(PSTR ClientIdentity, PSTR TransIdentity,
                                  PVOID* Interface);
    virtual void    RpcFinalize(void);
    virtual void    RpcUninitialize(void);

    // UserDebugServices.
    ULONG m_Refs;
    BOOL m_Initialized;
    char m_ClientIdentity[DBGRPC_MAX_IDENTITY];
    char m_TransIdentity[DBGRPC_MAX_IDENTITY];
};

//----------------------------------------------------------------------------
//
// LiveUserDebugServices.
//
//----------------------------------------------------------------------------

class LiveUserDebugServices
    : public UserDebugServices
{
public:
    LiveUserDebugServices(BOOL Remote);
    virtual ~LiveUserDebugServices(void);
    
    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        );
    STDMETHOD(GetTargetInfo)(
        THIS_
        OUT PULONG MachineType,
        OUT PULONG NumberProcessors,
        OUT PULONG PlatformId,
        OUT PULONG BuildNumber,
        OUT PULONG CheckedBuild,
        OUT PSTR CsdString,
        IN ULONG CsdStringSize,
        OUT PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT PULONG ProductType,
        OUT PULONG SuiteMask
        );
    STDMETHOD(GetConnectionInfo)(
        THIS_
        OUT OPTIONAL PSTR MachineName,
        IN ULONG MachineNameSize,
        OUT OPTIONAL PSTR ClientIdentity,
        IN ULONG ClientIdentitySize,
        OUT OPTIONAL PSTR TransportIdentity,
        IN ULONG TransportIdentitySize
        );
    STDMETHOD(GetProcessorId)(
        THIS_
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT PULONG BufferUsed
        );
    STDMETHOD(GetGenericProcessorFeatures)(
        THIS_
        OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
        IN ULONG FeaturesSize,
        OUT OPTIONAL PULONG Used
        );
    STDMETHOD(GetSpecificProcessorFeatures)(
        THIS_
        OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
        IN ULONG FeaturesSize,
        OUT OPTIONAL PULONG Used
        );
    STDMETHOD(GetFileVersionInformationA)(
        THIS_
        IN PCWSTR File,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        );
    STDMETHOD(GetProcessIds)(
        THIS_
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        );
    STDMETHOD(GetProcessIdByExecutableNameW)(
        THIS_
        IN PCWSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        );
    STDMETHOD(GetProcessDescriptionW)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PWSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PWSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        );
    STDMETHOD(GetProcessInfo)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PULONG64 Handle,
        OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
        IN ULONG InfoCount,
        OUT OPTIONAL PULONG ThreadCount
        );
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG AttachFlags,
        OUT PULONG64 ProcessHandle,
        OUT PULONG ProcessOptions
        );
    STDMETHOD(DetachProcess)(
        THIS_
        IN ULONG ProcessId
        );
    STDMETHOD(CreateProcessW)(
        THIS_
        IN PWSTR CommandLine,
        IN ULONG CreateFlags,
        IN BOOL InheritHandles,
        IN OPTIONAL PWSTR CurrentDir,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT PULONG64 ProcessHandle,
        OUT PULONG64 ThreadHandle
        );
    STDMETHOD(TerminateProcess)(
        THIS_
        IN ULONG64 Process,
        IN ULONG ExitCode
        );
    STDMETHOD(AbandonProcess)(
        THIS_
        IN ULONG64 Process
        );
    STDMETHOD(GetProcessExitCode)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG ExitCode
        );
    STDMETHOD(CloseHandle)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG64 Process,
        IN ULONG Options
        );
    STDMETHOD(SetDebugObjectOptions)(
        THIS_
        IN ULONG64 DebugObject,
        IN ULONG Options
        );
    STDMETHOD(GetProcessDebugObject)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 DebugObject
        );
    STDMETHOD(DuplicateHandle)(
        THIS_
        IN ULONG64 InProcess,
        IN ULONG64 InHandle,
        IN ULONG64 OutProcess,
        IN ULONG DesiredAccess,
        IN ULONG Inherit,
        IN ULONG Options,
        OUT PULONG64 OutHandle
        );
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(ProtectVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG NewProtect,
        OUT PULONG OldProtect
        );
    STDMETHOD(AllocVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type,
        IN ULONG Protect,
        OUT PULONG64 AllocOffset
        );
    STDMETHOD(FreeVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type
        );
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    STDMETHOD(SuspendThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        );
    STDMETHOD(ResumeThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        );
    STDMETHOD(GetThreadStartAddress)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetContext)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Flags,
        IN ULONG FlagsOffset,
        OUT PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        );
    STDMETHOD(SetContext)(
        THIS_
        IN ULONG64 Thread,
        IN PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        );
    STDMETHOD(GetProcessDataOffset)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadDataOffset)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        );
    STDMETHOD(DescribeSelector)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Selector,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(GetCurrentTimeDateN)(
        THIS_
        OUT PULONG64 TimeDate
        );
    STDMETHOD(GetCurrentSystemUpTimeN)(
        THIS_
        OUT PULONG64 UpTime
        );
    STDMETHOD(GetProcessUpTimeN)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 UpTime
        );
    STDMETHOD(GetProcessTimes)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Create,
        OUT PULONG64 Exit,
        OUT PULONG64 Kernel,
        OUT PULONG64 User
        );
    STDMETHOD(GetThreadTimes)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Create,
        OUT PULONG64 Exit,
        OUT PULONG64 Kernel,
        OUT PULONG64 User
        );

    STDMETHOD(RequestBreakIn)(
        THIS_
        IN ULONG64 Process
        );
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Timeout,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(ContinueEvent)(
        THIS_
        IN ULONG ContinueStatus
        );
    STDMETHOD(InsertCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        OUT PVOID Storage,
        IN ULONG StorageSize
        );
    STDMETHOD(RemoveCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        IN PVOID Storage,
        IN ULONG StorageSize
        );
    STDMETHOD(InsertDataBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        IN ULONG64 Offset,
        IN ULONG AccessLength,
        IN ULONG AccessType,
        IN ULONG MachineType
        );
    STDMETHOD(RemoveDataBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        IN ULONG64 Offset,
        IN ULONG AccessLength,
        IN ULONG AccessType,
        IN ULONG MachineType
        );
    STDMETHOD(GetLastDataBreakpointHit)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        OUT PULONG64 Address,
        OUT PULONG AccessType
        );

    STDMETHOD(GetFunctionTableListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetOutOfProcessFunctionTableW)(
        THIS_
        IN ULONG64 Process,
        IN PWSTR Dll,
        IN ULONG64 LoadedDllHandle,
        IN ULONG64 Table,
        IN OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TableSize,
        OUT OPTIONAL PULONG64 UsedDllHandle
        );

    STDMETHOD(GetUnloadedModuleListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        );

    STDMETHOD(LoadLibrary)(
        THIS_
        IN PWSTR Path,
        OUT PULONG64 Handle
        );
    STDMETHOD(FreeLibrary)(
        THIS_
        IN ULONG64 Handle
        );

    // LiveUserDebugServices.
    ULONG m_ContextSize;
    ULONG m_SysProcInfoSize;
    BOOL m_Remote;
    ULONG m_EventProcessId;
    ULONG m_EventThreadId;
    ULONG m_PlatformId;
    BOOL m_Win95;
    HANDLE m_DebugObject;
    BOOL m_UseDebugObject;

    HRESULT SysGetProcessOptions(HANDLE Process, PULONG Options);
    HRESULT OpenDebugActiveProcess(ULONG ProcessId, HANDLE Process);
    HRESULT CreateDebugActiveProcess(ULONG ProcessId, HANDLE Process,
                                     ULONG AttachFlags);
};

// This global instance is intended for direct use only
// by routines which need a temporary local service instance.
extern LiveUserDebugServices g_LiveUserDebugServices;

#define SERVER_SERVICES(Server) \
    ((Server) != 0 ? (PUSER_DEBUG_SERVICES)(Server) : &g_LiveUserDebugServices)

// A client of the services can watch this variable to
// see if any instance has received an Uninitialize request.
extern ULONG g_UserServicesUninitialized;

#endif // #ifndef __DBGSVC_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\nt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifdef NT_NATIVE
#define _CRTIMP
#endif

#include <stdlib.h>
#include <stdio.h>

#ifndef _WIN32_WCE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <wcecompat.h>
#include <objbase.h>

#ifndef _WIN32_WCE
#define NOEXTAPI
#include <wdbgexts.h>
#include <dbgeng.h>
#include <ntdbg.h>
#else
#define DEBUG_NO_IMPLEMENTATION
#include "../published/dbgeng.w"
#endif
#include <dbgsvc.h>

#define NTDLL_APIS
#include <dllimp.h>
#include <cmnutil.hpp>

#include <dbgrpc.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\mds\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\dbgsvc.cpp ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <time.h>
#ifndef _WIN32_WCE
#include <comsvcs.h>
#else
#include <winver.h>
struct SYSTEM_PROCESS_INFORMATION
{
    PVOID Member;
};
typedef SYSTEM_PROCESS_INFORMATION *PSYSTEM_PROCESS_INFORMATION;
typedef struct _DBGUI_WAIT_STATE_CHANGE
{
    PVOID Member;
} DBGUI_WAIT_STATE_CHANGE;
#define ProcessDebugFlags 0
#define ProcessDebugObjectHandle 0
#define DebugObjectFlags 0
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)
#define PROCESS_DEBUG_INHERIT 0
#define DEBUG_KILL_ON_CLOSE 0
#endif

#include "dbgsvc.hpp"

#ifndef MONO_DBGSRV

// #include <winbasep.h>
extern "C" {
BOOL
WINAPI
CloseProfileUserMapping(
    VOID
    );
};
// winbasep.h

#else

#ifdef NT_NATIVE
#include <ntnative.h>
#endif

#define CloseProfileUserMapping()

#endif

// SYSTEM_PROCESS_INFORMATION can change in size, requiring
// different offsets to get to thread information.
#define NT4_SYSTEM_PROCESS_INFORMATION_SIZE 136
#define W2K_SYSTEM_PROCESS_INFORMATION_SIZE 184

#define SYSTEM_PROCESS_NAME "System Process"
#define SYSTEM_PROCESS_NAME_W L"System Process"
#define PEBLESS_PROCESS_NAME "System"
#define PEBLESS_PROCESS_NAME_W L"System"

ULONG g_UserServicesUninitialized;

//----------------------------------------------------------------------------
//
// UserDebugServices.
//
//----------------------------------------------------------------------------

UserDebugServices::UserDebugServices(void)
{
    m_Refs = 1;
    m_Initialized = FALSE;
    m_ClientIdentity[0] = 0;
    m_TransIdentity[0] = 0;
}

UserDebugServices::~UserDebugServices(void)
{
}

STDMETHODIMP
UserDebugServices::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;
    
    *Interface = NULL;
    Status = S_OK;

#ifdef _WIN32_WCE
    if (DbgIsEqualIID(InterfaceId, IID_IUnknown) ||
        DbgIsEqualIID(InterfaceId, __uuidof(IUserDebugServices)))
#else
    if (DbgIsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        DbgIsEqualIID(InterfaceId, __uuidof(IUserDebugServices)))
#endif
    {
        *Interface = (IUserDebugServices *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    if (Status == S_OK)
    {
        AddRef();
    }
    
    return Status;
}

STDMETHODIMP_(ULONG)
UserDebugServices::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
UserDebugServices::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        delete this;
    }
    return Refs;
}

HRESULT
UserDebugServices::Initialize(
    THIS_
    OUT PULONG Flags
    )
{
    m_Initialized = TRUE;
    *Flags = 0;
    return S_OK;
}

HRESULT
UserDebugServices::Uninitialize(
    THIS_
    IN BOOL Global
    )
{
    m_Initialized = FALSE;
    if (Global)
    {
        g_UserServicesUninitialized++;
    }
    return S_OK;
}

HRESULT
UserDebugServices::RpcInitialize(PSTR ClientIdentity, PSTR TransIdentity,
                                 PVOID* Interface)
{
    HRESULT Status;
    ULONG Flags;

    if ((Status = Initialize(&Flags)) != S_OK)
    {
        return Status;
    }
    
    *Interface = (IUserDebugServices*)this;
    CopyString(m_ClientIdentity, ClientIdentity, DIMA(m_ClientIdentity));
    CopyString(m_TransIdentity, TransIdentity, DIMA(m_TransIdentity));
    return S_OK;
}

void
UserDebugServices::RpcFinalize(void)
{
    // Take a reference on this object for the RPC client
    // thread to hold.
    AddRef();
}

void
UserDebugServices::RpcUninitialize(void)
{
    // Directly destroy the client object rather than releasing
    // as the remote client may have exited without politely
    // cleaning up references.
    delete this;
}

//----------------------------------------------------------------------------
//
// LiveUserDebugServices.
//
//----------------------------------------------------------------------------

// This global instance is intended for direct use only
// by routines which need a temporary local service instance.
LiveUserDebugServices g_LiveUserDebugServices(FALSE);

LiveUserDebugServices::LiveUserDebugServices(BOOL Remote)
{
    m_Remote = Remote;
    m_EventProcessId = 0;
    m_ContextSize = 0;
    m_SysProcInfoSize = 0;
    m_PlatformId = VER_PLATFORM_WIN32s;
    m_Win95 = FALSE;
    m_DebugObject = NULL;
}

LiveUserDebugServices::~LiveUserDebugServices(void)
{
    if (m_DebugObject != NULL)
    {
        g_NtDllCalls.NtClose(m_DebugObject);
    }
}

HRESULT
GetOsVerInfo(LPOSVERSIONINFOEXW OsVersionInfo, PBOOL WideCsd)
{
    *WideCsd = TRUE;
    ZeroMemory(OsVersionInfo, sizeof(*OsVersionInfo));
    OsVersionInfo->dwOSVersionInfoSize = sizeof(*OsVersionInfo);
#ifdef NT_NATIVE
    NTSTATUS NtStatus;

    if (!NT_SUCCESS(NtStatus = RtlGetVersion((LPOSVERSIONINFOW)OsVersionInfo)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }
#else
    if (!GetVersionExW((LPOSVERSIONINFOW)OsVersionInfo))
    {
        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            OSVERSIONINFOA InfoA;
            
            // Must be Win9x.
            ZeroMemory(&InfoA, sizeof(InfoA));
            InfoA.dwOSVersionInfoSize = sizeof(InfoA);
            if (!::GetVersionExA(&InfoA))
            {
                return WIN32_LAST_STATUS();
            }

            OsVersionInfo->dwMajorVersion = InfoA.dwMajorVersion;
            OsVersionInfo->dwMinorVersion = InfoA.dwMinorVersion;
            OsVersionInfo->dwBuildNumber = InfoA.dwBuildNumber;
            OsVersionInfo->dwPlatformId = InfoA.dwPlatformId;
            memcpy(OsVersionInfo->szCSDVersion, InfoA.szCSDVersion,
                   sizeof(InfoA.szCSDVersion));
            *WideCsd = FALSE;
        }
        else
        {
            // Try the plain info.
            OsVersionInfo->dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
            if (!GetVersionExW((LPOSVERSIONINFOW)OsVersionInfo))
            {
                return WIN32_LAST_STATUS();
            }
        }
    }
#endif
    return S_OK;
}

HRESULT
LiveUserDebugServices::Initialize(
    THIS_
    OUT PULONG Flags
    )
{
    HRESULT Status;
    OSVERSIONINFOEXW OsVersionInfo;
    BOOL WideCsd;

    if ((Status = GetOsVerInfo(&OsVersionInfo, &WideCsd)) != S_OK)
    {
        return Status;
    }

    ULONG BaseFlags;
        
    if ((Status = UserDebugServices::Initialize(&BaseFlags)) != S_OK)
    {
        return Status;
    }
    
    m_PlatformId = OsVersionInfo.dwPlatformId;

    // System structures may change size depending on the OS
    // version.  Pick the right size to use later.
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (OsVersionInfo.dwBuildNumber <= 1381)
        {
            m_SysProcInfoSize = NT4_SYSTEM_PROCESS_INFORMATION_SIZE;
        }
        else if (OsVersionInfo.dwBuildNumber <= 2195)
        {
            m_SysProcInfoSize = W2K_SYSTEM_PROCESS_INFORMATION_SIZE;
        }
        else
        {
            m_SysProcInfoSize = sizeof(SYSTEM_PROCESS_INFORMATION);
        }
    }
    else if (m_PlatformId == VER_PLATFORM_WIN32_WINDOWS &&
             (OsVersionInfo.dwBuildNumber & 0xffff) < 1998)
    {
        m_Win95 = TRUE;
    }

    // If the direct NT debugging APIs are available use them
    // as they offer more flexibility.
    if (g_NtDllCalls.DbgUiSetThreadDebugObject != NULL)
    {
        // The NtWait/Continue APIs do not automatically manage
        // process and thread handles so the caller must close them.
        BaseFlags |= DBGSVC_CLOSE_PROC_THREAD_HANDLES;
        m_UseDebugObject = TRUE;
    }
    else
    {
        m_UseDebugObject = FALSE;
    }
    
    *Flags = BaseFlags | DBGSVC_GENERIC_CODE_BREAKPOINTS |
        DBGSVC_GENERIC_DATA_BREAKPOINTS;
    return S_OK;
}

HRESULT
LiveUserDebugServices::Uninitialize(
    THIS_
    IN BOOL Global
    )
{
    HRESULT Status;
    
    if ((Status = UserDebugServices::Uninitialize(Global)) != S_OK)
    {
        return Status;
    }
    
    m_Remote = FALSE;
    m_EventProcessId = 0;
    m_ContextSize = 0;
    m_PlatformId = VER_PLATFORM_WIN32s;
    m_Win95 = FALSE;
    if (m_DebugObject != NULL)
    {
        ::CloseHandle(m_DebugObject);
        m_DebugObject = NULL;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetTargetInfo(
    THIS_
    OUT PULONG MachineType,
    OUT PULONG NumberProcessors,
    OUT PULONG PlatformId,
    OUT PULONG BuildNumber,
    OUT PULONG CheckedBuild,
    OUT PSTR CsdString,
    IN ULONG CsdStringSize,
    OUT PSTR BuildString,
    IN ULONG BuildStringSize,
    OUT PULONG ProductType,
    OUT PULONG SuiteMask
    )
{
    HRESULT Status;
    OSVERSIONINFOEXW OsVersionInfo;
    BOOL WideCsd;

    if ((Status = GetOsVerInfo(&OsVersionInfo, &WideCsd)) != S_OK)
    {
        return Status;
    }

    ULONG ProcArch, NumProc;
    
#ifdef NT_NATIVE
    NTSTATUS NtStatus;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcInfo;
    
    if (!NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemBasicInformation,
                                             &BasicInfo, sizeof(BasicInfo),
                                             NULL)) ||
        !NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemProcessorInformation,
                                             &ProcInfo, sizeof(ProcInfo),
                                             NULL)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    ProcArch = ProcInfo.ProcessorArchitecture;
    NumProc = BasicInfo.NumberOfProcessors;
#else
    SYSTEM_INFO SystemInfo;

    ::GetSystemInfo(&SystemInfo);
    ProcArch = SystemInfo.wProcessorArchitecture;
    NumProc = SystemInfo.dwNumberOfProcessors;
#endif
    
    switch(ProcArch)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *MachineType = IMAGE_FILE_MACHINE_I386;
        switch(OsVersionInfo.dwPlatformId)
        {
#ifndef _WIN32_WCE
        case VER_PLATFORM_WIN32_NT:
            if (OsVersionInfo.dwBuildNumber <= 1381)
            {
                m_ContextSize = sizeof(X86_CONTEXT);
            }
            else
            {
                m_ContextSize = sizeof(X86_NT5_CONTEXT);
            }
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            // Win9x prior to Win98SE didn't support the extended context.
            if ((OsVersionInfo.dwBuildNumber & 0xffff) <= 1998)
            {
                m_ContextSize = sizeof(X86_CONTEXT);
            }
            else
            {
                m_ContextSize = sizeof(X86_NT5_CONTEXT);
            }
            break;
        default:
            // Assume all other platforms only support the basic x86 context.
            m_ContextSize = sizeof(X86_CONTEXT);
            break;
#endif // #ifndef _WIN32_WCE
        case VER_PLATFORM_WIN32_CE:
            m_ContextSize = sizeof(CONTEXT);
            break;
        }
        break;
#ifndef _WIN32_WCE
    case PROCESSOR_ARCHITECTURE_ALPHA:
        *MachineType = IMAGE_FILE_MACHINE_ALPHA;
        // The "NT5" is a misnomer, this context
        // applies to all versions.
        m_ContextSize = sizeof(ALPHA_NT5_CONTEXT);
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        *MachineType = IMAGE_FILE_MACHINE_AXP64;
        m_ContextSize = sizeof(ALPHA_NT5_CONTEXT);
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        *MachineType = IMAGE_FILE_MACHINE_IA64;
        m_ContextSize = sizeof(IA64_CONTEXT);
        break;
    case PROCESSOR_ARCHITECTURE_AMD64:
        *MachineType = IMAGE_FILE_MACHINE_AMD64;
        m_ContextSize = sizeof(AMD64_CONTEXT);
        break;
#endif // #ifndef _WIN32_WCE
    case PROCESSOR_ARCHITECTURE_ARM:
        *MachineType = IMAGE_FILE_MACHINE_ARM;
#ifndef _WIN32_WCE
        m_ContextSize = sizeof(ARM_CONTEXT);
#else
        m_ContextSize = sizeof(CONTEXT);
#endif
        break;
    default:
        return E_UNEXPECTED;
    }

    *NumberProcessors = NumProc;
    *PlatformId = OsVersionInfo.dwPlatformId;
    *BuildNumber = OsVersionInfo.dwBuildNumber;
    *CheckedBuild = 0;
    if (WideCsd)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, OsVersionInfo.szCSDVersion, -1,
                                 CsdString, CsdStringSize, NULL, NULL))
        {
            CsdString[0] = 0;
        }
    }
    else
    {
        CopyString(CsdString, (PSTR)OsVersionInfo.szCSDVersion, CsdStringSize);
    }
    BuildString[0] = 0;
    *ProductType = OsVersionInfo.wProductType;
    *SuiteMask = OsVersionInfo.wSuiteMask;

#ifndef NT_NATIVE
    if (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId)
    {
        HKEY hkey = NULL;
        TCHAR sz[40] = {0};
        DWORD dwType;
        DWORD dwSize = sizeof(sz);

        if (ERROR_SUCCESS ==
            RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "Software\\Microsoft\\Windows NT\\CurrentVersion",
                         0,
                         KEY_READ,
                         &hkey))
        {
            if (ERROR_SUCCESS ==
                RegQueryValueEx(hkey,
                                "CurrentType",
                                NULL,
                                &dwType,
                                (PUCHAR) sz,
                                &dwSize))
            {
                if (*sz)
                {
                    _strlwr(sz);
                    if (strstr(sz, "checked"))
                    {
                        *CheckedBuild = 0xC;
                    }
                }
            }

            RegCloseKey(hkey);
        }

        if (OsVersionInfo.dwBuildNumber > 2195)
        {
            char RawString[128];
            
            // Look up the file version string for a system DLL to
            // try and get the build lab information.
            strcpy(RawString, "kernel32.dll version: ");
            GetFileStringFileInfo(L"kernel32.dll", "FileVersion",
                                  RawString + strlen(RawString),
                                  sizeof(RawString) - strlen(RawString));
            CopyString(BuildString, RawString, BuildStringSize);
        }
    }
#endif // #ifndef NT_NATIVE

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetConnectionInfo(
    THIS_
    OUT OPTIONAL PSTR MachineName,
    IN ULONG MachineNameSize,
    OUT OPTIONAL PSTR ClientIdentity,
    IN ULONG ClientIdentitySize,
    OUT OPTIONAL PSTR TransportIdentity,
    IN ULONG TransportIdentitySize
    )
{
    HRESULT Status = S_OK;
    
    if (MachineName)
    {
#if defined(NT_NATIVE) || defined(_WIN32_WCE)
        if (FillStringBuffer("<ComputerName>", 0,
                             MachineName, MachineNameSize,
                             NULL) == S_FALSE)
        {
            Status = S_FALSE;
        }
#else
        ULONG CompSize;

        CompSize = MachineNameSize;
        if (!GetComputerName(MachineName, &CompSize))
        {
            return WIN32_LAST_STATUS();
        }
#endif
    }

    if (ClientIdentity)
    {
        if (FillStringBuffer(m_ClientIdentity, 0,
                             ClientIdentity, ClientIdentitySize,
                             NULL) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }

    if (TransportIdentity)
    {
        if (FillStringBuffer(m_TransIdentity, 0,
                             TransportIdentity, TransportIdentitySize,
                             NULL) == S_FALSE)
        {
            Status = S_FALSE;
        }
    }

    return Status;
}

BOOL
X86CpuId(
    IN ULONG SubFunction,
    OUT PULONG EaxRegister,
    OUT PULONG EbxRegister,
    OUT PULONG EcxRegister,
    OUT PULONG EdxRegister
    )
{
#ifdef _X86_
    ULONG _Eax;
    ULONG _Ebx;
    ULONG _Ecx;
    ULONG _Edx;

    __asm
    {
        ; Preserve ebx as its value will be changed by cpuid.
        push ebx
            
        mov eax, SubFunction
                
        __emit 0x0F
        __emit 0xA2  ;; CPUID

        mov _Eax, eax
        mov _Ebx, ebx
        mov _Ecx, ecx
        mov _Edx, edx

        pop ebx
    }

    *EaxRegister = _Eax;
    *EbxRegister = _Ebx;
    *EcxRegister = _Ecx;
    *EdxRegister = _Edx;

    return TRUE;
#else
    return FALSE;
#endif // #ifdef _X86_
}

BOOL
Ia64CpuId(ULONG Reg, PULONG64 Val)
{
    // XXX drewb - How should this be implemented?
#if defined(_IA64_) && defined(IA64_INLINE_ASSEMBLY)
    ULONG64 _Val;

    __asm mov t0, Reg;
    __asm mov _Val, cpuid[t0];
    *Val = _Val;
    return TRUE;
#else
    return FALSE;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessorId(
    THIS_
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BufferUsed
    )
{
    if (BufferSize < sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALL))
    {
        return E_INVALIDARG;
    }

    ZeroMemory(Buffer, sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALL));

    ULONG ProcArch, ProcLevel, ProcRevision;
    
#ifdef NT_NATIVE
    NTSTATUS NtStatus;
    SYSTEM_PROCESSOR_INFORMATION ProcInfo;
    
    if (!NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemProcessorInformation,
                                             &ProcInfo, sizeof(ProcInfo),
                                             NULL)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    ProcArch = ProcInfo.ProcessorArchitecture;
    ProcLevel = ProcInfo.ProcessorLevel;
    ProcRevision = ProcInfo.ProcessorRevision;
#else
    SYSTEM_INFO SystemInfo;

    ::GetSystemInfo(&SystemInfo);
    ProcArch = SystemInfo.wProcessorArchitecture;
    ProcLevel = SystemInfo.wProcessorLevel;
    ProcRevision = SystemInfo.wProcessorRevision;
#endif
    
    PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id =
        (PDEBUG_PROCESSOR_IDENTIFICATION_ALL)Buffer;

    switch(ProcArch)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_X86);
        Id->X86.Family = ProcLevel;
        Id->X86.Model = (ProcRevision >> 8) & 0xf;
        Id->X86.Stepping = ProcRevision & 0xf;

        if (ProcLevel >= 5)
        {
            ULONG Eax, Ebx, Ecx, Edx;

            if (X86CpuId(0, &Eax, &Ebx, &Ecx, &Edx))
            {
                *(PULONG)(Id->X86.VendorString + 0 * sizeof(ULONG)) = Ebx;
                *(PULONG)(Id->X86.VendorString + 1 * sizeof(ULONG)) = Edx;
                *(PULONG)(Id->X86.VendorString + 2 * sizeof(ULONG)) = Ecx;
            }
        }
        break;

#ifndef _WIN32_WCE
        
    case PROCESSOR_ARCHITECTURE_ALPHA:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALPHA);
        Id->Alpha.Type = ProcLevel;
        Id->Alpha.Revision = ProcRevision;
        break;
        
    case PROCESSOR_ARCHITECTURE_IA64:
        ULONG64 Val;

        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_IA64);
        Id->Ia64.Model = ProcLevel;
        Id->Ia64.Revision = ProcRevision;

        if (Ia64CpuId(3, &Val))
        {
            Id->Ia64.ArchRev = (ULONG)((Val >> 32) & 0xff);
            Id->Ia64.Family = (ULONG)((Val >> 24) & 0xff);
            Ia64CpuId(0, (PULONG64)
                      (Id->Ia64.VendorString + 0 * sizeof(ULONG64)));
            Ia64CpuId(1, (PULONG64)
                      (Id->Ia64.VendorString + 1 * sizeof(ULONG64)));
        }
        break;
        
    case PROCESSOR_ARCHITECTURE_AMD64:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_AMD64);
        Id->Amd64.Family = ProcLevel;
        Id->Amd64.Model = (ProcRevision >> 8) & 0xf;
        Id->Amd64.Stepping = ProcRevision & 0xf;
        break;
        
#endif // #ifndef _WIN32_WCE

    case PROCESSOR_ARCHITECTURE_ARM:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ARM);
        Id->Arm.Type = ProcLevel;
        Id->Arm.Revision = ProcRevision;
        break;
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetGenericProcessorFeatures(
    THIS_
    OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
    IN ULONG FeaturesSize,
    OUT OPTIONAL PULONG Used
    )
{
    ULONG ChunkIndex, BitIndex;
    PULONG64 ChunkBits;
    ULONG Max;

    //
    // IsProcessorFeaturePresent doesn't have a fixed upper
    // limit so we can't easily say how many bits are
    // needed.  Right now there are only 11 feature bits
    // defined, though, so guessing 128 should give
    // plenty of room for expansion.
    //
    
    Max = 128 / sizeof(*Features);
    
    if (Used)
    {
        *Used = Max;
    }

    if (Features)
    {
        //
        // Fill in as many bits as were provided, up to the maximum.
        //
        
        if (FeaturesSize > Max)
        {
            FeaturesSize = Max;
        }

        ChunkBits = Features;
        for (ChunkIndex = 0; ChunkIndex < FeaturesSize; ChunkIndex++)
        {
            *ChunkBits = 0;
            for (BitIndex = 0; BitIndex < 8 * sizeof(*Features); BitIndex++)
            {
                ULONG PfIndex = ChunkIndex * sizeof(*Features) + BitIndex;
#ifdef NT_NATIVE
                if (USER_SHARED_DATA->ProcessorFeatures[PfIndex])
#else
                if (::IsProcessorFeaturePresent(PfIndex))
#endif
                {
                    *ChunkBits |= 1UI64 << BitIndex;
                }
            }
            ChunkBits++;
        }
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetSpecificProcessorFeatures(
    THIS_
    OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
    IN ULONG FeaturesSize,
    OUT OPTIONAL PULONG Used
    )
{
#ifdef _X86_

    ULONG Count = 0;
    ULONG Eax, Ebx, Ecx, Edx;
    BOOL Amd = FALSE;

    if (!Features)
    {
        FeaturesSize = 0;
    }
    
    //
    // x86 indices are:
    // 0 = CPUID version information.
    // 1 = CPUID feature information.
    // 2 = Extended feature information.
    //

    if (!X86CpuId(0, &Eax, &Ebx, &Ecx, &Edx))
    {
        return E_FAIL;
    }

    if (Ebx == AMD_VENDOR_ID_EBX &&
        Edx == AMD_VENDOR_ID_EDX &&
        Ecx == AMD_VENDOR_ID_ECX)
    {
        Amd = TRUE;
    }
        
    if (!X86CpuId(1, &Eax, &Ebx, &Ecx, &Edx))
    {
        return E_FAIL;
    }

    Count += 2;
    if (FeaturesSize > 0)
    {
        *Features++ = Eax;
        FeaturesSize--;
    }
    if (FeaturesSize > 0)
    {
        *Features++ = Edx;
        FeaturesSize--;
    }

    if (Amd)
    {
        if (!X86CpuId(0x80000001, &Eax, &Ebx, &Ecx, &Edx))
        {
            return E_FAIL;
        }

        Count++;
        if (FeaturesSize > 0)
        {
            *Features++ = Edx;
            FeaturesSize--;
        }
    }
    
    if (Used)
    {
        *Used = Count;
    }

    return S_OK;
    
#else // #ifdef _X86_

    return E_NOINTERFACE;

#endif
}

STDMETHODIMP
LiveUserDebugServices::GetFileVersionInformationA(
    THIS_
    IN PCWSTR File,
    IN PCSTR Item,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG VerInfoSize
    )
{
#ifndef NT_NATIVE
    PVOID AllInfo = GetAllFileVersionInfo(File);
    if (AllInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT Status;
    PVOID Val;
    UINT ValSize;

    if (VerQueryValue(AllInfo, (PSTR)Item, &Val, &ValSize))
    {
        Status = FillDataBuffer(Val, ValSize,
                                Buffer, BufferSize, VerInfoSize);
    }
    else
    {
        Status = WIN32_LAST_STATUS();
    }

    free(AllInfo);
    return Status;
#else // #ifndef NT_NATIVE
    return E_UNEXPECTED;
#endif // #ifndef NT_NATIVE
}

HRESULT
GetNtSystemProcessInformation(PSYSTEM_PROCESS_INFORMATION* ProcInfo)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS NtStatus;
    PVOID Buffer;
    SIZE_T BufferSize = 8192;

    for (;;)
    {
        Buffer = NULL;
        NtStatus = g_NtDllCalls.
            NtAllocateVirtualMemory(NtCurrentProcess(),
                                    &Buffer, 0, &BufferSize,
                                    MEM_COMMIT, PAGE_READWRITE);
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }

        NtStatus = g_NtDllCalls.
            NtQuerySystemInformation(SystemProcessInformation,
                                     Buffer, (ULONG)BufferSize, NULL);
        if (NT_SUCCESS(NtStatus))
        {
            break;
        }
        
        g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                         &Buffer, &BufferSize, MEM_RELEASE);
        if (NtStatus == STATUS_INFO_LENGTH_MISMATCH)
        {
            BufferSize += 8192;
        }
        else
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }

    *ProcInfo = (PSYSTEM_PROCESS_INFORMATION)Buffer;
    return S_OK;
#endif // #ifndef _WIN32_WCE
}

HRESULT
NtGetProcessIds(PULONG Ids, ULONG Count, PULONG ActualCount)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;

    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;
    ULONG ProcessCount;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    ProcessCount = 0;
    for (;;)
    {
        if (ProcessCount < Count)
        {
            Ids[ProcessCount] = (ULONG)(ULONG_PTR)ProcessInfo->UniqueProcessId;
        }

        ProcessCount++;

        if (ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    if (ActualCount != NULL)
    {
        *ActualCount = ProcessCount;
    }

    SIZE_T MemSize = 0;
    
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
#endif // #ifndef _WIN32_WCE
}

HRESULT
ThGetProcessIds(PULONG Ids, ULONG Count, PULONG ActualCount)
{
#ifndef NT_NATIVE
    HANDLE Snap;

    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    ULONG ProcessCount = 0;

    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (ProcessCount == 0)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        if (ProcessCount < Count)
        {
            Ids[ProcessCount] = Proc.th32ProcessID;
        }

        ProcessCount++;
    }
                
    if (ActualCount != NULL)
    {
        *ActualCount = ProcessCount;
    }

    CloseHandle(Snap);
    return S_OK;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessIds(
    THIS_
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Count,
    OUT OPTIONAL PULONG ActualCount
    )
{
    HRESULT Status;

    // Allow privileged enumeration.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetProcessIds(Ids, Count, ActualCount);
    case VER_PLATFORM_WIN32_WINDOWS:
    case VER_PLATFORM_WIN32_CE:
        return ThGetProcessIds(Ids, Count, ActualCount);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
NtGetPidByExe(PCWSTR ExeName, ULONG Flags, PULONG Id)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT Status;
    BOOL HasPath;

    // Check if the given name has path components.
    HasPath =
        wcschr(ExeName, '\\') != NULL ||
        wcschr(ExeName, '/') != NULL ||
        (ExeName[0] && ExeName[1] == ':');
    
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;

    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;
    ULONG FoundId;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    FoundId = DEBUG_ANY_ID;
    Status = E_NOINTERFACE;
    for (;;)
    {
        PWSTR ImageName;
        
        if (ProcessInfo->ImageName.Buffer == NULL)
        {
            ImageName = SYSTEM_PROCESS_NAME_W;
        }
        else
        {
            ImageName = ProcessInfo->ImageName.Buffer;
        }
        if ((Flags & DEBUG_GET_PROC_FULL_MATCH) == 0 &&
            !HasPath)
        {
            PWSTR Slash;
            
            Slash = wcsrchr(ImageName, '\\');
            if (Slash == NULL)
            {
                Slash = wcsrchr(ImageName, '/');
            }
            if (Slash != NULL)
            {
                ImageName = Slash + 1;
            }
        }

        if (!_wcsicmp(ImageName, ExeName))
        {
            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) &&
                FoundId != DEBUG_ANY_ID)
            {
                Status = S_FALSE;
                break;
            }
            
            Status = S_OK;
            FoundId = (ULONG)(ULONG_PTR)ProcessInfo->UniqueProcessId;
            *Id = FoundId;

            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) == 0)
            {
                break;
            }
        }

        if (ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    SIZE_T MemSize = 0;
    
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
#endif // #ifndef _WIN32_WCE
}

HRESULT
ThGetPidByExe(PCWSTR ExeName, ULONG Flags, PULONG Id)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;
    char ExeNameA[MAX_PATH];

    if (!WideCharToMultiByte(CP_ACP, 0, ExeName, -1,
                             ExeNameA, sizeof(ExeNameA),
                             NULL, NULL))
    {
        return WIN32_LAST_STATUS();
    }
    
    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    // Check if the given name has path components.
    BOOL HasPath =
        strchr(ExeNameA, '\\') != NULL ||
        strchr(ExeNameA, '/') != NULL ||
        (ExeNameA[0] && ExeNameA[1] == ':');

    ULONG FoundId = DEBUG_ANY_ID;
    BOOL First = TRUE;
    
    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (First)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        PSTR ImageName = Proc.szExeFile;
        
        if ((Flags & DEBUG_GET_PROC_FULL_MATCH) == 0 &&
            !HasPath)
        {
            PSTR Slash;
            
            Slash = strrchr(ImageName, '\\');
            if (Slash == NULL)
            {
                Slash = strrchr(ImageName, '/');
            }
            if (Slash != NULL)
            {
                ImageName = Slash + 1;
            }
        }

        if (!_stricmp(ImageName, ExeNameA))
        {
            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) &&
                FoundId != DEBUG_ANY_ID)
            {
                Status = S_FALSE;
                break;
            }
            
            Status = S_OK;
            FoundId = Proc.th32ProcessID;
            *Id = FoundId;

            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) == 0)
            {
                break;
            }
        }
    }
                
    CloseHandle(Snap);
    return S_OK;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessIdByExecutableNameW(
    THIS_
    IN PCWSTR ExeName,
    IN ULONG Flags,
    OUT PULONG Id
    )
{
    HRESULT Status;

    // Allow privileged enumeration.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }
    
    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetPidByExe(ExeName, Flags, Id);
    case VER_PLATFORM_WIN32_WINDOWS:
    case VER_PLATFORM_WIN32_CE:
        return ThGetPidByExe(ExeName, Flags, Id);
    default:
        return E_UNEXPECTED;
    }
}

#if !defined(NT_NATIVE) && !defined(_WIN32_WCE)

HRESULT
NtGetServiceStatus(PULONG NumServices,
                   LPENUM_SERVICE_STATUS_PROCESSW* ServiceStatus)
{
    SC_HANDLE Scm;

    Scm = g_Advapi32Calls.OpenSCManagerW(NULL, NULL,
                                         SC_MANAGER_CONNECT |
                                         SC_MANAGER_ENUMERATE_SERVICE);
    if (!Scm)
    {
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;
    LPENUM_SERVICE_STATUS_PROCESSW Info;
    ULONG InfoSize = 8 * 1024;
    ULONG ExtraNeeded;
    ULONG Resume;
    ULONG Loop = 0;

    //
    // First pass through the loop allocates from an initial guess.
    // If that isn't sufficient, we make another pass and allocate
    // what is actually needed.  Things may have changed due to
    // other machine changes, so loop around a few times before
    // giving up.
    //
    
    for (;;)
    {
        Info = (LPENUM_SERVICE_STATUS_PROCESSW)malloc(InfoSize);
        if (!Info)
        {
            Status = E_OUTOFMEMORY;
            break;
        }

        Resume = 0;
        if (!g_Advapi32Calls.EnumServicesStatusExW(Scm,
                                                   SC_ENUM_PROCESS_INFO,
                                                   SERVICE_WIN32,
                                                   SERVICE_ACTIVE,
                                                   (LPBYTE)Info,
                                                   InfoSize,
                                                   &ExtraNeeded,
                                                   NumServices,
                                                   &Resume,
                                                   NULL))
        {
            free(Info);
            
            if (Loop > 2 || GetLastError() != ERROR_MORE_DATA)
            {
                Status = WIN32_LAST_STATUS();
                break;
            }
        }
        else
        {
            *ServiceStatus = Info;
            Status = S_OK;
            break;
        }
        
        InfoSize += ExtraNeeded;
        Loop++;
    }

    CloseServiceHandle(Scm);
    return Status;
}

HRESULT
NtGetProcessServiceNames(HRESULT RetStatus, ULONG ProcessId,
                         PWSTR* Description, ULONG* DescriptionSize,
                         PULONG ActualDescriptionSize, PBOOL Any)
{
    HRESULT Status;
    
    if (!g_Advapi32Calls.EnumServicesStatusExW ||
        !g_Advapi32Calls.OpenSCManagerW)
    {
        return RetStatus;
    }

    ULONG i, NumServices;
    LPENUM_SERVICE_STATUS_PROCESSW ServiceStatus;
    BOOL AnyServices = FALSE;

    if ((Status = NtGetServiceStatus(&NumServices, &ServiceStatus)) != S_OK)
    {
        // If we can't get the service status just leave the
        // string unchanged and do not consider it a serious error.
        return RetStatus;
    }

    for (i = 0; i < NumServices; i++)
    {
        if (ServiceStatus[i].ServiceStatusProcess.dwProcessId != ProcessId ||
            !ServiceStatus[i].lpServiceName ||
            !ServiceStatus[i].lpServiceName[0])
        {
            continue;
        }

        PWSTR Intro;

        if (AnyServices)
        {
            Intro = L",";
        }
        else if (*Any)
        {
            Intro = L"  Services: ";
        }
        else
        {
            Intro = L"Services: ";
        }

        RetStatus = AppendToStringBufferW(RetStatus, Intro, !*Any,
                                          Description, DescriptionSize,
                                          ActualDescriptionSize);
        RetStatus = AppendToStringBufferW(RetStatus,
                                          ServiceStatus[i].lpServiceName,
                                          FALSE, Description, DescriptionSize,
                                          ActualDescriptionSize);

        *Any = TRUE;
        AnyServices = TRUE;
    }

    free(ServiceStatus);
    return RetStatus;
}

HRESULT
NtGetProcessMtsPackageNames(HRESULT RetStatus, ULONG ProcessId,
                            PWSTR* Description, ULONG* DescriptionSize,
                            PULONG ActualDescriptionSize, PBOOL Any)
{
    HRESULT Status;
    
    // Load and initialize ole32.dll so we can call CoCreateInstance.
    if ((Status = InitDynamicCalls(&g_Ole32CallsDesc)) != S_OK ||
        (Status = InitDynamicCalls(&g_OleAut32CallsDesc)) != S_OK ||
        FAILED(Status = g_Ole32Calls.CoInitializeEx(NULL, COM_THREAD_MODEL)))
    {
        // Just leave things unchanged on failure.
        return RetStatus;
    }

    IMtsGrp* MtsGrp = NULL;
    long Packages;
    long i;
    BOOL AnyPackages = FALSE;

    if ((Status = g_Ole32Calls.
         CoCreateInstance(CLSID_MtsGrp, NULL, CLSCTX_ALL,
                          __uuidof(IMtsGrp), (void **)&MtsGrp)) != S_OK ||
        (Status = MtsGrp->Refresh()) != S_OK ||
        (Status = MtsGrp->get_Count(&Packages)) != S_OK)
    {
        goto Exit;
    }
        
    for (i = 0; i < Packages; i++)
    {
        IUnknown* Unk;
        IMtsEvents* Events;
        BSTR Name;
        ULONG Pid;
        
        if ((Status = MtsGrp->Item(i, &Unk)) != S_OK)
        {
            continue;
        }

        Status = Unk->QueryInterface(IID_IMtsEvents, (void **)&Events);

        Unk->Release();

        if (Status != S_OK)
        {
            continue;
        }
        
        Status = Events->GetProcessID((PLONG)&Pid);
        if (Status == S_OK && Pid == ProcessId)
        {
            Status = Events->get_PackageName(&Name);
        }

        Events->Release();

        if (Status != S_OK || Pid != ProcessId)
        {
            continue;
        }

        PWSTR Intro;

        if (AnyPackages)
        {
            Intro = L",";
        }
        else if (*Any)
        {
            Intro = L"  MTS Packages: ";
        }
        else
        {
            Intro = L"MTS Packages: ";
        }

        RetStatus = AppendToStringBufferW(RetStatus, Intro, !*Any,
                                          Description, DescriptionSize,
                                          ActualDescriptionSize);
        RetStatus = AppendToStringBufferW(RetStatus, Name, FALSE,
                                          Description, DescriptionSize,
                                          ActualDescriptionSize);

        g_OleAut32Calls.SysFreeString(Name);

        *Any = TRUE;
        AnyPackages = TRUE;
    }

 Exit:
    if (MtsGrp)
    {
        MtsGrp->Release();
    }
    g_Ole32Calls.CoUninitialize();
    return RetStatus;
}

#endif // if !defined(NT_NATIVE) && !defined(_WIN32_WCE)

HRESULT
NtGetProcessCommandLine(HRESULT RetStatus, HANDLE Process,
                        PUNICODE_STRING ParamsCmdLine,
                        PWSTR* Description, ULONG* DescriptionSize,
                        PULONG ActualDescriptionSize, PBOOL Any)
{
    PWSTR FullStr;
    PWSTR Intro;
    SIZE_T Done;

    if (!ParamsCmdLine->Buffer)
    {
        return RetStatus;
    }

    FullStr = (PWSTR)malloc(ParamsCmdLine->Length + sizeof(*FullStr));
    if (!FullStr)
    {
        return RetStatus;
    }

    if (!::ReadProcessMemory(Process, ParamsCmdLine->Buffer,
                             FullStr, ParamsCmdLine->Length, &Done) ||
        Done < sizeof(*FullStr))
    {
        goto EH_FullStr;
    }

    FullStr[Done / sizeof(*FullStr)] = 0;
    
    if (*Any)
    {
        Intro = L"  Command Line: ";
    }
    else
    {
        Intro = L"Command Line: ";
    }

    RetStatus = AppendToStringBufferW(RetStatus, Intro, !*Any,
                                      Description, DescriptionSize,
                                      ActualDescriptionSize);
    RetStatus = AppendToStringBufferW(RetStatus, FullStr, FALSE,
                                      Description, DescriptionSize,
                                      ActualDescriptionSize);

    *Any = TRUE;

 EH_FullStr:
    free(FullStr);
    return RetStatus;
}

HRESULT
NtGetProcDesc(ULONG ProcessId, ULONG Flags,
              PWSTR ExeName, ULONG ExeNameSize, PULONG ActualExeNameSize,
              PWSTR Description, ULONG DescriptionSize,
              PULONG ActualDescriptionSize)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT Status;

    if (ProcessId == 0)
    {
        // This is base system process so fake the description.
        Status = FillStringBufferW(SYSTEM_PROCESS_NAME_W, 0,
                                   ExeName, ExeNameSize, ActualExeNameSize);
        FillStringBufferW(L"", 0,
                          Description, DescriptionSize, ActualDescriptionSize);
        return Status;
    }
    
    NTSTATUS NtStatus;
    HANDLE Process;

    OBJECT_ATTRIBUTES ObjAttr;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = (HANDLE)(ULONG_PTR)ProcessId;
    InitializeObjectAttributes(&ObjAttr, NULL, 0, NULL, NULL);
    NtStatus = g_NtDllCalls.NtOpenProcess(&Process, PROCESS_ALL_ACCESS,
                                          &ObjAttr, &ClientId);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Exit;
    }

    PROCESS_BASIC_INFORMATION ProcBasic;
    ULONG Done;
    
    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(Process, ProcessBasicInformation,
                                  &ProcBasic, sizeof(ProcBasic), &Done);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Process;
    }
    if (Done != sizeof(ProcBasic))
    {
        Status = E_FAIL;
        goto EH_Process;
    }

    if (ProcBasic.PebBaseAddress == 0)
    {
        // This process has no PEB so fake the description.
        Status = FillStringBufferW(PEBLESS_PROCESS_NAME_W, 0,
                                   ExeName, ExeNameSize, ActualExeNameSize);
        FillStringBufferW(L"", 0,
                          Description, DescriptionSize, ActualDescriptionSize);
        goto EH_Process;
    }
    
    PEB Peb;
    SIZE_T DoneSize;

    if (!::ReadProcessMemory(Process, ProcBasic.PebBaseAddress,
                             &Peb, sizeof(Peb), &DoneSize))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Process;
    }
    if (DoneSize != sizeof(Peb))
    {
        Status = E_FAIL;
        goto EH_Process;
    }

    RTL_USER_PROCESS_PARAMETERS Params;

    if (!::ReadProcessMemory(Process, Peb.ProcessParameters,
                             &Params, sizeof(Params), &DoneSize))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Process;
    }
    if (DoneSize != sizeof(Params))
    {
        Status = E_FAIL;
        goto EH_Process;
    }
    
    if (Params.ImagePathName.Buffer != NULL)
    {
        ULONG Len;
        PWSTR ImagePath;
        PWSTR ImageName;

        Len = (Params.ImagePathName.Length + 1) * sizeof(WCHAR);
        ImagePath = (PWSTR)malloc(Len);
        if (ImagePath == NULL)
        {
            Status = E_OUTOFMEMORY;
            goto EH_Process;
        }

        if (!::ReadProcessMemory(Process, Params.ImagePathName.Buffer,
                                 ImagePath, Len, &DoneSize))
        {
            Status = WIN32_LAST_STATUS();
            free(ImagePath);
            goto EH_Process;
        }
        if (DoneSize < Len)
        {
            Status = E_FAIL;
            free(ImagePath);
            goto EH_Process;
        }
        
        if (Flags & DEBUG_PROC_DESC_NO_PATHS)
        {
            ImageName = wcsrchr(ImagePath, '\\');
            if (ImageName == NULL)
            {
                ImageName = wcsrchr(ImagePath, '/');
            }
            if (ImageName == NULL)
            {
                ImageName = ImagePath;
            }
            else
            {
                ImageName++;
            }
        }
        else
        {
            ImageName = ImagePath;
        }
        
        Status = FillStringBufferW(ImageName, 0,
                                   ExeName, ExeNameSize, ActualExeNameSize);

        free(ImagePath);
    }
    else
    {
        Status = FillStringBufferW(SYSTEM_PROCESS_NAME_W, 0,
                                   ExeName, ExeNameSize, ActualExeNameSize);
    }

#ifndef NT_NATIVE
    if ((Description && DescriptionSize) || ActualDescriptionSize)
    {
        BOOL Any = FALSE;

        if (!(Flags & DEBUG_PROC_DESC_NO_SERVICES))
        {
            Status = NtGetProcessServiceNames(Status, ProcessId,
                                              &Description, &DescriptionSize,
                                              ActualDescriptionSize, &Any);
        }
        if (!(Flags & DEBUG_PROC_DESC_NO_SERVICES))
        {
            Status = NtGetProcessMtsPackageNames(Status, ProcessId,
                                                 &Description,
                                                 &DescriptionSize,
                                                 ActualDescriptionSize, &Any);
        }
        if (!(Flags & DEBUG_PROC_DESC_NO_COMMAND_LINE))
        {
            Status = NtGetProcessCommandLine(Status, Process,
                                             &Params.CommandLine,
                                             &Description,
                                             &DescriptionSize,
                                             ActualDescriptionSize, &Any);
        }
        if (!Any)
        {
            if (FillStringBufferW(L"", 0,
                                  Description, DescriptionSize,
                                  ActualDescriptionSize) == S_FALSE)
            {
                Status = S_FALSE;
            }
        }
    }
    else
#endif // #ifndef NT_NATIVE
    {
        FillStringBufferW(L"", 0,
                          Description, DescriptionSize, ActualDescriptionSize);
    }

 EH_Process:
    g_NtDllCalls.NtClose(Process);
 EH_Exit:
    return Status;
#endif // #ifdef _WIN32_WCE
}

HRESULT
ThGetProcDesc(ULONG ProcessId, ULONG Flags,
              PWSTR ExeName, ULONG ExeNameSize, PULONG ActualExeNameSize,
              PWSTR Description, ULONG DescriptionSize,
              PULONG ActualDescriptionSize)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    BOOL First = TRUE;

    Status = E_NOINTERFACE;
    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (First)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        if (Proc.th32ProcessID == ProcessId)
        {
            PSTR AnsiImage = Proc.szExeFile;
            PSTR ImageName;
            WCHAR WideImage[MAX_PATH];
            
            if (Flags & DEBUG_PROC_DESC_NO_PATHS)
            {
                ImageName = strrchr(AnsiImage, '\\');
                if (ImageName == NULL)
                {
                    ImageName = strrchr(AnsiImage, '/');
                }
                if (ImageName == NULL)
                {
                    ImageName = AnsiImage;
                }
                else
                {
                    ImageName++;
                }
            }
            else
            {
                ImageName = AnsiImage;
            }

            if (!MultiByteToWideChar(CP_ACP, 0, ImageName, -1, WideImage,
                                     sizeof(WideImage) / sizeof(WCHAR)))
            {
                Status = WIN32_LAST_STATUS();
            }
            else
            {
                Status = FillStringBufferW(WideImage, 0,
                                           ExeName, ExeNameSize,
                                           ActualExeNameSize);
            }
            break;
        }
    }
                
    CloseHandle(Snap);

    // Win9x doesn't have services and we don't have to
    // worry about IIS so there's currently nothing we provide
    // as a description.
    FillStringBufferW(L"", 0,
                      Description, DescriptionSize, ActualDescriptionSize);
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDescriptionW(
    THIS_
    IN ULONG ProcessId,
    IN ULONG Flags,
    OUT OPTIONAL PWSTR ExeName,
    IN ULONG ExeNameSize,
    OUT OPTIONAL PULONG ActualExeNameSize,
    OUT OPTIONAL PWSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG ActualDescriptionSize
    )
{
    HRESULT Status;

    // Allow privileged access.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetProcDesc(ProcessId, Flags, ExeName, ExeNameSize,
                             ActualExeNameSize, Description, DescriptionSize,
                             ActualDescriptionSize);
    case VER_PLATFORM_WIN32_WINDOWS:
    case VER_PLATFORM_WIN32_CE:
        return ThGetProcDesc(ProcessId, Flags, ExeName, ExeNameSize,
                             ActualExeNameSize,
                             Description, DescriptionSize,
                             ActualDescriptionSize);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
InsertUserThread(ULONG Flags, PUSER_THREAD_INFO Threads, ULONG Index,
                 HRESULT Status, ULONG ThreadId, HANDLE ThreadHandle,
                 PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
    // Suspend the thread immediately to try and keep the
    // process state as static as we can.
    if (Status == S_OK &&
        !(Flags & DBGSVC_PROC_INFO_NO_SUSPEND) &&
        ::SuspendThread(ThreadHandle) == -1)
    {
        Status = WIN32_LAST_STATUS();
        ::CloseHandle(ThreadHandle);
    }
    
    if (Status != S_OK)
    {
        while (Index-- > 0)
        {
            if (!(Flags & DBGSVC_PROC_INFO_NO_SUSPEND))
            {
                ::ResumeThread(OS_HANDLE(Threads[Index].Handle));
            }
            ::CloseHandle(OS_HANDLE(Threads[Index].Handle));
        }
        return Status;
    }

    Threads[Index].Handle = SERVICE_HANDLE(ThreadHandle);
    Threads[Index].Id = ThreadId;
    Threads[Index].Reserved = 0;

    //
    // Search for this thread in any previous information.
    //
    
    if (PrevThreads == NULL)
    {
        return S_OK;
    }

    ULONG i;

    Status = S_FALSE;
    for (i = 0; i < PrevInfoCount; i++)
    {
        if (PrevThreads[i].Id == ThreadId)
        {
            // Found a match.
            Status = S_OK;
            break;
        }
    }
    
    return Status;
}

HRESULT
NtGetProcThreads(ULONG ProcessId, ULONG Flags, PUSER_THREAD_INFO Threads,
                 ULONG InfoCount, PULONG ThreadCount,
                 ULONG SysProcInfoSize,
                 PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;
    
    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    for (;;)
    {
        if (ProcessInfo->UniqueProcessId == (HANDLE)(ULONG_PTR)ProcessId ||
            ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    if (ProcessInfo->UniqueProcessId == (HANDLE)(ULONG_PTR)ProcessId)
    {
        // We can't just use ProcessInfo->NumberOfThreads as some
        // of the threads may exit before we record them.
        ULONG NumThreads = 0;
        
        // If the last iteration returned a different number
        // of threads there's a mismatch so we need to return S_FALSE.
        Status = (PrevThreads != NULL &&
                  PrevInfoCount != ProcessInfo->NumberOfThreads) ?
            S_FALSE : S_OK;
        
        PSYSTEM_THREAD_INFORMATION ThreadInfo = (PSYSTEM_THREAD_INFORMATION)
            ((PUCHAR)ProcessInfo + SysProcInfoSize);
        for (ULONG i = 0; i < ProcessInfo->NumberOfThreads; i++, ThreadInfo++)
        {
            if (NumThreads < InfoCount)
            {
                NTSTATUS NtStatus;
                OBJECT_ATTRIBUTES ObjAttr;
                HANDLE Thread;
                HRESULT SingleStatus;

                InitializeObjectAttributes(&ObjAttr, NULL, 0, NULL, NULL);
                NtStatus = g_NtDllCalls.
                    NtOpenThread(&Thread, THREAD_ALL_ACCESS, &ObjAttr,
                                 &ThreadInfo->ClientId);
            
                // If the thread exited since the system info was
                // gathered we may not be able to open it.  Check
                // for the specific error to distinguish it from
                // resource problems, etc.
                if (NtStatus == STATUS_INVALID_CID)
                {
                    // We know the system state has changed so
                    // force a refresh.
                    Status = S_FALSE;
                    continue;
                }

                SingleStatus = InsertUserThread
                    (Flags, Threads, NumThreads, CONV_NT_STATUS(NtStatus),
                     (ULONG)(ULONG_PTR)ThreadInfo->ClientId.UniqueThread,
                     Thread, PrevThreads, PrevInfoCount);
                if (SingleStatus == S_FALSE)
                {
                    // Inserted thread didn't match so return S_FALSE.
                    Status = S_FALSE;
                }
                else if (SingleStatus != S_OK)
                {
                    Status = SingleStatus;
                    break;
                }
            }

            NumThreads++;
        }

        if (ThreadCount != NULL)
        {
            *ThreadCount = NumThreads;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    SIZE_T MemSize = 0;
        
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
#endif // #ifdef _WIN32_WCE
}

// These functions are in the minidump library and are
// not really public functions, but we need them so
// just extern them here.
#if defined(_X86_) && !defined(MONO_DBGSRV)
BOOL WinInitialize(BOOL Win95);
HANDLE WINAPI WinOpenThread(BOOL Win95, DWORD dwAccess, BOOL bInheritHandle,
                            DWORD ThreadId);
#else
#define WinInitialize(Win95) (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)
#define WinOpenThread(Win95, dwAccess, bInheritHandle, ThreadId) NULL
#endif

HRESULT
ThGetProcThreads(BOOL Win9x, BOOL Win95,
                 ULONG ProcessId, ULONG Flags, PUSER_THREAD_INFO Threads,
                 ULONG InfoCount, PULONG ThreadCount,
                 PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

#ifdef MONO_DBGSRV
    // The monolithic dbgsrv doesn't have the minidump
    // Win9x hack WinOpenThread.
    Win9x = FALSE;
#endif
    
    if (Win9x)
    {
        if (!WinInitialize(Win95))
        {
            return WIN32_LAST_STATUS();
        }
    }
    else if (!g_Kernel32Calls.OpenThread)
    {
        return E_NOTIMPL;
    }
    
    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD,
                                                    ProcessId);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    BOOL First = TRUE;
    ULONG NumThreads = 0;

    Status = S_OK;
    for (;;)
    {
        THREADENTRY32 Thread;
        BOOL Succ;
        
        Thread.dwSize = sizeof(Thread);
        if (First)
        {
            Succ = g_Kernel32Calls.Thread32First(Snap, &Thread);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Thread32Next(Snap, &Thread);
        }
        if (!Succ)
        {
            break;
        }

        if (Thread.th32OwnerProcessID == ProcessId)
        {
            if (NumThreads < InfoCount)
            {
                HRESULT SingleStatus;
                HANDLE Handle;

                if (Win9x)
                {
                    Handle = WinOpenThread(Win95, THREAD_ALL_ACCESS, FALSE,
                                           Thread.th32ThreadID);
                }
                else
                {
#ifdef _WIN32_WCE
                    Handle = (HANDLE)Thread.th32ThreadID;
#else
                    Handle = g_Kernel32Calls.OpenThread(THREAD_ALL_ACCESS,
                                                        FALSE,
                                                        Thread.th32ThreadID);
#endif
                }
                
                // If the thread exited since the system info was
                // gathered we may not be able to open it.  Check
                // for the specific error to distinguish it from
                // resource problems, etc.
                if (!Handle && GetLastError() == ERROR_INVALID_PARAMETER)
                {
                    // We know the system state has changed so
                    // force a refresh.
                    Status = S_FALSE;
                    continue;
                }

                SingleStatus = InsertUserThread
                    (Flags, Threads, NumThreads,
                     CONV_W32_STATUS(Handle != NULL),
                     Thread.th32ThreadID, Handle,
                     PrevThreads, PrevInfoCount);
                if (SingleStatus == S_FALSE)
                {
                    // Inserted thread didn't match so return S_FALSE.
                    Status = S_FALSE;
                }
                else if (SingleStatus != S_OK)
                {
                    Status = SingleStatus;
                    break;
                }
            }

            NumThreads++;
        }
    }
                
    if (ThreadCount != NULL)
    {
        *ThreadCount = NumThreads;
    }

    if (Status == S_OK)
    {
        // If no threads were found the process must be invalid.
        if (NumThreads == 0)
        {
            Status = E_NOINTERFACE;
        }
        else if (PrevThreads != NULL && NumThreads != PrevInfoCount)
        {
            // Thread count didn't match so return S_FALSE.
            Status = S_FALSE;
        }
    }
    
    CloseHandle(Snap);
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessInfo(
    THIS_
    IN ULONG ProcessId,
    IN ULONG Flags,
    OUT OPTIONAL PULONG64 Handle,
    OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
    IN ULONG InfoCount,
    OUT OPTIONAL PULONG ThreadCount
    )
{
    HANDLE Process;
    HRESULT Status;

#if DBG_GET_PROC_INFO
    g_NtDllCalls.DbgPrint("GetProcessInfo(%X, %X, %X)\n",
                          ProcessId, Flags, InfoCount);
#endif
    
    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
#if DBG_GET_PROC_INFO
        g_NtDllCalls.DbgPrint("  EDP %X\n", Status);
#endif
        return Status;
    }

    if (Handle != NULL)
    {
        // This should always be a real process ID so there's
        // no need to look for the special CSR value.
        Process = ::OpenProcess(PROCESS_ALL_ACCESS, 0, ProcessId);
        if (Process == NULL)
        {
#if DBG_GET_PROC_INFO
            g_NtDllCalls.DbgPrint("  OP %X\n", WIN32_LAST_STATUS());
#endif
            return WIN32_LAST_STATUS();
        }
        
        *Handle = SERVICE_HANDLE(Process);
    }
    else
    {
        Process = NULL;
    }

    if (Threads != NULL || ThreadCount != NULL)
    {
        PUSER_THREAD_INFO PrevThreads;
        ULONG PrevInfoCount;
        ULONG _ThreadCount;
        
        //
        // We need to enumerate the threads in the process.
        // This is a difficult thing to get right as
        // the thread state for the process can continuously
        // change.  In order to try and get a clean snapshot
        // of the thread state we iteratively enumerate until
        // we get two consecutive snapshots that match.
        //
        // We suspend enumerated threads immediately to
        // reduce churn from inside the process itself.
        // We can't do anything about external processes so
        // the enumeration could still get stale right after
        // we return but by stopping everything in the process
        // itself we do what we can.
        //
        // If the caller is just getting the count and
        // not the actual thread information we don't bother
        // iterating as there's no expectation that the
        // thread state will be the same from one call to
        // the next so there's no need to do the extra work.
        //

        if (Threads != NULL)
        {
            // Allocate an array to hold previous results.  This
            // can always be the same size as the return array
            // because if there are more threads than can fit in
            // the return array the snapshot will be wrong anyway
            // so we just return without doing comparisons.
            PrevThreads = new USER_THREAD_INFO[InfoCount];
            if (PrevThreads == NULL)
            {
                Status = E_OUTOFMEMORY;
                goto EH_CloseProc;
            }
        }
        else
        {
            PrevThreads = NULL;
        }
        PrevInfoCount = 0;

        for (;;)
        {
            switch(m_PlatformId)
            {
            case VER_PLATFORM_WIN32_NT:
                Status = NtGetProcThreads(ProcessId, Flags, Threads, InfoCount,
                                          &_ThreadCount, m_SysProcInfoSize,
                                          PrevThreads, PrevInfoCount);
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
            case VER_PLATFORM_WIN32_CE:
                Status = ThGetProcThreads
                    (m_PlatformId == VER_PLATFORM_WIN32_WINDOWS, m_Win95,
                     ProcessId, Flags, Threads,
                     InfoCount, &_ThreadCount,
                     PrevThreads, PrevInfoCount);
                break;
            default:
                Status = E_UNEXPECTED;
                break;
            }

#if DBG_GET_PROC_INFO
            g_NtDllCalls.DbgPrint("    loop prev %X, new %X, status %X\n",
                                  PrevInfoCount, _ThreadCount, Status);
#endif
            
            //
            // We can clean up any previous information now.
            //
            
            ULONG i;

            for (i = 0; i < PrevInfoCount; i++)
            {
                if (!(Flags & DBGSVC_PROC_INFO_NO_SUSPEND))
                {
                    ::ResumeThread(OS_HANDLE(PrevThreads[i].Handle));
                }
                ::CloseHandle(OS_HANDLE(PrevThreads[i].Handle));
            }

            if (Status != S_FALSE ||
                _ThreadCount > InfoCount ||
                (Flags & DBGSVC_PROC_INFO_NO_SUSPEND))
            {
                // The snapshot either matched the previous
                // snapshot or there was an error.  Also,
                // if the snapshot overflowed the return array
                // quit and give the caller the option of
                // calling again when they notice they didn't
                // get a complete snapshot.
                // We also don't loop if threads aren't being
                // suspended as there's no guarantee the
                // state will remain stable.
                break;
            }

            // There was a snapshot mismatch so loop again
            // with this snapshot as the previous data.
            PrevInfoCount = _ThreadCount;
            if (PrevInfoCount > InfoCount)
            {
                PrevInfoCount = InfoCount;
            }

            RtlCopyMemory(PrevThreads, Threads,
                          PrevInfoCount * sizeof(*PrevThreads));
        }

        if (ThreadCount != NULL)
        {
            *ThreadCount = _ThreadCount;
        }

        delete [] PrevThreads;

    EH_CloseProc:
        if (FAILED(Status) && Process != NULL)
        {
            ::CloseHandle(Process);
        }
    }
    else
    {
        Status = S_OK;
    }

#if DBG_GET_PROC_INFO
    g_NtDllCalls.DbgPrint("  out %X\n", Status);
#endif
    return Status;
}

HRESULT
ProcessIdToHandle(ULONG ProcessId, PHANDLE Process)
{
    if (ProcessId == CSRSS_PROCESS_ID)
    {
        if (g_NtDllCalls.CsrGetProcessId != NULL)
        {
            ProcessId = (ULONG)(ULONG_PTR)g_NtDllCalls.CsrGetProcessId();
        }
        else
        {
            *Process = NULL;
            return S_OK;
        }
    }
    
    *Process = ::OpenProcess(PROCESS_ALL_ACCESS, 0, ProcessId);
    if (*Process == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

NTSTATUS
CreateDebugObject(PHANDLE Object)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    if (*Object != NULL)
    {
        return STATUS_SUCCESS;
    }
    
    OBJECT_ATTRIBUTES Attr;
    
    InitializeObjectAttributes(&Attr, NULL, 0, NULL, g_AllAccessSecDesc);
    return g_NtDllCalls.NtCreateDebugObject(Object, DEBUG_ALL_ACCESS,
                                            &Attr, DEBUG_KILL_ON_CLOSE);
#endif
}

HRESULT
LiveUserDebugServices::SysGetProcessOptions(HANDLE Process, PULONG Options)
{
    NTSTATUS NtStatus;
    ULONG Flags;

    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(Process, ProcessDebugFlags,
                                      &Flags, sizeof(Flags), NULL);
    }
    else
    {
        NtStatus = STATUS_INVALID_INFO_CLASS;
    }
    if (NtStatus == STATUS_INVALID_INFO_CLASS)
    {
        // The system doesn't support control over the
        // debug flags.  In the attach case this means
        // the flags will be DEBUG_ONLY_THIS_PROCESS.
        *Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
        NtStatus = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        *Options = 0;
        if ((Flags & PROCESS_DEBUG_INHERIT) == 0)
        {
            *Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }
    }

    return CONV_NT_STATUS(NtStatus);
}

HRESULT
LiveUserDebugServices::OpenDebugActiveProcess(ULONG ProcessId,
                                              HANDLE Process)
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT ||
        !m_UseDebugObject)
    {
        return E_NOTIMPL;
    }
    
    // We're going to open the process's existing debug
    // object and use it so we can't already have a debug object.
    if (Process == NULL || m_DebugObject != NULL)
    {
        return E_UNEXPECTED;
    }

    NTSTATUS NtStatus;

    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(Process, ProcessDebugObjectHandle,
                                  &m_DebugObject, sizeof(m_DebugObject), NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    return S_OK;
}

HRESULT
LiveUserDebugServices::CreateDebugActiveProcess(ULONG ProcessId,
                                                HANDLE Process,
                                                ULONG AttachFlags)
{
    if (m_UseDebugObject)
    {
        if (Process == NULL)
        {
            return E_FAIL;
        }
        if (g_NtDllCalls.NtDebugActiveProcess == NULL)
        {
            return E_NOTIMPL;
        }
        
        NTSTATUS NtStatus;

        NtStatus = CreateDebugObject(&m_DebugObject);
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = g_NtDllCalls.NtDebugActiveProcess(Process,
                                                         m_DebugObject);
            if (NT_SUCCESS(NtStatus) &&
                !(AttachFlags & DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK))
            {
                g_NtDllCalls.DbgUiIssueRemoteBreakin(Process);
            }
        }
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }
#ifndef NT_NATIVE
    else
    {
        if (AttachFlags & DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK)
        {
            return E_NOTIMPL;
        }
        
        if (!::DebugActiveProcess(ProcessId))
        {
            return WIN32_LAST_STATUS();
        }
    }
#else
    else
    {
        return E_UNEXPECTED;
    }
#endif

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::AttachProcess(
    THIS_
    IN ULONG ProcessId,
    IN ULONG AttachFlags,
    OUT PULONG64 ProcessHandle,
    OUT PULONG ProcessOptions
    )
{
    HRESULT Status;
    
    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    HANDLE Process;
    
    if (ProcessId == CSRSS_PROCESS_ID)
    {
        CloseProfileUserMapping();
    }

    if ((Status = ProcessIdToHandle(ProcessId, &Process)) != S_OK)
    {
        return Status;
    }

    if ((Status = SysGetProcessOptions(Process, ProcessOptions)) != S_OK)
    {
        if (Process != NULL)
        {
            ::CloseHandle(Process);
        }
        return Status;
    }

    if (AttachFlags & DEBUG_ATTACH_EXISTING)
    {
        Status = OpenDebugActiveProcess(ProcessId, Process);
    }
    else
    {
        Status = CreateDebugActiveProcess(ProcessId, Process, AttachFlags);

        // Attaching always sets the inherit flag to not-inherit
        // as by default an attached process does not debug
        // children.
        *ProcessOptions |= DEBUG_PROCESS_ONLY_THIS_PROCESS;
    }
    if (Status != S_OK)
    {
        if (Process != NULL)
        {
            ::CloseHandle(Process);
        }
        return Status;
    }

    *ProcessHandle = SERVICE_HANDLE(Process);
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::DetachProcess(
    THIS_
    IN ULONG ProcessId
    )
{
    HRESULT Status;

    //
    // A ProcessId of zero means that the caller is just
    // checking for detach support and no actual detach
    // should occur.
    //

    if (m_UseDebugObject)
    {
        if (g_NtDllCalls.NtRemoveProcessDebug == NULL)
        {
            return E_NOTIMPL;
        }

        // Check for the query before checking the debug
        // object as the query may come in early.
        if (ProcessId == 0)
        {
            return S_OK;
        }
        
        if (m_DebugObject == NULL)
        {
            return E_UNEXPECTED;
        }

        HANDLE Process;

        if ((Status = ProcessIdToHandle(ProcessId, &Process)) != S_OK)
        {
            return Status;
        }
        if (Process == NULL)
        {
            return E_FAIL;
        }

        NTSTATUS NtStatus;

        NtStatus = g_NtDllCalls.
            NtRemoveProcessDebug(Process, m_DebugObject);
        Status = CONV_NT_STATUS(NtStatus);
            
        ::CloseHandle(Process);
    }
    else
    {
        if (g_Kernel32Calls.DebugActiveProcessStop == NULL)
        {
            return E_NOTIMPL;
        }

        if (ProcessId == 0)
        {
            return S_OK;
        }
        
        if (!g_Kernel32Calls.DebugActiveProcessStop(ProcessId))
        {
            return WIN32_LAST_STATUS();
        }
    }

    return S_OK;
}

NTSTATUS
NtSimpleCreateProcess(PCWSTR CommandLine,
                      ULONG CreateFlags,
                      BOOL InheritHandles,
                      PCWSTR CurrentDir,
                      HANDLE DebugObject,
                      LPPROCESS_INFORMATION RetInfo)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS Status;
    PWSTR RawAppName;
    ULONG AppLen;
    UNICODE_STRING AppName;
    UNICODE_STRING CurDirStr;
    PUNICODE_STRING CurDir;
    UNICODE_STRING CmdLineStr;
    PRTL_USER_PROCESS_PARAMETERS Params;
    RTL_USER_PROCESS_INFORMATION Info;

    if (!g_NtDllCalls.RtlCreateUserProcess)
    {
        return STATUS_NOT_IMPLEMENTED;
    }
    
    if (!(CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)))
    {
        DebugObject = NULL;
    }
    else if (CreateFlags & DEBUG_ONLY_THIS_PROCESS)
    {
        // The hacked way of controlling debug inheritance
        // is via the low bit of the debug object handle.
        // If the bit is set it means do not inherit.
        DebugObject = (HANDLE)((ULONG_PTR)DebugObject | 1);
    }

    //
    // This is a simple interface, so assume the first
    // space-delimited token is the executable to run.
    //
    
    PCWSTR ExeStart, ExeEnd;

    ExeStart = CommandLine;
    while (*ExeStart == L' ' || *ExeStart == L'\t')
    {
        ExeStart++;
    }
    if (*ExeStart == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ExeEnd = ExeStart;
    while (*ExeEnd && !(*ExeEnd == L' ' || *ExeEnd == L'\t'))
    {
        ExeEnd++;
    }

    AppLen = (ULONG)(ExeEnd - ExeStart);
    RawAppName = new WCHAR[AppLen + 1];
    if (!RawAppName)
    {
        return STATUS_NO_MEMORY;
    }

    memcpy(RawAppName, ExeStart, AppLen * sizeof(WCHAR));
    RawAppName[AppLen] = 0;

    Status = g_NtDllCalls.
        RtlDosPathNameToNtPathName_U(RawAppName, &AppName, NULL, NULL);

    delete [] RawAppName;
    
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    if (CurrentDir)
    {
        Status = g_NtDllCalls.
            RtlDosPathNameToNtPathName_U(CurrentDir, &CurDirStr, NULL, NULL);
        if (!NT_SUCCESS(Status))
        {
            goto EH_AppName;
        }

        CurDir = &CurDirStr;
    }
    else
    {
        CurDir = NULL;
    }
    
    g_NtDllCalls.RtlInitUnicodeString(&CmdLineStr, CommandLine);
    
    Status = g_NtDllCalls.
        RtlCreateProcessParameters(&Params, &AppName, NULL, CurDir,
                                   &CmdLineStr, NULL, NULL, NULL,
                                   NULL, NULL);
    if (!NT_SUCCESS(Status))
    {
        goto EH_CurDir;
    }

    Info.Length = sizeof(Info);
    
    Status = g_NtDllCalls.
        RtlCreateUserProcess(&AppName, OBJ_CASE_INSENSITIVE,
                             Params, NULL, NULL, NULL,
                             InheritHandles ? TRUE : FALSE,
                             DebugObject, NULL, &Info);

    g_NtDllCalls.RtlDestroyProcessParameters(Params);

    if (NT_SUCCESS(Status))
    {
        RetInfo->dwProcessId = HandleToUlong(Info.ClientId.UniqueProcess);
        RetInfo->dwThreadId = HandleToUlong(Info.ClientId.UniqueThread);
        RetInfo->hProcess = Info.Process;
        RetInfo->hThread = Info.Thread;
        if ((CreateFlags & CREATE_SUSPENDED) == 0)
        {
            g_NtDllCalls.NtResumeThread(Info.Thread, NULL);
        }
    }

 EH_CurDir:
    if (CurDir)
    {
        g_NtDllCalls.RtlFreeUnicodeString(CurDir);
    }
 EH_AppName:
    g_NtDllCalls.RtlFreeUnicodeString(&AppName);
    return Status;
#endif // #ifdef _WIN32_WCE
}

#define DHEAP_ENV "_NO_DEBUG_HEAP"

STDMETHODIMP
LiveUserDebugServices::CreateProcessW(
    THIS_
    IN PWSTR CommandLine,
    IN ULONG CreateFlags,
    IN BOOL InheritHandles,
    IN OPTIONAL PWSTR CurrentDir,
    OUT PULONG ProcessId,
    OUT PULONG ThreadId,
    OUT PULONG64 ProcessHandle,
    OUT PULONG64 ThreadHandle
    )
{
    HRESULT Status;

    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    // The system looks at the environment variable
    // _NO_DEBUG_HEAP to determine whether the new
    // process should use the debug heap or not.  If
    // the caller has requested the normal heap
    // set this environment variable so that it's
    // inherited.
    if (CreateFlags & DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP)
    {
#ifndef _WIN32_WCE
        ::SetEnvironmentVariable(DHEAP_ENV, "1");
#endif
        // Turn off this flag since it's not meaningful
        // to CreateProcess itself.
        CreateFlags &= ~DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
    }
    
    PROCESS_INFORMATION ProcInfo;

#ifndef NT_NATIVE
    
    HANDLE OldDebugObject;
    BOOL SetOldDebugObject = FALSE;

    Status = S_OK;

    if ((CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) &&
        m_UseDebugObject)
    {
        //
        // Set up this thread's debug object to the one that
        // we're using so that our debug object is used when
        // debugging the new process.  This lets us continue
        // to use the normal Win32 CreateProcess call rather
        // than trying to go through NtCreateProcessEx and
        // guarantees we get all the Win32 process creation logic.
        //
        
        if (g_NtDllCalls.DbgUiSetThreadDebugObject == NULL)
        {
            Status = E_NOTIMPL;
        }
        else
        {
            NTSTATUS NtStatus;
            
            OldDebugObject = g_NtDllCalls.DbgUiGetThreadDebugObject();

            NtStatus = CreateDebugObject(&m_DebugObject);
            if (NT_SUCCESS(NtStatus))
            {
                g_NtDllCalls.DbgUiSetThreadDebugObject(m_DebugObject);
                SetOldDebugObject = TRUE;
            }
            else
            {
                Status = HRESULT_FROM_NT(NtStatus);
            }
        }
    }

    if (Status == S_OK)
    {
        if (CreateFlags & DEBUG_CREATE_PROCESS_THROUGH_RTL)
        {
            if (!m_UseDebugObject)
            {
                Status = E_UNEXPECTED;
            }
            else
            {
                NTSTATUS NtStatus;

                // The RTL create flag is an overloading of an existing
                // flag, so clear it before the actual create to
                // avoid unwanted behavior.
                CreateFlags &= ~DEBUG_CREATE_PROCESS_THROUGH_RTL;
                
                NtStatus = NtSimpleCreateProcess(CommandLine,
                                                 CreateFlags,
                                                 InheritHandles,
                                                 CurrentDir,
                                                 m_DebugObject,
                                                 &ProcInfo);
                Status = CONV_NT_STATUS(NtStatus);
            }
        }
        else
        {
            Status = S_OK;
            switch(m_PlatformId)
            {
            case VER_PLATFORM_WIN32_NT:
#ifdef _WIN32_WCE
                Status = E_NOTIMPL;
#else
                {
                    STARTUPINFOW StartupInfoW;
                
                    ZeroMemory(&StartupInfoW, sizeof(StartupInfoW));
                    StartupInfoW.cb = sizeof(StartupInfoW);

                    if (!::CreateProcessW(NULL, CommandLine, NULL, NULL,
                                          InheritHandles, CreateFlags,
                                          NULL, CurrentDir,
                                          &StartupInfoW, &ProcInfo))
                    {
                        Status = WIN32_LAST_STATUS();
                    }
                }
#endif
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
            case VER_PLATFORM_WIN32_CE:
                {
                    STARTUPINFOA StartupInfoA;
                    PSTR CmdLineA, CurDirA;
    
                    ZeroMemory(&StartupInfoA, sizeof(StartupInfoA));
                    StartupInfoA.cb = sizeof(StartupInfoA);
                    
                    if ((Status = WideToAnsi(CommandLine, &CmdLineA)) != S_OK)
                    {
                        break;
                    }
                    if (CurrentDir)
                    {
                        if ((Status = WideToAnsi(CurrentDir,
                                                 &CurDirA)) != S_OK)
                        {
                            FreeAnsi(CmdLineA);
                            break;
                        }
                    }
                    else
                    {
                        CurDirA = NULL;
                    }
                    
                    if (!::CreateProcessA(NULL, CmdLineA, NULL, NULL,
                                          InheritHandles, CreateFlags,
                                          NULL, CurDirA,
                                          &StartupInfoA, &ProcInfo))
                    {
                        Status = WIN32_LAST_STATUS();
                    }

                    FreeAnsi(CmdLineA);
                    if (CurDirA)
                    {
                        FreeAnsi(CurDirA);
                    }
                }
                break;
            default:
                Status = E_NOTIMPL;
                break;
            }
        }
    }

    if (SetOldDebugObject)
    {
        g_NtDllCalls.DbgUiSetThreadDebugObject(OldDebugObject);
    }

#else // #ifndef NT_NATIVE

    if (!m_UseDebugObject)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        NTSTATUS NtStatus;

        if (CreateFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))
        {
            NtStatus = CreateDebugObject(&m_DebugObject);
        }
        else
        {
            NtStatus = STATUS_SUCCESS;
        }
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = NtSimpleCreateProcess(CommandLine,
                                             CreateFlags,
                                             InheritHandles,
                                             CurrentDir,
                                             m_DebugObject,
                                             &ProcInfo);
        }
        Status = CONV_NT_STATUS(NtStatus);
    }
    
#endif // #ifndef NT_NATIVE

    // Clear the special debug heap variable so it
    // isn't inadvertently used somewhere else.
#ifndef _WIN32_WCE
    ::SetEnvironmentVariable(DHEAP_ENV, NULL);
#endif

    if (Status == S_OK)
    {
        *ProcessId = ProcInfo.dwProcessId;
        *ThreadId = ProcInfo.dwThreadId;
        *ProcessHandle = SERVICE_HANDLE(ProcInfo.hProcess);
        *ThreadHandle = SERVICE_HANDLE(ProcInfo.hThread);
    }
    
    return Status;
}

STDMETHODIMP
LiveUserDebugServices::TerminateProcess(
    THIS_
    IN ULONG64 Process,
    IN ULONG ExitCode
    )
{
    if (!::TerminateProcess(OS_HANDLE(Process), ExitCode))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::AbandonProcess(
    THIS_
    IN ULONG64 Process
    )
{
    //
    // In order to abandon a process but still leave it
    // as being debugged we need to get the process's
    // debug object and duplicate it into the debuggee
    // process.  This gives the debuggee process itself
    // a reference to its debug object, creating a circle
    // that will keep the process alive and in the debugged
    // state.
    //
    // This circular reference will also mean that the
    // process must be manually killed.  This may be
    // something interesting to address at some point.
    //

    if (m_DebugObject == NULL)
    {
        return E_NOTIMPL;
    }

#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HRESULT Status;
    HANDLE Dup;
    
    if (!::DuplicateHandle(GetCurrentProcess(), m_DebugObject,
                           OS_HANDLE(Process), &Dup, 0, FALSE,
                           DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }
#endif

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessExitCode(
    THIS_
    IN ULONG64 Process,
    OUT PULONG ExitCode
    )
{
    if (!::GetExitCodeProcess(OS_HANDLE(Process), ExitCode))
    {
        return WIN32_LAST_STATUS();
    }

    return *ExitCode == STILL_ACTIVE ? S_FALSE : S_OK;
}

STDMETHODIMP
LiveUserDebugServices::CloseHandle(
    THIS_
    IN ULONG64 Handle
    )
{
    if (Handle == 0)
    {
        return S_FALSE;
    }

    if (!::CloseHandle(OS_HANDLE(Handle)))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::SetProcessOptions(
    THIS_
    IN ULONG64 Process,
    IN ULONG Options
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    ULONG NtFlags = 0;

    if ((Options & DEBUG_PROCESS_ONLY_THIS_PROCESS) == 0)
    {
        NtFlags |= PROCESS_DEBUG_INHERIT;
    }
    
    NtStatus = g_NtDllCalls.
        NtSetInformationProcess(OS_HANDLE(Process), ProcessDebugFlags,
                                &NtFlags, sizeof(NtFlags));
    if (NtStatus == STATUS_INVALID_INFO_CLASS)
    {
        return E_NOTIMPL;
    }
    else
    {
        return CONV_NT_STATUS(NtStatus);
    }
}
        
STDMETHODIMP
LiveUserDebugServices::SetDebugObjectOptions(
    THIS_
    IN ULONG64 DebugObject,
    IN ULONG Options
    )
{
    if (DebugObject == 0)
    {
        if (m_DebugObject == NULL)
        {
            if (g_Kernel32Calls.DebugSetProcessKillOnExit == NULL)
            {
                return E_NOTIMPL;
            }

            if (!g_Kernel32Calls.
                DebugSetProcessKillOnExit((Options &
                                           DEBUG_PROCESS_DETACH_ON_EXIT) == 0))
            {
                return WIN32_LAST_STATUS();
            }

            return S_OK;
        }
        
        DebugObject = SERVICE_HANDLE(m_DebugObject);
    }
    
    if (g_NtDllCalls.NtSetInformationDebugObject == NULL)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    ULONG NtFlags = 0;

    if ((Options & DEBUG_PROCESS_DETACH_ON_EXIT) == 0)
    {
        NtFlags |= DEBUG_KILL_ON_CLOSE;
    }
    NtStatus = g_NtDllCalls.
        NtSetInformationDebugObject(OS_HANDLE(DebugObject), DebugObjectFlags,
                                    &NtFlags, sizeof(NtFlags), NULL);
    return CONV_NT_STATUS(NtStatus);
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDebugObject(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 DebugObject
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    HANDLE ObjHandle;

    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(OS_HANDLE(Process), ProcessDebugObjectHandle,
                                  &ObjHandle, sizeof(ObjHandle), NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    *DebugObject = SERVICE_HANDLE(ObjHandle);
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::DuplicateHandle(
    THIS_
    IN ULONG64 InProcess,
    IN ULONG64 InHandle,
    IN ULONG64 OutProcess,
    IN ULONG DesiredAccess,
    IN ULONG Inherit,
    IN ULONG Options,
    OUT PULONG64 OutHandle
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HANDLE Dup;
    
    if (!::DuplicateHandle(OS_HANDLE(InProcess), OS_HANDLE(InHandle),
                           OS_HANDLE(OutProcess), &Dup,
                           DesiredAccess, Inherit, Options))
    {
        return WIN32_LAST_STATUS();
    }

    *OutHandle = SERVICE_HANDLE(Dup);
    return S_OK;
#endif
}

STDMETHODIMP
LiveUserDebugServices::ReadVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    SIZE_T SizeRead;
    
    if (!::ReadProcessMemory(OS_HANDLE(Process),
                             (LPCVOID)(ULONG_PTR)Offset,
                             Buffer, BufferSize, &SizeRead))
    {
        return WIN32_LAST_STATUS();
    }

    if (BytesRead != NULL)
    {
        *BytesRead = (ULONG)SizeRead;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::WriteVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    SIZE_T SizeWritten;
    
    if (!::WriteProcessMemory(OS_HANDLE(Process),
                              (LPVOID)(ULONG_PTR)Offset,
                              Buffer, BufferSize, &SizeWritten))
    {
        return WIN32_LAST_STATUS();
    }

    if (BytesWritten != NULL)
    {
        *BytesWritten = (ULONG)SizeWritten;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::QueryVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    if (BufferSize < sizeof(MEMORY_BASIC_INFORMATION))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(MEMORY_BASIC_INFORMATION);
    }

    if (!::VirtualQueryEx(OS_HANDLE(Process),
                          (LPCVOID)(ULONG_PTR)Offset,
                          (PMEMORY_BASIC_INFORMATION)Buffer,
                          sizeof(MEMORY_BASIC_INFORMATION)))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::ProtectVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    BOOL Status = ::VirtualProtectEx(OS_HANDLE(Process),
                                     (PVOID)(ULONG_PTR)Offset, (SIZE_T)Size,
                                     NewProtect, OldProtect);
    return CONV_W32_STATUS(Status);
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::AllocVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG Type,
    IN ULONG Protect,
    OUT PULONG64 AllocOffset
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    PVOID Addr = ::VirtualAllocEx(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Offset,
                                  (SIZE_T)Size, Type, Protect);
    if (Addr == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    *AllocOffset = (ULONG64)(LONG64)(LONG_PTR)Addr;
    return S_OK;
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::FreeVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG Type
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    BOOL Status = ::VirtualFreeEx(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Offset,
                                  (SIZE_T)Size, Type);
    return CONV_W32_STATUS(Status);
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::ReadHandleData(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }

#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    HANDLE Dup = NULL;
    
    if (DataType != DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT &&
        !::DuplicateHandle(OS_HANDLE(Process), OS_HANDLE(Handle),
                           GetCurrentProcess(), &Dup, 0, FALSE,
                           DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }

    ULONG64 NtBuffer[1024 / sizeof(ULONG64)];
    ULONG Used = 0;
    NTSTATUS NtStatus;
    HRESULT Status = S_OK;
    PUNICODE_STRING RetStr = NULL;
    BOOL WideStr = FALSE;

    switch(DataType)
    {
    case DEBUG_HANDLE_DATA_TYPE_BASIC:
        Used = sizeof(DEBUG_HANDLE_DATA_BASIC);
        if (Buffer == NULL)
        {
            break;
        }
        
        if (BufferSize < Used)
        {
            Status = E_INVALIDARG;
            break;
        }
        
        POBJECT_BASIC_INFORMATION NtBasic;

        NtBasic = (POBJECT_BASIC_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectBasicInformation,
                                              NtBasic, sizeof(*NtBasic), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        PDEBUG_HANDLE_DATA_BASIC Basic;
        
        Basic = (PDEBUG_HANDLE_DATA_BASIC)Buffer;
        Basic->TypeNameSize = NtBasic->TypeInfoSize / sizeof(WCHAR);
        Basic->ObjectNameSize = NtBasic->NameInfoSize / sizeof(WCHAR);
        Basic->Attributes = NtBasic->Attributes;
        Basic->GrantedAccess = NtBasic->GrantedAccess;
        Basic->HandleCount = NtBasic->HandleCount;
        Basic->PointerCount = NtBasic->PointerCount;
        break;
        
    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE:
        WideStr = TRUE;
    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME:
        POBJECT_TYPE_INFORMATION NtType;

        NtType = (POBJECT_TYPE_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectTypeInformation,
                                              NtType, sizeof(NtBuffer), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        RetStr = &NtType->TypeName;
        break;
        
    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE:
        WideStr = TRUE;
    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME:
        POBJECT_NAME_INFORMATION NtName;
        
        NtName = (POBJECT_NAME_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectNameInformation,
                                              NtName, sizeof(NtBuffer), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        RetStr = &NtName->Name;
        break;

    case DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT:
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(OS_HANDLE(Process), ProcessHandleCount,
                                      Buffer, BufferSize, &Used);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
        break;
    }

    if (RetStr)
    {
        if (!RetStr->Buffer)
        {
            Used = WideStr ? sizeof(WCHAR) : sizeof(CHAR);
            if (Buffer)
            {
                if (BufferSize < Used)
                {
                    Status = E_INVALIDARG;
                }
                else if (WideStr)
                {
                    *(PWCHAR)Buffer = 0;
                }
                else
                {
                    *(PCHAR)Buffer = 0;
                }
            }
        }
        else
        {
            if (WideStr)
            {
                Used = RetStr->Length + sizeof(WCHAR);
                if (Buffer)
                {
                    BufferSize &= ~(sizeof(WCHAR) - 1);
                    if (BufferSize < sizeof(WCHAR))
                    {
                        Status = E_INVALIDARG;
                    }
                    else
                    {
                        ULONG CopySize = Used - sizeof(WCHAR);
                        if (BufferSize < CopySize)
                        {
                            CopySize = BufferSize;
                        }
                        memcpy(Buffer, RetStr->Buffer, CopySize);
                        
                        // Force termination.
                        if (BufferSize < Used)
                        {
                            *(PWCHAR)((PUCHAR)Buffer +
                                      (BufferSize - sizeof(WCHAR))) = 0;
                            Status = S_FALSE;
                        }
                        else
                        {
                            *(PWCHAR)((PUCHAR)Buffer +
                                      (Used - sizeof(WCHAR))) = 0;
                        }
                    }
                }
            }
            else
            {
                Used = RetStr->Length / sizeof(WCHAR) + 1;
                if (Buffer)
                {
                    if (BufferSize < sizeof(CHAR))
                    {
                        Status = E_INVALIDARG;
                    }
                    else
                    {
                        if (!WideCharToMultiByte(CP_ACP, 0,
                                                 RetStr->Buffer, Used - 1,
                                                 (LPSTR)Buffer, BufferSize,
                                                 NULL, NULL))
                        {
                            Status = WIN32_LAST_STATUS();
                        }
                        else
                        {
                            // Force termination.
                            if (BufferSize < Used)
                            {
                                *((PCHAR)Buffer +
                                  (BufferSize - sizeof(CHAR))) = 0;
                                Status = S_FALSE;
                            }
                            else
                            {
                                *((PCHAR)Buffer +
                                  (Used - sizeof(CHAR))) = 0;
                            }
                        }
                    }
                }
            }
        }
    }

    if (DataSize != NULL)
    {
        *DataSize = Used;
    }

    if (Dup != NULL)
    {
        ::CloseHandle(Dup);
    }
    return Status;
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::SuspendThreads(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PULONG64 Threads,
    OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
    )
{
    ULONG i;
    HRESULT Status;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        ULONG OldCount = ::SuspendThread(OS_HANDLE(Threads[i]));
        if (OldCount == -1)
        {
            Status = WIN32_LAST_STATUS();
        }
        if (SuspendCounts != NULL)
        {
            SuspendCounts[i] = OldCount + 1;
        }
    }

    return Status;
}

STDMETHODIMP
LiveUserDebugServices::ResumeThreads(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PULONG64 Threads,
    OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
    )
{
    ULONG i;
    HRESULT Status;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        ULONG OldCount = ::ResumeThread(OS_HANDLE(Threads[i]));
        if (OldCount == -1)
        {
            Status = WIN32_LAST_STATUS();
        }
        if (SuspendCounts != NULL)
        {
            SuspendCounts[i] = OldCount - 1;
        }
    }

    return Status;
}

STDMETHODIMP
LiveUserDebugServices::GetThreadStartAddress(
    THIS_
    IN ULONG64 Thread,
    OUT PULONG64 Offset
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        // XXX drewb - Equivalent?
        return E_NOTIMPL;
    }
    
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS NtStatus;
    LONG_PTR StartAddr;

    NtStatus = g_NtDllCalls.
        NtQueryInformationThread(OS_HANDLE(Thread),
                                 ThreadQuerySetWin32StartAddress,
                                 &StartAddr,
                                 sizeof(StartAddr),
                                 NULL);
    *Offset = (ULONG64)(LONG64)StartAddr;
    return CONV_NT_STATUS(NtStatus);
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::GetContext(
    THIS_
    IN ULONG64 Thread,
    IN ULONG Flags,
    IN ULONG FlagsOffset,
    OUT PVOID Context,
    IN ULONG ContextSize,
    OUT OPTIONAL PULONG ContextUsed
    )
{
    if (ContextSize < m_ContextSize)
    {
        return E_INVALIDARG;
    }

    if (ContextUsed != NULL)
    {
        *ContextUsed = m_ContextSize;
    }
    
    // Some platforms have alignment requirements for
    // context information, so just get data into a
    // local context structure, which presumably the
    // compiler will properly align, and then copy
    // it into the output buffer.
#ifndef _X86_
    CONTEXT _LocalContext;
    PCONTEXT LocalContext = &_LocalContext;
#else
    PCONTEXT LocalContext = (PCONTEXT)Context;
#endif
    
    // Initialize context flags here rather than making Context
    // IN OUT to avoid sending a full CONTEXT just for a
    // ULONG's worth of flags.
    *(PULONG)((PUCHAR)LocalContext + FlagsOffset) = Flags;
    
    if (!::GetThreadContext(OS_HANDLE(Thread), LocalContext))
    {
        return WIN32_LAST_STATUS();
    }

#ifndef _X86_
    memcpy(Context, LocalContext, m_ContextSize);
#endif
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::SetContext(
    THIS_
    IN ULONG64 Thread,
    IN PVOID Context,
    IN ULONG ContextSize,
    OUT OPTIONAL PULONG ContextUsed
    )
{
    if (ContextSize < m_ContextSize)
    {
        return E_INVALIDARG;
    }
    
    if (ContextUsed != NULL)
    {
        *ContextUsed = m_ContextSize;
    }
    
    // Some platforms have alignment requirements for
    // context information, so just get data into a
    // local context structure, which presumably the
    // compiler will properly align.
#ifndef _X86_
    CONTEXT _LocalContext;
    PCONTEXT LocalContext = &_LocalContext;
    memcpy(LocalContext, Context, m_ContextSize);
#else
    PCONTEXT LocalContext = (PCONTEXT)Context;
#endif
    
    if (!::SetThreadContext(OS_HANDLE(Thread), LocalContext))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDataOffset(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Offset
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        // XXX drewb - Equivalent?
        return E_NOTIMPL;
    }
    
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS NtStatus;
    PROCESS_BASIC_INFORMATION ProcessInformation;
        
    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(OS_HANDLE(Process),
                                  ProcessBasicInformation,
                                  &ProcessInformation,
                                  sizeof(ProcessInformation),
                                  NULL);
    *Offset = (ULONG64)(LONG64)(LONG_PTR)ProcessInformation.PebBaseAddress;
    return CONV_NT_STATUS(NtStatus);
#endif // #ifdef _WIN32_WCE
}

HRESULT
NtGetThreadTeb(HANDLE Thread,
               PULONG64 Offset)
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    NTSTATUS NtStatus;
    THREAD_BASIC_INFORMATION ThreadInformation;

    NtStatus = g_NtDllCalls.
        NtQueryInformationThread(Thread,
                                 ThreadBasicInformation,
                                 &ThreadInformation,
                                 sizeof(ThreadInformation),
                                 NULL);
    *Offset = (ULONG64)(LONG64)(LONG_PTR)ThreadInformation.TebBaseAddress;
    return CONV_NT_STATUS(NtStatus);
#endif // #ifdef _WIN32_WCE
}

HRESULT
W9xGetThreadTib(HANDLE Thread,
                PULONG64 Offset)
{
#if defined(_WIN32_WCE) || !defined(_X86_)
    return E_NOTIMPL;
#else
    ULONG Addr;
    LDT_ENTRY Ldt;
    CONTEXT Context;

    Context.ContextFlags = CONTEXT_SEGMENTS;

    if (!::GetThreadContext(Thread, &Context) ||
        !::GetThreadSelectorEntry(Thread,
                                  Context.SegFs,
                                  &Ldt))
    {
        return WIN32_LAST_STATUS();
    }

    Addr = (Ldt.HighWord.Bytes.BaseHi << 24) |
        (Ldt.HighWord.Bytes.BaseMid << 16) |
        (Ldt.BaseLow);
    *Offset = (ULONG64)(LONG64)(LONG_PTR)Addr;
    return S_OK;
#endif // #if defined(_WIN32_WCE) || !defined(_X86_)
}

STDMETHODIMP
LiveUserDebugServices::GetThreadDataOffset(
    THIS_
    IN ULONG64 Thread,
    OUT PULONG64 Offset
    )
{
    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetThreadTeb(OS_HANDLE(Thread), Offset);
    case VER_PLATFORM_WIN32_WINDOWS:
        return W9xGetThreadTib(OS_HANDLE(Thread), Offset);
    default:
        return E_UNEXPECTED;
    }
}

STDMETHODIMP
LiveUserDebugServices::DescribeSelector(
    THIS_
    IN ULONG64 Thread,
    IN ULONG Selector,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
#ifdef _X86_
    if (BufferSize < sizeof(LDT_ENTRY))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(LDT_ENTRY);
    }
#endif

    if (!::GetThreadSelectorEntry(OS_HANDLE(Thread), Selector,
                                  (LPLDT_ENTRY)Buffer))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::GetCurrentTimeDateN(
    THIS_
    OUT PULONG64 TimeDate
    )
{
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        LARGE_INTEGER Large;

        Large.LowPart = USER_SHARED_DATA->SystemTime.LowTime;
        Large.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        *TimeDate = Large.QuadPart;
    }
    else
    {
        *TimeDate = TimeDateStampToFileTime((ULONG)time(NULL));
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetCurrentSystemUpTimeN(
    THIS_
    OUT PULONG64 UpTime
    )
{
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        LARGE_INTEGER Large;

        Large.LowPart = USER_SHARED_DATA->InterruptTime.LowTime;
        Large.HighPart = USER_SHARED_DATA->InterruptTime.High1Time;
        *UpTime = Large.QuadPart;
    }
    else
    {
        *UpTime = (ULONG64)GetTickCount() * 10000;
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessUpTimeN(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 UpTime
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        NTSTATUS NtStatus;
        KERNEL_USER_TIMES KernelUserTimes;
        
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(OS_HANDLE(Process),
                                      ProcessTimes,
                                      &KernelUserTimes,
                                      sizeof(KernelUserTimes),
                                      NULL);
        if (NT_SUCCESS(NtStatus))
        {
            LARGE_INTEGER Large;

            Large.LowPart = USER_SHARED_DATA->SystemTime.LowTime;
            Large.HighPart = USER_SHARED_DATA->SystemTime.High1Time;

            *UpTime = Large.QuadPart - KernelUserTimes.CreateTime.QuadPart;
        }

        return CONV_NT_STATUS(NtStatus);
    }
    else
    {
        return E_NOTIMPL;
    }
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::GetProcessTimes(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Create,
    OUT PULONG64 Exit,
    OUT PULONG64 Kernel,
    OUT PULONG64 User
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        NTSTATUS NtStatus;
        KERNEL_USER_TIMES KernelUserTimes;
        
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(OS_HANDLE(Process),
                                      ProcessTimes,
                                      &KernelUserTimes,
                                      sizeof(KernelUserTimes),
                                      NULL);
        if (NT_SUCCESS(NtStatus))
        {
            *Create = KernelUserTimes.CreateTime.QuadPart;
            *Exit = KernelUserTimes.ExitTime.QuadPart;
            *Kernel = KernelUserTimes.KernelTime.QuadPart;
            *User = KernelUserTimes.UserTime.QuadPart;
        }

        return CONV_NT_STATUS(NtStatus);
    }
#ifndef NT_NATIVE
    else
    {
        FILETIME FtCreate, FtExit, FtKernel, FtUser;
        
        if (!::GetProcessTimes(OS_HANDLE(Process), &FtCreate, &FtExit,
                               &FtKernel, &FtUser))
        {
            return WIN32_LAST_STATUS();
        }

        *Create = ((ULONG64)FtCreate.dwHighDateTime << 32) |
            FtCreate.dwLowDateTime;
        *Exit = ((ULONG64)FtExit.dwHighDateTime << 32) |
            FtExit.dwLowDateTime;
        *Kernel = ((ULONG64)FtKernel.dwHighDateTime << 32) |
            FtKernel.dwLowDateTime;
        *User = ((ULONG64)FtUser.dwHighDateTime << 32) |
            FtUser.dwLowDateTime;
        
        return S_OK;
    }
#else
    else
    {
        return E_NOTIMPL;
    }
#endif // #ifndef NT_NATIVE
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::GetThreadTimes(
    THIS_
    IN ULONG64 Thread,
    OUT PULONG64 Create,
    OUT PULONG64 Exit,
    OUT PULONG64 Kernel,
    OUT PULONG64 User
    )
{
#ifdef NT_NATIVE
    return E_NOTIMPL;
#else
    FILETIME FtCreate, FtExit, FtKernel, FtUser;
    
    if (!::GetThreadTimes(OS_HANDLE(Thread),
                          &FtCreate, &FtExit, &FtKernel, &FtUser))
    {
        return WIN32_LAST_STATUS();
    }

    *Create =
        ((ULONG64)FtCreate.dwHighDateTime << 32) | FtCreate.dwLowDateTime;
    *Exit =
        ((ULONG64)FtExit.dwHighDateTime << 32) | FtExit.dwLowDateTime;
    *Kernel =
        ((ULONG64)FtKernel.dwHighDateTime << 32) | FtKernel.dwLowDateTime;
    *User =
        ((ULONG64)FtUser.dwHighDateTime << 32) | FtUser.dwLowDateTime;
    return S_OK;
#endif
}

STDMETHODIMP
LiveUserDebugServices::RequestBreakIn(
    THIS_
    IN ULONG64 Process
    )
{
#ifdef _WIN32_WCE
    return E_NOTIMPL;
#else
    if (g_Kernel32Calls.DebugBreakProcess != NULL)
    {
        if (!g_Kernel32Calls.DebugBreakProcess(OS_HANDLE(Process)))
        {
            return WIN32_LAST_STATUS();
        }
    }
    else if (g_NtDllCalls.DbgUiIssueRemoteBreakin != NULL)
    {
        NTSTATUS Status;
        
        Status = g_NtDllCalls.DbgUiIssueRemoteBreakin(OS_HANDLE(Process));
        return CONV_NT_STATUS(Status);
    }
    else
    {
        HANDLE Thread;
        DWORD ThreadId;
        LPTHREAD_START_ROUTINE BreakFn;

#if defined(_WIN64)
        BreakFn = (LPTHREAD_START_ROUTINE)g_NtDllCalls.DbgBreakPoint;
#else
        BreakFn = (LPTHREAD_START_ROUTINE)g_Kernel32Calls.DebugBreak;
#endif
        
        Thread =
            ::CreateRemoteThread(OS_HANDLE(Process), NULL, 0, BreakFn,
                                 NULL, 0, &ThreadId);
        if (Thread != NULL)
        {
            ::CloseHandle(Thread);
        }
        else
        {
            return WIN32_LAST_STATUS();
        }
    }

    return S_OK;
#endif // #ifdef _WIN32_WCE
}

STDMETHODIMP
LiveUserDebugServices::WaitForEvent(
    THIS_
    IN ULONG Timeout,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
    if (BufferSize < sizeof(DEBUG_EVENT))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(DEBUG_EVENT);
    }

    LPDEBUG_EVENT Event = (LPDEBUG_EVENT)Buffer;
    HRESULT Status = E_NOTIMPL;

    if (m_DebugObject == NULL)
    {
#ifndef NT_NATIVE
        if (!::WaitForDebugEvent(Event, Timeout))
        {
            if (GetLastError() == ERROR_SEM_TIMEOUT)
            {
                Status = S_FALSE;
            }
            else
            {
                Status = WIN32_LAST_STATUS();
            }
        }
        else
        {
            Status = S_OK;
        }
#endif
    }
    else if (g_NtDllCalls.NtWaitForDebugEvent != NULL &&
             g_NtDllCalls.DbgUiConvertStateChangeStructure != NULL)
    {
        NTSTATUS NtStatus;
        LARGE_INTEGER NtTimeout;
        DBGUI_WAIT_STATE_CHANGE StateChange;

        Win32ToNtTimeout(Timeout, &NtTimeout);
        NtStatus = g_NtDllCalls.NtWaitForDebugEvent(m_DebugObject, FALSE,
                                                    &NtTimeout, &StateChange);
        if (NtStatus == STATUS_TIMEOUT)
        {
            Status = S_FALSE;
        }
        else if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
        else
        {
            NtStatus = g_NtDllCalls.
                DbgUiConvertStateChangeStructure(&StateChange, Event);
            // If the conversion fails we'll lose an event, but
            // there's nothing else that can be done.  Conversion
            // failures will only occur in out-of-resource situations
            // so normal debugging will not be affected.
            Status = CONV_NT_STATUS(NtStatus);
        }
    }

    if (Status != S_OK)
    {
        return Status;
    }
    
    m_EventProcessId = Event->dwProcessId;
    m_EventThreadId = Event->dwThreadId;

#ifdef DBG_WAITFOREVENT
    g_NtDllCalls.DbgPrint("Event %d for %X.%X\n",
                          Event->dwDebugEventCode, Event->dwProcessId,
                          Event->dwThreadId);
#endif
    
    // If this is responding to a remote request then
    // we can't return file handles.
    if (m_Remote)
    {
        switch(Event->dwDebugEventCode)
        {
        case CREATE_PROCESS_DEBUG_EVENT:
            ::CloseHandle(Event->u.CreateProcessInfo.hFile);
            Event->u.CreateProcessInfo.hFile = NULL;
            break;
        case LOAD_DLL_DEBUG_EVENT:
            ::CloseHandle(Event->u.LoadDll.hFile);
            Event->u.LoadDll.hFile = NULL;
            break;
        }
    }
    
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::ContinueEvent(
    THIS_
    IN ULONG ContinueStatus
    )
{
#ifdef DBG_WAITFOREVENT
    g_NtDllCalls.DbgPrint("Continue event for %X.%X\n",
                          m_EventProcessId, m_EventThreadId);
#endif
    
    if (m_EventProcessId == 0)
    {
        return E_UNEXPECTED;
    }

    if (m_DebugObject != NULL && g_NtDllCalls.NtDebugContinue != NULL)
    {
        NTSTATUS NtStatus;
        CLIENT_ID ClientId;

        ClientId.UniqueProcess = UlongToHandle(m_EventProcessId);
        ClientId.UniqueThread = UlongToHandle(m_EventThreadId);
        NtStatus = g_NtDllCalls.NtDebugContinue(m_DebugObject, &ClientId,
                                                ContinueStatus);
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }
#ifndef NT_NATIVE
    else if (!::ContinueDebugEvent(m_EventProcessId, m_EventThreadId,
                                   ContinueStatus))
    {
        return WIN32_LAST_STATUS();
    }
#else
    else
    {
        return E_UNEXPECTED;
    }
#endif

    m_EventProcessId = 0;
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::InsertCodeBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG MachineType,
    OUT PVOID Storage,
    IN ULONG StorageSize
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::RemoveCodeBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG MachineType,
    IN PVOID Storage,
    IN ULONG StorageSize
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::InsertDataBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Thread,
    IN ULONG64 Offset,
    IN ULONG AccessLength,
    IN ULONG AccessType,
    IN ULONG MachineType
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::RemoveDataBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Thread,
    IN ULONG64 Offset,
    IN ULONG AccessLength,
    IN ULONG AccessType,
    IN ULONG MachineType
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::GetLastDataBreakpointHit(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Thread,
    OUT PULONG64 Address,
    OUT PULONG AccessType
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::GetFunctionTableListHead(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Offset
    )
{
    if (!g_NtDllCalls.RtlGetFunctionTableListHead)
    {
        *Offset = 0;
        return E_NOINTERFACE;
    }
    else
    {
        *Offset = (ULONG64)(LONG64)(LONG_PTR)
            g_NtDllCalls.RtlGetFunctionTableListHead();
        return S_OK;
    }
}

STDMETHODIMP
LiveUserDebugServices::GetOutOfProcessFunctionTableW(
    THIS_
    IN ULONG64 Process,
    IN PWSTR Dll,
    IN ULONG64 LoadedDllHandle,
    IN ULONG64 Table,
    IN OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TableSize,
    OUT OPTIONAL PULONG64 UsedDllHandle
    )
{
#if !defined(NT_NATIVE) && defined(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME)
    HRESULT Status;
    NTSTATUS NtStatus;
    HMODULE DllHandle;
    POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK Callback;
    ULONG Entries;
    PRUNTIME_FUNCTION Functions;

    if (LoadedDllHandle)
    {
        DllHandle = (HMODULE)(ULONG_PTR)LoadedDllHandle;
    }
    else if ((DllHandle = ::LoadLibraryW(Dll)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    Callback = (POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)GetProcAddress
        (DllHandle, OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME);
    if (!Callback)
    {
        Status = WIN32_LAST_STATUS();
        goto Exit;
    }

    NtStatus = Callback(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Table,
                        &Entries, &Functions);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto Exit;
    }
    if (Functions == NULL)
    {
        Status = E_NOINTERFACE;
        goto Exit;
    }

    Status = FillDataBuffer(Functions, Entries * sizeof(RUNTIME_FUNCTION),
                            Buffer, BufferSize, TableSize);

    // RtlProcessHeap turns into a TEB reference so it doesn't
    // need to (and can't) be a dynamic reference.
    g_NtDllCalls.RtlFreeHeap(RtlProcessHeap(), 0, Functions);
    
 Exit:
    if (SUCCEEDED(Status) && UsedDllHandle)
    {
        *UsedDllHandle = (LONG_PTR)DllHandle;
    }
    else if (!LoadedDllHandle)
    {
        ::FreeLibrary(DllHandle);
    }
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetUnloadedModuleListHead(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Offset
    )
{
    if (!g_NtDllCalls.RtlGetUnloadEventTrace)
    {
        *Offset = 0;
        return E_NOINTERFACE;
    }
    else
    {
        *Offset = (ULONG64)(LONG64)(LONG_PTR)
            g_NtDllCalls.RtlGetUnloadEventTrace();
        return S_OK;
    }
}

STDMETHODIMP
LiveUserDebugServices::LoadLibrary(
    THIS_
    IN PWSTR Path,
    OUT PULONG64 Handle
    )
{
#ifndef NT_NATIVE
    HMODULE Mod = ::LoadLibraryW(Path);
    if (!Mod)
    {
        return WIN32_LAST_STATUS();
    }

    *Handle = (LONG_PTR)Mod;
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

STDMETHODIMP
LiveUserDebugServices::FreeLibrary(
    THIS_
    IN ULONG64 Handle
    )
{
#ifndef NT_NATIVE
    BOOL Succ = ::FreeLibrary((HMODULE)(ULONG_PTR)Handle);
    return CONV_W32_STATUS(Succ);
#else
    return E_NOTIMPL;
#endif
}

//----------------------------------------------------------------------------
//
// Generated RPC proxies and stubs.
//
//----------------------------------------------------------------------------

// Generated headers.
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

#include "dbgsvc_p.cpp"
#include "dbgsvc_s.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\dbgsvc.h ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interfaces.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#ifndef __DBGSVC_H__
#define __DBGSVC_H__

#include <stdarg.h>
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//
// GUIDs and interface forward declarations.
//
//----------------------------------------------------------------------------

/* a7ba24c4-e4fb-4625-a8fc-b1cb1fd51f53 */
DEFINE_GUID(IID_IUserDebugServices, 0xa7ba24c4, 0xe4fb, 0x4625,
            0xa8, 0xfc, 0xb1, 0xcb, 0x1f, 0xd5, 0x1f, 0x53);

typedef interface DECLSPEC_UUID("a7ba24c4-e4fb-4625-a8fc-b1cb1fd51f53")
    IUserDebugServices* PUSER_DEBUG_SERVICES;
    
//----------------------------------------------------------------------------
//
// IUserDebugServices.
//
//----------------------------------------------------------------------------

// The service implementation does not implement Insert/RemoveCodeBreakpoints
// directly, instead it is the caller's responsibility to handle them
// via break instruction insertion and removal.
#define DBGSVC_GENERIC_CODE_BREAKPOINTS  0x00000001
// Handles returned in create process and create thread events
// are not automatically closed.  Instead it is the responsibility
// of the caller to close them when they are no longer needed.
#define DBGSVC_CLOSE_PROC_THREAD_HANDLES 0x00000002
// The service implementation does not implement Insert/RemoveDataBreakpoints
// directly, instead it is the caller's responsibility to handle them
// via process register manipulation.
#define DBGSVC_GENERIC_DATA_BREAKPOINTS  0x00000004

// GetProcessInfo flags.
#define DBGSVC_PROC_INFO_NO_SUSPEND 0x00000001
    
// Handle to ULONG64 and back.
#define SERVICE_HANDLE(OsHandle) ((ULONG64)(OsHandle))
#define OS_HANDLE(SvcHandle) ((HANDLE)(ULONG_PTR)(SvcHandle))

typedef struct _USER_THREAD_INFO
{
    ULONG64 Handle;
    ULONG Id;
    ULONG Reserved;
} USER_THREAD_INFO, *PUSER_THREAD_INFO;
    
#undef INTERFACE
#define INTERFACE IUserDebugServices
DECLARE_INTERFACE_(IUserDebugServices, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        ) PURE;
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        ) PURE;
    STDMETHOD(GetTargetInfo)(
        THIS_
        OUT PULONG MachineType,
        OUT PULONG NumberProcessors,
        OUT PULONG PlatformId,
        OUT PULONG BuildNumber,
        OUT PULONG CheckedBuild,
        OUT PSTR CsdString,
        IN ULONG CsdStringSize,
        OUT PSTR BuildString,
        IN ULONG BuildStringSize,
        OUT PULONG ProductType,
        OUT PULONG SuiteMask
        ) PURE;
    STDMETHOD(GetConnectionInfo)(
        THIS_
        OUT OPTIONAL PSTR MachineName,
        IN ULONG MachineNameSize,
        OUT OPTIONAL PSTR ClientIdentity,
        IN ULONG ClientIdentitySize,
        OUT OPTIONAL PSTR TransportIdentity,
        IN ULONG TransportIdentitySize
        ) PURE;
    STDMETHOD(GetProcessorId)(
        THIS_
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT PULONG BufferUsed
        ) PURE;
    STDMETHOD(GetGenericProcessorFeatures)(
        THIS_
        OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
        IN ULONG FeaturesSize,
        OUT OPTIONAL PULONG Used
        ) PURE;
    STDMETHOD(GetSpecificProcessorFeatures)(
        THIS_
        OUT OPTIONAL /* size_is(FeaturesSize) */ PULONG64 Features,
        IN ULONG FeaturesSize,
        OUT OPTIONAL PULONG Used
        ) PURE;
    STDMETHOD(GetFileVersionInformationA)(
        THIS_
        IN PCWSTR File,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        ) PURE;

    STDMETHOD(GetProcessIds)(
        THIS_
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetProcessIdByExecutableNameW)(
        THIS_
        IN PCWSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetProcessDescriptionW)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PWSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PWSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;
    STDMETHOD(GetProcessInfo)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PULONG64 Handle,
        OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
        IN ULONG InfoCount,
        OUT OPTIONAL PULONG ThreadCount
        ) PURE;
    
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG AttachFlags,
        OUT PULONG64 ProcessHandle,
        OUT PULONG ProcessOptions
        ) PURE;
    STDMETHOD(DetachProcess)(
        THIS_
        IN ULONG ProcessId
        ) PURE;
    STDMETHOD(CreateProcessW)(
        THIS_
        IN PWSTR CommandLine,
        IN ULONG CreateFlags,
        IN BOOL InheritHandles,
        IN OPTIONAL PWSTR CurrentDir,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT PULONG64 ProcessHandle,
        OUT PULONG64 ThreadHandle
        ) PURE;
    STDMETHOD(TerminateProcess)(
        THIS_
        IN ULONG64 Process,
        IN ULONG ExitCode
        ) PURE;
    STDMETHOD(AbandonProcess)(
        THIS_
        IN ULONG64 Process
        ) PURE;
    STDMETHOD(GetProcessExitCode)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG ExitCode
        ) PURE;
    STDMETHOD(CloseHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG64 Process,
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetDebugObjectOptions)(
        THIS_
        IN ULONG64 DebugObject,
        IN ULONG Options
        ) PURE;
    STDMETHOD(GetProcessDebugObject)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 DebugObject
        ) PURE;
    STDMETHOD(DuplicateHandle)(
        THIS_
        IN ULONG64 InProcess,
        IN ULONG64 InHandle,
        IN ULONG64 OutProcess,
        IN ULONG DesiredAccess,
        IN ULONG Inherit,
        IN ULONG Options,
        OUT PULONG64 OutHandle
        ) PURE;
        
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;
    STDMETHOD(ProtectVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG NewProtect,
        OUT PULONG OldProtect
        ) PURE;
    STDMETHOD(AllocVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type,
        IN ULONG Protect,
        OUT PULONG64 AllocOffset
        ) PURE;
    STDMETHOD(FreeVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type
        ) PURE;
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    STDMETHOD(SuspendThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        ) PURE;
    STDMETHOD(ResumeThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        ) PURE;
    STDMETHOD(GetThreadStartAddress)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        ) PURE;

    STDMETHOD(GetContext)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Flags,
        IN ULONG FlagsOffset,
        OUT PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        ) PURE;
    STDMETHOD(SetContext)(
        THIS_
        IN ULONG64 Thread,
        IN PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        ) PURE;

    STDMETHOD(GetProcessDataOffset)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetThreadDataOffset)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        ) PURE;
    
    STDMETHOD(DescribeSelector)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Selector,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;

    STDMETHOD(GetCurrentTimeDateN)(
        THIS_
        OUT PULONG64 TimeDate
        ) PURE;
    STDMETHOD(GetCurrentSystemUpTimeN)(
        THIS_
        OUT PULONG64 UpTime
        ) PURE;
    STDMETHOD(GetProcessUpTimeN)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 UpTime
        ) PURE;
    STDMETHOD(GetProcessTimes)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Create,
        OUT PULONG64 Exit,
        OUT PULONG64 Kernel,
        OUT PULONG64 User
        ) PURE;
    STDMETHOD(GetThreadTimes)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Create,
        OUT PULONG64 Exit,
        OUT PULONG64 Kernel,
        OUT PULONG64 User
        ) PURE;

    STDMETHOD(RequestBreakIn)(
        THIS_
        IN ULONG64 Process
        ) PURE;

    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Timeout,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;
    STDMETHOD(ContinueEvent)(
        THIS_
        IN ULONG ContinueStatus
        ) PURE;

    STDMETHOD(InsertCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        OUT PVOID Storage,
        IN ULONG StorageSize
        ) PURE;
    STDMETHOD(RemoveCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        IN PVOID Storage,
        IN ULONG StorageSize
        ) PURE;
    STDMETHOD(InsertDataBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        IN ULONG64 Offset,
        IN ULONG AccessLength,
        IN ULONG AccessType,
        IN ULONG MachineType
        ) PURE;
    STDMETHOD(RemoveDataBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        IN ULONG64 Offset,
        IN ULONG AccessLength,
        IN ULONG AccessType,
        IN ULONG MachineType
        ) PURE;
    STDMETHOD(GetLastDataBreakpointHit)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Thread,
        OUT PULONG64 Address,
        OUT PULONG AccessType
        ) PURE;

    STDMETHOD(GetFunctionTableListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetOutOfProcessFunctionTableW)(
        THIS_
        IN ULONG64 Process,
        IN PWSTR Dll,
        IN ULONG64 LoadedDllHandle,
        IN ULONG64 Table,
        IN OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TableSize,
        OUT OPTIONAL PULONG64 UsedDllHandle
        ) PURE;

    STDMETHOD(GetUnloadedModuleListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        ) PURE;

    STDMETHOD(LoadLibrary)(
        THIS_
        IN PWSTR Path,
        OUT PULONG64 Handle
        ) PURE;
    STDMETHOD(FreeLibrary)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
};

#ifdef __cplusplus
};
#endif

#endif // #ifndef __DBGSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbgsvc\w32\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\mdi\pch.h ===
/*
 * header for mdi, which implements MapDebugInformation
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <dbghelp.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\mdi\mdi.c ===
/*
 * This code implements the old MapDebugInformation API.
 */

#if defined(_WIN64)
 #error "This doesn't build in 64 bits!"
#endif

#include <pch.h>

PIMAGE_DEBUG_INFORMATION
IMAGEAPI
MapDebugInformation(
    HANDLE FileHandle,
    LPSTR FileName,
    LPSTR SymbolPath,
    ULONG ImageBase
    )

// Here's what we're going to try.  MapDebugInformation was only
// documented as returning COFF symbolic and every user I can find
// in the tree uses COFF exclusively.  Rather than try to make this
// api do everything possible, let's just leave it as a COFF only thing.

// The new debug info api (GetDebugData) will be internal only.

{
    PIMAGE_DEBUG_INFORMATION pIDI;
    CHAR szName[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];
    PIMGHLP_DEBUG_DATA pIDD;
    PPIDI              pPIDI;
    DWORD sections;
    BOOL               SymbolsLoaded;
    HANDLE             hProcess;
    LPSTR sz;
    HANDLE hdb;
    DWORD dw;
    DWORD len;
    hProcess = GetCurrentProcess();

    pIDD = GetIDD(FileHandle, FileName, SymbolPath, ImageBase, NO_PE64_IMAGES);

    if (!pIDD)
        return NULL;

    pPIDI = (PPIDI)MemAlloc(sizeof(PIDI));
    if (!pPIDI)
        return NULL;

    ZeroMemory(pPIDI, sizeof(PIDI));
    pIDI = &pPIDI->idi;
    pPIDI->hdr.pIDD = pIDD;

    pIDI->ReservedSize            = sizeof(IMAGE_DEBUG_INFORMATION);
    pIDI->ReservedMachine         = pIDD->Machine;
    pIDI->ReservedCharacteristics = (USHORT)pIDD->Characteristics;
    pIDI->ReservedCheckSum        = pIDD->CheckSum;
    pIDI->ReservedTimeDateStamp   = pIDD->TimeDateStamp;
    pIDI->ReservedRomImage        = pIDD->fROM;

    // read info

    InitializeListHead( &pIDI->List );
    pIDI->ImageBase = (ULONG)pIDD->ImageBaseFromImage;

    len = strlen(pIDD->ImageFilePath) + 1;
    pIDI->ImageFilePath = (PSTR)MemAlloc(len);
    if (pIDI->ImageFilePath) {
        CopyString(pIDI->ImageFilePath, pIDD->ImageFilePath, len);
    }

    len = strlen(pIDD->OriginalImageFileName) + 1;
    pIDI->ImageFileName = (PSTR)MemAlloc(len);
    if (pIDI->ImageFileName) {
        CopyString(pIDI->ImageFileName, pIDD->OriginalImageFileName, len);
    }

    if (pIDD->pMappedCoff) {
        pIDI->CoffSymbols = (PIMAGE_COFF_SYMBOLS_HEADER)MemAlloc(pIDD->cMappedCoff);
        if (pIDI->CoffSymbols) {
            memcpy(pIDI->CoffSymbols, pIDD->pMappedCoff, pIDD->cMappedCoff);
        }
        pIDI->SizeOfCoffSymbols = pIDD->cMappedCoff;
    }

    if (pIDD->pFpo) {
        pIDI->ReservedNumberOfFpoTableEntries = pIDD->cFpo;
        pIDI->ReservedFpoTableEntries = (PFPO_DATA)pIDD->pFpo;
    }

    pIDI->SizeOfImage = pIDD->SizeOfImage;

    if (pIDD->DbgFilePath && *pIDD->DbgFilePath) {
        len = strlen(pIDD->DbgFilePath) + 1;
        pIDI->ReservedDebugFilePath = (PSTR)MemAlloc(len);
        if (pIDI->ReservedDebugFilePath) {
            CopyString(pIDI->ReservedDebugFilePath, pIDD->DbgFilePath, len);
        }
    }

    if (pIDD->pMappedCv) {
        pIDI->ReservedCodeViewSymbols       = pIDD->pMappedCv;
        pIDI->ReservedSizeOfCodeViewSymbols = pIDD->cMappedCv;
    }

    // for backwards compatibility
    if (pIDD->ImageMap) {
        sections = (DWORD)((char *)pIDD->pCurrentSections - (char *)pIDD->ImageMap);
        pIDI->ReservedMappedBase = MapItRO(pIDD->ImageFileHandle);
        if (pIDI->ReservedMappedBase) {
            pIDI->ReservedSections = (PIMAGE_SECTION_HEADER)pIDD->pCurrentSections;
            pIDI->ReservedNumberOfSections = pIDD->cCurrentSections;
            if (pIDD->ddva) {
                pIDI->ReservedDebugDirectory = (PIMAGE_DEBUG_DIRECTORY)((PCHAR)pIDI->ReservedMappedBase + pIDD->ddva);
                pIDI->ReservedNumberOfDebugDirectories = pIDD->cdd;
            }
        }
    }

    return pIDI;
}

BOOL
UnmapDebugInformation(
    PIMAGE_DEBUG_INFORMATION pIDI
    )
{
    PPIDI pPIDI;

    if (!pIDI)
        return true;

    if (pIDI->ImageFileName){
        MemFree(pIDI->ImageFileName);
    }

    if (pIDI->ImageFilePath) {
        MemFree(pIDI->ImageFilePath);
    }

    if (pIDI->ReservedDebugFilePath) {
        MemFree(pIDI->ReservedDebugFilePath);
    }

    if (pIDI->CoffSymbols) {
        MemFree(pIDI->CoffSymbols);
    }

    if (pIDI->ReservedMappedBase) {
        UnmapViewOfFile(pIDI->ReservedMappedBase);
    }

    pPIDI = (PPIDI)(PCHAR)((PCHAR)pIDI - sizeof(PIDI_HEADER));
    ReleaseDebugData(pPIDI->hdr.pIDD, IMGHLP_FREE_ALL);
    MemFree(pPIDI);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\pdbstr\pch.h ===
/*
 * pch.h for pdbstr
 */
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <strsafe.h>

#define PDB_LIBRARY
#include "pdb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\dbh\dbh.cpp ===
/*
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
 * ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 * Copyright (C) 2002.  Microsoft Corporation.  All rights reserved.
 *
 * dbh.c
 *
 * This file implements a command line utility that shows how to 
 * use the dbghelp API to query symbolic information from an image 
 * or pdb file.
 * 
 * Requires dbghelp.dll version 6.1 or greater.
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <dbghelp.h>
#include <strsafe.h>

// general #defines

#define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
#define DIMA(Array) DIMAT(Array, (Array)[0])

#ifndef true
 #define true TRUE
 #define false FALSE
#endif

#define MAX_STR         256
#define WILD_UNDERSCORE 1
#define SYM_BUFFER_SIZE (sizeof(IMAGEHLP_SYMBOL64) + MAX_SYM_NAME)
#define SI_BUFFER_SIZE (sizeof(SYMBOL_INFO) + MAX_SYM_NAME)

// for calling SymEnumSymbols

typedef struct {
    char    mask[MAX_STR];
    DWORD64 base;
} ENUMSYMDATA, *PENUMSYMDATA;

// available commands

typedef enum
{
    cmdQuit = 0,
    cmdHelp,
    cmdVerbose,
    cmdLoad,
    cmdUnload,
    cmdEnum,
    cmdName,
    cmdAddr,
    cmdBase,
    cmdNext,
    cmdPrev,
    cmdLine,
    cmdLineNext,
    cmdLinePrev,
    cmdUndec,
    cmdFindFile,
    cmdEnumSrcFiles,
    cmdAdd,
    cmdDelete,
    cmdSymbolServer,
    cmdEnumForAddr,
    cmdLocals,
    cmdMapDBI,
    cmdMulti,
    cmdType,
    cmdInfo,
    cmdObj,
    cmdEnumLines,
    cmdEnumTag,
    cmdMax
};

// this struct associates commands with functions

typedef BOOL (*CMDPROC)(char *params);

typedef struct _CMD
{
    char    token[MAX_STR + 1];
    char    shorttoken[4];
    CMDPROC fn;
} CMD, *PCMD;

// and here are the functions

BOOL fnQuit(char *);
BOOL fnHelp(char *);
BOOL fnVerbose(char *);
BOOL fnLoad(char *);
BOOL fnUnload(char *);
BOOL fnEnum(char *);
BOOL fnName(char *);
BOOL fnAddr(char *);
BOOL fnBase(char *);
BOOL fnNext(char *);
BOOL fnPrev(char *);
BOOL fnLine(char *);
BOOL fnLineNext(char *);
BOOL fnLinePrev(char *);
BOOL fnUndec(char *);
BOOL fnFindFile(char *);
BOOL fnEnumSrcFiles(char *);
BOOL fnAdd(char *);
BOOL fnDelete(char *);
BOOL fnSymbolServer(char *);
BOOL fnEnumForAddr(char *);
BOOL fnLocals(char *);
BOOL fnMap(char *);
BOOL fnMulti(char *);
BOOL fnType(char *);
BOOL fnInfo(char *);
BOOL fnObj(char *);
BOOL fnEnumLines(char *);
BOOL fnEnumTag(char *);

// array of command structs

CMD gCmd[cmdMax] =
{
    {"addr",    "a", fnAddr},
    {"base",    "b", fnBase},
//  {"",        "c", fn},
//  {"",        "d", fn},
    {"elines",  "e",  fnEnumLines},
    {"ff",      "f", fnFindFile},
//  {"",        "g", fn},
//  {"",        "h", fn},
    {"info",    "i",  fnInfo},
    {"linenext","j", fnLineNext},
    {"lineprev","k", fnLinePrev},
    {"line",    "l", fnLine},
    {"enumaddr","m", fnEnumForAddr},
    {"name",    "n", fnName},
    {"obj",     "o", fnObj},
    {"prev",    "p", fnPrev},
    {"quit",    "q", fnQuit},
    {"src",     "r", fnEnumSrcFiles},
    {"next",    "s", fnNext},
    {"type",    "t", fnType},
    {"unload",  "u", fnUnload},
    {"verbose", "v", fnVerbose},
//  {"",        "w", fn},
    {"enum",    "x", fnEnum},
    {"ss",      "y", fnSymbolServer},
    {"locals",  "z", fnLocals},
    
    {"add",     "+", fnAdd},
    {"del",     "-", fnDelete},
    {"help",    "?", fnHelp},
    {"undec",   "",  fnUndec},
    {"load",    "",  fnLoad},
    {"map",     "",  fnMap},
    {"multi",   "",  fnMulti},
    {"etag",    "",  fnEnumTag},
};

// globals

char            gModName[MAX_STR] = "";
char            gImageName[MAX_STR];
char            gSymbolSearchPath[MAX_STR];
DWORD64         gBase;
DWORD64         gDefaultBase;
DWORD64         gDefaultBaseForVirtualMods;
DWORD           gOptions;
HANDLE          gTID;
IMAGEHLP_LINE64 gLine;
char            gExecCmd[MAX_STR] = "";
char            gSrcFileName[MAX_PATH + 1] = "";
char            gObj[MAX_PATH + 1] = "";


// REMOVE

// symbol server stuff

HINSTANCE                       ghSrv;
PSYMBOLSERVERPROC               gfnSymbolServer;
PSYMBOLSERVERCLOSEPROC          gfnSymbolServerClose;
PSYMBOLSERVERSETOPTIONSPROC     gfnSymbolServerSetOptions;
PSYMBOLSERVERGETOPTIONSPROC     gfnSymbolServerGetOptions;

// REMOVE END


// Use this to display verbose information, when
// the -v switch is used.

int
dprintf(
    LPSTR Format,
    ...
    )
{
    static char buf[1000] = "";
    va_list args;

    if ((gOptions & SYMOPT_DEBUG) == 0)
        return 1;

    va_start(args, Format);
#if 0
    _vsnprintf(buf, sizeof(buf), Format, args);
#else
    StringCchVPrintf(buf, DIMA(buf), Format, args);
#endif
    va_end(args);
    fputs(buf, stdout);
    return 1;
}


__inline int ucase(int c)
{
    return (gOptions & SYMOPT_CASE_INSENSITIVE) ? toupper(c) : c;
}


#define MAX_FORMAT_STRINGS 8

char *
_dispaddr(
    ULONG64 addr,
    BOOL    pad
    )
{
    static char sz[20];

#if 0                                    
    if ((addr >> 32) != 0)
        sprintf(sz, "%8x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    else
        sprintf(sz, pad ? "         %8x" : "%8x", (ULONG)addr);
#else
    if ((addr >> 32) != 0)
        StringCchPrintf(sz, DIMA(sz), "%8x`%08x", (ULONG)(addr>>32), (ULONG)addr);
    else
        StringCchPrintf(sz, DIMA(sz), pad ? "         %8x" : "%8x", (ULONG)addr);
#endif
    return sz;
}

#define dispaddr(addr) _dispaddr(addr, false)

BOOL
validnum(
    char *sz
    )
{
    int c;

    for (; *sz; sz++)
    {
        c = tolower(*sz);
        if (c >= '0' && c <= '9')
            continue;
        if (c >= 'a' && c <= 'f')
            continue;
        return false;
    }

    return true;
}

DWORD64
sz2addr(
    char *sz
    )
{
    char   *p;
    DWORD64 addr = 0;

    if (sz && *sz)
    {
        p = sz;
        if (*(p + 1) == 'x' || *(p + 1) == 'X')
            p += 2;
        if (!validnum(p))
            return 0;
        if (sscanf(p, "%I64x", &addr) < 1)
            return 0;
    }

    return addr;
}


void _dumpsym(
    PIMAGEHLP_SYMBOL64 sym,
    BOOL               pad
    )
{
    printf(" name : %s\n", sym->Name);
    printf(" addr : %s\n", _dispaddr(sym->Address, pad));
    printf(" size : %x\n", sym->Size);
    printf("flags : %x\n", sym->Flags);
}

#define dumpsym(sym) _dumpsym(sym, false)

void dumpsym32(
    PIMAGEHLP_SYMBOL sym
    )
{
    printf(" name : %s\n", sym->Name);
    printf(" addr : %s\n", dispaddr(sym->Address));
    printf(" size : %x\n", sym->Size);
    printf("flags : %x\n", sym->Flags);
}


void dumpLine(
    PIMAGEHLP_LINE64 line
    )
{
    printf("file : %s\n", line->FileName);
    printf("line : %d\n", line->LineNumber);
    printf("addr : %s\n", dispaddr(line->Address));
}


#ifndef _WIN64
void dumpdbi(
    PIMAGE_DEBUG_INFORMATION dbi
    )
{
    printf("              List : 0x%x\n", dbi->List);
    printf("         ImageBase : 0x%x\n", dbi->ImageBase);
    printf("       SizeOfImage : 0x%x\n", dbi->SizeOfImage);
    printf(" SizeOfCoffSymbols : 0x%x\n", dbi->SizeOfCoffSymbols);
    printf("       CoffSymbols : 0x%x\n", dbi->CoffSymbols);
    printf("     ImageFilePath : %s\n",   dbi->ImageFilePath);
    printf("     ImageFileName : %s\n",   dbi->ImageFileName);
}
#endif

// This stuff displays the symbol tag descriptions.

#ifndef SymTagMax
 // normally found in cvconst.h which ships with Visual Studio
 #define SymTagMax 0x1f
#endif

char* g_SymTagNames[] =
{
    "SymTagNull",
    "SymTagExe",
    "SymTagCompiland",
    "SymTagCompilandDetails",
    "SymTagCompilandEnv",
    "SymTagFunction",
    "SymTagBlock",
    "SymTagData",
    "SymTagAnnotation",
    "SymTagLabel",
    "SymTagPublicSymbol",
    "SymTagUDT",
    "SymTagEnum",
    "SymTagFunctionType",
    "SymTagPointerType",
    "SymTagArrayType",
    "SymTagBaseType",
    "SymTagTypedef",
    "SymTagBaseClass",
    "SymTagFriend",
    "SymTagFunctionArgType",
    "SymTagFuncDebugStart",
    "SymTagFuncDebugEnd",
    "SymTagUsingNamespace",
    "SymTagVTableShape",
    "SymTagVTable",
    "SymTagCustom",
    "SymTagThunk",
    "SymTagCustomType",
    "SymTagManagedType",
    "SymTagDimension",
};

char* dispsymtag(
    ULONG symtag
    )
{
    if (symtag >= SymTagMax) {
        return "<Invalid>";
    } else {
        return g_SymTagNames[symtag];
    }
}


void dumpsi(
    PSYMBOL_INFO si
    )
{
    printf("   name : %s\n", si->Name);
    printf("   addr : %s\n", dispaddr(si->Address));
    printf("   size : %x\n", si->Size);
    printf("  flags : %x\n", si->Flags);
    printf("   type : %x\n", si->TypeIndex);
    printf("modbase : %s\n", dispaddr(si->ModBase));
    printf("  value : %s\n", dispaddr(si->Value));
    printf("    reg : %x\n", si->Register);
    printf("  scope : %s (%x)\n", dispsymtag(si->Scope), si->Scope);
    printf("    tag : %s (%x)\n", dispsymtag(si->Tag), si->Tag);
}


BOOL
CALLBACK
cbEnumSymbols(
    PSYMBOL_INFO  si,
    ULONG         size,
    PVOID         context
    )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    printf(" %8s : ", _dispaddr(si->Address, true));
    if (si->Flags & SYMF_FORWARDER)
        printf("%c ", 'F');
    else if (si->Flags & SYMF_EXPORT)
        printf("%c ", 'E');
    else
        printf("  ");
    printf("%s\n", si->Name);

    return true;
}


BOOL
CALLBACK
cbEnumObjs(
    PSYMBOL_INFO  si,
    ULONG         size,
    PVOID         context
    )
{
    PENUMSYMDATA esd = (PENUMSYMDATA)context;

    printf("%s\n", si->Name);

    return true;
}


BOOL
cbSrcFiles(
    PSOURCEFILE pSourceFile,
    PVOID       UserContext
    )
{
    if (!pSourceFile)
        return false;

    printf("%s\n", pSourceFile->FileName);

    return true;
}


BOOL
CALLBACK
cbEnumLines(
    PSRCCODEINFO sci,
    PVOID        context
    )
{
    static int cnt;

    if (!sci)
        return false;

    if (strcmp(gObj, sci->Obj) )
    {
        StringCchCopy(gObj, DIMA(gObj), sci->Obj);
        printf("\nOBJ:%s", sci->Obj);
    }
    if (strcmp(gSrcFileName, sci->FileName))
    {
        StringCchCopy(gSrcFileName, DIMA(gSrcFileName), sci->FileName);
        printf("\n   %s ", sci->FileName);
        cnt = 0;
    }

    if (cnt > 15)
        cnt = 0;
    if (!cnt)
        printf("\n     ");
    printf(" %d", sci->LineNumber);
    cnt++;

    return true;
}


BOOL
CALLBACK
cbSymbol(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch ( ActionCode )
    {
    case CBA_DEBUG_INFO:
        printf("%s", (LPSTR)CallbackData);
        break;

    default:
        return false;
    }

    return false;
}


// exit this program

BOOL fnQuit(char *param)
{
    printf("goodbye\n");
    return false;
}


// display command help

BOOL fnHelp(char *param)
{
    printf("      dbh commands :\n");
    printf("?             help : prints this message\n");
    printf("q             quit : quits this program\n");
    printf("v verbose <on/off> : controls debug spew\n");
    printf("    load <modname> : loads the requested module\n");
    printf("u           unload : unloads the current module\n");
    printf("x      enum <mask> : enumerates all matching symbols\n");
    printf("n   name <symname> : finds a symbol by it's name\n");
    printf("a      addr <addr> : finds a symbol by it's hex address\n");
    printf("m  enumaddr <addr> : lists all symbols with a certain hex address\n");
    printf("b   base <address> : sets the new default base address\n");
    printf("s   next <add/nam> : finds the symbol after the passed sym\n");
    printf("p   prev <add/nam> : finds the symbol before the passed sym\n");
    printf("l    line <file:#> : finds the matching line number\n");
    printf("j         linenext : goes to the next line after the current\n");
    printf("k         lineprev : goes to the line previous to the current\n");
    printf("f ff <path> <file> : finds file in path\n");
    printf("r       src <mask> : lists source files\n");
    printf("+  add <name addr> : adds symbols with passed name and address\n");
    printf("-  del <name/addr> : deletes symbols with passed name or address\n");
    printf("y               ss : executes a symbol server command\n");
    printf("m  enumaddr <addr> : enum all symbols for address\n");
    printf("z    locals <name> : enum all scoped symbols for a named function\n");
    printf("        map <name> : call MapDebugInfo on the named file\n");
    printf("      multi <name> : loads the requested module 1000 times\n");
    printf("t      type <name> : lists the type information for the symbol\n");
    printf("i             info : displays information about the loaded module\n");
    printf("o              obj : displays object files in the loaded module\n");
    printf("e           elines : enumerates lines for an obj and source file\n");
    printf(" etag <tag> <mask> : enumerates all symbols for a matching SymTag\n");
    printf("      undec <name> : undecorates a given symbol name\n");

    return true;
}


// display debug spew from debughlp

BOOL fnVerbose(char *param)
{
    int opts = gOptions;

    if (!param || !*param)
        printf("");
    else if (!_strcmpi(param, "on"))
        opts |= SYMOPT_DEBUG;
    else if (!_strcmpi(param, "off"))
        opts = gOptions & ~SYMOPT_DEBUG;
    else
        printf("verbose <on//off>\n");

    gOptions = SymSetOptions(opts);

    printf("verbose mode %s.\n", gOptions & SYMOPT_DEBUG ? "on" : "off");

    return true;
}


// load an image

BOOL fnLoad(char *param)
{
    char    ext[MAX_STR];
    char    mod[MAX_STR];
    DWORD   flags = 0;
    DWORD64 addr  = 0;
    DWORD   size  = 0x1000000;
    HANDLE  hf = NULL;
    BOOL    dontopen = false;

    if (!*param)
    {
        printf("load <modname> - you must specify a module to load\n");
        return true;
    }
    
    _splitpath(param, NULL, NULL, mod, ext);

    if (!*ext) {
        flags = SLMFLAG_VIRTUAL;
        addr = gDefaultBaseForVirtualMods;
    } else if (!_strcmpi(ext, ".pdb")) {
        addr = gDefaultBaseForVirtualMods;
        dontopen = true;
    } else {
        addr = gDefaultBase;
    }

    fnUnload(NULL);

    StringCchCopy(gModName, DIMA(gModName), mod);

    // you can do this with or without an open file handle

    if (!dontopen) {
        hf = CreateFile(param,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        0);
        size = GetFileSize(hf, NULL);
    }

    addr = SymLoadModuleEx(gTID,
                           hf,         // hFile,
                           param,      // ImageName,
                           mod,        // ModuleName,
                           addr,       // BaseOfDll,
                           size,       // SizeOfDll
                           NULL,       // Data
                           flags);     // Flags

    if (!addr)
    {
        *gModName = 0;
        printf("error 0x%x loading %s.\n", GetLastError(), param);
        return true;
    } 
    StringCchCopy(gImageName, DIMA(gImageName), param);
    gBase = addr;

    if (hf != INVALID_HANDLE_VALUE)
        CloseHandle(hf);

    return true;
}


// unload the image

BOOL fnUnload(char *param)
{
    if (!gBase)
        return true;

    if (!SymUnloadModule64(gTID, gBase))
        printf("error unloading %s at %s\n", gModName, dispaddr(gBase));

    gBase = 0;
    *gModName = 0;

    return true;
}


// enumerate the symbols

BOOL fnEnum(char *param)
{
    BOOL rc;
    ENUMSYMDATA esd;

    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, param ? param : "");

    rc = SymEnumSymbols(gTID, gBase, param, cbEnumSymbols, &esd);
    if (!rc)
        printf("error 0x%x calling SymEnumSymbols()\n", GetLastError());

    return true;
}


// enumerate the source files

BOOL fnEnumSrcFiles(char *param)
{
    BOOL rc;

    rc = SymEnumSourceFiles(gTID, gBase, param, cbSrcFiles, NULL);
    if (!rc)
        printf("error 0x%0 calling SymEnumSourceFiles()\n", GetLastError());

    return true;
}


// search for a symbol by name

BOOL fnName(char *param)
{
    SYMBOL_INFO_PACKAGE sip;    // this struct saves allocation code
    char         name[MAX_STR];

    if (!param || !*param)
    {
        printf("name <symbolname> - finds a symbol by it's name\n");
        return true;
    }
    StringCchPrintf(name, DIMA(name), "%s!%s", gModName, param);

    ZeroMemory(&sip, sizeof(sip));
    sip.si.MaxNameLen = MAX_SYM_NAME;

    if (SymFromName(gTID, name, &sip.si))
        dumpsi(&sip.si);

    return true;
}


// search for a symbol by address

BOOL fnAddr(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    DWORD64            disp;
    PSYMBOL_INFO       si;

    addr = sz2addr(param);
    if (!addr)
    {
        printf("addr <address> : finds a symbol by it's hex address\n");
        return true;
    }

    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    rc = SymFromAddr(gTID, addr, &disp, si);
    if (rc)
    {
        printf("%s", si->Name);
        if (disp)
            printf("+%I64x", disp);
        printf("\n");
        dumpsi(si);
    }

    free(si);

    return true;
}


// enumerate all symbols with the passed address

BOOL fnEnumForAddr(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    ENUMSYMDATA        esd;

    addr = sz2addr(param);
    if (!addr)
    {
        printf("enumaddr <addr> : lists all symbols with a certain hex address\n");
        return true;
    }

    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, "");

    rc = SymEnumSymbolsForAddr(gTID, addr, cbEnumSymbols, &esd);
    if (!rc)
        printf("error 0x%0 calling SymEnumSymbolsForAddr()\n", GetLastError());

    return true;
}


// find locals for passed symbol

BOOL fnLocals(char *param)
{
    PSYMBOL_INFO         si;
    char                 name[MAX_STR];
    IMAGEHLP_STACK_FRAME frame;
    ENUMSYMDATA          esd;

    if (!param || !*param)
    {
        printf("locals <symbolname> - finds all locals a function\n");
        return true;
    }
    StringCchPrintf(name, DIMA(name), "%s!%s", gModName, param);

    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    if (!SymFromName(gTID, name, si))
        goto exit;

    printf("dumping locals for %s...\n", si->Name);

    ZeroMemory(&frame, sizeof(frame));
    frame.InstructionOffset = si->Address;

    SymSetContext(gTID, &frame, NULL);

    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, "*");
    if (!SymEnumSymbols(gTID, 0, esd.mask, cbEnumSymbols, &esd))
        printf("error 0x%0 calling SymEnumSymbols()\n", GetLastError());

exit:
    free(si);

    return true;
}


// REMOVE

// Call MapDebugInfo. You should never do this.  
// I just put this in to test my compatibility
// with old imagehlp clients.

BOOL fnMap(char *param)
{
#ifndef _WIN64
    PIMAGE_DEBUG_INFORMATION dbi;

    if (!*param)
    {
        printf("no image specified\n");
        return true;
    }

    dbi = MapDebugInformation(NULL,   // HANDLE FileHandle,
                              param,
                              gSymbolSearchPath,
                              0);      // DWORD ImageBase

    if (!dbi)
    {
        printf("error 0x%x calling MapDebugInformation on %s\n", GetLastError(), param);
        return true;
    }

    dumpdbi(dbi);

    if (!UnmapDebugInformation(dbi))
        printf("error 0x%x calling UnmapDebugInformation on %s\n", GetLastError(), param);
#else
    printf("MapDebugInfo is not supported on 64 bit platforms.\n");
#endif
    return true;
}

// REMOVE END


// REMOVE

// use this to look for leaks in dbghelp

BOOL fnMulti(char *param)
{
    int i;

    for (i = 0; i < 1000; i++)
    {
        if (!fnLoad(param))
            return false;
        if (!fnUnload(param))
            return false;
    }

    return true;
}

// REMOVE END


// obtain simple type information

BOOL fnType(char *param)
{
    PSYMBOL_INFO si;

    if (!param || !*param)
    {
        printf("type <typename> - finds type info\n");
        return true;
    }

    si = (PSYMBOL_INFO)malloc(SI_BUFFER_SIZE);
    if (!si)
        return false;
    ZeroMemory(si, SI_BUFFER_SIZE);
    si->MaxNameLen = MAX_SYM_NAME;

    if (SymGetTypeFromName(gTID, gBase, param, si))
        dumpsi(si);

    free(si);

    return true;
}


// get module information

BOOL fnInfo(char *param)
{
	IMAGEHLP_MODULE64 mi;

    static char *symtypes[NumSymTypes] =
    {
        "SymNone",
        "SymCoff",
        "SymCv",
        "SymPdb",
        "SymExport",
        "SymDeferred",
        "SymSym",
        "SymDia",
        "SymVirtual"
    };

    ZeroMemory((void *)&mi, sizeof(mi));
    mi.SizeOfStruct = sizeof(mi);

	if (!SymGetModuleInfo64(gTID, gBase, &mi))
	{
		printf("error 0x%x calling SymGetModuleInfo64()\n", GetLastError());
		return true;
	}

    printf("    SizeOfStruct : 0x%x\n", mi.SizeOfStruct);
    printf("     BaseOfImage : 0x%i64x\n", mi.BaseOfImage);
    printf("       ImageSize : 0x%x\n", mi.ImageSize);
    printf("   TimeDateStamp : 0x%x\n", mi.TimeDateStamp);
    printf("        CheckSum : 0x%x\n", mi.CheckSum);
    printf("         NumSyms : 0x%x\n", mi.NumSyms);
    printf("         SymType : %s\n", symtypes[mi.SymType]);
    printf("      ModuleName : %s\n", mi.ModuleName);
    printf("       ImageName : %s\n", mi.ImageName);
    printf(" LoadedImageName : %s\n", mi.LoadedImageName);
    printf("   LoadedPdbName : %s\n", mi.LoadedPdbName);
    printf("           CVSig : 0x%x\n", mi.CVSig);
    printf("          CVData : %s\n", mi.CVData);
    printf("          PdbSig : 0x%x\n", mi.PdbSig);
    printf("        PdbSig70 : 0x%08x, 0x%04x, 0x%04x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x\n",
           mi.PdbSig70.Data1,
           mi.PdbSig70.Data2,
           mi.PdbSig70.Data3,
           mi.PdbSig70.Data4[0],
           mi.PdbSig70.Data4[1],
           mi.PdbSig70.Data4[2],
           mi.PdbSig70.Data4[3],
           mi.PdbSig70.Data4[4],
           mi.PdbSig70.Data4[5],
           mi.PdbSig70.Data4[6],
           mi.PdbSig70.Data4[7]);
    printf("          PdbAge : 0x%x\n", mi.PdbAge);
    printf("    PdbUnmatched : %s\n", mi.PdbUnmatched ? "true" : "false");
    printf("    DbgUnmatched : %s\n", mi.DbgUnmatched ? "true" : "false");
    printf("     LineNumbers : %s\n", mi.LineNumbers ? "true" : "false");
    printf("   GlobalSymbols : %s\n", mi.GlobalSymbols ? "true" : "false");
    printf("        TypeInfo : %s\n", mi.TypeInfo ? "true" : "false");

    return true;
}


// enumerate objs within a module

BOOL fnObj(char *param)
{
#if 0
    BOOL rc;
    ENUMSYMDATA esd;

    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, param ? param : "");

    rc = SymEnumObjs(gTID, gBase, param, cbEnumObjs, &esd);
    if (!rc)
        printf("error 0x%x calling SymEnumObjs()\n", GetLastError());
#else
    printf("not implemented\n");
#endif

    return true;
}
 

// enumerate lines within an image

BOOL fnEnumLines(char *param)
{
    BOOL rc;
    ENUMSYMDATA esd;

    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, param ? param : "");

    *gSrcFileName = 0;
    *gObj = 0;
    rc = SymEnumLines(gTID, gBase, param, NULL, cbEnumLines, &esd);
    if (!rc)
        printf("error 0x%x calling SymEnumLines()\n", GetLastError());
    else
        printf("\n");

    return true;
}


// REMOVE

// Deep search mechanism.  Don't call this.
// The API is not finished yet and it will
// be renamed when completed.

BOOL fnEnumTag(char *param)
{
#if 0
    DWORD tag;
    char  mask[4098];
    ENUMSYMDATA esd;
    
    *mask = 0;
    if (sscanf(param, "%x %s", &tag, mask) < 1) {
        printf("etags : must specify a symtag. A mask is optional\n");
        return true;
    }

    printf("symtag:%x mask:%s\n", tag, mask);
    
    esd.base = gBase;
    StringCchCopy(esd.mask, MAX_STR, param ? param : "");

    if (!SymEnumSymbolsByTag(gTID, 
                             gBase,
                             tag,
                             *mask ? mask : NULL,
                             SYMENUMFLAG_FULLSRCH,
                             cbEnumSymbols,
                             &esd))
        printf("error 0x%0 calling SymEnumSymbolsByTag()\n", GetLastError());
#else
    printf("not implemented\n");
#endif

    return true;
}

// REMOVE END


PIMAGEHLP_SYMBOL64 SymbolFromName(char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    char               name[MAX_STR];

    if (!name || !*name)
        return NULL;

    sym = (PIMAGEHLP_SYMBOL64)malloc(SYM_BUFFER_SIZE);
    if (!sym)
        return false;
    ZeroMemory(sym, SYM_BUFFER_SIZE);
    sym->MaxNameLength = MAX_SYM_NAME;

    StringCchPrintf(name, DIMA(name), "%s!%s", gModName, param);
    rc = SymGetSymFromName64(gTID, name, sym);
    if (!rc) {
        free(sym);
        return NULL;
    }

    return sym;
}


// worker function for the SymNext and SymPrev stuff

BOOL fnNextPrev(int direction, char *param)
{
    BOOL               rc;
    PIMAGEHLP_SYMBOL64 sym;
    DWORD64            addr;

    addr = sz2addr(param);
    if (!addr)
    {
        sym = SymbolFromName(param);
        if (!sym)
            return true;
        addr = sym->Address;
        if (!addr) {
            free(sym);
            return true;
        }
    }
    else
    {
        sym = (PIMAGEHLP_SYMBOL64)malloc(SYM_BUFFER_SIZE);
        if (!sym)
            return false;
        rc = SymGetSymFromAddr64(gTID, addr, NULL, sym);
        if (!rc) 
            return true;
    }

    if (direction > 0)
        rc = SymGetSymNext64(gTID, sym);
    else
        rc = SymGetSymPrev64(gTID, sym);

    if (rc)
        dumpsym(sym);

    free(sym);

    return true;
}


// find the next symbol

BOOL fnNext(char *param)
{
    return fnNextPrev(1, param);
}


// find the previous symbol

BOOL fnPrev(char *param)
{
    return fnNextPrev(-1, param);
}


// set the module base and reload, if needed

BOOL fnBase(char *param)
{
    DWORD64            addr;

    addr = sz2addr(param);
    if (!addr)
    {
        printf("base <address> : sets the base address for module loads\n");
        return true;
    }

    gDefaultBase = addr;
    gDefaultBaseForVirtualMods = addr;
    if (gBase)
        fnLoad(gImageName);

    return true;
}


// search for a line by it's name

BOOL fnLine(char *param)
{
    char              *file;
    DWORD              linenum;
    BOOL               rc;
    IMAGEHLP_LINE64    line;
    LONG               disp;

    if (!param || !*param)
        return true;

    file = param;

    while (*param != ':') {
        if (!*param)
            return true;
        param++;
    }
    *param++ = 0;
    linenum = atoi(param);
    if (!linenum)
        return true;

    memset(&line, 0, sizeof(line));
    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    rc = SymGetLineFromName64(gTID,
                              gModName,
                              file,
                              linenum,
                              &disp,
                              &line);

    if (!rc) {
        printf("line: error 0x%x looking for %s#%d\n",
               GetLastError(),
               file,
               linenum);
        return true;
    }

    dumpLine(&line);
    printf("disp : %x\n", disp);

    // save for future next/prev calls

    memcpy(&gLine, &line, sizeof(gLine));

    return true;
}


// worker function for the LineNext and LinePrev stuff

BOOL lineNextPrev(BOOL prev)
{
    BOOL               rc;
    IMAGEHLP_LINE64    line;

    if (!gLine.SizeOfStruct)
        return true;
    memcpy(&line, &gLine, sizeof(line));

    if (prev) 
        rc = SymGetLinePrev64(gTID, &line);
    else 
        rc = SymGetLineNext64(gTID, &line);

    if (!rc) {
        printf("line: error 0x%x looking for %s#%d\n",
               GetLastError(),
               line.FileName,
               line.LineNumber);
        return true;
    }

    dumpLine(&line);

    // save for future next/prev calls

    memcpy(&gLine, &line, sizeof(gLine));

    return true;
}


// find the next line

BOOL fnLineNext(char *param)
{
    return lineNextPrev(false);
}


// find the previous line

BOOL fnLinePrev(char *param)
{
    return lineNextPrev(true);
}


// undecorate a symbol name

BOOL fnUndec(char *param)
{
    DWORD rc;
    char uname[MAX_SYM_NAME + 1];

    if (!param || !*param)
    {
        printf("undec <symbolname> - undecorates a C++ mangled symbol name\n");
        return true;
    }

    rc = UnDecorateSymbolName(param, uname, MAX_SYM_NAME, UNDNAME_COMPLETE);
    if (!rc) 
        printf("error 0x%u undecorating %s\n", GetLastError(), param);
    else
        printf("%s =\n%s\n", param, uname);

    return true;
}


// search for a file in a tree

BOOL fnFindFile(char *param)
{
    DWORD rc;
    char  root[MAX_PATH + 1];
    char  file[MAX_PATH + 1];
    char  found[MAX_PATH + 1];

    if (!param)
    {
        printf("ff <root path> <file name> - finds file in path\n");
        return true;
    }

    rc = sscanf(param, "%s %s", root, file);
    if ((rc < 2) || !*root || !*file)
    {
        printf("ff <root path> <file name> - finds file in path\n");
        return true;
    }

    *found = 0;

    rc = SearchTreeForFile(root, file, found);

    if (!rc) {
        printf("error 0x%u looking for %s\n", GetLastError(), file);
    } else {
        printf("found %s\n", found);
    }

    return true;
}


// create a virtual symbol

BOOL fnAdd(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    DWORD              size;
    char              *p;
    char               name[MAX_STR];
    char              *n;

    if (!param || !*param) {
        printf("add <name address> : must specify a symbol name, address, and size.\n");
        return true;
    }

    p = param;
    while (isspace(*p)) p++;
    *name = 0;
    for (n = name; *p; p++, n++) {
        if (isspace(*p)) {
            *n = 0;
            break;
        }
        *n = *p;
    }

    addr = 0;
    size = 0;
    while (isspace(*p)) p++;
    if (*(p + 1) == 'x' || *(p + 1) == 'X')
        p += 2;
    rc = sscanf(p, "%I64x %x", &addr, &size);
    if ((rc < 2) || !addr || !*name)
    {
        printf("add <name address> : must specify a symbol name, address, and size.\n");
        return true;
    }

    rc = SymAddSymbol(gTID, 0, name, addr, size, 0);
    if (!rc)
        printf("Error 0x%x trying to add symbol\n", GetLastError());

    return true;
}


// delete a virtual symbol

BOOL fnDelete(char *param)
{
    BOOL               rc;
    DWORD64            addr;
    DWORD              err;
    char              *name = NULL;

    if (!param || !*param) {
        printf("del <name/address> : must specify a symbol name or address to delete.\n");
        return true;
    }

    addr = sz2addr(param);
    if (!addr)
        name = param;

    rc = SymDeleteSymbol(gTID, 0, name, addr, 0);
    if (!rc) {
        err = GetLastError();
        if (err == ERROR_NOT_FOUND)
            printf("Couldn't find %s to delete.\n", param);
        else
            printf("Error 0x%x trying to delete symbol\n", err);
    }

    return true;
}


// REMOVE

// This command is of no use.  It exists just for testing
// the symbol server.  You should use the symbol server 
// through dbghelp.  If you need to get a file directly, 
// call SymFindFileInPath().

BOOL fnSymbolServer(char *param)
{
    DWORD opt  = 0;
    DWORD data = 0;

    // initialize server, if needed

    if (ghSrv == (HINSTANCE)INVALID_HANDLE_VALUE)
        return false;

    if (!ghSrv) {
        ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        ghSrv = LoadLibrary("symsrv.dll");
        if (ghSrv) {
            gfnSymbolServer = (PSYMBOLSERVERPROC)GetProcAddress(ghSrv, "SymbolServer");
            if (!gfnSymbolServer) {
                FreeLibrary(ghSrv);
                ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
            }
            gfnSymbolServerClose = (PSYMBOLSERVERCLOSEPROC)GetProcAddress(ghSrv, "SymbolServerClose");
            gfnSymbolServerSetOptions = (PSYMBOLSERVERSETOPTIONSPROC)GetProcAddress(ghSrv, "SymbolServerSetOptions");
            gfnSymbolServerGetOptions = (PSYMBOLSERVERGETOPTIONSPROC)GetProcAddress(ghSrv, "SymbolServerGetOptions");
        } else {
            ghSrv = (HINSTANCE)INVALID_HANDLE_VALUE;
        }
    }

    // bail, if we have no valid server

    if (ghSrv == INVALID_HANDLE_VALUE
        || !gfnSymbolServerClose
        || !gfnSymbolServerSetOptions
        || !gfnSymbolServerGetOptions)
    {
        printf("SymSrv load failure.\n");
        return false;
    }

    if (param)
    {
        if (sscanf(param, "%x %x", &opt, &data) > 1)
        {
            if (opt)
                gfnSymbolServerSetOptions(opt, data);
        }
    }
    opt = (DWORD)gfnSymbolServerGetOptions();
    printf("SYMSRV options: 0x%x\n", opt);

    return true;
}

// REMOVE END


// read the command line

char *GetParameters(char *cmd)
{
    char *p     = cmd;
    char *param = NULL;

    while (*p++)
    {
        if (isspace(*p))
        {
            *p++ = 0;
             return *p ? p : NULL;
        }
    }

    return NULL;
}


void prompt()
{
    if (!*gModName)
        printf("dbh: ");
    else
        printf("%s [%I64x]: ", gModName, gBase);
}


char *
getstr(
    char *buf,
    int size
    )
{
    char *rc;

    rc = fgets(buf, size, stdin);
    if (!rc)
        return 0;

    while (*buf)
    {
        switch (*buf)
        {
        case 0xa:
            *buf = 0;
            // pass through
        case 0:
            return rc;
        }
        buf++;
    }

    return rc;
}


int InputLoop()
{
    char  cmd[MAX_STR + 1];
    char *params;
    int   i;
    BOOL  rc;

    do
    {
        rc = true;
        prompt();
        if (*gExecCmd) {
            StringCchCopy(cmd, DIMA(cmd), gExecCmd);
            printf(cmd);
            printf("\n");
        } else if (!getstr(cmd, sizeof(cmd)))
            return 0;
        params = GetParameters(cmd);

        for (i = 0; i < cmdMax; i++)
        {
            if (!_strcmpi(cmd, gCmd[i].token) 
                || !_strcmpi(cmd, gCmd[i].shorttoken))
            {
                break;
            }
        }

        if (i == cmdMax)
            printf("[%s] is an unrecognized command.\n", cmd);
        else
            rc = gCmd[i].fn(params);

        if (*gExecCmd)
            rc = false;
    } while (rc);

    return 0;
}


BOOL init()
{
    int i;
    BOOL rc;

    *gModName = 0;
    gBase = 0;;
    gDefaultBaseForVirtualMods = 0x1000000;
    gDefaultBase = 0x1000000;
    ZeroMemory(&gLine, sizeof(gLine));

    dprintf("dbh: initializing...\n");
    i = GetEnvironmentVariable("_NT_SYMBOL_PATH", gSymbolSearchPath, MAX_STR);
    if (i < 1)
        *gSymbolSearchPath = 0;
    dprintf("Symbol Path = [%s]\n", gSymbolSearchPath);

    gTID = (HANDLE)(ULONG_PTR)GetCurrentThreadId();
    rc = SymInitialize(gTID, gSymbolSearchPath, false);
    if (!rc)
    {
        printf("error 0x%x from SymInitialize()\n", GetLastError());
        return rc;
    }
    rc = SymInitialize(gTID, gSymbolSearchPath, false);
    if (!rc)
    {
        printf("error 0x%x from SymInitialize()\n", GetLastError());
        return rc;
    }

    gOptions = SymSetOptions(SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES | SYMOPT_ALLOW_ABSOLUTE_SYMBOLS | SYMOPT_AUTO_PUBLICS);
    dprintf("SymOpts = 0x%x\n", gOptions);

    rc = SymRegisterCallback64(gTID, cbSymbol, 0);
    if (!rc)
    {
        printf("error 0x%x from SymRegisterCallback64()\n", GetLastError());
        return rc;
    }

    return rc;
}


void cleanup()
{
    int i;

    fnUnload(NULL);
    for (i = 0; i < 50; i++)
        SymCleanup(gTID);
}


BOOL cmdline(int argc, char *argv[])
{
    int   i;
    char *p;

    for (i = 1; i < argc; i++)
    {
        p = argv[i];
        switch (*p)
        {
        case '/':
        case '-':
            p++;
            switch (tolower(*p))
            {
            case 'v':
                fnVerbose("on");
                break;
            default:
                printf("%s is an unknown switch\n", argv[i]);
                break;
            }
            break;

        default:
            if (*gModName) {
                StringCchCat(gExecCmd, DIMA(gExecCmd), argv[i]);
                StringCchCat(gExecCmd, DIMA(gExecCmd), " ");
            } else
                fnLoad(argv[i]);
            break;
        }
    }

    return true;
}

#include <crtdbg.h>

__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD rc;
    
    _CrtSetDbgFlag( ( _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_LEAK_CHECK_DF ) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG ) );

    if (!init())
        return 1;
    cmdline(argc, argv);
    rc = InputLoop();
    cleanup();

    _CrtDumpMemoryLeaks();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\mdi\main.c ===
/*
 * This code implements the old MapDebugInformation API.
 *
 * For source to MapDebugInformation, check out mdi.c
 */

#include <pch.h>

BOOL fVerbose;
BOOL fRemote;

UCHAR CurrentImageName[ MAX_PATH + 1 ];
UCHAR SymbolPath[ MAX_PATH + 1 ];

void
Usage( void )
{
    fputs("usage: DBGDUMP [-?] [-v] [-r] image-names...\n"
          "              [-?] display this message\n"
          "              [-v] verbose output\n"
          "              [-r symbol path] assume image names are from remote system.\n",
          stderr);
    exit( 1 );
}

#ifndef _WIN64

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    );

#endif

VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    );


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
#ifdef _WIN64
	printf("MapDebugInformation() is not supported on 64 bit platforms.\n");
#else
    char c, *s;
    LPSTR FilePart;
    HANDLE FileHandle;
    PIMAGE_DEBUG_INFORMATION DebugInfo;

    if (argc <= 1) {
        Usage();
        }

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (c = *++s)
                switch (toupper( c )) {
                case '?':
                    Usage();
                    break;

                case 'V':
                    fVerbose = TRUE;
                    break;

                case 'R':
                    if (--argc) {
                        StringCchCopy( (PCHAR) SymbolPath, MAX_PATH, *++argv );
                        fRemote = TRUE;
                        }
                    else {
                        fprintf( stderr, "DBGDUMP: Argument to /%c switch missing\n", c );
                        Usage();
                        }
                    break;

                default:
                    fprintf( stderr, "DBGDUMP: Invalid switch - /%c\n", c );
                    Usage();
                    break;
                }
            }
        else {
            DebugInfo = NULL;
            if (!fRemote) {
                if (!GetFullPathNameA( s, sizeof( CurrentImageName ), (PCHAR) CurrentImageName, &FilePart )) {
                    fprintf( stderr, "DBGDUMP: invalid file name - %s (%u)\n", s, GetLastError() );
                    }
                else {
                    FileHandle = CreateFileA( (PCHAR)CurrentImageName,
                                             GENERIC_READ,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL
                                           );
                    if (FileHandle == INVALID_HANDLE_VALUE) {
                        fprintf( stderr, "DBGDUMP: unable to open - %s (%u)\n", CurrentImageName, GetLastError() );
                        }
                    else {
                        DebugInfo = MapDebugInformation( FileHandle, NULL, NULL, 0 );
                        }
                    }
                }
            else {
                StringCchCopy( (PCHAR) CurrentImageName, MAX_PATH, s );
                DebugInfo = MapDebugInformation( NULL, (PCHAR) CurrentImageName, (PCHAR) SymbolPath, 0 );
                }

            if (DebugInfo != NULL) {
                ShowDebugInfo( DebugInfo );
                UnmapDebugInformation( DebugInfo );
                }
            }
        }

    exit( 0 );
#endif  // #if defined(_WIN64)
    return 0;
}


#ifndef _WIN64

VOID
DumpSectionHeader(
    IN ULONG i,
    IN PIMAGE_SECTION_HEADER Sh
    )
{
    PCHAR name;
    ULONG li, lj;
    USHORT memFlags, alignFlags;

    printf( "\nSECTION HEADER #%hX\n% 8.8s name\n", i, Sh->Name );

    printf( "% 8lX physical address\n% 8lX virtual address\n% 8lX size of raw data\n% 8lX file pointer to raw data\n% 8lX file pointer to relocation table\n",
           Sh->Misc.PhysicalAddress,
           Sh->VirtualAddress,
           Sh->SizeOfRawData,
           Sh->PointerToRawData,
           Sh->PointerToRelocations );

    printf( "% 8lX file pointer to line numbers\n% 8hX number of relocations\n% 8hX number of line numbers\n% 8lX flags\n",
           Sh->PointerToLinenumbers,
           Sh->NumberOfRelocations,
           Sh->NumberOfLinenumbers,
           Sh->Characteristics );

    memFlags = alignFlags = 0;
    for (li=Sh->Characteristics, lj=0L; li; li=li>>1, lj++) {
        if (li & 1) {
            switch((li & 1) << lj) {
                case IMAGE_SCN_TYPE_NO_PAD    : name = (PCHAR) "No Pad"; break;


                case IMAGE_SCN_CNT_CODE       : name = (PCHAR) "Code"; break;
                case IMAGE_SCN_CNT_INITIALIZED_DATA : name = (PCHAR) "Initialized Data"; break;
                case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = (PCHAR) "Uninitialized Data"; break;

                case IMAGE_SCN_LNK_OTHER      : name = (PCHAR) "Other"; break;
                case IMAGE_SCN_LNK_INFO       : name = (PCHAR) "Info"; break;
                case IMAGE_SCN_LNK_REMOVE     : name = (PCHAR) "Remove"; break;
                case IMAGE_SCN_LNK_COMDAT     : name = (PCHAR) "Communal"; break;

                case IMAGE_SCN_ALIGN_1BYTES   :
                case IMAGE_SCN_ALIGN_2BYTES   :
                case IMAGE_SCN_ALIGN_4BYTES   :
                case IMAGE_SCN_ALIGN_8BYTES   :
                case IMAGE_SCN_ALIGN_16BYTES  :
                case IMAGE_SCN_ALIGN_32BYTES  :
                case IMAGE_SCN_ALIGN_64BYTES  : name = (PCHAR) ""; break;

                case IMAGE_SCN_MEM_DISCARDABLE: name = (PCHAR) "Discardable"; break;
                case IMAGE_SCN_MEM_NOT_CACHED : name = (PCHAR) "Not Cached"; break;
                case IMAGE_SCN_MEM_NOT_PAGED  : name = (PCHAR) "Not Paged"; break;
                case IMAGE_SCN_MEM_SHARED     : name = (PCHAR) "Shared"; break;
                case IMAGE_SCN_MEM_EXECUTE    : name = (PCHAR) ""; memFlags |= 1; break;
                case IMAGE_SCN_MEM_READ       : name = (PCHAR) ""; memFlags |= 2; break;
                case IMAGE_SCN_MEM_WRITE      : name = (PCHAR) ""; memFlags |= 4; break;


                default : name = (PCHAR) "RESERVED - UNKNOWN";
            }
            if (*name) {
                printf( "         %s\n", name );
            }
        }
    }

    if (Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
        switch(Sh->Characteristics & IMAGE_SCN_ALIGN_64BYTES) {
            case IMAGE_SCN_ALIGN_1BYTES  : name = (PCHAR) "Align1";  break;
            case IMAGE_SCN_ALIGN_2BYTES  : name = (PCHAR) "Align2";  break;
            case IMAGE_SCN_ALIGN_4BYTES  : name = (PCHAR) "Align4";  break;
            case IMAGE_SCN_ALIGN_8BYTES  : name = (PCHAR) "Align8";  break;
            case IMAGE_SCN_ALIGN_16BYTES : name = (PCHAR) "Align16"; break;
            case IMAGE_SCN_ALIGN_32BYTES : name = (PCHAR) "Align32"; break;
            case IMAGE_SCN_ALIGN_64BYTES : name = (PCHAR) "Align64"; break;
        }
        printf( "         %s\n", name );
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = (PCHAR) "Execute Only"; break;
            case 2 : name = (PCHAR) "Read Only"; break;
            case 3 : name = (PCHAR) "Execute Read"; break;
            case 4 : name = (PCHAR) "Write Only"; break;
            case 5 : name = (PCHAR) "Execute Write"; break;
            case 6 : name = (PCHAR) "Read Write"; break;
            case 7 : name = (PCHAR) "Execute Read Write"; break;
            default : name = (PCHAR) "Unknown Memory Flags"; break;
        }
        printf( "         %s\n", name );
    }
}


char *FrameType[] = {
    "FRAME_FPO",
    "FRAME_TRAP",
    "FRAME_TSS",
    "FRAME_NONFPO",
    "FRAME_UNKNOWN"
};

void
ShowDebugInfo(
    PIMAGE_DEBUG_INFORMATION DebugInfo
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER Section;
    PIMAGE_FUNCTION_ENTRY FunctionEntry;
    PFPO_DATA FpoEntry;
    LPSTR s;


    printf( "Debug information at % p\n", DebugInfo );
    printf( "    Size             % 8lx\n", DebugInfo->ReservedSize );
    printf( "    Mapped at        % p\n", DebugInfo->ReservedMappedBase );
    printf( "    Machine          % 8hx\n", DebugInfo->ReservedMachine );
    printf( "    Characteristics  % 8hx\n", DebugInfo->ReservedCharacteristics );
    printf( "    Time/Date stamp  % 8lx",   DebugInfo->ReservedTimeDateStamp );
    if (DebugInfo->ReservedTimeDateStamp && (s = ctime( (time_t *)&DebugInfo->ReservedTimeDateStamp ))) {
        printf( " %s", s );
        }
    else {
        putchar( '\n' );
        }
    printf( "    CheckSum         % 8lx\n", DebugInfo->ReservedCheckSum );
    printf( "    ImageBase        % 8lx\n", DebugInfo->ImageBase );
    printf( "    SizeOfImage      % 8lx\n", DebugInfo->SizeOfImage );
    printf( "    NumberOfSections % 8lx\n", DebugInfo->ReservedNumberOfSections );
    printf( "    ExportedNamesSize% 8lx\n", DebugInfo->ReservedExportedNamesSize );
    printf( "    #Function Entries% 8lx\n", DebugInfo->ReservedNumberOfFunctionTableEntries );
    printf( "    #FPO Entries     % 8lx\n", DebugInfo->ReservedNumberOfFpoTableEntries );
    printf( "    Coff Symbol Size % 8lx\n", DebugInfo->SizeOfCoffSymbols );
    printf( "    CV Symbol Size   % 8lx\n", DebugInfo->ReservedSizeOfCodeViewSymbols );
    printf( "    Image Path               %s\n", DebugInfo->ImageFilePath );
    printf( "    Image Name               %s\n", DebugInfo->ImageFileName );
    printf( "    Debug Path               %s\n", DebugInfo->ReservedDebugFilePath );
    printf( "\n" );

    if (DebugInfo->ReservedNumberOfSections != 0) {
        printf( "Section Headers:\n" );
        Section = DebugInfo->ReservedSections;
        for (i=0; i<DebugInfo->ReservedNumberOfSections; i++) {
            DumpSectionHeader( i, Section++ );
            }
        printf( "\n" );
        }

    if (DebugInfo->ReservedExportedNamesSize != 0) {
        printf( "Exported Names:\n" );
        s = DebugInfo->ReservedExportedNames;
        while (*s) {
            printf( "    %s\n", s );
            while (*s++) {
                }
            }
        printf( "\n" );
        }

    if (DebugInfo->ReservedNumberOfFunctionTableEntries != 0) {
        printf( "Function Table:\n" );
        FunctionEntry = DebugInfo->ReservedFunctionTableEntries;
        for (i=0; i<DebugInfo->ReservedNumberOfFunctionTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x\n",
                    i,
                    FunctionEntry->StartingAddress,
                    FunctionEntry->EndingAddress,
                    FunctionEntry->EndOfPrologue
                  );

            FunctionEntry += 1;
            }
        printf( "\n" );
        }

    if (DebugInfo->ReservedNumberOfFpoTableEntries != 0) {
        printf( "FPO Table:\n" );
        FpoEntry = DebugInfo->ReservedFpoTableEntries;
        for (i=0; i<DebugInfo->ReservedNumberOfFpoTableEntries; i++) {
            printf( "    % 4x: % 8x % 8x % 8x [%02x %1x%s%s %s]\n",
                    i,
                    FpoEntry->ulOffStart,
                    FpoEntry->cbProcSize,
                    FpoEntry->cdwParams,
                    FpoEntry->cbProlog,
                    FpoEntry->cbRegs,
                    FpoEntry->fHasSEH ? " SEH" : "",
                    FpoEntry->fUseBP ? " EBP" : "",
                    FrameType[ FpoEntry->cbFrame ]
                  );

            FpoEntry += 1;
            }

        printf( "\n" );
        }

    return;
}

#endif // #ifndef _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\pdbstr\pdbstr.cpp ===
#include "pch.h"

typedef enum {
    fncRead = 0,
    fncWrite,
    fncNone
};

int parseargs(int argc, char **argv, char *pdb, char *input, char *stream, DWORD size);
int getcontent(char *filename, char **content);
int ProcessPDB6(int argc, char **argv, char **env);

#define fileexists(path) (GetFileAttributes(path) != 0xFFFFFFFF)

extern "C" int __cdecl main(int argc, char **argv, char **env)
{
    BOOL rc;
    int fnc = fncNone;
    char pdbname[MAX_PATH];
    char input[MAX_PATH];
    char streamname[MAX_PATH];
    PDB *pdb;
    EC ec;
    char errormsg[cbErrMax];
    Stream* pstream;
    char *buf = NULL;
    long  size;
    long  cb;
    bool success = false;

    fnc = parseargs(argc, argv, pdbname, input, streamname, MAX_PATH);
    if (fnc == fncNone)
        return success;

    *errormsg = 0;
    rc = PDBOpen(pdbname,
                 (fnc == fncRead) ? "r" : "w",
                 0,
                 &ec,
                 errormsg,
                 &pdb);
    if (!rc)
    {
        if (ec == ERROR_BAD_FORMAT)
            return ProcessPDB6(argc, argv, env);

        printf("error 0x%x opening %s\n", ec, pdbname);
        return success;
    }

    rc = PDBOpenStream(pdb, streamname, &pstream);
    if (!rc)
    {
        printf( "Could not open stream %s in %s.\n", streamname, pdbname);
        goto cleanup;
    }

    if (fnc == fncWrite)
    {
        size = getcontent(input, &buf);
        if (!size)
            goto cleanup;

        rc = StreamReplace(pstream, (void *)buf, (DWORD)size);
        if ( !rc )
        {
            printf( "StreamReplace failed for %s(%s).\n", pdbname, streamname);
            goto cleanup;
        }

        rc = PDBCommit( pdb );
        if ( !rc ) {
            printf( "PDBCommit failed for %s.\n", pdbname);
            goto cleanup;
        }
        success = true;
    }
    else if (fnc == fncRead)
    {
        size = StreamQueryCb(pstream);
        if (!size)
            goto cleanup;

        buf = (char *)calloc(size + 1, sizeof(char));
        if (!buf)
            goto cleanup;

        cb = size;
        rc = StreamRead(pstream, 0, buf, &cb);
        if (!rc)
            goto cleanup;
        if (cb != size)
            goto cleanup;
        printf(buf);
        success = true;
    }

cleanup:
    if (buf)
        free(buf);

    if (pdb)
        rc = PDBClose(pdb);

    return success ? 0 : -1;
}


bool parsesz(char *sz, char *file, DWORD size)
{
    if (*(sz + 2) != ':')
        return false;

    StringCchCopy(file, size, sz + 3);
    return (*file) ? true : false;
    return (GetFileAttributes(file) == 0xFFFFFFFF) ? false : true;
}

int parseerror()
{
    printf("pdbstr -r/w -p:PdbFileName -i:StreamFileName -s:StreamName\n");
    return fncNone;
}


int parseargs(int argc, char **argv, char *pdb, char *input, char *stream, DWORD size)
{
    // all input strings must be the same size

    int i;
    int rc;
    char *sz;

    rc = fncNone;
    assert(pdb && input && stream);
    *pdb = *input = *stream = 0;

    for (i = 0; i < argc; i++, argv++)
    {
        if (!i)
            continue;

        sz = *argv;
        if (*sz == '-' || *sz == '/')
        {
            switch(*(sz + 1))
            {
            case 'r':
            case 'R':
                rc = fncRead;
                break;
            case 'w':
            case 'W':
                rc = fncWrite;
                break;
            case 'p':
            case 'P':
                if (!parsesz(sz, pdb, size))
                    return parseerror();
                break;
            case 'i':
            case 'I':
                if (!parsesz(sz, input, size))
                    return parseerror();
                break;
            case 's':
            case 'S':
                if (!parsesz(sz, stream, size))
                    return parseerror();
                break;
            default:
                return parseerror();
            }
        }
    }

    if (rc == fncNone)
        return parseerror();
    if (!fileexists(pdb))
        return parseerror();
    if (!*stream)
        return parseerror();
    if ((rc == fncWrite) && !fileexists(input))
        return parseerror();

    return rc;
}


int getcontent(char *filename, char **buf)
{
    HANDLE hptr;
    DWORD  size;
    DWORD  cb;
    LPSTR  p;
    bool   success = false;

    hptr = CreateFile(filename,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hptr == INVALID_HANDLE_VALUE)
        return 0;

    // test validity of file pointer

    size = GetFileSize(hptr, NULL);
    if (!size)
        goto cleanup;

    // allocate space for file

    *buf = (char *)calloc(size, sizeof(char));
    if (!*buf)
        goto cleanup;

    // read it in

    if (!ReadFile(hptr, *buf, size, &cb, 0))
        goto cleanup;

    if (cb != size)
        goto cleanup;

    success = true;

cleanup:
    // done

    if (hptr)
        CloseHandle(hptr);

    if (!success)
    {
        if (*buf)
            free(*buf);
        return 0;
    }

    return size;
}


// all this stuff handles PDB6 format

typedef BOOL (PDBCALL *PfnPDBOpenStream)(PDB* ppdb, const char* szStream, OUT Stream** ppstream);
typedef BOOL (PDBCALL *PfnStreamReplace)(Stream* pstream, void* pvBuf, long cbBuf);
typedef BOOL (PDBCALL *PfnPDBCommit)(PDB* ppdb);
typedef BOOL (PDBCALL *PfnPDBClose)(PDB* ppdb);

PfnPDBOpen fnPDBOpen = NULL;
PfnPDBOpenStream fnPDBOpenStream = NULL;
PfnStreamReplace fnStreamReplace = NULL;
PfnPDBCommit fnPDBCommit = NULL;
PfnPDBClose fnPDBClose = NULL;

int ProcessPDB6(int argc, char **argv, char **env)
{
    BOOL rc;
    int fnc = fncNone;
    char pdbname[MAX_PATH];
    char input[MAX_PATH];
    char streamname[MAX_PATH];
    PDB *pdb;
    EC ec;
    char errormsg[cbErrMax];
    Stream* pstream;
    char *buf = NULL;
    long  size;
    long  cb;
    bool success = false;

    HINSTANCE hmspdb;

    fnc = parseargs(argc, argv, pdbname, input, streamname, MAX_PATH);
    if (fnc == fncNone)
        return success;

    hmspdb = LoadLibrary("mspdb60.dll");
    if (!hmspdb) 
    {
        printf("error 0x%x loading mspdb60.dll\n", GetLastError());
        return success;
    }
    fnPDBOpen = (PfnPDBOpen)GetProcAddress(hmspdb, "PDBOpen");
    fnPDBOpenStream = (PfnPDBOpenStream)GetProcAddress(hmspdb, "PDBOpenStream");
    fnStreamReplace = (PfnStreamReplace)GetProcAddress(hmspdb, "StreamReplace");
    fnPDBCommit = (PfnPDBCommit)GetProcAddress(hmspdb, "PDBCommit");
    fnPDBClose = (PfnPDBClose)GetProcAddress(hmspdb, "PDBClose");
    if (!fnPDBOpen || !fnPDBOpenStream || !fnStreamReplace || !fnPDBCommit || !fnPDBClose) 
    {
        printf("error 0x%x searching for exports in mspdb60.dll\n", GetLastError());
        return success;
    }

    *errormsg = 0;
    rc = fnPDBOpen(pdbname,
                   (fnc == fncRead) ? "r" : "w",
                   0,
                   &ec,
                   errormsg,
                   &pdb);
    if (!rc)
    {
        printf("error 0x%x opening %s\n", ec, pdbname);
        return success;
    }

    rc = fnPDBOpenStream(pdb, streamname, &pstream);
    if (!rc)
    {
        printf( "Could not open stream %s in %s.\n", streamname, pdbname);
        goto cleanup;
    }

    if (fnc == fncWrite)
    {
        size = getcontent(input, &buf);
        if (!size)
            goto cleanup;

        rc = fnStreamReplace(pstream, (void *)buf, (DWORD)size);
        if ( !rc )
        {
            printf( "StreamReplace failed for %s(%s).\n", pdbname, streamname);
            goto cleanup;
        }

        rc = fnPDBCommit( pdb );
        if ( !rc ) {
            printf( "PDBCommit failed for %s.\n", pdbname);
            goto cleanup;
        }
        success = true;
    }
    else if (fnc == fncRead)
    {
        size = StreamQueryCb(pstream);
        if (!size)
            goto cleanup;

        buf = (char *)calloc(size + 1, sizeof(char));
        if (!buf)
            goto cleanup;

        cb = size;
        rc = StreamRead(pstream, 0, buf, &cb);
        if (!rc)
            goto cleanup;
        if (cb != size)
            goto cleanup;
        printf(buf);
        success = true;
    }

cleanup:
    if (buf)
        free(buf);

    if (pdb)
        rc = fnPDBClose(pdb);

    return success ? 0 : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\browse.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    browse.cpp

Abstract:
    This file implements the functions that make use of the common
    file open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


static _TCHAR  szHelpFileName[MAX_PATH];
static _TCHAR  szLastWaveFile[MAX_PATH];
static _TCHAR  szLastDumpFile[MAX_PATH];



int CALLBACK
BrowseHookProc(
    HWND hwnd,
    UINT message,
    LPARAM lParam,
    LPARAM lpData
    )

/*++

Routine Description:

    Hook procedure for directory browse common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and set the edit so that the common file dialog dll
    thinks the user entered a value.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - Caller's data

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    switch (message) {
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    }

    return FALSE;
}

BOOL
BrowseForDirectory(
    HWND hwnd,
    _TCHAR *szCurrDir,
    DWORD len
    )

/*++

Routine Description:

    Presents a common file open dialog that contains only the directory
    tree.  The use can select a directory for use as a storage location
    for the DRWTSN32 log file.

Arguments:

    szCurrDir  - current directory

Return Value:

    TRUE       - got a good directory (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szCurrDir is also changed to have the selected directory.

--*/

{
    BROWSEINFO    browseinfo;
    LPITEMIDLIST  pitemidlist;
    _TCHAR          title      [MAX_PATH];
    _TCHAR          fname      [MAX_PATH];
    _TCHAR          szDir      [MAX_PATH];

    browseinfo.hwndOwner = hwnd;
    browseinfo.pidlRoot  = NULL;
    browseinfo.pszDisplayName = fname;
    LoadRcStringBuf( IDS_LOGBROWSE_TITLE, title, _tsizeof(title) );
    browseinfo.lpszTitle = title;
    browseinfo.ulFlags = BIF_NEWDIALOGSTYLE |
                         BIF_RETURNONLYFSDIRS ;
    browseinfo.lpfn = BrowseHookProc;
    browseinfo.lParam = (LPARAM) szCurrDir;
    
    if (pitemidlist = SHBrowseForFolder(&browseinfo)) {
        if (SHGetPathFromIDList(pitemidlist, 
                                szDir )) {
            lstrcpyn( szCurrDir, szDir, len );
            return TRUE;
        }
    }
    return FALSE;
}

UINT_PTR
WaveHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure for wave file selection common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and provide a test button for listening to a wave file.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    _TCHAR szWave[MAX_PATH];
    NMHDR *pnmhdr;

    switch (message) {
        case WM_INITDIALOG:
            SetForegroundWindow( hwnd );
            return (TRUE);
            break;

        case WM_COMMAND:
            switch (wParam) {
            case ID_TEST_WAVE:
                CommDlg_OpenSave_GetFilePath(GetParent(hwnd), szWave, sizeof(szWave) / sizeof(_TCHAR));
                PlaySound( szWave, NULL, SND_FILENAME );
                break;

            }
            break;

    case WM_NOTIFY:
        pnmhdr = (NMHDR *) lParam;
        if (pnmhdr->code == CDN_HELP) {
            LPOFNOTIFY pofn = (LPOFNOTIFY) lParam;
            
            PostMessage(pofn->lpOFN->hwndOwner, IDH_WAVE_FILE, 0 , 0);
            
            return TRUE;


            GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
            HtmlHelp(pofn->lpOFN->hwndOwner,
                    szHelpFileName,
                    HH_DISPLAY_TOPIC,
                    (DWORD_PTR) (IDHH_WAVEFILE)
                    );
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
GetWaveFileName(
    HWND hwnd,
    _TCHAR *szWaveName,
    DWORD len
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    wave file to be played when an application error occurs.

Arguments:

    szWaveName - name of the selected wave file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szWaveName is changed to have the selected wave file name.

--*/

{
    OPENFILENAME   of;
    _TCHAR           ftitle[MAX_PATH];
    _TCHAR           title[MAX_PATH];
    _TCHAR           fname[MAX_PATH];
    _TCHAR           filter[1024];
    _TCHAR           szDrive    [_MAX_DRIVE];
    _TCHAR           szDir      [_MAX_DIR];
    _TCHAR           szDefExt[]=_T("*.wav");

    LPTSTR           pszfil;

    ZeroMemory(&of, sizeof(OPENFILENAME));
    ftitle[0] = 0;
    lstrcpyn( fname, (*szWaveName ? szWaveName : szDefExt), _tsizeof(fname) );
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = GetModuleHandle( NULL );
    LoadRcStringBuf( IDS_WAVE_FILTER, filter, _tsizeof(filter) - 1);
    pszfil=&filter[_tcslen(filter)+1];
    if (pszfil < filter + (_tsizeof(filter) - _tsizeof(szDefExt) - 1)) {
        _tcscpy( pszfil, szDefExt );
        pszfil += _tcslen(pszfil) + 1;
    }
    *pszfil = _T('\0');
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    LoadRcStringBuf( IDS_WAVEBROWSE_TITLE, title, _tsizeof(title) );
    of.lpstrTitle = title;
    of.Flags = OFN_NONETWORKBUTTON |
               OFN_HIDEREADONLY    |
               OFN_ENABLEHOOK      |
               OFN_ENABLETEMPLATE  |
#if 1
               OFN_SHOWHELP        |
#endif               
               OFN_NOCHANGEDIR     |
               OFN_EXPLORER        |
               OFN_ENABLESIZING    |
               OFN_NODEREFERENCELINKS;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = szDefExt + 2;
    of.lCustData = 0;
    of.lpfnHook = WaveHookProc;
    of.lpTemplateName = MAKEINTRESOURCE(WAVEFILEOPENDIALOG2);
    if (GetOpenFileName( &of )) {
        lstrcpyn( szWaveName, fname, len );
        _tsplitpath( fname, szDrive, szDir, NULL, NULL );
        _tcscpy( szLastWaveFile, szDrive );
        _tcscat( szLastWaveFile, szDir );
        return TRUE;
    }
    return FALSE;
}

UINT_PTR
DumpHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure for wave file selection common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and provide a test button for listening to a wave file.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    NMHDR *pnmhdr;

    switch (message) {
    case WM_NOTIFY:
        pnmhdr = (NMHDR *) lParam;
        if (pnmhdr->code == CDN_HELP) {
            LPOFNOTIFY pofn = (LPOFNOTIFY) lParam;

            PostMessage(pofn->lpOFN->hwndOwner, IDH_CRASH_DUMP, 0 , 0);
            
            return TRUE;
            
            GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
            
            HtmlHelp(pofn->lpOFN->hwndOwner,
                    szHelpFileName,
                    HH_DISPLAY_TOPIC,
                    (DWORD_PTR) (IDHH_CRASH_DUMP)
                    );
            return TRUE;
        }
    case WM_CLOSE:
        HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
        break;
    }

    return FALSE;
}

BOOL
GetDumpFileName(
    HWND hwnd,
    _TCHAR *szDumpName,
    DWORD len
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    wave file to be played when an application error occurs.

Arguments:

    szWaveName - name of the selected wave file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szWaveName is changed to have the selected wave file name.

--*/

{
    OPENFILENAME   of;
    _TCHAR           ftitle[MAX_PATH];
    _TCHAR           title[MAX_PATH];
    _TCHAR           fname[MAX_PATH];
    _TCHAR           filter[1024];
    _TCHAR           szDrive    [_MAX_DRIVE];
    _TCHAR           szDir      [_MAX_DIR];
    _TCHAR           szDefExt[]=_T("*.dmp");

    LPTSTR           pszfil;

    ZeroMemory(&of, sizeof(OPENFILENAME));
    ftitle[0] = 0;
    lstrcpyn( fname, (*szDumpName ? szDumpName : szDefExt), _tsizeof(fname) );
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = GetModuleHandle( NULL );
    LoadRcStringBuf( IDS_DUMP_FILTER, filter, _tsizeof(filter) - 1 );
    pszfil=&filter[_tcslen(filter)+1];
    if (pszfil < filter + (_tsizeof(filter) - _tsizeof(szDefExt) - 1)) {
        _tcscpy( pszfil, szDefExt );
        pszfil += _tcslen(pszfil) + 1;
    }
    *pszfil = _T('\0');
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    LoadRcStringBuf( IDS_DUMPBROWSE_TITLE, title, _tsizeof(title) );
    of.lpstrTitle = title;
    of.Flags = //OFN_NONETWORKBUTTON |
               OFN_HIDEREADONLY    |
               OFN_ENABLEHOOK      |
#if 1
               OFN_SHOWHELP        |
#endif               
               OFN_NOCHANGEDIR     |
               OFN_EXPLORER        |
               OFN_ENABLESIZING;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = szDefExt + 2;
    of.lCustData = 0;
    of.lpfnHook = DumpHookProc;
    of.lpTemplateName = MAKEINTRESOURCE(DUMPFILEOPENDIALOG);
    if (GetOpenFileName( &of )) {
        lstrcpyn( szDumpName, fname, len );
        _tsplitpath( fname, szDrive, szDir, NULL, NULL );
        _tcscpy( szLastDumpFile, szDrive );
        _tcscat( szLastDumpFile, szDir );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\pdbstr\pdbstr.h ===
/*
 * pdbstr.h
 */
 
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <strsafe.h>

#define PDB_LIBRARY
#include "pdb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\controls.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    controls.cpp

Abstract:
    This file implements the sun-classing and message processing of
    the controls on the main ui dialog.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


typedef struct _tagDWCONTROLINFO {
    struct _tagDWCONTROLINFO   *next;
    HWND                       hwnd;
    WNDPROC                    wndProc;
} DWCONTROLINFO, *PDWCONTROLINFO;


PDWCONTROLINFO   ciHead    = NULL;
PDWCONTROLINFO   ciTail    = NULL;
PDWCONTROLINFO   ciFocus   = NULL;
PDWCONTROLINFO   ciDefault = NULL;



void
SetFocusToCurrentControl(
    void
    )

/*++

Routine Description:

    Sets the focus  to the current control.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (ciFocus != NULL) {
        SetFocus( ciFocus->hwnd );
        SendMessage( ciFocus->hwnd, BM_SETSTATE, 0, 0 );
    }
}

LRESULT
ControlWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Processes focus messages and ensures that when the focus changes
    from one button to another that the old button looses the focus
    and the "default" state.

Arguments:

    Standard WNDPROC entry.

Return Value:

    LRESULT - Depending on input message and processing options.

--*/

{
    PDWCONTROLINFO ci = ciHead;

    while (ci->hwnd != hwnd) {
        ci = ci->next;
        if (ci == NULL) {
            return FALSE;
        }
    }

    switch(message) {
        case WM_SETFOCUS:
            ciFocus = ci;
            break;

        case BM_SETSTYLE:
            if (wParam == BS_DEFPUSHBUTTON) {
                ciDefault = ci;
            }
            break;

        case BM_SETSTATE:
            if ((GetWindowLong( hwnd, GWL_STYLE ) & 0xff) < BS_CHECKBOX) {
                //
                // change the button that had the focus
                //
                SendMessage( ciDefault->hwnd,
                             BM_SETSTYLE,
                             ( WPARAM ) BS_PUSHBUTTON,
                             ( LPARAM ) TRUE
                           );
                UpdateWindow( ciDefault->hwnd );

                //
                // change the button that is getting the focus
                //
                SendMessage( hwnd,
                             BM_SETSTYLE,
                             ( WPARAM ) BS_DEFPUSHBUTTON,
                             ( LPARAM ) TRUE
                           );
                SetFocus( hwnd );
                UpdateWindow( hwnd );
            }
            break;
    }

    return CallWindowProc( ci->wndProc, hwnd, message, wParam, lParam );
}


BOOL
CALLBACK
EnumChildProc(
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

    Subclass a controls in DrWatson's main window.

Arguments:

    hwnd    - Supplies the window handle for the main window.

    lParam  - non used

Return Value:

    BOOL    - Returns TRUE if each of the buttons in the ButtonHelpTable is
              subclassed.

--*/

{
    PDWCONTROLINFO ci;

    //
    // add the control to the linked list
    //
    ci = (PDWCONTROLINFO) calloc( sizeof(DWCONTROLINFO), sizeof(BYTE) );
    if (ci == NULL) {
        return FALSE;
    }

    if (ciHead == NULL) {
        ciHead = ciTail = ci;
    }
    else {
        ciTail->next = ci;
        ciTail = ci;
    }

    //
    // save the HWND
    //
    ci->hwnd = hwnd;

    //
    // change the WNDPROC and save the address of the old one
    //
    ci->wndProc = (WNDPROC) SetWindowLongPtr( hwnd,
                                           GWLP_WNDPROC,
                                           (LONG_PTR)ControlWndProc
                                         );

    if (GetWindowLong( hwnd, GWL_STYLE ) & BS_DEFPUSHBUTTON) {
        ciDefault = ci;
    }

    return TRUE;
}

BOOL
SubclassControls(
    HWND hwnd
    )

/*++

Routine Description:

    Subclass the controls in DrWatson's main window.

Arguments:

    hWnd    - Supplies the window handle for the main window.

Return Value:

    BOOL    - Returns TRUE if each of the buttons in the ButtonHelpTable is
              subclassed.

--*/

{
    EnumChildWindows( hwnd, EnumChildProc, 0 );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dbhutils\storm\storm.cpp ===
// test : test program for multithreaded stack walk
//

#include <stdio.h>
#include <windows.h>
#include <dbghelp.h>

#ifndef _WIN64

CRITICAL_SECTION g_cs;

BOOL CALLBACK cbEnumSym(
	PSYMBOL_INFO si,
	ULONG size,
	PVOID context
)
{
//  printf("%s ", si->Name);
    return TRUE;
}

BOOL CALLBACK cbEnumMods(
    PSTR name,
    DWORD64 base,
    PVOID context
)
{
    HANDLE hp = (HANDLE)context;

    SymEnumSymbols(hp, base, "*", cbEnumSym, NULL);
    return TRUE;
}


BOOL
cbSymbol(
    HANDLE  hProcess,
    ULONG   ActionCode,
    ULONG64 CallbackData,
    ULONG64 UserContext
    )
{
    PIMAGEHLP_DEFERRED_SYMBOL_LOAD64 idsl;
    PIMAGEHLP_CBA_READ_MEMORY        prm;
    IMAGEHLP_MODULE64                mi;
    PUCHAR                           p;
    ULONG                            i;

    idsl = (PIMAGEHLP_DEFERRED_SYMBOL_LOAD64) CallbackData;

    switch ( ActionCode ) {
        case CBA_DEBUG_INFO:
            printf("%s", (LPSTR)CallbackData);
            break;

#if 0
    case CBA_DEFERRED_SYMBOL_LOAD_CANCEL:
        if (fControlC)
        {
            fControlC = 0;
            return TRUE;
        }
        break;
#endif

        case CBA_DEFERRED_SYMBOL_LOAD_START:
            printf("loading symbols for %s\n", idsl->FileName);
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_FAILURE:
            if (idsl->FileName && *idsl->FileName)
                printf( "*** Error: could not load symbols for %s\n", idsl->FileName );
            else
                printf( "*** Error: could not load symbols [MODNAME UNKNOWN]\n");
            break;

        case CBA_DEFERRED_SYMBOL_LOAD_COMPLETE:
            printf("loaded symbols for %s\n", idsl->FileName);
		    SymEnumSymbols(hProcess, idsl->BaseOfImage, "*", cbEnumSym, NULL);
            break;

        case CBA_SYMBOLS_UNLOADED:
            printf("unloaded symbols for %s\n", idsl->FileName);
            break;
#if 1
        case CBA_READ_MEMORY:
            prm = (PIMAGEHLP_CBA_READ_MEMORY)CallbackData;
            return ReadProcessMemory(GetCurrentProcess(),
                                     (LPCVOID)prm->addr,
                                     prm->buf,
                                     prm->bytes,
                                     prm->bytesread);
#endif

        default:
            return FALSE;
    }

    return FALSE;
}


BOOL CALLBACK
MyReadProcessMemory(
	  HANDLE	hProcess,				// handle to the process
	  DWORD		lpBaseAddress,			// base of memory area
	  LPVOID	lpBuffer,				// data buffer
	  DWORD		nSize,					// number of bytes to read
	  LPDWORD	lpNumberOfBytesRead)	// number of bytes read
{
	DWORD		i		= 0;
	BOOL		fRet	= FALSE;

	if (nSize == 0)
	{
		fRet = TRUE;
		goto Exit;
	}

	//
	// Try to read as much as possible
	//
	__try
	{
		for (i = 0; i < nSize; i++)
		{
			((PBYTE)lpBuffer)[i] = *((PBYTE)lpBaseAddress + i);
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		//
		// We have a partial read in this case
		//
	}

	if (lpNumberOfBytesRead)
	{
		*lpNumberOfBytesRead = i;
	}

	fRet = (i > 0);

Exit:
	return fRet;
}

VOID
GetStack()
{
	BOOL			fRet			= FALSE;
	HANDLE			hProcess		= GetCurrentProcess();
	HANDLE			hThread			= GetCurrentThread();
	DWORD			dwStackDepth		= 0;
	DWORD			i			= 0;
	DWORD			dwStackAddr[16];
	CONTEXT			Context;
	STACKFRAME		StackFrame;

	//
	// First initialize data used by the
	// stack walker
	//
	ZeroMemory(&Context, sizeof(CONTEXT));
	Context.ContextFlags = CONTEXT_FULL;
	ZeroMemory(&StackFrame, sizeof(STACKFRAME));

	fRet = GetThreadContext(hThread, &Context);
	if (!fRet)
	{
		printf("Could not get the thread context -0x%x\n", GetLastError());
		goto Exit;
	}

	//
	// Fill in our stack frame
	//
	StackFrame.AddrStack.Mode = AddrModeFlat;
	StackFrame.AddrFrame.Mode = AddrModeFlat;
	StackFrame.AddrPC.Mode = AddrModeFlat;

	__asm
	{
		mov StackFrame.AddrStack.Offset, esp;
		mov StackFrame.AddrFrame.Offset, ebp;
		mov StackFrame.AddrPC.Offset, offset DummyLabel;
DummyLabel:
	}

	//
	// Start walking the stack.
	//
	while (dwStackDepth < 16)
	{
		fRet = StackWalk(
				IMAGE_FILE_MACHINE_I386,	// MachineType
				hProcess,					// Current process
				hThread,					// Current thread
				&StackFrame,				// StackFrame
				&Context,					// ContextRecord - can be NULL for x86
				&MyReadProcessMemory, 		// use our own read process memory
				&SymFunctionTableAccess,	// FunctionTableAccessRoutine
				&SymGetModuleBase,			// GetModuleBaseRoutine
				NULL);						// TranslateAddressProc
		if (!fRet)
		{
			break;
		}

		dwStackAddr[dwStackDepth] = StackFrame.AddrPC.Offset;
		dwStackDepth++;
	}

	EnterCriticalSection(&g_cs);
	printf("\nThread: 0x%x\n", GetCurrentThreadId());
	for (i = 0; i < dwStackDepth; i++)
	{
		printf("\t-0x%x\n", dwStackAddr[i]);
	}
	LeaveCriticalSection(&g_cs);
	SymEnumerateModules64(hProcess, cbEnumMods, hProcess);
Exit:
	fflush(stdout);
	return;
}

VOID
Dummy2()
{

	ULONG ul = (GetCurrentThreadId() % 2);
	if (ul == 0)
	{
		GetStack();
	}
	else
		return;
}

VOID
Dummy1()
{
	ULONG ul = (GetCurrentThreadId() % 5);

	if (ul == 0 || ul == 4)
	{
		Dummy2();
	}
	else
	{
		GetStack();
	}
	GetStack();
}

DWORD WINAPI
DwThreadFn(
		LPVOID pvParam)
{
	ULONG ul = (GetCurrentThreadId() % 7);
	if (ul == 3 || ul == 1 || ul == 5 || ul == 6)
	{
		GetStack();
		Dummy1();
	}
	else
	{
		Dummy2();
	}
	GetStack();
	return 0;
}

#define THREAD_COUNT MAXIMUM_WAIT_OBJECTS

int __cdecl main(int argc, char* argv[])
{
	int		i		= 0;
	HANDLE	rghThread[THREAD_COUNT]	= {0};

	InitializeCriticalSection(&g_cs);

#if 0
	if (argc < 2 || argv[1] == NULL)
	{
		printf("usage: s.exe <sympath>\n");
		goto Exit;
	}
#endif

	printf("Starting test!\n");

	//
	// Initialize the symbols handler
	//
	SymSetOptions(SymGetOptions() | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES |
		SYMOPT_DEFERRED_LOADS | SYMOPT_DEBUG);

	if (!SymInitialize(
		GetCurrentProcess(),	// hProcess
		NULL,			// UserSearchPath
		TRUE))
	{
		printf("Cannot initialize the symbols - 0x%x!\n", GetLastError());
		goto Exit;
	}
    SymRegisterCallback64(GetCurrentProcess(), cbSymbol, 0);

	printf("Creating %u threads!\n", THREAD_COUNT);

	for (i = 0; i < THREAD_COUNT; i++)
	{
		rghThread[i] = CreateThread(
			NULL,
			0,
			&DwThreadFn,
			NULL,
			CREATE_SUSPENDED,
			NULL);
		if (!rghThread[i])
		{
			printf("Cannot create thread - 0x%x", GetLastError());
		}
		else printf("Created thread %x\n", rghThread[i]);
	}

	//
	// Now resume all threads
	//
	for (i = 0; i < THREAD_COUNT; i++)
	{
		ResumeThread(rghThread[i]);
	}

	//
	// Wait for the threads to finish
	//
	WaitForMultipleObjects(THREAD_COUNT, rghThread, TRUE, INFINITE);

	for (i = 0; i < THREAD_COUNT; i++)
	{
		CloseHandle(rghThread[i]);
	}

	printf("Test finished!\n");

Exit:
	DeleteCriticalSection(&g_cs);
	return 0;
}

#else

int __cdecl main(int argc, char* argv[])
{
	printf("storm.exe is not implemented for 64 bit platforms.\n");
	return 0;
}

#endif // #ifndef _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\debug.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    This file implements the debug module for drwatson.  This module
    processes all debug events and generates the postmortem dump.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


#define STATUS_POSSIBLE_DEADLOCK        ((DWORD)0xC0000194L)
#define STATUS_VDM_EVENT                STATUS_SEGMENT_NOTIFICATION

typedef struct tagSYSINFO {
    _TCHAR   szUserName[MAX_PATH];
    _TCHAR   szMachineName[MAX_PATH];
} SYSINFO, *PSYSINFO;

//----------------------------------------------------------------------------
//
// Log output callbacks.
//
//----------------------------------------------------------------------------

class LogOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

LogOutputCallbacks g_LogOutCb;

STDMETHODIMP
LogOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
LogOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
LogOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
LogOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    PCSTR Scan;

    for (;;)
    {
        Scan = strchr(Text, '\n');
        if (Scan == NULL)
        {
            break;
        }

        lprintfs(_T("%.*hs\r\n"), (int)(Scan - Text), Text);
        Text = Scan + 1;
    }
    
    lprintfs(_T("%hs"), Text);
    return S_OK;
}


_TCHAR *
GetExceptionText(
    DWORD dwExceptionCode
    )
{
    static _TCHAR buf[80];
    DWORD dwFormatId = 0;

    memset( buf, 0, sizeof(buf) );

    switch (dwExceptionCode) {
        case STATUS_SINGLE_STEP:
            dwFormatId = MSG_SINGLE_STEP_EXCEPTION;
            break;

        case DBG_CONTROL_C:
            dwFormatId = MSG_CONTROLC_EXCEPTION;
            break;

        case DBG_CONTROL_BREAK:
            dwFormatId = MSG_CONTROL_BRK_EXCEPTION;
            break;

        case STATUS_ACCESS_VIOLATION:
            dwFormatId = MSG_ACCESS_VIOLATION_EXCEPTION;
            break;

        case STATUS_STACK_OVERFLOW:
            dwFormatId = MSG_STACK_OVERFLOW_EXCEPTION;
            break;

        case STATUS_INTEGER_DIVIDE_BY_ZERO:
            dwFormatId = MSG_INTEGER_DIVIDE_BY_ZERO_EXCEPTION;
            break;

        case STATUS_PRIVILEGED_INSTRUCTION:
            dwFormatId = MSG_PRIVILEGED_INSTRUCTION_EXCEPTION;
            break;

        case STATUS_ILLEGAL_INSTRUCTION:
            dwFormatId = MSG_ILLEGAL_INSTRUCTION_EXCEPTION;
            break;

        case STATUS_IN_PAGE_ERROR:
            dwFormatId = MSG_IN_PAGE_IO_EXCEPTION;
            break;

        case STATUS_DATATYPE_MISALIGNMENT:
            dwFormatId = MSG_DATATYPE_EXCEPTION;
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            dwFormatId = MSG_DEADLOCK_EXCEPTION;
            break;

        case STATUS_VDM_EVENT:
            dwFormatId = MSG_VDM_EXCEPTION;
            break;

        case STATUS_BREAKPOINT:
            dwFormatId = MSG_BREAKPOINT_EXCEPTION;
            break;

        default:
            lprintfs( _T("\r\n") );
            break;
    }

    FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   NULL,
                   dwFormatId,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   buf,
                   sizeof(buf) / sizeof(_TCHAR),
                   NULL
                 );

    return buf;
}

void
CreateEngineInterfaces(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;

    if ((Status = DebugCreate(__uuidof(IDebugClient2),
                              (void **)&dp->DbgClient)) != S_OK) {
        goto Error;
    }

    if ((Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugControl),
                        (void **)&dp->DbgControl)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugDataSpaces),
                        (void **)&dp->DbgData)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugRegisters),
                        (void **)&dp->DbgRegisters)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugSymbols),
                        (void **)&dp->DbgSymbols)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugSystemObjects),
                        (void **)&dp->DbgSystem)) != S_OK) {
        goto Error;
    }

    if ((Status = dp->DbgSymbols->
         AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS)) != S_OK ||
        (Status = dp->DbgControl->
         AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK)) != S_OK ||
        (Status = dp->DbgControl->
         Execute(DEBUG_OUTCTL_IGNORE, "sxe et",
                 DEBUG_EXECUTE_DEFAULT)) != S_OK) {
        goto Error;
    }
    
    return;

 Error:
    if (dp->options.fVisual) {
        FatalError( Status, LoadRcString(IDS_CANT_INIT_ENGINE) );
    }
    else {
        ExitProcess( 1 );
    }
}

void
AttachToActiveProcess (
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    
    if ((Status = dp->DbgClient->
         AttachProcess(0, dp->dwPidToDebug, DEBUG_ATTACH_DEFAULT)) != S_OK) {
        if (dp->options.fVisual) {
            FatalError( Status, LoadRcString(IDS_ATTACHFAIL) );
        }
        else {
            ExitProcess( 1 );
        }
    }

    return;
}

DWORD
SysInfoThread(
    PSYSINFO si
    )
{
    DWORD len;

    len = sizeof(si->szMachineName) / sizeof(_TCHAR);
    GetComputerName( si->szMachineName, &len );
    len = sizeof(si->szUserName) / sizeof(_TCHAR);
    GetUserName( si->szUserName, &len );

    return 0;
}

void
LogSystemInformation(
    PDEBUGPACKET dp
    )
{
    _TCHAR         buf[1024];
    SYSTEM_INFO   si;
    DWORD         ver;
    SYSINFO       mySi;
    SYSINFO*      threadSi;
    DWORD         dwThreadId;
    HANDLE        hThread;
    DWORD         TSid;

    lprintf( MSG_SYSINFO_HEADER );

    // Initialize default unknown values.
    LoadRcStringBuf( IDS_UNKNOWN_MACHINE,
                     mySi.szMachineName, _tsizeof(mySi.szMachineName) );
    LoadRcStringBuf( IDS_UNKNOWN_USER,
                     mySi.szUserName, _tsizeof(mySi.szUserName) );

    // Attempt to get the actual values.
    // The storage passed to the get thread is not taken
    // from this thread's stack so that this function can exit
    // without leaving the other thread with stale stack pointers.
    threadSi = (SYSINFO*)malloc(sizeof(*threadSi));
    if (threadSi != NULL) {
        hThread = CreateThread( NULL,
                                16000,
                                (LPTHREAD_START_ROUTINE)SysInfoThread,
                                threadSi,
                                0,
                                &dwThreadId
                                );
        if (hThread != NULL) {
            // Let the thread run for a little while since
            // the get calls can be slow.  If the thread doesn't
            // finish in the time allotted we'll just go ahead
            // with the default values and forget about the get thread.
            Sleep( 0 );
            if (WaitForSingleObject( hThread, 30000 ) == WAIT_OBJECT_0) {
                // Thread finished so we have the real values.
                _tcscpy(mySi.szMachineName, threadSi->szMachineName);
                _tcscpy(mySi.szUserName, threadSi->szUserName);
                free(threadSi);
            }
            CloseHandle( hThread );
        } else {
            free(threadSi);
        }
    }

    lprintf( MSG_SYSINFO_COMPUTER, mySi.szMachineName );
    lprintf( MSG_SYSINFO_USER, mySi.szUserName );
    ProcessIdToSessionId(dp->dwPidToDebug, &TSid);
    _stprintf( buf, _T("%d"), TSid );
    lprintf( MSG_SYSINFO_TERMINAL_SESSION, buf );
    GetSystemInfo( &si );
    _stprintf( buf, _T("%d"), si.dwNumberOfProcessors );
    lprintf( MSG_SYSINFO_NUM_PROC, buf );
    RegLogProcessorType();
    ver = GetVersion();
    _stprintf( buf, _T("%d.%d"), LOBYTE(LOWORD(ver)), HIBYTE(LOWORD(ver)) );
    lprintf( MSG_SYSINFO_WINVER, buf );
    RegLogCurrentVersion();
    lprintfs( _T("\r\n") );
}

void
LogTaskList(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This function gets the current task list and logs the process id &
    process name to the log file.

--*/

{
    HRESULT Status;
#define MAX_IDS 8192
    PULONG Ids = NULL;
    ULONG IdCount;
    ULONG i;

    Ids = (PULONG)malloc(sizeof(*Ids) * MAX_IDS);
    if (Ids == NULL) {
        goto Error;
    }
    
    if ((Status = dp->DbgClient->
         GetRunningProcessSystemIds(0, Ids, MAX_IDS,
                                    &IdCount)) != S_OK) {
        goto Error;
    }

    if (IdCount > MAX_IDS) {
        // Incomplete process list is good enough.
        IdCount = MAX_IDS;
    }

    lprintf( MSG_TASK_LIST );

    for (i = 0; i < IdCount; i++) {
        char ExeName[MAX_PATH];

        if ((Status = dp->DbgClient->
             GetRunningProcessDescription(0, Ids[i],
                                          DEBUG_PROC_DESC_NO_PATHS,
                                          ExeName, sizeof(ExeName),
                                          NULL, NULL, 0, NULL)) != S_OK) {
            lprintfs(_T("%4d Error 0x%08X\r\n"), Ids[i], Status);
        } else {
            lprintfs(_T("%4d %hs\r\n"), Ids[i], ExeName);
        }
    }

    lprintfs( _T("\r\n") );

    free(Ids);
    return;

 Error:
    _tprintf( _T("ERROR: could not get the task list\n") );
    free(Ids);
}

void
LogModuleList(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    ULONG NumMod;
    ULONG i;
    char Image[MAX_PATH];
    DEBUG_MODULE_PARAMETERS Params;
    
    lprintf( MSG_MODULE_LIST );

    if ((Status = dp->DbgSymbols->GetNumberModules(&NumMod, &i)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }

    for (i = 0; i < NumMod; i++) {
        if ((Status = dp->DbgSymbols->
             GetModuleParameters(1, NULL, i, &Params)) != S_OK ||
            FAILED(Status = dp->DbgSymbols->
                   GetModuleNames(i, 0, Image, sizeof(Image), NULL,
                                  NULL, 0, NULL, NULL, 0, NULL))) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        } else {
            lprintfs(_T("%016I64x - %016I64x: %hs\r\n"),
                     Params.Base, Params.Base + Params.Size,
                     Image);
        }
    }

    lprintfs( _T("\r\n") );
}

void
LogStackDump(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    DWORD   i;
    DWORD   j;
    BYTE    stack[1024] = {0};
    ULONG64 StackOffset;

    if ((Status = dp->DbgRegisters->GetStackOffset(&StackOffset)) != S_OK ||
        (Status = dp->DbgData->ReadVirtual(StackOffset,
                                           stack,
                                           sizeof(stack),
                                           &i)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }

    lprintf( MSG_STACK_DUMP_HEADER );

    for( i = 0; i < 20; i++ ) {
        j = i * 16;
        lprintfs( _T("%016I64x  %02x %02x %02x %02x %02x %02x %02x %02x - ")
                  _T("%02x %02x %02x %02x %02x %02x %02x %02x  ")
                  _T("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\r\n"),
                  j + StackOffset,
                  stack[ j +  0 ],
                  stack[ j +  1 ],
                  stack[ j +  2 ],
                  stack[ j +  3 ],
                  stack[ j +  4 ],
                  stack[ j +  5 ],
                  stack[ j +  6 ],
                  stack[ j +  7 ],
                  stack[ j +  8 ],
                  stack[ j +  9 ],
                  stack[ j + 10 ],
                  stack[ j + 11 ],
                  stack[ j + 12 ],
                  stack[ j + 13 ],
                  stack[ j + 14 ],
                  stack[ j + 15 ],
                  isprint( stack[ j +  0 ]) ? stack[ j +  0 ] : _T('.'),
                  isprint( stack[ j +  1 ]) ? stack[ j +  1 ] : _T('.'),
                  isprint( stack[ j +  2 ]) ? stack[ j +  2 ] : _T('.'),
                  isprint( stack[ j +  3 ]) ? stack[ j +  3 ] : _T('.'),
                  isprint( stack[ j +  4 ]) ? stack[ j +  4 ] : _T('.'),
                  isprint( stack[ j +  5 ]) ? stack[ j +  5 ] : _T('.'),
                  isprint( stack[ j +  6 ]) ? stack[ j +  6 ] : _T('.'),
                  isprint( stack[ j +  7 ]) ? stack[ j +  7 ] : _T('.'),
                  isprint( stack[ j +  8 ]) ? stack[ j +  8 ] : _T('.'),
                  isprint( stack[ j +  9 ]) ? stack[ j +  9 ] : _T('.'),
                  isprint( stack[ j + 10 ]) ? stack[ j + 10 ] : _T('.'),
                  isprint( stack[ j + 11 ]) ? stack[ j + 11 ] : _T('.'),
                  isprint( stack[ j + 12 ]) ? stack[ j + 12 ] : _T('.'),
                  isprint( stack[ j + 13 ]) ? stack[ j + 13 ] : _T('.'),
                  isprint( stack[ j + 14 ]) ? stack[ j + 14 ] : _T('.'),
                  isprint( stack[ j + 15 ]) ? stack[ j + 15 ] : _T('.')
                );
    }

    lprintfs( _T("\r\n") );
}

void
LogCurrentThreadInformation(
    PDEBUGPACKET dp,
    PCRASHES crash
    )
{
    HRESULT Status;
    ULONG ThreadId;
    _TCHAR IdBuf[16];
    ULONG64 InstrOffs;
    DWORD InstrWindow;
    // The size should match the size of pCrash->szFunction
    char FuncNameA[256];
    WCHAR FuncNameW[256];
    ULONG64 Displ;

    if ((Status = dp->DbgSystem->
         GetCurrentThreadSystemId(&ThreadId)) != S_OK) {
        ThreadId = 0xffffffff;
    }
    
    _stprintf( IdBuf, _T("%x"), ThreadId );
    lprintf( MSG_STATE_DUMP, IdBuf );

    dp->DbgClient->SetOutputCallbacks(&g_LogOutCb);
    
    if ((Status = dp->DbgRegisters->
         OutputRegisters(DEBUG_OUTCTL_THIS_CLIENT,
                         DEBUG_REGISTERS_DEFAULT)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    }
    lprintfs( _T("\r\n") );

    InstrWindow = dp->options.dwInstructions;
    if (InstrWindow > 500) {
        InstrWindow = 500;
    }

    strcpy(FuncNameA, "<nosymbols>");
    wcscpy(FuncNameW, L"<nosymbols>");

    if ((Status = dp->DbgRegisters->
         GetInstructionOffset(&InstrOffs)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    } else {
        if (FAILED(Status = dp->DbgSymbols->
                   GetNameByOffset(InstrOffs, FuncNameA, sizeof(FuncNameA),
                                   NULL, &Displ))) {
            strcpy(FuncNameA, "<nosymbols>");
        }

#ifdef UNICODE
        if (MultiByteToWideChar(CP_ACP, 0, FuncNameA, -1,
                                FuncNameW,
                                sizeof(FuncNameW) / sizeof(WCHAR)) == 0) {
            wcscpy(FuncNameW, L"<nosymbols");
        }
        lprintf( MSG_FUNCTION, FuncNameW );
#else
        lprintf( MSG_FUNCTION, FuncNameA );
#endif
        
        dp->DbgClient->SetOutputLinePrefix("        ");
        if ((Status = dp->DbgControl->
             OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT, InstrWindow,
                                    InstrWindow, InstrOffs,
                                    DEBUG_DISASM_MATCHING_SYMBOLS,
                                    NULL, NULL, NULL, NULL)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }

        // If this is the event thread output a message
        // indicating the faulting instruction.
        if (crash) {
            dp->DbgClient->SetOutputLinePrefix(NULL);
            lprintf( MSG_FAULT );
        }
        if ((Status = dp->DbgControl->
             OutputDisassembly(DEBUG_OUTCTL_THIS_CLIENT, InstrOffs,
                               DEBUG_DISASM_EFFECTIVE_ADDRESS |
                               DEBUG_DISASM_MATCHING_SYMBOLS,
                               &InstrOffs)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }
        
        dp->DbgClient->SetOutputLinePrefix("        ");
        if ((Status = dp->DbgControl->
             OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT, 0,
                                    InstrWindow, InstrOffs,
                                    DEBUG_DISASM_EFFECTIVE_ADDRESS |
                                    DEBUG_DISASM_MATCHING_SYMBOLS,
                                    NULL, NULL, NULL, NULL)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }
        
        dp->DbgClient->SetOutputLinePrefix(NULL);
    }
    lprintfs( _T("\r\n") );
                                   
    if (crash) {
#ifdef UNICODE
        wcscpy(crash->szFunction, FuncNameW);
#else
        strcpy(crash->szFunction, FuncNameA);
#endif
    }

    lprintf( MSG_STACKTRACE );
    if ((Status = dp->DbgControl->
         OutputStackTrace(DEBUG_OUTCTL_THIS_CLIENT, NULL, 100,
                          DEBUG_STACK_ARGUMENTS |
                          DEBUG_STACK_FUNCTION_INFO |
                          DEBUG_STACK_FRAME_ADDRESSES |
                          DEBUG_STACK_COLUMN_NAMES)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    }
    lprintfs( _T("\r\n") );
    
    dp->DbgClient->SetOutputCallbacks(NULL);
    
    LogStackDump( dp );
}

void
LogAllThreadInformation(
    PDEBUGPACKET dp,
    PCRASHES crash
    )
{
    HRESULT Status;
    ULONG NumThreads;
    ULONG i;
    ULONG ThreadId;
    ULONG EventTid;

    if (!dp->options.fDumpAllThreads) {
        // Just log the current event thread's information.
        LogCurrentThreadInformation(dp, crash);
        return;
    }
    
    if ((Status = dp->DbgSystem->GetNumberThreads(&NumThreads)) != S_OK ||
        (Status = dp->DbgSystem->GetEventThread(&EventTid)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }
    
    for (i = 0; i < NumThreads; i++) {
        if ((Status = dp->DbgSystem->
             GetThreadIdsByIndex(i, 1, &ThreadId, NULL)) != S_OK ||
            (Status = dp->DbgSystem->SetCurrentThreadId(ThreadId)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
            continue;
        }

        LogCurrentThreadInformation(dp, ThreadId == EventTid ? crash : NULL);
    }

    dp->DbgSystem->SetCurrentThreadId(EventTid);
}

void
LogSymbols(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    char ModName[64];
    char Buf[MAX_PATH];
    ULONG64 InstrOffs;
    ULONG64 ModBase;
    
    lprintf( MSG_SYMBOL_TABLE );
    
    if ((Status = dp->DbgRegisters->
         GetInstructionOffset(&InstrOffs)) != S_OK ||
        (Status = dp->DbgSymbols->
         GetModuleByOffset(InstrOffs, 0, NULL, &ModBase)) != S_OK ||
        FAILED(Status = dp->DbgSymbols->
               GetModuleNames(DEBUG_ANY_ID, ModBase,
                              Buf, sizeof(Buf), NULL,
                              ModName, sizeof(ModName), NULL,
                              NULL, 0, NULL))) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }
    
    lprintfs(_T("%hs\r\n\r\n"), Buf);
    sprintf(Buf, "x %s!*", ModName);
    dp->DbgClient->SetOutputCallbacks(&g_LogOutCb);
    dp->DbgControl->Execute(DEBUG_OUTCTL_THIS_CLIENT, Buf,
                          DEBUG_EXECUTE_DEFAULT);
    dp->DbgClient->SetOutputCallbacks(NULL);
}

void
PostMortemDump(
    PDEBUGPACKET dp,
    PDEBUG_LAST_EVENT_INFO_EXCEPTION Exception
    )
{
    _TCHAR            dbuf[MAX_PATH];
    _TCHAR            szDate[20];
    _TCHAR            szTime[20];
    CRASHES           crash = {0};
    char              ExeName[MAX_PATH];

    GetLocalTime( &crash.time );
    crash.dwExceptionCode = Exception->ExceptionRecord.ExceptionCode;
    crash.dwAddress = (DWORD_PTR)Exception->ExceptionRecord.ExceptionAddress;
        
    if (FAILED(dp->DbgSystem->
               GetCurrentProcessExecutableName(ExeName, sizeof(ExeName),
                                               NULL))) {
        strcpy(ExeName, "<unknown>");
    }
#ifdef UNICODE
    if (MultiByteToWideChar(CP_ACP, 0, ExeName, -1,
                            crash.szAppName,
                            sizeof(crash.szAppName) / sizeof(TCHAR)) == 0) {
        _tcscpy(crash.szAppName, _T("<unknown>"));
    }
#endif

    lprintf( MSG_APP_EXCEPTION );
    _stprintf( dbuf, _T("%d"), dp->dwPidToDebug );
    lprintf( MSG_APP_EXEP_NAME, crash.szAppName, dbuf );

    GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, &crash.time,
        NULL, szDate, sizeof(szDate) / sizeof(_TCHAR));

    _sntprintf( szTime, _tsizeof(szTime),
                _T("%02d:%02d:%02d.%03d"),
                crash.time.wHour,
                crash.time.wMinute,
                crash.time.wSecond,
                crash.time.wMilliseconds );
    szTime[_tsizeof(szTime) - 1] = 0;
    lprintf( MSG_APP_EXEP_WHEN, szDate, szTime );
    _stprintf( dbuf, _T("%08lx"), Exception->ExceptionRecord.ExceptionCode );
    lprintf( MSG_EXCEPTION_NUMBER, dbuf );

    lprintfs( _T("(%s)\r\n\r\n"),
              GetExceptionText(Exception->ExceptionRecord.ExceptionCode) );

    LogSystemInformation( dp );

    LogTaskList( dp );

    LogModuleList( dp );

    LogAllThreadInformation(dp, &crash);

    if (dp->options.fDumpSymbols) {
        LogSymbols( dp );
    }

    ElSaveCrash( &crash, dp->options.dwMaxCrashes );

    dp->ExitStatus = Exception->ExceptionRecord.ExceptionCode;
    return;
}

// Valid range: [1-7]
#define NUM_DIGITS_FNAME 2

void
CalcNextFileName(
    IN PTSTR            pszUserName,
    OUT PSTR            pszFileName,
    IN OUT PINT         pnCurrentValue,
    IN BOOL             bUseLongFileNames
    )
{
    TCHAR   szDrive[_MAX_DRIVE];
    TCHAR   szPath[_MAX_PATH];
    TCHAR   szFName[_MAX_FNAME];
    TCHAR   szExt[_MAX_EXT];
    int     nLargestPossibleNum;
    int     nCnt;

    Assert(pszUserName);
    Assert(pnCurrentValue);

    Assert(1 <= NUM_DIGITS_FNAME);
    Assert(NUM_DIGITS_FNAME <= 7);

    // Given the number of digits, this is the largest number +1
    // we can have. If we could raise int to an int, this would
    // be easy.
    // nLargestPossibleNum = 10^NUM_DIGITS_FNAME
    // We are intentionally over by one, the actual range is
    // [0, 10^NUM_DIGITS_FNAME-1]
    nLargestPossibleNum = 1;
    for (nCnt = 0; nCnt<NUM_DIGITS_FNAME; nCnt++) {
        nLargestPossibleNum *= 10;
    }

    _tsplitpath(pszUserName, szDrive, szPath, szFName, szExt);

    if (!bUseLongFileNames) {
        // Shorten the file name len to 6, so that we can
        // add the 2 digit sequence.
        // MSDOS FName len == 8
        szFName[8 - NUM_DIGITS_FNAME] = 0;
    }

    sprintf(pszFileName,
#ifdef UNICODE
            "%ls%ls%ls%0*d%ls",
#else
            "%s%s%s%0*d%s",
#endif
            szDrive,
            szPath,
            szFName,
            NUM_DIGITS_FNAME,
            *pnCurrentValue++,
            szExt
            );

    // Make sure we stay in the range [0, 10^NUM_DIGITS_FNAME]
    *pnCurrentValue = ++(*pnCurrentValue) % nLargestPossibleNum;
}

BOOL
CreateDumpFile(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This function creates a crash dump file.

Arguments:

    dp              - debug packet for current process

Return Value:

    TRUE    - Crash dump was created
    FALSE   - Crash dump was NOT created

--*/

{
    PTSTR p;
    PCSTR Comment = "Dr. Watson generated MiniDump";
    ULONG Qual, Format = DEBUG_FORMAT_DEFAULT;
    HRESULT Status;
    char FileName[MAX_PATH];

    p = ExpandPath( dp->options.szCrashDump );
    if (!p) {
        return FALSE;
    }

    if (dp->options.fUseSequentialNaming) {
        // Figure out what the next file name should be.
        CalcNextFileName(p,
                         FileName,
                         &dp->options.nNextDumpSequence,
                         dp->options.fUseLongFileNames
                         );

        // Save the next value of nCurrent
        RegSave(&dp->options);
    } else {
#ifdef UNICODE
        if (WideCharToMultiByte(CP_ACP, 0, p, -1, FileName, _tsizeof(FileName),
                                NULL, NULL) == 0) {
            return FALSE;
        }
#else
        lstrcpyn(FileName, p, _tsizeof(FileName));
#endif
    }

    switch (dp->options.dwType) {
    case FullDump:
        Qual = DEBUG_USER_WINDOWS_DUMP;
        Comment = NULL;
	break;
    case FullMiniDump:
        Format = DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
            DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
        // Fall through.
    case MiniDump:
        Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;
	break;
    default:
        return FALSE;
    }

    Status = dp->DbgClient->WriteDumpFile2(FileName, Qual, Format, Comment);
    
    free( p );
    return Status == S_OK;
}

DWORD
DispatchDebugEventThread(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    _TCHAR        szLogFileName[1024];
    _TCHAR        buf[1024];
    PTSTR         p;


    if (dp->dwPidToDebug == 0) {
        goto exit;
    }

    CreateEngineInterfaces(dp);

    SetErrorMode( SEM_FAILCRITICALERRORS |
                  SEM_NOGPFAULTERRORBOX  |
                  SEM_NOOPENFILEERRORBOX   );

    AttachToActiveProcess( dp );

    p = ExpandPath(dp->options.szLogPath);

    if (p) {
        lstrcpyn( szLogFileName, p, _tsizeof(szLogFileName) );
        free( p );
    } else {
        _tcscpy( szLogFileName, dp->options.szLogPath );
    }

    MakeLogFileName( szLogFileName );
    OpenLogFile( szLogFileName,
                 dp->options.fAppendToLogFile,
                 dp->options.fVisual
               );

    for (;;) {

        ULONG Type, Process, Thread;
        DEBUG_LAST_EVENT_INFO_EXCEPTION LastEx;
        DWORD dwThreadId;
        HANDLE hThread;
        
        if (dp->DbgControl->
            WaitForEvent(DEBUG_WAIT_DEFAULT, 30000) != S_OK ||
            dp->DbgControl->
            GetLastEventInformation(&Type, &Process, &Thread,
                                    &LastEx, sizeof(LastEx), NULL,
                                    NULL, 0, NULL) != S_OK) {
            break;
        }

        switch (Type) {
        case DEBUG_EVENT_EXCEPTION:
            if (LastEx.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT) {
                //
                // If there is no event to signal, just use the first
                // breakpoint as the stop event.
                //
                if (dp->hEventToSignal && LastEx.FirstChance) {
                    //
                    // The aedebug event will be signalled AFTER this
                    // thread exits, so that it will disappear before
                    // the dump snapshot is taken.
                    //
                    dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO_HANDLED);
                    break;
                }
            }
            if (dp->options.fVisual) {
                //
                // this notification is necessary because the shell must know when
                // the debugee has been attached.  if it doesn't know and the user is
                // allowed to terminate drwatson then the system may intervene with
                // a popup.
                //
                SendMessage( dp->hwnd, WM_ATTACHCOMPLETE, 0, 0 );
                _sntprintf( buf, _tsizeof(buf),
                            LoadRcString( IDS_AE_TEXT ),
                            GetExceptionText(LastEx.ExceptionRecord.ExceptionCode),
                            LastEx.ExceptionRecord.ExceptionCode,
                            LastEx.ExceptionRecord.ExceptionAddress );
                buf[_tsizeof(buf) - 1] = 0;
                SendMessage( dp->hwnd, WM_EXCEPTIONINFO, 0, (LPARAM) buf );
            }
            PostMortemDump( dp, &LastEx );
            if (dp->options.fCrash) {
                CreateDumpFile( dp );
            }

            //
            // Attempt to terminate the debuggee.  Continue
            // on if this doesn't work as the debuggee should
            // be killed anyway when Dr. Watson exits.
            //
            
            hThread = CreateThread( NULL,
                                    16000,
                                    (LPTHREAD_START_ROUTINE)TerminationThread,
                                    dp,
                                    0,
                                    &dwThreadId
                                    );
            if (hThread) {
                WaitForSingleObject( hThread, 30000 );
                CloseHandle( hThread );
            }

            dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO_NOT_HANDLED);
            break;

        case DEBUG_EVENT_EXIT_THREAD:
            if ( dp->hEventToSignal ) {
                SetEvent(dp->hEventToSignal);
                dp->hEventToSignal = 0L;
            }
            dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO);
            break;
        }
    }

exit:
    CloseLogFile();

    if (dp->options.fVisual) {
        SendMessage( dp->hwnd, WM_DUMPCOMPLETE, 0, 0 );
    }

    return 0;
}

DWORD
TerminationThread(
    PDEBUGPACKET dp
    )
{
    HANDLE hProcess;

    hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, dp->dwPidToDebug );
    if (hProcess != NULL) {
        TerminateProcess( hProcess, dp->ExitStatus );
        CloseHandle( hProcess );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\drwtsn32.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    drwtsn32.cpp

Abstract:

    This file implements the user interface for DRWTSN32.  this includes
    both dialogs: the ui for the control of the options & the popup
    ui for application errors.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


int
__cdecl
main(
    int argc,
    _TCHAR *argv[]
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    argc           - argument count

    argv           - array of arguments

Return Value:

    always zero.

--*/

{
    DWORD   dwPidToDebug = 0;
    HANDLE  hEventToSignal = 0;
    BOOLEAN rc;

    // Keep Dr. Watson from recursing
    __try {

        rc = GetCommandLineArgs( &dwPidToDebug, &hEventToSignal );

        if (dwPidToDebug > 0) {
            
            NotifyWinMain();

        } else if (!rc) {
            
            DrWatsonWinMain();

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // We suffered an error, fail gracefully
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\drwatson.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    drwatson.h

Abstract:

    Common header file for drwatson data structures.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

typedef enum _CrashDumpType {
    FullDump  = 0,
    MiniDump  = 1,
    FullMiniDump = 2,
} CrashDumpType;

typedef struct _tagOPTIONS {
    _TCHAR                      szLogPath[MAX_PATH];
    _TCHAR                      szWaveFile[MAX_PATH];
    _TCHAR                      szCrashDump[MAX_PATH];
    BOOL                        fDumpSymbols;
    BOOL                        fDumpAllThreads;
    BOOL                        fAppendToLogFile;
    BOOL                        fVisual;
    BOOL                        fSound;
    BOOL                        fCrash;
    // true: Generate user dump name in the range from fname000.dmp to fname999.dmp
    // false: standard behavior, always overwrite fname.dmp when generating a new
    //      dump file.
    BOOL                        fUseSequentialNaming;
    // If TRUE use long file names when sequentially naming the dumps
    // If FALSE use 8.3 file names when sequentially naming the dumps
    //      causes the 'n' of characters to be removed from the end of the
    //      file name to make it fit in the 8.3 format. ie longuser.dmp -> longus00.dmp
    BOOL                        fUseLongFileNames;
    int                         nNextDumpSequence;
    DWORD                       dwInstructions;
    DWORD                       dwMaxCrashes;
    CrashDumpType               dwType;
} OPTIONS, *POPTIONS;

typedef struct _tagCRASHES {
    _TCHAR                      szAppName[256];
    _TCHAR                      szFunction[256];
    SYSTEMTIME                  time;
    DWORD                       dwExceptionCode;
    DWORD_PTR                   dwAddress;
} CRASHES, *PCRASHES;

typedef struct _tagCRASHINFO {
    HWND       hList;
    CRASHES    crash;
    HDC        hdc;
    DWORD      cxExtent;
    DWORD      dwIndex;
    DWORD      dwIndexDesired;
    BYTE      *pCrashData;
    DWORD      dwCrashDataSize;
} CRASHINFO, *PCRASHINFO;

typedef struct _tagDEBUGPACKET {
    HWND                    hwnd;
    OPTIONS                 options;
    DWORD                   dwPidToDebug;
    HANDLE                  hEventToSignal;
    HANDLE                  hProcess;
    DWORD                   dwProcessId;
    DWORD                   ExitStatus;
    
    // Debug engine interfaces.
    PDEBUG_CLIENT2          DbgClient;
    PDEBUG_CONTROL          DbgControl;
    PDEBUG_DATA_SPACES      DbgData;
    PDEBUG_REGISTERS        DbgRegisters;
    PDEBUG_SYMBOLS          DbgSymbols;
    PDEBUG_SYSTEM_OBJECTS   DbgSystem;
} DEBUGPACKET, *PDEBUGPACKET;

typedef BOOL (CALLBACK* CRASHESENUMPROC)(PCRASHINFO);

#if DBG
#define Assert(exp)    if(!(exp)) {AssertError(_T(#exp),_T(__FILE__),__LINE__);}
#else
#define Assert(exp)
#endif

#define WM_DUMPCOMPLETE       WM_USER+500
#define WM_EXCEPTIONINFO      WM_USER+501
#define WM_ATTACHCOMPLETE     WM_USER+502
#define WM_FINISH             WM_USER+503

extern const DWORD DrWatsonHelpIds[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\eventlog.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    eventlog.cpp

Abstract:

    This file contains all functions that access the application event log.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


_TCHAR * AddString( _TCHAR* base, DWORD len,
                    _TCHAR *p, _TCHAR *s );
_TCHAR * AddNumber( _TCHAR* base, DWORD len,
                    _TCHAR *p, _TCHAR *f, DWORD dwNumber );
_TCHAR * AddAddr( _TCHAR* base, DWORD len,
                  _TCHAR *p, _TCHAR *f, ULONG_PTR dwNumber );
_TCHAR * GetADDR( ULONG_PTR *ppvData, _TCHAR *p );
_TCHAR * GetDWORD( PDWORD pdwData, _TCHAR *p );
_TCHAR * GetWORD( PWORD pwData, _TCHAR *p );
_TCHAR * GetString( _TCHAR *s, _TCHAR *p, DWORD size );


BOOL
ElClearAllEvents(
    void
    )
{
    HANDLE           hEventLog;
    _TCHAR            szAppName[MAX_PATH];


    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    hEventLog = OpenEventLog( NULL, szAppName );
    if ( hEventLog != NULL ) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }
    RegSetNumCrashes(0);

    return TRUE;
}

BOOL
ElEnumCrashes(
    PCRASHINFO crashInfo,
    CRASHESENUMPROC lpEnumFunc
    )
{
    _TCHAR            *p;
    HANDLE           hEventLog;
    _TCHAR            *szEvBuf;
    EVENTLOGRECORD   *pevlr;
    DWORD            dwRead;
    DWORD            dwNeeded;
    DWORD            dwBufSize = 4096 * sizeof(_TCHAR);
    BOOL             rc;
    BOOL             ec;
    _TCHAR            szAppName[MAX_PATH];


    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    hEventLog = OpenEventLog( NULL, szAppName );
    if (hEventLog == NULL) {
        return FALSE;
    }

    szEvBuf = (_TCHAR *) calloc( dwBufSize, sizeof(_TCHAR) );
    if (szEvBuf == NULL) {
        return FALSE;
    }

    while (TRUE) {
try_again:
        rc = ReadEventLog(hEventLog,
                        EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        (EVENTLOGRECORD *) szEvBuf,
                        dwBufSize,
                        &dwRead,
                        &dwNeeded);

        if (!rc) {
            ec = GetLastError();
            if (ec != ERROR_INSUFFICIENT_BUFFER) {
                goto exit;
            }

            free( szEvBuf );

            dwBufSize = dwNeeded + 1024;
            szEvBuf = (_TCHAR *) calloc( dwBufSize, sizeof(_TCHAR) );
            if (szEvBuf == NULL) {
                return FALSE;
            }

            goto try_again;
        }

        if (dwRead == 0) {
            break;
        }

        GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
        p = szEvBuf;

        do {

            pevlr = (EVENTLOGRECORD *) p;

            p = (PWSTR) ( (PBYTE)p + sizeof(EVENTLOGRECORD));

            if (!_tcscmp( p, szAppName)) {

                p = (PWSTR) ( (PBYTE)pevlr + pevlr->StringOffset );

                p = GetString( crashInfo->crash.szAppName,           p,
                    sizeof(crashInfo->crash.szAppName) / sizeof(crashInfo->crash.szAppName[0]) );
                p = GetWORD  ( &crashInfo->crash.time.wMonth,        p );
                p = GetWORD  ( &crashInfo->crash.time.wDay,          p );
                p = GetWORD  ( &crashInfo->crash.time.wYear,         p );
                p = GetWORD  ( &crashInfo->crash.time.wHour,         p );
                p = GetWORD  ( &crashInfo->crash.time.wMinute,       p );
                p = GetWORD  ( &crashInfo->crash.time.wSecond,       p );
                p = GetWORD  ( &crashInfo->crash.time.wMilliseconds, p );
                p = GetDWORD ( &crashInfo->crash.dwExceptionCode,    p );
                p = GetADDR  ( &crashInfo->crash.dwAddress,          p );
                p = GetString( crashInfo->crash.szFunction,          p,
                    sizeof(crashInfo->crash.szFunction) / sizeof(crashInfo->crash.szFunction[0]) );

                p = (_TCHAR *) (pevlr + 1);

                crashInfo->dwCrashDataSize = pevlr->DataLength;
                crashInfo->pCrashData = (PBYTE) ((DWORD_PTR)pevlr + pevlr->DataOffset);

                if (!lpEnumFunc( crashInfo )) {
                    goto exit;
                }
            }

            //
            // update the pointer & read count
            //
            if (dwRead <= pevlr->Length) {
                // Set it to 0 so that we don't wrap around
                dwRead = 0;
            } else {
                dwRead -= pevlr->Length;
            }

            p = (_TCHAR *) ((DWORD_PTR)pevlr + pevlr->Length);

        } while ( dwRead > 0 );
    }

exit:
    free( szEvBuf );
    CloseEventLog( hEventLog );
    return TRUE;
}

BOOL
ElSaveCrash(
    PCRASHES crash,
    DWORD dwMaxCrashes
    )
{
    _TCHAR   szStrings[4096] = {0};
    PTSTR   p = szStrings;
    HANDLE  hEventSrc;
    PTSTR   pp[20] = {0};
    _TCHAR  *pLogFileData;
    DWORD   dwLogFileDataSize;
    _TCHAR  szAppName[MAX_PATH];


    if (dwMaxCrashes > 0) {
        if (RegGetNumCrashes() >= dwMaxCrashes) {
            return FALSE;
        }
    }

    RegSetNumCrashes( RegGetNumCrashes()+1 );

    p = AddString( szStrings, _tsizeof(szStrings),
                   pp[0]  = p,              crash->szAppName           );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[1]  = p, _T("%02d"),  crash->time.wMonth         );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[2]  = p, _T("%02d"),  crash->time.wDay           );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[3]  = p, _T("%4d"),   crash->time.wYear          );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[4]  = p, _T("%02d"),  crash->time.wHour          );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[5]  = p, _T("%02d"),  crash->time.wMinute        );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[6]  = p, _T("%02d"),  crash->time.wSecond        );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[7]  = p, _T("%03d"),  crash->time.wMilliseconds  );
    p = AddNumber( szStrings, _tsizeof(szStrings),
                   pp[8]  = p, _T("%08x"),  crash->dwExceptionCode     );
    p = AddAddr  ( szStrings, _tsizeof(szStrings),
                   pp[9]  = p, _T("%p"),    crash->dwAddress           );
    p = AddString( szStrings, _tsizeof(szStrings),
                   pp[10] = p,              crash->szFunction          );

    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );

    hEventSrc = RegisterEventSource( NULL, szAppName );

    if (hEventSrc == NULL) {
        return FALSE;
    }

    pLogFileData = GetLogFileData( &dwLogFileDataSize );

    ReportEvent( hEventSrc,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 MSG_CRASH,
                 NULL,
                 11,
                 dwLogFileDataSize,
                 (PCTSTR*)pp,
                 pLogFileData
               );

    DeregisterEventSource( hEventSrc );

    free( pLogFileData );

    return TRUE;
}

_TCHAR *
AddString(
    _TCHAR* base,
    DWORD len,
    _TCHAR *p,
    _TCHAR *s
    )
{
    if (p < base + (len - 1)) {
        lstrcpyn( p, s, len - (DWORD)(p - base) );
        p += (_tcslen(s) + 1);
    }
    return p;
}

_TCHAR *
AddNumber(
    _TCHAR* base,
    DWORD len,
    _TCHAR *p,
    _TCHAR *f,
    DWORD dwNumber
    )
{
    _TCHAR buf[64];
    _stprintf( buf, f, dwNumber );
    return AddString( base, len, p, buf );
}

_TCHAR *
AddAddr(
    _TCHAR* base,
    DWORD len,
    _TCHAR *p,
    _TCHAR *f,
    DWORD_PTR dwNumber
    )
{
    _TCHAR buf[64];
    _stprintf( buf, f, dwNumber );
    return AddString( base, len, p, buf );
}

_TCHAR *
GetString(
    _TCHAR *s,
    _TCHAR *p,
    DWORD size
    )
{
    lstrcpyn( s, p, size );
    return p + _tcslen(p) + 1;
}

_TCHAR *
GetDWORD(
    PDWORD pdwData,
    _TCHAR *p
    )
{
    if (_stscanf( p, _T("%x"), pdwData ) != 1) {
        *pdwData = 0;
    }
    return p + _tcslen(p) + 1;
}

_TCHAR *
GetADDR(
    ULONG_PTR *pAddrData,
    _TCHAR *p
    )
{
    if (_stscanf( p, _T("%p"), pAddrData ) != 1) {
        *pAddrData = 0;
    }
    return p + _tcslen(p) + 1;
}



_TCHAR *
GetWORD(
    PWORD pwData,
    _TCHAR *p
    )
{
    *pwData = (WORD)_ttoi( p );
    return p + _tcslen(p) + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\log.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    This file implements the access to the postmortem log file.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


#define BYTE_ORDER_MARK           0xFEFF
#define MAX_PRINTF_BUF_SIZE (1024 * 4)

enum LOG_TYPE {
    LT_ANSI,
    LT_UNICODE
};

//
// global variables for this module
//
static HANDLE  hFile = NULL;
static DWORD   dwStartingPos = 0;
static WCHAR   wchBOM = BYTE_ORDER_MARK;
static DWORD   dwLogType = LT_ANSI;

void
WriteAnsiCharsToLogFile(
    WCHAR *pszUnicode,
    DWORD dwCharCount
    )
{
    char szAnsiBuf[MAX_PRINTF_BUF_SIZE] = {0};
    DWORD nCharTranslated;
    WCHAR szWcharBuf[MAX_PRINTF_BUF_SIZE] = {0};

    nCharTranslated = WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
        pszUnicode, dwCharCount,
        szAnsiBuf, sizeof(szAnsiBuf), NULL, NULL);

    WriteFile( hFile, szAnsiBuf, nCharTranslated, &nCharTranslated, NULL );
#if 0
    nCharTranslated = MultiByteToWideChar(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
                                          szAnsiBuf, nCharTranslated,
                                          szWcharBuf, sizeof(szWcharBuf)/sizeof(WCHAR));

    WriteFile( hFile, szWcharBuf, nCharTranslated, &nCharTranslated, NULL );
#endif
}

void
__cdecl
lprintf(
    DWORD dwFormatId,
    ...
    )

/*++

Routine Description:

    This is function is a printf style function for printing messages
    in a message file.

Arguments:

    dwFormatId    - format id in the message file

    ...           - var args

Return Value:

    None.

--*/

{
    _TCHAR       buf[MAX_PRINTF_BUF_SIZE] = {0};
    DWORD       dwCount;
    va_list     args;

    va_start( args, dwFormatId );

    dwCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwFormatId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT), // Default language
                buf,
                sizeof(buf) / sizeof(_TCHAR),
                &args
                );

    va_end(args);

    if (dwCount == 0) {
        // Failure, nothing to write.
        return;
    }

#ifdef UNICODE
    // We currently want all of the output to be in ANSI
    if (dwLogType == LT_ANSI) {
        WriteAnsiCharsToLogFile(buf, dwCount);
    } else {
        WriteFile( hFile, buf, dwCount * sizeof(_TCHAR), &dwCount, NULL );
    }
#else
    WriteFile( hFile, buf, dwCount, &dwCount, NULL );
#endif

    return;
}

void
__cdecl
lprintfs(
    _TCHAR *format,
    ...
    )

/*++

Routine Description:

    This is function is a printf replacement that writes the output to
    the DrWatson log file.

Arguments:

    format        - print format

    ...           - var args

Return Value:

    None.

--*/

{
    _TCHAR   buf[MAX_PRINTF_BUF_SIZE] = {0};
    int      chars;
    DWORD    cb;

    va_list arg_ptr;
    va_start(arg_ptr, format);
    chars = _vsntprintf(buf, _tsizeof(buf), format, arg_ptr);
    buf[_tsizeof(buf) - 1] = 0;
    if (chars < 0 || chars == _tsizeof(buf)) {
        cb = _tsizeof(buf) - 1;
    } else {
        cb = chars;
    }
    va_end(arg_ptr);
    Assert( hFile != NULL );

#ifdef UNICODE
    // We currently want all of the output to be in ANSI
    if (dwLogType == LT_ANSI) {
        WriteAnsiCharsToLogFile(buf, cb);
    } else {
        WriteFile( hFile, buf, cb * sizeof(_TCHAR), &cb, NULL );
    }
#else
    WriteFile( hFile, buf, cb * sizeof(_TCHAR), &cb, NULL );
#endif
}

void
OpenLogFile(
    _TCHAR *szFileName,
    BOOL fAppend,
    BOOL fVisual
    )

/*++

Routine Description:

    Opens the DrWatson logfile for reading & writting.

Arguments:

    szFileName    - logfile name

    fAppend       - append the new data to the end of the file or
                    create a new file

    fVisual       - visual notification

Return Value:

    None.

--*/

{
    DWORD size;
    DWORD Retries = 10;

    //
    // The log file may be in use by another instance
    // of Dr. Watson, so try and open it several times
    // with a wait inbetween.
    //
    
    for (;;) {
        
        hFile = CreateFile( szFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (hFile != INVALID_HANDLE_VALUE) {
            break;
        }
        
        if (fVisual) {
            NonFatalError( LoadRcString(IDS_INVALID_LOGFILE) );
            _tgetcwd( szFileName, MAX_PATH );
            if (!BrowseForDirectory(NULL, szFileName, MAX_PATH )) {
                FatalError( GetLastError(),
                            LoadRcString(IDS_CANT_OPEN_LOGFILE) );
            }
            MakeLogFileName( szFileName );
        }
        else if (Retries-- == 0) {
            ExitProcess( 1 );
        }
        else {
            Sleep(1000);
        }
    }

    if (!fAppend || GetLastError() != ERROR_ALREADY_EXISTS) {

        //
        // The file was just created, so put a header in it.
        //

        dwLogType = LT_UNICODE;
        WriteFile( hFile, &wchBOM, sizeof(_TCHAR), &size, NULL );
        lprintfs( _T("\r\n") );
        lprintf( MSG_BANNER );
        lprintfs( _T("\r\n") );
        
    } else {
        
#ifdef UNICODE
        //
        // Check if the file is Unicode or ANSI
        //
        WCHAR wchHdr = 0;

        dwLogType = LT_ANSI;
        if (ReadFile( hFile, &wchHdr, sizeof(TCHAR), &size, NULL )) {
            if (wchHdr == wchBOM) {
                dwLogType = LT_UNICODE;
            }
        }
#endif

        SetFilePointer( hFile, 0, 0, FILE_END );
    }

    dwStartingPos = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );
}

void
CloseLogFile(
    void
    )

/*++

Routine Description:

    Closes the DrWatson logfile & releases the semaphore that
    protects it.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CloseHandle( hFile );
}

_TCHAR *
GetLogFileData(
    PDWORD pdwLogFileDataSize
    )

/*++

Routine Description:

    Reads in all of the logfile data that has been written since it was
    opened.  The data is placed into a buffer allocated by this function.
    The caller is responsible for freeing the memory.

Arguments:

    pdwLogFileDataSize     -  pointer to a dword that contains the size
                              in bytes of the data that is read.

Return Value:

    Valid character pointer to the logfile data

    NULL - could not read the data.

--*/

{
    DWORD   dwCurrPos;
    _TCHAR   *p;
    DWORD   size;


    dwCurrPos = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );

    *pdwLogFileDataSize = 0;
    size = dwCurrPos - dwStartingPos;

    p = (_TCHAR *) calloc( size, sizeof(_TCHAR) );
    if (p == NULL) {
        return NULL;
    }

    SetFilePointer( hFile, dwStartingPos, NULL, FILE_BEGIN );

    if (!ReadFile( hFile, p, size, &size, NULL )) {
        free( p );
        p = NULL;
        size = 0;
    }

    SetFilePointer( hFile, dwCurrPos, NULL, FILE_BEGIN );

    *pdwLogFileDataSize = size;

    return p;
}

void
MakeLogFileName(
    _TCHAR *szName
    )

/*++

Routine Description:

    Concatenates the base logfile name on to the string passed in.

Arguments:

    szName                 -  buffer for the logfile name.

Return Value:

    None.

--*/

{
    if (_tcslen(szName) + 16 < MAX_PATH) {
        _tcscat( szName, _T("\\drwtsn32.log") );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\notify.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    notify.cpp

Abstract:
    This file implements the functions that make use of the common
    file open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


//
// defines
//
#define DEFAULT_WAIT_TIME   (1000 * 60 * 5)     // wait for 5 minutes
#define MAX_PRINTF_BUF_SIZE (1024 * 4)

HANDLE         hThreadDebug = 0;
PDEBUGPACKET   dp;


INT_PTR
CALLBACK
NotifyDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
UsageDialogProc (
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


void
NotifyWinMain (
    void
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    MSG            msg;
    DWORD          dwThreadId;
    HINSTANCE      hInst;


    dp = (PDEBUGPACKET) calloc( sizeof(DEBUGPACKET), sizeof(BYTE) );
    if ( dp == NULL) {
        return;
    }
    GetCommandLineArgs( &dp->dwPidToDebug, &dp->hEventToSignal );

    RegInitialize( &dp->options );

    if (dp->options.fVisual) {
        WNDCLASS wndclass;
        
        hInst                   = GetModuleHandle( NULL );
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = (WNDPROC)NotifyDialogProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = DLGWINDOWEXTRA;
        wndclass.hInstance      = hInst;
        wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) );
        wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
        wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = _T("NotifyDialog");
        RegisterClass( &wndclass );

        dp->hwnd = CreateDialog( hInst,
                                 MAKEINTRESOURCE( NOTIFYDIALOG ),
                                 0,
                                 NotifyDialogProc );
	if (dp->hwnd == NULL) {
	    return;
	}
    }

    hThreadDebug = CreateThread( NULL,
                            16000,
                            (LPTHREAD_START_ROUTINE)DispatchDebugEventThread,
                            dp,
                            0,
                            &dwThreadId
                          );

    if (hThreadDebug == NULL) {
	return;
    }

    if (dp->options.fSound) {
        if ((waveOutGetNumDevs() == 0) || (!_tcslen(dp->options.szWaveFile))) {
            MessageBeep( MB_ICONHAND );
            MessageBeep( MB_ICONHAND );
        }
        else {
            PlaySound( dp->options.szWaveFile, NULL, SND_FILENAME );
        }
    }

    if (dp->options.fVisual) {
        ShowWindow( dp->hwnd, SW_SHOWNORMAL );
        while (GetMessage (&msg, NULL, 0, 0)) {
            if (!IsDialogMessage( dp->hwnd, &msg )) {
                TranslateMessage (&msg) ;
                DispatchMessage (&msg) ;
            }
        }
    }
    else {
        WaitForSingleObject( hThreadDebug, INFINITE );
    }

    CloseHandle( hThreadDebug );

    return;
}

INT_PTR
CALLBACK
NotifyDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the DRWTSN32.EXE popup.  This is the popup
    that is displayed when an application error occurs.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    DWORD          dwThreadId;
    DWORD          dwSize;
    HANDLE         hThread;
    _TCHAR         szTaskName[MAX_PATH];

    static DWORD   AttachComplete=FALSE;
    static DWORD   Cancel=FALSE;

    _TCHAR         buf[MAX_PRINTF_BUF_SIZE];


    switch (message) {
        case WM_CREATE:
            return FALSE;

        case WM_INITDIALOG:

            SubclassControls( hwnd );

            //
            // OK is hidden until the debugger thread finishes
            //
            ShowWindow( GetDlgItem( hwnd, IDOK ), SW_HIDE );

            //
            // CANCEL is enabled right away
            //
            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), TRUE );

            //
            //  make sure that the user can see the dialog box
            //
            SetForegroundWindow( hwnd );

            //
            // get the task name and display it on the dialog box
            //
            dwSize = sizeof(szTaskName) / sizeof(_TCHAR);
            GetTaskName( dp->dwPidToDebug, szTaskName, &dwSize );

            //
            // prevent recursion in the case where drwatson faults
            //
            if (_tcsicmp(szTaskName, _T("drwtsn32")) == 0) {
                ExitProcess(0);
            }


            //
            // Add the text in the dialog box
            //
            memset(buf,0,sizeof(buf));
            GetNotifyBuf( buf, MAX_PRINTF_BUF_SIZE, MSG_NOTIFY, szTaskName );
            SetDlgItemText( hwnd, ID_TEXT1, buf);

            memset(buf,0,sizeof(buf));
            GetNotifyBuf( buf, MAX_PRINTF_BUF_SIZE, MSG_NOTIFY2 );
            SetDlgItemText( hwnd, ID_TEXT2, buf );

            return TRUE;

        case WM_ACTIVATEAPP:
        case WM_SETFOCUS:
            SetFocusToCurrentControl();
            return 0;

        case WM_TIMER:
            SendMessage( hwnd, WM_COMMAND, IDOK, 0 );
            return 0;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    SendMessage( hwnd, WM_DESTROY, 0, 0 );
                    break;

                case IDCANCEL:
                    Cancel = TRUE;

                    // Make the window go away, but don't kill the
                    // the process until the WM_ATTACHCOMPLETE has
                    // occurred
                    ShowWindow( hwnd, SW_HIDE );
                    SendMessage( hwnd, WM_FINISH, 0, 0 );
                    
		    // Delete the dump file, since its invalid anyway
		    DeleteCrashDump();
		    break;
            }
            break;

        case WM_NEXTDLGCTL:
            DefDlgProc( hwnd, message, wParam, lParam );
            return 0;

        case WM_DUMPCOMPLETE:

            //
            // the message is received from the debugger thread
            // when the postmortem dump is finished.  all we need to do
            // is enable the OK button and wait for the user to press the
            // OK button or for the timer to expire.  in either case
            // DrWatson will terminate.
            //

            // Disable and hide the Cancel button
            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), FALSE);
            ShowWindow( GetDlgItem(hwnd, IDCANCEL ), SW_HIDE);

            // Show and Enable the OK button
            ShowWindow( GetDlgItem( hwnd, IDOK ), SW_SHOW);
            EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
            SetFocus( GetDlgItem(hwnd, IDOK) );
            SetFocusToCurrentControl();

            SetTimer( hwnd, 1, DEFAULT_WAIT_TIME, NULL );
            return 0;

        case WM_ATTACHCOMPLETE:
            //
            // the message is received from the debugger thread when
            // the debugactiveprocess() is completed.
            //

            AttachComplete = TRUE;
            SendMessage( hwnd, WM_FINISH, 0, 0 );
            return 0;

        case WM_FINISH:
            if (AttachComplete && Cancel) {

                //
                // terminate the debugger thread
                //
                if ( hThreadDebug ) TerminateThread( hThreadDebug, 0 );

                //
                // create a thread to terminate the debuggee
                // this is necessary if cancel is pressed before the
                // debugger thread finishes the postmortem dump
                //
                hThread = CreateThread( NULL,
                          16000,
                          (LPTHREAD_START_ROUTINE)TerminationThread,
                          dp,
                          0,
                          &dwThreadId
                        );

                //
                // wait for the termination thread to kill the debuggee
                //
                WaitForSingleObject( hThread, 30000 );

                CloseHandle( hThread );

                //
                // now post a quit message so that DrWatson will go away
                //
                SendMessage( hwnd, WM_DESTROY, 0, 0 );
            }
            return 0;

        case WM_EXCEPTIONINFO:

            return 0;

        case WM_DESTROY:
            KillTimer( hwnd, 1 );
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

BOOLEAN
GetCommandLineArgs(
    LPDWORD dwPidToDebug,
    LPHANDLE hEventToSignal
    )

/*++

Routine Description:

    Parses the command line for the 3 possible command lines
    arguments:

         -p %ld        process id
         -e %ld        event id
         -g            go

Arguments:

    dwPidToDebug - Returns the process id of the process to debug

    hEventToSignal - Returns the handle to an event which will be signalled
        when the attach is complete.

Return Value:

    None.

--*/

{
    _TCHAR      *lpstrCmd = GetCommandLine();
    _TUCHAR       ch;
    _TCHAR      buf[4096];
    BOOLEAN     rval = FALSE;
    BOOLEAN     ParsedEvent = FALSE;
    BOOLEAN     ParsedPid = FALSE;

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != _T(' ') && ch != _T('\t') && ch != _T('\0'));

    //  skip over any following white space
    while (ch == _T(' ') || ch == _T('\t')) {
        ch = *lpstrCmd++;
    }

    //  process each switch character _T('-') as encountered

    while (ch == _T('-')) {
        ch = *lpstrCmd++;
        //  process multiple switch characters as needed
        do {
            switch (ch) {
                case _T('e'):
                case _T('E'):
                    // event to signal takes decimal argument
                    // skip whitespace
                    do {
                        ch = *lpstrCmd++;
                    }
                    while (ch == _T(' ') || ch == _T('\t'));
                    while (ch >= _T('0') && ch <= _T('9')) {
                        if (!ParsedEvent) {
                            *hEventToSignal = (HANDLE)
                                ((DWORD_PTR)*hEventToSignal * 10 + ch - _T('0'));
                        }
                        ch = *lpstrCmd++;
                    }
                    rval = TRUE;
                    ParsedEvent = TRUE;
                    break;

                case _T('p'):
                case _T('P'):
                    // pid debug takes decimal argument

                    do
                        ch = *lpstrCmd++;
                    while (ch == _T(' ') || ch == _T('\t'));

                    if ( ch == _T('-') ) {
                        ch = *lpstrCmd++;
                        if ( ch == _T('1') ) {
                            if (!ParsedPid) {
                                *dwPidToDebug = (DWORD)-1;
                            }
                            ch = *lpstrCmd++;
                        }
                    }
                    else {
                        while (ch >= _T('0') && ch <= _T('9')) {
                            if (!ParsedPid) {
                                *dwPidToDebug =
                                    *dwPidToDebug * 10 + ch - _T('0');
                            }
                            ch = *lpstrCmd++;
                        }
                    }
                    rval = TRUE;
                    ParsedPid = TRUE;
                    break;

                case _T('g'):
                case _T('G'):
                    // GO
                    // Ignored but provided for compatiblity with windbg & ntsd
                    ch = *lpstrCmd++;
                    break;

                case _T('?'):
                    DialogBox( GetModuleHandle(NULL),
                               MAKEINTRESOURCE(USAGEDIALOG),
                               NULL,
                               UsageDialogProc
                             );
                    rval = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case _T('i'):
                case _T('I'):
                    FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      NULL,
                      MSG_INSTALL_NOTIFY,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                      buf,
                      sizeof(buf) / sizeof(_TCHAR),
                      NULL
                      );
                    RegInstallDrWatson( tolower(lpstrCmd[0]) == _T('q') );
                    MessageBox( NULL,
                                buf,
                                _T("Dr. Watson"),
                                MB_ICONINFORMATION | MB_OK |
                                MB_SETFOREGROUND );
                    rval = TRUE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    return rval;
            }
        } while (ch != _T(' ') && ch != _T('\t') && ch != _T('\0'));

        while (ch == _T(' ') || ch == _T('\t')) {
            ch = *lpstrCmd++;
        }
    }
    return rval;
}

INT_PTR
CALLBACK
UsageDialogProc (
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the assert dialog box.  Normally
    an assertion box is simply a message box but in this case a Help
    button is desired so a dialog box is used.

Arguments:

    hDlg       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    _TCHAR        buf[4096];

    switch (message) {
        case WM_INITDIALOG:
            FormatMessage(
              FORMAT_MESSAGE_FROM_HMODULE,
              NULL,
              MSG_USAGE,
              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
              buf,
              sizeof(buf) / sizeof(_TCHAR),
              NULL
              );
            SetDlgItemText( hDlg, ID_USAGE, buf );
            break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    EndDialog( hDlg, 0 );
                    break;
            }
            break;
    }

    return FALSE;
}


void
__cdecl
GetNotifyBuf(
    LPTSTR buf,
    DWORD bufsize,
    DWORD dwFormatId,
    ...
    )

/*++

Routine Description:

    This is function is a printf style function for printing messages
    in a message file.

Arguments:

    dwFormatId    - format id in the message file

    ...           - var args

Return Value:

    None.

--*/

{
    DWORD       dwCount;
    va_list     args;

    va_start( args, dwFormatId );

    dwCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwFormatId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //Default language
                buf,
                bufsize,
                &args
                );

    va_end(args);

    Assert( dwCount != 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\error.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    error.cpp

Abstract:

    This file implements the error handeling functions for the
    entire DRWTSN32 application.  This includes error popups,
    debug prints, and assertions.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
__cdecl
FatalError(
    HRESULT Error,
    _TCHAR * pszFormat,
    ...
    )

/*++

Routine Description:

    This function is called when there is nothing else to do, hence
    the name FatalError.  It puts up a popup and then terminates.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    PTSTR        pszErrMsg = NULL;
    PTSTR        pszInternalMsgFormat = NULL;
    _TCHAR       szArgumentsBuffer[1024 * 2] = {0};
    _TCHAR       szMsg[1024 * 8] = {0};
    DWORD       dwCount;
    va_list     arg_ptr;

    va_start(arg_ptr, pszFormat);
    _vsntprintf(szArgumentsBuffer, sizeof(szArgumentsBuffer) / sizeof(_TCHAR),
                pszFormat, arg_ptr);
    szArgumentsBuffer[sizeof(szArgumentsBuffer) / sizeof(_TCHAR) - 1] = 0;
    va_end(arg_ptr);

    dwCount = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (PTSTR) &pszErrMsg,
        0,
        NULL
        );

    _sntprintf(szMsg, sizeof(szMsg) / sizeof(_TCHAR),
               LoadRcString(IDS_ERROR_FORMAT_STRING),
               szArgumentsBuffer, Error);
    szMsg[sizeof(szMsg) / sizeof(_TCHAR) - 1] = 0;

    if (dwCount) {
        if ( (_tcslen(szMsg) + _tcslen(pszErrMsg) +1) * sizeof(_TCHAR) < sizeof(szMsg)) {
            _tcscat(szMsg, pszErrMsg);
        }
    }

    MessageBox(NULL, szMsg, LoadRcString(IDS_FATAL_ERROR), MB_TASKMODAL | MB_SETFOREGROUND | MB_OK);

    if (pszErrMsg) {
        LocalFree(pszErrMsg);
    }

    ExitProcess(0);
}

void
__cdecl
NonFatalError(
    PTSTR pszFormat,
    ...
    )

/*++

Routine Description:

    This function is used to generate a popup with some kind of
    warning message inside.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    PTSTR        pszErrMsg = NULL;
    PTSTR        pszInternalMsgFormat = NULL;
    _TCHAR       szArgumentsBuffer[1024 * 2] = {0};
    _TCHAR       szMsg[1024 * 8] = {0};
    DWORD       dwCount;
    va_list     arg_ptr;
    DWORD       dwError;

    dwError = GetLastError();

    va_start(arg_ptr, pszFormat);
    _vsntprintf(szArgumentsBuffer, sizeof(szArgumentsBuffer) / sizeof(_TCHAR),
                pszFormat, arg_ptr);
    szArgumentsBuffer[sizeof(szArgumentsBuffer) / sizeof(_TCHAR) - 1] = 0;
    va_end(arg_ptr);

    if (ERROR_SUCCESS == dwError) {
        // Don't bother getting an error message
        _tcscpy(szMsg, szArgumentsBuffer);
    } else {
        // We have a real error
        dwCount = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (PTSTR) &pszErrMsg,
            0,
            NULL
            );

        _sntprintf(szMsg, sizeof(szMsg) / sizeof(_TCHAR),
                   LoadRcString(IDS_ERROR_FORMAT_STRING),
                   szArgumentsBuffer, dwError);
        szMsg[sizeof(szMsg) / sizeof(_TCHAR) - 1] = 0;

        if (dwCount) {
            if ( (_tcslen(szMsg) + _tcslen(pszErrMsg) +1) * sizeof(_TCHAR) < sizeof(szMsg)) {
                _tcscat(szMsg, pszErrMsg);
            }
        }
    }

    MessageBox(NULL, szMsg, LoadRcString(IDS_NONFATAL_ERROR),
        MB_TASKMODAL | MB_SETFOREGROUND | MB_OK);

    if (pszErrMsg) {
        LocalFree(pszErrMsg);
    }
}

void
__cdecl
dprintf(
    _TCHAR *format,
    ...
    )

/*++

Routine Description:

    This function is a var-args version of OutputDebugString.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    _TCHAR    buf[1024];

    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsntprintf(buf, sizeof(buf) / sizeof(_TCHAR), format, arg_ptr);
    buf[sizeof(buf) / sizeof(_TCHAR) - 1] = 0;
    va_end(arg_ptr);
    OutputDebugString( buf );
    return;
}


void
AssertError(
    PTSTR    pszExpression,
    PTSTR    pszFile,
    DWORD   dwLineNumber
    )
/*++
Routine Description:
    Display an assertion failure message box which gives the user a choice
    as to whether the process should be aborted, the assertion ignored or
    a break exception generated.

Arguments:

    Expression  - Supplies a string representation of the failed assertion.

    File        - Supplies a pointer to the file name where the assertion
                  failed.

    LineNumber  - Supplies the line number in the file where the assertion
                  failed.

Return Value:

    None.

--*/
{
    int         nResponse;
    _TCHAR       szModuleBuffer[ MAX_PATH ];
    DWORD       dwLength;
    _TCHAR       szBuffer[ 4096 ];
    DWORD       dwError;
    LPTSTR      lpszMsgBuf = NULL;

    dwError = GetLastError();

    //
    // Get the last error string
    //
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |  FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpszMsgBuf,
        0,
        NULL);

    //
    // Get the asserting module's file name.
    //
    dwLength = GetModuleFileName( NULL, szModuleBuffer, sizeof(szModuleBuffer) / sizeof(_TCHAR));

    _sntprintf(szBuffer, sizeof(szBuffer) / sizeof(_TCHAR),
               _T("Assertion Failed : <%s> in file %s at line %u\n\n")
               _T("Module Name: %s\nLast system error: %u\n%s"),
               pszExpression, pszFile, dwLineNumber, szModuleBuffer,
               dwError, lpszMsgBuf);
    szBuffer[sizeof(szBuffer) / sizeof(_TCHAR) - 1] = 0;

    LocalFree( lpszMsgBuf );

    nResponse = MessageBox(NULL, szBuffer, _T("DrWatson Assertion"),
        MB_TASKMODAL | MB_ABORTRETRYIGNORE | MB_ICONERROR | MB_TASKMODAL);

    switch( nResponse ) {
    case IDABORT:
        //
        // Terminate the process.
        //
        ExitProcess( (UINT) -1 );
        break;

    case IDIGNORE:
        //
        // Ignore the failed assertion.
        //
        break;

    case IDRETRY:
        //
        // Break into a debugger.
        //
        DebugBreak();
        break;

    default:
        //
        // Break into a debugger because of a catastrophic failure.
        //
        DebugBreak( );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\process.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    This code provides access to the task list.

Author:

    Wesley Witt (wesw) 16-June-1993

Environment:

    User Mode

--*/

#include "pch.cpp"

#include <winperf.h>


//
// task list structure returned from GetTaskList()
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    _TCHAR      ProcessName[MAX_PATH];
} TASK_LIST, *PTASK_LIST;


//
// defines
//
#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")
#define UNKNOWN_TASK        _T("unknown")


//
// prototypes
//
PTASK_LIST
GetTaskList(
    LPLONG pNumTasks
    );


void
GetTaskName(
    ULONG pid,
    _TCHAR *szTaskName,
    LPDWORD pdwSize
    )

/*++

Routine Description:

    Gets the task name for a given process id.

Arguments:

    pid              - Process id to look for.

    szTaskName       - Buffer to put the task name into.

    lpdwSize         - Pointer to a dword.  On entry it contains the
                       size of the szTaskName buffer in characters.
                       On exit it contains the number of characters
                       in the buffer.

Return Value:

    None.

--*/

{
    PTASK_LIST   pTask;
    PTASK_LIST   pTaskBegin;
    LONG         NumTasks;


    pTask = pTaskBegin = GetTaskList( &NumTasks );

    if (pTask == NULL) {
        if (szTaskName) {
            _tcsncpy( szTaskName, _T("unknown"), *pdwSize );
            szTaskName[(*pdwSize) -1] = 0;
        }
        *pdwSize = min( 7, *pdwSize );

    } else {

        while (NumTasks--) {
            if (pTask->dwProcessId == pid) {
                if (szTaskName) {
                    _tcsncpy( szTaskName, pTask->ProcessName, *pdwSize );
                    szTaskName[(*pdwSize) -1] = 0;
                }
                *pdwSize = min( _tcslen(pTask->ProcessName), *pdwSize );
                break;
            }
            pTask++;
        }

        if (NumTasks < 0) {
            if (szTaskName) {
                _tcsncpy( szTaskName, LoadRcString(IDS_APP_ALREADY_EXITED), *pdwSize );
                szTaskName[(*pdwSize) -1] = 0;
            }
            *pdwSize = min( 8, *pdwSize );
        }

        free( pTaskBegin );
    }
}

PTASK_LIST
GetTaskList(
    LPLONG pNumTasks
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    pNumTasks      - pointer to a dword that will be set to the
                       number of tasks returned.

Return Value:

    PTASK_LIST       - pointer to an array of TASK_LIST records.

--*/

{
    DWORD                        rc;
    HKEY                         hKeyNames = NULL;
    DWORD                        dwType;
    DWORD                        dwSize;
    DWORD                        dwSizeOffered;
    PTSTR                        buf = NULL;
    _TCHAR                       szSubKey[1024];
    LANGID                       lid;
    PTSTR                        p;
    PTSTR                        p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter = 0;
    PTASK_LIST                   pTask;
    PTASK_LIST                   pTaskReturn = NULL;
#ifndef UNICODE
    _TCHAR                       szProcessName[MAX_PATH];
#endif
    int                          PrintChars;

    //
    // set the number of tasks to zero until we get some
    //
    *pNumTasks = 0;

    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    PrintChars = _sntprintf( szSubKey, _tsizeof(szSubKey),
                             _T("%s\\%03x"), REGKEY_PERF, lid );
    szSubKey[_tsizeof(szSubKey) - 1] = 0;
    if (PrintChars < 1 || PrintChars == _tsizeof(szSubKey)) {
        goto exit;
    }
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (PTSTR) calloc( dwSize, sizeof(BYTE) );
    if (buf == NULL) {
        goto exit;
    }

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          (PBYTE) buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

    p = buf;
    while (*p) {
        if (_tcsicmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for ( p2=p-2; isdigit(*p2); p2--) {
                ;
            }
            lstrcpyn( szSubKey, p2+1, _tsizeof(szSubKey) );
        }
        else
        if (_tcsicmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) {
                ;
            }
            dwProcessIdTitle = _ttol( p2+1 );
        }
        //
        // next string
        //
        p += (_tcslen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = (PTSTR) calloc( dwSize, sizeof(BYTE) );
    if (buf == NULL) {
        goto exit;
    }


    while (TRUE) {

        dwSizeOffered = dwSize;

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              (PBYTE) buf,
                              &dwSizeOffered
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)_T('P') &&
            (pPerf)->Signature[1] == (WCHAR)_T('E') &&
            (pPerf)->Signature[2] == (WCHAR)_T('R') &&
            (pPerf)->Signature[3] == (WCHAR)_T('F') ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            PTSTR NewBuf;
            
            dwSize += EXTEND_SIZE;
            NewBuf = (PTSTR) realloc( buf, dwSize );
            if (!NewBuf) {
                goto exit;
            }
            buf = NewBuf;
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD_PTR)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    //
    // allocate a buffer for the returned task list
    //
    dwSize = pObj->NumInstances * sizeof(TASK_LIST);
    pTask = pTaskReturn = (PTASK_LIST) calloc( dwSize, sizeof(BYTE) );
    if (pTask == NULL) {
        goto exit;
    }

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    *pNumTasks = pObj->NumInstances;
    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pObj + pObj->DefinitionLength);
    for (i=0; i<(DWORD)pObj->NumInstances; i++) {
        //
        // pointer to the process name
        //
        p = (PTSTR) ((DWORD_PTR)pInst + pInst->NameOffset);

#ifdef UNICODE
        if (*p) {
            lstrcpyn( pTask->ProcessName, p, _tsizeof(pTask->ProcessName) - 5);
            _tcscat( pTask->ProcessName, _T(".exe") );
        } else {
            //
            // if we cant convert the string then use a bogus value
            //
            _tcscpy( pTask->ProcessName, UNKNOWN_TASK );
        }
#else
        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName) / sizeof(_TCHAR),
                                  NULL,
                                  NULL
                                );

        if (!rc) {
            //
            // if we cant convert the string then use a bogus value
            //
            _tcscpy( pTask->ProcessName, UNKNOWN_TASK );
        }

        if ( (_tcslen(szProcessName)+4) * sizeof(_TCHAR) < sizeof(pTask->ProcessName)) {
            _tcscpy( pTask->ProcessName, szProcessName );
            _tcscat( pTask->ProcessName, _T(".exe") );
        }
#endif

        //
        // get the process id
        //
        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD_PTR)pInst + pInst->ByteLength);
        pTask->dwProcessId = *((LPDWORD) ((DWORD_PTR)pCounter + dwProcessIdCounter));

        //
        // next process
        //
        pTask++;
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        free( buf );
    }

    if (hKeyNames) {
        RegCloseKey( hKeyNames );
    }

    return pTaskReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\pch.cpp ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 1999-2002.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <direct.h>
#include <htmlhelp.h>

#include <dbghelp.h>
#include <dbgeng.h>

#include <dhhelp.h>
#include <cmnutil.hpp>

#pragma warning(3:4101) // Unreferenced local variable.

#include "drwatson.h"
#include "messages.h"
#include "proto.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\ui.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    ui.cpp

Abstract:

    This function implements the ui (dialog) that controls the
    options maintenace for drwatson.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
InitializeDialog(
    HWND hwnd
    );

void
InitializeCrashList(
    HWND hwnd
    );

BOOL
GetDialogValues(
    HWND hwnd
    );

INT_PTR
CALLBACK
LogFileViewerDialogProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
DrWatsonDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

PTSTR
ExpandPath(
    PTSTR lpPath
    );

const
DWORD
DrWatsonHelpIds[] = {
    ID_LOGPATH_TEXT,    IDH_LOG_FILE_PATH,
    ID_LOGPATH,         IDH_LOG_FILE_PATH,
    ID_BROWSE_LOGPATH,  IDH_BROWSE,
    ID_CRASH_DUMP_TEXT, IDH_CRASH_DUMP,
    ID_CRASH_DUMP,      IDH_CRASH_DUMP,
    ID_BROWSE_CRASH,    IDH_BROWSE,
    ID_WAVEFILE_TEXT,   IDH_WAVE_FILE,
    ID_WAVE_FILE,       IDH_WAVE_FILE,
    ID_BROWSE_WAVEFILE, IDH_BROWSE,

    ID_DUMP_TYPE_TEXT,      IDH_CRASH_DUMP_TYPE,
    ID_DUMP_TYPE_FULLMINI,  IDH_CRASH_DUMP_FULL,
    ID_DUMP_TYPE_MINI,      IDH_CRASH_DUMP_MINI,
    ID_DUMP_TYPE_FULL_OLD,  IDH_CRASH_DUMP_NT4FULL,

    ID_INSTRUCTIONS,    IDH_NUMBER_OF_INSTRUCTIONS,
    ID_NUM_CRASHES,     IDH_NUMBER_OF_ERRORS_TO_SAVE,

    ID_DUMPSYMBOLS,     IDH_DUMP_SYMBOL_TABLE,
    ID_DUMPALLTHREADS,  IDH_DUMP_ALL_THREAD_CONTEXTS,
    ID_APPENDTOLOGFILE, IDH_APPEND_TO_EXISTING_LOGFILE,
    ID_VISUAL,          IDH_VISUAL_NOTIFICATION,
    ID_SOUND,           IDH_SOUND_NOTIFICATION,
    ID_CRASH,           IDH_CREATE_CRASH_DUMP_FILE,

    ID_LOGFILE_VIEW,    IDH_VIEW,
    ID_CLEAR,           IDH_CLEAR,
    ID_CRASHES,         IDH_APPLICATION_ERRORS,

    ID_TEST_WAVE,       IDH_WAVE_FILE,
    psh15,              IDH_INDEX,
    0,                  0
};


void
DrWatsonWinMain(
    void
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    HWND           hwnd;
    MSG            msg;
    HINSTANCE      hInst;
    WNDCLASS wndclass;
        

    hInst                   = GetModuleHandle( NULL );
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)DrWatsonDialogProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInst;
    wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = _T("DrWatsonDialog");
    RegisterClass( &wndclass );
    
    hwnd = CreateDialog( hInst,
                         MAKEINTRESOURCE( DRWATSONDIALOG ),
                         0,
                         DrWatsonDialogProc
                       );

    if (hwnd == NULL) {
        return;
    }

    ShowWindow( hwnd, SW_SHOWNORMAL );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (!IsDialogMessage( hwnd, &msg )) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }

    return;
}


INT_PTR
CALLBACK
DrWatsonDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the DRWTSN32.EXE main user interface.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    DWORD       helpId;
    DWORD       ctlId;
    UINT        Checked;
    _TCHAR      szCurrDir[MAX_PATH];
    _TCHAR      szWave[MAX_PATH];
    _TCHAR      szDump[MAX_PATH];
    _TCHAR      szHelpFileName[MAX_PATH];
    PTSTR       p;
    PDWORD      pdw;


    switch (message) {
    case WM_CREATE:
        return 0;

    case WM_INITDIALOG:
        SubclassControls( hwnd );
        InitializeDialog( hwnd );
        return 1;

    case WM_HELP: // F1 key and ?

        ctlId = ((LPHELPINFO)lParam)->iCtrlId;
        helpId = IDH_INDEX;
        for (pdw = (PDWORD)DrWatsonHelpIds; *pdw; pdw+=2) {
            if (*pdw == ctlId) {
                helpId = pdw[1];
                break;
            }
        }
        if ( helpId == IDH_BROWSE ) {
               _tcscpy( szHelpFileName, _T("windows.hlp") );
        }
        else {
            GetWinHelpFileName( szHelpFileName,
                    sizeof(szHelpFileName) / sizeof(_TCHAR) );
        }

        WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle,
                 szHelpFileName,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)DrWatsonHelpIds );
        return TRUE;

    case WM_CONTEXTMENU: // right mouse click
        if( hwnd == (HWND) wParam ) {
            POINT pt;
            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);
            wParam = (WPARAM) ChildWindowFromPoint(hwnd, pt);
        }

        ctlId = GetDlgCtrlID((HWND)wParam);
        helpId = IDH_INDEX;
        for (pdw = (PDWORD)DrWatsonHelpIds; *pdw; pdw+=2) {
            if (*pdw == ctlId) {
                helpId = pdw[1];
                break;
            }
        }
        if ( helpId == IDH_BROWSE ) {
               _tcscpy( szHelpFileName, _T("windows.hlp") );
        }
        else {
            GetWinHelpFileName( szHelpFileName,
                    sizeof(szHelpFileName) / sizeof(_TCHAR) );
        }
        WinHelp((HWND)wParam,
                szHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)DrWatsonHelpIds
               );
        return TRUE;

    case WM_ACTIVATEAPP:
    case WM_SETFOCUS:
        SetFocusToCurrentControl();
        return 0;

    case WM_SYSCOMMAND:
        if (wParam == ID_ABOUT) {
            _TCHAR title[256];
            _TCHAR extra[256];

            LoadRcStringBuf( IDS_ABOUT_TITLE, title, _tsizeof(title) );
            LoadRcStringBuf( IDS_ABOUT_EXTRA, extra, _tsizeof(extra) );

            ShellAbout( hwnd,
                title,
                extra,
                LoadIcon( GetModuleHandle(NULL), MAKEINTRESOURCE(APPICON) )
                );

            return 0;
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (GetDialogValues( hwnd )) {
                HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
                PostQuitMessage( 0 );
            }
            break;

        case IDCANCEL:
            HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
            PostQuitMessage( 0 );
            break;

        case ID_BROWSE_LOGPATH:
            GetDlgItemText( hwnd, ID_LOGPATH, szCurrDir, MAX_PATH );
            p = ExpandPath( szCurrDir );
            if (p) {
                lstrcpyn( szCurrDir, p, _tsizeof(szCurrDir) );
                free( p );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_LOGPATH ), FALSE );
            if (BrowseForDirectory(hwnd, szCurrDir, _tsizeof(szCurrDir) )) {
                SetDlgItemText( hwnd, ID_LOGPATH, szCurrDir );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_LOGPATH ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_LOGPATH) );
            return FALSE;
            break;

        case ID_BROWSE_WAVEFILE:
            szWave[0] = _T('\0');
            GetDlgItemText( hwnd, ID_WAVE_FILE, szWave, MAX_PATH );
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), FALSE );
            if (GetWaveFileName(hwnd, szWave, _tsizeof(szWave) )) {
                SetDlgItemText( hwnd, ID_WAVE_FILE, szWave );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_WAVEFILE) );
            return FALSE;
            break;

        case ID_BROWSE_CRASH:
            szDump[0] = _T('\0');
            GetDlgItemText( hwnd, ID_CRASH_DUMP, szDump, MAX_PATH );
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), FALSE );
            if (GetDumpFileName(hwnd, szDump, _tsizeof(szDump) )) {
                SetDlgItemText( hwnd, ID_CRASH_DUMP, szDump );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_CRASH) );
            return FALSE;
            break;

        case ID_CLEAR:
            ElClearAllEvents();
            InitializeCrashList( hwnd );
            break;

        case ID_TEST_WAVE:
            GetDlgItemText( hwnd, ID_WAVE_FILE, szWave, sizeof(szWave) / sizeof(_TCHAR) );
            PlaySound( szWave, NULL, SND_FILENAME );
            break;

        case ID_LOGFILE_VIEW:
            DialogBoxParam( GetModuleHandle( NULL ),
                MAKEINTRESOURCE( LOGFILEVIEWERDIALOG ),
                hwnd,
                LogFileViewerDialogProc,
                SendMessage((HWND)GetDlgItem(hwnd,ID_CRASHES),
                LB_GETCURSEL,0,0)
                );
            break;

        case IDHELP:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp( hwnd,
                szHelpFileName,
                HH_DISPLAY_TOPIC,
                (DWORD_PTR)(IDHH_INDEX)
                );
            SetFocus( GetDlgItem(hwnd, IDHELP) );
            break;

        default:
            if (((HWND)lParam == GetDlgItem( hwnd, ID_CRASHES )) &&
                (HIWORD( wParam ) == LBN_DBLCLK)) {
                DialogBoxParam( GetModuleHandle( NULL ),
                    MAKEINTRESOURCE( LOGFILEVIEWERDIALOG ),
                    hwnd,
                    LogFileViewerDialogProc,
                    SendMessage((HWND)lParam,LB_GETCURSEL,0,0)
                    );
            }
            if (((HWND)lParam == GetDlgItem( hwnd, ID_CRASH )) &&
                (HIWORD( wParam ) == BN_CLICKED)) {
                Checked = IsDlgButtonChecked( hwnd, ID_CRASH );
                EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), Checked == 1 );
            }
            if (((HWND)lParam == GetDlgItem( hwnd, ID_SOUND )) &&
                (HIWORD( wParam ) == BN_CLICKED)) {
                Checked = IsDlgButtonChecked( hwnd, ID_SOUND );
                EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), Checked == 1 );
            }
            break;
        }
        break;

        case IDH_WAVE_FILE:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp(hwnd,
                     szHelpFileName,
                     HH_DISPLAY_TOPIC,
                     (DWORD_PTR)(IDHH_WAVEFILE)
                     );
            break;
        case IDH_CRASH_DUMP:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp( hwnd,
                      szHelpFileName,
                      HH_DISPLAY_TOPIC,
                      (DWORD_PTR)(IDHH_LOGFILELOCATION)
                      );
            break;


        case WM_DESTROY:
            HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

BOOL
CALLBACK
EnumCrashes(
    PCRASHINFO crashInfo
    )

/*++

Routine Description:

    Enumeration function for crash records.  This function is called
    once for each crash record.  This function places the formatted
    crash data in a listbox.

Arguments:

    crashInfo      - pointer to a CRASHINFO structure

Return Value:

    TRUE           - caller should continue calling the enum procedure
    FALSE          - caller should stop calling the enum procedure

--*/

{
    SIZE size;
    _TCHAR buf[1024];

    _sntprintf( buf, _tsizeof(buf),
                _T("%s  %08x  %s(%08p)"),
                crashInfo->crash.szAppName,
                crashInfo->crash.dwExceptionCode,
                crashInfo->crash.szFunction,
                (PVOID)crashInfo->crash.dwAddress);
    buf[_tsizeof(buf) - 1] = 0;
    SendMessage( crashInfo->hList, LB_ADDSTRING, 0, (LPARAM)buf );


    GetTextExtentPoint( crashInfo->hdc, buf, _tcslen(buf), &size );
    if (size.cx > (LONG)crashInfo->cxExtent) {
        crashInfo->cxExtent = size.cx;
    }

    return TRUE;
}


void
InitializeCrashList(
    HWND hwnd
    )

/*++

Routine Description:

    Initializes the listbox that contains the crash information.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CRASHINFO     crashInfo;
    TEXTMETRIC    tm;
    HFONT         hFont;

    crashInfo.hList = GetDlgItem( hwnd, ID_CRASHES );
    SendMessage( crashInfo.hList, LB_RESETCONTENT, FALSE, 0L );
    SendMessage( crashInfo.hList, WM_SETREDRAW, FALSE, 0L );
    crashInfo.hdc = GetDC( crashInfo.hList );
    crashInfo.cxExtent = 0;

    ElEnumCrashes( &crashInfo, EnumCrashes );

    hFont = (HFONT)SendMessage( crashInfo.hList, WM_GETFONT, 0, 0L );
    if (hFont != NULL) {
        SelectObject( crashInfo.hdc, hFont );
    }
    if (crashInfo.hdc != NULL) {
        GetTextMetrics( crashInfo.hdc, &tm );
        ReleaseDC( crashInfo.hList, crashInfo.hdc );
    }
    SendMessage( crashInfo.hList, LB_SETHORIZONTALEXTENT, crashInfo.cxExtent, 0L );
    SendMessage( crashInfo.hList, WM_SETREDRAW, TRUE, 0L );

    return;
}

void
InitializeDialog(
    HWND hwnd
    )

/*++

Routine Description:

    Initializes the DRWTSN32 user interface dialog with the values
    stored in the registry.

Arguments:

    hwnd       - window handle to the dialog

Return Value:

    None.

--*/

{
    OPTIONS       o;
    _TCHAR        buf[256];
    HMENU         hMenu;


    RegInitialize( &o );
    SetDlgItemText( hwnd, ID_LOGPATH, o.szLogPath );
    SetDlgItemText( hwnd, ID_WAVE_FILE, o.szWaveFile );
    SetDlgItemText( hwnd, ID_CRASH_DUMP, o.szCrashDump );
    _stprintf( buf, _T("%d"), o.dwMaxCrashes );
    SetDlgItemText( hwnd, ID_NUM_CRASHES, buf );
    _stprintf( buf, _T("%d"), o.dwInstructions );
    SetDlgItemText( hwnd, ID_INSTRUCTIONS, buf );
    SendMessage( GetDlgItem( hwnd, ID_DUMPSYMBOLS ), BM_SETCHECK, o.fDumpSymbols, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMPALLTHREADS ), BM_SETCHECK, o.fDumpAllThreads, 0 );
    SendMessage( GetDlgItem( hwnd, ID_APPENDTOLOGFILE ), BM_SETCHECK, o.fAppendToLogFile, 0 );
    SendMessage( GetDlgItem( hwnd, ID_VISUAL ), BM_SETCHECK, o.fVisual, 0 );
    SendMessage( GetDlgItem( hwnd, ID_SOUND ), BM_SETCHECK, o.fSound, 0 );
    SendMessage( GetDlgItem( hwnd, ID_CRASH ), BM_SETCHECK, o.fCrash, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), BM_SETCHECK, o.dwType == FullDump, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), BM_SETCHECK, o.dwType == MiniDump, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), BM_SETCHECK, o.dwType == FullMiniDump, 0 );

    if (waveOutGetNumDevs() == 0) {
        EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), FALSE );
    }
    else {
        EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), o.fSound );
        EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), o.fSound );
        EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), o.fSound );
    }

    EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP_TEXT ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_TEXT ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), o.fCrash );

    InitializeCrashList( hwnd );

    if (SendMessage( GetDlgItem( hwnd, ID_CRASHES ), LB_GETCOUNT, 0 ,0 ) == 0) {
        EnableWindow( GetDlgItem( hwnd, ID_CLEAR ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_LOGFILE_VIEW ), FALSE );
    }

    hMenu = GetSystemMenu( hwnd, FALSE );
    if (hMenu != NULL) {
        AppendMenu( hMenu, MF_SEPARATOR, 0, NULL );
        AppendMenu( hMenu, MF_STRING, ID_ABOUT, LoadRcString( IDS_ABOUT ) );
    }

    return;
}

BOOL
GetDialogValues(
    HWND hwnd
    )

/*++

Routine Description:

    Retrieves the values in the DRWTSN32 dialog controls and saves
    them in the registry.

Arguments:

    hwnd       - window handle to the dialog

Return Value:

    TRUE       - all values were retrieved and saved
    FALSE      - an error occurred

--*/

{
    OPTIONS     o;
    _TCHAR      buf[256];
    DWORD       dwFa;
    PTSTR       p,p1;
    _TCHAR      szDrive    [_MAX_DRIVE];
    _TCHAR      szDir      [_MAX_DIR];
    _TCHAR      szPath     [MAX_PATH];


    RegInitialize( &o );

    GetDlgItemText( hwnd, ID_LOGPATH, buf, sizeof(buf) / sizeof(_TCHAR) );
    p = ExpandPath( buf );
    if (p) {
        dwFa = GetFileAttributes( p );
        free( p );
    } else {
        dwFa = GetFileAttributes( buf );
    }
    if ((dwFa == 0xffffffff) || (!(dwFa&FILE_ATTRIBUTE_DIRECTORY))) {
        NonFatalError( LoadRcString(IDS_INVALID_PATH) );
        return FALSE;
    }
    if (_tcslen(buf) > 0) {
        _tcscpy( o.szLogPath, buf );
    }

    o.fCrash = SendMessage( GetDlgItem( hwnd, ID_CRASH ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;

    GetDlgItemText( hwnd, ID_CRASH_DUMP, buf, sizeof(buf) / sizeof(_TCHAR) );
    if (o.fCrash) {
        p = ExpandPath( buf );
        if (p) {
            dwFa = GetFileAttributes( p );
            free( p );
        } else {
            dwFa = GetFileAttributes( buf );
        }
        if (dwFa == 0xffffffff) {
            //
            // file does not exist, check to see if the dir is ok
            //
            p = ExpandPath( buf );
            if (p) {
                p1 = p;
            } else {
                p1 = buf;
            }
            _tsplitpath( p1, szDrive, szDir, NULL, NULL );
            _tmakepath( szPath, szDrive, szDir, NULL, NULL );
            if (p) {
                free( p );
            }
            dwFa = GetFileAttributes( szPath );
            if (dwFa == 0xffffffff) {
                NonFatalError( LoadRcString(IDS_INVALID_CRASH_PATH) );
                return FALSE;
            }
        } else if (dwFa & FILE_ATTRIBUTE_DIRECTORY) {
            NonFatalError( LoadRcString(IDS_INVALID_CRASH_PATH) );
            return FALSE;
        }
        if (_tcslen(buf) > 0) {
            _tcscpy( o.szCrashDump, buf );
        }
        if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), BM_GETCHECK, 0, 0 )) {
            o.dwType = FullDump;
        } else if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), BM_GETCHECK, 0, 0 )) {
            o.dwType = MiniDump;
        } else if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), BM_GETCHECK, 0, 0 )) {
            o.dwType = FullMiniDump;
        } 
    }

    GetDlgItemText( hwnd, ID_WAVE_FILE, buf, sizeof(buf) / sizeof(_TCHAR) );
    if (_tcslen(buf) > 0) {
        dwFa = GetFileAttributes( buf );
        if ((dwFa == 0xffffffff) || (dwFa&FILE_ATTRIBUTE_DIRECTORY)) {
            NonFatalError( LoadRcString(IDS_INVALID_WAVE) );
            return FALSE;
        }
    }

    _tcscpy( o.szWaveFile, buf );

    GetDlgItemText( hwnd, ID_NUM_CRASHES, buf, sizeof(buf) / sizeof(_TCHAR) );
    o.dwMaxCrashes = (DWORD) _ttol( buf );

    GetDlgItemText( hwnd, ID_INSTRUCTIONS, buf, sizeof(buf) / sizeof(_TCHAR) );
    o.dwInstructions = (DWORD) _ttol( buf );

    o.fDumpSymbols = SendMessage( GetDlgItem( hwnd, ID_DUMPSYMBOLS ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fDumpAllThreads = SendMessage( GetDlgItem( hwnd, ID_DUMPALLTHREADS ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fAppendToLogFile = SendMessage( GetDlgItem( hwnd, ID_APPENDTOLOGFILE ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fVisual = SendMessage( GetDlgItem( hwnd, ID_VISUAL ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fSound = SendMessage( GetDlgItem( hwnd, ID_SOUND ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;

    RegSave( &o );

    return TRUE;
}

BOOL
CALLBACK
EnumCrashesForViewer(
    PCRASHINFO crashInfo
    )

/*++

Routine Description:

    Enumeration function for crash records.  This function is called
    once for each crash record.  This function looks for s specific crash
    that is identified by the crashIndex.

Arguments:

    crashInfo      - pointer to a CRASHINFO structure

Return Value:

    TRUE           - caller should continue calling the enum procedure
    FALSE          - caller should stop calling the enum procedure

--*/

{
    PWSTR p;

    if ((crashInfo->dwIndex == crashInfo->dwIndexDesired) &&
        (crashInfo->dwCrashDataSize > 0) ) {
        p = (PWSTR)crashInfo->pCrashData;
        crashInfo->pCrashData = (PBYTE)
            calloc( crashInfo->dwCrashDataSize+10, sizeof(BYTE) );
        if (crashInfo->pCrashData != NULL) {
            if (IsTextUnicode(p, crashInfo->dwCrashDataSize, NULL)) {
                WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
                                    p, crashInfo->dwCrashDataSize,
                                    (LPSTR)crashInfo->pCrashData, crashInfo->dwCrashDataSize + 10, NULL, NULL);
            } else {
                memcpy( crashInfo->pCrashData, p, crashInfo->dwCrashDataSize+10 );
            }
            crashInfo->pCrashData[crashInfo->dwCrashDataSize] = 0;
        }
        return FALSE;
    }

    crashInfo->dwIndex++;

    return TRUE;
}

INT_PTR
CALLBACK
LogFileViewerDialogProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the log file viewer dialog box.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    static CRASHINFO    crashInfo;
    HFONT               hFont;

    switch (message) {
        case WM_INITDIALOG:
            hFont = (HFONT)GetStockObject( SYSTEM_FIXED_FONT );
            Assert( hFont != NULL );

            SendDlgItemMessage( hwnd,
                                ID_LOGFILE_VIEW,
                                WM_SETFONT,
                                (WPARAM) hFont,
                                (LPARAM) FALSE
                              );

            crashInfo.dwIndex = 0;
            crashInfo.dwIndexDesired = (DWORD)lParam;
            ElEnumCrashes( &crashInfo, EnumCrashesForViewer );
            if (crashInfo.dwIndex != crashInfo.dwIndexDesired) {
                MessageBeep( 0 );
                EndDialog( hwnd, 0 );
                return FALSE;
            }
            SetDlgItemTextA( hwnd, ID_LOGFILE_VIEW,
                             (LPSTR)crashInfo.pCrashData );

            return TRUE;

        case WM_COMMAND:
            if (wParam == IDOK) {
                free( crashInfo.pCrashData );
                EndDialog( hwnd, 0 );
            }
            break;
        case WM_CLOSE:
            free( crashInfo.pCrashData );
            EndDialog( hwnd, 0 );
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\resource.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource file constants.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

// Dr Watson Dialog
#define ID_LOGPATH_TEXT         101
#define ID_LOGPATH              102
#define ID_BROWSE_LOGPATH       103
#define ID_CRASH_DUMP_TEXT      104
#define ID_CRASH_DUMP           105
#define ID_BROWSE_CRASH         106
#define ID_WAVEFILE_TEXT        107
#define ID_WAVE_FILE            108
#define ID_BROWSE_WAVEFILE      109

#define ID_INSTRUCTIONS         110
#define ID_NUM_CRASHES          111

#define ID_DUMPSYMBOLS          112
#define ID_DUMPALLTHREADS       113
#define ID_APPENDTOLOGFILE      114
#define ID_VISUAL               115
#define ID_SOUND                116
#define ID_CRASH                117

#define ID_LOGFILE_VIEW         118
#define ID_CLEAR                119
#define ID_CRASHES              120

// Notify Dialog
#define ID_TEXT1                122
#define ID_TEXT2                123

// Wave File Open Dialog
#define ID_TEST_WAVE            124

// Assert Dialog - dead
#define ID_ASSERT_TEXT          125
#define ID_ASSERT_ICON          126

// Usage Dialog
#define ID_USAGE                127
#define ID_ABOUT                128

#define ID_DUMP_TYPE_TEXT       129          
#define ID_DUMP_TYPE_FULL_OLD   130          
#define ID_DUMP_TYPE_MINI       131          
#define ID_DUMP_TYPE_FULLMINI   132          

#define IDS_APPLICATION_NAME    201
#define IDS_FATAL_ERROR         202
#define IDS_NONFATAL_ERROR      203
#define IDS_ASSERTION_ERROR     204
#define IDS_MEMORY              205
#define IDS_DEBUGPRIV           206
#define IDS_ATTACHFAIL          207
#define IDS_INVALID_PATH        208
#define IDS_INVALID_WAVE        209
#define IDS_CANT_OPEN_LOGFILE   210
#define IDS_INVALID_LOGFILE     211
#define IDS_ABOUT_TITLE         212
#define IDS_ABOUT_EXTRA         213
#define IDS_AE_TEXT             214
#define IDS_LOGBROWSE_TITLE     215
#define IDS_WAVEBROWSE_TITLE    216
#define IDS_WAVE_FILTER         217
#define IDS_UNKNOWN_MACHINE     218
#define IDS_UNKNOWN_USER        219
#define IDS_ABOUT               220
#define IDS_DUMPBROWSE_TITLE    221
#define IDS_DUMP_FILTER         222
#define IDS_INVALID_CRASH_PATH  223
#define IDS_ERROR_FORMAT_STRING 224
#define IDS_APP_ALREADY_EXITED  225
#define IDS_CANT_INIT_ENGINE    226


// Help for Dr. Watson Dialog
#define IDH_BROWSE                      28496
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#define IDH_INDEX                       701
#define IDH_WHAT                        702
#define IDH_OPTIONS                     703
#define IDH_LOG_FILE_PATH               704
#define IDH_WAVE_FILE                   705
#define IDH_NUMBER_OF_INSTRUCTIONS      706
#define IDH_NUMBER_OF_ERRORS_TO_SAVE    707
#define IDH_DUMP_SYMBOL_TABLE           708
#define IDH_DUMP_ALL_THREAD_CONTEXTS    709
#define IDH_APPEND_TO_EXISTING_LOGFILE  710
#define IDH_VISUAL_NOTIFICATION         711
#define IDH_SOUND_NOTIFICATION          712
#define IDH_REGISTRY                    713
#define IDH_EVENTLOG                    714
#define IDH_WINDOWSDIR                  715
#define IDH_PC                          716
#define IDH_LOGFILE                     717
#define IDH_INSTALLATION                718
#define IDH_ASSERT                      719
#define IDH_VIEW                        720
#define IDH_CLEAR                       721
#define IDH_APPLICATION_ERRORS          722 
#define IDH_CREATE_CRASH_DUMP_FILE      723
#define IDH_CRASH_DUMP                  724
#define IDH_CRASH_DUMP_TYPE             725
#define IDH_CRASH_DUMP_FULL             726
#define IDH_CRASH_DUMP_MINI             727
#define IDH_CRASH_DUMP_NT4FULL          728

#define IDHH_INDEX              _T("drwatson_overview.htm")
#define IDHH_WHAT               _T("drwatson_overview.htm")
#define IDHH_LOGFILELOCATION    _T("drwatson_logfile.htm")
#define IDHH_WAVEFILE           _T("drwatson_options.htm")
#define IDHH_ASSERT             _T("drwatson_overview.htm")
#define IDHH_CRASH_DUMP         _T("drwatson_overview.htm")

#define NOTIFYDIALOG            501
#define DRWATSONDIALOG          502
#define DIRBROWSEDIALOG         503
#define WAVEFILEOPENDIALOG      504

#define DRWATSONICON            506
#define LOGFILEVIEWERDIALOG     507
#define DRWATSONACCEL           508
#define APPICON                 509
#define USAGEDIALOG             510
#define DUMPFILEOPENDIALOG      511
#define IDI_ICON1               512


#define DUMPFILEOPENDIALOG2     513
#define WAVEFILEOPENDIALOG2     514


#define stc1                 0x0440
#define stc2                 0x0441
#define stc3                 0x0442
#define stc4                 0x0443
#define edt1                 0x0480
#define lst1                 0x0460
#define lst2                 0x0461
#define cmb1                 0x0470
#define cmb2                 0x0471
#define cmb3                 0x0472
#define psh14                0x040d
#define psh15                0x040e
#define chx1                 0x0410
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\proto.h ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Prototypes for drwatson.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#define _tsizeof(sz) (sizeof(sz) / sizeof(TCHAR))

// error.cpp
void __cdecl NonFatalError(_TCHAR *format, ...);
void __cdecl FatalError(HRESULT Error, _TCHAR *format, ...);
void AssertError( _TCHAR *exp, _TCHAR * file, DWORD line );
void __cdecl dprintf(_TCHAR *format, ...);

// log.cpp
void OpenLogFile( _TCHAR *szFileName, BOOL fAppend, BOOL fVisual );
void CloseLogFile( void );
void __cdecl lprintfs(_TCHAR *format, ...);
void __cdecl lprintf(DWORD dwFormatId, ...);
void MakeLogFileName( _TCHAR *szName );
_TCHAR * GetLogFileData( LPDWORD dwLogFileDataSize );

// debug.cpp
DWORD DispatchDebugEventThread( PDEBUGPACKET dp );
DWORD TerminationThread( PDEBUGPACKET dp );

// registry.cpp
BOOL RegInitialize( POPTIONS o );
BOOL RegSave( POPTIONS o );
DWORD RegGetNumCrashes( void );
void RegSetNumCrashes( DWORD dwNumCrashes );
void RegLogCurrentVersion( void );
BOOLEAN RegInstallDrWatson( BOOL fQuiet );
void RegLogProcessorType( void );
void DeleteCrashDump();

// eventlog.cpp
BOOL ElSaveCrash( PCRASHES crash, DWORD dwNumCrashes );
BOOL ElEnumCrashes( PCRASHINFO crashInfo, CRASHESENUMPROC lpEnumFunc );
BOOL ElClearAllEvents( void );

// process.cpp
void GetTaskName( ULONG pid, _TCHAR *szTaskName, LPDWORD pdwSize );

// browse.cpp
BOOL BrowseForDirectory(HWND hwnd, _TCHAR *szCurrDir, DWORD len );
BOOL GetWaveFileName(HWND hwnd, _TCHAR *szWaveName, DWORD len );
BOOL GetDumpFileName(HWND hwnd, _TCHAR *szDumpName, DWORD len );

// notify.cpp
void NotifyWinMain ( void );
BOOLEAN GetCommandLineArgs( LPDWORD dwPidToDebug, LPHANDLE hEventToSignal );
void __cdecl GetNotifyBuf( LPTSTR buf, DWORD bufsize, DWORD dwFormatId, ...);

// ui.cpp
void DrWatsonWinMain ( void );

// util.cpp
void GetAppName( _TCHAR *pszAppName, DWORD len );
void GetWinHelpFileName( _TCHAR *pszHelpFileName, DWORD len );
void GetHtmlHelpFileName( _TCHAR *pszHelpFileName, DWORD len );
_TCHAR * LoadRcString( UINT wId );
void LoadRcStringBuf( UINT wId, _TCHAR* pszBuf, DWORD len );
PTSTR ExpandPath(PTSTR lpPath);

// controls.cpp
BOOL SubclassControls( HWND hwnd );
void SetFocusToCurrentControl( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dumpchk\dumpchk.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <lmcons.h>
#include <lmalert.h>
#include <ntiodump.h>
#define INITGUID
#include <dbgeng.h>
#include <guiddef.h>

PSTR g_AppName;

//
// Outputcallbacks for dumpcheck
//
class DumpChkOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
DumpChkOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
DumpChkOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if (Text) fputs(Text, stdout);
    return S_OK;
}

DumpChkOutputCallbacks g_OutputCallback;

void
Usage(void)
{
    fprintf(stderr, "Usage: %s [-y <sympath>] <dumpfile>\n", g_AppName);
}


BOOL
CheckDumpHeader(
    IN PTSTR DumpFileName
    )
{
    HANDLE File;
    ULONG Bytes;
    BOOL Succ;
    DUMP_HEADER Header;

    File = CreateFile (DumpFileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (File == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Unable to open dumpfile %s\n", DumpFileName);
        return FALSE;
    }
    

    Succ = ReadFile (File,
                     &Header,
                     sizeof (Header),
                     &Bytes,
                     NULL);

    CloseHandle (File);

    if (Succ &&
        Header.Signature == DUMP_SIGNATURE &&
        Header.ValidDump == DUMP_VALID_DUMP) {
        fprintf(stderr, "Invalid dump header\n");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

HRESULT
DoDumpCheck(
    PTSTR szDumpFile,
    PTSTR szSymbolPath
    )
{
    HRESULT Hr = E_FAIL;
    IDebugClient2 *DebugClient;
    IDebugControl2 *DebugControl;
    IDebugSymbols2 *DebugSymbols;
    IDebugSystemObjects2 *DebugSysObjects;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK) {
        fprintf(stderr, "Cannot initialize DebugClient\n");
        return Hr;
    }

    if ((DebugClient->QueryInterface(__uuidof(IDebugControl2),
                                    (void **)&DebugControl) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSymbols2),
                                    (void **)&DebugSymbols) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSystemObjects2),
                                    (void **)&DebugSysObjects) != S_OK)) {
        fprintf(stderr, "QueryInterface failed for DebugClient\n");
        return Hr;
    }

    DebugClient->SetOutputCallbacks(&g_OutputCallback);
    fprintf(stderr,"Loading dump file %s\n", szDumpFile);
    if ((Hr = DebugClient->OpenDumpFile(szDumpFile)) != S_OK) {
        fprintf(stderr, "**** DebugClient cannot open DumpFile - error %lx\n", Hr);
        if (Hr == HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT)) {
            fprintf(stderr, "DumpFile is corrupt\n");

        }
        return Hr;
    }
    if (szSymbolPath) {
        DebugSymbols->SetSymbolPath(szSymbolPath);
    }

    DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

    DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, ".dumpdebug", DEBUG_EXECUTE_DEFAULT);
    g_OutputCallback.Output(0,"\n\n");
    DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "vertarget", DEBUG_EXECUTE_DEFAULT);
    
    ULONG Class, Qual;
    if ((Hr = DebugControl->GetDebuggeeType(&Class, &Qual)) != S_OK) {
        Class = Qual = 0;
    }
    if (Class == DEBUG_CLASS_USER_WINDOWS) {
        //
        // User Mode dump
        //
        
        DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!peb", DEBUG_EXECUTE_DEFAULT);
    
    } else {
        //
        //  Kernel Mode dump
        //
        ULONG64 NtModBase = 0;

        Hr = DebugSymbols->GetModuleByModuleName("nt", 0, NULL, &NtModBase);

        if (Hr != S_OK || !NtModBase) {
            fprintf(stderr, "***** NT module not found - module list may be corrupt\n");
        } else {
            DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "lmt", DEBUG_EXECUTE_DEFAULT);
        }

        ULONG ThreadId;
        Hr = DebugSysObjects->GetCurrentThreadId(&ThreadId);
        if (Hr != S_OK) {
            fprintf(stderr, "***** Cannot get current thread ID, dump may be corrupt\n");
        }

        DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!analyze", DEBUG_EXECUTE_DEFAULT);
    

    }
    g_OutputCallback.Output(0,"Finished dump check\n");
    
    DebugSysObjects->Release();
    DebugControl->Release();
    DebugSymbols->Release();
    DebugClient->Release();
    return S_OK;
}

void
__cdecl
main (
    int Argc,
    PCHAR *Argv
    )

{
    LONG arg;
    PCHAR DumpFileName = NULL;
    PCHAR SymbolPath = NULL;

    g_AppName = Argv[0];
    
    for (arg = 1; arg < Argc; arg++) {
        if (Argv[arg][0] == '-' || Argv[arg][0] == '/') {
            switch (Argv[arg][1]) {
            case 'y':
            case 'Y':
                if (++arg < Argc) {
                    SymbolPath = Argv[arg];
                }
                break;
            default:
                break;
            }
        } else {
            // Its a dumpfile name
            DumpFileName = Argv[arg];
        }
    }

    if (!DumpFileName) {
        Usage();
        return;
    }
    DoDumpCheck(DumpFileName, SymbolPath);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\util.cpp ===
/*++

Copyright (c) 1993-2002  Microsoft Corporation

Module Name:

    util.cpp

Abstract:
    This file implements common utilitarian functions.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
GetWinHelpFileName(
    _TCHAR *pszHelpFileName,
    DWORD len
    )
{
    _TCHAR           szDrive[_MAX_DRIVE];
    _TCHAR           szDir[_MAX_DIR];

    //
    // find out the path where DrWatson was run from
    //
    GetModuleFileName( GetModuleHandle(NULL), pszHelpFileName, len );

    //
    // take the path and append the help file name
    //
    _tsplitpath( pszHelpFileName, szDrive, szDir, NULL, NULL );
    _sntprintf( pszHelpFileName, MAX_PATH,
                _T("%s%sdrwtsn32.hlp"), szDrive, szDir );
    pszHelpFileName[MAX_PATH - 1] = 0;

    return;
}

void
GetHtmlHelpFileName(
    _TCHAR *pszHelpFileName,
    DWORD len
    )
{
    _TCHAR           szDrive[_MAX_DRIVE];
    _TCHAR           szDir[_MAX_DIR];

    //
    // Make sure the array is at least initialized to zero.
    //

    *pszHelpFileName = 0;

    //
    // find out the path where DrWatson was run from
    //
    GetModuleFileName( GetModuleHandle(NULL), pszHelpFileName, len );

    //
    // take the path and append the help file name
    //
    _tsplitpath( pszHelpFileName, szDrive, szDir, NULL, NULL );
    _sntprintf( pszHelpFileName, MAX_PATH,
                _T("%s%sdrwtsn32.chm"), szDrive, szDir );
    pszHelpFileName[MAX_PATH - 1] = 0;

    return;
}

/***************************************************************************\
* LoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 05-Apr-1991 ScottLu   Fixed - code is now shared between client and server
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/

int
MyLoadStringOrError(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       nLenInChars,        // cch in Unicode buffer
    WORD      wLangId
    )
{
    HRSRC  hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        //RIPMSG0(RIP_WARNING, _T("MyLoadStringOrError: lpBuffer == NULL"));
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    hResInfo = FindResourceExW(hModule,
                               MAKEINTRESOURCEW(6), /* RT_STRING */
                               (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                               wLangId
                               );
    if (hResInfo) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);
        if (hStringSeg == NULL)
        {
            return 0;
        }

        lpsz = (LPWSTR) (hStringSeg);

        /*
         * Move past the other strings in this segment.
         * (16 strings in a segment -> & 0x0F)
         */
        wID &= 0x0F;
        while (TRUE) {
            cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
            if (wID-- == 0) break;
            lpsz += cch;                    // Step to start if next string
        }

        /*
         * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
         */
        if (nLenInChars == 0) {
            *(LPWSTR *)lpBuffer = lpsz;
        } else {

            /*
             * Account for the NULL
             */
            nLenInChars--;

            /*
             * Don't copy more than the max allowed.
             */
            if (cch > nLenInChars) {
                cch = nLenInChars;
            }

            /*
             * Copy the string into the buffer.
             */
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
        }
    }

    /*
     * Append a NULL.
     */
    if (nLenInChars != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}


/***************************************************************************\
* LoadStringA (API)
* LoadStringW (API)
*
*
* 05-Apr-1991 ScottLu   Fixed to work with client/server.
\***************************************************************************/

int
WINAPI
MyLoadString(
    HINSTANCE hmod,
    UINT      wID,
    LPWSTR    lpBuffer,
    int       nLenInChars
    )
{
    return MyLoadStringOrError((HMODULE)hmod,
                               wID,
                               lpBuffer,
                               nLenInChars,
                               0);
}


_TCHAR *
LoadRcString(
    UINT wId
    )

/*++

Routine Description:

    Loads a resource string from DRWTSN32 and returns a pointer
    to the string.

Arguments:

    wId        - resource string id

Return Value:

    pointer to the string

--*/

{
    static _TCHAR buf[1024];

    MyLoadString( GetModuleHandle(NULL), wId, buf, sizeof(buf) / sizeof(_TCHAR) );

    return buf;
}

void
LoadRcStringBuf( UINT wId, _TCHAR* pszBuf, DWORD len )
{
    MyLoadString( GetModuleHandle(NULL), wId, pszBuf, len );
}

void
GetAppName(
    _TCHAR *pszAppName,
    DWORD len
    )
{
    MyLoadString( GetModuleHandle(NULL), IDS_APPLICATION_NAME, pszAppName, len );
}

PTSTR
ExpandPath(
    PTSTR lpPath
    )
/*++
Description
    Expands the path passed. Returns the expanded path in an dynamically
    allocated string. The dynamically allocated string is always at least
    _MAX_PATH is size. Note: size is calculated in characters.

Arguments
    lpPath - Path to be expanded.

Returns
    Dynamically allocated buffer at least _MAX_PATH in length.
--*/
{
    DWORD   len;
    PTSTR   p;


    len = ExpandEnvironmentStrings( lpPath, NULL, 0 );
    if (!len) {
        return NULL;
    }

    len++; // Null terminator
    len = max(len, _MAX_PATH);
    p = (PTSTR) calloc( len, sizeof(_TCHAR) );
    if (!p) {
        return NULL;
    }

    len = ExpandEnvironmentStrings( lpPath, p, len );
    if (!len) {
        free( p );
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\drwatson\registry.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the apis for DRWTSN32 to access the registry.
    All access to the registry are done in this file.  If additional
    registry control is needed then a function should be added in this file
    and exposed to the other files in DRWTSN32.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


//
// string constants for accessing the registry
// there is a string constant here for each key and each value
// that is accessed in the registry.
//
#define DRWATSON_EXE_NAME           _T("drwtsn32.exe")
#define REGKEY_SOFTWARE             _T("software\\microsoft")
#define REGKEY_MESSAGEFILE          _T("EventMessageFile")
#define REGKEY_TYPESSUPP            _T("TypesSupported")
#define REGKEY_SYSTEMROOT           _T("%SystemRoot%\\System32\\")
#define REGKEY_EVENTLOG             _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\")
#define REGKEY_APPNAME              _T("ApplicationName")
#define REGKEY_FUNCTION             _T("FunctionName")
#define REGKEY_EXCEPTIONCODE        _T("ExceptionCode")
#define REGKEY_ADDRESS              _T("Address")
#define REGKEY_LOG_PATH             _T("LogFilePath")
#define REGKEY_DUMPSYMBOLS          _T("DumpSymbols")
#define REGKEY_DUMPALLTHREADS       _T("DumpAllThreads")
#define REGKEY_APPENDTOLOGFILE      _T("AppendToLogFile")
#define REGKEY_INSTRUCTIONS         _T("Instructions")
#define REGKEY_VISUAL               _T("VisualNotification")
#define REGKEY_SOUND                _T("SoundNotification")
#define REGKEY_CRASH_DUMP           _T("CreateCrashDump")
#define REGKEY_CRASH_FILE           _T("CrashDumpFile")
#define REGKEY_CRASH_TYPE           _T("CrashDumpType")
#define REGKEY_WAVE_FILE            _T("WaveFile")
#define REGKEY_NUM_CRASHES          _T("NumberOfCrashes")
#define REGKEY_MAX_CRASHES          _T("MaximumCrashes")
#define REGKEY_CURRENTVERSION       _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define REGKEY_CONTROLWINDOWS       _T("SYSTEM\\CurrentControlSet\\Control\\Windows")
#define REGKEY_CSD_VERSION          _T("CSDVersion")
#define REGKEY_CURRENT_BUILD        _T("CurrentBuildNumber")
#define REGKEY_CURRENT_TYPE         _T("CurrentType")
#define REGKEY_REG_ORGANIZATION     _T("RegisteredOrganization")
#define REGKEY_REG_OWNER            _T("RegisteredOwner")
#define REGKEY_AEDEBUG              _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGKEY_AUTO                 _T("Auto")
#define REGKEY_DEBUGGER             _T("Debugger")
#define REGKEY_PROCESSOR            _T("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0")
#define REGKEY_PROCESSOR_ID         _T("Identifier")


//
// local prototypes
//
void
RegSetDWORD(
    HKEY hkey,
    PTSTR pszSubKey,
    DWORD dwValue
    );

void
RegSetBOOL(
    HKEY hkey,
    PTSTR pszSubKey,
    BOOL dwValue
    );

void
RegSetSZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue
    );

void
RegSetEXPANDSZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue
    );

BOOL
RegQueryBOOL(
    HKEY hkey,
    PTSTR pszSubKey
    );

DWORD
RegQueryDWORD(
    HKEY hkey,
    PTSTR pszSubKey
    );

void
RegQuerySZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue,
    DWORD   dwSizeValue
    );

BOOL
RegSaveAllValues(
    HKEY hKeyDrWatson,
    POPTIONS o
    );

BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY hKeyDrWatson
    );

BOOL
RegInitializeDefaults(
    HKEY hKeyDrWatson
    );

HKEY
RegGetAppKey(
    BOOL ReadOnly
    );

BOOL
RegCreateEventSource(
    void
    );

void
GetDrWatsonLogPath(
    LPTSTR szPath
    );

void
GetDrWatsonCrashDump(
    LPTSTR szPath
    );

BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY hKeyDrWatson
    )

/*++

Routine Description:

    This functions retrieves all registry data for DRWTSN32 and puts
    the data in the OPTIONS structure passed in.

Arguments:

    o              - pointer to an OPTIONS structure

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

Return Value:

    TRUE       - retrieved all data without error
    FALSE      - errors occurred and did not get all data

--*/

{
    RegQuerySZ(hKeyDrWatson, REGKEY_LOG_PATH, o->szLogPath, sizeof(o->szLogPath) );
    RegQuerySZ(hKeyDrWatson, REGKEY_WAVE_FILE, o->szWaveFile, sizeof(o->szWaveFile) );
    RegQuerySZ(hKeyDrWatson, REGKEY_CRASH_FILE, o->szCrashDump, sizeof(o->szCrashDump) );

    o->fDumpSymbols = RegQueryBOOL( hKeyDrWatson, REGKEY_DUMPSYMBOLS );
    o->fDumpAllThreads = RegQueryBOOL( hKeyDrWatson, REGKEY_DUMPALLTHREADS );
    o->fAppendToLogFile = RegQueryBOOL( hKeyDrWatson, REGKEY_APPENDTOLOGFILE );
    o->fVisual = RegQueryBOOL( hKeyDrWatson, REGKEY_VISUAL );
    o->fSound = RegQueryBOOL( hKeyDrWatson, REGKEY_SOUND );
    o->fCrash = RegQueryBOOL( hKeyDrWatson, REGKEY_CRASH_DUMP );
    o->dwInstructions = RegQueryDWORD( hKeyDrWatson, REGKEY_INSTRUCTIONS );
    o->dwMaxCrashes = RegQueryDWORD( hKeyDrWatson, REGKEY_MAX_CRASHES );
    o->dwType = (CrashDumpType)RegQueryDWORD(hKeyDrWatson, REGKEY_CRASH_TYPE);

    return TRUE;
}

BOOL
RegSaveAllValues(
    HKEY hKeyDrWatson,
    POPTIONS o
    )

/*++

Routine Description:

    This functions saves all registry data for DRWTSN32 that is passed
    in via the OPTIONS structure.

Arguments:

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    RegSetSZ( hKeyDrWatson, REGKEY_LOG_PATH, o->szLogPath );
    RegSetSZ( hKeyDrWatson, REGKEY_WAVE_FILE, o->szWaveFile );
    RegSetSZ( hKeyDrWatson, REGKEY_CRASH_FILE, o->szCrashDump );
    RegSetBOOL( hKeyDrWatson, REGKEY_DUMPSYMBOLS, o->fDumpSymbols );
    RegSetBOOL( hKeyDrWatson, REGKEY_DUMPALLTHREADS, o->fDumpAllThreads );
    RegSetBOOL( hKeyDrWatson, REGKEY_APPENDTOLOGFILE, o->fAppendToLogFile );
    RegSetBOOL( hKeyDrWatson, REGKEY_VISUAL, o->fVisual );
    RegSetBOOL( hKeyDrWatson, REGKEY_SOUND, o->fSound );
    RegSetBOOL( hKeyDrWatson, REGKEY_CRASH_DUMP, o->fCrash );
    RegSetDWORD( hKeyDrWatson, REGKEY_INSTRUCTIONS, o->dwInstructions );
    RegSetDWORD( hKeyDrWatson, REGKEY_MAX_CRASHES, o->dwMaxCrashes );
    RegSetDWORD( hKeyDrWatson, REGKEY_CRASH_TYPE, o->dwType);

    return TRUE;
}

BOOL
RegInitializeDefaults(
    HKEY hKeyDrWatson
    )

/*++

Routine Description:

    This functions initializes the registry with the default values.

Arguments:

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    OPTIONS o;

    GetDrWatsonLogPath(o.szLogPath);
    GetDrWatsonCrashDump(o.szCrashDump);
    o.szWaveFile[0] = _T('\0');
    o.fDumpSymbols = FALSE;
    o.fDumpAllThreads = TRUE;
    o.fAppendToLogFile = TRUE;
    o.fVisual = FALSE;
    o.fSound = FALSE;
    o.fCrash = TRUE;
    o.dwInstructions = 10;
    o.dwMaxCrashes = 10;
    o.dwType = MiniDump;

    RegSetNumCrashes( 0 );

    RegSaveAllValues( hKeyDrWatson, &o );

    RegCreateEventSource();

    return TRUE;
}

BOOL
RegCreateEventSource(
    void
    )

/*++

Routine Description:

    This function creates an event source in the registry.  The event
    source is used by the event viewer to display the data in a
    presentable manner.

Arguments:

    None.

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    HKEY        hk;
    _TCHAR      szBuf[1024];
    DWORD       dwDisp;
    _TCHAR      szAppName[MAX_PATH];

    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    _tcscpy( szBuf, REGKEY_EVENTLOG );
    _tcscat( szBuf, szAppName );
    if (RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                        szBuf,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        NULL,
                        &hk,
                        &dwDisp
                      )) {
        return FALSE;
    }

    if (dwDisp == REG_OPENED_EXISTING_KEY) {
        RegCloseKey(hk);
        return TRUE;
    }

    _tcscpy( szBuf, REGKEY_SYSTEMROOT );
    _tcscat( szBuf, DRWATSON_EXE_NAME );
    RegSetEXPANDSZ( hk, REGKEY_MESSAGEFILE, szBuf );
    RegSetDWORD( hk, REGKEY_TYPESSUPP, EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE );

    RegCloseKey(hk);

    return TRUE;
}

HKEY
RegGetAppKey(
    BOOL ReadOnly
    )

/*++

Routine Description:

    This function gets a handle to the DRWTSN32 registry key.

Arguments:

    ReadOnly - Caller needs this foe reading purposes only
               Although, we could need to create it if its not present

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD       rc;
    DWORD       dwDisp;
    HKEY        hKeyDrWatson;
    HKEY        hKeyMicrosoft;
    _TCHAR      szAppName[MAX_PATH];

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_SOFTWARE,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeyMicrosoft
                     );

    if (rc != ERROR_SUCCESS) {
        if (ReadOnly) {
            // Try oepning it for read only
            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               REGKEY_SOFTWARE,
                               0,
                               KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                               &hKeyMicrosoft
                             );
        }
        if (rc != ERROR_SUCCESS) {
            return NULL;
        }
    }

    szAppName[0] = 0;
    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );

    rc = RegCreateKeyEx( hKeyMicrosoft,
                         szAppName,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE,
                         NULL,
                         &hKeyDrWatson,
                         &dwDisp
                       );

    if (rc != ERROR_SUCCESS) {
        if (ReadOnly) {
            // Try oepning it for read only
            rc = RegCreateKeyEx( hKeyMicrosoft,
                                 szAppName,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ,
                                 NULL,
                                 &hKeyDrWatson,
                                 &dwDisp
                               );
        }
        if (rc != ERROR_SUCCESS) {
            RegCloseKey(hKeyMicrosoft);
            return NULL;
        }
    }

    if (dwDisp == REG_CREATED_NEW_KEY) {
        RegInitializeDefaults( hKeyDrWatson );
    }


    RegCloseKey(hKeyMicrosoft);
    return hKeyDrWatson;
}

BOOL
RegInitialize(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to initialize the OPTIONS structure passed in
    with the current values in the registry.  Note that if the registry
    is empty then the defaults are stored in the registry and also
    returned in the OPTIONS structure.

Arguments:

    o - Returns an OPTIONS struct with initial values

Return Value:

    TRUE           - all data was retrieved ok
    NULL           - could not get all data

--*/

{
    HKEY    hKeyDrWatson;
    BOOL    Succ = FALSE;

    ZeroMemory(o, sizeof(*o));

    hKeyDrWatson = RegGetAppKey( TRUE );
    if ( hKeyDrWatson != NULL ) {
        Succ = RegGetAllValues( o, hKeyDrWatson );
        RegCloseKey( hKeyDrWatson );
    }

    return Succ;
}

BOOL
RegSave(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to save the data in the OPTIONS structure
    to the registry.

Arguments:

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE           - all data was saved ok
    NULL           - could not save all data

--*/

{
    HKEY    hKeyDrWatson;

    hKeyDrWatson = RegGetAppKey( FALSE );
    if (hKeyDrWatson)
    {
        RegSaveAllValues( hKeyDrWatson, o );
        RegCloseKey( hKeyDrWatson );
        return TRUE;
    }

    return FALSE;
}

void
RegSetNumCrashes(
    DWORD dwNumCrashes
    )

/*++

Routine Description:

    This function changes the value in the registry that contains the
    number of crashes that have occurred.

Arguments:

    dwNumCrashes   - the number of craches to save

Return Value:

    None.

--*/

{
    HKEY    hKeyDrWatson;

    hKeyDrWatson = RegGetAppKey( FALSE );
    if (hKeyDrWatson)
    {
        RegSetDWORD( hKeyDrWatson, REGKEY_NUM_CRASHES, dwNumCrashes );
        RegCloseKey( hKeyDrWatson );
    }

    return;
}

DWORD
RegGetNumCrashes(
    void
    )

/*++

Routine Description:

    This function get the value in the registry that contains the
    number of crashes that have occurred.

Arguments:

    None.

Return Value:

    the number of craches that have occurred

--*/

{
    HKEY    hKeyDrWatson;
    DWORD   dwNumCrashes=0;

    hKeyDrWatson = RegGetAppKey( TRUE );
    if ( hKeyDrWatson != NULL ) {
        dwNumCrashes = RegQueryDWORD( hKeyDrWatson, REGKEY_NUM_CRASHES );
        RegCloseKey( hKeyDrWatson );
    }

    return dwNumCrashes;
}

BOOLEAN
RegInstallDrWatson(
    BOOL fQuiet
    )

/*++

Routine Description:

    This function sets the AEDebug registry values to automatically
    invoke drwtsn32 when a crash occurs.

Arguments:

    None.

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD     rc;
    HKEY      hKeyMicrosoft;
    OPTIONS   o;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_AEDEBUG,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &hKeyMicrosoft
                     );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    RegSetSZ( hKeyMicrosoft, REGKEY_AUTO, _T("1") );
    RegSetSZ( hKeyMicrosoft, REGKEY_DEBUGGER, _T("drwtsn32 -p %ld -e %ld -g") );

    RegCloseKey( hKeyMicrosoft );

    RegInitialize( &o );
    if (fQuiet) {
        o.fVisual = FALSE;
        o.fSound = FALSE;
        RegSave( &o );
    }

    return TRUE;
}

void
RegSetDWORD(
    HKEY hkey,
    PTSTR pszSubKey,
    DWORD dwValue
    )

/*++

Routine Description:

    This function changes a DWORD value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    pszSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue) );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetBOOL(
    HKEY hkey,
    PTSTR pszSubKey,
    BOOL dwValue
    )

/*++

Routine Description:

    This function changes a BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    dwValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetSZ(
    HKEY hkey,
    PTSTR pszSubKey,
    PTSTR pszValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    pszValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;
    TCHAR szPath[_MAX_PATH];

    // If Dr Watson registry key for log path or crash file are
    // the defaults, don't write them to the registry.
    // The defaults for these are obtained by querying.

    if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH ) == 0 ) {
        GetDrWatsonLogPath( szPath );
        if (_tcscmp(szPath,pszValue) == 0 ) return;

    } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0 ) {
    RegQuerySZ(hkey, pszSubKey, szPath, _MAX_PATH * sizeof(_TCHAR));
        if ( _tcscmp(szPath, pszValue) == 0 ) return;
    }
    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_SZ, (PBYTE) pszValue, (_tcslen(pszValue) +1) * sizeof(_TCHAR) );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetEXPANDSZ(
    HKEY hkey,
    PTSTR pszSubKey,
    PTSTR pszValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    pszValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_EXPAND_SZ, (PBYTE) pszValue, (_tcslen(pszValue)+1) * sizeof(TCHAR) );
    Assert( rc == ERROR_SUCCESS );
}

BOOL
RegQueryBOOL(
    HKEY hkey,
    PTSTR pszSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a FALSE value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    TRUE or FALSE.

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    BOOL    fValue = FALSE;

    len = 4;
    rc = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = FALSE;
            RegSetBOOL( hkey, pszSubKey, fValue );
        }
        else {
            Assert( rc == ERROR_SUCCESS );
        }
    }
    else {
        Assert( dwType == REG_DWORD );
    }

    return fValue;
}

DWORD
RegQueryDWORD(
    HKEY hkey,
    PTSTR pszSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    DWORD   fValue = 0;

    len = 4;
    rc = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = 0;
            RegSetDWORD( hkey, pszSubKey, fValue );
        }
        else {
            Assert( rc == ERROR_SUCCESS );
        }
    }
    else {
        Assert( dwType == REG_DWORD );
    }

    return fValue;
}

void
RegQuerySZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue,
    DWORD   dwSizeValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    LONG    lRes;
    DWORD   dwType;

    lRes = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (PBYTE) pszValue, &dwSizeValue );

    if (lRes == ERROR_FILE_NOT_FOUND) {

        // If these two SubKeys already exist in the registry, then use the registry values.
        // If they don't exist, query for the value.
        if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH) == 0 ) {
            GetDrWatsonLogPath( pszValue );
        } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0 ) {
            GetDrWatsonCrashDump( pszValue );
        }
    } else {
        Assert( lRes == ERROR_SUCCESS );
        Assert( dwType == REG_SZ || dwType == REG_EXPAND_SZ );

        // If the old defaults for Beta 3 or NT4 log path and crash file
        // exist, then delete them and use the new and improved values

        if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH) == 0  &&
            (_tcsicmp( pszValue, _T("%userprofile%")) == 0  ||
             _tcsicmp( pszValue, _T("%windir%")) == 0 ) ) {

            // Delete the key
            lRes = RegDeleteValue( hkey, pszSubKey);
            Assert ( lRes == ERROR_SUCCESS);
            GetDrWatsonLogPath( pszValue );

        } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0  &&
                    _tcsicmp( pszValue, _T("%windir%\\user.dmp")) == 0 ) {
            // Delete the key
            lRes = RegDeleteValue( hkey, pszSubKey);
            Assert( lRes == ERROR_SUCCESS);
            GetDrWatsonCrashDump( pszValue );
        }
    }
}

void
RegLogCurrentVersion(
    void
    )

/*++

Routine Description:

    This function writes system and user info. to the log file

Arguments:

    None

Return Value:

    registry value

History:

    8/21/97 a-paulbr fixed bug 658

--*/

{
    _TCHAR  buf[1024];
    DWORD   rc;
    HKEY    hKeyCurrentVersion = NULL;
    HKEY    hKeyControlWindows = NULL;
    DWORD   dwSPNum = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_CURRENTVERSION,
                       0,
                       KEY_QUERY_VALUE,
                       &hKeyCurrentVersion
                     );

    if (rc != ERROR_SUCCESS) {
        return;
    }
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_CONTROLWINDOWS,
                       0,
                       KEY_QUERY_VALUE,
                       &hKeyControlWindows);
    if (hKeyControlWindows) {
        //
        // I'm using RegQueryValueEx() because there is an assertion in
        // RegQueryDWORD() if the key does not exist.
        //
        RegQueryValueEx(hKeyControlWindows,
                        REGKEY_CSD_VERSION,
                        NULL,
                        &dwType,
                        (BYTE*)&dwSPNum,
                        &dwSize
                        );
    }

    RegQuerySZ(hKeyCurrentVersion, REGKEY_CURRENT_BUILD, buf, sizeof(buf) );
    lprintf( MSG_CURRENT_BUILD, buf );

    if ((hKeyControlWindows) &&
        (dwType == REG_DWORD) &&
        (HIBYTE(LOWORD(dwSPNum)) != 0)) {
        _stprintf(buf, _T("%hu"), HIBYTE(LOWORD(dwSPNum)));
        lprintf( MSG_CSD_VERSION, buf );
    } else {
        _stprintf(buf, _T("None"));
        lprintf( MSG_CSD_VERSION, buf );
    }

    RegQuerySZ( hKeyCurrentVersion,REGKEY_CURRENT_TYPE, buf, sizeof(buf) );
    lprintf( MSG_CURRENT_TYPE, buf );
    RegQuerySZ( hKeyCurrentVersion,REGKEY_REG_ORGANIZATION, buf, sizeof(buf) );
    lprintf( MSG_REG_ORGANIZATION, buf );
    RegQuerySZ( hKeyCurrentVersion,REGKEY_REG_OWNER, buf, sizeof(buf) );
    lprintf( MSG_REG_OWNER, buf );

    //
    // Close the keys that we opened
    //
    RegCloseKey(hKeyCurrentVersion);
    RegCloseKey(hKeyControlWindows);

    return;
}

void
RegLogProcessorType(
    void
    )
{
    _TCHAR  buf[1024];
    DWORD   rc;
    HKEY    hKey;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_PROCESSOR,
                       0,
                       KEY_QUERY_VALUE,
                       &hKey
                     );

    if (rc != ERROR_SUCCESS) {
        return;
    }

    RegQuerySZ( hKey, REGKEY_PROCESSOR_ID, buf, sizeof(buf) );
    lprintf( MSG_SYSINFO_PROC_TYPE, buf );

    return;
}


void
GetDrWatsonLogPath(
    LPTSTR szPath
    )
{
    int rc;
    HRESULT Hr;

    Hr = SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE,
                         NULL, 0, szPath);
    if (Hr != S_OK) {
        ExitProcess(1);
    }
    if (_tcslen(szPath) > MAX_PATH - 32) {
        ExitProcess(1);
    }
    _tcscat(szPath,_T("\\Microsoft\\Dr Watson") );

    if ( !CreateDirectory(szPath, NULL) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
            rc = GetLastError();
         }
    }
}

void
GetDrWatsonCrashDump(
    LPTSTR szPath
    )
{
    int rc;
    HRESULT Hr;

    Hr = SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE,
                         NULL, 0, szPath);
    if (Hr != S_OK) {
        ExitProcess(1);
    }
    if (_tcslen(szPath) > MAX_PATH - 40) {
        ExitProcess(1);
    }
    _tcscat(szPath,_T("\\Microsoft\\Dr Watson") );

    if ( !CreateDirectory(szPath, NULL) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
            rc = GetLastError();
        }
    }
    _tcscat(szPath, _T("\\user.dmp") );

    return;
}

void
DeleteCrashDump()
{
    HKEY hKeyDrWatson;
    TCHAR szCrashDump[MAX_PATH];

    hKeyDrWatson = RegGetAppKey( TRUE );

    if (hKeyDrWatson) {
        RegQuerySZ(hKeyDrWatson, REGKEY_CRASH_FILE, szCrashDump, sizeof(szCrashDump) );

        DeleteFile(szCrashDump);
        RegCloseKey( hKeyDrWatson );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dumpexam\dumpexam.c ===
#include <windows.h>
#include <stdio.h>

void
__cdecl
main (
    int Argc,
    PUCHAR *Argv
    )

{

    fprintf(stderr, "\n\n\n\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   This tool is no longer supported.  It's functionality has been      **\n");
    fprintf(stderr, "**   merged into the kernel debugger.  You can examine a dump file by    **\n");
    fprintf(stderr, "**   loading it in the kernel debugger                                   **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   kd -z <dump_file_name> -y <symbol_path> [-i <image_path>]           **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   and running commands such as !vm, !process, !locks, etc...          **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   Please refer to the debugger documentation for more information     **\n");
    fprintf(stderr, "**   on analyzing system failures.                                       **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "\n\n\n\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\dumpconv\exe\dumpconv.cpp ===
//-----------------------------------------------------------------------
// @doc
//
// @module convert crash dump to triage dump for crash dump utilities
//
// Copyright 1999 Microsoft Corporation.  All Rights Reserved
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgeng.h>

BOOL
DoConversion(
    LPSTR szInputDumpFile,          // full or kernel dump
    HANDLE OutputDumpFile        // triage dump file
    );

void Usage()
{
    fprintf(stderr, "dmpconv -i input_dump_file -o output_dump_file\n");
    fprintf(stderr, "\tinput dump file is full or kernel crash dump.\n");
    fprintf(stderr, "\toutput is triage crash dump.\n");
}

int
WINAPIV
main(
    int argc,
    PTSTR argv[ ],
    PTSTR envp[]
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    char *szInputDumpFile = NULL;
    char *szOutputTriageDumpFile = NULL;
    int iarg;

    for(iarg = 1; iarg < argc; iarg++)
    {
        if (argv[iarg][0] == '/' ||
            argv[iarg][0] == '-')
        {
            if (_tcslen(argv[iarg]) < 2)
            {
                Usage();
                exit(-1);
            }

            switch(argv[iarg][1])
            {
                default:
                    Usage();
                    exit(-1);

                case 'i':
                case 'I':
                    szInputDumpFile = argv[++iarg];
                    break;

                case 'o':
                case 'O':
                    szOutputTriageDumpFile = argv[++iarg];
                    break;
            }
        }
        else
        {
            Usage();
            exit(-1);
        }
    }

    if (szInputDumpFile == NULL ||
        szOutputTriageDumpFile == NULL)
    {
        Usage();
        exit(-1);
    }


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if (DebugClient->QueryInterface(__uuidof(IDebugControl),
                                    (void **)&DebugControl) == S_OK)
    {
        if (DebugClient->OpenDumpFile(szInputDumpFile) == S_OK)
        {
            // Optional.  Conversion does not require symbols
            //if (DebugSymbols->SetSymbolPath("C:\\") == S_OK)

            DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

            if (DebugClient->WriteDumpFile(szOutputTriageDumpFile,
                                           DEBUG_DUMP_SMALL) == S_OK)
            {
                Hr = S_OK;
            }
        }

        DebugControl->Release();
    }

    DebugClient->Release();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\assign\mapistuff.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    assign.cpp

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Andre Vachon (andreva)
    
    bugcheck analyzer.

--*/


#include <tchar.h>
#include <malloc.h>
#include <mapi.h>	

#ifdef __cplusplus
extern "C" {
#endif

BOOL SendOffFailure(TCHAR *pszToList, TCHAR *pszTitle, TCHAR *pszMessage);
DWORD CountRecips(PTCHAR pszToList);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\assign\mapistuff.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    assign.cpp

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Andre Vachon (andreva)
    
    bugcheck analyzer.

--*/

#include "precomp.h"
#include "mapistuff.h"

ULONG (FAR PASCAL *lpfnMAPILogon)(ULONG_PTR, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE);
ULONG (PASCAL *lpfnMAPISendMail)(LHANDLE, ULONG_PTR, MapiMessage*, FLAGS, ULONG);
ULONG (PASCAL *lpfnMAPIResolveName)(LHANDLE, ULONG_PTR, LPTSTR, FLAGS, ULONG, MapiRecipDesc **);
ULONG (FAR PASCAL *lpfnMAPILogoff)(LHANDLE, ULONG_PTR, FLAGS, ULONG);
ULONG (FAR PASCAL *lpfnMAPIFreeBuffer)(LPVOID);
HINSTANCE hInstMapi = NULL;

BOOL SendOffFailure(
    TCHAR *pszToList,
    TCHAR *pszTitle,
    TCHAR *pszMessage)
{
    LHANDLE lhSession;
    ULONG lResult = 0;
    MapiMessage mmmessage;
    lpMapiRecipDesc rdList = NULL;
    DWORD i = 0;

    memset(&mmmessage, 0, sizeof(mmmessage));

    hInstMapi = LoadLibrary("Mapi32.dll");
    if(hInstMapi == NULL)
    {
        dprintf("Unable to Load MAPI32.dll!!!\n");
        return FALSE;
    }

    //
    // Find the addresses of functions
    //

    (FARPROC)lpfnMAPILogon = GetProcAddress(hInstMapi, "MAPILogon");
    (FARPROC)lpfnMAPILogoff = GetProcAddress(hInstMapi, "MAPILogoff");
    (FARPROC)lpfnMAPIFreeBuffer = GetProcAddress(hInstMapi, "MAPIFreeBuffer");
    (FARPROC)lpfnMAPIResolveName = GetProcAddress(hInstMapi, "MAPIResolveName");
    (FARPROC)lpfnMAPISendMail = GetProcAddress(hInstMapi, "MAPISendMail");

    if ((lpfnMAPILogon == NULL)         ||
        (lpfnMAPILogoff == NULL)        ||
        (lpfnMAPIFreeBuffer == NULL)    ||
        (lpfnMAPIResolveName == NULL)   ||
        (lpfnMAPISendMail == NULL))
    {
        dprintf("Unable to Load MAPI32 entry points!!!\n");
        FreeLibrary(hInstMapi);
        return FALSE;
    }

    // Log on to existing session
    lResult = lpfnMAPILogon(0, NULL, NULL, 0, 0, &lhSession);
    if (lResult != SUCCESS_SUCCESS)
    {
        // We need outlook up and running to send mail
        // Maybe I write the code to do the connect when I get some time
        dprintf("Unable to Logon to an existing MAPI session.  Make sure you have Outlook started!!!\n");
    }
    else
    {
        mmmessage.ulReserved = 0;
        mmmessage.lpszMessageType = NULL;
        mmmessage.lpszSubject = pszTitle;
        mmmessage.lpszNoteText = pszMessage;
        mmmessage.lpRecips = NULL;
        mmmessage.flFlags = MAPI_SENT;
        mmmessage.lpOriginator = NULL;
        mmmessage.nFileCount = 0;
        mmmessage.nRecipCount = CountRecips(pszToList);

        if (mmmessage.nRecipCount == 0)
        {
            dprintf("No receipients in string %s\n", pszToList);
        }
        else
        {
            TCHAR *token = NULL;
            DWORD index = 0;

            rdList = (lpMapiRecipDesc) calloc(mmmessage.nRecipCount, sizeof (MapiRecipDesc));
            if (rdList)
            {
                token = _tcstok(pszToList, _T(";"));
                while( token != NULL )
                {
                    lResult = lpfnMAPIResolveName(lhSession,
                                                  0,
                                                  token,
                                                  0,
                                                  0,
                                                  &mmmessage.lpRecips);
                    if (lResult != SUCCESS_SUCCESS)
                    {
                        dprintf("Unable to resolve %s properly! Failing Send\n", token);
                        break;
                    }
                    else
                    {
                        if (mmmessage.lpRecips->lpEntryID)
                        {
                            rdList[index].lpEntryID = malloc(mmmessage.lpRecips->ulEIDSize);
                        }
                        if (mmmessage.lpRecips->lpszAddress)
                        {
                            rdList[index].lpszAddress = _tcsdup(mmmessage.lpRecips->lpszAddress);
                        }
                        if (mmmessage.lpRecips->lpszName)
                        {
                            rdList[index].lpszName = _tcsdup(mmmessage.lpRecips->lpszName);
                        }

                        memcpy(rdList[index].lpEntryID, mmmessage.lpRecips->lpEntryID, mmmessage.lpRecips->ulEIDSize);
                        rdList[index].ulEIDSize = mmmessage.lpRecips->ulEIDSize;
                        rdList[index].ulRecipClass = MAPI_TO;
                        rdList[index].ulReserved = mmmessage.lpRecips->ulReserved;
                        lpfnMAPIFreeBuffer(mmmessage.lpRecips);
                    }

                    index++;
                    token = _tcstok(NULL, _T(";"));
                }

                if (token == NULL)
                {
                    // Send the message
                    mmmessage.lpRecips = rdList;
                    lResult = lpfnMAPISendMail(lhSession, 0, &mmmessage, 0, 0);
                }

                // free up allocated memory.
                for (i = 0; i < mmmessage.nRecipCount; i++)
                {
                    if (rdList[i].lpEntryID)
                            free(rdList[i].lpEntryID);
                    if (rdList[i].lpszAddress)
                            free(rdList[i].lpszAddress);
                    if (rdList[i].lpszName)
                            free(rdList[i].lpszName);
                }

                free(rdList);
            }
        }

        lpfnMAPILogoff(lhSession, 0, 0, 0);
        lpfnMAPILogoff(0, lhSession, 0, 0);
    }

    FreeLibrary(hInstMapi);

    if (lResult != SUCCESS_SUCCESS)
    {
        dprintf("SendMail to %s failed\n", pszToList);
        return FALSE;
    }
    else
    {
        dprintf("SendMail to %s succeeded\n", pszToList);
        return TRUE;
    }
}

DWORD CountRecips(PTCHAR pszToList)
{
    DWORD i = 0;
    PTCHAR ptr = pszToList;

    if ((!ptr)||(ptr[0] == TEXT('\0')))
    {
        return 0;
    }

    ptr = pszToList + _tcslen(pszToList) - 1;
    // rear trim
    while ((ptr >= pszToList) &&
           ((ptr[0] == TEXT(';'))  ||
            (ptr[0] == TEXT(' '))  ||
            (ptr[0] == TEXT('/r')) ||
            (ptr[0] == TEXT('/n')) ||
            (ptr[0] == TEXT('/t')) ||
            (ptr[0] == TEXT(':'))))
    {
        ptr[0] = TEXT('\0');
        ptr--;
    }

    ptr = pszToList;
    // front trim
    while ((ptr[0] == TEXT(';'))  ||
           (ptr[0] == TEXT(' '))  ||
           (ptr[0] == TEXT('/r')) ||
           (ptr[0] == TEXT('/n')) ||
           (ptr[0] == TEXT('/t')) ||
           (ptr[0] == TEXT(':')))
    {
        _tcscpy(ptr, ptr + 1);
    }

    // remove spaces
    while (ptr = _tcschr(pszToList, TEXT(' ')))
    {
        _tcscpy(ptr, ptr + 1);
    }

    ptr = pszToList;
    while (ptr = _tcschr(ptr, TEXT(';')))
    {
        i++;
        ptr++;
    }

    if (!_tcslen(pszToList))
    {
        return 0;
    }

    return i + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exdi\dbgeng_exdi_io.h ===
//----------------------------------------------------------------------------
//
// Debug engine Ioctls for extending EXDI.
// Covers:
//   Read/write MSRs.
//   Multiprocessor description and control.
//   Determination of what breakpoint was hit for hrBp.
//
//----------------------------------------------------------------------------

#ifndef __DBGENG_EXDI_IO_H__
#define __DBGENG_EXDI_IO_H__

//
// Specific Ioctl operations.
// All Ioctl structures must have the Ioctl code as the first member.
//

typedef enum
{
    // Marker for the beginning of the enum.  Start at
    // a value other than zero to prevent obvious collisions
    // with other Ioctl codes.
    DBGENG_EXDI_IOC_BEFORE_FIRST = 0x8664,
    
    DBGENG_EXDI_IOC_IDENTIFY,
    DBGENG_EXDI_IOC_READ_MSR,
    DBGENG_EXDI_IOC_WRITE_MSR,
    DBGENG_EXDI_IOC_IDENTIFY_PROCESSORS,
    DBGENG_EXDI_IOC_GET_CURRENT_PROCESSOR,
    DBGENG_EXDI_IOC_SET_CURRENT_PROCESSOR,
    DBGENG_EXDI_IOC_GET_BREAKPOINT_HIT,

    // Marker for the end of the enum.
    DBGENG_EXDI_IOC_AFTER_LAST
} DBGENG_EXDI_IOCTL_CODE;

//
// Basic Ioctl containing only a code for the Ioctl input.
//

typedef struct _DBGENG_EXDI_IOCTL_BASE_IN
{
    DBGENG_EXDI_IOCTL_CODE Code;
} DBGENG_EXDI_IOCTL_BASE_IN;

//
// IDENTIFY - Verify and describe Ioctl support.
//

#define DBGENG_EXDI_IOCTL_IDENTIFY_SIGNATURE '468E'

typedef struct _DBGENG_EXDI_IOCTL_IDENTIFY_OUT
{
    ULONG Signature;
    DBGENG_EXDI_IOCTL_CODE BeforeFirst;
    DBGENG_EXDI_IOCTL_CODE AfterLast;
} DBGENG_EXDI_IOCTL_IDENTIFY_OUT;

//
// {READ|WRITE}_MSR - Access processor MSRs.
//

// Input structure is used for both read and write.
typedef struct _DBGENG_EXDI_IOCTL_MSR_IN
{
    DBGENG_EXDI_IOCTL_CODE Code;
    ULONG Index;
    // Value is only used for write.
    ULONG64 Value;
} DBGENG_EXDI_IOCTL_MSR_IN;

typedef struct _DBGENG_EXDI_IOCTL_READ_MSR_OUT
{
    ULONG64 Value;
} DBGENG_EXDI_IOCTL_READ_MSR_OUT;

//
// Multiprocessor support.  Basic EXDI doesn't support
// multiprocessor machines so add Ioctls to query and
// control a "current" processor that the EXDI methods
// apply to.
//

//
// IDENTIFY_PROCESSORS - Used to query the processor configuration.
// Currently only the count is used.  Other fields are zeroed.
//

typedef struct _DBGENG_EXDI_IOCTL_IDENTIFY_PROCESSORS_OUT
{
    ULONG Flags;
    ULONG NumberProcessors;
    ULONG64 Reserved[7];
} DBGENG_EXDI_IOCTL_IDENTIFY_PROCESSORS_OUT;

//
// {GET|SET}_CURRENT_PROCESSOR - Current processor control.
//

typedef struct _DBGENG_EXDI_IOCTL_GET_CURRENT_PROCESSOR_OUT
{
    ULONG Processor;
} DBGENG_EXDI_IOCTL_GET_CURRENT_PROCESSOR_OUT;

typedef struct _DBGENG_EXDI_IOCTL_SET_CURRENT_PROCESSOR_IN
{
    DBGENG_EXDI_IOCTL_CODE Code;
    ULONG Processor;
} DBGENG_EXDI_IOCTL_SET_CURRENT_PROCESSOR_IN;

//
// GET_BREAKPOINT_HIT - Determine which breakpoint was hit
// after a breakpoint halt reason.
//

#define DBGENG_EXDI_IOCTL_BREAKPOINT_NONE 0
#define DBGENG_EXDI_IOCTL_BREAKPOINT_CODE 1
#define DBGENG_EXDI_IOCTL_BREAKPOINT_DATA 2

typedef struct _DBGENG_EXDI_IOCTL_GET_BREAKPOINT_HIT_OUT
{
    ADDRESS_TYPE Address;
    ULONG AccessWidth;
    DATA_ACCESS_TYPE AccessType;
    ULONG Type;
} DBGENG_EXDI_IOCTL_GET_BREAKPOINT_HIT_OUT, *PDBGENG_EXDI_IOCTL_GET_BREAKPOINT_HIT_OUT;

#endif // #ifndef __DBGENG_EXDI_IO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exdi\exdi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* at Mon Sep 09 14:10:36 2002
 */
/* Compiler settings for exdi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __exdi_h__
#define __exdi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IeXdiServer_FWD_DEFINED__
#define __IeXdiServer_FWD_DEFINED__
typedef interface IeXdiServer IeXdiServer;
#endif 	/* __IeXdiServer_FWD_DEFINED__ */


#ifndef __IeXdiCodeBreakpoint_FWD_DEFINED__
#define __IeXdiCodeBreakpoint_FWD_DEFINED__
typedef interface IeXdiCodeBreakpoint IeXdiCodeBreakpoint;
#endif 	/* __IeXdiCodeBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiDataBreakpoint_FWD_DEFINED__
#define __IeXdiDataBreakpoint_FWD_DEFINED__
typedef interface IeXdiDataBreakpoint IeXdiDataBreakpoint;
#endif 	/* __IeXdiDataBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiEnumCodeBreakpoint_FWD_DEFINED__
#define __IeXdiEnumCodeBreakpoint_FWD_DEFINED__
typedef interface IeXdiEnumCodeBreakpoint IeXdiEnumCodeBreakpoint;
#endif 	/* __IeXdiEnumCodeBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiEnumDataBreakpoint_FWD_DEFINED__
#define __IeXdiEnumDataBreakpoint_FWD_DEFINED__
typedef interface IeXdiEnumDataBreakpoint IeXdiEnumDataBreakpoint;
#endif 	/* __IeXdiEnumDataBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiX86Context_FWD_DEFINED__
#define __IeXdiX86Context_FWD_DEFINED__
typedef interface IeXdiX86Context IeXdiX86Context;
#endif 	/* __IeXdiX86Context_FWD_DEFINED__ */


#ifndef __IeXdiX86ExContext_FWD_DEFINED__
#define __IeXdiX86ExContext_FWD_DEFINED__
typedef interface IeXdiX86ExContext IeXdiX86ExContext;
#endif 	/* __IeXdiX86ExContext_FWD_DEFINED__ */


#ifndef __IeXdiX86_64Context_FWD_DEFINED__
#define __IeXdiX86_64Context_FWD_DEFINED__
typedef interface IeXdiX86_64Context IeXdiX86_64Context;
#endif 	/* __IeXdiX86_64Context_FWD_DEFINED__ */


#ifndef __IeXdiSHXContext_FWD_DEFINED__
#define __IeXdiSHXContext_FWD_DEFINED__
typedef interface IeXdiSHXContext IeXdiSHXContext;
#endif 	/* __IeXdiSHXContext_FWD_DEFINED__ */


#ifndef __IeXdiMIPSContext_FWD_DEFINED__
#define __IeXdiMIPSContext_FWD_DEFINED__
typedef interface IeXdiMIPSContext IeXdiMIPSContext;
#endif 	/* __IeXdiMIPSContext_FWD_DEFINED__ */


#ifndef __IeXdiARMContext_FWD_DEFINED__
#define __IeXdiARMContext_FWD_DEFINED__
typedef interface IeXdiARMContext IeXdiARMContext;
#endif 	/* __IeXdiARMContext_FWD_DEFINED__ */


#ifndef __IeXdiPPCContext_FWD_DEFINED__
#define __IeXdiPPCContext_FWD_DEFINED__
typedef interface IeXdiPPCContext IeXdiPPCContext;
#endif 	/* __IeXdiPPCContext_FWD_DEFINED__ */


#ifndef __IeXdiIA64Context_FWD_DEFINED__
#define __IeXdiIA64Context_FWD_DEFINED__
typedef interface IeXdiIA64Context IeXdiIA64Context;
#endif 	/* __IeXdiIA64Context_FWD_DEFINED__ */


#ifndef __IeXdiClientNotifyMemChg_FWD_DEFINED__
#define __IeXdiClientNotifyMemChg_FWD_DEFINED__
typedef interface IeXdiClientNotifyMemChg IeXdiClientNotifyMemChg;
#endif 	/* __IeXdiClientNotifyMemChg_FWD_DEFINED__ */


#ifndef __IeXdiClientNotifyRunChg_FWD_DEFINED__
#define __IeXdiClientNotifyRunChg_FWD_DEFINED__
typedef interface IeXdiClientNotifyRunChg IeXdiClientNotifyRunChg;
#endif 	/* __IeXdiClientNotifyRunChg_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_exdi_0000 */
/* [local] */ 
















// Common eXDI HRESULT values:
//
#define FACILITY_EXDI   (130)
#define CUSTOMER_FLAG   (1)
//
#define SEV_SUCCESS         (0)
#define SEV_INFORMATIONAL   (1)
#define SEV_WARNING         (2)
#define SEV_ERROR           (3)
//
#define MAKE_EXDI_ERROR(ErrorCode,Severity) ((DWORD)(ErrorCode) | (FACILITY_EXDI << 16) | (CUSTOMER_FLAG << 29) | (Severity << 30))
//
//      S_OK                                                 (0)                                                                                      // Operation successful
#define EXDI_E_NOTIMPL               MAKE_EXDI_ERROR (0x4001, SEV_ERROR)          // Not implemented (in the specific conditions - could be implement for others - like Kernel Debugger inactive)
#define EXDI_E_OUTOFMEMORY           MAKE_EXDI_ERROR (0x000E, SEV_ERROR)          // Failed to allocate necessary memory
#define EXDI_E_INVALIDARG            MAKE_EXDI_ERROR (0x0057, SEV_ERROR)          // One or more arguments are invalid
#define EXDI_E_ABORT                 MAKE_EXDI_ERROR (0x4004, SEV_ERROR)          // Operation aborted
#define EXDI_E_FAIL                  MAKE_EXDI_ERROR (0x4005, SEV_ERROR)          // Unspecified failure
#define EXDI_E_COMMUNICATION         MAKE_EXDI_ERROR (0x0001, SEV_ERROR)          // Communication error between host driver and target
//
#define EXDI_E_NOLASTEXCEPTION       MAKE_EXDI_ERROR (0x0002, SEV_ERROR)          // No exception occured already, cannot return last
#define EXDI_I_TGTALREADYRUNNING     MAKE_EXDI_ERROR (0x0003, SEV_INFORMATIONAL)  // Indicates that the target was already running
#define EXDI_I_TGTALREADYHALTED      MAKE_EXDI_ERROR (0x0004, SEV_INFORMATIONAL)  // Indicates that the target was already halted
#define EXDI_E_TGTWASNOTHALTED       MAKE_EXDI_ERROR (0x0005, SEV_ERROR)          // The target was not halted (before Single Step command issued)
#define EXDI_E_NORESAVAILABLE        MAKE_EXDI_ERROR (0x0006, SEV_ERROR)          // No resource available, cannot instanciate Breakpoint (in the kind requested)
#define EXDI_E_NOREBOOTAVAIL         MAKE_EXDI_ERROR (0x0007, SEV_ERROR)          // The external reset is not available programatically to the probe
#define EXDI_E_ACCESSVIOLATION       MAKE_EXDI_ERROR (0x0008, SEV_ERROR)          // Access violation on at least one element in address range specificified by the operation
#define EXDI_E_CANNOTWHILETGTRUNNING MAKE_EXDI_ERROR (0x0009, SEV_ERROR)          // Cannot proceed while target running. Operation not supported on the fly. Must halt the target first
#define EXDI_E_USEDBYCONCURENTTHREAD MAKE_EXDI_ERROR (0x000A, SEV_ERROR)          // Cannot proceed immediately because resource is already used by concurent thread. Recall later or call SetWaitOnConcurentUse (TRUE) - default
#define EXDI_E_ADVISELIMIT           MAKE_EXDI_ERROR (0x000D, SEV_ERROR)          // The connection point has already reached its limit of connections and cannot accept any more
typedef __int64 ADDRESS_TYPE;

typedef __int64 *PADDRESS_TYPE;

typedef unsigned __int64 DWORD64;

typedef unsigned __int64 *PDWORD64;

#define	PROCESSOR_FAMILY_X86	( 0 )

#define	PROCESSOR_FAMILY_SH3	( 1 )

#define	PROCESSOR_FAMILY_SH4	( 2 )

#define	PROCESSOR_FAMILY_MIPS	( 3 )

#define	PROCESSOR_FAMILY_ARM	( 4 )

#define	PROCESSOR_FAMILY_PPC	( 5 )

#define	PROCESSOR_FAMILY_IA64	( 8 )

#define	PROCESSOR_FAMILY_UNK	( 0xffffffff )

typedef struct _DEBUG_ACCESS_CAPABILITIES_STRUCT
    {
    BOOL fWriteCBPWhileRunning;
    BOOL fReadCBPWhileRunning;
    BOOL fWriteDBPWhileRunning;
    BOOL fReadDBPWhileRunning;
    BOOL fWriteVMWhileRunning;
    BOOL fReadVMWhileRunning;
    BOOL fWritePMWhileRunning;
    BOOL fReadPMWhileRunning;
    BOOL fWriteRegWhileRunning;
    BOOL fReadRegWhileRunning;
    } 	DEBUG_ACCESS_CAPABILITIES_STRUCT;

typedef struct _DEBUG_ACCESS_CAPABILITIES_STRUCT *PDEBUG_ACCESS_CAPABILITIES_STRUCT;

typedef struct _GLOBAL_TARGET_INFO_STRUCT
    {
    DWORD TargetProcessorFamily;
    DEBUG_ACCESS_CAPABILITIES_STRUCT dbc;
    LPOLESTR szTargetName;
    LPOLESTR szProbeName;
    } 	GLOBAL_TARGET_INFO_STRUCT;

typedef struct _GLOBAL_TARGET_INFO_STRUCT *PGLOBAL_TARGET_INFO_STRUCT;

typedef 
enum _RUN_STATUS_TYPE
    {	rsRunning	= 0,
	rsHalted	= rsRunning + 1,
	rsError	= rsHalted + 1,
	rsUnknown	= rsError + 1
    } 	RUN_STATUS_TYPE;

typedef enum _RUN_STATUS_TYPE *PRUN_STATUS_TYPE;

typedef 
enum _PHALT_REASON_TYPE
    {	hrNone	= 0,
	hrUser	= hrNone + 1,
	hrException	= hrUser + 1,
	hrBp	= hrException + 1,
	hrStep	= hrBp + 1,
	hrUnknown	= hrStep + 1
    } 	HALT_REASON_TYPE;

typedef enum _PHALT_REASON_TYPE *PHALT_REASON_TYPE;

typedef struct _EXCEPTION_TYPE
    {
    DWORD dwCode;
    ADDRESS_TYPE Address;
    } 	EXCEPTION_TYPE;

typedef struct _EXCEPTION_TYPE *PEXCEPTION_TYPE;

typedef 
enum _CBP_KIND
    {	cbptAlgo	= 0,
	cbptHW	= cbptAlgo + 1,
	cbptSW	= cbptHW + 1
    } 	CBP_KIND;

typedef enum _CBP_KIND *PCBP_KIND;

typedef 
enum _DATA_ACCESS_TYPE
    {	daWrite	= 0,
	daRead	= 1,
	daBoth	= 2
    } 	DATA_ACCESS_TYPE;

typedef enum _DATA_ACCESS_TYPE *PDATA_ACCESS_TYPE;

typedef struct _BREAKPOINT_SUPPORT_TYPE
    {
    BOOL fCodeBpBypassCountSupported;
    BOOL fDataBpBypassCountSupported;
    BOOL fDataBpSupported;
    BOOL fDataBpMaskableAddress;
    BOOL fDataBpMaskableData;
    BOOL fDataBpDataWidthSpecifiable;
    BOOL fDataBpReadWriteSpecifiable;
    BOOL fDataBpDataMatchSupported;
    } 	BREAKPOINT_SUPPORT_TYPE;

typedef struct _BREAKPOINT_SUPPORT_TYPE *PBREAKPOINT_SUPPORT_TYPE;

typedef 
enum _MEM_TYPE
    {	mtVirtual	= 0,
	mtPhysicalOrPeriIO	= mtVirtual + 1,
	mtContext	= mtPhysicalOrPeriIO + 1
    } 	MEM_TYPE;

typedef enum _MEM_TYPE *PMEM_TYPE;

typedef 
enum _EXCEPTION_DEFAULT_ACTION_TYPE
    {	edaIgnore	= 0,
	edaNotify	= edaIgnore + 1,
	edaStop	= edaNotify + 1
    } 	EXCEPTION_DEFAULT_ACTION_TYPE;

typedef struct _EXCEPTION_DESCRIPTION_TYPE
    {
    DWORD dwExceptionCode;
    EXCEPTION_DEFAULT_ACTION_TYPE efd;
    wchar_t szDescription[ 60 ];
    } 	EXCEPTION_DESCRIPTION_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0000_v0_0_s_ifspec;

#ifndef __IeXdiServer_INTERFACE_DEFINED__
#define __IeXdiServer_INTERFACE_DEFINED__

/* interface IeXdiServer */
/* [ref][helpstring][uuid][object] */ 

#define DBGMODE_BFMASK_KERNEL (0x0001) // If TRUE indicates that Kernel Debugger is active (can use KDAPI), so HW on-chip debug functions (eXDI)
                                       //  may be optionaly handled (can return EXDI_E_NOTIMPL)
                                       // If FALSE indicates that Kernel Debugger is not active so HW on-chip debug capabilities are the only   
                                       //  one available and should be implemented.

EXTERN_C const IID IID_IeXdiServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495352435201")
    IeXdiServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetInfo( 
            /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugMode( 
            /* [in] */ DWORD dwModeBitField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExceptionDescriptionList( 
            /* [in] */ DWORD dwNbElementToReturn,
            /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE *pedTable,
            /* [out] */ DWORD *pdwNbTotalExceptionInList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT ErrorCode,
            /* [out] */ LPOLESTR *pszErrorDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWaitOnConcurentUse( 
            /* [in] */ BOOL fNewWaitOnConcurentUseFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunStatus( 
            /* [out] */ PRUN_STATUS_TYPE persCurrent,
            /* [out] */ PHALT_REASON_TYPE pehrCurrent,
            /* [out] */ ADDRESS_TYPE *pCurrentExecAddress,
            /* [out] */ DWORD *pdwExceptionCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastException( 
            /* [out] */ PEXCEPTION_TYPE pexLast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Halt( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoSingleStep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoMultipleStep( 
            /* [in] */ DWORD dwNbInstructions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoRangeStep( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBpSupport( 
            /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNbCodeBpAvail( 
            /* [out] */ DWORD *pdwNbHwCodeBpAvail,
            /* [out] */ DWORD *pdwNbSwCodeBpAvail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNbDataBpAvail( 
            /* [out] */ DWORD *pdwNbDataBpAvail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCodeBreakpoint( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ CBP_KIND cbpk,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ DWORD dwExecMode,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelCodeBreakpoint( 
            /* [in] */ IeXdiCodeBreakpoint *pieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDataBreakpoint( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ ADDRESS_TYPE AddressMask,
            /* [in] */ DWORD dwData,
            /* [in] */ DWORD dwDataMask,
            /* [in] */ BYTE bAccessWidth,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DATA_ACCESS_TYPE da,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelDataBreakpoint( 
            /* [in] */ IeXdiDataBreakpoint *pieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAllCodeBreakpoints( 
            /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAllDataBreakpoints( 
            /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeBreakpointsInAddrRange( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDataBreakpointsInAddrRange( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartNotifyingRunChg( 
            /* [in] */ IeXdiClientNotifyRunChg *pieXdiClientNotifyRunChg,
            /* [out] */ DWORD *pdwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopNotifyingRunChg( 
            /* [in] */ DWORD dwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtualMemory( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE *pbReadBuffer,
            /* [out] */ DWORD *pdwNbElementEffectRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtualMemory( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE *pbWriteBuffer,
            /* [out] */ DWORD *pdwNbElementEffectWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPhysicalMemoryOrPeriphIO( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE *pbReadBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePhysicalMemoryOrPeriphIO( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE *pbWriteBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartNotifyingMemChg( 
            /* [in] */ IeXdiClientNotifyMemChg *pieXdiClientNotifyMemChg,
            /* [out] */ DWORD *pdwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopNotifyingMemChg( 
            /* [in] */ DWORD dwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ioctl( 
            /* [in] */ DWORD dwBuffInSize,
            /* [size_is][in] */ const BYTE *pbBufferIn,
            /* [in] */ DWORD dwBuffOutSize,
            /* [out] */ DWORD *pdwEffectBuffOutSize,
            /* [length_is][size_is][out] */ BYTE *pbBufferOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTargetInfo )( 
            IeXdiServer * This,
            /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugMode )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwModeBitField);
        
        HRESULT ( STDMETHODCALLTYPE *GetExceptionDescriptionList )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwNbElementToReturn,
            /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE *pedTable,
            /* [out] */ DWORD *pdwNbTotalExceptionInList);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorDescription )( 
            IeXdiServer * This,
            /* [in] */ HRESULT ErrorCode,
            /* [out] */ LPOLESTR *pszErrorDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SetWaitOnConcurentUse )( 
            IeXdiServer * This,
            /* [in] */ BOOL fNewWaitOnConcurentUseFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunStatus )( 
            IeXdiServer * This,
            /* [out] */ PRUN_STATUS_TYPE persCurrent,
            /* [out] */ PHALT_REASON_TYPE pehrCurrent,
            /* [out] */ ADDRESS_TYPE *pCurrentExecAddress,
            /* [out] */ DWORD *pdwExceptionCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastException )( 
            IeXdiServer * This,
            /* [out] */ PEXCEPTION_TYPE pexLast);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IeXdiServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Halt )( 
            IeXdiServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoSingleStep )( 
            IeXdiServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoMultipleStep )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwNbInstructions);
        
        HRESULT ( STDMETHODCALLTYPE *DoRangeStep )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress);
        
        HRESULT ( STDMETHODCALLTYPE *Reboot )( 
            IeXdiServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBpSupport )( 
            IeXdiServer * This,
            /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps);
        
        HRESULT ( STDMETHODCALLTYPE *GetNbCodeBpAvail )( 
            IeXdiServer * This,
            /* [out] */ DWORD *pdwNbHwCodeBpAvail,
            /* [out] */ DWORD *pdwNbSwCodeBpAvail);
        
        HRESULT ( STDMETHODCALLTYPE *GetNbDataBpAvail )( 
            IeXdiServer * This,
            /* [out] */ DWORD *pdwNbDataBpAvail);
        
        HRESULT ( STDMETHODCALLTYPE *AddCodeBreakpoint )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ CBP_KIND cbpk,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ DWORD dwExecMode,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *DelCodeBreakpoint )( 
            IeXdiServer * This,
            /* [in] */ IeXdiCodeBreakpoint *pieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *AddDataBreakpoint )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ ADDRESS_TYPE AddressMask,
            /* [in] */ DWORD dwData,
            /* [in] */ DWORD dwDataMask,
            /* [in] */ BYTE bAccessWidth,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DATA_ACCESS_TYPE da,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *DelDataBreakpoint )( 
            IeXdiServer * This,
            /* [in] */ IeXdiDataBreakpoint *pieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAllCodeBreakpoints )( 
            IeXdiServer * This,
            /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAllDataBreakpoints )( 
            IeXdiServer * This,
            /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCodeBreakpointsInAddrRange )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDataBreakpointsInAddrRange )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *StartNotifyingRunChg )( 
            IeXdiServer * This,
            /* [in] */ IeXdiClientNotifyRunChg *pieXdiClientNotifyRunChg,
            /* [out] */ DWORD *pdwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE *StopNotifyingRunChg )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtualMemory )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE *pbReadBuffer,
            /* [out] */ DWORD *pdwNbElementEffectRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtualMemory )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE *pbWriteBuffer,
            /* [out] */ DWORD *pdwNbElementEffectWritten);
        
        HRESULT ( STDMETHODCALLTYPE *ReadPhysicalMemoryOrPeriphIO )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE *pbReadBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *WritePhysicalMemoryOrPeriphIO )( 
            IeXdiServer * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE *pbWriteBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *StartNotifyingMemChg )( 
            IeXdiServer * This,
            /* [in] */ IeXdiClientNotifyMemChg *pieXdiClientNotifyMemChg,
            /* [out] */ DWORD *pdwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE *StopNotifyingMemChg )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Ioctl )( 
            IeXdiServer * This,
            /* [in] */ DWORD dwBuffInSize,
            /* [size_is][in] */ const BYTE *pbBufferIn,
            /* [in] */ DWORD dwBuffOutSize,
            /* [out] */ DWORD *pdwEffectBuffOutSize,
            /* [length_is][size_is][out] */ BYTE *pbBufferOut);
        
        END_INTERFACE
    } IeXdiServerVtbl;

    interface IeXdiServer
    {
        CONST_VTBL struct IeXdiServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiServer_GetTargetInfo(This,pgti)	\
    (This)->lpVtbl -> GetTargetInfo(This,pgti)

#define IeXdiServer_SetDebugMode(This,dwModeBitField)	\
    (This)->lpVtbl -> SetDebugMode(This,dwModeBitField)

#define IeXdiServer_GetExceptionDescriptionList(This,dwNbElementToReturn,pedTable,pdwNbTotalExceptionInList)	\
    (This)->lpVtbl -> GetExceptionDescriptionList(This,dwNbElementToReturn,pedTable,pdwNbTotalExceptionInList)

#define IeXdiServer_GetErrorDescription(This,ErrorCode,pszErrorDesc)	\
    (This)->lpVtbl -> GetErrorDescription(This,ErrorCode,pszErrorDesc)

#define IeXdiServer_SetWaitOnConcurentUse(This,fNewWaitOnConcurentUseFlag)	\
    (This)->lpVtbl -> SetWaitOnConcurentUse(This,fNewWaitOnConcurentUseFlag)

#define IeXdiServer_GetRunStatus(This,persCurrent,pehrCurrent,pCurrentExecAddress,pdwExceptionCode)	\
    (This)->lpVtbl -> GetRunStatus(This,persCurrent,pehrCurrent,pCurrentExecAddress,pdwExceptionCode)

#define IeXdiServer_GetLastException(This,pexLast)	\
    (This)->lpVtbl -> GetLastException(This,pexLast)

#define IeXdiServer_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IeXdiServer_Halt(This)	\
    (This)->lpVtbl -> Halt(This)

#define IeXdiServer_DoSingleStep(This)	\
    (This)->lpVtbl -> DoSingleStep(This)

#define IeXdiServer_DoMultipleStep(This,dwNbInstructions)	\
    (This)->lpVtbl -> DoMultipleStep(This,dwNbInstructions)

#define IeXdiServer_DoRangeStep(This,FirstAddress,LastAddress)	\
    (This)->lpVtbl -> DoRangeStep(This,FirstAddress,LastAddress)

#define IeXdiServer_Reboot(This)	\
    (This)->lpVtbl -> Reboot(This)

#define IeXdiServer_GetBpSupport(This,pbps)	\
    (This)->lpVtbl -> GetBpSupport(This,pbps)

#define IeXdiServer_GetNbCodeBpAvail(This,pdwNbHwCodeBpAvail,pdwNbSwCodeBpAvail)	\
    (This)->lpVtbl -> GetNbCodeBpAvail(This,pdwNbHwCodeBpAvail,pdwNbSwCodeBpAvail)

#define IeXdiServer_GetNbDataBpAvail(This,pdwNbDataBpAvail)	\
    (This)->lpVtbl -> GetNbDataBpAvail(This,pdwNbDataBpAvail)

#define IeXdiServer_AddCodeBreakpoint(This,Address,cbpk,mt,dwExecMode,dwTotalBypassCount,ppieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> AddCodeBreakpoint(This,Address,cbpk,mt,dwExecMode,dwTotalBypassCount,ppieXdiCodeBreakpoint)

#define IeXdiServer_DelCodeBreakpoint(This,pieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> DelCodeBreakpoint(This,pieXdiCodeBreakpoint)

#define IeXdiServer_AddDataBreakpoint(This,Address,AddressMask,dwData,dwDataMask,bAccessWidth,mt,bAddressSpace,da,dwTotalBypassCount,ppieXdiDataBreakpoint)	\
    (This)->lpVtbl -> AddDataBreakpoint(This,Address,AddressMask,dwData,dwDataMask,bAccessWidth,mt,bAddressSpace,da,dwTotalBypassCount,ppieXdiDataBreakpoint)

#define IeXdiServer_DelDataBreakpoint(This,pieXdiDataBreakpoint)	\
    (This)->lpVtbl -> DelDataBreakpoint(This,pieXdiDataBreakpoint)

#define IeXdiServer_EnumAllCodeBreakpoints(This,ppieXdiEnumCodeBreakpoint)	\
    (This)->lpVtbl -> EnumAllCodeBreakpoints(This,ppieXdiEnumCodeBreakpoint)

#define IeXdiServer_EnumAllDataBreakpoints(This,ppieXdiEnumDataBreakpoint)	\
    (This)->lpVtbl -> EnumAllDataBreakpoints(This,ppieXdiEnumDataBreakpoint)

#define IeXdiServer_EnumCodeBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumCodeBreakpoint)	\
    (This)->lpVtbl -> EnumCodeBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumCodeBreakpoint)

#define IeXdiServer_EnumDataBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumDataBreakpoint)	\
    (This)->lpVtbl -> EnumDataBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumDataBreakpoint)

#define IeXdiServer_StartNotifyingRunChg(This,pieXdiClientNotifyRunChg,pdwConnectionCookie)	\
    (This)->lpVtbl -> StartNotifyingRunChg(This,pieXdiClientNotifyRunChg,pdwConnectionCookie)

#define IeXdiServer_StopNotifyingRunChg(This,dwConnectionCookie)	\
    (This)->lpVtbl -> StopNotifyingRunChg(This,dwConnectionCookie)

#define IeXdiServer_ReadVirtualMemory(This,Address,dwNbElemToRead,bAccessWidth,pbReadBuffer,pdwNbElementEffectRead)	\
    (This)->lpVtbl -> ReadVirtualMemory(This,Address,dwNbElemToRead,bAccessWidth,pbReadBuffer,pdwNbElementEffectRead)

#define IeXdiServer_WriteVirtualMemory(This,Address,dwNbElemToWrite,bAccessWidth,pbWriteBuffer,pdwNbElementEffectWritten)	\
    (This)->lpVtbl -> WriteVirtualMemory(This,Address,dwNbElemToWrite,bAccessWidth,pbWriteBuffer,pdwNbElementEffectWritten)

#define IeXdiServer_ReadPhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToRead,bAccessWidth,pbReadBuffer)	\
    (This)->lpVtbl -> ReadPhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToRead,bAccessWidth,pbReadBuffer)

#define IeXdiServer_WritePhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToWrite,bAccessWidth,pbWriteBuffer)	\
    (This)->lpVtbl -> WritePhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToWrite,bAccessWidth,pbWriteBuffer)

#define IeXdiServer_StartNotifyingMemChg(This,pieXdiClientNotifyMemChg,pdwConnectionCookie)	\
    (This)->lpVtbl -> StartNotifyingMemChg(This,pieXdiClientNotifyMemChg,pdwConnectionCookie)

#define IeXdiServer_StopNotifyingMemChg(This,dwConnectionCookie)	\
    (This)->lpVtbl -> StopNotifyingMemChg(This,dwConnectionCookie)

#define IeXdiServer_Ioctl(This,dwBuffInSize,pbBufferIn,dwBuffOutSize,pdwEffectBuffOutSize,pbBufferOut)	\
    (This)->lpVtbl -> Ioctl(This,dwBuffInSize,pbBufferIn,dwBuffOutSize,pdwEffectBuffOutSize,pbBufferOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiServer_GetTargetInfo_Proxy( 
    IeXdiServer * This,
    /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti);


void __RPC_STUB IeXdiServer_GetTargetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_SetDebugMode_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwModeBitField);


void __RPC_STUB IeXdiServer_SetDebugMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetExceptionDescriptionList_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwNbElementToReturn,
    /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE *pedTable,
    /* [out] */ DWORD *pdwNbTotalExceptionInList);


void __RPC_STUB IeXdiServer_GetExceptionDescriptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetErrorDescription_Proxy( 
    IeXdiServer * This,
    /* [in] */ HRESULT ErrorCode,
    /* [out] */ LPOLESTR *pszErrorDesc);


void __RPC_STUB IeXdiServer_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_SetWaitOnConcurentUse_Proxy( 
    IeXdiServer * This,
    /* [in] */ BOOL fNewWaitOnConcurentUseFlag);


void __RPC_STUB IeXdiServer_SetWaitOnConcurentUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetRunStatus_Proxy( 
    IeXdiServer * This,
    /* [out] */ PRUN_STATUS_TYPE persCurrent,
    /* [out] */ PHALT_REASON_TYPE pehrCurrent,
    /* [out] */ ADDRESS_TYPE *pCurrentExecAddress,
    /* [out] */ DWORD *pdwExceptionCode);


void __RPC_STUB IeXdiServer_GetRunStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetLastException_Proxy( 
    IeXdiServer * This,
    /* [out] */ PEXCEPTION_TYPE pexLast);


void __RPC_STUB IeXdiServer_GetLastException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Run_Proxy( 
    IeXdiServer * This);


void __RPC_STUB IeXdiServer_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Halt_Proxy( 
    IeXdiServer * This);


void __RPC_STUB IeXdiServer_Halt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoSingleStep_Proxy( 
    IeXdiServer * This);


void __RPC_STUB IeXdiServer_DoSingleStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoMultipleStep_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwNbInstructions);


void __RPC_STUB IeXdiServer_DoMultipleStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoRangeStep_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress);


void __RPC_STUB IeXdiServer_DoRangeStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Reboot_Proxy( 
    IeXdiServer * This);


void __RPC_STUB IeXdiServer_Reboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetBpSupport_Proxy( 
    IeXdiServer * This,
    /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps);


void __RPC_STUB IeXdiServer_GetBpSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetNbCodeBpAvail_Proxy( 
    IeXdiServer * This,
    /* [out] */ DWORD *pdwNbHwCodeBpAvail,
    /* [out] */ DWORD *pdwNbSwCodeBpAvail);


void __RPC_STUB IeXdiServer_GetNbCodeBpAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetNbDataBpAvail_Proxy( 
    IeXdiServer * This,
    /* [out] */ DWORD *pdwNbDataBpAvail);


void __RPC_STUB IeXdiServer_GetNbDataBpAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_AddCodeBreakpoint_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ CBP_KIND cbpk,
    /* [in] */ MEM_TYPE mt,
    /* [in] */ DWORD dwExecMode,
    /* [in] */ DWORD dwTotalBypassCount,
    /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint);


void __RPC_STUB IeXdiServer_AddCodeBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DelCodeBreakpoint_Proxy( 
    IeXdiServer * This,
    /* [in] */ IeXdiCodeBreakpoint *pieXdiCodeBreakpoint);


void __RPC_STUB IeXdiServer_DelCodeBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_AddDataBreakpoint_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ ADDRESS_TYPE AddressMask,
    /* [in] */ DWORD dwData,
    /* [in] */ DWORD dwDataMask,
    /* [in] */ BYTE bAccessWidth,
    /* [in] */ MEM_TYPE mt,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DATA_ACCESS_TYPE da,
    /* [in] */ DWORD dwTotalBypassCount,
    /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint);


void __RPC_STUB IeXdiServer_AddDataBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DelDataBreakpoint_Proxy( 
    IeXdiServer * This,
    /* [in] */ IeXdiDataBreakpoint *pieXdiDataBreakpoint);


void __RPC_STUB IeXdiServer_DelDataBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumAllCodeBreakpoints_Proxy( 
    IeXdiServer * This,
    /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint);


void __RPC_STUB IeXdiServer_EnumAllCodeBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumAllDataBreakpoints_Proxy( 
    IeXdiServer * This,
    /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint);


void __RPC_STUB IeXdiServer_EnumAllDataBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumCodeBreakpointsInAddrRange_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress,
    /* [out] */ IeXdiEnumCodeBreakpoint **ppieXdiEnumCodeBreakpoint);


void __RPC_STUB IeXdiServer_EnumCodeBreakpointsInAddrRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumDataBreakpointsInAddrRange_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress,
    /* [out] */ IeXdiEnumDataBreakpoint **ppieXdiEnumDataBreakpoint);


void __RPC_STUB IeXdiServer_EnumDataBreakpointsInAddrRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StartNotifyingRunChg_Proxy( 
    IeXdiServer * This,
    /* [in] */ IeXdiClientNotifyRunChg *pieXdiClientNotifyRunChg,
    /* [out] */ DWORD *pdwConnectionCookie);


void __RPC_STUB IeXdiServer_StartNotifyingRunChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StopNotifyingRunChg_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwConnectionCookie);


void __RPC_STUB IeXdiServer_StopNotifyingRunChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_ReadVirtualMemory_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ DWORD dwNbElemToRead,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][out] */ BYTE *pbReadBuffer,
    /* [out] */ DWORD *pdwNbElementEffectRead);


void __RPC_STUB IeXdiServer_ReadVirtualMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_WriteVirtualMemory_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ DWORD dwNbElemToWrite,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][in] */ const BYTE *pbWriteBuffer,
    /* [out] */ DWORD *pdwNbElementEffectWritten);


void __RPC_STUB IeXdiServer_WriteVirtualMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_ReadPhysicalMemoryOrPeriphIO_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemToRead,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][out] */ BYTE *pbReadBuffer);


void __RPC_STUB IeXdiServer_ReadPhysicalMemoryOrPeriphIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_WritePhysicalMemoryOrPeriphIO_Proxy( 
    IeXdiServer * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemToWrite,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][in] */ const BYTE *pbWriteBuffer);


void __RPC_STUB IeXdiServer_WritePhysicalMemoryOrPeriphIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StartNotifyingMemChg_Proxy( 
    IeXdiServer * This,
    /* [in] */ IeXdiClientNotifyMemChg *pieXdiClientNotifyMemChg,
    /* [out] */ DWORD *pdwConnectionCookie);


void __RPC_STUB IeXdiServer_StartNotifyingMemChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StopNotifyingMemChg_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwConnectionCookie);


void __RPC_STUB IeXdiServer_StopNotifyingMemChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Ioctl_Proxy( 
    IeXdiServer * This,
    /* [in] */ DWORD dwBuffInSize,
    /* [size_is][in] */ const BYTE *pbBufferIn,
    /* [in] */ DWORD dwBuffOutSize,
    /* [out] */ DWORD *pdwEffectBuffOutSize,
    /* [length_is][size_is][out] */ BYTE *pbBufferOut);


void __RPC_STUB IeXdiServer_Ioctl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiServer_INTERFACE_DEFINED__ */


#ifndef __IeXdiCodeBreakpoint_INTERFACE_DEFINED__
#define __IeXdiCodeBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiCodeBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiCodeBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495342507401")
    IeXdiCodeBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PCBP_KIND pcbpk,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ DWORD *pdwExecMode,
            /* [out] */ DWORD *pdwTotalBypassCount,
            /* [out] */ DWORD *pdwBypassedOccurences,
            /* [out] */ BOOL *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiCodeBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiCodeBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiCodeBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiCodeBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IeXdiCodeBreakpoint * This,
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PCBP_KIND pcbpk,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ DWORD *pdwExecMode,
            /* [out] */ DWORD *pdwTotalBypassCount,
            /* [out] */ DWORD *pdwBypassedOccurences,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IeXdiCodeBreakpoint * This,
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences);
        
        END_INTERFACE
    } IeXdiCodeBreakpointVtbl;

    interface IeXdiCodeBreakpoint
    {
        CONST_VTBL struct IeXdiCodeBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiCodeBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiCodeBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiCodeBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiCodeBreakpoint_GetAttributes(This,pAddress,pcbpk,pmt,pdwExecMode,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)	\
    (This)->lpVtbl -> GetAttributes(This,pAddress,pcbpk,pmt,pdwExecMode,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)

#define IeXdiCodeBreakpoint_SetState(This,fEnabled,fResetBypassedOccurences)	\
    (This)->lpVtbl -> SetState(This,fEnabled,fResetBypassedOccurences)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiCodeBreakpoint_GetAttributes_Proxy( 
    IeXdiCodeBreakpoint * This,
    /* [out] */ PADDRESS_TYPE pAddress,
    /* [out] */ PCBP_KIND pcbpk,
    /* [out] */ PMEM_TYPE pmt,
    /* [out] */ DWORD *pdwExecMode,
    /* [out] */ DWORD *pdwTotalBypassCount,
    /* [out] */ DWORD *pdwBypassedOccurences,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IeXdiCodeBreakpoint_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiCodeBreakpoint_SetState_Proxy( 
    IeXdiCodeBreakpoint * This,
    /* [in] */ BOOL fEnabled,
    /* [in] */ BOOL fResetBypassedOccurences);


void __RPC_STUB IeXdiCodeBreakpoint_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiCodeBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiDataBreakpoint_INTERFACE_DEFINED__
#define __IeXdiDataBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiDataBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiDataBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495357507400")
    IeXdiDataBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PADDRESS_TYPE pAddressMask,
            /* [out] */ DWORD *pdwData,
            /* [out] */ DWORD *pdwDataMask,
            /* [out] */ BYTE *pbAccessWidth,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ BYTE *pbAddressSpace,
            /* [out] */ PDATA_ACCESS_TYPE pda,
            /* [out] */ DWORD *pdwTotalBypassCount,
            /* [out] */ DWORD *pdwBypassedOccurences,
            /* [out] */ BOOL *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiDataBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiDataBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiDataBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiDataBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IeXdiDataBreakpoint * This,
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PADDRESS_TYPE pAddressMask,
            /* [out] */ DWORD *pdwData,
            /* [out] */ DWORD *pdwDataMask,
            /* [out] */ BYTE *pbAccessWidth,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ BYTE *pbAddressSpace,
            /* [out] */ PDATA_ACCESS_TYPE pda,
            /* [out] */ DWORD *pdwTotalBypassCount,
            /* [out] */ DWORD *pdwBypassedOccurences,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IeXdiDataBreakpoint * This,
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences);
        
        END_INTERFACE
    } IeXdiDataBreakpointVtbl;

    interface IeXdiDataBreakpoint
    {
        CONST_VTBL struct IeXdiDataBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiDataBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiDataBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiDataBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiDataBreakpoint_GetAttributes(This,pAddress,pAddressMask,pdwData,pdwDataMask,pbAccessWidth,pmt,pbAddressSpace,pda,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)	\
    (This)->lpVtbl -> GetAttributes(This,pAddress,pAddressMask,pdwData,pdwDataMask,pbAccessWidth,pmt,pbAddressSpace,pda,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)

#define IeXdiDataBreakpoint_SetState(This,fEnabled,fResetBypassedOccurences)	\
    (This)->lpVtbl -> SetState(This,fEnabled,fResetBypassedOccurences)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiDataBreakpoint_GetAttributes_Proxy( 
    IeXdiDataBreakpoint * This,
    /* [out] */ PADDRESS_TYPE pAddress,
    /* [out] */ PADDRESS_TYPE pAddressMask,
    /* [out] */ DWORD *pdwData,
    /* [out] */ DWORD *pdwDataMask,
    /* [out] */ BYTE *pbAccessWidth,
    /* [out] */ PMEM_TYPE pmt,
    /* [out] */ BYTE *pbAddressSpace,
    /* [out] */ PDATA_ACCESS_TYPE pda,
    /* [out] */ DWORD *pdwTotalBypassCount,
    /* [out] */ DWORD *pdwBypassedOccurences,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB IeXdiDataBreakpoint_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiDataBreakpoint_SetState_Proxy( 
    IeXdiDataBreakpoint * This,
    /* [in] */ BOOL fEnabled,
    /* [in] */ BOOL fResetBypassedOccurences);


void __RPC_STUB IeXdiDataBreakpoint_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiDataBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__
#define __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiEnumCodeBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiEnumCodeBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495345425074")
    IeXdiEnumCodeBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiCodeBreakpoint *apieXdiCodeBreakpoint[  ],
            /* [out] */ DWORD *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ DWORD *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiEnumCodeBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiEnumCodeBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiEnumCodeBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiEnumCodeBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IeXdiEnumCodeBreakpoint * This,
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiCodeBreakpoint *apieXdiCodeBreakpoint[  ],
            /* [out] */ DWORD *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IeXdiEnumCodeBreakpoint * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IeXdiEnumCodeBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IeXdiEnumCodeBreakpoint * This,
            /* [out] */ DWORD *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            IeXdiEnumCodeBreakpoint * This,
            /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *DisableAll )( 
            IeXdiEnumCodeBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableAll )( 
            IeXdiEnumCodeBreakpoint * This);
        
        END_INTERFACE
    } IeXdiEnumCodeBreakpointVtbl;

    interface IeXdiEnumCodeBreakpoint
    {
        CONST_VTBL struct IeXdiEnumCodeBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiEnumCodeBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiEnumCodeBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiEnumCodeBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiEnumCodeBreakpoint_Next(This,celt,apieXdiCodeBreakpoint,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,apieXdiCodeBreakpoint,pceltFetched)

#define IeXdiEnumCodeBreakpoint_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IeXdiEnumCodeBreakpoint_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IeXdiEnumCodeBreakpoint_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define IeXdiEnumCodeBreakpoint_GetNext(This,ppieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> GetNext(This,ppieXdiCodeBreakpoint)

#define IeXdiEnumCodeBreakpoint_DisableAll(This)	\
    (This)->lpVtbl -> DisableAll(This)

#define IeXdiEnumCodeBreakpoint_EnableAll(This)	\
    (This)->lpVtbl -> EnableAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Next_Proxy( 
    IeXdiEnumCodeBreakpoint * This,
    /* [in] */ DWORD celt,
    /* [length_is][size_is][out] */ IeXdiCodeBreakpoint *apieXdiCodeBreakpoint[  ],
    /* [out] */ DWORD *pceltFetched);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Skip_Proxy( 
    IeXdiEnumCodeBreakpoint * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Reset_Proxy( 
    IeXdiEnumCodeBreakpoint * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_GetCount_Proxy( 
    IeXdiEnumCodeBreakpoint * This,
    /* [out] */ DWORD *pcelt);


void __RPC_STUB IeXdiEnumCodeBreakpoint_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_GetNext_Proxy( 
    IeXdiEnumCodeBreakpoint * This,
    /* [out] */ IeXdiCodeBreakpoint **ppieXdiCodeBreakpoint);


void __RPC_STUB IeXdiEnumCodeBreakpoint_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_DisableAll_Proxy( 
    IeXdiEnumCodeBreakpoint * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_DisableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_EnableAll_Proxy( 
    IeXdiEnumCodeBreakpoint * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_EnableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__
#define __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiEnumDataBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiEnumDataBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495345575074")
    IeXdiEnumDataBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiDataBreakpoint *apieXdiDataBreakpoint[  ],
            /* [out] */ DWORD *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ DWORD *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiEnumDataBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiEnumDataBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiEnumDataBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiEnumDataBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IeXdiEnumDataBreakpoint * This,
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiDataBreakpoint *apieXdiDataBreakpoint[  ],
            /* [out] */ DWORD *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IeXdiEnumDataBreakpoint * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IeXdiEnumDataBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IeXdiEnumDataBreakpoint * This,
            /* [out] */ DWORD *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            IeXdiEnumDataBreakpoint * This,
            /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *DisableAll )( 
            IeXdiEnumDataBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableAll )( 
            IeXdiEnumDataBreakpoint * This);
        
        END_INTERFACE
    } IeXdiEnumDataBreakpointVtbl;

    interface IeXdiEnumDataBreakpoint
    {
        CONST_VTBL struct IeXdiEnumDataBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiEnumDataBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiEnumDataBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiEnumDataBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiEnumDataBreakpoint_Next(This,celt,apieXdiDataBreakpoint,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,apieXdiDataBreakpoint,pceltFetched)

#define IeXdiEnumDataBreakpoint_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IeXdiEnumDataBreakpoint_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IeXdiEnumDataBreakpoint_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define IeXdiEnumDataBreakpoint_GetNext(This,ppieXdiDataBreakpoint)	\
    (This)->lpVtbl -> GetNext(This,ppieXdiDataBreakpoint)

#define IeXdiEnumDataBreakpoint_DisableAll(This)	\
    (This)->lpVtbl -> DisableAll(This)

#define IeXdiEnumDataBreakpoint_EnableAll(This)	\
    (This)->lpVtbl -> EnableAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Next_Proxy( 
    IeXdiEnumDataBreakpoint * This,
    /* [in] */ DWORD celt,
    /* [length_is][size_is][out] */ IeXdiDataBreakpoint *apieXdiDataBreakpoint[  ],
    /* [out] */ DWORD *pceltFetched);


void __RPC_STUB IeXdiEnumDataBreakpoint_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Skip_Proxy( 
    IeXdiEnumDataBreakpoint * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IeXdiEnumDataBreakpoint_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Reset_Proxy( 
    IeXdiEnumDataBreakpoint * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_GetCount_Proxy( 
    IeXdiEnumDataBreakpoint * This,
    /* [out] */ DWORD *pcelt);


void __RPC_STUB IeXdiEnumDataBreakpoint_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_GetNext_Proxy( 
    IeXdiEnumDataBreakpoint * This,
    /* [out] */ IeXdiDataBreakpoint **ppieXdiDataBreakpoint);


void __RPC_STUB IeXdiEnumDataBreakpoint_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_DisableAll_Proxy( 
    IeXdiEnumDataBreakpoint * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_DisableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_EnableAll_Proxy( 
    IeXdiEnumDataBreakpoint * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_EnableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0261 */
/* [local] */ 

#define	SIZE_OF_80387_REGISTERS_IN_BYTES	( 80 )

typedef struct _CONTEXT_X86
    {
    struct 
        {
        BOOL fSegmentRegs;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD SegCs;
    DWORD SegSs;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD EFlags;
    DWORD Ebp;
    DWORD Eip;
    DWORD Esp;
    DWORD Eax;
    DWORD Ebx;
    DWORD Ecx;
    DWORD Edx;
    DWORD Esi;
    DWORD Edi;
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[ 80 ];
    DWORD Cr0NpxState;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    } 	CONTEXT_X86;

typedef struct _CONTEXT_X86 *PCONTEXT_X86;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0261_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0261_v0_0_s_ifspec;

#ifndef __IeXdiX86Context_INTERFACE_DEFINED__
#define __IeXdiX86Context_INTERFACE_DEFINED__

/* interface IeXdiX86Context */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiX86Context;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495358383643")
    IeXdiX86Context : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_X86 pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_X86 Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiX86ContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiX86Context * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiX86Context * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiX86Context * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiX86Context * This,
            /* [out][in] */ PCONTEXT_X86 pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiX86Context * This,
            /* [in] */ CONTEXT_X86 Context);
        
        END_INTERFACE
    } IeXdiX86ContextVtbl;

    interface IeXdiX86Context
    {
        CONST_VTBL struct IeXdiX86ContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiX86Context_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiX86Context_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiX86Context_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiX86Context_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiX86Context_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiX86Context_GetContext_Proxy( 
    IeXdiX86Context * This,
    /* [out][in] */ PCONTEXT_X86 pContext);


void __RPC_STUB IeXdiX86Context_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiX86Context_SetContext_Proxy( 
    IeXdiX86Context * This,
    /* [in] */ CONTEXT_X86 Context);


void __RPC_STUB IeXdiX86Context_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiX86Context_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0262 */
/* [local] */ 

typedef struct _X86_SEG_DESC_INFO
    {
    DWORD Base;
    DWORD Limit;
    DWORD Flags;
    } 	X86_SEG_DESC_INFO;

typedef struct _X86_SSE_REG
    {
    DWORD Reg0;
    DWORD Reg1;
    DWORD Reg2;
    DWORD Reg3;
    } 	X86_SSE_REG;

typedef struct _CONTEXT_X86_EX
    {
    struct 
        {
        BOOL fSegmentRegs;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        BOOL fSegmentDescriptors;
        BOOL fSSERegisters;
        BOOL fSystemRegisters;
        } 	RegGroupSelection;
    DWORD SegCs;
    DWORD SegSs;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD EFlags;
    DWORD Ebp;
    DWORD Eip;
    DWORD Esp;
    DWORD Eax;
    DWORD Ebx;
    DWORD Ecx;
    DWORD Edx;
    DWORD Esi;
    DWORD Edi;
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[ 80 ];
    DWORD Cr0NpxState;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    X86_SEG_DESC_INFO DescriptorCs;
    X86_SEG_DESC_INFO DescriptorSs;
    X86_SEG_DESC_INFO DescriptorGs;
    X86_SEG_DESC_INFO DescriptorFs;
    X86_SEG_DESC_INFO DescriptorEs;
    X86_SEG_DESC_INFO DescriptorDs;
    DWORD IdtBase;
    DWORD IdtLimit;
    DWORD GdtBase;
    DWORD GdtLimit;
    DWORD Ldtr;
    X86_SEG_DESC_INFO DescriptorLdtr;
    DWORD Tr;
    X86_SEG_DESC_INFO DescriptorTr;
    DWORD Cr0;
    DWORD Cr2;
    DWORD Cr3;
    DWORD Cr4;
    DWORD Mxcsr;
    X86_SSE_REG Sse[ 8 ];
    } 	CONTEXT_X86_EX;

typedef struct _CONTEXT_X86_EX *PCONTEXT_X86_EX;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0262_v0_0_s_ifspec;

#ifndef __IeXdiX86ExContext_INTERFACE_DEFINED__
#define __IeXdiX86ExContext_INTERFACE_DEFINED__

/* interface IeXdiX86ExContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiX86ExContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("353ba159-ff30-4af9-86ae-393809fef440")
    IeXdiX86ExContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_X86_EX pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_X86_EX Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiX86ExContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiX86ExContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiX86ExContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiX86ExContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiX86ExContext * This,
            /* [out][in] */ PCONTEXT_X86_EX pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiX86ExContext * This,
            /* [in] */ CONTEXT_X86_EX Context);
        
        END_INTERFACE
    } IeXdiX86ExContextVtbl;

    interface IeXdiX86ExContext
    {
        CONST_VTBL struct IeXdiX86ExContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiX86ExContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiX86ExContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiX86ExContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiX86ExContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiX86ExContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiX86ExContext_GetContext_Proxy( 
    IeXdiX86ExContext * This,
    /* [out][in] */ PCONTEXT_X86_EX pContext);


void __RPC_STUB IeXdiX86ExContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiX86ExContext_SetContext_Proxy( 
    IeXdiX86ExContext * This,
    /* [in] */ CONTEXT_X86_EX Context);


void __RPC_STUB IeXdiX86ExContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiX86ExContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0263 */
/* [local] */ 

// The following constants are bit definitions for the ModeFlags value in CONTEXT_X86_64.
// They are provided to allow debuggers to correctly disassemble instructions based on
// the current operating mode of the processor.
#define X86_64_MODE_D     (0x0001) // D bit from the current CS selector
#define X86_64_MODE_L     (0x0002) // L bit (long mode) from the current CS selector
#define X86_64_MODE_LME   (0x0004) // LME bit (lomg mode enable) from extended feature MSR
#define X86_64_MODE_REX   (0x0008) // REX bit (register extension) from extended feature MSR
typedef struct _SEG64_DESC_INFO
    {
    DWORD64 SegBase;
    DWORD64 SegLimit;
    DWORD SegFlags;
    } 	SEG64_DESC_INFO;

typedef struct _SSE_REG
    {
    DWORD Reg0;
    DWORD Reg1;
    DWORD Reg2;
    DWORD Reg3;
    } 	SSE_REG;

typedef struct _CONTEXT_X86_64
    {
    struct 
        {
        BOOL fSegmentRegs;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        BOOL fSegmentDescriptors;
        BOOL fSSERegisters;
        BOOL fSystemRegisters;
        } 	RegGroupSelection;
    DWORD SegCs;
    DWORD SegSs;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD64 ModeFlags;
    DWORD64 EFlags;
    DWORD64 Rbp;
    DWORD64 Rip;
    DWORD64 Rsp;
    DWORD64 Rax;
    DWORD64 Rbx;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[ 80 ];
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    SEG64_DESC_INFO DescriptorCs;
    SEG64_DESC_INFO DescriptorSs;
    SEG64_DESC_INFO DescriptorGs;
    SEG64_DESC_INFO DescriptorFs;
    SEG64_DESC_INFO DescriptorEs;
    SEG64_DESC_INFO DescriptorDs;
    DWORD64 IDTBase;
    DWORD64 IDTLimit;
    DWORD64 GDTBase;
    DWORD64 GDTLimit;
    DWORD SelLDT;
    SEG64_DESC_INFO SegLDT;
    DWORD SelTSS;
    SEG64_DESC_INFO SegTSS;
    DWORD64 RegCr0;
    DWORD64 RegCr2;
    DWORD64 RegCr3;
    DWORD64 RegCr4;
    DWORD64 RegCr8;
    DWORD RegMXCSR;
    SSE_REG RegSSE[ 16 ];
    } 	CONTEXT_X86_64;

typedef struct _CONTEXT_X86_64 *PCONTEXT_X86_64;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0263_v0_0_s_ifspec;

#ifndef __IeXdiX86_64Context_INTERFACE_DEFINED__
#define __IeXdiX86_64Context_INTERFACE_DEFINED__

/* interface IeXdiX86_64Context */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiX86_64Context;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4795B125-6CDE-4e76-B8D3-D5ED69ECE739")
    IeXdiX86_64Context : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_X86_64 pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_X86_64 Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiX86_64ContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiX86_64Context * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiX86_64Context * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiX86_64Context * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiX86_64Context * This,
            /* [out][in] */ PCONTEXT_X86_64 pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiX86_64Context * This,
            /* [in] */ CONTEXT_X86_64 Context);
        
        END_INTERFACE
    } IeXdiX86_64ContextVtbl;

    interface IeXdiX86_64Context
    {
        CONST_VTBL struct IeXdiX86_64ContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiX86_64Context_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiX86_64Context_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiX86_64Context_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiX86_64Context_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiX86_64Context_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiX86_64Context_GetContext_Proxy( 
    IeXdiX86_64Context * This,
    /* [out][in] */ PCONTEXT_X86_64 pContext);


void __RPC_STUB IeXdiX86_64Context_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiX86_64Context_SetContext_Proxy( 
    IeXdiX86_64Context * This,
    /* [in] */ CONTEXT_X86_64 Context);


void __RPC_STUB IeXdiX86_64Context_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiX86_64Context_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0264 */
/* [local] */ 

typedef struct _CONTEXT_SHX
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD Pr;
    DWORD Mach;
    DWORD Macl;
    DWORD Gbr;
    DWORD Pc;
    DWORD Sr;
    DWORD R0;
    DWORD R1;
    DWORD R2;
    DWORD R3;
    DWORD R4;
    DWORD R5;
    DWORD R6;
    DWORD R7;
    DWORD R8;
    DWORD R9;
    DWORD R10;
    DWORD R11;
    DWORD R12;
    DWORD R13;
    DWORD R14;
    DWORD R15;
    DWORD Fpscr;
    DWORD Fpul;
    DWORD FR_B0[ 16 ];
    DWORD FR_B1[ 16 ];
    DWORD BarA;
    BYTE BasrA;
    BYTE BamrA;
    WORD BbrA;
    DWORD BarB;
    BYTE BasrB;
    BYTE BamrB;
    WORD BbrB;
    DWORD BdrB;
    DWORD BdmrB;
    WORD Brcr;
    WORD Align;
    } 	CONTEXT_SHX;

typedef struct _CONTEXT_SHX *PCONTEXT_SHX;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0264_v0_0_s_ifspec;

#ifndef __IeXdiSHXContext_INTERFACE_DEFINED__
#define __IeXdiSHXContext_INTERFACE_DEFINED__

/* interface IeXdiSHXContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiSHXContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495353475843")
    IeXdiSHXContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_SHX pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_SHX Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiSHXContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiSHXContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiSHXContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiSHXContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiSHXContext * This,
            /* [out][in] */ PCONTEXT_SHX pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiSHXContext * This,
            /* [in] */ CONTEXT_SHX Context);
        
        END_INTERFACE
    } IeXdiSHXContextVtbl;

    interface IeXdiSHXContext
    {
        CONST_VTBL struct IeXdiSHXContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiSHXContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiSHXContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiSHXContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiSHXContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiSHXContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiSHXContext_GetContext_Proxy( 
    IeXdiSHXContext * This,
    /* [out][in] */ PCONTEXT_SHX pContext);


void __RPC_STUB IeXdiSHXContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiSHXContext_SetContext_Proxy( 
    IeXdiSHXContext * This,
    /* [in] */ CONTEXT_SHX Context);


void __RPC_STUB IeXdiSHXContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiSHXContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0265 */
/* [local] */ 

typedef struct _CONTEXT_MIPS
    {
    struct 
        {
        BOOL fMode64bits;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fExceptRegs;
        BOOL fMemoryMgmRegs;
        } 	RegGroupSelection;
    DWORD IntAt;
    DWORD Hi32_IntAt;
    DWORD IntV0;
    DWORD Hi32_IntV0;
    DWORD IntV1;
    DWORD Hi32_IntV1;
    DWORD IntA0;
    DWORD Hi32_IntA0;
    DWORD IntA1;
    DWORD Hi32_IntA1;
    DWORD IntA2;
    DWORD Hi32_IntA2;
    DWORD IntA3;
    DWORD Hi32_IntA3;
    DWORD IntT0;
    DWORD Hi32_IntT0;
    DWORD IntT1;
    DWORD Hi32_IntT1;
    DWORD IntT2;
    DWORD Hi32_IntT2;
    DWORD IntT3;
    DWORD Hi32_IntT3;
    DWORD IntT4;
    DWORD Hi32_IntT4;
    DWORD IntT5;
    DWORD Hi32_IntT5;
    DWORD IntT6;
    DWORD Hi32_IntT6;
    DWORD IntT7;
    DWORD Hi32_IntT7;
    DWORD IntS0;
    DWORD Hi32_IntS0;
    DWORD IntS1;
    DWORD Hi32_IntS1;
    DWORD IntS2;
    DWORD Hi32_IntS2;
    DWORD IntS3;
    DWORD Hi32_IntS3;
    DWORD IntS4;
    DWORD Hi32_IntS4;
    DWORD IntS5;
    DWORD Hi32_IntS5;
    DWORD IntS6;
    DWORD Hi32_IntS6;
    DWORD IntS7;
    DWORD Hi32_IntS7;
    DWORD IntT8;
    DWORD Hi32_IntT8;
    DWORD IntT9;
    DWORD Hi32_IntT9;
    DWORD IntK0;
    DWORD Hi32_IntK0;
    DWORD IntK1;
    DWORD Hi32_IntK1;
    DWORD IntGp;
    DWORD Hi32_IntGp;
    DWORD IntSp;
    DWORD Hi32_IntSp;
    DWORD IntS8;
    DWORD Hi32_IntS8;
    DWORD IntRa;
    DWORD Hi32_IntRa;
    DWORD IntLo;
    DWORD Hi32_IntLo;
    DWORD IntHi;
    DWORD Hi32_IntHi;
    DWORD FltF0;
    DWORD Hi32_FltF0;
    DWORD FltF1;
    DWORD Hi32_FltF1;
    DWORD FltF2;
    DWORD Hi32_FltF2;
    DWORD FltF3;
    DWORD Hi32_FltF3;
    DWORD FltF4;
    DWORD Hi32_FltF4;
    DWORD FltF5;
    DWORD Hi32_FltF5;
    DWORD FltF6;
    DWORD Hi32_FltF6;
    DWORD FltF7;
    DWORD Hi32_FltF7;
    DWORD FltF8;
    DWORD Hi32_FltF8;
    DWORD FltF9;
    DWORD Hi32_FltF9;
    DWORD FltF10;
    DWORD Hi32_FltF10;
    DWORD FltF11;
    DWORD Hi32_FltF11;
    DWORD FltF12;
    DWORD Hi32_FltF12;
    DWORD FltF13;
    DWORD Hi32_FltF13;
    DWORD FltF14;
    DWORD Hi32_FltF14;
    DWORD FltF15;
    DWORD Hi32_FltF15;
    DWORD FltF16;
    DWORD Hi32_FltF16;
    DWORD FltF17;
    DWORD Hi32_FltF17;
    DWORD FltF18;
    DWORD Hi32_FltF18;
    DWORD FltF19;
    DWORD Hi32_FltF19;
    DWORD FltF20;
    DWORD Hi32_FltF20;
    DWORD FltF21;
    DWORD Hi32_FltF21;
    DWORD FltF22;
    DWORD Hi32_FltF22;
    DWORD FltF23;
    DWORD Hi32_FltF23;
    DWORD FltF24;
    DWORD Hi32_FltF24;
    DWORD FltF25;
    DWORD Hi32_FltF25;
    DWORD FltF26;
    DWORD Hi32_FltF26;
    DWORD FltF27;
    DWORD Hi32_FltF27;
    DWORD FltF28;
    DWORD Hi32_FltF28;
    DWORD FltF29;
    DWORD Hi32_FltF29;
    DWORD FltF30;
    DWORD Hi32_FltF30;
    DWORD FltF31;
    DWORD Hi32_FltF31;
    DWORD FCR0;
    DWORD FCR31;
    DWORD Pc;
    DWORD Hi32_Pc;
    DWORD Context;
    DWORD Hi32_Context;
    DWORD BadVAddr;
    DWORD Hi32_BadVAddr;
    DWORD EPC;
    DWORD Hi32_EPC;
    DWORD XContextReg;
    DWORD Hi32_XContextReg;
    DWORD ErrorEPC;
    DWORD Hi32_ErrorEPC;
    DWORD Count;
    DWORD Compare;
    DWORD Sr;
    DWORD Cause;
    DWORD WatchLo;
    DWORD WatchHi;
    DWORD ECC;
    DWORD CacheErr;
    DWORD Index;
    DWORD Random;
    DWORD EntryLo0;
    DWORD Hi32_EntryLo0;
    DWORD EntryLo1;
    DWORD Hi32_EntryLo1;
    DWORD PageMask;
    DWORD Wired;
    DWORD EntryHi;
    DWORD Hi32_EntryHi;
    DWORD PRId;
    DWORD Config;
    DWORD LLAddr;
    DWORD TagLo;
    DWORD TagHi;
    } 	CONTEXT_MIPS;

typedef struct _CONTEXT_MIPS *PCONTEXT_MIPS;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0265_v0_0_s_ifspec;

#ifndef __IeXdiMIPSContext_INTERFACE_DEFINED__
#define __IeXdiMIPSContext_INTERFACE_DEFINED__

/* interface IeXdiMIPSContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiMIPSContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49534D495043")
    IeXdiMIPSContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_MIPS pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_MIPS Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiMIPSContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiMIPSContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiMIPSContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiMIPSContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiMIPSContext * This,
            /* [out][in] */ PCONTEXT_MIPS pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiMIPSContext * This,
            /* [in] */ CONTEXT_MIPS Context);
        
        END_INTERFACE
    } IeXdiMIPSContextVtbl;

    interface IeXdiMIPSContext
    {
        CONST_VTBL struct IeXdiMIPSContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiMIPSContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiMIPSContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiMIPSContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiMIPSContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiMIPSContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiMIPSContext_GetContext_Proxy( 
    IeXdiMIPSContext * This,
    /* [out][in] */ PCONTEXT_MIPS pContext);


void __RPC_STUB IeXdiMIPSContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiMIPSContext_SetContext_Proxy( 
    IeXdiMIPSContext * This,
    /* [in] */ CONTEXT_MIPS Context);


void __RPC_STUB IeXdiMIPSContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiMIPSContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0266 */
/* [local] */ 

typedef struct _CONTEXT_ARM
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD Sp;
    DWORD Lr;
    DWORD Pc;
    DWORD Psr;
    DWORD R0;
    DWORD R1;
    DWORD R2;
    DWORD R3;
    DWORD R4;
    DWORD R5;
    DWORD R6;
    DWORD R7;
    DWORD R8;
    DWORD R9;
    DWORD R10;
    DWORD R11;
    DWORD R12;
    } 	CONTEXT_ARM;

typedef struct _CONTEXT_ARM *PCONTEXT_ARM;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0266_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0266_v0_0_s_ifspec;

#ifndef __IeXdiARMContext_INTERFACE_DEFINED__
#define __IeXdiARMContext_INTERFACE_DEFINED__

/* interface IeXdiARMContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiARMContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495341524D43")
    IeXdiARMContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_ARM pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_ARM Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiARMContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiARMContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiARMContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiARMContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiARMContext * This,
            /* [out][in] */ PCONTEXT_ARM pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiARMContext * This,
            /* [in] */ CONTEXT_ARM Context);
        
        END_INTERFACE
    } IeXdiARMContextVtbl;

    interface IeXdiARMContext
    {
        CONST_VTBL struct IeXdiARMContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiARMContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiARMContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiARMContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiARMContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiARMContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiARMContext_GetContext_Proxy( 
    IeXdiARMContext * This,
    /* [out][in] */ PCONTEXT_ARM pContext);


void __RPC_STUB IeXdiARMContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiARMContext_SetContext_Proxy( 
    IeXdiARMContext * This,
    /* [in] */ CONTEXT_ARM Context);


void __RPC_STUB IeXdiARMContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiARMContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0267 */
/* [local] */ 

typedef struct _CONTEXT_PPC
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    double Fpr0;
    double Fpr1;
    double Fpr2;
    double Fpr3;
    double Fpr4;
    double Fpr5;
    double Fpr6;
    double Fpr7;
    double Fpr8;
    double Fpr9;
    double Fpr10;
    double Fpr11;
    double Fpr12;
    double Fpr13;
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    double Fpscr;
    DWORD Gpr0;
    DWORD Gpr1;
    DWORD Gpr2;
    DWORD Gpr3;
    DWORD Gpr4;
    DWORD Gpr5;
    DWORD Gpr6;
    DWORD Gpr7;
    DWORD Gpr8;
    DWORD Gpr9;
    DWORD Gpr10;
    DWORD Gpr11;
    DWORD Gpr12;
    DWORD Gpr13;
    DWORD Gpr14;
    DWORD Gpr15;
    DWORD Gpr16;
    DWORD Gpr17;
    DWORD Gpr18;
    DWORD Gpr19;
    DWORD Gpr20;
    DWORD Gpr21;
    DWORD Gpr22;
    DWORD Gpr23;
    DWORD Gpr24;
    DWORD Gpr25;
    DWORD Gpr26;
    DWORD Gpr27;
    DWORD Gpr28;
    DWORD Gpr29;
    DWORD Gpr30;
    DWORD Gpr31;
    DWORD Msr;
    DWORD Iar;
    DWORD Lr;
    DWORD Ctr;
    DWORD Cr;
    DWORD Xer;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr4;
    DWORD Dr5;
    DWORD Dr6;
    DWORD Dr7;
    } 	CONTEXT_PPC;

typedef struct _CONTEXT_PPC *PCONTEXT_PPC;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0267_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0267_v0_0_s_ifspec;

#ifndef __IeXdiPPCContext_INTERFACE_DEFINED__
#define __IeXdiPPCContext_INTERFACE_DEFINED__

/* interface IeXdiPPCContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiPPCContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495350504343")
    IeXdiPPCContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_PPC pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_PPC Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiPPCContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiPPCContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiPPCContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiPPCContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiPPCContext * This,
            /* [out][in] */ PCONTEXT_PPC pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiPPCContext * This,
            /* [in] */ CONTEXT_PPC Context);
        
        END_INTERFACE
    } IeXdiPPCContextVtbl;

    interface IeXdiPPCContext
    {
        CONST_VTBL struct IeXdiPPCContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiPPCContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiPPCContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiPPCContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiPPCContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiPPCContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiPPCContext_GetContext_Proxy( 
    IeXdiPPCContext * This,
    /* [out][in] */ PCONTEXT_PPC pContext);


void __RPC_STUB IeXdiPPCContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiPPCContext_SetContext_Proxy( 
    IeXdiPPCContext * This,
    /* [in] */ CONTEXT_PPC Context);


void __RPC_STUB IeXdiPPCContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiPPCContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0268 */
/* [local] */ 

typedef struct _IA64_FLOAT128
    {
    DWORD64 Low;
    DWORD64 High;
    } 	IA64_FLOAT128;

typedef struct _EXDI_CONTEXT_IA64
    {
    struct 
        {
        BOOL fIntegerRegs;
        BOOL fBranchRegs;
        BOOL fLowFloatRegs;
        BOOL fHighFloatRegs;
        BOOL fDebugRegs;
        BOOL fControlRegs;
        BOOL fSystemRegs;
        } 	RegGroupSelection;
    DWORD64 IntR1;
    DWORD64 IntR2;
    DWORD64 IntR3;
    DWORD64 IntR4;
    DWORD64 IntR5;
    DWORD64 IntR6;
    DWORD64 IntR7;
    DWORD64 IntR8;
    DWORD64 IntR9;
    DWORD64 IntR10;
    DWORD64 IntR11;
    DWORD64 IntR12;
    DWORD64 IntR13;
    DWORD64 IntR14;
    DWORD64 IntR15;
    DWORD64 IntR16;
    DWORD64 IntR17;
    DWORD64 IntR18;
    DWORD64 IntR19;
    DWORD64 IntR20;
    DWORD64 IntR21;
    DWORD64 IntR22;
    DWORD64 IntR23;
    DWORD64 IntR24;
    DWORD64 IntR25;
    DWORD64 IntR26;
    DWORD64 IntR27;
    DWORD64 IntR28;
    DWORD64 IntR29;
    DWORD64 IntR30;
    DWORD64 IntR31;
    DWORD64 IntNats;
    DWORD64 Preds;
    DWORD64 Br0;
    DWORD64 Br1;
    DWORD64 Br2;
    DWORD64 Br3;
    DWORD64 Br4;
    DWORD64 Br5;
    DWORD64 Br6;
    DWORD64 Br7;
    DWORD64 StFPSR;
    IA64_FLOAT128 FltF2;
    IA64_FLOAT128 FltF3;
    IA64_FLOAT128 FltF4;
    IA64_FLOAT128 FltF5;
    IA64_FLOAT128 FltF6;
    IA64_FLOAT128 FltF7;
    IA64_FLOAT128 FltF8;
    IA64_FLOAT128 FltF9;
    IA64_FLOAT128 FltF10;
    IA64_FLOAT128 FltF11;
    IA64_FLOAT128 FltF12;
    IA64_FLOAT128 FltF13;
    IA64_FLOAT128 FltF14;
    IA64_FLOAT128 FltF15;
    IA64_FLOAT128 FltF16;
    IA64_FLOAT128 FltF17;
    IA64_FLOAT128 FltF18;
    IA64_FLOAT128 FltF19;
    IA64_FLOAT128 FltF20;
    IA64_FLOAT128 FltF21;
    IA64_FLOAT128 FltF22;
    IA64_FLOAT128 FltF23;
    IA64_FLOAT128 FltF24;
    IA64_FLOAT128 FltF25;
    IA64_FLOAT128 FltF26;
    IA64_FLOAT128 FltF27;
    IA64_FLOAT128 FltF28;
    IA64_FLOAT128 FltF29;
    IA64_FLOAT128 FltF30;
    IA64_FLOAT128 FltF31;
    IA64_FLOAT128 FltF32;
    IA64_FLOAT128 FltF33;
    IA64_FLOAT128 FltF34;
    IA64_FLOAT128 FltF35;
    IA64_FLOAT128 FltF36;
    IA64_FLOAT128 FltF37;
    IA64_FLOAT128 FltF38;
    IA64_FLOAT128 FltF39;
    IA64_FLOAT128 FltF40;
    IA64_FLOAT128 FltF41;
    IA64_FLOAT128 FltF42;
    IA64_FLOAT128 FltF43;
    IA64_FLOAT128 FltF44;
    IA64_FLOAT128 FltF45;
    IA64_FLOAT128 FltF46;
    IA64_FLOAT128 FltF47;
    IA64_FLOAT128 FltF48;
    IA64_FLOAT128 FltF49;
    IA64_FLOAT128 FltF50;
    IA64_FLOAT128 FltF51;
    IA64_FLOAT128 FltF52;
    IA64_FLOAT128 FltF53;
    IA64_FLOAT128 FltF54;
    IA64_FLOAT128 FltF55;
    IA64_FLOAT128 FltF56;
    IA64_FLOAT128 FltF57;
    IA64_FLOAT128 FltF58;
    IA64_FLOAT128 FltF59;
    IA64_FLOAT128 FltF60;
    IA64_FLOAT128 FltF61;
    IA64_FLOAT128 FltF62;
    IA64_FLOAT128 FltF63;
    IA64_FLOAT128 FltF64;
    IA64_FLOAT128 FltF65;
    IA64_FLOAT128 FltF66;
    IA64_FLOAT128 FltF67;
    IA64_FLOAT128 FltF68;
    IA64_FLOAT128 FltF69;
    IA64_FLOAT128 FltF70;
    IA64_FLOAT128 FltF71;
    IA64_FLOAT128 FltF72;
    IA64_FLOAT128 FltF73;
    IA64_FLOAT128 FltF74;
    IA64_FLOAT128 FltF75;
    IA64_FLOAT128 FltF76;
    IA64_FLOAT128 FltF77;
    IA64_FLOAT128 FltF78;
    IA64_FLOAT128 FltF79;
    IA64_FLOAT128 FltF80;
    IA64_FLOAT128 FltF81;
    IA64_FLOAT128 FltF82;
    IA64_FLOAT128 FltF83;
    IA64_FLOAT128 FltF84;
    IA64_FLOAT128 FltF85;
    IA64_FLOAT128 FltF86;
    IA64_FLOAT128 FltF87;
    IA64_FLOAT128 FltF88;
    IA64_FLOAT128 FltF89;
    IA64_FLOAT128 FltF90;
    IA64_FLOAT128 FltF91;
    IA64_FLOAT128 FltF92;
    IA64_FLOAT128 FltF93;
    IA64_FLOAT128 FltF94;
    IA64_FLOAT128 FltF95;
    IA64_FLOAT128 FltF96;
    IA64_FLOAT128 FltF97;
    IA64_FLOAT128 FltF98;
    IA64_FLOAT128 FltF99;
    IA64_FLOAT128 FltF100;
    IA64_FLOAT128 FltF101;
    IA64_FLOAT128 FltF102;
    IA64_FLOAT128 FltF103;
    IA64_FLOAT128 FltF104;
    IA64_FLOAT128 FltF105;
    IA64_FLOAT128 FltF106;
    IA64_FLOAT128 FltF107;
    IA64_FLOAT128 FltF108;
    IA64_FLOAT128 FltF109;
    IA64_FLOAT128 FltF110;
    IA64_FLOAT128 FltF111;
    IA64_FLOAT128 FltF112;
    IA64_FLOAT128 FltF113;
    IA64_FLOAT128 FltF114;
    IA64_FLOAT128 FltF115;
    IA64_FLOAT128 FltF116;
    IA64_FLOAT128 FltF117;
    IA64_FLOAT128 FltF118;
    IA64_FLOAT128 FltF119;
    IA64_FLOAT128 FltF120;
    IA64_FLOAT128 FltF121;
    IA64_FLOAT128 FltF122;
    IA64_FLOAT128 FltF123;
    IA64_FLOAT128 FltF124;
    IA64_FLOAT128 FltF125;
    IA64_FLOAT128 FltF126;
    IA64_FLOAT128 FltF127;
    DWORD64 DbI0;
    DWORD64 DbI1;
    DWORD64 DbI2;
    DWORD64 DbI3;
    DWORD64 DbI4;
    DWORD64 DbI5;
    DWORD64 DbI6;
    DWORD64 DbI7;
    DWORD64 DbD0;
    DWORD64 DbD1;
    DWORD64 DbD2;
    DWORD64 DbD3;
    DWORD64 DbD4;
    DWORD64 DbD5;
    DWORD64 DbD6;
    DWORD64 DbD7;
    DWORD64 ApUNAT;
    DWORD64 ApLC;
    DWORD64 ApEC;
    DWORD64 ApCCV;
    DWORD64 ApDCR;
    DWORD64 RsPFS;
    DWORD64 RsBSP;
    DWORD64 RsBSPSTORE;
    DWORD64 RsRSC;
    DWORD64 RsRNAT;
    DWORD64 StIPSR;
    DWORD64 StIIP;
    DWORD64 StIFS;
    DWORD64 StFCR;
    DWORD64 Eflag;
    DWORD64 SegCSD;
    DWORD64 SegSSD;
    DWORD64 Cflag;
    DWORD64 StFSR;
    DWORD64 StFIR;
    DWORD64 StFDR;
    DWORD64 PfC0;
    DWORD64 PfC1;
    DWORD64 PfC2;
    DWORD64 PfC3;
    DWORD64 PfC4;
    DWORD64 PfC5;
    DWORD64 PfC6;
    DWORD64 PfC7;
    DWORD64 PfD0;
    DWORD64 PfD1;
    DWORD64 PfD2;
    DWORD64 PfD3;
    DWORD64 PfD4;
    DWORD64 PfD5;
    DWORD64 PfD6;
    DWORD64 PfD7;
    DWORD64 IntH16;
    DWORD64 IntH17;
    DWORD64 IntH18;
    DWORD64 IntH19;
    DWORD64 IntH20;
    DWORD64 IntH21;
    DWORD64 IntH22;
    DWORD64 IntH23;
    DWORD64 IntH24;
    DWORD64 IntH25;
    DWORD64 IntH26;
    DWORD64 IntH27;
    DWORD64 IntH28;
    DWORD64 IntH29;
    DWORD64 IntH30;
    DWORD64 IntH31;
    DWORD64 ApCPUID0;
    DWORD64 ApCPUID1;
    DWORD64 ApCPUID2;
    DWORD64 ApCPUID3;
    DWORD64 ApCPUID4;
    DWORD64 ApCPUID5;
    DWORD64 ApCPUID6;
    DWORD64 ApCPUID7;
    DWORD64 ApKR0;
    DWORD64 ApKR1;
    DWORD64 ApKR2;
    DWORD64 ApKR3;
    DWORD64 ApKR4;
    DWORD64 ApKR5;
    DWORD64 ApKR6;
    DWORD64 ApKR7;
    DWORD64 ApITC;
    DWORD64 ApITM;
    DWORD64 ApIVA;
    DWORD64 ApPTA;
    DWORD64 ApGPTA;
    DWORD64 StISR;
    DWORD64 StIFA;
    DWORD64 StITIR;
    DWORD64 StIIPA;
    DWORD64 StIIM;
    DWORD64 StIHA;
    DWORD64 SaLID;
    DWORD64 SaIVR;
    DWORD64 SaTPR;
    DWORD64 SaEOI;
    DWORD64 SaIRR0;
    DWORD64 SaIRR1;
    DWORD64 SaIRR2;
    DWORD64 SaIRR3;
    DWORD64 SaITV;
    DWORD64 SaPMV;
    DWORD64 SaCMCV;
    DWORD64 SaLRR0;
    DWORD64 SaLRR1;
    DWORD64 Rr0;
    DWORD64 Rr1;
    DWORD64 Rr2;
    DWORD64 Rr3;
    DWORD64 Rr4;
    DWORD64 Rr5;
    DWORD64 Rr6;
    DWORD64 Rr7;
    DWORD64 Pkr0;
    DWORD64 Pkr1;
    DWORD64 Pkr2;
    DWORD64 Pkr3;
    DWORD64 Pkr4;
    DWORD64 Pkr5;
    DWORD64 Pkr6;
    DWORD64 Pkr7;
    DWORD64 Pkr8;
    DWORD64 Pkr9;
    DWORD64 Pkr10;
    DWORD64 Pkr11;
    DWORD64 Pkr12;
    DWORD64 Pkr13;
    DWORD64 Pkr14;
    DWORD64 Pkr15;
    DWORD64 TrI0;
    DWORD64 TrI1;
    DWORD64 TrI2;
    DWORD64 TrI3;
    DWORD64 TrI4;
    DWORD64 TrI5;
    DWORD64 TrI6;
    DWORD64 TrI7;
    DWORD64 TrD0;
    DWORD64 TrD1;
    DWORD64 TrD2;
    DWORD64 TrD3;
    DWORD64 TrD4;
    DWORD64 TrD5;
    DWORD64 TrD6;
    DWORD64 TrD7;
    DWORD64 SrMSR0;
    DWORD64 SrMSR1;
    DWORD64 SrMSR2;
    DWORD64 SrMSR3;
    DWORD64 SrMSR4;
    DWORD64 SrMSR5;
    DWORD64 SrMSR6;
    DWORD64 SrMSR7;
    } 	EXDI_CONTEXT_IA64;

typedef struct _EXDI_CONTEXT_IA64 *PEXDI_CONTEXT_IA64;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0268_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0268_v0_0_s_ifspec;

#ifndef __IeXdiIA64Context_INTERFACE_DEFINED__
#define __IeXdiIA64Context_INTERFACE_DEFINED__

/* interface IeXdiIA64Context */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiIA64Context;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40c9adbb-de25-4ef4-a206-024440f78839")
    IeXdiIA64Context : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PEXDI_CONTEXT_IA64 pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ EXDI_CONTEXT_IA64 Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiIA64ContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiIA64Context * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiIA64Context * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiIA64Context * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IeXdiIA64Context * This,
            /* [out][in] */ PEXDI_CONTEXT_IA64 pContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            IeXdiIA64Context * This,
            /* [in] */ EXDI_CONTEXT_IA64 Context);
        
        END_INTERFACE
    } IeXdiIA64ContextVtbl;

    interface IeXdiIA64Context
    {
        CONST_VTBL struct IeXdiIA64ContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiIA64Context_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiIA64Context_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiIA64Context_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiIA64Context_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiIA64Context_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiIA64Context_GetContext_Proxy( 
    IeXdiIA64Context * This,
    /* [out][in] */ PEXDI_CONTEXT_IA64 pContext);


void __RPC_STUB IeXdiIA64Context_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiIA64Context_SetContext_Proxy( 
    IeXdiIA64Context * This,
    /* [in] */ EXDI_CONTEXT_IA64 Context);


void __RPC_STUB IeXdiIA64Context_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiIA64Context_INTERFACE_DEFINED__ */


#ifndef __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__
#define __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__

/* interface IeXdiClientNotifyMemChg */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiClientNotifyMemChg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49434E4D4300")
    IeXdiClientNotifyMemChg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyMemoryChange( 
            /* [in] */ MEM_TYPE mtChanged,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemChanged,
            /* [in] */ BYTE bAccessWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiClientNotifyMemChgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiClientNotifyMemChg * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiClientNotifyMemChg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiClientNotifyMemChg * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyMemoryChange )( 
            IeXdiClientNotifyMemChg * This,
            /* [in] */ MEM_TYPE mtChanged,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemChanged,
            /* [in] */ BYTE bAccessWidth);
        
        END_INTERFACE
    } IeXdiClientNotifyMemChgVtbl;

    interface IeXdiClientNotifyMemChg
    {
        CONST_VTBL struct IeXdiClientNotifyMemChgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiClientNotifyMemChg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiClientNotifyMemChg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiClientNotifyMemChg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiClientNotifyMemChg_NotifyMemoryChange(This,mtChanged,Address,bAddressSpace,dwNbElemChanged,bAccessWidth)	\
    (This)->lpVtbl -> NotifyMemoryChange(This,mtChanged,Address,bAddressSpace,dwNbElemChanged,bAccessWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiClientNotifyMemChg_NotifyMemoryChange_Proxy( 
    IeXdiClientNotifyMemChg * This,
    /* [in] */ MEM_TYPE mtChanged,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemChanged,
    /* [in] */ BYTE bAccessWidth);


void __RPC_STUB IeXdiClientNotifyMemChg_NotifyMemoryChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__ */


#ifndef __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__
#define __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__

/* interface IeXdiClientNotifyRunChg */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiClientNotifyRunChg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49434E525343")
    IeXdiClientNotifyRunChg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyRunStateChange( 
            /* [in] */ RUN_STATUS_TYPE ersCurrent,
            /* [in] */ HALT_REASON_TYPE ehrCurrent,
            /* [in] */ ADDRESS_TYPE CurrentExecAddress,
            /* [in] */ DWORD dwExceptionCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiClientNotifyRunChgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IeXdiClientNotifyRunChg * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IeXdiClientNotifyRunChg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IeXdiClientNotifyRunChg * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyRunStateChange )( 
            IeXdiClientNotifyRunChg * This,
            /* [in] */ RUN_STATUS_TYPE ersCurrent,
            /* [in] */ HALT_REASON_TYPE ehrCurrent,
            /* [in] */ ADDRESS_TYPE CurrentExecAddress,
            /* [in] */ DWORD dwExceptionCode);
        
        END_INTERFACE
    } IeXdiClientNotifyRunChgVtbl;

    interface IeXdiClientNotifyRunChg
    {
        CONST_VTBL struct IeXdiClientNotifyRunChgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiClientNotifyRunChg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiClientNotifyRunChg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiClientNotifyRunChg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiClientNotifyRunChg_NotifyRunStateChange(This,ersCurrent,ehrCurrent,CurrentExecAddress,dwExceptionCode)	\
    (This)->lpVtbl -> NotifyRunStateChange(This,ersCurrent,ehrCurrent,CurrentExecAddress,dwExceptionCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiClientNotifyRunChg_NotifyRunStateChange_Proxy( 
    IeXdiClientNotifyRunChg * This,
    /* [in] */ RUN_STATUS_TYPE ersCurrent,
    /* [in] */ HALT_REASON_TYPE ehrCurrent,
    /* [in] */ ADDRESS_TYPE CurrentExecAddress,
    /* [in] */ DWORD dwExceptionCode);


void __RPC_STUB IeXdiClientNotifyRunChg_NotifyRunStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\assign\assign.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    assign.cpp

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Andre Vachon (andreva)
    
    bugcheck analyzer.

--*/

#include "precomp.h"
#include "mapistuff.h"


DECLARE_API( assign )
{
    ULONG Platform, MajorVer, MinorVer, SrvPack, StringUsed;
    CHAR  BuildString[100];
    EXT_GET_FAILURE_ANALYSIS pfnGetAnalysis;
    PDEBUG_FAILURE_ANALYSIS pAnalysis = NULL;
    HANDLE hAssign;
    CHAR Text[4096];
    CHAR CorruptMods[1024];
    HRESULT hRes = S_FALSE;
    FA_ENTRY* Entry;

    INIT_API();

    g_ExtControl->GetSystemVersion(&Platform, &MajorVer, &MinorVer, NULL,
                                   0, NULL, &SrvPack, &BuildString[0],
                                   sizeof(BuildString), &StringUsed);

    if (S_OK == g_ExtControl->GetExtensionFunction(0, "GetFailureAnalysis",
                                                   (FARPROC*)&pfnGetAnalysis))
    {
        (*pfnGetAnalysis)(Client, 0, &pAnalysis);
    }

    if (pAnalysis)
    {
        //
        // If we are not doing assignment, just print the output
        //

        if (!*args)
        {
            ULONG i;

            g_ExtControl->Output(1, "Analysis data structure output\n");
            g_ExtControl->Output(1, "\n");
            g_ExtControl->Output(1, "Failure code %08lx\n", pAnalysis->GetFailureCode());

            Entry = pAnalysis->Get(DEBUG_FLR_FOLLOWUP_NAME);
            g_ExtControl->Output(1, "Followup Name : %s\n", Entry ?
                                 FA_ENTRY_DATA(PCHAR, Entry) : "<none>");
            Entry = pAnalysis->Get(DEBUG_FLR_BUCKET_ID);
            g_ExtControl->Output(1, "BucketId      : %s\n", Entry ?
                                 FA_ENTRY_DATA(PCHAR, Entry) : "<none>");

            Entry = NULL;
            while (Entry = pAnalysis->NextEntry(Entry)) {

                g_ExtControl->Output(1,
                                     "Type = %08lx - Size = %08lx\n",
                                     Entry->Tag, Entry->DataSize);
            }

            hRes = S_OK;
        }

        if (!pAnalysis->Get(DEBUG_FLR_BUCKET_ID))
        {
            dprintf("missing bucket ID\n");
            sprintf(Text, "%s\n", args);
          //SendOffFailure("andreva",
          //               "bugcheck assignment failed - no bucket",
          //               Text);
        }
        else if (!pAnalysis->Get(DEBUG_FLR_FOLLOWUP_NAME))
        {
            dprintf("missing FollowUp\n");
            sprintf(Text, "%s\n", args);
          //SendOffFailure("andreva",
          //               "bugcheck assignment failed - no followup",
          //               Text);
        }
        else if (*args)
        {
            CHAR *rootDir;
            CHAR *dumpPath;
            CHAR *dumpFile;
            CHAR *parg;
            CHAR  arg[MAX_PATH];
            CHAR  dump[MAX_PATH];
            CHAR  bucketDir[MAX_PATH];
            CHAR  newfile[MAX_PATH];
            CHAR  assignedTo[MAX_PATH];
            CHAR  followupdir[MAX_PATH];

            strcpy(arg, args);

            parg = rootDir = arg;

            while (*parg && (*parg != ' ')) {parg++;}
            while (*parg && (*parg == ' ')) {*parg++ = 0;}
            dumpPath = parg;

            while (*parg && (*parg != ' ')) {parg++;}
            while (*parg && (*parg == ' ')) {*parg++ = 0;}
            dumpFile = parg;

            if (*rootDir && *dumpPath && *dumpFile)
            {
                sprintf(dump, "%s\\%s", dumpPath, dumpFile);

                CreateDirectory(rootDir, NULL);

                // create followup\bugcheck directory

                if ((Entry = pAnalysis->Get(DEBUG_FLR_POOL_CORRUPTOR)) ||
                    (Entry = pAnalysis->Get(DEBUG_FLR_MEMORY_CORRUPTOR)))
                {
                    sprintf(followupdir, "%s\\corruption-%s", rootDir,
                            FA_ENTRY_DATA(PCHAR, Entry));
                }
                else
                {
                    sprintf(followupdir, "%s\\%s", rootDir,
                            FA_ENTRY_DATA(PCHAR,
                                          pAnalysis->Get(DEBUG_FLR_FOLLOWUP_NAME)));
                }

                CreateDirectory(followupdir, NULL);

                sprintf(bucketDir, "%s\\%s", followupdir,
                        FA_ENTRY_DATA(PCHAR,
                                      pAnalysis->Get(DEBUG_FLR_BUCKET_ID)));

                CreateDirectory(bucketDir, NULL);

                sprintf(newfile, "%s\\%s", bucketDir, dumpFile);

                dprintf("%s\n", newfile);

                CopyFile(dump, newfile, 0);

                //
                // See if this succeeded correctly
                // put a marker in the root if it did
                //

                hAssign = CreateFile(newfile,
                                     GENERIC_READ | GENERIC_WRITE,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL);

                if (hAssign != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hAssign);

                    hRes = S_OK;

#if 0
                    //
                    // Check to see if this directory already has this failure
                    // assigned to someone.
                    //

                    hAssign = CreateFile(assignedTo,
                                         GENERIC_READ | GENERIC_WRITE,
                                         0,
                                         NULL,
                                         OPEN_EXISTING,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL);

                    if (hAssign == INVALID_HANDLE_VALUE)
                    {
                        hAssign = CreateFile(assignedTo,
                                             GENERIC_READ | GENERIC_WRITE,
                                             0,
                                             NULL,
                                             CREATE_NEW,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL);

                        CHAR Title[1024];

                        sprintf(Title,
                                "Bugcheck %s",
                                FA_ENTRY_DATA(PCHAR,
                                              pAnalysis->Get(DEBUG_FLR_BUCKET_ID)));

                        sprintf(Text,
                                "To debuger this dump file, run\n"
                                "\n"
                                "kd -z %s -y SRV*\\\\symbols\\symbols "
                                "-i SRV*\\\\symbols\\symbols\n"
                                "\n"
                                "If this failure should not have been assigned to "
                                "you, please send mail to \"dbg\"\n"
                                "If you can not debug this dump file, "
                                "please send mail to \"dbg\"\n"
                                "If you have any other issues with this dump file"
                                "please send mail to \"dbg\"\n"
                                "\n"
                                "We unfortunately do not know the origin of this "
                                " dump file.\n",
                                newfile);

                        SendOffFailure(FA_ENTRY_DATA(PCHAR, pAnalysis->Get(DEBUG_FLR_FOLLOWUP_NAME)),
                                       Title,
                                       Text);
                    }

                    if (hAssign != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hAssign);
                    }
#endif

                }
            }
        }

        pAnalysis->Release();
    }


    EXIT_API();
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\assign\kext.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass, g_TargetQual;
ULONG   g_TargetBuild;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG MajorVer, Platform, MinorVer, SrvPack;
                if ((Hr = DebugControl->GetSystemVersion(&Platform, &MajorVer,
                                         &MinorVer, NULL,
                                         0, NULL,
                                         &SrvPack, NULL,
                                         0, NULL)) == S_OK) {
                    g_TargetBuild = MinorVer;
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &g_TargetQual)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\assign\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>
#include "extsfns.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#ifndef EXTENSION_API
#define EXTENSION_API( name )  \
HRESULT _EFN_##name
#endif // EXTENSION_API

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetQual;
extern ULONG g_TargetBuild;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\eng\engexts\engexts.cpp ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#define DEBUG_NO_IMPLEMENTATION
#include <engexts.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_DATA_SPACES2   g_ExtData2;
PDEBUG_DATA_SPACES3   g_ExtData3;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    //
    // Required interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    //
    // Optional interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData2)) != S_OK)
    {
        g_ExtData2 = NULL;
    }
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces3),
                                         (void **)&g_ExtData3)) != S_OK)
    {
        g_ExtData3 = NULL;
    }
    
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtData2);
    EXT_RELEASE(g_ExtData3);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\eng\engexts\engexts.h ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __ENGEXTS_H__
#define __ENGEXTS_H__

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_DATA_SPACES2   g_ExtData2;
extern PDEBUG_DATA_SPACES3   g_ExtData3;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Prototype just to force the extern "C".
// The implementation of these functions are not provided.
HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags);
void CALLBACK DebugExtensionUninitialize(void);

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

#ifdef __cplusplus
}
#endif

#endif // #ifndef __ENGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\bugcheck.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    bugcheck.cpp

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

    Andre Vachon (andreva)

    bugcheck analyzer.

--*/

#include "precomp.h"

#pragma hdrstop

extern BUGDESC_APIREFS g_BugDescApiRefs[];
extern ULONG           g_NumBugDescApiRefs;

PSTR g_PoolRegion[DbgPoolRegionMax] = {
    "Unknown",                      // DbgPoolRegionUnknown,
    "Special pool",                 // DbgPoolRegionSpecial,
    "Paged pool",                   // DbgPoolRegionPaged,
    "Nonpaged pool",                // DbgPoolRegionNonPaged,
    "Pool code",                    // DbgPoolRegionCode,
    "Nonpaged pool expansion",      // DbgPoolRegionNonPagedExpansion,
};

/*
   Get the description record for a bugcheck code.
*/

BOOL
GetBugCheckDescription(
    PBUGCHECK_ANALYSIS Bc
    )
{
    ULONG i;
    for (i=0; i<g_NumBugDescApiRefs; i++) {
        if (g_BugDescApiRefs[i].Code == Bc->Code) {
            (g_BugDescApiRefs[i].pExamineRoutine)(Bc);
            return TRUE;
        }
    }
    return FALSE;
}

void
PrintBugDescription(
    PBUGCHECK_ANALYSIS pBugCheck
    )
{
    LPTSTR Name = pBugCheck->szName;
    LPTSTR Description = pBugCheck->szDescription;

    if (!Name)
    {
        Name = "Unknown bugcheck code";
    }

    if (!Description)
    {
        Description = "Unknown bugcheck description\n";
    }

    dprintf("%s (%lx)\n%s", Name, pBugCheck->Code, Description);

    dprintf("Arguments:\n");
    for (ULONG i=0; i<4; i++) {
        dprintf("Arg%lx: %p",i+1,pBugCheck->Args[i]);
        if (pBugCheck->szParamsDesc[i]) {
            dprintf(", %s", pBugCheck->szParamsDesc[i]);
        }
        dprintf("\n");
    }
}

BOOL
SaveImageName(
    DebugFailureAnalysis* Analysis,
    LPSTR DriverName)
{
    PCHAR BaseName = strrchr(DriverName, '\\');

    if (BaseName)
    {
        BaseName++;
    }
    else
    {
        BaseName = DriverName;
    }

    if (*BaseName)
    {
        Analysis->SetString(DEBUG_FLR_IMAGE_NAME, BaseName);

        //
        // Just create a best guess module name because I don't think
        // the driver name returned by theOs is guaranteed to be in
        // the loaded module list (it could be unlaoded)
        //

        PCHAR EndName;

        if (EndName = strrchr(DriverName, '.'))
        {
            *EndName = 0;
        }

        Analysis->SetString(DEBUG_FLR_MODULE_NAME, BaseName);

        return TRUE;
    }

    return FALSE;
}



BOOL
ReadUnicodeString(
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG BufferSize,
    PULONG StringSize)
{
    UNICODE_STRING64 uStr;
    UNICODE_STRING32 uStr32;
    ULONG res;

    if (!Buffer) {
        return FALSE;
    }
    if (!IsPtr64()) {

        if (!ReadMemory(Address, &uStr32, sizeof(uStr32), &res)) {
            return FALSE;
        }
        uStr.Length = uStr32.Length;
        uStr.MaximumLength = uStr32.MaximumLength;
        uStr.Buffer = (ULONG64) (LONG64) (LONG) uStr32.Buffer;
    } else {
        if (!ReadMemory(Address, &uStr, sizeof(uStr), &res)) {
            return FALSE;
        }

    }
    if (StringSize) {
        *StringSize = uStr.Length;
    }
    uStr.Length = (USHORT) min(BufferSize - 2, uStr.Length);

    if (!ReadMemory(uStr.Buffer, Buffer, uStr.Length, &res)) {
        return FALSE;
    }
    return TRUE;
}



/*
 Add driver name to CrashInfo if a KiBugCheckReferences a valid name
 */
BOOL
AddBugcheckDriver(
    DebugFailureAnalysis* Analysis,
    BOOL bUnicodeString,
    BOOL bUnicodeData,
    ULONG64 BugCheckDriver
    )
{
    CHAR DriverName[MAX_PATH];

    if (Analysis->Get(DEBUG_FLR_IMAGE_NAME))
    {
        return FALSE;
    }

    if (!BugCheckDriver)
    {
        //
        // This contains a pointer to the unicode string.
        //

        BugCheckDriver = GetExpression("NT!KiBugCheckDriver");

        if (BugCheckDriver)
        {
            ReadPointer(BugCheckDriver, &BugCheckDriver);
        }
    }

    if (BugCheckDriver)
    {
        ULONG length = 0;
        BOOL success;
        ULONG size;
        ULONG res;

        ZeroMemory(DriverName, sizeof(DriverName));

        if (bUnicodeString)
        {
            success = ReadUnicodeString(BugCheckDriver,
                                        (PWCHAR) &DriverName[0],
                                        sizeof(DriverName), &length);
        }
        else
        {
            size = bUnicodeData ? 2 : 1;

            while (ReadMemory(BugCheckDriver + length,
                              DriverName + length,
                              size,
                              &res) &&
                   (res == size) &&
                   *(DriverName + length))
            {
                length += size;
            }
            success = (length > 0);
        }

        if (success)
        {
            DriverName[length] = 0;

            if (bUnicodeData)
            {
                wchr2ansi((PWCHAR) DriverName, DriverName);
                DriverName[length / 2] = 0;
            }

            return SaveImageName(Analysis, DriverName);
        }
    }

    return FALSE;
}


BOOL
BcGetDriverNameFromIrp(
    DebugFailureAnalysis* Analysis,
    ULONG64 Irp,
    ULONG64 DevObj,
    ULONG64 DrvObj
    )
{
    if (Irp != 0)
    {
        DEBUG_IRP_INFO IrpInfo;
        PGET_IRP_INFO GetIrpInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetIrpInfo", (FARPROC*)&GetIrpInfo) == S_OK)
        {
            IrpInfo.SizeOfStruct = sizeof(IrpInfo);
            if (GetIrpInfo &&
                ((*GetIrpInfo)(g_ExtClient,Irp, &IrpInfo) == S_OK))
            {
                DevObj = IrpInfo.CurrentStack.DeviceObject;
                Analysis->SetUlong64(DEBUG_FLR_DEVICE_OBJECT, DevObj);
            }
        }

    }

    if (DevObj != 0)
    {
        DEBUG_DEVICE_OBJECT_INFO DevObjInfo;
        PGET_DEVICE_OBJECT_INFO GetDevObjInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetDevObjInfo", (FARPROC*)&GetDevObjInfo) == S_OK)
        {
            DevObjInfo.SizeOfStruct = sizeof(DEBUG_DEVICE_OBJECT_INFO);
            if (GetDevObjInfo &&
                ((*GetDevObjInfo)(g_ExtClient,DevObj, &DevObjInfo) == S_OK))
            {
                DrvObj = DevObjInfo.DriverObject;
                Analysis->SetUlong64(DEBUG_FLR_DRIVER_OBJECT, DrvObj);
            }
        }
    }

    if (DrvObj)
    {
        DEBUG_DRIVER_OBJECT_INFO DrvObjInfo;
        PGET_DRIVER_OBJECT_INFO GetDrvObjInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetDrvObjInfo",
                                               (FARPROC*)&GetDrvObjInfo) == S_OK)
        {
            DrvObjInfo.SizeOfStruct = sizeof(DEBUG_DRIVER_OBJECT_INFO);
            if (GetDrvObjInfo &&
                ((*GetDrvObjInfo)(g_ExtClient,DrvObj, &DrvObjInfo) == S_OK))
            {
                if (AddBugcheckDriver(Analysis, FALSE, TRUE,
                                      DrvObjInfo.DriverName.Buffer))
                {
                    return TRUE;
                }
            }

            CHAR DriverName[MAX_PATH];

            if (g_ExtSymbols->GetModuleNames(DEBUG_ANY_ID,
                                             DrvObjInfo.DriverStart,
                                             DriverName,
                                             sizeof(DriverName),
                                             NULL,
                                             NULL, 0, NULL,
                                             NULL, 0, NULL) == S_OK)
            {
                return SaveImageName(Analysis, DriverName);
            }
        }
    }

    return FALSE;
}


ULONG64
BcTargetKernelAddressStart(
    void
    )
{
    switch (g_TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        return 0x80000000;
    case IMAGE_FILE_MACHINE_AMD64:
//        return 0x80000000000UI64;
    case IMAGE_FILE_MACHINE_IA64:
        return 0x2000000000000000UI64;
    }
    return 0;
}

BOOL
BcIsCpuOverClocked(
    void
    )
{
    struct _IntelCPUSpeeds
    {
        union
        {
            ULONG CpuId;
            struct
            {
                ULONG Stepping:8;
                ULONG Model:8;
                ULONG Family:16;
            } s;
        };
        ULONG Mhz;
    } IntelSpeeds[] = {
        {0x06060d, 350},
        //{0x060702, 450},
        {0x060702, 500},
        //{0x060703, 450},
        //{0x060703, 500},
        //{0x060703, 550},
        //{0x060703, 533},
        {0x060703, 600},
        //{0x060801, 500},
        //{0x060801, 533},
        //{0x060801, 550},
        //{0x060801, 600},
        //{0x060801, 650},
        //{0x060801, 667},
        //{0x060801, 700},
        //{0x060801, 733},
        //{0x060801, 750},
        {0x060801, 800},
        //{0x060803, 500},
        //{0x060803, 533},
        //{0x060803, 550},
        //{0x060803, 600},
        //{0x060803, 650},
        //{0x060803, 667},
        //{0x060803, 700},
        //{0x060803, 733},
        //{0x060803, 750},
        //{0x060803, 800},
        //{0x060803, 850},
        //{0x060803, 866},
        //{0x060803, 933},
        {0x060803, 1000},
        //{0x060806, 600},
        //{0x060806, 650},
        //{0x060806, 667},
        //{0x060806, 700},
        //{0x060806, 733},
        //{0x060806, 750},
        //{0x060806, 800},
        //{0x060806, 850},
        //{0x060806, 866},
        //{0x060806, 900},
        //{0x060806, 933},
        {0x060806, 1000},
        //{0x06080A, 700},
        //{0x06080A, 733},
        //{0x06080A, 750},
        //{0x06080A, 800},
        //{0x06080A, 850},
        //{0x06080A, 866},
        //{0x06080A, 933},
        //{0x06080A, 1100},
        {0x06080A, 1130},
        //{0x060B01, 1000},
        //{0x060B01, 1130},
        //{0x060B01, 1200},
        {0x060B01, 1260},
        {0, 0},
    };
    PROCESSORINFO ProcInfo;
    ULONG Processor;
    ULONG64 Prcb;
    HRESULT Hr;
    ULONG Mhz;
    ULONG Number;
    ULONG CpuType;
    ULONG CpuStep;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL IdAll;

    if (g_TargetMachine != IMAGE_FILE_MACHINE_I386)
    {
        return FALSE;
    }

    if (!Ioctl(IG_KD_CONTEXT, &ProcInfo, sizeof(ProcInfo)))
    {
        return FALSE;
    }

    Processor = ProcInfo.Processor;

    Hr = g_ExtData->ReadProcessorSystemData(Processor,
                                            DEBUG_DATA_KPRCB_OFFSET,
                                            &Prcb,
                                            sizeof(Prcb),
                                            NULL);
    if (Hr != S_OK)
    {
        return FALSE;
    }

    if (g_ExtData->
        ReadProcessorSystemData(Processor,
                                DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                &IdAll, sizeof(IdAll), NULL) != S_OK)
    {
        return FALSE;
    }

    if (g_ExtData->
        ReadProcessorSystemData(Processor,
                                DEBUG_DATA_PROCESSOR_SPEED,
                                &Mhz, sizeof(Mhz), NULL) != S_OK)
    {
        return FALSE;

    }


    {
        ULONG Speed;
        ULONG CpuId;

        CpuId = (IdAll.X86.Family << 16) + (IdAll.X86.Model << 8) + IdAll.X86.Stepping;

        if (!strcmp(IdAll.X86.VendorString, "GenuineIntel"))
        {
            for (ULONG i=0; IntelSpeeds[i].CpuId !=0; ++i)
            {
                if (IntelSpeeds[i].CpuId == CpuId)
                {
                    //
                    // If the part is within 2% of the MHz, it's OK.
                    //
                    if (Mhz > (IntelSpeeds[i].Mhz * 1.02))
                    {
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


HRESULT
ExtGetPoolData(
    ULONG64 Pool,
    PDEBUG_POOL_DATA pPoolData
    )
{
    PGET_POOL_DATA pGetPoolData = NULL;

    if (g_ExtControl->
        GetExtensionFunction(0, "GetPoolData",
                         (FARPROC*)&pGetPoolData) == S_OK &&
        pGetPoolData)
    {
        return (*pGetPoolData)(g_ExtClient, Pool, pPoolData);
    }
    return E_FAIL;
}

#define DECL_GETINFO(bcname)         \
        void                         \
        GetInfoFor##bcname (         \
            PBUGCHECK_ANALYSIS Bc,   \
            KernelDebugFailureAnalysis* Analysis \
            )


//DUPINFOCASE( DRIVER_IRQL_NOT_LESS_OR_EQUAL ); //0xD1
DECL_GETINFO( IRQL_NOT_LESS_OR_EQUAL ) // (0xA)
/*
 * Parameters
 *
 * Parameter 1  Memory referenced
 * Parameter 2  IRQL Value
 * Parameter 3  0 - Read 1 - Write
 * Parameter 4  Address that referenced the memory
 *
 *
 * Special Case
 *
 * If Parameter 3 is nonzero and equal to Parameter 1, this means that
 * a worker routine returned at a raised IRQL.
 * In this case:
 *
 * Parameter 1  Address of work routine
 * Parameter 2  IRQL at time of reference
 * Parameter 3  Address of work routine
 * Parameter 4  Work item
 *
*/
{
    if ((Bc->Args[0] == Bc->Args[2]) && Bc->Args[2])
    {
        // special case
        Analysis->SetUlong64(DEBUG_FLR_WORKER_ROUTINE, Bc->Args[2]);
        Analysis->SetUlong64(DEBUG_FLR_WORK_ITEM, Bc->Args[3]);
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        return;
    }

    Analysis->SetUlong64(Bc->Args[2] ?
                         DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                         Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[3]);

    if (Bc->Args[0] == Bc->Args[3] &&
        Bc->Args[2] == 0)
    {
        Analysis->SetString(DEBUG_FLR_BUGCHECK_SPECIFIER, "_CODE_AV");
    }

}

DECL_GETINFO( MEMORY_MANAGEMENT ) // 0x1A
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
}


DECL_GETINFO( KMODE_EXCEPTION_NOT_HANDLED ) //  (1e)
{
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_CODE, Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[1]);
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_PARAMETER1, Bc->Args[2]);
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_PARAMETER2, Bc->Args[3]);
    if ((ULONG)Bc->Args[0] == STATUS_ACCESS_VIOLATION)
    {
        Analysis->SetUlong64(Bc->Args[2] ?
                             DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                             Bc->Args[3]);
    }
}


DECL_GETINFO( FAT_FILE_SYSTEM ) // 0x23
{
    ULONG64 ExR = 0, CxR = 0;
    ULONG64 KernAddrStart;


    KernAddrStart = BcTargetKernelAddressStart();

    if (Bc->Args[1] > KernAddrStart) {
        ExR = Bc->Args[1];
    }
    if (Bc->Args[2] > KernAddrStart) {
        CxR = Bc->Args[2];
    }

    if (ExR) {
        Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_RECORD, ExR);
    }
    if (CxR) {
        Analysis->SetUlong64(DEBUG_FLR_CONTEXT, CxR);
    }
}

DECL_GETINFO( PANIC_STACK_SWITCH ) // 0x2b
{
    Analysis->SetUlong64(DEBUG_FLR_TRAP_FRAME, Bc->Args[0]);
}

DECL_GETINFO( SYSTEM_SERVICE_EXCEPTION ) // 0x3b
{
    Analysis->SetUlong64(DEBUG_FLR_CONTEXT, Bc->Args[2]);
}

DECL_GETINFO( MULTIPLE_IRP_COMPLETE_REQUESTS ) // 0x44
{
    Analysis->SetUlong64(DEBUG_FLR_IRP_ADDRESS, Bc->Args[0]);
}

DECL_GETINFO( SESSION3_INITIALIZATION_FAILED ) // 0x6f
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lX_%lX", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
}


DECL_GETINFO( PROCESS_HAS_LOCKED_PAGES ) // 0x76
{
    Analysis->SetUlong64(DEBUG_FLR_PROCESS_OBJECT, Bc->Args[1]);

    Analysis->SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "DRIVER_FAULT_0x76");

#if 0
    Analysis->SetString(DEBUG_FLR_INTERNAL_SOLUTION_TEXT,
                        "An unknown driver has left locked pages in the kernel"
                        ".\nUsing the registry editor, set HKLM\\SYSTEM\\"
                        "CurrentControlSet\\Control\\Session Manager\\"
                        "Memory Management\\TrackLockedPages to a DWORD value"
                        " of 1, and then reboot the machine.\n\n"
                        "If the problem reproduces, the "
                        "guilty driver will now be identifiable.\n");
#endif
}


DECL_GETINFO( KERNEL_STACK_INPAGE_ERROR ) // 0x77
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
    Analysis->SetUlong(DEBUG_FLR_STATUS_CODE, (ULONG)Bc->Args[0]);

    switch ((ULONG) Bc->Args[0])
    {
    case 0xc000009c: // (STATUS_DEVICE_DATA_ERROR)
    case 0xC000016A: // (STATUS_DISK_OPERATION_FAILED)
        Analysis->SetUlong(DEBUG_FLR_DISK_HARDWARE_ERROR, 1);
        break;
    default:
        break;
    }
}

DECL_GETINFO( KERNEL_DATA_INPAGE_ERROR ) // 0x7A
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[1]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
    Analysis->SetUlong(DEBUG_FLR_STATUS_CODE, (ULONG) Bc->Args[1]);

    switch ( (ULONG) Bc->Args[1])
    {
    case 0xC000000E: case 0xC000009C:
    case 0xC000009D: case 0xC0000185:
        Analysis->SetUlong(DEBUG_FLR_DISK_HARDWARE_ERROR, 1);
        break;
    default:
        break;
    }

}

DECL_GETINFO( SYSTEM_THREAD_EXCEPTION_NOT_HANDLED ) //  (7e)
{
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_CODE, Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[1]);
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_PARAMETER1, Bc->Args[2]);
    Analysis->SetUlong64(DEBUG_FLR_CONTEXT, Bc->Args[3]);
}

DECL_GETINFO( BUGCODE_NDIS_DRIVER ) //0x7c
{
    ULONG64 DriverAddr, DriverBase;

    DriverAddr = 0;

    g_ExtSymbols->Reload("ndis.sys");
    switch (Bc->Args[0])
    {
    case 1: case 2: case 3:
    case 5: case 6: case 7: case 8: case 9:
        // Args[1] -  A pointer to Miniport block. !ndiskd.miniport on this pointer for more info.
        GetFieldValue(Bc->Args[1], "ndis!NDIS_MINIPORT_BLOCK", "SavedSendHandler", DriverAddr);
        if (!DriverAddr)
        {
            GetFieldValue(Bc->Args[1], "ndis!NDIS_MINIPORT_BLOCK", "SavedSendPacketsHandler", DriverAddr);
        }
        break;
    case 4:
        // Arg[1] - a pointer to ndis!NDIS_M_DRIVER_BLOCK

        GetFieldValue(Bc->Args[1], "ndis!NDIS_M_DRIVER_BLOCK", "MiniportCharacteristics.InitializeHandler", DriverAddr);
        break;
    default:
        break;
    }
    if (DriverAddr &&
        (g_ExtSymbols->GetModuleByOffset(DriverAddr, 0, NULL, &DriverBase) == S_OK))
    {
        if (DriverBase)
        {
            Analysis->SetUlong64(DEBUG_FLR_FAULTING_MODULE, DriverBase);
        }
    }

    return ;
}


DECL_GETINFO( UNEXPECTED_KERNEL_MODE_TRAP ) // (7f)
// It would be good to have TSS or TRAP address as exception parameter
{
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    ULONG frames, i;
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);

    if ((g_TargetMachine == IMAGE_FILE_MACHINE_I386) &&
        (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES,
                                     &frames ) == S_OK))
    {
        for (i=0; i<frames; ++i)
        {
            if (stk[i].FuncTableEntry)
            {
                PFPO_DATA FpoData = (PFPO_DATA)stk[i].FuncTableEntry;
                if (FpoData->cbFrame == FRAME_TSS)
                {
                    Analysis->SetUlong64(DEBUG_FLR_TSS,
                                         (ULONG)stk[i].Reserved[1]);
                    break;
                }
                // KiSystemService always has a trap frame - thats normal
                else if ( (FpoData->cbFrame == FRAME_TRAP) &&
                          !FaIsFunctionAddr(stk[i].InstructionOffset,
                                           "KiSystemService"))
                {
                    Analysis->SetUlong64(DEBUG_FLR_TRAP_FRAME,
                                         (ULONG)stk[i].Reserved[2]);
                    break;
                }
                //if (FaIsFunctionAddr(stk[i].InstructionOffset, "KiTrap"))
                //{
                //    TrapFrame = stk[i].FrameOffset;
                //    break;
                //}
            }
        }
    }
}


DECL_GETINFO( KERNEL_MODE_EXCEPTION_NOT_HANDLED ) //  (8e)
{
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_CODE, Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[1]);
    Analysis->SetUlong64(DEBUG_FLR_TRAP_FRAME, Bc->Args[2]);
}

DECL_GETINFO( MACHINE_CHECK_EXCEPTION ) // 0x9C
{
    DEBUG_PROCESSOR_IDENTIFICATION_ALL IdAll;
    CHAR BugCheckStr[4+5+17+3]; // space for vendor string, etc.
    PROCESSORINFO ProcInfo;
    ULONG64 Prcb;
    PCHAR Architecture;
    PCHAR Vendor;
    ULONG Processor;
    HRESULT Hr;

    if (!Ioctl(IG_KD_CONTEXT, &ProcInfo, sizeof(ProcInfo)))
    {
        return;
    }

    Processor = ProcInfo.Processor;

    //
    // Make sure we can find the PRCB before we ask for identification
    // information that would've been acquired from the PRCB.
    //

    Hr = g_ExtData->ReadProcessorSystemData(Processor,
                                            DEBUG_DATA_KPRCB_OFFSET,
                                            &Prcb,
                                            sizeof(Prcb),
                                            NULL);
    if (Hr != S_OK)
    {
        return;
    }

    Hr = g_ExtData->ReadProcessorSystemData(Processor,
                                            DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                            &IdAll,
                                            sizeof(IdAll),
                                            NULL);
    if (Hr != S_OK)
    {
        return;
    }

    switch (g_TargetMachine) {
    case IMAGE_FILE_MACHINE_I386:
        Architecture = "IA32";
        Vendor = IdAll.X86.VendorString;
        break;
    case IMAGE_FILE_MACHINE_IA64:
        Architecture = "IA64";
        Vendor = IdAll.Ia64.VendorString;
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        Architecture = "AMD64";
        Vendor = IdAll.Amd64.VendorString;
        break;
    default:
        // use the standard bugcheck string
        return;
    }
    sprintf(BugCheckStr, "0x%lX_%s_%s", Bc->Code, Architecture, Vendor);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
}

DECL_GETINFO( USER_MODE_HEALTH_MONITOR ) // 0x9E
{
    if (Bc->Args[0])
    {
        ULONG result;
        CHAR ImageName[MAX_PATH];

        Analysis->SetUlong64(DEBUG_FLR_PROCESS_OBJECT, Bc->Args[0]);

        //
        // Second parameter (which is actually a string within the EPROCESS)
        // is the name of the image.
        //
        if (ReadMemory(Bc->Args[2], ImageName, sizeof(ImageName),  &result) &&
            result)
        {
            ImageName[MAX_PATH-1]=0;
            ImageName[result]=0;
            SaveImageName(Analysis, ImageName);
        }
    }
}

DECL_GETINFO( DRIVER_POWER_STATE_FAILURE ) // 0x9F
{
    ULONG64 DevObj = Bc->Args[2];
    ULONG64 DrvObj = Bc->Args[3];
    ULONG SubCode = (ULONG) Bc->Args[0];

    if (SubCode)
    {
        Analysis->SetUlong64(DEBUG_FLR_DRVPOWERSTATE_SUBCODE, SubCode);
    }

    if (DrvObj)
    {
        Analysis->SetUlong64(DEBUG_FLR_DRIVER_OBJECT, DrvObj);
        BcGetDriverNameFromIrp(Analysis, 0, 0, DrvObj);
    }

    if (DevObj)
    {
        Analysis->SetUlong64(DEBUG_FLR_DEVICE_OBJECT, DevObj);
        if (!DrvObj)
        {
            BcGetDriverNameFromIrp(Analysis, 0, DevObj, 0);
        }
    }
}

DECL_GETINFO( ACPI_BIOS_ERROR ) // 0xa5
{
    switch (Bc->Args[0])
    {
    case 0x03 :
        Analysis->SetUlong64(DEBUG_FLR_ACPI_OBJECT, Bc->Args[1]);
        break;

    case 0x04 :
    case 0x05 :
    case 0x06 :
    case 0x07 :
    case 0x08 :
    case 0x09 :
    case 0x0A :
    case 0x0C :
        Analysis->SetUlong64(DEBUG_FLR_ACPI_OBJECT, Bc->Args[2]);
        // fallthrough

    case 0x01 :
    case 0x02 :
    case 0x0B :
    case 0x0D :
    case 0x10 :
        Analysis->SetUlong64(DEBUG_FLR_ACPI_EXTENSION, Bc->Args[1]);
        break;

    case 0x11 :
        if (Bc->Args[1] == 6)
        {
            // The machine fail to transition into ACPI mode
            CHAR BugCheckStr[40];

            sprintf(BugCheckStr, "0x%lx_FAILED_ACPI_TRANSITION", Bc->Code);
            Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
        }
        break;
    case 0x10001 :
    case 0x10002 :
    case 0x10003 :
        Analysis->SetUlong64(DEBUG_FLR_DEVICE_OBJECT, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_ACPI_OBJECT, Bc->Args[3]);
        break;

    case 0x10005 :
    case 0x10006 :
        Analysis->SetUlong64(DEBUG_FLR_ACPI_OBJECT, Bc->Args[1]);
        break;

    default:
        break;
    }
}


DECL_GETINFO( SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION )  // (c1)
{
    Analysis->SetUlong(DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION, 1);
    Analysis->SetUlong64(DEBUG_FLR_SPECIAL_POOL_CORRUPTION_TYPE, Bc->Args[3]);
}


DECL_GETINFO( BAD_POOL_CALLER ) // 0xC2
{
    DEBUG_POOL_DATA PoolData = {0};
    CHAR BugcheckStr[20] = {0};

    sprintf(BugcheckStr, "0x%lx_%lx", BAD_POOL_CALLER, (ULONG) Bc->Args[0]);
    if (Bc->Args[0] == 7)
    {
        // Double free
        if (!(Bc->Args[3] & 0x7))
        {
            // likely to be a valid address

            Analysis->SetUlong(DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION, 1);

            PoolData.SizeofStruct = sizeof(DEBUG_POOL_DATA);

            if (ExtGetPoolData(Bc->Args[3], &PoolData) == S_OK)
            {
                if (isprint(PoolData.PoolTag & 0xff) &&
                    isprint((PoolData.PoolTag >> 8) & 0xff))
                {
                    CHAR PoolTag[8] = {0};
                    sprintf(PoolTag,"%c%c%c%c",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                            PP(PoolData.PoolTag),
                            PP(PoolData.PoolTag >> 8),
                            PP(PoolData.PoolTag >> 16),
                            PP((PoolData.PoolTag&~0x80000000) >> 24)
#undef PP
                            );
                    // seems like a valid pooltag
                    Analysis->SetString(DEBUG_FLR_FREED_POOL_TAG, PoolTag);
                    CatString(BugcheckStr, "_", sizeof(BugcheckStr));
                    CatString(BugcheckStr, PoolTag, sizeof(BugcheckStr));
                }
            }

        }
        Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugcheckStr);
    }
    else if ((Bc->Args[0] >= 0x40) && (Bc->Args[0] < 0x60))
    {
        if (Bc->Args[1] == 0)
        {
            Analysis->SetUlong(DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION, 1);
        }
    } else
    {
        Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugcheckStr);
    }

}


DECL_GETINFO( DRIVER_VERIFIER_DETECTED_VIOLATION ) // 0xC4
/*
 * Parameters
 *
 * Parameter 1 subclass of violation
 * Parameter 2, 3, 4 vary depending on parameter 1
 *
 */
{
    ULONG64 BadDriverAddr;
    ULONG64 DriverNameAddr;
    ULONG res;
    ULONG ParamCount = 0;

    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);


    Analysis->SetUlong(DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION, 1);

    if ((BadDriverAddr = GetExpression("nt!ViBadDriver")) &&
        ReadPointer(BadDriverAddr, &DriverNameAddr))
    {
        AddBugcheckDriver(Analysis, TRUE, TRUE, DriverNameAddr);
    }

    switch (Bc->Args[0])
    {
    case 0x00 : // caller is trying to allocate zero bytes
    case 0x01 : // caller is trying to allocate paged pool at DISPATCH_LEVEL or above
    case 0x02 : // caller is trying to allocate nonpaged pool at an IRQL above DISPATCH_LEVEL
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
            // 3 - pool type
            // 4 - number of bytes
        break;
    case 0x03 : // caller is trying to allocate more than one page of mustsucceed pool, but one page is the maximum allowed by this API.
        break;

    case 0x10 : // caller is freeing a bad pool address
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[1]); // bad pool address
        break;

    case 0x11 : // caller is trying to free paged pool at DISPATCH_LEVEL or above
    case 0x12 : // caller is trying to free nonpaged pool at an IRQL above DISPATCH_LEVEL
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[3]);
            // 3 - pool type
        break;

    case 0x13 : // the pool the caller is trying to free is already free.
    case 0x14 : // the pool the caller is trying to free is already free.
            // 2 - line number
            // 3 - pool header
            // 4 - pool header contents
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[3]);
        break;

    case 0x15 : // the pool the caller is trying to free contains an active timer.
        // 2 - timer entry
        // 3 - pool type
        // 4 - pool address being freed
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[3]);
        break;

    case 0x16 : // the pool the caller is trying to free is a bad address.
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[2]);
        break;
            // 2 - line number

    case 0x17 : // the pool the caller is trying to free contains an active ERESOURCE.
            // 2 - resource entry
            // 3 - pool type
        Analysis->SetUlong64(DEBUG_FLR_POOL_ADDRESS, Bc->Args[3]);
        break;

    case 0x30 : // raising IRQL to an invalid level,
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_REQUESTED_IRQL, Bc->Args[2]);
        break;

    case 0x31 : // lowering IRQL to an invalid level,
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_REQUESTED_IRQL, Bc->Args[2]);
             // 4 -  0 means the new IRQL is bad, 1 means the IRQL is invalid inside a DPC routine
        break;

    case 0x32 : // releasing a spinlock when not at DISPATCH_LEVEL.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
            // 3 -  spinlock address
        break;

    case 0x33 : //  acquiring a fast mutex when not at APC_LEVEL or below.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  fast mutex address

    case 0x34 : // releasing a fast mutex when not at APC_LEVEL.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  thread APC disable count, 4 == fast mutex address

    case 0x35 : // kernel is releasing a spinlock when not at DISPATCH_LEVEL.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_PREVIOUS_IRQL, Bc->Args[3]);
        break;
            // 3 -  spinlock address, 4 == old irql.

    case 0x36 : // kernel is releasing a queued spinlock when not at DISPATCH_LEVEL.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_PREVIOUS_IRQL, Bc->Args[3]);
        break;
            // 3 -  spinlock number,

    case 0x37 : // a resource is being acquired but APCs are not disabled.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  thread APC disable count,
            // 4 -  resource.

    case 0x38 : // a resource is being released but APCs are not disabled.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  thread APC disable count,
            // 4 -  resource.

    case 0x39 : // a mutex is being acquired unsafe, but irql is not APC_LEVEL on entry.
    case 0x3A : // a mutex is being released unsafe, but irql is not APC_LEVEL on entry.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  thread APC disable count,
            // 4 -  mutex.

    case 0x3B : // KeWaitXxx routine is being called at DISPATCH_LEVEL or higher.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
            // 3 -  object to wait on,
            // 4 -  time out parameter.

    case 0x3E : // KeLeaveCriticalRegion is being called for a thread that never entered a critical region.
        // Current stack analysis will give followup
        break;

    case 0x40 : // acquiring a spinlock when not at DISPATCH_LEVEL.
    case 0x41 : // releasing a spinlock when not at DISPATCH_LEVEL.
    case 0x42 : // acquiring a spinlock when caller is already above DISPATCH_LEVEL.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;
        // 3 -  spinlock address

    case 0x51 : // freeing memory where the caller has written past the end of the allocation overwriting our stored bytecount.
    case 0x52 : // freeing memory where the caller has written past the end of the allocation overwriting our stored virtual address.
    case 0x53 : // freeing memory where the caller has written past the end of the allocation overwriting our stored virtual address.
    case 0x54 : // freeing memory where the caller has written past the end of the allocation overwriting our stored virtual address.
    case 0x59 : // freeing memory where the caller has written past the end of the allocation overwriting our stored virtual address.
        Analysis->SetUlong64(DEBUG_FLR_WRITE_ADDRESS, Bc->Args[1]);
        break;

    case 0x60 : // A driver has forgotten to free its pool allocations prior to unloading.
    case 0x61 : // A driver is unloading and allocating memory (in another thread) at the same time.
        // In both cases ViBadDriver should be set.
        break;

    case 0x70 :  // MmProbeAndLockPages called when not at DISPATCH_LEVEL or below.
    case 0x71 : // MmProbeAndLockProcessPages called when not at DISPATCH_LEVEL or below.
    case 0x72 : // MmProbeAndLockSelectedPages called when not at DISPATCH_LEVEL or below.
    case 0x73 : // MmMapIoSpace called when not at DISPATCH_LEVEL or below.
    case 0x74 : // MmMapLockedPages called when not at DISPATCH_LEVEL or below.
    case 0x75 : // MmMapLockedPages called when not at APC_LEVEL or below.
    case 0x76 : // MmMapLockedPagesSpecifyCache called when not at DISPATCH_LEVEL or below.
    case 0x77 : // MmMapLockedPagesSpecifyCache called when not at APC_LEVEL or below.
    case 0x78 : // MmUnlockPages called when not at DISPATCH_LEVEL or below.
    case 0x79 : // MmUnmapLockedPages called when not at DISPATCH_LEVEL or below.
    case 0x7A : // MmUnmapLockedPages called when not at APC_LEVEL or below.
    case 0x7B : // MmUnmapIoSpace called when not at APC_LEVEL or below.
    case 0x7C : // MmUnlockPages called with an MDL whose pages were never successfully locked.
    case 0x7D : // MmUnlockPages called with an MDL whose pages are from nonpaged pool - these should never be unlocked.
    case 0x80 : // KeSetEvent called when not at DISPATCH_LEVEL or below.
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        break;

    case 0x81 : // MmMapLockedPages called without MDL_MAPPING_CAN_FAIL
        break;

    }
}


DECL_GETINFO( DRIVER_CAUGHT_MODIFYING_FREED_POOL ) // (c6)
/*
  An attempt was made to access freed pool memory.  The faulty component is
  displayed in the current kernel stack.
  Arguments:
   Arg1: memory referenced
   Arg2: value 0 = read operation, 1 = write operation
   Arg3: previous mode.
   Arg4: 4.
*/
{
    DEBUG_POOL_DATA PoolData;

    Analysis->SetUlong64(Bc->Args[1] ?
                         DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                         Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_PREVIOUS_MODE, Bc->Args[2]);
}

DECL_GETINFO( TIMER_OR_DPC_INVALID ) // (c7)
/*
 *
 * This is issued if a kernel timer or DPC is found somewhere in
 * memory where it is not permitted.
 *
 * Bugcheck Parameters
 *
 * Parameter 1  0: Timer object 1: DPC object 2: DPC routine
 * Parameter 2  Address of object
 * Parameter 3  Beginning of memory range checked
 * Parameter 4 End of memory range checked
 *
 * This condition is usually caused by a driver failing to cancel a
 * timer or DPC before freeing the memory where it resides.
 */
{

    ULONG PtrSize = IsPtr64() ? 8 : 4;
    ULONG64 ObjAddress;
    CHAR Buffer[MAX_PATH];
    ULONG64 Disp;

    ObjAddress = Bc->Args[1];

    switch (Bc->Args[0]) {
    case 0: //Timer object
        ULONG DpcOffsetInTimer;
        if (GetFieldOffset("nt!_KTIMER", "Dpc", &DpcOffsetInTimer))
        {
            // we don't have types
            DpcOffsetInTimer = 0x10 + PtrSize*4;
        }
        if (!ReadPointer(ObjAddress + DpcOffsetInTimer, &ObjAddress))
        {
            // fail
            break;
        }
        // Fall thru
    case 1:
        ULONG DeferredRoutinOffsetInKDPC;
        if (GetFieldOffset("nt!_KDPC", "DeferredRoutine", &DeferredRoutinOffsetInKDPC))
        {
            DeferredRoutinOffsetInKDPC = 4 + PtrSize*2;
        }
        if (!ReadPointer(ObjAddress + DeferredRoutinOffsetInKDPC, &ObjAddress))
        {
            // fail
            break;
        }
        // Fall thru
    case 2:

        if (FaGetSymbol(ObjAddress, Buffer, &Disp, sizeof(Buffer)))
        {
            Analysis->SetUlong64(DEBUG_FLR_INVALID_DPC_FOUND, ObjAddress);
            Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, ObjAddress);
        }
        break;
    }
}


DECL_GETINFO( DRIVER_VERIFIER_IOMANAGER_VIOLATION ) // (c9)
{
    ULONG64 DeviceObject = 0;

    Analysis->SetUlong64(DEBUG_FLR_DRIVER_VERIFIER_IO_VIOLATION_TYPE,
                         Bc->Args[0]);

    switch (Bc->Args[0])
    {
    case  0x1:
        // "Invalid IRP passed to IoFreeIrp";
    case  0x2:
        // "IRP still associated with a thread at IoFreeIrp";
    case  0x3:
        // "Invalid IRP passed to IoCallDriver";
        Analysis->SetUlong64(DEBUG_FLR_IRP_ADDRESS, Bc->Args[1]);
        break;

    case  0x4:
        // "Invalid Device object passed to IoCallDriver";
        DeviceObject = Bc->Args[1];
        break;

    case  0x5:
        // "Irql not equal across call to the driver dispatch routine"
        DeviceObject = Bc->Args[1];
        Analysis->SetUlong64(DEBUG_FLR_PREVIOUS_IRQL, Bc->Args[2]);
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[3]);
        break;

    case  0x6:
        // "IRP passed to IoCompleteRequest contains invalid status"
        // Param 1 = "the status";
        Analysis->SetUlong64(DEBUG_FLR_IRP_ADDRESS, Bc->Args[2]);
        break;

    case  0x7:
        // "IRP passed to IoCompleteRequest still has cancel routine"
        Analysis->SetUlong64(DEBUG_FLR_IRP_CANCEL_ROUTINE, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_IRP_ADDRESS, Bc->Args[2]);
        break;

    case  0x8:
        // "Call to IoBuildAsynchronousFsdRequest threw an exce
        DeviceObject = Bc->Args[1];
        Analysis->SetUlong64(DEBUG_FLR_IRP_MAJOR_FN, Bc->Args[2]);
        Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_CODE, Bc->Args[3]);
        break;

    case  0x9:
        // "Call to IoBuildDeviceIoControlRequest threw an exce
        DeviceObject = Bc->Args[1];
        Analysis->SetUlong64(DEBUG_FLR_IOCONTROL_CODE, Bc->Args[2]);
        Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_CODE, Bc->Args[3]);
        break;

    case  0x10:
        // "Reinitialization of Device object timer";
        DeviceObject = Bc->Args[1];
        break;

    case  0x12:
        // "Invalid IOSB in IRP at APC IopCompleteRequest (appe
        Analysis->SetUlong64(DEBUG_FLR_IOSB_ADDRESS, Bc->Args[1]);
        break;

    case  0x13:
        // "Invalid UserEvent in IRP at APC IopCompleteRequest
        Analysis->SetUlong64(DEBUG_FLR_INVALID_USEREVENT, Bc->Args[1]);
        break;

    case  0x14:
        // "Irql > DPC at IoCompleteRequest";
        Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
        Analysis->SetUlong64(DEBUG_FLR_IRP_ADDRESS, Bc->Args[2]);
        break;

    }

    if (DeviceObject)
    {
        Analysis->SetUlong64(DEBUG_FLR_DEVICE_OBJECT, DeviceObject);
        BcGetDriverNameFromIrp(Analysis, 0, DeviceObject, 0);
    }


}

DECL_GETINFO( PNP_DETECTED_FATAL_ERROR ) // 0xca
{
    CHAR BugCheckStr[20];
    ULONG64 DeviceObject;

    sprintf(BugCheckStr, "0x%lX_%lX", Bc->Code, Bc->Args[0]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
    DeviceObject = Bc->Args[1];

    if (DeviceObject)
    {
        Analysis->SetUlong64(DEBUG_FLR_DEVICE_OBJECT, DeviceObject);
        BcGetDriverNameFromIrp(Analysis, 0, DeviceObject, 0);
    }

}

DECL_GETINFO( DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS ) // 0xcb
{
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_MODULE, Bc->Args[0]);
}

DECL_GETINFO( DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS ) //0xce
{
    Analysis->SetUlong64(Bc->Args[1] ?
                         DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                         Bc->Args[0]);
    if (Bc->Args[2]) {
        Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[2]);
    }
}

DECL_GETINFO( DRIVER_CORRUPTED_MMPOOL ) // 0xd0
{
    Analysis->SetUlong64(Bc->Args[2] ?
                     DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                     Bc->Args[0]);
    Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Bc->Args[1]);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[3]);

}


//DUPINFOCASE( PAGE_FAULT_IN_FREED_SPECIAL_POOL );            // 0xCC
//DUPINFOCASE( PAGE_FAULT_BEYOND_END_OF_ALLOCATION );         // 0xCD
//DUPINFOCASE( TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE ); // 0xCF
//DUPINFOCASE( PAGE_FAULT_IN_NONPAGED_AREA )                  // 0x50
//DUPINFOCASE( DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION )   // 0xD6
DECL_GETINFO( DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL )       // 0xD5
/*
 * Parameters
 *
 * Parameter 1 Memory referenced
 * Parameter 2 0: Read 1: Write
 * Parameter 3 Address that referenced memory (if known)
 * Parameter 4 Reserved
 *
 */
{
    CHAR BugCheckStr[30];

    Analysis->SetUlong64(Bc->Args[1] ?
                         DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                         Bc->Args[0]);
    if (Bc->Args[2]) {
        Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[2]);
    }
    Analysis->SetUlong64(DEBUG_FLR_MM_INTERNAL_CODE, Bc->Args[3]);

    if (Bc->Args[0] == Bc->Args[2] &&
        Bc->Args[1] == 0)
    {
        Analysis->SetString(DEBUG_FLR_BUGCHECK_SPECIFIER, "_CODE_AV");
    }
    AddBugcheckDriver(Analysis, TRUE, TRUE, 0);
}


DECL_GETINFO( MANUALLY_INITIATED_CRASH ) //0xE2, 0xDEADDEAD
{
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, "MANUALLY_INITIATED_CRASH");
}

DECL_GETINFO( THREAD_STUCK_IN_DEVICE_DRIVER ) // 0xEA
/*
 * PARAMETERS:
 *
 *  1 - Pointer to a stuck thread object. Do .thread then kb on it to
 *      find hung location.
 *
 *  2 - Pointer to a DEFERRED_WATCHDOG object.
 *
 *  3 - Pointer to offending driver name.
 *
 *  4 - Number of times "intercepted" bugcheck 0xEA was hit (see notes).
 */
{
    Analysis->SetUlong64(DEBUG_FLR_FOLLOWUP_DRIVER_ONLY, 0);
    Analysis->SetUlong64(DEBUG_FLR_FAULTING_THREAD, Bc->Args[0]);

    Analysis->SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "GRAPHICS_DRIVER_FAULT");
}

DECL_GETINFO( CRITICAL_PROCESS_DIED ) // (0xef)
{
    Analysis->SetUlong64(DEBUG_FLR_PROCESS_OBJECT, Bc->Args[0]);
}

DECL_GETINFO( CRITICAL_OBJECT_TERMINATION ) // (0xf4)
{
    if (Bc->Args[0] == 3)
    {
        ULONG result;
        CHAR ImageName[MAX_PATH];

        Analysis->SetUlong64(DEBUG_FLR_PROCESS_OBJECT, Bc->Args[1]);

        //
        // Second parameter (which is actually a string within the EPROCESS)
        // is the name of the image.
        //
        if (ReadMemory(Bc->Args[2], ImageName, sizeof(ImageName),  &result) &&
            result)
        {
            ImageName[MAX_PATH-1]=0;
            ImageName[result]=0;
            SaveImageName(Analysis, ImageName);
        }
    }
}


DECL_GETINFO( WINLOGON_FATAL_ERROR ) //(c000021a)
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, Bc->Args[1]);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
}

DECL_GETINFO( STATUS_DRIVER_UNABLE_TO_LOAD ) //0xc0000xxx
{
    if (Bc->Args[0])
    {
        AddBugcheckDriver(Analysis, FALSE, FALSE, Bc->Args[0]);
    }
}

DECL_GETINFO( ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY ) // (0xFC)
{
    if (Bc->Args[0])
    {
        Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, Bc->Args[0]);
    }
    // Add bugcheck driver from KiBugCheckDriver
    AddBugcheckDriver(Analysis, TRUE, TRUE, 0);
}

DECL_GETINFO( UNMOUNTABLE_BOOT_VOLUME ) // 0xED
{
    CHAR BugCheckStr[20];

    sprintf(BugCheckStr, "0x%lx_%lx", Bc->Code, (ULONG) Bc->Args[1]);
    Analysis->SetUlong(DEBUG_FLR_STATUS_CODE, (ULONG) Bc->Args[1]);
    switch ((ULONG) Bc->Args[1])
    {
    case 0xC0000006:
        Analysis->SetUlong(DEBUG_FLR_SHOW_ERRORLOG, 1);
        break;
    default:
        break;
    }
}

#define GETINFOCASE(bcname)                      \
        case bcname :                            \
           GetInfoFor##bcname (Bc, Analysis);    \
           break;
#define DUPINFOCASE(bcname)                      \
        case bcname:

void
BcFillAnalysis(
    PBUGCHECK_ANALYSIS Bc,
    KernelDebugFailureAnalysis* Analysis
    )
{
    Analysis->SetFailureClass(DEBUG_CLASS_KERNEL);

    HRESULT Status = Analysis->CheckModuleSymbols("nt", "Kernel");
    if (Status != S_OK)
    {
        goto SkipBucheckSpecificProcessing;
    }

    //
    // BBT Breaks the stack trace for builds > 2201
    //      Hack the return address for better results
    // A new of routines are at the wrong addresses.
    //
    if ((g_TargetMachine == IMAGE_FILE_MACHINE_I386) &&
        (g_TargetBuild > 2500) && (g_TargetBuild < 2507))
    {
        DEBUG_STACK_FRAME Stk[MAX_STACK_FRAMES];
        ULONG Frames = 0;

        if (S_OK == g_ExtControl->GetStackTrace(0, 0, 0, Stk, MAX_STACK_FRAMES,
                                                &Frames) &&
            FaIsFunctionAddr(Stk[0].InstructionOffset, "KeBugCheckEx"))
        {
            ULONG CallIP = (ULONG) Stk[1].InstructionOffset - 5, Res;
            UCHAR Instr;

            // Move the caller's IP back to the actual KeBugCheckEx
            // call.  Only do this if we haven't already backed up
            // to a call instruction.
            if (!ReadMemory(Stk[1].InstructionOffset, &Instr, sizeof(Instr),
                            &Res) ||
                Res != sizeof(Instr) ||
                Instr != 0xe8)
            {
                WriteMemory(Stk[0].FrameOffset + 4, &CallIP, sizeof(CallIP),
                            &Res);
                g_ExtControl->GetStackTrace(0, 0, 0, Stk, MAX_STACK_FRAMES,
                                            &Frames);
            }
        }
    }

    //
    // Special value that is set by the kernel debugger so we can detect when
    // people are messing with physical address via the kernel debugger.
    //

    ULONG64 MmPoisonedTbAddr;
    MmPoisonedTbAddr = GetExpression("nt!MmPoisonedTb");

    if (MmPoisonedTbAddr)
    {
        ULONG cb;
        ULONG MmPoisonedTb = 0;

        if (ReadMemory(MmPoisonedTbAddr, &MmPoisonedTb, sizeof(ULONG), &cb) &&
            (MmPoisonedTb != 0))
        {
            Analysis->SetUlong64(DEBUG_FLR_POISONED_TB, 0);
        }
    }

SkipBucheckSpecificProcessing:


    Analysis->SetFailureType(DEBUG_FLR_KERNEL);

    switch (Bc->Code)
    {
        case 0:
            ULONG c_ip;
            //
            // This can be a user mode failurein kd.  Try to determine that.
            //

            if ( (GetExpression("@$ip") < BcTargetKernelAddressStart()) &&
                 (GetExpression("@$sp") < BcTargetKernelAddressStart()) )
            {
                Analysis->SetFailureType(DEBUG_FLR_USER_CRASH);
                g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, ".reload /user",
                                       DEBUG_EXECUTE_NOT_LOGGED);
            }

            break;

        GETINFOCASE( DRIVER_CAUGHT_MODIFYING_FREED_POOL );

        DUPINFOCASE( PAGE_FAULT_IN_FREED_SPECIAL_POOL );
        DUPINFOCASE( PAGE_FAULT_BEYOND_END_OF_ALLOCATION );
        DUPINFOCASE( TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE );
        DUPINFOCASE( PAGE_FAULT_IN_NONPAGED_AREA );
        DUPINFOCASE( DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION );
        GETINFOCASE( DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL );

        GETINFOCASE( DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS );

        GETINFOCASE( DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS );

        GETINFOCASE( DRIVER_VERIFIER_IOMANAGER_VIOLATION );

        DUPINFOCASE( DRIVER_IRQL_NOT_LESS_OR_EQUAL );
        GETINFOCASE( IRQL_NOT_LESS_OR_EQUAL );

        GETINFOCASE( PANIC_STACK_SWITCH );

        GETINFOCASE( KMODE_EXCEPTION_NOT_HANDLED );

        GETINFOCASE( SYSTEM_SERVICE_EXCEPTION );

        GETINFOCASE( ACPI_BIOS_ERROR );

        GETINFOCASE( USER_MODE_HEALTH_MONITOR );

        GETINFOCASE( MEMORY_MANAGEMENT );

        DUPINFOCASE( KERNEL_MODE_EXCEPTION_NOT_HANDLED_M );
        GETINFOCASE( KERNEL_MODE_EXCEPTION_NOT_HANDLED );

        DUPINFOCASE( SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M );
        GETINFOCASE( SYSTEM_THREAD_EXCEPTION_NOT_HANDLED );

        GETINFOCASE( SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION );

        GETINFOCASE( KERNEL_STACK_INPAGE_ERROR );

        GETINFOCASE( KERNEL_DATA_INPAGE_ERROR );

        GETINFOCASE( TIMER_OR_DPC_INVALID );

        DUPINFOCASE( UNEXPECTED_KERNEL_MODE_TRAP_M );
        GETINFOCASE( UNEXPECTED_KERNEL_MODE_TRAP );

        GETINFOCASE( MULTIPLE_IRP_COMPLETE_REQUESTS );

        GETINFOCASE( WINLOGON_FATAL_ERROR );

        DUPINFOCASE( RDR_FILE_SYSTEM );
        DUPINFOCASE( UDFS_FILE_SYSTEM );
        DUPINFOCASE( CDFS_FILE_SYSTEM );
        DUPINFOCASE( NTFS_FILE_SYSTEM );
        GETINFOCASE( FAT_FILE_SYSTEM );

        DUPINFOCASE( STATUS_DRIVER_ENTRYPOINT_NOT_FOUND );
        DUPINFOCASE( STATUS_PROCEDURE_NOT_FOUND );
        DUPINFOCASE( STATUS_DRIVER_ORDINAL_NOT_FOUND );
        GETINFOCASE( STATUS_DRIVER_UNABLE_TO_LOAD );

        GETINFOCASE( PNP_DETECTED_FATAL_ERROR );

        GETINFOCASE( MACHINE_CHECK_EXCEPTION );

        GETINFOCASE( DRIVER_POWER_STATE_FAILURE );

        DUPINFOCASE( THREAD_STUCK_IN_DEVICE_DRIVER_M );
        GETINFOCASE( THREAD_STUCK_IN_DEVICE_DRIVER );

        GETINFOCASE( SESSION3_INITIALIZATION_FAILED );

        GETINFOCASE( DRIVER_VERIFIER_DETECTED_VIOLATION );

        GETINFOCASE( CRITICAL_OBJECT_TERMINATION );

        GETINFOCASE( CRITICAL_PROCESS_DIED );

        GETINFOCASE( PROCESS_HAS_LOCKED_PAGES );

        DUPINFOCASE( MANUALLY_INITIATED_CRASH1 );
        GETINFOCASE( MANUALLY_INITIATED_CRASH );

        GETINFOCASE( BAD_POOL_CALLER );

        DUPINFOCASE( DRIVER_CORRUPTED_SYSPTES );
        DUPINFOCASE( SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD )
        DUPINFOCASE( DRIVER_PORTION_MUST_BE_NONPAGED );
        GETINFOCASE( DRIVER_CORRUPTED_MMPOOL );
    default:
        break;
    }


    if (!Analysis->GetFailureCode())
    {
        //
        // We ignore the top bit when setting the internal failure code
        // so we can bucket things togeter appropriately.
        // The top bit only represent a dump generation difference, not
        // a root cause difference.
        //
        Analysis->SetFailureCode(Bc->Code & ~0x10000000);
    }

    if (!Analysis->Get(DEBUG_FLR_DEFAULT_BUCKET_ID))
    {
        if (Analysis->GetFailureType() == DEBUG_FLR_USER_CRASH)
        {
            Analysis->SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "APPLICATION_FAULT");
        }
        else
        {
            Analysis->SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "DRIVER_FAULT");
        }
    }

    if (!Analysis->Get(DEBUG_FLR_BUGCHECK_STR))
    {
        CHAR BugCheckStr[12];
        sprintf(BugCheckStr, "0x%lX", Analysis->GetFailureCode());
        Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);

        if (Analysis->Get(DEBUG_FLR_WRITE_ADDRESS))
        {
            Analysis->SetString(DEBUG_FLR_BUGCHECK_SPECIFIER, "_W");
        }
    }

    //
    // Save the current IRQL.
    //

    if (g_TargetBuild > 2600)
    {
        PROCESSORINFO ProcInfo;
        ULONG64 Prcb;
        ULONG64 Irql = 0;
        HRESULT Hr;

        if (Ioctl(IG_KD_CONTEXT, &ProcInfo, sizeof(ProcInfo)))
        {
            Hr = g_ExtData->ReadProcessorSystemData(ProcInfo.Processor,
                                                    DEBUG_DATA_KPRCB_OFFSET,
                                                    &Prcb,
                                                    sizeof(Prcb),
                                                    NULL);
            if (Hr == S_OK && Prcb)
            {
                if (!GetFieldValue(Prcb, "nt!_KPRCB", "DebuggerSavedIRQL", Irql))
                {
                    Analysis->SetUlong64(DEBUG_FLR_CURRENT_IRQL, Irql);
                }
            }
        }
    }

    ULONG64 Irp;

    if (Analysis->GetUlong64(DEBUG_FLR_IRP_ADDRESS, &Irp))
    {
        BcGetDriverNameFromIrp(Analysis, Irp, 0, 0);
    }

    //
    // Generic processing
    //

    Analysis->ProcessInformation();
}

void
ReadWatchDogBugcheck(
    PBUGCHECK_ANALYSIS Bc
    )
{
    // Check if this could be a watchdog bugcheck
    //       Read watchdog!g_WdBugCheckData
    ULONG64 wdBugcheck;
    ULONG res;
    ULONG PtrSize = IsPtr64() ? 8 : 4;

    wdBugcheck = GetExpression("watchdog!g_WdBugCheckData");
    if (wdBugcheck)
    {
        wdBugcheck = GetExpression("VIDEOPRT!g_WdpBugCheckData");
    }
    if (wdBugcheck)
    {
        ReadMemory(wdBugcheck, &Bc->Code, sizeof(ULONG), &res);
        ReadPointer(wdBugcheck + PtrSize,&Bc->Args[0]);
        ReadPointer(wdBugcheck + 2*PtrSize,&Bc->Args[1]);
        ReadPointer(wdBugcheck + 3*PtrSize,&Bc->Args[2]);
        ReadPointer(wdBugcheck + 4*PtrSize,&Bc->Args[3]);
    }

}

KernelDebugFailureAnalysis*
BcAnalyze(
    OUT PBUGCHECK_ANALYSIS Bc,
    ULONG Flags
    )
{
    if (g_ExtControl->ReadBugCheckData(&Bc->Code, &Bc->Args[0], &Bc->Args[1],
                                       &Bc->Args[2], &Bc->Args[3]) != S_OK)
    {
        return NULL;
    }

    if (Bc->Code == 0)
    {
        ReadWatchDogBugcheck(Bc);
    }

    KernelDebugFailureAnalysis* Analysis = new KernelDebugFailureAnalysis;
    if (Analysis)
    {
        Analysis->SetProcessingFlags(Flags);

        __try
        {
            BcFillAnalysis(Bc, Analysis);
        }
        __except(FaExceptionFilter(GetExceptionInformation()))
        {
            delete Analysis;
            Analysis = NULL;
        }
    }

    return Analysis;
}

HRESULT
AnalyzeBugCheck(
    PCSTR args
    )
{
    KernelDebugFailureAnalysis* Analysis;
    BUGCHECK_ANALYSIS Bc = {0};
    BOOL Dump = TRUE;
    ULONG Flags = 0;
    DEBUG_FLR_PARAM_TYPE Params[10];
    ULONG ParamCount = 0;

    if (g_TargetClass != DEBUG_CLASS_KERNEL) {
        dprintf("!analyzebugcheck is for kernel mode only\n");
        return E_FAIL;
    }

    for (;;)
    {
        while (*args == ' ' || *args == '\t')
        {
            args++;
        }

        if (*args == '-')
        {
            ++args;
            switch(*args)
            {
            case 'D':
                {
                CHAR ParamString[100];
                ULONG ParamLength = 0;
                args+=2;
                while(*args && *args != ' ' && *args != '\t')
                {
                    ParamString[ParamLength++] = *args++;
                }
                ParamString[ParamLength] = 0;

                //
                // Match the string to the actual failure ID.
                //

                ULONG i=0;
                while(FlrLookupTable[i].Data &&
                      strcmp(FlrLookupTable[i].String, ParamString))
                {
                    i++;
                }

                Params[ParamCount++] = FlrLookupTable[i].Data;
                break;
                }
            case 'n':
                if (!strncmp(args, "nodb",4))
                {
                    args+=4;
                    Flags |= FAILURE_ANALYSIS_NO_DB_LOOKUP;
                }
                break;
            case 's':
                if (!strncmp(args, "show",4))
                {
                    ULONG64 Code;
                    args+=4;
                    GetExpressionEx(args, &Code, &args);
                    Bc.Code = (ULONG)Code;

                    for (ULONG i=0; i<4 && *args; i++)
                    {
                        if (!GetExpressionEx(args, &Bc.Args[i], &args))
                        {
                            break;
                        }
                    }
                    GetBugCheckDescription(&Bc);
                    PrintBugDescription(&Bc);
                    return S_OK;
                }
            case 'v':
                Flags |= FAILURE_ANALYSIS_VERBOSE;
                break;
            case 'f':
                break;
            default:
                {
                    CHAR Option[2];
                    Option[0] = *args; Option[1] = 0;
                    dprintf("\nUnknown option '-%s'\n", Option );
                    break;
                }
            }
            if (*args == 0)
            {
                break;
            }
            ++args;
        }
        else
        {
            break;
        }
    }


    g_ExtControl->ReadBugCheckData(&Bc.Code, &Bc.Args[0], &Bc.Args[1],
                                   &Bc.Args[2], &Bc.Args[3]);

    if (Bc.Code == 0)
    {
        ReadWatchDogBugcheck(&Bc);
    }

    if (!ParamCount)
    {
        dprintf("*******************************************************************************\n");
        dprintf("*                                                                             *\n");
        dprintf("*                        Bugcheck Analysis                                    *\n");
        dprintf("*                                                                             *\n");
        dprintf("*******************************************************************************\n");
        dprintf("\n");

        if (Flags & FAILURE_ANALYSIS_VERBOSE)
        {
            GetBugCheckDescription(&Bc);
            PrintBugDescription(&Bc);
            dprintf("\nDebugging Details:\n------------------\n\n");
        }
        else
        {
            dprintf("Use !analyze -v to get detailed debugging information.\n\n");

            dprintf("BugCheck %lX, {%1p, %1p, %1p, %1p}\n\n",
                    Bc.Code,
                    Bc.Args[0],Bc.Args[1],Bc.Args[2],Bc.Args[3]);
        }
    }

    Analysis = BcAnalyze(&Bc, Flags);

    if (!Analysis)
    {
        dprintf("\n\nFailure could not be analyzed\n\n");
        return E_FAIL;
    }

    if (ParamCount)
    {
        while(ParamCount--)
        {
            Analysis->OutputEntryParam(Params[ParamCount]);
        }
    }

    //
    // Always call output so we can key information printed out also, such
    // as *** entries.
    //

    Analysis->Output();

    delete Analysis;

    return S_OK;

}


//----------------------------------------------------------------------------
//
// KernelDebugFailureAnalysis.
//
//----------------------------------------------------------------------------

KernelDebugFailureAnalysis::KernelDebugFailureAnalysis(void)
    : m_KernelModule("nt")
{
}

DEBUG_POOL_REGION
KernelDebugFailureAnalysis::GetPoolForAddress(ULONG64 Addr)
{
    PGET_POOL_REGION GetPoolRegion = NULL;

    if (g_ExtControl->
        GetExtensionFunction(0, "GetPoolRegion",
                             (FARPROC*)&GetPoolRegion) == S_OK &&
        GetPoolRegion)
    {
        DEBUG_POOL_REGION RegionId;

        (*GetPoolRegion)(g_ExtClient, Addr, &RegionId);
        return RegionId;
    }

    return DbgPoolRegionUnknown;
}

PCSTR
KernelDebugFailureAnalysis::DescribeAddress(ULONG64 Addr)
{
    DEBUG_POOL_REGION RegionId = GetPoolForAddress(Addr);


    if ((RegionId != DbgPoolRegionUnknown) &&
        (RegionId < DbgPoolRegionMax))
    {
        return g_PoolRegion[RegionId];
    }
    return NULL;
}

FOLLOW_ADDRESS
KernelDebugFailureAnalysis::IsPotentialFollowupAddress(ULONG64 Address)
{
    CHAR Buffer[MAX_PATH];
    ULONG64 Disp;

    //
    // Check for special symbols which indicate we are transitioning back
    // to user mode code, so the rest of the stack can not be at fault.
    //

    if (GetFailureType() == DEBUG_FLR_USER_CRASH)
    {
        return FollowYes;
    }

    if (FaGetSymbol(Address, Buffer, &Disp, sizeof(Buffer)) &&
        (!_strcmpi(Buffer, "nt!KiCallUserMode") ||
         !_strcmpi(Buffer, "SharedUserData!SystemCallStub")))
    {
        return FollowStop;
    }

    if (Address > BcTargetKernelAddressStart())
    {
        return FollowYes;
    }
    else
    {
        //
        // We don't stop on user mode addresses because they could be
        // garbage on the stack we - just skip them
        //

        return FollowSkip;
    }
}

FOLLOW_ADDRESS
KernelDebugFailureAnalysis::IsFollowupContext(ULONG64 Address1,
                                              ULONG64 Address2,
                                              ULONG64 Address3)
{
    // If it's a user mode address, and a dump file, it's not a valid
    // context.
    // A user mode address is valid for a kernel mode context because
    // a hardcoded breakpoint from user mode with kd active will show up
    // on the stack.

    if ( (Address1 < BcTargetKernelAddressStart()) &&
         (Address2 < BcTargetKernelAddressStart()) &&
         (Address3 < BcTargetKernelAddressStart()) )
    {
        if ((g_TargetQualifier == DEBUG_DUMP_SMALL)   ||
            (g_TargetQualifier == DEBUG_DUMP_DEFAULT) ||
            (g_TargetQualifier == DEBUG_DUMP_FULL))
        {
            return FollowStop;
        }
    }

    return FollowYes;
}

FlpClasses
KernelDebugFailureAnalysis::GetFollowupClass(ULONG64 Address,
                                             PCSTR Module, PCSTR Routine)
{
    if (m_KernelModule.Contains(Address) ||
        !_strcmpi(Module, "ntfs")        ||
        !_strcmpi(Module, "fastfat"))
    {
        return FlpOSRoutine;
    }
    else if (!_strcmpi(Module, "sr")       ||
             !_strcmpi(Module, "ndis")     ||
             !_strcmpi(Module, "videoprt") ||
             !_strcmpi(Module, "USBPORT")  ||
             !_strcmpi(Module, "USBHUB")   ||
             !_strcmpi(Module, "dxg")      ||
             !_strcmpi(Module, "win32k")   ||
             !_strcmpi(Module, "verifier") ||
             !_strcmpi(Module, "scsiport"))
    {
        return FlpOSFilterDrv;
    }
    else if (!_strcmpi(Module, "SharedUserData") &&
             Routine && !_strcmpi(Routine, "SystemCallStub"))
    {
        // Do not followup on usermode calls
        return FlpIgnore;
    }
    else
    {
        return FlpUnknownDrv;
    }
}



/*
 * This checks for valid object pointers in HANDLE_TABLE_ENTRY. If the pointers are
 * invalid it tries to figure out who corrupted the values.
 *
 * Reutrns TRUE if it succesfully identifies a memory curruption
 */
BOOL
KernelDebugFailureAnalysis::CheckForCorruptionInHTE(
    ULONG64 hTableEntry,
    PCHAR Owner,
    ULONG OwnerSize)
{
    ULONG64 Object = 0;
    ULONG64 CorruptingPool = 0;
    DEBUG_POOL_REGION Region;

    // hTableEntry must be in PagedPool, but we have
    // a loose check here since GetPoolForAddress is unreliable on
    // minidumps PagedPool
    if (IsPotentialFollowupAddress(hTableEntry) != FollowYes)
    {
        return FALSE;
    }

    if (!ReadPointer(hTableEntry, &Object))
    {
        return FALSE;
    }

    Region = GetPoolForAddress(Object);

    if (IsPotentialFollowupAddress(Object) != FollowYes)
    {
        // Object is invalid, it must be in PagedPool or NonPagedPool

        return AddCorruptingPool(hTableEntry);
    }

    if (InitTypeRead(Object, nt!_OBJECT_HEADER))
    {
        return FALSE;
    }
    ULONG PointerCount, HandleCount;
    ULONG64 ObjType;

    PointerCount = (ULONG) ReadField(PointerCount);
    HandleCount = (ULONG) ReadField(HandleCount);
    ObjType = (ULONG) ReadField(Type);

    // Verify object for inconsistent counts
     // Invalid object type, must be in kernel mode

    if ((PointerCount > 0x10000) ||
        (HandleCount > 0x10000) ||
        (HandleCount > PointerCount) ||
        (IsPotentialFollowupAddress(ObjType) != FollowYes)
        )
    {
        // Object is corrupted, previous pool is a possible corruptor

        AddCorruptingPool(Object);
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
KernelDebugFailureAnalysis::AddCorruptingPool(
    ULONG64 CorruptedPool
    )
{
    DEBUG_POOL_DATA PoolData = {0};

    PoolData.SizeofStruct = sizeof(DEBUG_POOL_DATA);
    if (ExtGetPoolData(CorruptedPool, &PoolData) != S_OK)
    {
        //
        // Pool block is badly corrupted, loop backwards to find first non-corrupt block
        //
        ULONG PoolHeaderSize = GetTypeSize("nt!_POOL_HEADER");
        ULONG64 PoolAddr;
        for (PoolAddr = CorruptedPool - 2*PoolHeaderSize;
             PoolAddr > (CorruptedPool -0x1000); // Limit to 4KB
             PoolAddr -= 2*PoolHeaderSize)
        {
            if (ExtGetPoolData(PoolAddr, &PoolData) == S_OK)
            {
                goto FoundPool;
            }
        }

        return FALSE;
    } else if (PoolData.Free && !PoolData.Allocated &&
               PoolData.Size != 0)
    {
        // Pool seem to have been correctly freed
        return FALSE;
    } else if (ExtGetPoolData(PoolData.PoolBlock - PoolData.PreviousSize,
                                   &PoolData) == S_OK)
        // Now get previous pool as it most likely corruptor
     {
FoundPool:
         CHAR PoolTag[8] = {0};
         SetUlong64(DEBUG_FLR_CORRUPTING_POOL_ADDRESS, PoolData.PoolBlock);

         sprintf(PoolTag,"%c%c%c%c",
#define PP(x) isprint(((x)&0xff))?((x)&0xff):('.')
                 PP(PoolData.PoolTag),
                 PP(PoolData.PoolTag >> 8),
                 PP(PoolData.PoolTag >> 16),
                 PP((PoolData.PoolTag&~0x80000000) >> 24)
#undef PP
                 );

         SetString(DEBUG_FLR_CORRUPTING_POOL_TAG, PoolTag);

         return TRUE;
    }

    return FALSE;
}

typedef struct _CHECK_STACK {
    PCHAR* BreakinStk;
    BOOL   ValidMatch;
    ULONG  MachineType;
 } CHECK_STACK;

BOOL
KernelDebugFailureAnalysis::IsManualBreakin(
    PDEBUG_STACK_FRAME Stk,
    ULONG Frames
    )
//
// Check stack to see if this is result of manual breakin
//
{
    CHAR    szBrakFn[100];
    ULONG64 Disp;
    ULONG   NumStacks, i, j;
    BOOL    NoMatches;
    static PCHAR StkX86CtrlCBreakin1[] = {
        "nt!*Break*",
        "nt!KeUpdateSystemTime",
        "nt!KiIdleLoop",
        NULL,
    };
    static PCHAR StkX86CtrlCBreakin2[] = {
        "nt!*Break*",
        "nt!KeUpdateSystemTime",
        "hal!HalProcessorIdle",
        NULL,
    };
    static PCHAR StkIa64CtrlCBreakin1[] = {
        "nt!KeBreakinBreakpoint",
        "hal!HalpClockInterrupt",
        "nt!KiExternalInterruptHandler",
        "nt!Kil_TopOfIdleLoop",
        NULL,
    };
    static PCHAR StkIa64CtrlCBreakin2[] = {
        "nt!KeBreakinBreakpoint",
        "hal!HalpClockInterrupt",
        "nt!KiExternalInterruptHandler",
        NULL
    };
    CHECK_STACK StksToCheck[] = {
        {StkX86CtrlCBreakin1,  TRUE, IMAGE_FILE_MACHINE_I386},
        {StkX86CtrlCBreakin2,  TRUE, IMAGE_FILE_MACHINE_I386},
        {StkIa64CtrlCBreakin1, TRUE, IMAGE_FILE_MACHINE_IA64},
        {StkIa64CtrlCBreakin2, TRUE, IMAGE_FILE_MACHINE_IA64},
    };


    //
    // We are looking for:
    // 0                  nt!*Break*
    //


    //
    // Assume 3 to 5 frames for a manual breakin stack
    //
    if (Frames < 3 || Frames > 5 || Stk == NULL)
    {
        return FALSE;
    }

    if (FaGetSymbol(Stk[0].InstructionOffset, szBrakFn,
                    &Disp, sizeof(szBrakFn)))
    {
        if (!strstr(szBrakFn, "Break"))
        {
            return FALSE;
        }
    } else
    {
        return FALSE;
    }

    NumStacks = sizeof(StksToCheck)/sizeof(CHECK_STACK);

    for (i = 0; i < NumStacks; ++i)
    {
        if (StksToCheck[i].MachineType != g_TargetMachine)
        {
            StksToCheck[i].ValidMatch = FALSE;
        }
    }

    for (j=1;j<Frames;++j)
    {
        NoMatches = TRUE;
        if (FaGetSymbol(Stk[j].InstructionOffset, szBrakFn,
                        &Disp, sizeof(szBrakFn)))
        {
            for (i = 0; i < NumStacks; ++i)
            {
                if (StksToCheck[i].ValidMatch)
                {
                    if (StksToCheck[i].BreakinStk[j] == NULL)
                    {
                        StksToCheck[i].ValidMatch = FALSE;
                    } else if (strcmp(szBrakFn, StksToCheck[i].BreakinStk[j]))
                    {
                        StksToCheck[i].ValidMatch = FALSE;
                    } else
                    {
                        // Breakin stack i matck with current stack till frame j
                        NoMatches = FALSE;
                    }

                }
            }

        }

        if (NoMatches)
        {
            // None of the stacks in StksToCheck match
            return FALSE;
        }
    }

    for (i = 0; i < NumStacks; ++i)
    {
        if (StksToCheck[i].ValidMatch)
        {
            return TRUE;
        }
    }

    return FALSE;
}


    //
    // Create a new minidump file of this crash
    //
#if 0
    ULONG FailTime = 0;
    ULONG UpTime = 0;
    CHAR  CurrentTime[20];
    CHAR  CurrentDate[20];
    CHAR  Buffer[MAX_PATH];

    g_ExtControl->GetCurrentTimeDate(&FailTime);
    g_ExtControl->GetCurrentSystemUpTime(&UpTime);
    _strtime(CurrentTime);
    _strdate(CurrentDate);

    if (CurrentTime && UpTime)
    {
        PrintString(Buffer, sizeof(Buffer), "Dump%s-%s-%08lx-%08lx-%s.dmp",
                    FailTime, Uptime, Currentdate, CurrentTime);
        Status = g_ExtClient->WriteDumpFile(Buffer ,DEBUG_DUMP_SMALL);
    }
#endif

#if 0
    CHAR  Buffer[MAX_PATH];
    if (Dump && GetTempFileName(".", "DMP", 0, Buffer))
    {
        Status = g_ExtClient->WriteDumpFile(Buffer ,DEBUG_DUMP_SMALL);

        if (Status == S_OK)
        {
            //
            // We create a file - now lets send it to the database
            //

            //CopyFile(Buffer, "c:\\xxxx", 0);
            DeleteFile(Buffer);
        }
        dprintf("Done.");
    }

    dprintf("\n\n");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\analyze.h ===
//----------------------------------------------------------------------------
//
// Generic failure analysis framework.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __ANALYZE_H__
#define __ANALYZE_H__

#define E_FAILURE_FOLLOWUP_INFO_NOT_FOUND         0x80100001
#define E_FAILURE_BAD_STACK                       0x80100002
#define E_FAILURE_ZEROED_STACK                    0x80100003
#define E_FAILURE_WRONG_SYMBOLS                   0x80100004
#define E_FAILURE_CORRUPT_MODULE_LIST             0x80100005

#define MAX_STACK_FRAMES 50

typedef enum FOLLOW_ADDRESS
{
    FollowYes,
    FollowSkip,
    FollowStop
} FOLLOW_ADDRESS;

typedef enum FlpClasses
{
    FlpIgnore = 0,
    FlpOSInternalRoutine,  // followups marked as last_ (ignore routines)
    FlpOSRoutine,          // nt!* or maybe_ followup
    FlpOSFilterDrv,        // fsfilter!, scsiport! etc.
    FlpUnknownDrv,
    FlpSpecific,           // bugcheck or other source tells us exactly what
                           // the failure is.
    MaxFlpClass
} FlpClasses;

typedef struct _FOLLOWUP_DESCS
{
    ULONG64 InstructionOffset;
    CHAR    Owner[100];
} FOLLOWUP_DESCS, *PFOLLOWUP_DESCS;


typedef struct _FLR_LOOKUP_TABLE {
    DEBUG_FLR_PARAM_TYPE Data;
    PSTR String;
} FLR_LOOKUP_TABLE, *PFLR_LOOKUP_TABLE;

extern FLR_LOOKUP_TABLE FlrLookupTable[];

struct ModuleParams
{
    ModuleParams(PCSTR ModName)
    {
        m_Name = ModName;
        m_Valid = FALSE;
    }

    ULONG64 GetBase(void)
    {
        return Update() == S_OK ? m_Base : 0;
    }
    ULONG GetSize(void)
    {
        return Update() == S_OK ? m_Size : 0;
    }
    BOOL Contains(ULONG64 Address)
    {
        if (Update() == S_OK)
        {
            return Address >= m_Base && Address < m_Base + m_Size;
        }

        return FALSE;
    }

private:
    HRESULT Update(void);

    PCSTR m_Name;
    BOOL m_Valid;
    ULONG64 m_Base;
    ULONG m_Size;
};

LONG
FaExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

BOOL
FaGetSymbol(
    ULONG64 Address,
    PCHAR Name,
    PULONG64 Disp,
    ULONG NameSize
    );

BOOL
FaIsFunctionAddr(
    ULONG64 IP,
    PSTR FuncName
    );

BOOL
FaGetFollowupInfo(
    IN OPTIONAL ULONG64 Addr,
    IN OPTIONAL PSTR SymbolName,
    OUT OPTIONAL PCHAR Owner,
    ULONG OwnerSize
    );

BOOL
FaShowFollowUp(
    PCHAR Name
    );

ULONG64
FaGetImplicitStackOffset(
    void
    );

LPSTR
TimeToStr(
    ULONG TimeDateStamp,
    BOOL DateOnly
    );


//----------------------------------------------------------------------------
//
// DebugFailureAnalysis.
//
//----------------------------------------------------------------------------

class DebugFailureAnalysis : public IDebugFailureAnalysis
{
public:
    DebugFailureAnalysis(void);
    ~DebugFailureAnalysis(void);

    //
    // IDebugFailureAnalysis.
    //

    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    STDMETHOD_(ULONG, GetFailureClass)(void);
    STDMETHOD_(DEBUG_FAILURE_TYPE, GetFailureType)(void);
    STDMETHOD_(ULONG, GetFailureCode)(void);
    STDMETHOD_(FA_ENTRY*, Get)(FA_TAG Tag);
    STDMETHOD_(FA_ENTRY*, GetNext)(FA_ENTRY* Entry, FA_TAG Tag,
                                   FA_TAG TagMask);
    STDMETHOD_(FA_ENTRY*, GetString)(FA_TAG Tag, PSTR Str, ULONG MaxSize);
    STDMETHOD_(FA_ENTRY*, GetBuffer)(FA_TAG Tag, PVOID Buf, ULONG Size);
    STDMETHOD_(FA_ENTRY*, GetUlong)(FA_TAG Tag, PULONG Value);
    STDMETHOD_(FA_ENTRY*, GetUlong64)(FA_TAG Tag, PULONG64 Value);
    STDMETHOD_(FA_ENTRY*, NextEntry)(FA_ENTRY* Entry);

    //
    // DebugFailureAnalysis.
    //

    virtual DEBUG_POOL_REGION GetPoolForAddress(ULONG64 Addr) = 0;
    virtual PCSTR DescribeAddress(ULONG64 Address) = 0;
    virtual FOLLOW_ADDRESS IsPotentialFollowupAddress(ULONG64 Address) = 0;
    virtual FOLLOW_ADDRESS IsFollowupContext(ULONG64 Address1,
                                             ULONG64 Address2,
                                             ULONG64 Address3) = 0;

    virtual FlpClasses GetFollowupClass(ULONG64 Address,
                                        PCSTR Module, PCSTR Routine) = 0;
    virtual BOOL CheckForCorruptionInHTE(ULONG64 hTableEntry,PCHAR Owner,
                                         ULONG OwnerSize) = 0;
    virtual BOOL IsManualBreakin(PDEBUG_STACK_FRAME Stk, ULONG Frames) = 0;

    void SetFailureClass(ULONG Class)
    {
        m_FailureClass = Class;
    }
    void SetFailureType(DEBUG_FAILURE_TYPE Type)
    {
        m_FailureType = Type;
    }
    void SetFailureCode(ULONG Code)
    {
        m_FailureCode = Code;
    }

    ULONG GetProcessingFlags(void)
    {
        return m_ProcessingFlags;
    }
    void SetProcessingFlags(ULONG Flags)
    {
        m_ProcessingFlags = Flags;
    }

    void Output();
    void OutputEntry(FA_ENTRY* Entry);
    void OutputEntryParam(DEBUG_FLR_PARAM_TYPE Type);
    BOOL AddCorruptModules(void);
    void GenerateBucketId(void);
    void DbFindBucketInfo(void);
    void AnalyzeStack(void);
    void FindFollowupOnRawStack(ULONG64 StackBase,
                                PFOLLOWUP_DESCS PossibleFollowups,
                                FlpClasses *BestClassFollowUp);
    BOOL GetTriageInfoFromStack(PDEBUG_STACK_FRAME Stack,
                                ULONG Frames,
                                ULONG64 Instruction,
                                PFOLLOWUP_DESCS PossibleFollowups,
                                FlpClasses *BestClassFollowUp);
    void SetSymbolNameAndModule(void);
    HRESULT CheckModuleSymbols(PSTR ModName, PSTR ShowName);
    void ProcessInformation(void);
    BOOL ProcessInformationPass(void);

    FA_ENTRY* Set(FA_TAG Tag, ULONG Size);
    FA_ENTRY* SetString(FA_TAG Tag, PSTR Str);
    FA_ENTRY* SetStrings(FA_TAG Tag, ULONG Count, PSTR* Strs);
    FA_ENTRY* SetBuffer(FA_TAG Tag, PVOID Buf, ULONG Size);
    FA_ENTRY* SetUlong(FA_TAG Tag, ULONG Value)
    {
        FA_ENTRY* Entry = SetBuffer(Tag, &Value, sizeof(Value));
        return Entry;
    }
    FA_ENTRY* SetUlong64(FA_TAG Tag, ULONG64 Value)
    {
        FA_ENTRY* Entry = SetBuffer(Tag, &Value, sizeof(Value));
        return Entry;
    }
    FA_ENTRY* SetUlong64s(FA_TAG Tag, ULONG Count, PULONG64 Values)
    {
        FA_ENTRY* Entry = SetBuffer(Tag, Values, Count * sizeof(*Values));
        return Entry;
    }

    FA_ENTRY* Add(FA_TAG Tag, ULONG Size);

    ULONG Delete(FA_TAG Tag, FA_TAG TagMask);
    void Empty(void);
    BOOL IsEmpty(void)
    {
        return m_DataUsed == 0;
    }

    BOOL ValidEntry(FA_ENTRY* Entry)
    {
        return (PUCHAR)Entry >= m_Data &&
            (ULONG)((PUCHAR)Entry - m_Data) < m_DataUsed;
    }


protected:
    ULONG m_Refs;
    ULONG m_FailureClass;
    DEBUG_FAILURE_TYPE m_FailureType;
    ULONG m_FailureCode;
    ULONG m_ProcessingFlags;

    PUCHAR m_Data;
    ULONG m_DataLen;
    ULONG m_DataUsed;

    FOLLOWUP_DESCS PossibleFollowups[MaxFlpClass];
    FlpClasses BestClassFollowUp;

    void PackData(PUCHAR Dst, ULONG Len)
    {
        PUCHAR Src = Dst + Len;
        memmove(Dst, Src, m_DataUsed - (ULONG)(Src - m_Data));
        m_DataUsed -= Len;
    }
    FA_ENTRY* AllocateEntry(ULONG FullSize);
};

class KernelDebugFailureAnalysis : public DebugFailureAnalysis
{
public:
    KernelDebugFailureAnalysis(void);

    virtual DEBUG_POOL_REGION GetPoolForAddress(ULONG64 Addr);
    virtual PCSTR DescribeAddress(ULONG64 Address);
    virtual FOLLOW_ADDRESS IsPotentialFollowupAddress(ULONG64 Address);
    virtual FOLLOW_ADDRESS IsFollowupContext(ULONG64 Address1,
                                             ULONG64 Address2,
                                             ULONG64 Address3);
    virtual FlpClasses GetFollowupClass(ULONG64 Address,
                                        PCSTR Module, PCSTR Routine);
    virtual BOOL CheckForCorruptionInHTE(ULONG64 hTableEntry,PCHAR Owner,
                                         ULONG OwnerSize);
    virtual BOOL IsManualBreakin(PDEBUG_STACK_FRAME Stk, ULONG Frames);

    BOOL AddCorruptingPool(ULONG64 Pool);
    ModuleParams m_KernelModule;
};

class UserDebugFailureAnalysis : public DebugFailureAnalysis
{
public:
    UserDebugFailureAnalysis(void);

    virtual DEBUG_POOL_REGION GetPoolForAddress(ULONG64 Addr);
    virtual PCSTR DescribeAddress(ULONG64 Address);
    virtual FOLLOW_ADDRESS IsPotentialFollowupAddress(ULONG64 Address);
    virtual FOLLOW_ADDRESS IsFollowupContext(ULONG64 Address1,
                                             ULONG64 Address2,
                                             ULONG64 Address3);
    virtual FlpClasses GetFollowupClass(ULONG64 Address,
                                        PCSTR Module, PCSTR Routine);
    virtual BOOL CheckForCorruptionInHTE(ULONG64 hTableEntry,PCHAR Owner,
                                         ULONG OwnerSize);
    virtual BOOL IsManualBreakin(PDEBUG_STACK_FRAME Stk, ULONG Frames)
    {
        return FALSE;
    }

    ModuleParams m_NtDllModule;
    ModuleParams m_Kernel32Module;
    ModuleParams m_Advapi32Module;
};

#endif // #ifndef __ANALYZE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\eng\test\test.cpp ===
#include <engexts.h>

//----------------------------------------------------------------------------
//
// StaticEventCallbacks.
//
//----------------------------------------------------------------------------

class StaticEventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

STDMETHODIMP_(ULONG)
StaticEventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StaticEventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// ExcepCallbacks.
//
//----------------------------------------------------------------------------

class ExcepCallbacks : public StaticEventCallbacks
{
public:
    ExcepCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        );

    HRESULT Initialize(PDEBUG_CLIENT Client)
    {
        HRESULT Status;
        
        m_Client = Client;
        m_Client->AddRef();
        
        if ((Status = m_Client->QueryInterface(__uuidof(IDebugControl),
                                               (void**)&m_Control)) == S_OK)
        {
            // Turn off default breakin on breakpoint exceptions.
            Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                        "sxd bpe", DEBUG_EXECUTE_DEFAULT);
        }

        return Status;
    }
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }
    
private:
    PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
};

STDMETHODIMP
ExcepCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXCEPTION;
    return S_OK;
}
    
STDMETHODIMP
ExcepCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    m_Control->Output(DEBUG_OUTPUT_NORMAL, "Exception %X at %p, chance %d\n",
                      Exception->ExceptionCode, Exception->ExceptionAddress,
                      FirstChance ? 1 : 2);
    return DEBUG_STATUS_GO_HANDLED;
}

ExcepCallbacks g_ExcepCallbacks;

//----------------------------------------------------------------------------
//
// FnProfCallbacks.
//
//----------------------------------------------------------------------------

class FnProfCallbacks : public StaticEventCallbacks
{
public:
    FnProfCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );

    HRESULT Initialize(PDEBUG_CLIENT Client, PDEBUG_CONTROL Control)
    {
        m_Hits = 0;
        
        m_Client = Client;
        m_Client->AddRef();
        m_Control = Control;
        m_Control->AddRef();
        
        return S_OK;
    }
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }

    ULONG GetHits(void)
    {
        return m_Hits;
    }
    PDEBUG_CONTROL GetControl(void)
    {
        return m_Control;
    }
    
private:
    PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
    ULONG m_Hits;
};

STDMETHODIMP
FnProfCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_BREAKPOINT;
    return S_OK;
}
    
STDMETHODIMP
FnProfCallbacks::Breakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    PDEBUG_CLIENT Client;
    HRESULT Status = DEBUG_STATUS_NO_CHANGE;
    
    // If this is one of our profiling breakpoints
    // record the function hit and continue on.
    if (Bp->GetAdder(&Client) == S_OK)
    {
        if (Client == m_Client)
        {
            m_Hits++;
            Status = DEBUG_STATUS_GO;
        }
        
        Client->Release();
    }

    Bp->Release();
    return Status;
}

FnProfCallbacks g_FnProfCallbacks;

//----------------------------------------------------------------------------
//
// Extension entry points.
//
//----------------------------------------------------------------------------

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    g_ExcepCallbacks.Uninitialize();
    g_FnProfCallbacks.Uninitialize();
}

#if 0
extern "C" HRESULT CALLBACK
teb(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    ULONG64 DataOffset;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }
    
    if (*Args)
    {
        sscanf(Args, "%I64x", &DataOffset);
    }
    else
    {
        g_ExtSystem->GetCurrentThreadDataOffset(&DataOffset);
    }
    
    ExtOut("TEB at %I64x\n", DataOffset);

    TEB Teb;

    Status = g_ExtData->ReadVirtual(DataOffset, &Teb, sizeof(Teb), NULL);
    if (Status != S_OK)
    {
        ExtErr("* Unable to read TEB\n");
    }
    else
    {
        ExtOut("    ExceptionList:    %x\n", Teb.NtTib.ExceptionList);
        ExtOut("    Stack Base:       %x\n", Teb.NtTib.StackBase);
        ExtOut("    Stack Limit:      %x\n", Teb.NtTib.StackLimit);
        ExtOut("    SubSystemTib:     %x\n", Teb.NtTib.SubSystemTib);
        ExtOut("    FiberData:        %x\n", Teb.NtTib.FiberData);
        ExtOut("    ArbitraryUser:    %x\n", Teb.NtTib.ArbitraryUserPointer);
        ExtOut("    Self:             %x\n", Teb.NtTib.Self);
        ExtOut("    EnvironmentPtr:   %x\n", Teb.EnvironmentPointer);
        ExtOut("    ClientId:         %x.%x\n",
               Teb.ClientId.UniqueProcess, Teb.ClientId.UniqueThread);
        if (Teb.ClientId.UniqueProcess != Teb.RealClientId.UniqueProcess ||
            Teb.ClientId.UniqueThread != Teb.RealClientId.UniqueThread)
        {
            ExtOut("    Real ClientId:    %x.%x\n",
                   Teb.RealClientId.UniqueProcess,
                   Teb.RealClientId.UniqueThread);
        }
        ExtOut("    Real ClientId:    %x.%x\n",
               Teb.RealClientId.UniqueProcess,
               Teb.RealClientId.UniqueThread);
        ExtOut("    RpcHandle:        %x\n", Teb.ActiveRpcHandle);
        ExtOut("    Tls Storage:      %x\n", Teb.ThreadLocalStoragePointer);
        ExtOut("    PEB Address:      %x\n", Teb.ProcessEnvironmentBlock);
        ExtOut("    LastErrorValue:   %u\n", Teb.LastErrorValue);
        ExtOut("    LastStatusValue:  %x\n", Teb.LastStatusValue);
        ExtOut("    Count Owned Locks:%u\n", Teb.CountOfOwnedCriticalSections);
        ExtOut("    HardErrorMode:    %u\n", Teb.HardErrorMode);

        Status = S_OK;
    }

    ExtRelease();
    return Status;
}
#endif

extern "C" HRESULT CALLBACK
outreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    g_ExtRegisters->OutputRegisters(DEBUG_OUTCTL_ALL_CLIENTS,
                                    DEBUG_REGISTERS_ALL);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
enumreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Num;

    g_ExtRegisters->GetNumberRegisters(&Num);
    ExtOut("%d registers\n", Num);

    ULONG i;
    char Name[64];
    DEBUG_REGISTER_DESCRIPTION Desc;
    ULONG Reax, Rebx, Refl, Rsf, Rst0;
    ULONG RegFound = 0;

    for (i = 0; i < Num; i++)
    {
        g_ExtRegisters->GetDescription(i, Name, sizeof(Name), NULL, &Desc);

        ExtOut("  %2d: \"%s\", type %d, flags %X\n",
               i, Name, Desc.Type, Desc.Flags);
        if (Desc.Flags & DEBUG_REGISTER_SUB_REGISTER)
        {
            ExtOut("      sub to %d, len %d, mask %I64X, shift %d\n",
                   Desc.SubregMaster, Desc.SubregLength,
                   Desc.SubregMask, Desc.SubregShift);
        }
        
        // XXX drewb - Hack for testing purposes.
        if (!_strcmpi(Name, "eax"))
        {
            Reax = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "ebx"))
        {
            Rebx = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "efl"))
        {
            Refl = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "sf"))
        {
            Rsf = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "st0"))
        {
            Rst0 = i;
            RegFound++;
        }
    }

    ULONG ProcType;

    g_ExtControl->GetExecutingProcessorType(&ProcType);
    ExtOut("Processor type %d\n", ProcType);
    
    if (ProcType == IMAGE_FILE_MACHINE_I386)
    {
        DEBUG_VALUE Val;
        DEBUG_VALUE Coerce;

        if (RegFound != 5)
        {
            ExtErr("** Only found %d registers\n", RegFound);
        }
        
        Val.Type = DEBUG_VALUE_INT32;
        Val.I32 = 0x12345678;
        g_ExtRegisters->SetValue(Reax, &Val);
        Val.I32 = 12345678;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,st0", DEBUG_EXECUTE_NOT_LOGGED);

        Val.Type = DEBUG_VALUE_FLOAT32;
        Val.F32 = 1.2345f;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r st0", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rst0, &Val);
        ExtOut("st0 type is %d\n", Val.Type);
        
        g_ExtControl->CoerceValue(&Val, DEBUG_VALUE_FLOAT32, &Coerce);
        Coerce.F32 *= 2.0f;
        ExtOut("coerce type is %d, val*2 %hf\n", Coerce.Type, Coerce.F32);
        
        g_ExtRegisters->SetValue(Reax, &Val);
        g_ExtRegisters->SetValue(Rebx, &Coerce);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,ebx", DEBUG_EXECUTE_NOT_LOGGED);

        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
symnear(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    LONG Delta;

    Delta = 0;
    sscanf(Args, "%d", &Delta);
    
    ULONG64 Instr;
    char Name[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetNearNameByOffset(Instr, Delta,
                                          Name, sizeof(Name), NULL,
                                          &Disp) == S_OK)
    {
        ExtOut("Symbol %d away from %p is:\n  %s + 0x%I64x\n",
               Delta, Instr, Name, Disp);
        
        if (g_ExtSymbols->GetOffsetByName(Name, &Instr) == S_OK)
        {
            ExtOut("Symbol %s has offset %p\n", Name, Instr);
        }
        else
        {
            ExtOut("Symbol %s has no offset\n", Name);
        }
    }
    else
    {
        ExtOut("No symbol %d away from %p\n", Delta, Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
symname(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Offs;
    
    if (g_ExtSymbols->GetOffsetByName(Args, &Offs) == S_OK)
    {
        ExtOut("Symbol %s has offset %I64x\n",
               Args, Offs);
    }
    else
    {
        ExtOut("Symbol %s has no offset\n", Args);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
line(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Instr;
    ULONG Line;
    char File[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetLineByOffset(Instr, &Line,
                                      File, sizeof(File), NULL, &Disp) == S_OK)
    {
        ExtOut("Line at %p is:\n  %s(%d) + 0x%I64x\n",
               Instr, File, Line, Disp);

        if (g_ExtSymbols->GetOffsetByLine(Line, File, &Instr) == S_OK)
        {
            ExtOut("Line %s(%d) has offset %p\n", File, Line, Instr);
        }
        else
        {
            ExtOut("Line %s(%d) has no offset\n", File, Line);
        }
    }
    else
    {
        ExtOut("No line information for %p\n", Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
sympat(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Match;
    char Name[128];
    ULONG64 Offset;
    PCSTR Pattern;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        Pattern = Args;
    }
    else
    {
        Pattern = "*";
    }

    Status = g_ExtSymbols->StartSymbolMatch(Pattern, &Match);
    if (Status != S_OK)
    {
        ExtErr("Unable to match on '%s'\n", Pattern);
    }
    else
    {
        for (;;)
        {
            Status = g_ExtSymbols->
                GetNextSymbolMatch(Match, Name, sizeof(Name), NULL, &Offset);
            if (Status != S_OK)
            {
                break;
            }

            ExtOut("%p - %s\n", Offset, Name);

            if (g_ExtControl->GetInterrupt() == S_OK)
            {
                ExtOut("** interrupt\n");
                break;
            }
        }

        g_ExtSymbols->EndSymbolMatch(Match);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
stack(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Flags;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        sscanf(Args, "%d", &Flags);
    }
    else
    {
        Flags = 0;
    }
    
    DEBUG_STACK_FRAME Frames[4];
    ULONG64 FrameOff, StackOff, InstrOff;
    ULONG Filled;

    g_ExtRegisters->GetFrameOffset(&FrameOff);
    g_ExtRegisters->GetStackOffset(&StackOff);
    g_ExtRegisters->GetInstructionOffset(&InstrOff);
    
    if (g_ExtControl->GetStackTrace(FrameOff, StackOff, InstrOff,
                                    Frames, sizeof(Frames) / sizeof(Frames[0]),
                                    &Filled) != S_OK)
    {
        ExtErr("Unable to get stack trace\n");
    }
    else
    {
        ExtOut("Filled %d frames at %p\n", Filled, InstrOff);
        g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                                       Frames, Filled, Flags);
    }

    ExtOut("\nDirect:\n");
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                                   NULL, 20, Flags);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tyid(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    ULONG TypeSize;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }

    if (Status == S_OK)
    {
        ExtOut("Type ID of '%s' is %d\n", Args, TypeId);
    }
    else
    {
        ExtErr("Unable to get type ID, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
typeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    ULONG TypeSize;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }
    if (Status == S_OK)
    {
        Status = g_ExtSymbols->GetTypeName(Module, TypeId, Type, sizeof(Type),
                                           &TypeSize);
    }

    if (Status == S_OK)
    {
        ExtOut("Type of '%s' is '%s':%d (%d chars)\n",
               Args, Type, TypeId, TypeSize);
    }
    else
    {
        ExtErr("Unable to get type, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tsizeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    PCSTR TypeName;
    ULONG TypeId;
    ULONG TypeSize;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    TypeName = strchr(Args, '!');
    if (TypeName == NULL)
    {
        ExtErr("Must specify Module!Type\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, TypeName, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeSize(Module, TypeId, &TypeSize);
        }
    
        if (Status == S_OK)
        {
            ExtOut("Type '%s':%d is %d bytes\n",
                   Args, TypeId, TypeSize);
        }
        else
        {
            ExtErr("Unable to get type size, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
foff(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    PCSTR Bang, Dot;
    ULONG Offset;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Dot = strchr(Bang + 1, '.');
    }
    if (Bang == NULL || Dot == NULL)
    {
        ExtErr("Syntax is Module!Type.Field\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        memcpy(Type, Bang + 1, Dot - (Bang + 1));
        Type[Dot - (Bang + 1)] = 0;
        Dot++;

        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetFieldOffset(Module, TypeId, Dot,
                                                  &Offset);
        }
        
        if (Status == S_OK)
        {
            ExtOut("Offset of %s is %d bytes\n",
                   Args, Offset);
        }
        else
        {
            ExtErr("Unable to get field offset, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
otype(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    PCSTR Bang, Space;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Space = strchr(Bang + 1, ' ');
    }
    if (Bang == NULL || Space == NULL)
    {
        ExtErr("Syntax is Module!Type Address\n");
        Status = E_INVALIDARG;
    }
    else
    {
        memcpy(Type, Bang + 1, Space - (Bang + 1));
        Type[Space - (Bang + 1)] = 0;
        Space++;

        ULONG64 Module;
        ULONG Flags = DEBUG_OUTTYPE_RECURSION_LEVEL(15);
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Space, DEBUG_VALUE_INT64, &IntVal, NULL);
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->
                OutputTypedDataVirtual(DEBUG_OUTCTL_ALL_CLIENTS,
                                       IntVal.I64, Module, TypeId, Flags);
            if (Status != S_OK)
            {
                ExtErr("Unable to output data, %X\n", Status);
            }
        }
        else
        {
            ExtErr("Unable to get type ID, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vsearch(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    ULONG Chars;
    
    sscanf(Args, "%x %x%n", &Start, &Len, &Chars);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len Byte+\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Pattern[32];
        ULONG PatLen;

        Args += Chars;
        PatLen = 0;
        for (;;)
        {
            while (*Args == ' ' || *Args == '\t')
            {
                Args++;
            }

            if (*Args == 0)
            {
                break;
            }

            sscanf(Args, "%x", &Pattern[PatLen]);
            PatLen++;

            while (*Args != 0 && *Args != ' ' && *Args != '\t')
            {
                Args++;
            }
        }

        ULONG64 Match;
        
        Status = g_ExtData->SearchVirtual(Start, Len, Pattern, PatLen, 1,
                                          &Match);
        if (Status == S_OK)
        {
            ExtOut("Match at %p\n", Match);
        }
        else
        {
            ExtErr("Search failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vread(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    
    sscanf(Args, "%x %x", &Start, &Len);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Buffer[16384];
        ULONG Read;

        if (Len > sizeof(Buffer))
        {
            ExtWarn("Buffer is only %X bytes, clamping\n", sizeof(Buffer));
            Len = sizeof(Buffer);
        }
        
        Status = g_ExtData->ReadVirtual(Start, Buffer, Len, &Read);
        if (Status == S_OK)
        {
            ExtOut("Read %X bytes\n", Read);
        }
        else
        {
            ExtErr("Read failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
watch(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    PDEBUG_CLIENT Watcher = NULL;

    if ((Status = Client->CreateClient(&Watcher)) != S_OK)
    {
        goto Exit;
    }

    if ((Status = Watcher->SetEventCallbacks(&g_ExcepCallbacks)) != S_OK)
    {
        goto Exit;
    }

    g_ExcepCallbacks.Uninitialize();
    Status = g_ExcepCallbacks.Initialize(Watcher);

 Exit:
    EXT_RELEASE(Watcher);
    if (Status != S_OK)
    {
        ExtErr("Unable to watch, 0x%X\n", Status);
        g_ExcepCallbacks.Uninitialize();
    }
    
    return Status;
}

extern "C" HRESULT CALLBACK
fnprof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    PDEBUG_CLIENT Profiler = NULL;
    PDEBUG_CONTROL ProfCtrl = NULL;
    PDEBUG_BREAKPOINT Bp = NULL;
    static ULONG s_BpId = DEBUG_ANY_ID;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (!*Args)
    {
        goto Exit;
    }

    if (!_strcmpi(Args, "-end"))
    {
        ULONG64 Offset;
        char OffsetExpr[512];
        
        if (s_BpId == DEBUG_ANY_ID)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }
        
        if ((Status = g_FnProfCallbacks.GetControl()->
             GetBreakpointById(s_BpId, &Bp)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->GetOffset(&Offset)) != S_OK)
        {
            Offset = DEBUG_INVALID_OFFSET;
        }
        if ((Status = Bp->GetOffsetExpression(OffsetExpr,
                                              sizeof(OffsetExpr),
                                              NULL)) != S_OK)
        {
            goto Exit;
        }

        ExtOut("%s ", OffsetExpr);
        if (Offset != DEBUG_INVALID_OFFSET)
        {
            ExtOut("(%p) ", Offset);
        }
        ExtOut("was hit %d times\n", g_FnProfCallbacks.GetHits());

        g_FnProfCallbacks.GetControl()->RemoveBreakpoint(Bp);
        Bp = NULL;
        s_BpId = DEBUG_ANY_ID;
        g_FnProfCallbacks.Uninitialize();
    }
    else
    {
        if (s_BpId != DEBUG_ANY_ID)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }
        
        if ((Status = Client->CreateClient(&Profiler)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Profiler->SetEventCallbacks(&g_FnProfCallbacks)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Profiler->QueryInterface(__uuidof(IDebugControl),
                                               (void **)&ProfCtrl)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = ProfCtrl->AddBreakpoint(DEBUG_BREAKPOINT_CODE,
                                              DEBUG_ANY_ID, &Bp)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->SetOffsetExpression(Args)) != S_OK)
        {
            goto Exit;
        }
        
        if ((Status = Bp->AddFlags(DEBUG_BREAKPOINT_ADDER_ONLY |
                                   DEBUG_BREAKPOINT_ENABLED)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->GetId(&s_BpId)) != S_OK)
        {
            goto Exit;
        }
        
        g_FnProfCallbacks.Uninitialize();
        if ((Status = g_FnProfCallbacks.Initialize(Profiler,
                                                   ProfCtrl)) != S_OK)
        {
            goto Exit;
        }

        ExtOut("Added breakpoint %d on %s\n", s_BpId, Args);
        Bp = NULL;
    }

 Exit:
    if (Bp != NULL)
    {
        if (ProfCtrl != NULL)
        {
            ProfCtrl->RemoveBreakpoint(Bp);
        }
        else
        {
            Bp->Release();
        }
    }
    EXT_RELEASE(ProfCtrl);
    EXT_RELEASE(Profiler);
    if (Status != S_OK)
    {
        ExtErr("Unable to profile, 0x%X\n", Status);
        g_FnProfCallbacks.Uninitialize();
    }

    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vtrans(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    if (g_ExtData2 != NULL)
    {
        ULONG64 PhysOffs[8];
        ULONG Levels;
        DEBUG_VALUE Virt;
        
        if ((Status = g_ExtControl->
             Evaluate(Args, DEBUG_VALUE_INT64, &Virt, NULL)) == S_OK)
        {
            Status = g_ExtData2->
                GetVirtualTranslationPhysicalOffsets(Virt.I64, PhysOffs,
                                                     sizeof(PhysOffs) /
                                                     sizeof(PhysOffs[0]),
                                                     &Levels);
            if (SUCCEEDED(Status))
            {
                ULONG i;

                ExtOut("%I64X translates in %d levels:\n",
                       Virt.I64, Levels);
                for (i = 0; i < Levels; i++)
                {
                    ExtOut("  %I64X\n", PhysOffs[i]);
                }
            }
            else
            {
                ExtErr("Unable to translate %I64X, 0x%X\n",
                       Virt.I64, Status);
            }
        }
        else
        {
            ExtErr("Unable to evaluate '%s', 0x%X\n", Args, Status);
        }
    }
    else
    {
        ExtErr("Debugger does not support IDebugDataSpaces2\n");
    }

    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
enummod(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Num[2];
    ULONG Type, i, Index;
    DEBUG_MODULE_PARAMETERS Params;

    if ((Status = g_ExtSymbols->GetNumberModules(&Num[0],
                                                 &Num[1])) != S_OK)
    {
        ExtErr("GetNumberModules failed, 0x%X\n", Status);
        goto Exit;
    }

    ExtOut("%d modules, %d unloaded modules\n", Num[0], Num[1]);

    Index = -1;
    for (Type = 0; Type < 2; Type++)
    {
        if (!Num[Type])
        {
            continue;
        }
        
        switch(Type)
        {
        case 0:
            ExtOut("Loaded:\n");
            ExtOut("-------\n");
            break;
        case 1:
            ExtOut("Unloaded:\n");
            ExtOut("---------\n");
            break;
        }
        
        for (i = 0; i < Num[Type]; i++)
        {
            if ((Status = g_ExtSymbols->
                 GetModuleParameters(1, NULL, ++Index, &Params)) != S_OK)
            {
                ExtErr("  GetModuleParameters failed, 0x%X\n", Status);
                continue;
            }
            
            ExtOut("  Base %p, size %08x\n", Params.Base, Params.Size);
            ExtOut("    Flags %08x\n", Params.Flags);
        }
    }

 Exit:
    ExtRelease();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\bugcheck.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    bugcheck.h

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

    Kshitix K. Sharma (kksharma)

    bugcheck analyzer headers.

--*/

#ifndef _BUGCHECK_H_
#define _BUGCHECK_H_

#include "bugcodes.h"
#include "extsfns.h"


typedef struct _BUGCHECK_ANALYSIS
{
    ULONG Code;
    ULONG64 Args[4];
    PCHAR szName;
    PCHAR szDescription;
    PCHAR szParamsDesc[4];
} BUGCHECK_ANALYSIS, *PBUGCHECK_ANALYSIS;


typedef void (WINAPI *PBUGCHECK_EXAMINE) (
    PBUGCHECK_ANALYSIS pBugCheck
);

typedef struct _BUGDESC_APIREFS {
    ULONG Code;
    PBUGCHECK_EXAMINE pExamineRoutine;
} BUGDESC_APIREFS, *PBUGDESC_APIREFS;


// why is this not defined in bugcodes.h ??
#ifndef HEAP_INITIALIZATION_FAILED
#define HEAP_INITIALIZATION_FAILED       0x5D
#endif

BOOL
ReadUnicodeString(
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG BufferSize,
    PULONG StringSize);

BOOL
BcGetDriverNameFromIrp(
    DebugFailureAnalysis* Analysis,
    ULONG64 Irp,
    ULONG64 DevObj,
    ULONG64 DrvObj
    );

BOOL
BcIsCpuOverClocked(
    void
    );

KernelDebugFailureAnalysis*
BcAnalyze(
    OUT PBUGCHECK_ANALYSIS Bc,
    ULONG Flags
    );

HRESULT
AnalyzeBugCheck(
    PCSTR args
    );

#endif // _BUGCHECK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\crdb.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    crdb.cpp

Abstract:
    Handles database queries for crash buckets

Environment:

    User Mode.

--*/

#include "precomp.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include <shlwapi.h>
#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#include "ocamon.h"

#define  LvlDatabaseInitDone 1
#define  LvlCrashAddedToDB   2
#define  LvlCustomerDbUpdate 4
#define  LvlMessageQReply    8

LPOLESTR g_lpwszGetAll = L"SELECT * from CrashInstances";
LPOLESTR g_lpwszCrashInstanceTable = L"CrashInstances";
LPOLESTR g_lpwszBucketTable = L"BucketToInt";
LPOLESTR g_lpwszBucketMapTable = L"BucketToCrash";
LPOLESTR g_lpwszMachineInfoTable = L"MachineDescription";
LPOLESTR g_lpwszOverClkTable = L"OverClocked";
LPOLESTR g_lpwszSolutionsTable = L"SolutionMap";
LPOLESTR g_lpwszRaidTable = L"RaidBugs";
LPSTR g_lpszBaseUrl = "https://oca.microsoft.com/secure/response.asp?";

CrashDatabaseHandler *g_CrDb = NULL;
CustDatabaseHandler *g_CustDb = NULL;
SolutionDatabaseHandler *g_SolDb = NULL;
BOOL g_ComInitialized = FALSE;

static bool fResetFilter = false;

void
ansi2wchr(
    const PCHAR astr,
    PWCHAR wstr
    );


HRESULT
ExtDllInitDynamicCalls(
    PDEBUG_CONTROL3 DebugControl
    )
//
// Load Ole32 and OleAut32 dlls
//
{
    HRESULT Hr;
    ULONG EngineOptions;

    if ((Hr = DebugControl->GetEngineOptions(&EngineOptions)) == S_OK)
    {
        if (EngineOptions & DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS)
        {
            // Do not use ole32 APIs when we disallow network paths
            return E_FAIL;
        }
        if ((Hr = InitDynamicCalls(&g_Ole32CallsDesc)) != S_OK)
        {
            return Hr;
        }
        if ((Hr = InitDynamicCalls(&g_OleAut32CallsDesc)) != S_OK)
        {
            return Hr;
        }
        if ((Hr = InitDynamicCalls(&g_ShlWapiCallsDesc)) != S_OK)
        {
            return Hr;
        }
        return S_OK;
    }
    return Hr;
}
void BuildCrashId(ULONG UpTime, ULONG CrashTime, PULONG64 pCID)
{
    ULONG64 u64 = CrashTime;
    *pCID = (u64 << 32) + UpTime;
}

#ifdef _NEED_EVENT_LOGS_

LPCSTR c_szEventLogKey          = "System\\CurrentControlSet\\Services\\EventLog\\Application";
LPCSTR c_szEventLogSource       = "OcaDbAddCrash";
LPCSTR c_szEventLogMsgFile      = "EventMessageFile";
LPCSTR c_szEventLogTypes        = "TypesSupported";


HRESULT
SetupEventLogging(
    void
    )
{
    HKEY hEvLog = NULL;
    HKEY hEvLogSource = NULL;
    LONG err = ERROR_SUCCESS;
    CHAR AppName[MAX_PATH];

    if ((err = RegOpenKey(HKEY_LOCAL_MACHINE,
                          c_szEventLogKey, &hEvLog)) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32( err );
    }

    if ((err = RegOpenKey(hEvLog, c_szEventLogSource,
                           &hEvLogSource)) != ERROR_SUCCESS)
    {
        DWORD AllowTypes;
        //
        // OCA logging hasn't been registered on this system yet
        // try to setup the registry values for logging
        //
        err = RegCreateKey(hEvLog, c_szEventLogSource, &hEvLogSource);
        if (err != ERROR_SUCCESS)
        {
            goto Exit;
        }

        if (!GetModuleFileName(NULL, AppName, sizeof(AppName)))
        {
            err = GetLastError();
            goto Exit;
        } else
        {
            PSTR FileName = strrchr(AppName, '\\');

            if (FileName)
            {
                StringCbCopy(FileName+1, sizeof(AppName) - strlen(FileName), "winext\\ext.dll");
            }
        }
        if ((err = RegSetValueEx(hEvLogSource, c_szEventLogMsgFile, 0,
                                 REG_SZ, (BYTE *) AppName,
                                 strlen(AppName)+1)) != ERROR_SUCCESS)
        {
            goto Exit;
        }
        AllowTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
        if ((err = RegSetValueEx(hEvLogSource, c_szEventLogTypes, 0,
                                 REG_DWORD, (BYTE *) &AllowTypes,
                                 sizeof(AllowTypes))) != ERROR_SUCCESS)
        {
            goto Exit;
        }
    } else
    {
        //
        // Assume we have values set up propperly...
        //
    }
Exit:
    if (hEvLog != NULL)
    {
        RegCloseKey(hEvLog);
    }
    if (hEvLogSource != NULL)
    {
        RegCloseKey(hEvLogSource);
    }
    return HRESULT_FROM_WIN32(err);
}

void
DbAddCrashEventLog(
    HRESULT hrAddCrash,
    DWORD LevelFinished,
    PCRASH_INSTANCE Crash
    )
{
    HANDLE hEventSrc;
    HRESULT Hr;
    CHAR LogBuffer[2048];

    if (FAILED(SetupEventLogging()))
    {
        return;
    }
    hEventSrc = RegisterEventSource(NULL, c_szEventLogSource);

    if (hEventSrc == NULL ||
        hEventSrc == INVALID_HANDLE_VALUE)
    {
        return;
    }

    Hr = StringCbPrintf(LogBuffer, sizeof(LogBuffer),
                   "GUID: %s\n"
                   "BUCKET: %s\n"
                   "GENERIC_BUCKET: %s\n"
                   "SOLUTION_ID: 0x%03lx\n"
                   "SOLUTION_TYPE: %ld\n"
                   "ARCHIVE_PATH: %s\n"
                   "RESULT: 0x%08lx\n",
                   Crash->MesgGuid,
                   Crash->Bucket,
                   Crash->DefaultBucket,
                   Crash->SolutionId,
                   Crash->SolutionType,
                   Crash->Path,
                   hrAddCrash);
    if (Hr == S_OK)
    {
        WORD wCategory = 0;
        LPCSTR pStringArr = LogBuffer;
        ReportEvent(hEventSrc,
                    EVENTLOG_INFORMATION_TYPE,
                    wCategory,
                    FAILED(hrAddCrash) ? EXT_ADDCRASH_FAILED : EXT_CRASH_SOLVED,
                    NULL,
                    1,
                    0,
                    &pStringArr,
                    NULL);

    }
    DeregisterEventSource(hEventSrc);
}
#endif // _NEED_EVENT_LOGS_

void
DbAddCrashReportToMonitor(
    HRESULT hrAddCrash,
    DWORD LevelFinished,
    PCRASH_INSTANCE Crash
    )
{
    HANDLE hPipe;
    DWORD dwMode, cbWritten;
    OCAKD_MONITOR_MESSAGE Msg;
    OVERLAPPED WriteOverlapped;

    Msg.MessageId = OKD_MESSAGE_DEBUGGER_RESULT;
    Msg.u.KdResult.SizeOfStruct = sizeof(Msg.u.KdResult);
    Msg.u.KdResult.hrAddCrash   = hrAddCrash;
    Msg.u.KdResult.SolutionId   = Crash->SolutionId;
    Msg.u.KdResult.ResponseType = Crash->SolutionType;
    Msg.u.KdResult.CrashGuid[0] = 0;
    Msg.u.KdResult.BucketId[0]  = 0;
    Msg.u.KdResult.ArchivePath[0] = 0;
    if (Crash->MesgGuid)
    {
        StringCbCopy(Msg.u.KdResult.CrashGuid,   sizeof(Msg.u.KdResult.CrashGuid),
                     Crash->MesgGuid);
    }
    if (Crash->Bucket)
    {
        StringCbCopy(Msg.u.KdResult.BucketId,    sizeof(Msg.u.KdResult.BucketId),
                     Crash->Bucket);
    }
    if (Crash->ArchiveFileName)
    {
        StringCbCopy(Msg.u.KdResult.ArchivePath, sizeof(Msg.u.KdResult.ArchivePath),
                     Crash->ArchiveFileName);
    }


    for (;;)
    {
        hPipe = CreateFile(c_tszCollectPipeName, FILE_WRITE_DATA,
                           0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED,
                           NULL);
        if (hPipe != INVALID_HANDLE_VALUE)
        {
            break;
        }
        if (GetLastError() != ERROR_PIPE_BUSY)
        {
            return;
        }
        if (!WaitNamedPipe(c_tszCollectPipeName, 5*60*1000))
        {
            return;
        }
    }

    // We are now connected to pipe

    // Set the message mode on pipe
/*    dwMode = PIPE_READMODE_MESSAGE;
    if (!SetNamedPipeHandleState(hPipe, &dwMode,
                                 NULL, NULL))
    {
        CloseHandle(hPipe);
        return;
    }
*/

    WriteOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (WriteOverlapped.hEvent != NULL)
    {
        // Send crash information to monitor pipe
        if (!WriteFile(hPipe, (LPVOID) &Msg, sizeof(Msg),
                       &cbWritten, &WriteOverlapped))
        {

            if (GetLastError() == ERROR_IO_PENDING ||
                !GetOverlappedResult(hPipe, &WriteOverlapped, &cbWritten,
                                     TRUE))
            {
                // failed to write, exit silently
                // Its up to monitor if it is keeping track of kds launched
            }

        }
        CloseHandle(WriteOverlapped.hEvent);
    }
    FlushFileBuffers(hPipe);
    CloseHandle(hPipe);
    return;
}

void
OcaKdLog(
    LPSTR Qual,
    LPSTR szMesg1,
    LPSTR szMesg2,
    ULONG Err
    )
{
    BOOL bOnce = FALSE;
    PSTR szLogFile;


    if (szLogFile = g_pTriager->GetFollowupStr("debugger-params",
                                   "dbfailurelog"))
    {
        int   hLogFile;
        CHAR  Log[300];


         hLogFile = _open(szLogFile, O_APPEND | O_CREAT | O_RDWR,
                          S_IREAD | S_IWRITE);

         if (hLogFile != -1 &&
             StringCbPrintf(Log, sizeof(Log), "%15s: %0lx - %20s, %s\n",
                            Qual, Err, szMesg1, szMesg2) == S_OK)
         {
             _write(hLogFile, Log, strlen(Log));
             _close(hLogFile);
         }
    }
}

BOOL
OpenSysDataFileFromCab(
    CHAR *CabFile,
    HANDLE *FileHandle
    )
{
    CHAR SysDataFile[2 * MAX_PATH];
    INT_PTR CabFh;
    HRESULT Status;

    Status = ExpandDumpCab(CabFile,
                  _O_CREAT | _O_EXCL | _O_TEMPORARY,
                  "sysdata.xml",
                  SysDataFile, DIMA(SysDataFile),
                  &CabFh);
    if (Status != S_OK)
    {
        goto exitSysDataFileOpen;
    }


    *FileHandle = CreateFile(SysDataFile, GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if (*FileHandle == NULL || *FileHandle == INVALID_HANDLE_VALUE)
    {
        Status = E_FAIL;
    }
    if (CabFh >= 0)
    {
        // no longer needed
        _close((int)CabFh);
    }

exitSysDataFileOpen:

    return Status == S_OK;
}


ULONG
ScanForId(
    PVOID pBuffer,
    ULONG64 Size
    )
{
    const WCHAR cwszOEMIdTag[] = L"<HARDWAREID>PCI\\VEN_";
    PWCHAR Scan, Match, End;
    ULONG FreqId = 0;
#define MAX_OEM_IDS 50
    struct {
        ULONG Id;
        ULONG Count;
    } FoundIds[MAX_OEM_IDS] = {0};

    Scan = (PWCHAR) pBuffer;
    End = (PWCHAR) ( ((PCHAR) pBuffer) + (ULONG_PTR) Size );
    while (Scan < End)
    {
        Match = (PWCHAR) &cwszOEMIdTag[0];
        while (*Scan++ == *Match++);
        if (!*Match)
        {
            --Scan;
            // Match the tag
            //      <HARDWAREID>PCI\VEN_8086&amp;DEV_2532&amp;SUBSYS_00000000&amp;REV_02</HARDWAREID>
            //                          ^ Scan
            WCHAR Line[61], *Subsys;
            ULONG Id1 = 0, Id2 = 0;
            StringCbCopyNW(Line, sizeof(Line),Scan, sizeof(Line) - sizeof(WCHAR));
            swscanf(Line, L"%lx", &Id1);
            Subsys = wcsstr(Line, L"SUBSYS_");
            if (Subsys)
            {
                Subsys += 7;
                swscanf(Subsys, L"%lx", &Id2);
                Id2 &= 0xffff;

                if (Id2 != Id1 && Id2 != 0)
                {
                    // We foud a oem Id, store it
                    for (int i = 0; i<MAX_OEM_IDS; i++)
                    {
                        if (FoundIds[i].Id == Id2)
                        {
                            FoundIds[i].Count++;
                        } else if (FoundIds[i].Id == 0)
                        {
                            FoundIds[i].Count = 1;
                            FoundIds[i].Id = Id2;
                        }
                    }
                }
            }
//          dprintf("PCI\\VEN_%ws\n Id1 %lx Id2 %lx\n", Line, Id1, Id2);
        }
    }

    ULONG Count = 0;
    for (int i = 0; i<MAX_OEM_IDS; i++)
    {
        if (FoundIds[i].Count > Count)
        {
            FreqId = FoundIds[i].Id;
        }
    }
//  dprintf("Found %lx\n", FreqId);
    return FreqId;
}


ULONG
GetOEMId(
    PCHAR szCabFile
    )
{
    ULONG SizeLow, SizeHigh;
    HANDLE hSysDataFile = NULL, hMap = NULL;
    PVOID pFileMap = NULL;
    ULONG OEMId = 0;

    if (!OpenSysDataFileFromCab(szCabFile, &hSysDataFile))
    {
        goto exitGetOEMID;
    }

    SizeLow = GetFileSize(hSysDataFile, &SizeHigh);

    ULONG BytesRead;

    hMap = CreateFileMapping(hSysDataFile, NULL, PAGE_READONLY,
                              0, 0, NULL);

    if (hMap == NULL)
    {
        goto exitGetOEMID;
    }
    pFileMap = MapViewOfFile(hMap, FILE_MAP_READ,
                             0, 0, 0);
    if (!pFileMap)
    {
        goto exitGetOEMID;
    }

    OEMId = ScanForId(pFileMap, SizeLow + ((ULONG64)SizeHigh << 32));

exitGetOEMID:
    if (pFileMap)
    {
        UnmapViewOfFile(pFileMap);
    }
    if (hMap)
    {
        CloseHandle(hMap);
    }
    if (hSysDataFile)
    {
        CloseHandle(hSysDataFile);
    }
    return OEMId;
}


CVar::CVar()
{
    g_OleAut32Calls.VariantInit(this);
}

CVar::CVar(VARTYPE vt, SCODE scode)
{
    g_OleAut32Calls.VariantInit(this);
    this->vt = vt;
    this->scode = scode;
}
CVar::CVar(VARIANT var)
{
    *this = var;
}

CVar::~CVar()
{
    g_OleAut32Calls.VariantClear(this);
}

// ASSIGNMENT OPS.
CVar &
CVar::operator=(PCWSTR pcwstr)
{
    g_OleAut32Calls.VariantClear(this);
    if (NULL == (this->bstrVal = g_OleAut32Calls.SysAllocStringLen(pcwstr, wcslen(pcwstr))))
        throw E_OUTOFMEMORY;
    this->vt = VT_BSTR;
    return *this;
}

CVar &
CVar::operator=(VARIANT var)
{
    HRESULT hr;

    g_OleAut32Calls.VariantClear(this);
    if (FAILED(hr = g_OleAut32Calls.VariantCopy(this, &var)))
        throw hr;
    return *this;
}

// CAST OPS.
// doesn't change type. only returns BSTR if variant is of type
// bstr. asserts otherwise.
CVar::operator BSTR() const
{
    if(VT_BSTR == this->vt)
        return this->bstrVal;
    else
        return NULL;
}

HRESULT
CVar::Clear()
{
    return g_OleAut32Calls.VariantClear(this);
}


BOOL
CCrashInstance::InitData(
    PCRASH_INSTANCE Crash
    )
{
    SYSTEMTIME Systime;

    if (!Crash || !Crash->Build || !Crash->Bucket || !Crash->Path)
    {
        return FALSE;
    }

    if (strlen(Crash->Path) < sizeof(m_sz_Path))
    {
        CopyString(m_sz_Path, Crash->Path, sizeof(m_sz_Path));
    }
    else
    {
        return FALSE;
    }

    m_iBuild = Crash->Build;

    m_iCpuId = Crash->uCpu;

    BuildCrashId(Crash->UpTime, Crash->CrashTime, &m_CrashId);

//    GetSystemTime(&Systime);
//    m_Date = Systime.wYear

    m_lSourceStatus = 0;
    m_lBuildSatus = 0;
    m_lPathStatus = 0;
    m_lCrashIdStatus = 0;
    return TRUE;
}

void
CCrashInstance::OutPut()
{
    dprintf("%I64lx, %s\n",
            m_CrashId,
            m_sz_Path);
    dprintf("Build %ld, CPU Id %I64lx\n",
            m_iBuild,
            m_iCpuId);
}



BOOL
CBucketMap::InitData(
    ULONG64 CrashId,
    PCHAR Bucket
    )
{
    m_CrashId = CrashId;

    if (!Bucket)
    {
        return FALSE;
    }

    if (strlen(Bucket) < sizeof(m_sz_BucketId))
    {
        CopyString(m_sz_BucketId, Bucket, sizeof(m_sz_BucketId));
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
COverClocked::InitData(
    ULONG64 CrashId
    )
{
    m_CrashId = CrashId;

    m_lCrashIdStatus = 0;
    return TRUE;
}

BOOL
CMachineInfo::InitData(
    ULONG64 CpuId,
    PSTR Desc
    )
{
    if (Desc && strlen(Desc) < sizeof(m_sz_Desc))
    {
        CopyString(m_sz_Desc, Desc, sizeof(m_sz_Desc));
    }
    else
    {
        m_sz_Desc[0] = 0;
    }

    m_iCpuId = CpuId;

    return TRUE;
}


void
CBucketSolution::Output()
{
    dprintf("Solution for bucket %s:\n%s\nFixed in %s\n",
            m_sz_BucketId,
            m_sz_SolText,
            m_sz_OSVersion);
    return;
}

HRESULT
ArchiveCrash(
    PSTR OriginalPath,
    PSTR ShareName,
    PSTR DestFileName OPTIONAL,
    PSTR ArchivedPath,
    ULONG SizeofArchivedPath
    )
//
// Copy over crashfile to the share
//
{
    CHAR CopyTo[MAX_PATH], Date[20];
    PCHAR FileName;
    SYSTEMTIME Time;

    if (!OriginalPath || !ShareName)
    {
        dprintf("Invalid original dumppath or archive share\n");
        return E_FAIL;
    }
    GetLocalTime(&Time);
    StringCbPrintf(Date, sizeof(Date), "%02ld-%02ld-%04ld",
                   Time.wMonth,
                   Time.wDay,
                   Time.wYear);

    StringCbCopy(CopyTo, sizeof(CopyTo), ShareName);
    StringCbCat(CopyTo, sizeof(CopyTo), "\\");
    StringCbCat(CopyTo, sizeof(CopyTo), Date);
    StringCbCat(CopyTo, sizeof(CopyTo), "\\");

    if (!g_ShlWapiCalls.PathIsDirectoryA(CopyTo))
    {
        CreateDirectory(CopyTo, NULL);
    }
    if (DestFileName != NULL && DestFileName[0] != '\0')
    {
        FileName = DestFileName;
    } else
    {
        FileName = strrchr(OriginalPath, '\\');
        if (!FileName)
        {
            dprintf("Bad filename in '%s'\n", OriginalPath);
            return E_FAIL;
        }
    }
    if (*FileName == '\\')
    {
        FileName++;
    }
    StringCbCat(CopyTo, sizeof(CopyTo), FileName);

    if (!CopyFile(OriginalPath, CopyTo, TRUE))
    {
        dprintf("Cannot Copy %s to %s\n", OriginalPath, CopyTo);
        return E_FAIL;
    }
    StringCchCopy(ArchivedPath, SizeofArchivedPath, CopyTo);
    return S_OK;
}


HRESULT
MQNotifyCrashProcessed(
    PCRASH_INSTANCE Crash
    )
{
    WCHAR wszGuid[50], wszMQConnectStr[100], wszMQMessage[2*MAX_PATH];
    typedef HRESULT (WINAPI* MQSENDMSGPROC)(LPWSTR, LPWSTR, LPWSTR);
    MQSENDMSGPROC SendMQMessageText;
    ULONG64 hMQExt = 0;
    HRESULT Hr;
    PSTR BaseUrl;
    HINSTANCE hMod;


    if (!(BaseUrl = g_pTriager->GetFollowupStr("debugger-params",
                                               "solutionurl")))
    {
        BaseUrl = g_lpszBaseUrl;
    }

    if (!Crash->MqConnectStr || !Crash->MesgGuid)
    {
        return E_INVALIDARG;
    }

    if ((StringCbPrintfW(wszGuid, sizeof(wszGuid), L"%S", Crash->MesgGuid) != S_OK) ||
        (StringCbPrintfW(wszMQConnectStr, sizeof(wszMQConnectStr), L"%S", Crash->MqConnectStr) != S_OK))
    {
        return E_FAIL;
    }
    if (Crash->SourceId == CiSrcCER ||
        Crash->SourceId == CiSrcStress)
    {
        Hr = StringCbPrintfW(wszMQMessage, sizeof(wszMQMessage),
                             L"%Ssid=%ld&State=%ld&szSBucket=%S&iSBucket=%ld&szGBucket=%S&iGBucket=%ld&gsid=%ld",
                             BaseUrl,
                             (Crash->SolutionId ? Crash->SolutionId : -1),
                             Crash->SolutionType != CiSolFixed && Crash->SolutionType != CiSolWorkaround,
                             Crash->Bucket,
                             Crash->iBucket,
                             Crash->DefaultBucket,
                             Crash->iDefaultBucket,
                             (Crash->GenericSolId ? Crash->GenericSolId : -1)
                             );
    } else
    {
        ULONG State, Solution;

        //
        // Set the tracking state for caller
        //
        if (Crash->SolutionType == CiSolFixed ||
            Crash->SolutionType == CiSolWorkaround)
        {
            State = 0;
        } else
        {
            State = 1;
        }
        Solution = Crash->SolutionId && (Crash->SolutionId != -1) ? Crash->SolutionId : Crash->GenericSolId;

        if (Solution)
        {
            Hr = StringCbPrintfW(wszMQMessage, sizeof(wszMQMessage),
                                 L"%Ssid=%ld&State=%ld",
                                 BaseUrl,
                                 Solution,
                                 State);
        }
        else
        {
            Hr = StringCbPrintfW(wszMQMessage, sizeof(wszMQMessage),
                             L"NO_SOLUTION");
        }
    }

    hMod = LoadLibrary("winxp\\mqext.dll");

    if (hMod == NULL)
    {
        hMod = LoadLibrary("oca\\mqext.dll");

        if (hMod == NULL)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    SendMQMessageText  = (MQSENDMSGPROC) GetProcAddress(hMod, "_EFN_SendMQMessageText");
    if (SendMQMessageText != NULL)
    {
        Hr = SendMQMessageText(wszMQConnectStr, wszGuid, wszMQMessage);
    } else
    {
        Hr =  HRESULT_FROM_WIN32(GetLastError());
    }
    FreeLibrary(hMod);
    return E_FAIL;
}


ULONG
GetAdoCommandTimeOut()
{
#define DEFAULT_TIMEOUT 200

    PSTR String;
    ULONG TimeOut;

    TimeOut = 0;
    String = g_pTriager->GetFollowupStr("debugger-params", "DbCommandTimeout");

    if (String)
    {
        TimeOut = atoi(String);
    }

    if (!TimeOut)
    {
        TimeOut = DEFAULT_TIMEOUT;
    }
    return TimeOut;
}


ULONG
GetAdoConnectionTimeOut()
{
#define DEFAULT_CONNECTION_TIMEOUT 5

    PSTR String;
    ULONG TimeOut;

    TimeOut = 0;

    String = g_pTriager->GetFollowupStr("debugger-params", "DbConnectionTimeout");

    if (String)
    {
        TimeOut = atoi(String);
    }
    if (!TimeOut)
    {
        TimeOut = DEFAULT_CONNECTION_TIMEOUT;
    }
    return TimeOut;
}

HRESULT
InitializeDatabaseHandlers(
    PDEBUG_CONTROL3 DebugControl,
    ULONG Flags
    )
{
    HRESULT Hr;
    ULONG EngineOptions;

    if (!ExtensionApis.lpOutputRoutine)
    {
        ExtensionApis.nSize = sizeof (ExtensionApis);
        if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
            return Hr;
        }
    }

    if ((Hr = ExtDllInitDynamicCalls(DebugControl)) != S_OK)
    {
        return Hr;
    }

    if (!g_pTriager)
    {
        g_pTriager = new CTriager();
    }

    if (!g_CrDb || !g_CustDb || !g_SolDb)
    {
        if (!g_ComInitialized)
        {
            if (FAILED(Hr = g_Ole32Calls.CoInitializeEx(NULL, COM_THREAD_MODEL)))
            {
                dprintf("CoInitialize failed %lx\n", Hr);
                return Hr;
            }
            g_ComInitialized = TRUE;
        }
        if (!g_CrDb && (Flags & 1))
        {
            g_CrDb = new CrashDatabaseHandler();
            if (!g_CrDb)
            {
                return E_OUTOFMEMORY;
            }
        }

        if (!g_CustDb && (Flags & 2))
        {
            g_CustDb = new CustDatabaseHandler();
            if (!g_CustDb)
            {
                return E_OUTOFMEMORY;
            }
        }

        if (!g_SolDb && (Flags & 4))
        {
            g_SolDb = new SolutionDatabaseHandler();
            if (!g_SolDb)
            {
                return E_OUTOFMEMORY;
            }
        }
    }

    if (g_CrDb && !g_CrDb->IsConnected() && (Flags & 1))
    {
        if (!g_CrDb->ConnectToDataBase())
        {
            return E_FAIL;
        }

    }
    if (g_CustDb && !g_CustDb->IsConnected() && (Flags & 2))
    {
        if (!g_CustDb->ConnectToDataBase())
        {
            return E_FAIL;
        }
    }
    if (g_SolDb && !g_SolDb->IsConnected() && (Flags & 4))
    {
        if (!g_SolDb->ConnectToDataBase())
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT
UnInitializeDatabaseHandlers(
    BOOL bUninitCom
    )
{
    if (g_CrDb)
    {
        delete g_CrDb;
    }
    if (g_CustDb)
    {
        delete g_CustDb;
    }
    if (g_SolDb)
    {
        delete g_SolDb;
    }
    g_CrDb = NULL;
    g_CustDb = NULL;
    g_SolDb = NULL;
    if (g_ComInitialized && bUninitCom)
    {
        g_Ole32Calls.CoUninitialize();
        g_ComInitialized = FALSE;
    }
    return S_OK;
}

HRESULT
ReportSolution(
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr = S_OK;

    if (!Crash->SolutionId ||
        (Crash->SourceId == CiSrcCER && !Crash->GenericSolId))
    {
        // Get the solution, we need generic bucket solution for CER even if sBugcket is solved
        Hr = g_SolDb->CheckSolutionExists(Crash->Bucket, Crash->DefaultBucket,
                                          &Crash->SolutionId, (PULONG) &Crash->SolutionType,
                                          (PULONG) &Crash->GenericSolId,
                                          (Crash->SourceId == CiSrcCER) ? 1 : 0);
        if (FAILED(Hr) || !Crash->SolutionId)
        {
            Crash->SolutionId = -1;
            Crash->SolutionType = CiSolUnsolved;
        }

    }

    if (Crash->SolutionId != -1)
    {
        OcaKdLog(Crash->MesgGuid, "SOLVED", Crash->Bucket, Crash->SolutionId);
    } else
    {
        OcaKdLog(Crash->MesgGuid, "UNSOLVED", Crash->Bucket, Hr);
    }

    if (Crash->SourceId == CiSrcCER)
    {
        // get bucket ids
    }

    //
    // Check if we have info to connect to solution queue and a solution exists
    //
//    if (Crash->SolutionId)
    {
        if (Crash->MesgGuid && Crash->MqConnectStr &&
            Crash->MesgGuid[0] && Crash->MqConnectStr[0])

        {
            // Notify the sender that crash has been processed
            MQNotifyCrashProcessed(Crash);
        }
    }
    return S_OK;
}

HRESULT
_EFN_DbAddCrashDirect(
    PCRASH_INSTANCE Crash,
    PDEBUG_CONTROL3 DebugControl
    )
{

    ULONG LevelCompleted;
    HRESULT Hr=S_OK;
    ULONG SleepFor;

    LevelCompleted = 0;
    SleepFor = 0;
ReTry:

    if (SleepFor > 5)
    {
        dprintf("Could not succeed after %ld tries, quitting.\n", SleepFor);
        DbAddCrashReportToMonitor(Hr, LevelCompleted, Crash);
        return Hr;
    }
    else if (SleepFor)
    {
        dprintf("Level Finished %lx, sleep for %ld sec before retry.\n", LevelCompleted, SleepFor);
        Sleep(SleepFor*1000);

    }

    if (!(LevelCompleted & LvlDatabaseInitDone))
    {
        ULONG Flags = 1;

        if (!Crash->bResetBucket)
        {
            if (!Crash->SolutionId ||
                (Crash->SourceId == CiSrcCER  &&
                 Crash->GenericSolId == 0))
            {
                Flags |= 4;
            }
        }
        if (Crash->bUpdateCustomer)
        {
            Flags |= 2;
        }
        if ((Hr = InitializeDatabaseHandlers(DebugControl, Flags)) != S_OK)
        {

            dprintf("Initializtion error.\n");
            ++SleepFor;
            goto ReTry;
        }
        LevelCompleted |= LvlDatabaseInitDone;
    }

    while (!(LevelCompleted & LvlMessageQReply) ||
           !(LevelCompleted & LvlCrashAddedToDB))
    {
        if (!(LevelCompleted & LvlMessageQReply) &&
            ((Crash->SourceId != CiSrcCER) || (LevelCompleted & LvlCrashAddedToDB)))
            // For CER we need ibuckets to report solution
        {
            if (!Crash->bResetBucket)
            {
                ReportSolution(Crash); // Ignore return value, we fail quietly if there is
                                       // any problem in reporting solution to Q
            }
            LevelCompleted |= LvlMessageQReply;
        }

        if (!(LevelCompleted & LvlCrashAddedToDB))
        {
            Hr = g_CrDb->AddCrashInstance(Crash);

            if (FAILED(Hr))
            {
                ++SleepFor;
                goto ReTry;
            }
            LevelCompleted |= LvlCrashAddedToDB;
        }

        if (Crash->SourceId == CiSrcCER && Crash->iBucket == 0)
        {
            g_CrDb->LookupCrashBucket(Crash->Bucket, &Crash->iBucket,
                                      Crash->DefaultBucket, &Crash->iDefaultBucket);
        }

    }

    //
    // Only update the customer DB for kernel mode failures as the user
    // mode failures don't go in that DB.
    //

    if (!(LevelCompleted & LvlCustomerDbUpdate))
    {
        if (Crash->bUpdateCustomer &&
            (Crash->FailureType == DEBUG_FLR_KERNEL))
        {
            if (Crash->iBucket && Crash->iDefaultBucket)
            {
                Hr = g_CustDb->AddCrashToDB(Crash);
                if (FAILED(Hr))
                {
                    ++SleepFor;
                    goto ReTry;
                }
            }
            else
            {
                dprintf("Cannot retrieve bucket Ids\n");
                Hr = E_FAIL;
            }
        }
        LevelCompleted |= LvlCustomerDbUpdate;
    }

    DbAddCrashReportToMonitor(Hr, LevelCompleted, Crash);
    return Hr;
}

//
// DatabaseHandler Methods
//


DatabaseHandler::DatabaseHandler()
{
    m_piConnection = NULL;
    m_piCrRecordSet = NULL;
    m_fConnected = FALSE;
    m_fRecordsetEmpty = TRUE;
    m_pADOResult = NULL;
    m_fPrintIt = FALSE;
    m_piCrCommandObj = NULL;
}

DatabaseHandler::~DatabaseHandler()
{

    if (m_piCrRecordSet != NULL)
    {
        m_piCrRecordSet->Release();
    }
    if (m_piCrCommandObj != NULL)
    {
        m_piCrCommandObj->Release();
    }
    if (m_piConnection != NULL)
    {
        if (m_fConnected)
        {
            m_piConnection->Close();
            m_fConnected = FALSE;
        }
        m_piConnection->Release();
    }

    m_piCrRecordSet = NULL;
    m_piConnection = NULL;
}

BOOL
DatabaseHandler::ConnectToDataBase(
    LPSTR szDB
    )
{
    HRESULT Hr = S_OK;
    WCHAR szConnectStr[200];

    PSTR String;

    String = g_pTriager->GetFollowupStr("debugger-params", szDB);

    if (!String)
    {
        return FALSE;
    }

//  bstrConnect = (PCRDB_ADOBSTR) &szConnectStr[0];
//  bstrConnect->dwLength = sizeof(szConnectStr)/sizeof(WCHAR) - sizeof(DWORD);
    ansi2wchr(String, szConnectStr);
    CVar    vNull(VT_ERROR, DISP_E_PARAMNOTFOUND);
    CVar    bstrConnect(VT_ERROR, DISP_E_PARAMNOTFOUND);

    __try
    {
        if ((Hr = g_Ole32Calls.CoCreateInstance(CLSID_CADOConnection,
                                                NULL,
                                                CLSCTX_INPROC_SERVER,
                                                IID_IADOConnection,
                                                (LPVOID *)&m_piConnection)) != S_OK)
        {
            dprintf("CoCreate failed for connection %lx\n", Hr);
            return FALSE;
        }

        m_piConnection->put_ConnectionTimeout(GetAdoConnectionTimeOut());

        bstrConnect = szConnectStr;

        if (bstrConnect == NULL)
        {
            return FALSE;
        }
        if ((Hr = m_piConnection->put_ConnectionString((BSTR)bstrConnect)) != S_OK)
        {
            dprintf("put_ConnectionString ( %ws ) failed %lx\n", szConnectStr, Hr);
            return FALSE;
        }

        if ((Hr = m_piConnection->Open(NULL,
                                       NULL, NULL,
                                       adConnectUnspecified)) != S_OK)
        {
            dprintf("Debugger %s Connection::Open failed %lx\n\n", m_szDbName, Hr);
            return FALSE;
        }
        m_fConnected = TRUE;

        // Set command timeout to 60, crashdatabase is huge and commands
        // takte long time
        m_piConnection->put_CommandTimeout(GetAdoCommandTimeOut());

        if ((Hr = g_Ole32Calls.CoCreateInstance(CLSID_CADORecordset,
                                                NULL,
                                                CLSCTX_INPROC_SERVER,
                                                IID_IADORecordset,
                                                (LPVOID *)&m_piCrRecordSet)) != S_OK )
        {
            dprintf("CoCreate failed for recordset %lx\n", Hr);
            return FALSE;
        }

        if ((Hr = m_piCrRecordSet->putref_ActiveConnection(m_piConnection)) != S_OK)
        {
            dprintf("putref_ActiveConn failed %lx\n", Hr);
            return FALSE;
        }

        if ((Hr = g_Ole32Calls.CoCreateInstance(CLSID_CADOCommand,
                                                NULL,
                                                CLSCTX_INPROC_SERVER,
                                                IID_IADOCommand15,
                                                (LPVOID *)&m_piCrCommandObj)) != S_OK )
        {
            dprintf("CoCreate failed for Command %lx\n", Hr);
            return FALSE;
        }

        if ((Hr = m_piCrCommandObj->putref_ActiveConnection(m_piConnection)) != S_OK)
        {
            dprintf("putref_ActiveConn failed %lx\n", Hr);
            return FALSE;
        }

    }
    __except (Hr)
    {
        dprintf("Unhandled exception %lx\n", Hr);
        return (FALSE);
    }
    return TRUE;
}


HRESULT
DatabaseHandler::GetRecords(
    PULONG Count,
    BOOL bEnumerateAll
    )
{
    HRESULT hr;
    CVar    vSource(VT_ERROR, DISP_E_PARAMNOTFOUND);
    CVar    vNull(VT_ERROR, DISP_E_PARAMNOTFOUND);
    LONG State;
//    dprintf("Executing %ws\n", m_wszQueryCommand);

    if (!m_fConnected || !m_wszQueryCommand[0])
    {
        dprintf("Not connected\n");
        return E_FAIL;
    }
    __try
    {
        vSource = m_wszQueryCommand;
        if (m_piCrRecordSet == NULL)
        {
            if ((hr = g_Ole32Calls.CoCreateInstance(CLSID_CADORecordset,
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IADORecordset,
                                                    (LPVOID *)&m_piCrRecordSet)) != S_OK )
            {
                dprintf("CoCreate failed for recordset %lx\n", hr);
                return hr;
            }

            if ((hr = m_piCrRecordSet->putref_ActiveConnection(m_piConnection)) != S_OK)
            {
                dprintf("putref_ActiveConn failed %lx\n", hr);
                goto Cleanup;
            }
        }

        if ((hr = m_piCrRecordSet->Open(vSource, vNull, adOpenKeyset, adLockReadOnly, adCmdText)) != S_OK)
        {
            if (m_fPrintIt)
            {
                dprintf("RecordSet::Open Failed %lx, \n %ws \n", hr, m_wszQueryCommand);
            }
            goto Cleanup;
        }

        if (Count)
        {
            ADO_LONGPTR MaxRec;

            if ((hr = m_piCrRecordSet->get_RecordCount(&MaxRec)) != S_OK)
            {
                *Count = 0;
                hr = S_FALSE;
            }
            *Count = (ULONG) MaxRec;
        }

        if (bEnumerateAll)
        {
            if ((hr = EnumerateAllRows()) != S_OK)
            {
                // dprintf("Cannot enumerate rows %lx\n", hr);
            }

        }

    }
    __except (hr)
    {
        dprintf("Unhandled Exception in GetRecordForFollowup %lx\n", hr);
        return hr;
    }

Cleanup:
    State = -1;

    m_piCrRecordSet->get_State(&State);
    if (State & 1)
    {
        m_piCrRecordSet->Close();
    }

    m_piCrRecordSet->Release();
    m_piCrRecordSet = NULL;
    return hr;
}

HRESULT
DatabaseHandler::EnumerateAllRows(
    void
    )
{
    VARIANT avarRecords;
    HRESULT Hr;
    ADO_LONGPTR MaxRec;
    ULONG Count=0;
    CHAR Text[100];
    CVar    vNull(VT_ERROR, DISP_E_PARAMNOTFOUND);
    IADORecordBinding   *picRs = NULL;
    COutputQueryRecords  *QueryResult;
    CCrashInstance CrashInstance;

    if (m_pADOResult)
    {
        QueryResult = m_pADOResult;
    } else
    {
        QueryResult = &CrashInstance;
    }
    __try
    {
        ULONG lUbound;
        LONG State = -1;

        if ((Hr = m_piCrRecordSet->get_RecordCount(&MaxRec)) != S_OK)
        {
            Hr = S_FALSE;
        }

        Count = (ULONG) MaxRec;
        if (m_fPrintIt)
        {
//            dprintf("Enumerating %lx rows\n", MaxRec);
        }

        picRs = NULL;
        m_piCrRecordSet->get_State(&State);
        if ((Hr = m_piCrRecordSet->QueryInterface(__uuidof(IADORecordBinding),(LPVOID*)&picRs)) != S_OK)
        {
            dprintf("RecordSet::QueryInterface (IADORecordBinding) Failed %lx, State %lx\n", Hr, State);
            return Hr;
        }


        //Bind the Recordset
        if ((Hr = picRs->BindToRecordset(QueryResult)) != S_OK)
        {
            dprintf("RecordSet::BindToRecordset (IADORecordBinding) Failed %lx, State %lx\n", Hr, State);
            picRs->Release();
            return Hr;
        }

        while (1)
        {
            VARIANT_BOOL IsEof;

            if (m_piCrRecordSet->get_EOF(&IsEof) == S_OK)
            {
                if (IsEof)
                {
                    // preserve last valut for the caller
                    m_piCrRecordSet->MovePrevious();
                    break;
                }
            }

            if (m_pADOResult && m_fPrintIt)
            {
                m_pADOResult->Output();
            } else
            {
                //                CrashInstance.OutPut();
            }

            --Count;
            if (m_piCrRecordSet->MoveNext() != S_OK)
            {
                break;
            }
        }

        if (picRs)
        {
            picRs->Release();
        }

    }
    __except (Hr)
    {
        dprintf("Unhandled Exception in EnumerateAllRows %lx\n", Hr);
        return Hr;
    }

    return S_OK;
}


//
// CrashDatabaseHandler Methods
//

CrashDatabaseHandler::CrashDatabaseHandler()
{
    m_szDbName = "CrashDb";
}

CrashDatabaseHandler::~CrashDatabaseHandler()
{
}

HRESULT
CrashDatabaseHandler::BuildQueryForCrashInstance(
    PCRASH_INSTANCE Crash
    )
{
    ULONG64 CrashId;

    BuildCrashId(Crash->UpTime, Crash->CrashTime, &CrashId);
    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                     L"SELECT * FROM %ws WHERE CrashId = %I64ld",
                    g_lpwszCrashInstanceTable,
                    CrashId
                    );

    return S_OK;
}

BOOL
CrashDatabaseHandler::CheckCrashExists(
    PCRASH_INSTANCE Crash
    )
{
    ULONG nRecords = 0;
    CCheckCrashExists Exists;

    Exists.m_CrashIdExists = 0;
    m_pADOResult = &Exists;
    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_CheckCrashExists '%S'",
                    Crash->MesgGuid);

    HRESULT Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr) || !Exists.m_CrashIdExists)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
CrashDatabaseHandler::CheckSRExists(
    PSTR szSR,
    PCRASH_INSTANCE Crash
    )
{
    ULONG nRecords = 0;
    CIntValue Exists;

    Exists.m_dw_Value1 = 0;
    m_pADOResult = &Exists;
    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_CheckSRExists '%S'",
                    szSR);

    HRESULT Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr) || !Exists.m_dw_Value1)
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT
CrashDatabaseHandler::LinkCrashToSR(
    PSTR szSR,
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr;
    ULONG nRecords = 0;
    CIntValue lnk;

    lnk.m_dw_Value1 = 0;
    m_pADOResult = &lnk;
    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_LinkCrashSR '%S', '%S'",
                    szSR,
                    Crash->MesgGuid);

    Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (!lnk.m_dw_Value1)
    {

        return E_FAIL;
    }

    return Hr;
}

HRESULT
CrashDatabaseHandler::FindSRBuckets(
    PSTR szSR,
    PSTR szSBucket,
    ULONG sBucketSize,
    PSTR szGBucket,
    ULONG gBucketSize
    )
{
    HRESULT Hr;
    ULONG nRecords = 0;
    CRetriveBucket Buckets;

    Buckets.m_sz_gBucketId[0] = Buckets.m_sz_sBucketId[0] = 0;

    m_pADOResult = &Buckets;

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_RetriveSRBuckets '%S'",
                    szSR);
    Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr) || !Buckets.m_sz_gBucketId[0])
    {
        return Hr;
    }

    StringCchCopy(szSBucket, sBucketSize, Buckets.m_sz_sBucketId);
    StringCchCopy(szGBucket, gBucketSize, Buckets.m_sz_gBucketId);
    return Hr;
}

HRESULT
CrashDatabaseHandler::GetBucketComments(
    PSTR szBuckt,
    PSTR szComments,
    ULONG SizeofComment,
    PULONG pBugId
    )
{
    HRESULT Hr;

    ULONG nRecords = 0;
    CBugAndComment Comments;

    Comments.m_dw_BugId = 0;
    Comments.m_sz_CommentBy[0] = Comments.m_sz_Comments[0] = 0;

    m_pADOResult = &Comments;

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_GetBucketComments '%S'",
                    szBuckt);
    Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr))
    {
        return Hr;
    }
    if (Comments.m_dw_BugId == 0 &&
        Comments.m_sz_Comments[0] == 0)
    {
        return E_FAIL;
    }

    StringCchCopy(szComments, SizeofComment, Comments.m_sz_Comments);
    *pBugId = Comments.m_dw_BugId;
    return Hr;

}

HRESULT
CrashDatabaseHandler::AddCrashInstance(
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr = S_OK;
    PSTR OriginalPath = Crash->Path;

    if (!Crash->bResetBucket &&
        (Crash->SolutionId != 0) &&
        (Crash->iBucket != -1) &&
        (Crash->SolutionType == CiSolFixed))
    {
        //
        // No need to add this to CrashDB, just update the count
        //
        Crash->bExpendableDump = TRUE;
        Hr = UpdateBucketCount(Crash);
    } else
    {
        PSTR ArchiveShare, ArchParam;
        ULONG index;
        CHAR ArchivePath[MAX_PATH];

        ArchParam = ArchivePath;
        StringCchPrintf(ArchParam, MAX_PATH, "archshare-k-%s",
                        (Crash->DumpClass == DEBUG_DUMP_SMALL) ? "mini" : "full");

        ArchiveShare = g_pTriager->GetFollowupStr("debugger-params", ArchParam);

        ArchivePath[0] = 0;
        if ((Crash->bExpendableDump) || Crash->bResetBucket ||
            ((Hr = ArchiveCrash(Crash->Path, ArchiveShare, Crash->ArchiveFileName,
                                ArchivePath, sizeof(ArchivePath))) == S_OK))
        {
            if (!Crash->bExpendableDump && !Crash->bResetBucket)
            {
                Crash->Path = ArchivePath;
                Crash->OEMId = GetOEMId(OriginalPath);
            }
            Crash->bExpendableDump = TRUE;
            Hr = AddCrashToDBByStoreProc(Crash);
            Crash->Path = OriginalPath;

            if (SUCCEEDED(Hr) && Crash->PssSr && Crash->PssSr[0])
            {
                Hr = LinkCrashToSR(Crash->PssSr, Crash);
                OcaKdLog(Crash->MesgGuid, "CRASH SR", Crash->PssSr, Hr);
            }
        } else
        {
            dprintf("ArchiveCrash failed with %lx\n", Hr);
        }

        OcaKdLog(Crash->MesgGuid, "ARCHIVED CRASH", ArchivePath, Hr);
    }
    if (OriginalPath && SUCCEEDED(Hr) &&
        (Crash->SourceId != CiSrcErClient) &&
        (Crash->SourceId != CiSrcUser) &&
        !Crash->bResetBucket)
    {
        DeleteFile(OriginalPath);
    }
    return Hr;
}

HRESULT
CrashDatabaseHandler::AddCrashToDBByStoreProc(
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr;
    CVar    vNull(VT_ERROR, DISP_E_PARAMNOTFOUND);
    CIntValue IntValue;
    ULONG sBucket, gBucket;

    Hr = S_OK;

    if (Crash->SourceId == CiSrcManualFullDump)
    {
        // we already have a FailureType field to show full dumps
        Crash->SourceId = CiSrcManual;
    }
    Crash->ServicePack %= 10000;

    dprintf("ADDING CRASH:\n");

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"EXEC sp_AddCrashInstance2 "
                    L" @ip_retriageBucket = %ld, "
                    L" @ip_Bucketid = '%S', "
                    L" @ip_Path = '%S', "
                    L" @ip_FollowUp = '%S', "
                    L" @ip_BuildNo = %ld, "
                    L" @ip_Source = %ld, "
                    L" @ip_CpuId = %I64ld, "
                    L" @ip_OverClocked = %ld, "
                    L" @ip_Guid = '%S', "
                    L" @ip_gBucketId = '%S', "
                    L" @ip_DriverName = '%S', "
                    L" @ip_Type = %ld, "
                    L" @ip_UpTime = %ld, "
                    L" @ip_SKU = %ld,"
                    L" @ip_LangId = 0,"
                    L" @ip_OemId = %ld\n",
                    Crash->bResetBucket,
                    Crash->Bucket,
                    Crash->Path,
                    Crash->Followup,
                    Crash->Build * 10000 + Crash->ServicePack,
                    Crash->SourceId,
                    Crash->uCpu,
                    Crash->OverClocked,
                    Crash->MesgGuid,
                    Crash->DefaultBucket,
                    Crash->FaultyDriver,
                    Crash->FailureType | ((Crash->DumpClass == DEBUG_DUMP_SMALL) ? 0 : 4),
                    Crash->UpTime,
                    Crash->Sku,
                    Crash->OEMId
                    );

    m_pADOResult = &IntValue;
    __try
    {
        // Build query for store proc
        //      LATER: modify this to use adStoreProc Interface instead of query
        ULONG nRecords;

        IntValue.m_dw_Value1 = 0;

        m_fPrintIt = TRUE;

        if (!strcmp(Crash->Bucket, "BAD_DUMPFILE"))
        {
            sBucket = gBucket = -1;
        }
        else
        {
            sBucket = gBucket = 0;

            // This proc returns sBucket and gBucket on success
            // CALL FindBucketId directly to get those

            dprintf("%ws", m_wszQueryCommand);
            Hr = FindBucketId(&sBucket, &gBucket);

            dprintf("%d %d \n", sBucket, gBucket);

            m_fPrintIt = FALSE;
            if (FAILED(Hr))
            {
                dprintf("GerRecord Failed %lx for store proc AddCrashToDBByStoreProc \n", Hr);
                dprintf("Query:\n%ws\n", m_wszQueryCommand);
                return Hr;
            }

            if (!CheckCrashExists(Crash))
            {
                dprintf("Crash could not be added to crash database: %s\n", Crash->MesgGuid);
                Hr = E_FAIL;
            }
            else
            {
                dprintf("Crash instance %s now exists in DB\n", Crash->MesgGuid);
            }

            // Get Integer mappings for buckets
            if (!sBucket || !gBucket)
            {
                StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                                L"sp_GetIntBucket '%S', '%S'",
                                Crash->Bucket, Crash->DefaultBucket);

                //
                // Now Try finding with explicit query
                //
                FindBucketId(&sBucket, &gBucket);

                if (!sBucket || !gBucket)
                {
                    dprintf("Unable to retrive int bucketids from crashdb\n");
                    Hr = E_FAIL;
                }
            }
        }

        Crash->iBucket = sBucket;
        Crash->iDefaultBucket = gBucket;
    }
    __except (Hr)
    {
        dprintf("Unhandled Exception in AddCrashToDB %lx\n", Hr);
        return Hr;
    }
    return Hr;
}


HRESULT
CrashDatabaseHandler::UpdateBucketCount(
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr;
    ULONG sBucket, Count;
    CIntValue RetVal;

    dprintf("Update Bucket Count:\n");

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"EXEC sp_UpdateCount '%S', %ld",
                    Crash->Bucket,
                    Crash->Build * 10000 + Crash->ServicePack
                    );

    __try
    {
        // Build query for store proc
        //      LATER: modify this to use adStoreProc Interface instead of query
        ULONG nRecords;

        // This proc returns sBucket and gBucket on success
        // CALL FindBucketId directly to get those

        dprintf("%ws", m_wszQueryCommand);
        m_pADOResult = &RetVal;
        Hr = GetRecords(&Count, FALSE);
        m_pADOResult = NULL;
        dprintf("sp_UpdateCount returned %d \n", RetVal.m_dw_Value1);
    }
    __except (Hr)
    {
        dprintf("Unhandled Exception in UpdateBucketCount %lx\n", Hr);
        return Hr;
    }
    return Hr;

}

HRESULT
CrashDatabaseHandler::FindRaidBug(
    PSTR Bucket,
    PULONG RaidBug
    )
{
    WCHAR wszBkt[100];
    CBucketRaid BktRaid;
    ULONG Count=0;
    HRESULT result;

    if (Bucket && strlen(Bucket) < sizeof(wszBkt)/sizeof(WCHAR))
    {
        ansi2wchr(Bucket, wszBkt);
    }

    StringCchPrintfW(m_wszQueryCommand,
                     sizeof(m_wszQueryCommand)/sizeof(WCHAR),
                     L"SELECT BucketId, BugId from %ws b, %ws r "
                     L" WHERE BucketId='%ws' AND b.iBucket = r.iBucket",
                     g_lpwszBucketTable,
                     g_lpwszRaidTable,
                     wszBkt);

    m_pADOResult = &BktRaid;

    result = GetRecords(&Count, TRUE);

    if (Count == 0)
    {
        result = S_FALSE;
    }

    if (result == S_OK)
    {
        *RaidBug = BktRaid.m_dw_Raid;
    }

    m_pADOResult = NULL;
    return result;
}

HRESULT
CrashDatabaseHandler::FindBucketId(
    PULONG isBucket,
    PULONG igBucket
    )
{
    CGetIntBucket BktIds;
    CBuckets Bkt;
    ULONG Count=0;
    HRESULT result;


    BktIds.m_iBucket1 = BktIds.m_iBucket2 = 0;

    m_pADOResult = &BktIds;

    result = GetRecords(&Count, TRUE);

    if (result == S_OK)
    {
        //
        // BUGBUG - what is this supposed to check ?
        //
        if (Count == 0)
        {
            result = S_FALSE;
        }

        *isBucket = BktIds.m_iBucket1;
        *igBucket = BktIds.m_iBucket2;
    }
    //dprintf("%ws : %ld, %ld\n", m_wszQueryCommand, *isBucket, *igBucket);

    m_pADOResult = NULL;
    return result;
}

HRESULT
CrashDatabaseHandler::LookupCrashBucket(
    PSTR SBucket,
    PULONG iSBucket,
    PSTR GBucket,
    PULONG iGBucket
    )
{
    HRESULT Hr = S_OK;
    ULONG Dummy;

    if (!m_fConnected)
    {
        return E_FAIL;
    }

    Hr = StringCchPrintfW(m_wszQueryCommand,
                     sizeof(m_wszQueryCommand)/sizeof(WCHAR),
                     L"sp_GetIntBucket '%S', '%S'",
                     SBucket, GBucket ? GBucket : "");
    if (Hr == S_OK)
    {
        Hr = FindBucketId(iSBucket, iGBucket ? iGBucket : &Dummy);
    }
    return Hr;
}


//
// CustDatabaseHandler Methods
//

CustDatabaseHandler::CustDatabaseHandler()
{
    m_szDbName = "CustomerDb";
}

CustDatabaseHandler::~CustDatabaseHandler()
{
}

HRESULT
CustDatabaseHandler::AddCrashToDB(
    PCRASH_INSTANCE Crash
    )
{
    if (!m_fConnected)
    {
        return E_FAIL;
    }

    HRESULT Hr = S_OK;
    CVar    vNull(VT_ERROR, DISP_E_PARAMNOTFOUND);
    PCHAR CallSp;

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"SetDBGResults '%S', %ld, '%S', %ld, '%S', %ld, %ld, '%S'",
                    Crash->MesgGuid,
                    Crash->iDefaultBucket,
                    Crash->DefaultBucket,
                    Crash->iBucket,
                    Crash->Bucket,
                    Crash->StopCode,
                    Crash->bSendMail ? 1 : 0,
                    Crash->OriginalDumpFileName);

    ULONG nRecords;
    CIntValue ReturnVal;

    ReturnVal.m_dw_Value1 = 0;
    m_fPrintIt = TRUE;

    m_pADOResult = &ReturnVal;

    Hr = GetRecords(&nRecords, TRUE);

    m_fPrintIt = FALSE;
    dprintf("Query:\n%ws\n", m_wszQueryCommand);

    if ((Hr == S_OK) && (ReturnVal.m_dw_Value1 == 0))
    {
        Hr = E_FAIL;
    }

    m_pADOResult = NULL;
    if (FAILED(Hr))
    {
        dprintf("GerRecord Failed %lx for store proc SetDBGResults on AddToCustomerDb \n", Hr);
    } else
    {
        dprintf("Added to customer DB (%ld)\n", ReturnVal.m_dw_Value1);
    }
    return Hr;
}



//
// SolutionDatabaseHandler Methods
//

SolutionDatabaseHandler::SolutionDatabaseHandler()
{
    m_szDbName = "SolutionDb";
}

SolutionDatabaseHandler::~SolutionDatabaseHandler()
{
}

HRESULT
SolutionDatabaseHandler::GetSolution(
    PCRASH_INSTANCE Crash
    )
{
    HRESULT Hr = S_OK;

    if (!m_fConnected)
    {
        return E_FAIL;
    }

    return E_NOTIMPL;
}

HRESULT
SolutionDatabaseHandler::CheckSolutionExists(
    PSTR szSBucket,
    PSTR szGBucket,
    PULONG pSolnId,
    PULONG pSolutionType,
    PULONG pgSolutionId,
    BOOL bForcegSolLookup
    )
{
    HRESULT Hr = S_OK;
    ULONG nRecords = 0;
    CIntValue3 SolnId;

    if (!m_fConnected)
    {
        return E_FAIL;
    }
    SolnId.m_dw_Value1 = 0;
    m_pADOResult = &SolnId;

    StringCbPrintfW(
        m_wszQueryCommand, sizeof(m_wszQueryCommand),
        L"sp_CheckForSolution '%S', '<Driver>', 0, '%S', %ld",
        szSBucket,
        szGBucket ? szGBucket : "",
        bForcegSolLookup         // we need gbucket solution
        );
    // returns: SolutionId, SolutionType, gSolutionId

    Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr))
    {
        return Hr;
    }

    if (!SolnId.m_dw_Value1 && !SolnId.m_dw_Value3)
    {
        return E_FAIL;
    }

    *pSolnId = SolnId.m_dw_Value1;
    if (pSolutionType)
    {
        *pSolutionType = SolnId.m_dw_Value2;
    }
    if (pgSolutionId)
    {
        *pgSolutionId = SolnId.m_dw_Value3;
    }
    return S_OK;
}

HRESULT
SolutionDatabaseHandler::GetSolutionFromDB(
    PSTR szBucket,
    PSTR szGBucket,
    LPSTR DriverName,
    ULONG TimeStamp,
    ULONG OS,
    OUT PSTR pszSolution,
    ULONG SolutionBufferSize,
    OUT PULONG pSolutionId,
    OUT PULONG pSolutionType,
    OUT PULONG pGenericSolutionId
    )
{
    if (!m_fConnected)
    {
        return E_FAIL;
    }

    HRESULT Hr = S_OK;
    PSTR BaseUrl;
    ULONG SolnId = 0, GenSolId = 0;

    if (!(BaseUrl = g_pTriager->GetFollowupStr("debugger-params",
                                               "solutionurl")))
    {
        BaseUrl = g_lpszBaseUrl;
    }

    if ((Hr = CheckSolutionExists(szBucket, szGBucket, &SolnId,
                                  pSolutionType, &GenSolId,
                                  TRUE)) == S_OK)
    {
        *pSolutionId = SolnId;
        if (pGenericSolutionId)
        {
            *pGenericSolutionId = GenSolId;
        }

        if (!SolnId && !GenSolId)
        {
            Hr = S_FALSE;
        }
        else if (pszSolution && SolnId)
        {
            Hr = StringCbPrintfA(pszSolution, SolutionBufferSize,
                                 "%ssid=%ld&State=1",
                                 BaseUrl,
                                 SolnId);
        } else if (!SolnId)
        {
            Hr = S_FALSE;
        }
    }

    return Hr;
}

HRESULT
SolutionDatabaseHandler::GetSolutiontext(
    PSTR szBucket,
    PSTR szSolText,
    ULONG SolTextSize
    )
{
    HRESULT Hr;

    ULONG nRecords = 0;
    CSolutionDesc Solution;

    Solution.m_dw_SolType = 0;
    Solution.m_sz_Solution[0] = 0;

    m_pADOResult = &Solution;

    StringCbPrintfW(m_wszQueryCommand, sizeof(m_wszQueryCommand),
                    L"sp_GetBucketSolution '%S', ''",
                    szBucket);
    Hr = GetRecords(&nRecords, TRUE);
    m_pADOResult = NULL;
    if (FAILED(Hr))
    {
        return Hr;
    }
    if (Solution.m_dw_SolType == 0 &&
        Solution.m_sz_Solution[0] == 0)
    {
        return E_FAIL;
    }

    StringCchCopy(szSolText, SolTextSize, Solution.m_sz_Solution);
    return Hr;

}

HRESULT
SolutionDatabaseHandler::PrintBucketInfo(
    PSTR sBucket,
    PSTR gBucket
    )
{
    HRESULT Hr = S_OK;
    CHAR SolutionText[MAX_PATH];


    dprintf("BUCKET ID : %s\n", sBucket);
    if (SUCCEEDED(GetSolutiontext(sBucket, SolutionText, sizeof(SolutionText))))
    {
        dprintf("ISSUE IS SOLVED : %s\n\n", SolutionText);
    } else
    {
        dprintf("ISSUE IS UNSOLVED\n");
    }
    return Hr;
}

HRESULT
SolutionDatabaseHandler::AddKnownFailureToDB(LPSTR Bucket)
{
    if (!m_fConnected)
    {
        return E_FAIL;
    }

    HRESULT Hr = S_OK;
    return Hr;
}

HRESULT
BuildGuidForSR(
    PSTR szSR,
    PSTR Guid,
    ULONG GuidSize
    )
{
    GUID srGuid = {0};
    PUCHAR szTempGuid = NULL;
    HRESULT hr = g_Ole32Calls.CoCreateGuid(&srGuid);
    if (FAILED(hr))
    {
        return hr;
    }
    hr = UuidToString(&srGuid, &szTempGuid);
    if (hr == S_OK)
    {
        hr = StringCchCopy(Guid, GuidSize, (PCHAR) szTempGuid);
        RpcStringFree(&szTempGuid);
    }
    return hr;
}


HRESULT
FindSrInfo(
    PSTR szSR,
    PSTR szDumpPath,
    PDEBUG_CONTROL3 DebugControl
    )
{
    HRESULT Hr;
    CHAR szSBucket[100], szGBucket[100];
    CHAR BktComment[200];
    ULONG BugId;

    if (!szSR || *szSR == '\0')
    {
        return E_FAIL;
    }
    if (FAILED(Hr = InitializeDatabaseHandlers(DebugControl ? DebugControl : g_ExtControl, 5)))
    {
        return Hr;
    }

    BktComment[0] = 0;
    BugId = 0;
    // Validate if SR# is present in DB
    if (g_CrDb->CheckSRExists(szSR, NULL))
    {
        // SR present info DB
        if (szDumpPath && *szDumpPath != '\0')
        {
            // we already have an entry
            Hr = E_INVALIDARG;

            dprintf("\n\nThere is already an entry in DB for SR %s. It cannot be linked to another\n"
                    "dumpfile. Specifiy only the SR ID to retrive the crash info.\n",
                    szSR);
        } else
        {
            // Get bucket info

            dprintf("\nFound entry for %s in database.\n\n", szSR);
            Hr = g_CrDb->FindSRBuckets(szSR, szSBucket, sizeof(szSBucket),
                                       szGBucket, sizeof(szGBucket));
            if (SUCCEEDED(Hr))
            {
                g_CrDb->GetBucketComments(szSBucket, BktComment, sizeof(BktComment),
                                          &BugId);
                Hr = S_OK;
            }
        }

    } else if (szDumpPath && *szDumpPath != '\0')
    {
        CRASH_INSTANCE Crash = {0};
        CHAR szGUID[50];
        PCHAR Ext;

        Ext = strrchr(szDumpPath, '.');

        if (Ext == NULL || _stricmp(Ext, ".cab"))
        {
            dprintf("\n\nERROR: %s is not CABed dump.\n Please add only the CAB dumps through ticket.\n\n",
                    szDumpPath);
            Hr = E_INVALIDARG;
        } else if ((Hr = BuildGuidForSR(szSR, szGUID, sizeof(szGUID))) == S_OK)
        {
            CHAR FileName[100];

            StringCchCopy(FileName, sizeof(FileName) - 5, szSR);
            StringCchCat(FileName, sizeof(FileName), ".cab");
            Crash.MesgGuid = szGUID;
            Crash.PssSr = szSR;
            Crash.ArchiveFileName = FileName;
            Crash.Bucket     = szSBucket;
            Crash.BucketSize = sizeof(szSBucket);
            Crash.DefaultBucket     = szGBucket;
            Crash.DefaultBucketSize = sizeof(szGBucket);
            Crash.Path = szDumpPath;

            // Add crash entry to DB
            Hr = AddCrashToDB(2, &Crash);
            if (Hr == S_OK)
            {
//                Hr = g_CrDb->LinkCrashToSR(szSR, &Crash);

                if (SUCCEEDED(Hr))
                {
                    g_CrDb->GetBucketComments(szSBucket, BktComment, sizeof(BktComment),
                                              &BugId);
                    Hr = S_OK;
                }
            }
        }


        // Get bucket info
    } else
    {
        dprintf("SR %s does not exist in database\n", szSR);
        Hr = S_FALSE;
    }

    CHAR szSolution[300];
    ULONG SolutionId;

    if (Hr == S_OK)
    {
        // Print comment, bug id, solution

        if (BugId != 0)
        {
            dprintf("KNOWN BUG # %ld\n\n", BugId);
        }
        if (BktComment[0])
        {
            dprintf("DEV COMMENT ON ISSUE : %s\n\n", BktComment);
        }
        if (g_SolDb->PrintBucketInfo(szSBucket, szGBucket))
        {
        }

    }
    UnInitializeDatabaseHandlers( TRUE );
    return Hr;
}

HRESULT
_EFN_FindSrInfo(
    PSTR szSR,
    PSTR szDumpPath,
    PDEBUG_CONTROL3 DebugControl
    )
{
    return FindSrInfo(szSR, szDumpPath, DebugControl);
}

DECLARE_API( ticket )
{
    HRESULT Hr = S_OK;
    CHAR szSR[100] = {0}, szDumpPath[MAX_PATH] = {0};
    INIT_API();

    if (sscanf(args, "%100s %240s", szSR, szDumpPath))
    {
        Hr = FindSrInfo(szSR, szDumpPath, g_ExtControl);
    } else
    {
        dprintf("Usage: !ticket <SR#> <dumppath>\n");
    }

    EXIT_API();
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\analyze.cpp ===
//----------------------------------------------------------------------------
//
// Generic failure analysis framework.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

#include <time.h>

BOOL g_SymbolsReloaded;

HRESULT
ModuleParams::Update(void)
{
    HRESULT Status;
    ULONG i;
    DEBUG_MODULE_PARAMETERS Params;

    if (m_Valid)
    {
        return S_OK;
    }

    if ((Status = g_ExtSymbols->GetModuleByModuleName(m_Name, 0,
                                                      &i, &m_Base)) == S_OK &&
        (Status = g_ExtSymbols->GetModuleParameters(1, &m_Base, i,
                                                    &Params)) == S_OK)
    {
        m_Size = Params.Size;
        m_Valid = TRUE;
    }

    return Status;
}

// Read a null terminated string from the address specified.
BOOL ReadAcsiiString(ULONG64 Address, PCHAR DestBuffer, ULONG BufferLen)
{
    ULONG OneByteRead;
    ULONG BytesRead = 0;

    if (Address && DestBuffer)
    {
        while (BufferLen && ReadMemory(Address, DestBuffer, 1, &OneByteRead))
        {
            BytesRead++;

            if ((*DestBuffer) == 0)
            {
                return BytesRead;
            }

            BufferLen--;
            DestBuffer++;
            Address++;
        }
    }

    return 0;
}


LONG
FaExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    ULONG Code = ExceptionInfo->ExceptionRecord->ExceptionCode;
    if (Code == E_OUTOFMEMORY || Code == E_INVALIDARG)
    {
        // Expected exceptions that the analysis code
        // can throw to terminate the analysis.  Drop
        // into the handler.
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // Otherwise this isn't an exception we expected.
    // Let it continue on so that it isn't hidden and
    // can be debugged.
    return EXCEPTION_CONTINUE_SEARCH;
}

BOOL
FaGetSymbol(
    ULONG64 Address,
    PCHAR Name,
    PULONG64 Disp,
    ULONG NameSize
    )
{
    CHAR Buffer[MAX_PATH] = {0};

    *Name = 0;
    GetSymbol(Address, Name, Disp);

    if (*Name == 0)
    {
        //
        // Get the actual Image name from debugger module list
        //
        ULONG Index;
        CHAR ModBuffer[100];
        ULONG64 Base;

        if (S_OK == g_ExtSymbols->
            GetModuleByOffset(Address, 0, &Index, &Base))
        {
            if (g_ExtSymbols->
                GetModuleNames(Index, Base,
                               ModBuffer, sizeof(ModBuffer), NULL,
                               NULL, 0, NULL,
                               NULL, 0, NULL) == S_OK)
            {
                PCHAR Break = strrchr(ModBuffer, '\\');
                if (Break)
                {
                    CopyString(ModBuffer, Break + 1, sizeof(ModBuffer));
                }
                CopyString(Name, ModBuffer, NameSize);
                if (Break = strchr(Name, '.'))
                {
                    *Break = 0;
                }

                *Disp = Address - Base;
            }
        }
    }

    return (*Name != 0);
}

BOOL
FaIsFunctionAddr(
    ULONG64 IP,
    PSTR FuncName
    )
// Check if IP is in the function FuncName
{
    static ULONG64 s_LastIP = 0;
    static CHAR s_Buffer[MAX_PATH];
    CHAR *Scan, *FnIP;
    ULONG64 Disp;

    if (s_LastIP != IP)
    {
        // This would make it faster for multiple IsFunctionAddr for same IP
        GetSymbol(IP, s_Buffer, &Disp);
        s_LastIP = IP;
    }

    if (Scan = strchr(s_Buffer, '!'))
    {
        FnIP = Scan + 1;
        while (*FnIP == '_')
        {
            ++FnIP;
        }
    }
    else
    {
        FnIP = &s_Buffer[0];
    }

    return !strncmp(FnIP, FuncName, strlen(FuncName));
}



BOOL
FaGetFollowupInfo(
    IN OPTIONAL ULONG64 Addr,
    PCHAR SymbolName,
    PCHAR Owner,
    ULONG OwnerSize
    )
{
    EXT_TRIAGE_FOLLOWUP FollowUp = &_EFN_GetTriageFollowupFromSymbol;
    DEBUG_TRIAGE_FOLLOWUP_INFO Info;
    CHAR Buffer[MAX_PATH];

    if (!*SymbolName)
    {
        ULONG64 Disp;

        FaGetSymbol(Addr, Buffer, &Disp, sizeof(Buffer));
        SymbolName = Buffer;
    }

    if (*SymbolName)
    {
        Info.SizeOfStruct = sizeof(Info);
        Info.OwnerName = Owner;
        Info.OwnerNameSize = (USHORT)OwnerSize;

        if ((*FollowUp)(g_ExtClient, SymbolName, &Info) > TRIAGE_FOLLOWUP_IGNORE)
        {
            // This is an interesting routine to followup on
            return TRUE;
        }
    }

    if (Owner)
    {
        *Owner=0;
    }

    return FALSE;
}


HRESULT
FaGetPoolTagFollowup(
    PCHAR szPoolTag,
    PSTR Followup,
    ULONG FollowupSize
    )
{
    ULONG PoolTag;
    DEBUG_POOLTAG_DESCRIPTION TagDesc = {0};
    PGET_POOL_TAG_DESCRIPTION pGetTagDesc = NULL;

    TagDesc.SizeOfStruct = sizeof(TagDesc);
    if (g_ExtControl->
        GetExtensionFunction(0, "GetPoolTagDescription",
                         (FARPROC*)&pGetTagDesc) == S_OK &&
        pGetTagDesc)
    {
        PoolTag = *((PULONG) szPoolTag);
        if ((*pGetTagDesc)(PoolTag, &TagDesc) == S_OK)
        {
            PCHAR Dot;

            if (Dot = strchr(TagDesc.Binary, '.'))
            {
                *Dot = 0;
            }
            if (TagDesc.Binary[0])
            {
                if (FaGetFollowupInfo(0, TagDesc.Binary, Followup, FollowupSize))
                {
                    return S_OK;
                }
            }
            if (TagDesc.Owner[0])
            {
                CopyString(Followup, TagDesc.Owner, FollowupSize);
                return S_OK;
            }
        }
    }
    return E_FAIL;
}


ULONG64
FaGetImplicitStackOffset(
    void
    )
{
    // IDebugRegisters::GetStackOffset not used since it
    // ignores implicit context
    ULONG64 Stk = 0;

    switch (g_TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        Stk = GetExpression("@esp");
        break;
    case IMAGE_FILE_MACHINE_IA64:
        Stk = GetExpression("@sp");
        break;
    case IMAGE_FILE_MACHINE_AMD64:
        Stk = GetExpression("@rsp");
        break;
    }

    return Stk;
}


DECLARE_API( analyze )
{
    ULONG EventType, ProcId, ThreadId;
    BOOL Force = FALSE;
    BOOL ForceUser = FALSE;

    INIT_API();

    if (g_ExtControl->GetLastEventInformation(&EventType, &ProcId, &ThreadId,
                                              NULL, 0, NULL,
                                              NULL, 0, NULL) != S_OK)
    {
        ExtErr("Unable to get last event information\n");
        goto Exit;
    }

    //
    // Check for -f in both cases
    //

    PCSTR tmpArgs = args;

    while (*args)
    {
        if (*args == '-')
        {
            ++args;

            if (*args == 'f')
            {
                Force = TRUE;
                break;
            } else if (!strncmp(args, "show",4))
            {
                Force = TRUE;
            } else if (*args == 'u')
            {
                // could be use for user stack anlysis in k-mode
                // ForceUser = TRUE;
            }

        }

        ++args;
    }

    args = tmpArgs;

    //
    // Call the correct routine to process the event.
    //

    if ((EventType == DEBUG_EVENT_EXCEPTION) || (Force == TRUE))
    {
        ULONG DebugType, DebugQual;

        if (g_ExtControl->GetDebuggeeType(&DebugType, &DebugQual) != S_OK)
        {
            ExtErr("Unable to determine debuggee type\n");
            Status = E_FAIL;
        }
        else
        {
            if (ForceUser)
            {
                DebugType = DEBUG_CLASS_USER_WINDOWS;
            }
            switch(DebugType)
            {
            case DEBUG_CLASS_KERNEL:
                //
                // For live debug sessions force the symbols to get reloaded
                // the first time as we find many sessions where the
                // debugger got reconnected and no module list exists.
                // This also happens for user mode breaks in kd where the
                // module list is wrong.
                //
                if ((g_TargetQualifier == DEBUG_KERNEL_CONNECTION) &&
                    (!g_SymbolsReloaded++))
                {
                    g_ExtSymbols->Reload("");
                }
                Status = AnalyzeBugCheck(args);
                break;
            case DEBUG_CLASS_USER_WINDOWS:
                Status = AnalyzeUserException(args);
                break;
            case DEBUG_CLASS_UNINITIALIZED:
                ExtErr("No debuggee\n");
                Status = E_FAIL;
            default:
                ExtErr("Unknown debuggee type\n");
                Status = E_INVALIDARG;
            }
        }
    }
    else if (EventType == 0)
    {
        dprintf("The debuggee is ready to run\n");
        Status = S_OK;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    if (Status == E_NOINTERFACE)
    {
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, ".lastevent",
                              DEBUG_EXECUTE_DEFAULT);
    }

 Exit:
    EXIT_API();
    return Status;
}

HRESULT
_EFN_GetFailureAnalysis(
    IN PDEBUG_CLIENT Client,
    IN ULONG Flags,
    OUT PDEBUG_FAILURE_ANALYSIS* Analysis
    )
{
    BOOL Enter = (g_ExtClient != Client);
    HRESULT Hr;

    if (Enter)
    {
        INIT_API();
    }

    ULONG DebugType, DebugQual;

    if ((Hr = g_ExtControl->GetDebuggeeType(&DebugType,
                                            &DebugQual)) != S_OK)
    {
        ExtErr("Unable to determine debuggee type\n");
    }
    else if (DebugType == DEBUG_CLASS_KERNEL)
    {
        BUGCHECK_ANALYSIS Bc;

        *Analysis = (IDebugFailureAnalysis*)BcAnalyze(&Bc, Flags);
        Hr = *Analysis ? S_OK : E_OUTOFMEMORY;
    }
    else if (DebugType == DEBUG_CLASS_USER_WINDOWS)
    {
        EX_STATE ExState;

        *Analysis = (IDebugFailureAnalysis*)UeAnalyze(&ExState, Flags);
        Hr = *Analysis ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        Hr = E_INVALIDARG;
    }

    if (Enter)
    {
        EXIT_API();
    }

    return Hr;
}

DECLARE_API( dumpfa )
{
    INIT_API();

    ULONG64 Address = GetExpression(args);
    if (Address)
    {
        ULONG64 Data;
        ULONG64 DataUsed;
        ULONG EntrySize;

        EntrySize = GetTypeSize("ext!_FA_ENTRY");

        InitTypeRead(Address, ext!DebugFailureAnalysis);
        Data = ReadField(m_Data);
        DataUsed = ReadField(m_DataUsed);

        g_ExtControl->Output(1, "DataUsed %x\n", (ULONG)DataUsed);

        while (DataUsed > EntrySize)
        {
            ULONG FullSize;

            InitTypeRead(Data, ext!_FA_ENTRY);
            g_ExtControl->Output(1,
                                 "Type = %08lx - Size = %x\n",
                                 (ULONG)ReadField(Tag),
                                 ReadField(DataSize));
            FullSize = (ULONG)ReadField(FullSize);
            Data += FullSize;
            DataUsed -= FullSize;
        }
    }

    EXIT_API();
    return S_OK;
}

//----------------------------------------------------------------------------
//
// DebugFailureAnalysisImpl.
//
//----------------------------------------------------------------------------

#define FA_ALIGN(Size) (((Size) + 7) & ~7)
#define FA_GROW_BY 4096

#if DBG
#define SCORCH_ENTRY(Entry) \
    memset((Entry) + 1, 0xdb, (Entry)->FullSize - sizeof(*(Entry)))
#else
#define SCORCH_ENTRY(Entry)
#endif

#define RAISE_ERROR(Code) RaiseException(Code, 0, 0, NULL)

DebugFailureAnalysis::DebugFailureAnalysis(void)
{
    m_Refs = 1;

    m_FailureClass = DEBUG_CLASS_UNINITIALIZED;
    m_FailureType = DEBUG_FLR_UNKNOWN;
    m_FailureCode = 0;

    m_Data = NULL;
    m_DataLen = 0;
    m_DataUsed = 0;

    ZeroMemory(PossibleFollowups, sizeof(PossibleFollowups));
    BestClassFollowUp = (FlpClasses)0;

}

DebugFailureAnalysis::~DebugFailureAnalysis(void)
{
    free(m_Data);
}

STDMETHODIMP
DebugFailureAnalysis::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = S_OK;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugFailureAnalysis)))
    {
        *Interface = (IDebugFailureAnalysis *)this;
        AddRef();
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
DebugFailureAnalysis::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
DebugFailureAnalysis::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        delete this;
    }
    return Refs;
}

STDMETHODIMP_(ULONG)
DebugFailureAnalysis::GetFailureClass(void)
{
    return m_FailureClass;
}

STDMETHODIMP_(DEBUG_FAILURE_TYPE)
DebugFailureAnalysis::GetFailureType(void)
{
    return m_FailureType;
}

STDMETHODIMP_(ULONG)
DebugFailureAnalysis::GetFailureCode(void)
{
    return m_FailureCode;
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::Get(FA_TAG Tag)
{
    FA_ENTRY* Entry = NULL;
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if (Entry->Tag == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::GetNext(FA_ENTRY* Entry, FA_TAG Tag, FA_TAG TagMask)
{
    while ((Entry = NextEntry(Entry)) != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            return Entry;
        }
    }

    return NULL;
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::GetString(FA_TAG Tag, PSTR Str, ULONG MaxSize)
{
    FA_ENTRY* Entry = Get(Tag);

    if (Entry != NULL)
    {
        if (Entry->DataSize > MaxSize)
        {
            return NULL;
        }

        CopyString(Str, FA_ENTRY_DATA(PSTR, Entry),MaxSize);
    }

    return Entry;
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::GetBuffer(FA_TAG Tag, PVOID Buf, ULONG Size)
{
    FA_ENTRY* Entry = Get(Tag);

    if (Entry != NULL)
    {
        if (Entry->DataSize != Size)
        {
            return NULL;
        }

        memcpy(Buf, FA_ENTRY_DATA(PUCHAR, Entry), Size);
    }

    return Entry;
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::GetUlong(FA_TAG Tag, PULONG Value)
{
    return GetBuffer(Tag, Value, sizeof(*Value));
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::GetUlong64(FA_TAG Tag, PULONG64 Value)
{
    return GetBuffer(Tag, Value, sizeof(*Value));
}

STDMETHODIMP_(FA_ENTRY*)
DebugFailureAnalysis::NextEntry(FA_ENTRY* Entry)
{
    if (Entry == NULL)
    {
        Entry = (FA_ENTRY*)m_Data;
    }
    else
    {
        Entry = (FA_ENTRY*)((PUCHAR)Entry + Entry->FullSize);
    }

    if (ValidEntry(Entry))
    {
        return Entry;
    }
    else
    {
        return NULL;
    }
}

FA_ENTRY*
DebugFailureAnalysis::Set(FA_TAG Tag, ULONG Size)
{
    FA_ENTRY* Entry;
    ULONG FullSize;

    // Compute full rounded size.
    FullSize = sizeof(FA_ENTRY) + FA_ALIGN(Size);

    // Check and see if there's already an entry.
    Entry = Get(Tag);
    if (Entry != NULL)
    {
        // If it's already large enough use it and
        // pack in remaining data.
        if (Entry->FullSize >= FullSize)
        {
            ULONG Pack = Entry->FullSize - FullSize;
            if (Pack > 0)
            {
                PackData((PUCHAR)Entry + FullSize, Pack);
                Entry->FullSize = (USHORT)FullSize;
            }

            Entry->DataSize = (USHORT)Size;
            SCORCH_ENTRY(Entry);
            return Entry;
        }

        // Entry is too small so remove it.
        PackData((PUCHAR)Entry, Entry->FullSize);
    }

    return Add(Tag, Size);
}

FA_ENTRY*
DebugFailureAnalysis::SetString(FA_TAG Tag, PSTR Str)
{
    ULONG Size = strlen(Str) + 1;
    FA_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(FA_ENTRY_DATA(PSTR, Entry), Str, Size);
    }

    return Entry;
}

FA_ENTRY*
DebugFailureAnalysis::SetStrings(FA_TAG Tag, ULONG Count, PSTR* Strs)
{
    ULONG i;
    ULONG Size = 0;

    for (i = 0; i < Count; i++)
    {
        Size += strlen(Strs[i]) + 1;
    }
    // Put a double terminator at the very end.
    Size++;

    FA_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        PSTR Data = FA_ENTRY_DATA(PSTR, Entry);

        for (i = 0; i < Count; i++)
        {
            Size = strlen(Strs[i]) + 1;
            memcpy(Data, Strs[i], Size);
            Data += Size;
        }
        *Data = 0;
    }

    return Entry;
}

FA_ENTRY*
DebugFailureAnalysis::SetBuffer(FA_TAG Tag, PVOID Buf, ULONG Size)
{
    FA_ENTRY* Entry = Set(Tag, Size);

    if (Entry != NULL)
    {
        memcpy(FA_ENTRY_DATA(PUCHAR, Entry), Buf, Size);
    }

    return Entry;
}

FA_ENTRY*
DebugFailureAnalysis::Add(FA_TAG Tag, ULONG Size)
{
    // Compute full rounded size.
    ULONG FullSize = sizeof(FA_ENTRY) + FA_ALIGN(Size);

    FA_ENTRY* Entry = AllocateEntry(FullSize);
    if (Entry != NULL)
    {
        Entry->Tag = Tag;
        Entry->FullSize = (USHORT)FullSize;
        Entry->DataSize = (USHORT)Size;
        SCORCH_ENTRY(Entry);
    }

    return Entry;
}

ULONG
DebugFailureAnalysis::Delete(FA_TAG Tag, FA_TAG TagMask)
{
    ULONG Deleted = 0;
    FA_ENTRY* Entry = NextEntry(NULL);

    while (Entry != NULL)
    {
        if ((Entry->Tag & TagMask) == Tag)
        {
            PackData((PUCHAR)Entry, Entry->FullSize);
            Deleted++;

            // Check and see if we packed away the last entry.
            if (!ValidEntry(Entry))
            {
                break;
            }
        }
        else
        {
            Entry = NextEntry(Entry);
        }
    }

    return Deleted;
}

void
DebugFailureAnalysis::Empty(void)
{
    // Reset used to just the header.
    m_DataUsed = 0;
}

FA_ENTRY*
DebugFailureAnalysis::AllocateEntry(ULONG FullSize)
{
    // Sizes must fit in USHORTs.  This shouldn't be
    // a big problem since analyses shouldn't have
    // huge data items in them.
    if (FullSize > 0xffff)
    {
        RAISE_ERROR(E_INVALIDARG);
        return NULL;
    }

    if (m_DataUsed + FullSize > m_DataLen)
    {
        ULONG NewLen = m_DataLen;
        do
        {
            NewLen += FA_GROW_BY;
        }
        while (m_DataUsed + FullSize > NewLen);

        PUCHAR NewData = (PUCHAR)realloc(m_Data, NewLen);
        if (NewData == NULL)
        {
            RAISE_ERROR(E_OUTOFMEMORY);
            return NULL;
        }

        m_Data = NewData;
        m_DataLen = NewLen;
    }

    FA_ENTRY* Entry = (FA_ENTRY*)(m_Data + m_DataUsed);
    m_DataUsed += FullSize;
    return Entry;
}


void
DebugFailureAnalysis::DbFindBucketInfo(
    void
    )
{
    SolutionDatabaseHandler *Db;
    CHAR Solution[SOLUTION_TEXT_SIZE];
    CHAR SolOSVer[OS_VER_SIZE];
    ULONG RaidBug;
    FA_ENTRY* BucketEntry;
    FA_ENTRY* GBucketEntry;
    FA_ENTRY* DriverNameEntry = NULL;
    FA_ENTRY* TimeStampEntry = NULL;
    static CHAR SolvedBucket[MAX_PATH] = {0}, SolvedgBucket[MAX_PATH] = {0};
    static CHAR SolutionString[MAX_PATH] = {0};
    static ULONG SolutionId = 0, SolutionType, SolutionIdgBucket = 0;

    if (GetProcessingFlags() & FAILURE_ANALYSIS_NO_DB_LOOKUP)
    {
        return;
    }

    if (!(BucketEntry = Get(DEBUG_FLR_BUCKET_ID)))
    {
        return;
    }


    if (!strcmp(SolvedBucket, FA_ENTRY_DATA(PCHAR, BucketEntry)))
    {
        if (SolutionType != CiSolUnsolved)
        {
            SetString(DEBUG_FLR_INTERNAL_SOLUTION_TEXT, SolutionString);
        }
        SetUlong(DEBUG_FLR_SOLUTION_ID, SolutionId);
        SetUlong(DEBUG_FLR_SOLUTION_TYPE, SolutionType);

        // Generic bucket
        if (BucketEntry = Get(DEBUG_FLR_DEFAULT_BUCKET_ID))
        {
            if (!strcmp(SolvedgBucket, FA_ENTRY_DATA(PCHAR, BucketEntry)))
            {
                SetUlong(DEBUG_FLR_DEFAULT_SOLUTION_ID, SolutionIdgBucket);
            }

        }

        return;
    }

//    if (!(DriverNameEntry = Get(DEBUG_FLR_IMAGE_NAME)) ||
//        !(TimeStampEntry =  Get(DEBUG_FLR_IMAGE_TIMESTAMP)))
//    {
//        return;
//    }

    HRESULT Hr;
    BOOL SolDbInitialized = g_SolDb != NULL;

    if (!SolDbInitialized)
    {
        if (FAILED(Hr = InitializeDatabaseHandlers(g_ExtControl, 4)))
        {
            // dprintf("Database initialize failed %lx\n", Hr);
            return;
        }
        SolDbInitialized = TRUE;
    }

    if (g_SolDb->ConnectToDataBase())
    {
        if (GBucketEntry = Get(DEBUG_FLR_DEFAULT_BUCKET_ID))
        {
            CopyString(SolvedgBucket, FA_ENTRY_DATA(PCHAR, GBucketEntry), sizeof(SolvedgBucket));
        }

        //
        // List crashes for the same bucket
        //
        CopyString(SolvedBucket, FA_ENTRY_DATA(PCHAR, BucketEntry), sizeof(SolvedBucket));
        if (SUCCEEDED(Hr = g_SolDb->GetSolutionFromDB(FA_ENTRY_DATA(PCHAR, BucketEntry),
                                                      SolvedgBucket, NULL, 0,
//                                  FA_ENTRY_DATA(PCHAR, DriverNameEntry),
//                                (ULONG)(*FA_ENTRY_DATA(PULONG64, TimeStampEntry)),
                                                      0, Solution, SOLUTION_TEXT_SIZE,
                                                      &SolutionId, &SolutionType,
                                                      &SolutionIdgBucket)))
        {
            if (SolutionId != 0)
            {
                SetString(DEBUG_FLR_INTERNAL_SOLUTION_TEXT, Solution);
                CopyString(SolutionString, Solution, sizeof(SolutionString));
            } else
            {
                SolutionId = -1; // unsolved
                SolutionType = 0;
            }
            if (SolutionIdgBucket == 0)
            {
                SolutionIdgBucket = -1; // unsolved
            }

            SetUlong(DEBUG_FLR_SOLUTION_ID, SolutionId);
            SetUlong(DEBUG_FLR_SOLUTION_TYPE, SolutionType);
            SetUlong(DEBUG_FLR_DEFAULT_SOLUTION_ID, SolutionIdgBucket);
        } else
        {
            // We did not succesfully look up in DB
            SolvedgBucket[0] = '\0';
            SolvedBucket[0] = '\0';
        }


#if 0
        if (SolOSVer[0] != '\0')
        {
            SetString(DEBUG_FLR_FIXED_IN_OSVERSION, SolOSVer);
        }
    }
            if (Db->FindRaidBug(FA_ENTRY_DATA(PCHAR, Entry),
                                  &RaidBug) == S_OK)
            {
                SetUlong64(DEBUG_FLR_INTERNAL_RAID_BUG, RaidBug);
            }
#endif
    }
    ;
    if (SolDbInitialized)
    {
        UnInitializeDatabaseHandlers(FALSE);
    }

    return;
}


FLR_LOOKUP_TABLE FlrLookupTable[] = {
    DEBUG_FLR_RESERVED                         , "RESERVED"
   ,DEBUG_FLR_DRIVER_OBJECT                    , "DRIVER_OBJECT"
   ,DEBUG_FLR_DEVICE_OBJECT                    , "DEVICE_OBJECT"
   ,DEBUG_FLR_INVALID_PFN                      , "INVALID_PFN"
   ,DEBUG_FLR_WORKER_ROUTINE                   , "WORKER_ROUTINE"
   ,DEBUG_FLR_WORK_ITEM                        , "WORK_ITEM"
   ,DEBUG_FLR_INVALID_DPC_FOUND                , "INVALID_DPC_FOUND"
   ,DEBUG_FLR_PROCESS_OBJECT                   , "PROCESS_OBJECT"
   ,DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS       , "FAILED_INSTRUCTION_ADDRESS"
   ,DEBUG_FLR_LAST_CONTROL_TRANSFER            , "LAST_CONTROL_TRANSFER"
   ,DEBUG_FLR_ACPI_EXTENSION                   , "ACPI_EXTENSION"
   ,DEBUG_FLR_ACPI_OBJECT                      , "ACPI_OBJECT"
   ,DEBUG_FLR_PROCESS_NAME                     , "PROCESS_NAME"
   ,DEBUG_FLR_READ_ADDRESS                     , "READ_ADDRESS"
   ,DEBUG_FLR_WRITE_ADDRESS                    , "WRITE_ADDRESS"
   ,DEBUG_FLR_CRITICAL_SECTION                 , "CRITICAL_SECTION"
   ,DEBUG_FLR_BAD_HANDLE                       , "BAD_HANDLE"
   ,DEBUG_FLR_INVALID_HEAP_ADDRESS             , "INVALID_HEAP_ADDRESS"
   ,DEBUG_FLR_IRP_ADDRESS                      , "IRP_ADDRESS"
   ,DEBUG_FLR_IRP_MAJOR_FN                     , "IRP_MAJOR_FN"
   ,DEBUG_FLR_IRP_MINOR_FN                     , "IRP_MINOR_FN"
   ,DEBUG_FLR_IRP_CANCEL_ROUTINE               , "IRP_CANCEL_ROUTINE"
   ,DEBUG_FLR_IOSB_ADDRESS                     , "IOSB_ADDRESS"
   ,DEBUG_FLR_INVALID_USEREVENT                , "INVALID_USEREVENT"
   ,DEBUG_FLR_PREVIOUS_MODE                    , "PREVIOUS_MODE"
   ,DEBUG_FLR_CURRENT_IRQL                     , "CURRENT_IRQL"
   ,DEBUG_FLR_PREVIOUS_IRQL                    , "PREVIOUS_IRQL"
   ,DEBUG_FLR_REQUESTED_IRQL                   , "REQUESTED_IRQL"
   ,DEBUG_FLR_ASSERT_DATA                      , "ASSERT_DATA"
   ,DEBUG_FLR_ASSERT_FILE                      , "ASSERT_FILE_LOCATION"
   ,DEBUG_FLR_EXCEPTION_PARAMETER1             , "EXCEPTION_PARAMETER1"
   ,DEBUG_FLR_EXCEPTION_PARAMETER2             , "EXCEPTION_PARAMETER2"
   ,DEBUG_FLR_EXCEPTION_PARAMETER3             , "EXCEPTION_PARAMETER3"
   ,DEBUG_FLR_EXCEPTION_PARAMETER4             , "EXCEPTION_PARAMETER4"
   ,DEBUG_FLR_EXCEPTION_RECORD                 , "EXCEPTION_RECORD"
   ,DEBUG_FLR_POOL_ADDRESS                     , "POOL_ADDRESS"
   ,DEBUG_FLR_CORRUPTING_POOL_ADDRESS          , "CORRUPTING_POOL_ADDRESS"
   ,DEBUG_FLR_CORRUPTING_POOL_TAG              , "CORRUPTING_POOL_TAG"
   ,DEBUG_FLR_FREED_POOL_TAG                   , "FREED_POOL_TAG"
   ,DEBUG_FLR_SPECIAL_POOL_CORRUPTION_TYPE     , "SPECIAL_POOL_CORRUPTION_TYPE"
   ,DEBUG_FLR_FILE_ID                          , "FILE_ID"
   ,DEBUG_FLR_FILE_LINE                        , "FILE_LINE"
   ,DEBUG_FLR_BUGCHECK_STR                     , "BUGCHECK_STR"
   ,DEBUG_FLR_BUGCHECK_SPECIFIER               , "BUGCHECK_SPECIFIER"
   ,DEBUG_FLR_DRIVER_VERIFIER_IO_VIOLATION_TYPE, "DRIVER_VERIFIER_IO_VIOLATION_TYPE"
   ,DEBUG_FLR_EXCEPTION_CODE                   , "EXCEPTION_CODE"
   ,DEBUG_FLR_STATUS_CODE                      , "STATUS_CODE"
   ,DEBUG_FLR_IOCONTROL_CODE                   , "IOCONTROL_CODE"
   ,DEBUG_FLR_MM_INTERNAL_CODE                 , "MM_INTERNAL_CODE"
   ,DEBUG_FLR_DRVPOWERSTATE_SUBCODE            , "DRVPOWERSTATE_SUBCODE"
   ,DEBUG_FLR_CORRUPT_MODULE_LIST              , "CORRUPT_MODULE_LIST"
   ,DEBUG_FLR_BAD_STACK                        , "BAD_STACK"
   ,DEBUG_FLR_ZEROED_STACK                     , "ZEROED_STACK"
   ,DEBUG_FLR_WRONG_SYMBOLS                    , "WRONG_SYMBOLS"
   ,DEBUG_FLR_FOLLOWUP_DRIVER_ONLY             , "FOLLOWUP_DRIVER_ONLY"
   ,DEBUG_FLR_CPU_OVERCLOCKED                  , "CPU_OVERCLOCKED"
   ,DEBUG_FLR_MANUAL_BREAKIN                   , "MANUAL_BREAKIN"
   ,DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER, "POSSIBLE_INVALID_CONTROL_TRANSFER"
   ,DEBUG_FLR_POISONED_TB                      , "POISONED_TB"
   ,DEBUG_FLR_UNKNOWN_MODULE                   , "UNKNOWN_MODULE"
   ,DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION      , "ANALYZAABLE_POOL_CORRUPTION"
   ,DEBUG_FLR_SINGLE_BIT_ERROR                 , "SINGLE_BIT_ERROR"
   ,DEBUG_FLR_TWO_BIT_ERROR                    , "TWO_BIT_ERROR"
   ,DEBUG_FLR_INVALID_KERNEL_CONTEXT           , "INVALID_KERNEL_CONTEXT"
   ,DEBUG_FLR_DISK_HARDWARE_ERROR              , "DISK_HARDWARE_ERROR"
   ,DEBUG_FLR_POOL_CORRUPTOR                   , "POOL_CORRUPTOR"
   ,DEBUG_FLR_MEMORY_CORRUPTOR                 , "MEMORY_CORRUPTOR"
   ,DEBUG_FLR_UNALIGNED_STACK_POINTER          , "UNALIGNED_STACK_POINTER"
   ,DEBUG_FLR_OLD_OS_VERSION                   , "OLD_OS_VERSION"
   ,DEBUG_FLR_BUGCHECKING_DRIVER               , "BUGCHECKING_DRIVER"
   ,DEBUG_FLR_BUCKET_ID                        , "BUCKET_ID"
   ,DEBUG_FLR_IMAGE_NAME                       , "IMAGE_NAME"
   ,DEBUG_FLR_SYMBOL_NAME                      , "SYMBOL_NAME"
   ,DEBUG_FLR_FOLLOWUP_NAME                    , "FOLLOWUP_NAME"
   ,DEBUG_FLR_STACK_COMMAND                    , "STACK_COMMAND"
   ,DEBUG_FLR_STACK_TEXT                       , "STACK_TEXT"
   ,DEBUG_FLR_INTERNAL_SOLUTION_TEXT           , "INTERNAL_SOLUTION_TEXT"
   ,DEBUG_FLR_MODULE_NAME                      , "MODULE_NAME"
   ,DEBUG_FLR_INTERNAL_RAID_BUG                , "INTERNAL_RAID_BUG"
   ,DEBUG_FLR_FIXED_IN_OSVERSION               , "FIXED_IN_OSVERSION"
   ,DEBUG_FLR_DEFAULT_BUCKET_ID                , "DEFAULT_BUCKET_ID"
   ,DEBUG_FLR_FAULTING_IP                      , "FAULTING_IP"
   ,DEBUG_FLR_FAULTING_MODULE                  , "FAULTING_MODULE"
   ,DEBUG_FLR_IMAGE_TIMESTAMP                  , "DEBUG_FLR_IMAGE_TIMESTAMP"
   ,DEBUG_FLR_FOLLOWUP_IP                      , "FOLLOWUP_IP"
   ,DEBUG_FLR_FAULTING_THREAD                  , "FAULTING_THREAD"
   ,DEBUG_FLR_CONTEXT                          , "CONTEXT"
   ,DEBUG_FLR_TRAP_FRAME                       , "TRAP_FRAME"
   ,DEBUG_FLR_TSS                              , "TSS"
   ,DEBUG_FLR_SHOW_ERRORLOG                    , "ERROR_LOG"
   ,DEBUG_FLR_MASK_ALL                         , "MASK_ALL"
   // Zero entry Must be last;
   ,DEBUG_FLR_INVALID                          , "INVALID"
};



void
DebugFailureAnalysis::OutputEntryParam(DEBUG_FLR_PARAM_TYPE Type)
{
    FA_ENTRY *Entry = Get(Type);

    if (Entry)
    {
        OutputEntry(Entry);
    }
}

void
DebugFailureAnalysis::OutputEntry(FA_ENTRY* Entry)
{
    CHAR Buffer[MAX_PATH];
    CHAR Module[MAX_PATH];
    ULONG64 Base;
    ULONG64 Address;
    ULONG OutCtl;
    ULONG i = 0;

    OutCtl = DEBUG_OUTCTL_AMBIENT;

    switch(Entry->Tag)
    {
    // These are just tags - don't print out
    case DEBUG_FLR_CORRUPT_MODULE_LIST:
    case DEBUG_FLR_BAD_STACK:
    case DEBUG_FLR_ZEROED_STACK:
    case DEBUG_FLR_WRONG_SYMBOLS:
    case DEBUG_FLR_FOLLOWUP_DRIVER_ONLY:
    case DEBUG_FLR_UNKNOWN_MODULE:
    case DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION:
    case DEBUG_FLR_INVALID_KERNEL_CONTEXT:
    case DEBUG_FLR_SOLUTION_TYPE:
    case DEBUG_FLR_MANUAL_BREAKIN:

    // soluion ids from DB
    case DEBUG_FLR_SOLUTION_ID:
    case DEBUG_FLR_DEFAULT_SOLUTION_ID:

    // Field folded into others
    case DEBUG_FLR_BUGCHECK_SPECIFIER:
        return;

    // Marged with other output
        return;
    }

    //
    // Find the entry in the description table
    //

    while(FlrLookupTable[i].Data &&
          Entry->Tag != FlrLookupTable[i].Data)
    {
        i++;
    }

    dprintf("\n%s: ", FlrLookupTable[i].String);

    switch(Entry->Tag)
    {
    // Notification to user
    case DEBUG_FLR_DISK_HARDWARE_ERROR:
        // FlrLookupTable value has already been printed
        dprintf("There was error with disk hardware\n");
        break;

    // Strings:
    case DEBUG_FLR_ASSERT_DATA:
    case DEBUG_FLR_ASSERT_FILE:
    case DEBUG_FLR_BUCKET_ID:
    case DEBUG_FLR_DEFAULT_BUCKET_ID:
    case DEBUG_FLR_STACK_TEXT:
    case DEBUG_FLR_STACK_COMMAND:
    case DEBUG_FLR_INTERNAL_SOLUTION_TEXT:
    case DEBUG_FLR_FIXED_IN_OSVERSION:
    case DEBUG_FLR_BUGCHECK_STR:
    case DEBUG_FLR_IMAGE_NAME:
    case DEBUG_FLR_MODULE_NAME:
    case DEBUG_FLR_PROCESS_NAME:
    case DEBUG_FLR_FOLLOWUP_NAME:
    case DEBUG_FLR_POOL_CORRUPTOR:
    case DEBUG_FLR_MEMORY_CORRUPTOR:
    case DEBUG_FLR_BUGCHECKING_DRIVER:
    case DEBUG_FLR_SYMBOL_NAME:
    case DEBUG_FLR_CORRUPTING_POOL_TAG:
    case DEBUG_FLR_FREED_POOL_TAG:
        dprintf(" %s\n", FA_ENTRY_DATA(PCHAR, Entry));
        break;

    // DWORDs:
    case DEBUG_FLR_PREVIOUS_IRQL:
    case DEBUG_FLR_CURRENT_IRQL:
    case DEBUG_FLR_MM_INTERNAL_CODE:
    case DEBUG_FLR_SPECIAL_POOL_CORRUPTION_TYPE:
    case DEBUG_FLR_PREVIOUS_MODE:
    case DEBUG_FLR_IMAGE_TIMESTAMP:
    case DEBUG_FLR_SINGLE_BIT_ERROR:
    case DEBUG_FLR_TWO_BIT_ERROR:
        dprintf(" %lx\n", *FA_ENTRY_DATA(PULONG64, Entry));
        break;

    // DWORDs:
    case DEBUG_FLR_INTERNAL_RAID_BUG:
    case DEBUG_FLR_OLD_OS_VERSION:
        dprintf(" %d\n",  *FA_ENTRY_DATA(PULONG64, Entry));
        break;

    // Pointers
    case DEBUG_FLR_PROCESS_OBJECT:
    case DEBUG_FLR_DEVICE_OBJECT:
    case DEBUG_FLR_DRIVER_OBJECT:
    case DEBUG_FLR_ACPI_OBJECT:
    case DEBUG_FLR_IRP_ADDRESS:
    case DEBUG_FLR_EXCEPTION_PARAMETER1:
    case DEBUG_FLR_EXCEPTION_PARAMETER2:
    case DEBUG_FLR_FAULTING_THREAD:
    case DEBUG_FLR_WORK_ITEM:
        dprintf(" %p\n", *FA_ENTRY_DATA(PULONG64, Entry));
        break;

    // Pointers to code
    case DEBUG_FLR_WORKER_ROUTINE:
    case DEBUG_FLR_IRP_CANCEL_ROUTINE:
    case DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS:
    case DEBUG_FLR_FAULTING_IP:
    case DEBUG_FLR_FOLLOWUP_IP:
    case DEBUG_FLR_FAULTING_MODULE:
        FaGetSymbol(*FA_ENTRY_DATA(PULONG64, Entry), Buffer, &Address, sizeof(Buffer));
        dprintf("\n%s+%I64lx\n", Buffer, Address);

        g_ExtControl->OutputDisassemblyLines(OutCtl, 0, 1,
                                             *FA_ENTRY_DATA(PULONG64, Entry),
                                             0, NULL, NULL, NULL, NULL);
        break;

    // Address description
    case DEBUG_FLR_READ_ADDRESS:
    case DEBUG_FLR_WRITE_ADDRESS:
    case DEBUG_FLR_POOL_ADDRESS:
    case DEBUG_FLR_CORRUPTING_POOL_ADDRESS:
    {
        PCSTR Desc = DescribeAddress(*FA_ENTRY_DATA(PULONG64, Entry));
        if (!Desc)
        {
            Desc = "";
        }
        dprintf(" %p %s\n", *FA_ENTRY_DATA(PULONG64, Entry), Desc);
        break;
    }

    case DEBUG_FLR_EXCEPTION_CODE:
    case DEBUG_FLR_STATUS_CODE:
    {
        DEBUG_DECODE_ERROR Err;

        Err.Code = (ULONG) *FA_ENTRY_DATA(PULONG, Entry);
        Err.TreatAsStatus = (Entry->Tag == DEBUG_FLR_STATUS_CODE);

//      dprintf(" %lx", *FA_ENTRY_DATA(PULONG, Entry));
        DecodeErrorForMessage( &Err );
        if (!Err.TreatAsStatus)
        {
            dprintf("(%s) %#x (%u) - %s\n",
                    Err.Source, Err.Code, Err.Code, Err.Message);
        }
        else
        {
            dprintf("(%s) %#x - %s\n",
                    Err.Source, Err.Code, Err.Message);
        }

        break;
    }

    case DEBUG_FLR_CPU_OVERCLOCKED:
        dprintf(" *** Machine was determined to be overclocked !\n");
        break;

    case DEBUG_FLR_ACPI_EXTENSION:
        dprintf(" %p -- (!acpikd.acpiext %p)\n", *FA_ENTRY_DATA(PULONG64, Entry),
                 *FA_ENTRY_DATA(PULONG64, Entry));
        sprintf(Buffer, "!acpikd.acpiext %I64lx", *FA_ENTRY_DATA(PULONG64, Entry));
        g_ExtControl->Execute(OutCtl, Buffer, DEBUG_EXECUTE_DEFAULT);
        break;

    case DEBUG_FLR_TRAP_FRAME:
        dprintf(" %p -- (.trap %I64lx)\n", *FA_ENTRY_DATA(PULONG64, Entry),
                *FA_ENTRY_DATA(PULONG64, Entry));
        sprintf(Buffer, ".trap %I64lx", *FA_ENTRY_DATA(PULONG64, Entry));
        g_ExtControl->Execute(OutCtl, Buffer, DEBUG_EXECUTE_DEFAULT);
        g_ExtControl->Execute(OutCtl, ".trap", DEBUG_EXECUTE_DEFAULT);
        break;

    case DEBUG_FLR_CONTEXT:
        dprintf(" %p -- (.cxr %I64lx)\n", *FA_ENTRY_DATA(PULONG64, Entry),
                *FA_ENTRY_DATA(PULONG64, Entry));
        sprintf(Buffer, ".cxr %I64lx", *FA_ENTRY_DATA(PULONG64, Entry));
        g_ExtControl->Execute(OutCtl, Buffer, DEBUG_EXECUTE_DEFAULT);
        g_ExtControl->Execute(OutCtl, ".cxr", DEBUG_EXECUTE_DEFAULT);
        break;

    case DEBUG_FLR_EXCEPTION_RECORD:
        dprintf(" %p -- (.exr %I64lx)\n", *FA_ENTRY_DATA(PULONG64, Entry),
                *FA_ENTRY_DATA(PULONG64, Entry));
        sprintf(Buffer, ".exr %I64lx", *FA_ENTRY_DATA(PULONG64, Entry));
        g_ExtControl->Execute(OutCtl, Buffer, DEBUG_EXECUTE_DEFAULT);
        break;

    case DEBUG_FLR_TSS:
        dprintf(" %p -- (.tss %I64lx)\n", *FA_ENTRY_DATA(PULONG64, Entry),
                *FA_ENTRY_DATA(PULONG64, Entry));
        sprintf(Buffer, ".tss %I64lx", *FA_ENTRY_DATA(PULONG64, Entry));
        g_ExtControl->Execute(OutCtl, Buffer, DEBUG_EXECUTE_DEFAULT);
        g_ExtControl->Execute(OutCtl, ".trap", DEBUG_EXECUTE_DEFAULT);
        break;


    case DEBUG_FLR_LAST_CONTROL_TRANSFER:
    case DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER:
        dprintf(" from %p to %p\n",
                FA_ENTRY_DATA(PULONG64, Entry)[0],
                FA_ENTRY_DATA(PULONG64, Entry)[1]);
        break;
    case DEBUG_FLR_CRITICAL_SECTION:
        dprintf("%p (!cs -s %p)\n",
                 *FA_ENTRY_DATA(PULONG64, Entry),
                 *FA_ENTRY_DATA(PULONG64, Entry));
        break;
    case DEBUG_FLR_BAD_HANDLE:
        dprintf("%p (!htrace %p)\n",
                 *FA_ENTRY_DATA(PULONG64, Entry),
                 *FA_ENTRY_DATA(PULONG64, Entry));
        break;
    case DEBUG_FLR_INVALID_HEAP_ADDRESS:
        dprintf("%p (!heap -p -a %p)\n",
                 *FA_ENTRY_DATA(PULONG64, Entry),
                 *FA_ENTRY_DATA(PULONG64, Entry));
        break;

    case DEBUG_FLR_SHOW_ERRORLOG:
        g_ExtControl->Execute(OutCtl, "!errlog", DEBUG_EXECUTE_DEFAULT);
        break;

    default:
        dprintf(" *** Unknown TAG in analysis list %lx\n\n",
                Entry->Tag);
        return;

    }

    return;
}


void
DebugFailureAnalysis::Output()
{
    ULONG RetVal;
    FA_ENTRY* Entry;
    BOOL Verbose = (GetProcessingFlags() & FAILURE_ANALYSIS_VERBOSE);

    //
    // In verbose mode, show everything that we figured out during analysis
    //

    if (Verbose)
    {
        Entry = NULL;
        while (Entry = NextEntry(Entry))
        {
            OutputEntry(Entry);
        }
    }

    if (Get(DEBUG_FLR_POISONED_TB))
    {
        dprintf("*** WARNING: nt!MmPoisonedTb is non-zero:\n"
                "***    The machine has been manipulated using the kernel debugger.\n"
                "***    MachineOwner should be contacted first\n\n\n");
    }

    PCHAR SolInOS = NULL;

    if (Entry = Get(DEBUG_FLR_FIXED_IN_OSVERSION))
    {
        SolInOS =  FA_ENTRY_DATA(PCHAR, Entry);
    }

    PCHAR Solution = NULL;

    if (Entry = Get(DEBUG_FLR_INTERNAL_SOLUTION_TEXT))
    {
        Solution = FA_ENTRY_DATA(PCHAR, Entry);
    }

    //
    // Print the bad driver if we are not in verbose mode - otherwise
    // is is printed out using the params
    //

    if (!Verbose && !Solution)
    {
        if (Entry = Get(DEBUG_FLR_CORRUPTING_POOL_TAG))
        {
            dprintf("Probably pool corruption caused by Tag:  %s\n",
                    FA_ENTRY_DATA(PCHAR, Entry));
        }
        else
        {
            PCHAR DriverName = NULL;
            PCHAR SymName = NULL;

            if (Entry = Get(DEBUG_FLR_IMAGE_NAME))
            {
                DriverName = FA_ENTRY_DATA(PCHAR, Entry);
            }
            if (Entry = Get(DEBUG_FLR_SYMBOL_NAME))
            {
                SymName = FA_ENTRY_DATA(PCHAR, Entry);
            }

            if (DriverName || SymName)
            {
                dprintf("Probably caused by : ");
                if (SymName && DriverName)
                {
                    dprintf("%s ( %s )\n", DriverName, SymName);
                }
                else if (SymName)
                {
                    dprintf("%s\n", SymName);
                }
                else
                {
                    dprintf("%s\n", DriverName);
                }
            }
        }
    }

    if (Verbose || !Solution)
    {
        PCHAR FollowupAlias = NULL;
        //
        // Print what the user should do:
        // - Followup person
        // - Solution text if there is one.
        //

        if (Entry = Get(DEBUG_FLR_FOLLOWUP_NAME))
        {
            dprintf("\nFollowup: %s\n", FA_ENTRY_DATA(PCHAR, Entry));
        }
        else
        {
            dprintf(" *** Followup info cannot be found !!! Please contact \"Debugger Team\"\n");
        }
        dprintf("---------\n");


        if (Entry = Get(DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER))
        {
            CHAR Buffer[MAX_PATH];
            ULONG64 Address;

            FaGetSymbol(FA_ENTRY_DATA(PULONG64, Entry)[0], Buffer, &Address, sizeof(Buffer));
            dprintf(" *** Possible invalid call from %p ( %s+0x%1p )\n",
                    FA_ENTRY_DATA(PULONG64, Entry)[0],
                    Buffer,
                    Address);
            FaGetSymbol(FA_ENTRY_DATA(PULONG64, Entry)[1], Buffer, &Address, sizeof(Buffer));
            dprintf(" *** Expected target %p ( %s+0x%1p )\n",
                    FA_ENTRY_DATA(PULONG64, Entry)[1],
                    Buffer,
                    Address);
        }

        dprintf("\n");
    }

    if (Entry = Get(DEBUG_FLR_INTERNAL_RAID_BUG))
    {
        dprintf("Raid bug for this failure: %d\n\n",
                *FA_ENTRY_DATA(PULONG64, Entry));
    }

    if (Solution)
    {
        dprintf("      This problem has a known fix.\n"
                "      Please connect to the following URL for details:\n"
                "      ------------------------------------------------\n"
                "      %s\n\n",
                Solution);
    }
    if (SolInOS)
    {
        dprintf(" This has been fixed in : %s\n", SolInOS);
    }
}


LPSTR
TimeToStr(
    ULONG TimeDateStamp,
    BOOL DateOnly
    )
{
    LPSTR TimeDateStr; // pointer to static cruntime buffer.
    static char datebuffer[100];
    tm * pTime;
    time_t TDStamp = (time_t) (LONG) TimeDateStamp;

    // Handle invalid \ page out timestamps, since ctime blows up on
    // this number

    if ((TimeDateStamp == 0) || (TimeDateStamp == -1))
    {
        return "unknown_date";
    }
    else if (DateOnly)
    {
        pTime = localtime(&TDStamp);

        sprintf(datebuffer, "%d_%d_%d",
                pTime->tm_mon + 1, pTime->tm_mday, pTime->tm_year + 1900);

        return datebuffer;
    }
    else
    {
        // TimeDateStamp is always a 32 bit quantity on the target,
        // and we need to sign extend for 64 bit host since time_t
        // has been extended to 64 bits.


        TDStamp = (time_t) (LONG) TimeDateStamp;
        TimeDateStr = ctime((time_t *)&TDStamp);

        if (TimeDateStr)
        {
            TimeDateStr[strlen(TimeDateStr) - 1] = 0;
        }
        else
        {
            TimeDateStr = "***** Invalid";
        }
        return TimeDateStr;
    }
}


void
DebugFailureAnalysis::GenerateBucketId(void)
{
    ULONG LengthUsed = 0;
    CHAR BucketId[MAX_PATH] = {0};
    PSTR BucketPtr = BucketId;
    PSTR Str;
    FA_ENTRY* Entry;
    FA_ENTRY* NameEntry;
    FA_ENTRY* ModuleEntry;
    ULONG ModuleTimestamp = 0;
    CHAR Command[MAX_PATH] = {0};
    CHAR followup[MAX_PATH];

    //
    // Set the final command string
    //

    if (Entry = Get(DEBUG_FLR_STACK_COMMAND))
    {
        CopyString(Command, FA_ENTRY_DATA(PSTR, Entry), sizeof(Command) - 5);
        strcat(Command, " ; ");
    }

    strcat(Command, "kb");
    SetString(DEBUG_FLR_STACK_COMMAND, Command);


    if (Get(DEBUG_FLR_OLD_OS_VERSION))
    {
        SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "OLD_OS");
    }

    //
    // Don't change the bucket ID for these two things as the debugger code
    // to detect them is not 100% reliable.
    //
    //if (Get(DEBUG_FLR_CPU_OVERCLOCKED))
    //{
    //    SetString(DEBUG_FLR_BUCKET_ID, "CPU_OVERCLOCKED");
    //    return;
    //}
    //

    //
    // If the faulting module exists:
    // Get the module timestamp of the faulting module.
    // Check if it is an old driver.
    //

    ModuleEntry = Get(DEBUG_FLR_MODULE_NAME);

    if (ModuleEntry)
    {
        ULONG Index;
        ULONG64 Base;
        DEBUG_MODULE_PARAMETERS Params;

        g_ExtSymbols->GetModuleByModuleName(FA_ENTRY_DATA(PCHAR, ModuleEntry),
                                            0, &Index, &Base);

        if (Base &&
            g_ExtSymbols->GetModuleParameters(1, &Base, Index, &Params) == S_OK)
        {
            ModuleTimestamp = Params.TimeDateStamp;
        }
    }

    NameEntry = Get(DEBUG_FLR_IMAGE_NAME);

    if (NameEntry)
    {
        if (!strcmp(FA_ENTRY_DATA(PCHAR, NameEntry), "Unknown_Image"))
        {
            NameEntry = NULL;
        }
    }

    if (ModuleTimestamp && NameEntry)
    {
        PCHAR String;
        ULONG LookupTimestamp;


        String = g_pTriager->GetFollowupStr("OldImages",
                                            FA_ENTRY_DATA(PCHAR, NameEntry));
        if (String)
        {
            LookupTimestamp = strtol(String, NULL, 16);

            //
            // If the driver is known to be bad, just use driver name
            //

            if (LookupTimestamp > ModuleTimestamp)
            {
                if (FaGetFollowupInfo(NULL,
                                      FA_ENTRY_DATA(PCHAR, ModuleEntry),
                                      followup,
                                      sizeof(followup)))
                {
                    SetString(DEBUG_FLR_FOLLOWUP_NAME, followup);
                }

                //sprintf(BucketPtr, "OLD_IMAGE_%s_TS_%lX",
                //        FA_ENTRY_DATA(PCHAR, NameEntry),
                //        ModuleTimestamp);
                PrintString(BucketPtr, sizeof(BucketId) - LengthUsed, "OLD_IMAGE_%s",
                            FA_ENTRY_DATA(PCHAR, NameEntry));

                SetString(DEBUG_FLR_BUCKET_ID, BucketId);
                return;
            }
        }
    }


    if (Entry = Get(DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER))
    {
        if (Get(DEBUG_FLR_SINGLE_BIT_ERROR))
        {
            SetString(DEBUG_FLR_BUCKET_ID, "SINGLE_BIT_CPU_CALL_ERROR");
        }
        else if (Get(DEBUG_FLR_TWO_BIT_ERROR))
        {
            SetString(DEBUG_FLR_BUCKET_ID, "TWO_BIT_CPU_CALL_ERROR");
        }
        else
        {
            SetString(DEBUG_FLR_BUCKET_ID, "CPU_CALL_ERROR");
        }

        return;
    }

    if (Entry = Get(DEBUG_FLR_MANUAL_BREAKIN))
    {
        SetString(DEBUG_FLR_BUCKET_ID, "MANUAL_BREAKIN");
        SetString(DEBUG_FLR_FOLLOWUP_NAME, "MachineOwner");
        return;
    }

    if (!PossibleFollowups[FlpSpecific].Owner[0])
    {
        BOOL bPoolTag = FALSE;
        if (Entry = Get(DEBUG_FLR_BUGCHECKING_DRIVER))
        {
            PrintString(BucketPtr, sizeof(BucketId) - LengthUsed,
                        "%s_BUGCHECKING_DRIVER_%s",
                        FA_ENTRY_DATA(PCHAR, Get(DEBUG_FLR_BUGCHECK_STR)),
                        FA_ENTRY_DATA(PCHAR, Entry));
        }
        else if (Entry = Get(DEBUG_FLR_MEMORY_CORRUPTOR))
        {
            PrintString(BucketPtr, sizeof(BucketId) - LengthUsed,
                      "MEMORY_CORRUPTION_%s",
                      FA_ENTRY_DATA(PCHAR, Entry));
        }
        else if (Entry = Get(DEBUG_FLR_POOL_CORRUPTOR))
        {
            PrintString(BucketPtr, sizeof(BucketId) - LengthUsed,
                      "POOL_CORRUPTION_%s",
                      FA_ENTRY_DATA(PCHAR, Entry));
        }
        else if (Entry = Get(DEBUG_FLR_CORRUPTING_POOL_TAG))
        {
            PrintString(BucketPtr, sizeof(BucketId) - LengthUsed,
                      "CORRUPTING_POOLTAG_%s",
                      FA_ENTRY_DATA(PCHAR, Entry));
            bPoolTag = TRUE;
        }

        if (Entry)
        {
            if (bPoolTag &&
                (FaGetPoolTagFollowup(FA_ENTRY_DATA(PCHAR, Entry),
                                      followup,
                                      sizeof(followup)) == S_OK))
            {
                SetString(DEBUG_FLR_FOLLOWUP_NAME, followup);

            } else if (FaGetFollowupInfo(NULL,
                                  FA_ENTRY_DATA(PCHAR, Entry),
                                  followup,
                                  sizeof(followup)))
            {
                SetString(DEBUG_FLR_FOLLOWUP_NAME, followup);
            }

            SetString(DEBUG_FLR_BUCKET_ID, BucketId);
            return;
        }
    }

    //
    // Only check this after as we could still have found a bad driver
    // with a bad stack (like drivers that cause stack corruption ...)
    //

    Str = NULL;
    Entry = NULL;

    while (Entry = NextEntry(Entry))
    {
        switch(Entry->Tag)
        {
        case DEBUG_FLR_WRONG_SYMBOLS:
            Str = "WRONG_SYMBOLS";
            break;
        case DEBUG_FLR_BAD_STACK:
            Str = "BAD_STACK";
            break;
        case DEBUG_FLR_ZEROED_STACK:
            Str = "ZEROED_STACK";
            break;
        case DEBUG_FLR_INVALID_KERNEL_CONTEXT:
            Str = "INVALID_KERNEL_CONTEXT";
            break;
        case DEBUG_FLR_CORRUPT_MODULE_LIST:
            Str = "CORRUPT_MODULELIST";
            break;
            break;
        }

        if (Str)
        {
            if (FaGetFollowupInfo(NULL,
                                  "ProcessingError",
                                  followup,
                                  sizeof(followup)))
            {
                SetString(DEBUG_FLR_FOLLOWUP_NAME, followup);
            }

            SetString(DEBUG_FLR_BUCKET_ID, Str);
            return;
        }
    }


    //
    // Add failure code.
    //
    if (Entry = Get(DEBUG_FLR_BUGCHECK_STR))
    {
        PrintString(BucketPtr, sizeof(BucketId) - LengthUsed, "%s", FA_ENTRY_DATA(PCHAR, Entry));
        LengthUsed += strlen(BucketPtr);
        BucketPtr = BucketId + LengthUsed;
    }
    if (Entry = Get(DEBUG_FLR_BUGCHECK_SPECIFIER))
    {
        PrintString(BucketPtr, sizeof(BucketId) - LengthUsed, "%s", FA_ENTRY_DATA(PCHAR, Entry));
        LengthUsed += strlen(BucketPtr);
        BucketPtr = BucketId + LengthUsed;
    }

    //
    // If it's driver only, but the failure is not in a driver, then show the
    // full name of the failure.  If we could not get the name, or we really
    // have a driver only, show the name of the image.
    //

    if ( (Entry = Get(DEBUG_FLR_SYMBOL_NAME)) &&
         (  !Get(DEBUG_FLR_FOLLOWUP_DRIVER_ONLY) ||
            (BestClassFollowUp < FlpUnknownDrv)))
    {
        //
        // If the faulting IP and the read address are the same, this is
        // an interesting scenario we want to catch.
        //

        if (Get(DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS))
        {
            PrintString(BucketPtr,
                        sizeof(BucketId) - LengthUsed,
                        "_BAD_IP");
            LengthUsed += strlen(BucketPtr);
            BucketPtr = BucketId + LengthUsed;
        }

        PrintString(BucketPtr,
                    sizeof(BucketId) - LengthUsed,
                    "_%s",
                    FA_ENTRY_DATA(PCHAR, Entry));
        LengthUsed += strlen(BucketPtr);
        BucketPtr = BucketId + LengthUsed;
    }
    else if (NameEntry)
    {
        PrintString(BucketPtr,
                    sizeof(BucketId) - LengthUsed,
                    "_IMAGE_%s",
                    FA_ENTRY_DATA(PCHAR, NameEntry));
        LengthUsed += strlen(BucketPtr);
        BucketPtr = BucketId + LengthUsed;

        // Also add timestamp in this case.

        if (ModuleTimestamp)
        {
           PrintString(BucketPtr,
                       sizeof(BucketId) - LengthUsed,
                       "_DATE_%s",
                       TimeToStr(ModuleTimestamp, TRUE));
           LengthUsed += strlen(BucketPtr);
           BucketPtr = BucketId + LengthUsed;
        }
    }

    //
    // Store the bucket ID in the analysis structure
    //

//BucketDone:

    for (PCHAR Scan = &BucketId[0]; *Scan; ++Scan)
    {
        // remove special chars that cause problems for IIS or SQL
        if (*Scan == '<' || *Scan == '>' || *Scan == '|' ||
            *Scan == '`' || *Scan == '\''|| (!isprint(*Scan)) )
        {
            *Scan = '_';
        }
    }

    SetString(DEBUG_FLR_BUCKET_ID, BucketId);
}

void
DebugFailureAnalysis::AnalyzeStack(void)
{
    PDEBUG_OUTPUT_CALLBACKS PrevCB;
    ULONG i;
    BOOL BoostToSpecific = FALSE;
    ULONG64 TrapFrame = 0;
    ULONG64 Thread = 0;
    ULONG64 ImageNameAddr = 0;
    DEBUG_STACK_FRAME Stk[MAX_STACK_FRAMES];
    ULONG Frames = 0;
    ULONG Trap0EFrameLimit = 2;
    ULONG64 OriginalFaultingAddress = 0;
    CHAR Command[50] = {0};
    FA_ENTRY* Entry;
    BOOL BadContext = FALSE;
    ULONG PtrSize = IsPtr64() ? 8 : 4;
    BOOL IsVrfBugcheck = FALSE;

    //
    // If someone provided a best followup already, just return
    //

    if (PossibleFollowups[MaxFlpClass-1].Owner[0])
    {
        return;
    }

    if (g_TargetClass == DEBUG_CLASS_KERNEL)
    {
        // Check if CPU is overclocked
        //if (BcIsCpuOverClocked())
        //{
        //    SetUlong64(DEBUG_FLR_CPU_OVERCLOCKED, -1);
        //
        //    BestClassFollowUp = FlpOSInternalRoutine;
        //    strcpy(PossibleFollowups[FlpOSInternalRoutine].Owner, "MachineOwner");
        //    return;
        //}

        //
        // Check if this bugcheck has any specific followup that independant
        // of the failure stack
        //

        if (Entry = Get(DEBUG_FLR_BUGCHECK_STR))
        {
            PCHAR String;

            String = g_pTriager->GetFollowupStr("bugcheck",
                                                FA_ENTRY_DATA(PCHAR, Entry));
            if (String)
            {
                if (!strncmp(String, "maybe_", 6))
                {
                    BestClassFollowUp = FlpOSRoutine;
                    CopyString(PossibleFollowups[FlpOSRoutine].Owner,
                               String + 6,
                               sizeof(PossibleFollowups[FlpOSRoutine].Owner));
                }
                else if (!strncmp(String, "specific_", 9))
                {
                    BoostToSpecific = TRUE;
                }
                else
                {
                    BestClassFollowUp = FlpSpecific;
                    CopyString(PossibleFollowups[FlpSpecific].Owner,
                               String,
                               sizeof(PossibleFollowups[FlpSpecific].Owner));
                    return;
                }
            }
        }
    }

    //
    // Add trap frame, context info from the current stack
    //
    //      Note(kksharma):We only need one of these to get to
    //                     faulting stack (and only one of them should
    //                     be available otherwise somethings wrong)
    //

    Entry = NULL;
    while (Entry = NextEntry(Entry))
    {
        switch(Entry->Tag)
        {
        case DEBUG_FLR_CONTEXT:
            sprintf(Command, ".cxr %I64lx",
                    *FA_ENTRY_DATA(PULONG64, Entry));
            break;
        case DEBUG_FLR_TRAP_FRAME:
            sprintf(Command, ".trap %I64lx",
                    *FA_ENTRY_DATA(PULONG64, Entry));
            break;
        case DEBUG_FLR_TSS:
            sprintf(Command, ".tss %I64lx",
                    *FA_ENTRY_DATA(PULONG64, Entry));
            break;
        case DEBUG_FLR_FAULTING_THREAD:
            sprintf(Command, ".thread %I64lx",
                    *FA_ENTRY_DATA(PULONG64, Entry));
            break;
        case DEBUG_FLR_EXCEPTION_RECORD:
            if (*FA_ENTRY_DATA(PULONG64, Entry) == -1)
            {
                sprintf(Command, ".ecxr");
            }
            break;

        case DEBUG_FLR_FAULTING_IP:
        case DEBUG_FLR_FAULTING_MODULE:

            //
            // We already have some info from the bugcheck
            // Use that address to start off with.
            // But if we could not use it to set any followup, then continue
            // lookinh for the others.
            //

            if (OriginalFaultingAddress = *FA_ENTRY_DATA(PULONG64, Entry))
            {
                if (!GetTriageInfoFromStack(0, 1, OriginalFaultingAddress,
                                            PossibleFollowups,
                                            &BestClassFollowUp))
                {
                    OriginalFaultingAddress = 0;
                }
            }
            break;

        default:
            break;
        }

        if (Command[0] && OriginalFaultingAddress)
        {
            break;
        }
    }

RepeatGetCommand:

    if (!Command[0])
    {
        //
        // Get the current stack.
        //

        if (S_OK != g_ExtControl->GetStackTrace(0, 0, 0, Stk, MAX_STACK_FRAMES,
                                                &Frames))
        {
            Frames = 0;
        }

        //
        // Make sure this is a valid stack to analyze. Such as for kernel mode
        // try to recognize stack after user breakin and send to machineowner
        //
        if (m_FailureType == DEBUG_FLR_KERNEL &&
            m_FailureCode == 0 && Frames >= 3)
        {
            if (IsManualBreakin(Stk, Frames))
            {
                // set machine owner as followup
                SetUlong(DEBUG_FLR_MANUAL_BREAKIN, TRUE);
                strcpy(PossibleFollowups[MaxFlpClass-1].Owner, "MachineOwner");
                PossibleFollowups[MaxFlpClass-1].InstructionOffset = Stk[0].InstructionOffset;
                return;
            }

        }

        //
        // Get the current stack and check if we can get trap
        // frame/context from it
        //
        ULONG64 ExceptionPointers = 0;

        for (i = 0; i < Frames; ++i)
        {
#if 0
            // Stack walker taskes care of these when walking stack

            if (GetTrapFromStackFrameFPO(&stk[i], &TrapFrame))
            {
                break;
            }
#endif
            //
            // First argument of this function is the assert
            // Second argument of this function is the file name
            // Third argument of this function is the line number
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset, "RtlAssert"))
            {
                ULONG Len;
                CHAR AssertData[MAX_PATH + 1] = {0};

                if (Len = ReadAcsiiString(Stk[i].Params[0],
                                          AssertData,
                                          sizeof(AssertData)))
                {
                    SetString(DEBUG_FLR_ASSERT_DATA,  AssertData);
                }

                if (Len = ReadAcsiiString(Stk[i].Params[1],
                                          AssertData,
                                          sizeof(AssertData)))
                {
                    strncat(AssertData, " at Line ", sizeof(AssertData) - Len);

                    Len = strlen(AssertData);

                    PrintString(AssertData + Len,
                                sizeof(AssertData) - Len - 1,
                                "%I64lx",
                                Stk[i].Params[2]);

                    SetString(DEBUG_FLR_ASSERT_FILE,  AssertData);
                }
            }

            // If Trap 0E is the second or 3rd frame on the stack, we can just
            // switch to that trap frame.
            // Otherwise, we want to leave it as is because the failure is
            // most likely due to the frames between bugcheck and trap0E
            //
            // ebp of KiTrap0E is the trap frame
            //
            if ((i <= Trap0EFrameLimit) &&
                FaIsFunctionAddr(Stk[i].InstructionOffset, "KiTrap0E"))
            {
                TrapFrame = Stk[i].Reserved[2];
                break;
            }

            //
            // take first param - spin lock - and it contains the thread that
            // owns the spin lock.
            // Make sure to zero the bottom bit as it is always set ...
            //
            if ((i == 0) &&
                FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "SpinLockSpinningForTooLong"))
            {
                if (ReadPointer(Stk[0].Params[0], &Thread) &&
                    Thread)
                {
                    Thread &= ~0x1;
                }
                break;
            }

            //
            // First arg of KiMemoryFault is the trap frame
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset, "KiMemoryFault") ||
                FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "Ki386CheckDivideByZeroTrap"))
            {
                TrapFrame = Stk[i].Params[0];
                break;
            }

            //
            // Third arg of KiMemoryFault is the trap frame
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "KiDispatchException"))
            {
                TrapFrame = Stk[i].Params[2];
                break;
            }

            //
            // First argument of this function is EXCEPTION_POINTERS
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "PspUnhandledExceptionInSystemThread"))
            {
                ExceptionPointers = Stk[i].Params[0];
                break;
            }

            //
            // First argument of this function is a BUGCHECK_DATA structure
            // The thread is the second parameter in that data structure
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "WdBugCheckStuckDriver") ||
                FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "WdpBugCheckStuckDriver"))
            {
                ReadPointer(Stk[i].Params[0] + PtrSize, &Thread);
                break;
            }

            //
            // First argument of these functions are EXCEPTION_POINTERS
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "PopExceptionFilter") ||
                FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "RtlUnhandledExceptionFilter2"))
            {
                ExceptionPointers = Stk[i].Params[0];
                break;
            }

            //
            // THIRD argument has the name of Exe
            //          nt!PspCatchCriticalBreak(char* Msg, void* Object,unsigned char* ImageFileName)
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "PspCatchCriticalBreak"))
            {
                ImageNameAddr = Stk[i].Params[2];
                break;
            }

            //
            // VERIFIER : Look for possible verifier failures
            //          verifier!VerifierStopMessage means verifier caused the break
            //
            if (FaIsFunctionAddr(Stk[i].InstructionOffset,
                                 "VerifierStopMessage"))
            {
                IsVrfBugcheck = TRUE;
                break;
            }
        }

        if (ExceptionPointers)
        {
            ULONG64 Exr = 0, Cxr = 0;

            if (!ReadPointer(ExceptionPointers, &Exr) ||
                !ReadPointer(ExceptionPointers + PtrSize, &Cxr))
            {
                // dprintf("Unable to read exception pointers at %p\n",
                //         ExcepPtr);
            }

            if (Exr)
            {
                SetUlong64(DEBUG_FLR_EXCEPTION_RECORD, Exr);
            }
            if (Cxr)
            {
                sprintf(Command, ".cxr %I64lx", Cxr);
                SetUlong64(DEBUG_FLR_CONTEXT, Cxr);
            }
        }

        if (TrapFrame)
        {
            sprintf(Command, ".trap %I64lx", TrapFrame);
            SetUlong64(DEBUG_FLR_TRAP_FRAME, TrapFrame);
        }
        if (Thread)
        {
            sprintf(Command, ".thread %I64lx", Thread);
            SetUlong64(DEBUG_FLR_FAULTING_THREAD, Thread);
        }
        if (ImageNameAddr)
        {
            CHAR Buffer[50]={0}, *pImgExt;
            ULONG cb;

            if (ReadMemory(ImageNameAddr, Buffer, sizeof(Buffer) - 1, &cb) &&
                Buffer[0])
            {
                if (pImgExt = strchr(Buffer, '.'))
                {
                    // we do not want imageextension here
                    *pImgExt = 0;
                }
                SetString(DEBUG_FLR_MODULE_NAME, Buffer);
            }
        }
        if (IsVrfBugcheck)
        {
            ULONG64 AvrfCxr = 0;
            // We hit this when app verifier breaks into kd and usermode
            // analysis isn't called
            if (DoVerifierAnalysis(NULL, this) == S_OK)
            {
                if (GetUlong64(DEBUG_FLR_CONTEXT, &AvrfCxr) != NULL)
                {
                    sprintf(Command, ".cxr %I64lx", AvrfCxr);
                }
            }
        }
    }

    //
    // execute the command and get an updated stack
    //

    if (Command[0])
    {
        g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, Command,
                              DEBUG_EXECUTE_NOT_LOGGED);
        if (g_ExtControl->GetStackTrace(0, 0, 0, Stk, MAX_STACK_FRAMES,
                                        &Frames) != S_OK)
        {
            Frames = 0;
        }
    }

    //
    // Get relevant stack
    //
    // We can get stack with 1 frame because a .trap can bring us to the
    // faulting instruction, and if it's a 3rd party driver with no symbols
    // and image, the stack can be 1 frame - although a very valid one.
    //

    if (Frames)
    {
        ULONG64 Values[3];
        Values[0] = Stk[0].ReturnOffset;
        Values[1] = Stk[0].InstructionOffset;
        Values[2] = Stk[0].StackOffset;
        SetUlong64s(DEBUG_FLR_LAST_CONTROL_TRANSFER, 3, Values);

        // If everything on the stack is user mode in the case of a kernel
        // mode failure, we got some bad context information.
        if (IsFollowupContext(Values[0],Values[1],Values[2]) != FollowYes)
        {
            SetUlong64(DEBUG_FLR_INVALID_KERNEL_CONTEXT, 0);
            BadContext = TRUE;
        }
        else
        {
            GetTriageInfoFromStack(&Stk[0], Frames, 0, PossibleFollowups,
                                   &BestClassFollowUp);
        }
    }

    ULONG64 StackBase = FaGetImplicitStackOffset();

    //
    // If the stack pointer is not aligned, take a note of that.
    //

    if (StackBase & 0x3)
    {
        Set(DEBUG_FLR_UNALIGNED_STACK_POINTER, 0);
    }

    //
    // If we have an image name (possibly directly from the bugcheck
    // information) try to get the followup from that.
    //

    if ((BestClassFollowUp < FlpUnknownDrv) &&
        (Entry = Get(DEBUG_FLR_MODULE_NAME)))
    {
        FaGetFollowupInfo(NULL,
                          FA_ENTRY_DATA(PCHAR, Entry),
                          PossibleFollowups[FlpUnknownDrv].Owner,
                          sizeof(PossibleFollowups[FlpUnknownDrv].Owner));

        if (PossibleFollowups[FlpUnknownDrv].Owner[0])
        {
            BestClassFollowUp = FlpUnknownDrv;
        }
    }

    //
    // If we could not find anything at this point, look further up the stack
    // for a trap frame to catch failures of this kind:
    // nt!RtlpBreakWithStatusInstruction
    // nt!KiBugCheckDebugBreak+0x19
    // nt!KeBugCheck2+0x499
    // nt!KeBugCheckEx+0x19
    // nt!_KiTrap0E+0x224
    //

    if (!Command[0] &&
        (BestClassFollowUp < FlpOSFilterDrv) &&
        (Trap0EFrameLimit != 0xff))
    {
        Trap0EFrameLimit = 0xff;
        goto RepeatGetCommand;
    }

    //
    // Last resort, manually read the stack and look for some symbol
    // to followup on.
    //

    if ((BadContext == FALSE) &&
        ((BestClassFollowUp == FlpIgnore) ||
         ((BestClassFollowUp < FlpOSRoutine) && (Frames <= 2))))
    {
        FindFollowupOnRawStack(StackBase,
                               PossibleFollowups,
                               &BestClassFollowUp);
    }

    //
    // Get something !
    //

    if (BestClassFollowUp < FlpOSRoutine)
    {
        if (!BestClassFollowUp)
        {
            PossibleFollowups[FlpOSInternalRoutine].InstructionOffset =
                GetExpression("@$ip");
        }

        if (!PossibleFollowups[FlpOSInternalRoutine].Owner[0] ||
            !_stricmp(PossibleFollowups[FlpOSInternalRoutine].Owner, "ignore"))
        {
            FaGetFollowupInfo(NULL,
                              "default",
                              PossibleFollowups[FlpOSInternalRoutine].Owner,
                              sizeof(PossibleFollowups[FlpOSInternalRoutine].Owner));

            BestClassFollowUp = FlpOSRoutine;
        }
    }

    //
    // Special handling so a bugcheck EA can always take predence over a pool
    // corruption.
    //

    if (BoostToSpecific)
    {
        for (i = MaxFlpClass-1; i ; i--)
        {
            if (PossibleFollowups[i].Owner[0])
            {
                PossibleFollowups[FlpSpecific] = PossibleFollowups[i];
                break;
            }
        }
    }

    //
    // Get the faulting stack
    //
    g_OutCapCb.Reset();
    g_OutCapCb.Output(0, "\n");

    g_ExtClient->GetOutputCallbacks(&PrevCB);
    g_ExtClient->SetOutputCallbacks(&g_OutCapCb);
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_THIS_CLIENT |
                                   DEBUG_OUTCTL_NOT_LOGGED, Stk, Frames,
                                   DEBUG_STACK_ARGUMENTS |
                                   DEBUG_STACK_FRAME_ADDRESSES |
                                   DEBUG_STACK_SOURCE_LINE);
    g_ExtClient->SetOutputCallbacks(PrevCB);

    if (*g_OutCapCb.GetCapturedText())
    {
        SetString(DEBUG_FLR_STACK_TEXT, g_OutCapCb.GetCapturedText());
    }

    //
    // Reset the current state to normal so !analyze does not have any
    // side-effects
    //

    if (Command[0])
    {
        SetString(DEBUG_FLR_STACK_COMMAND, Command);

        //
        // Clear the set context
        //
        g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, ".cxr 0; .thread",
                              DEBUG_EXECUTE_NOT_LOGGED);
    }
}

VOID
DebugFailureAnalysis::FindFollowupOnRawStack(
    ULONG64 StackBase,
    PFOLLOWUP_DESCS PossibleFollowups,
    FlpClasses *BestClassFollowUp
    )
{

#define NUM_ADDRS 200
    ULONG   i;
    ULONG   PtrSize = IsPtr64() ? 8 : 4;
    BOOL    AddressFound = FALSE;
    BOOL    ZeroedStack = TRUE;
    ULONG64 AddrToLookup;
    FlpClasses RawStkBestFollowup;

    if (*BestClassFollowUp >= FlpUnknownDrv)
    {
        // Any better fron raw stack won't be as accurate as what we have
        return;
    } else if (*BestClassFollowUp == FlpIgnore)
    {
        // We don't want to followup on os internal routine here
        RawStkBestFollowup = FlpOSInternalRoutine;
    } else
    {
        RawStkBestFollowup = *BestClassFollowUp;
    }


    // Align stack to natural pointer size.
    StackBase &= ~((ULONG64)PtrSize - 1);

    for (i = 0; i < NUM_ADDRS; i++)
    {
        if (!ReadPointer(StackBase, &AddrToLookup))
        {
            break;
        }

        StackBase+= PtrSize;

        if (AddrToLookup)
        {
            FOLLOW_ADDRESS Follow;
            ZeroedStack = FALSE;

            Follow = IsPotentialFollowupAddress(AddrToLookup);

            if (Follow == FollowStop)
            {
                break;
            }
            else if (Follow == FollowSkip)
            {
                continue;
            }

            AddressFound = TRUE;

            GetTriageInfoFromStack(0, 1, AddrToLookup,
                                   PossibleFollowups,
                                   &RawStkBestFollowup);

            if (RawStkBestFollowup == FlpUnknownDrv)
            {
                break;
            }
        }
    }

    if (!AddressFound)
    {
        if (ZeroedStack)
        {
            SetUlong64(DEBUG_FLR_ZEROED_STACK, 0);
        }
        else
        {
            SetUlong64(DEBUG_FLR_BAD_STACK, 0);
        }
    }
    if (RawStkBestFollowup > FlpOSInternalRoutine)
    {
        *BestClassFollowUp = RawStkBestFollowup;
    }
}


BOOL
DebugFailureAnalysis::GetTriageInfoFromStack(
    PDEBUG_STACK_FRAME Stack,
    ULONG Frames,
    ULONG64 SingleInstruction,
    PFOLLOWUP_DESCS PossibleFollowups,
    FlpClasses *BestClassFollowUp)
{
    ULONG i;
    EXT_TRIAGE_FOLLOWUP FollowUp = &_EFN_GetTriageFollowupFromSymbol;
    BOOL bStat = FALSE;
    BOOL IgnorePoolCorruptionFlp = FALSE;
    FOLLOW_ADDRESS Follow;

    if (Get(DEBUG_FLR_ANALYZAABLE_POOL_CORRUPTION))
    {
        IgnorePoolCorruptionFlp = TRUE;
    }
    for (i = 0; i < Frames; ++i)
    {
        ULONG64 Disp;
        ULONG64 Instruction;
        CHAR Module[20] = {0};
        CHAR Buffer[MAX_PATH];
        CHAR Owner[100];
        DWORD dwOwner;
        DEBUG_TRIAGE_FOLLOWUP_INFO Info;

        FlpClasses ClassFollowUp = FlpIgnore;
        FlpClasses StoreClassFollowUp = FlpIgnore;

        Instruction = SingleInstruction;
        if (!SingleInstruction)
        {
            Instruction = Stack[i].InstructionOffset;
        }

        //
        // Determine how to process this address.
        //

        Follow = IsPotentialFollowupAddress(Instruction);

        if (Follow == FollowStop)
        {
            break;
        }
        else if (Follow == FollowSkip)
        {
            continue;
        }

        Buffer[0] = 0;

        FaGetSymbol(Instruction, Buffer, &Disp, sizeof(Buffer));

        if (Buffer[0] == 0)
        {
            //
            // Either its a bad stack or someone jumped called to bad IP
            //
            continue;
        }

        //
        // Check if this routine has any special significance for getting
        // faulting module
        //

        PCHAR Routine = strchr(Buffer, '!');
        if (Routine)
        {
            *Routine = 0;
        }

        CopyString(Module, Buffer, sizeof(Module));

        if (Routine)
        {
            *Routine = '!';
            Routine++;

            if (Stack && !strcmp(Routine, "IopCompleteRequest"))
            {
                // First argument is Irp Tail, get the driver from Irp
                ULONG TailOffset = 0;
                ULONG64 Irp;

                GetFieldOffset("nt!_IRP", "Tail", &TailOffset);
                if (TailOffset)
                {
                    FA_ENTRY* Entry = NULL;
                    PCHAR ModuleName = NULL;

                    Irp = Stack[i].Params[0] - TailOffset;

                    SetUlong64(DEBUG_FLR_IRP_ADDRESS, Irp);

                    if (BcGetDriverNameFromIrp(this, Irp, NULL, NULL))
                    {
                        if (Entry = Get(DEBUG_FLR_IMAGE_NAME))
                        {
                            CopyString(Buffer, FA_ENTRY_DATA(PCHAR, Entry), sizeof(Buffer));

                            PCHAR Dot;
                            if (Dot = strchr(Buffer, '.'))
                            {
                                *Dot = 0;
                                CopyString(Module, Buffer, sizeof(Module));
                            }
                        }
                    }
                }
            }
            else if ((i == 0) && Stack &&
                     !strcmp(Routine, "ObpCloseHandleTableEntry"))
            {
                //
                // Check for possible memory corruption
                //      2nd parameter is HANDLE_TABLE_ENTRY
                //
                if (CheckForCorruptionInHTE(Stack[i].Params[1], Owner, sizeof(Owner)))
                {
                    // We have pool corrupting PoolTag in analysis
                    // continue with default analysis for now
                }
            }
        }

        ClassFollowUp = GetFollowupClass(Instruction, Module, Routine);
        if (ClassFollowUp == FlpIgnore)
        {
            continue;
        }

        Info.SizeOfStruct = sizeof(Info);
        Info.OwnerName = &Owner[0];
        Info.OwnerNameSize = sizeof(Owner);

        if (dwOwner = (*FollowUp)(g_ExtClient, Buffer, &Info))
        {
            PCHAR pOwner = Owner;

            if (dwOwner == TRIAGE_FOLLOWUP_IGNORE)
            {
                ClassFollowUp = FlpIgnore;
            }
            else if (!strncmp(Owner, "maybe_", 6))
            {
                pOwner = Owner + 6;
                ClassFollowUp = (FlpClasses) ((ULONG) ClassFollowUp - 1);
            }
            else if (!strncmp(Owner, "last_", 5))
            {
                pOwner = Owner + 5;
                ClassFollowUp = FlpOSInternalRoutine;
            }
            else if (!strncmp(Owner, "specific_", 9))
            {
                pOwner = Owner + 9;
                ClassFollowUp = FlpSpecific;
            }
            else if (!_stricmp(Owner, "pool_corruption"))
            {
                if (IgnorePoolCorruptionFlp)
                {
                    continue;
                }

                //
                // If we have non-kernel followups already on the stack
                // it could be them no correctly handling this stack.
                // If we only have kernel calls, then it must be pool
                // corruption.
                //
                // We later rely on a pool corruption always being marked
                // as a FlpUnknownDrv
                //

                StoreClassFollowUp = FlpUnknownDrv;
                ClassFollowUp = FlpOSFilterDrv;

            }

            if (StoreClassFollowUp == FlpIgnore)
            {
                StoreClassFollowUp = ClassFollowUp;
            }

            //
            // Save this entry if it's better than anything else we have.
            //

            if (ClassFollowUp > *BestClassFollowUp)
            {
                bStat = TRUE;

                *BestClassFollowUp = StoreClassFollowUp;
                CopyString(PossibleFollowups[StoreClassFollowUp].Owner,
                           pOwner,
                           sizeof(PossibleFollowups[StoreClassFollowUp].Owner));
                PossibleFollowups[StoreClassFollowUp].InstructionOffset =
                    Instruction;

                if (StoreClassFollowUp == FlpUnknownDrv)
                {
                    // Best match possible
                    return bStat;
                }
            }
        }
    }

    return bStat;
}

BOOL
DebugFailureAnalysis::AddCorruptModules(void)
{
    //
    // Check if we have an old build.  Anything smaller than OSBuild
    // and not identified specifically by build number in the list is old.
    //

    PCHAR String;
    CHAR BuildString[7];
    ULONG BuildNum = 0;
    BOOL FoundCorruptor = FALSE;
    BOOL PoolCorruption = FALSE;
    ULONG Loaded;
    ULONG Unloaded;
    CHAR Name[MAX_PATH];
    CHAR ImageName[MAX_PATH];
    CHAR CorruptModule[MAX_PATH];
    FA_ENTRY *Entry;
    FA_ENTRY *BugCheckEntry;


    sprintf(BuildString, "%d", g_TargetBuild);

    if (!g_pTriager->GetFollowupStr("OSBuild", BuildString))
    {
        if (String = g_pTriager->GetFollowupStr("OSBuild", "old"))
        {
            BuildNum = strtol(String, NULL, 10);

            if (BuildNum > g_TargetBuild)
            {
                SetUlong64(DEBUG_FLR_OLD_OS_VERSION, g_TargetBuild);
            }
        }
    }

    //
    // If we have a specific solution, return
    // if we can't get a module list, return
    //

    if (PossibleFollowups[FlpSpecific].Owner[0] ||
        (g_ExtSymbols->GetNumberModules(&Loaded, &Unloaded) != S_OK))
    {
        return FALSE;
    }

    //
    // Determine if the failure was likely caused by a pool corruption
    //

    if ((BestClassFollowUp < FlpUnknownDrv) ||
        !_stricmp(PossibleFollowups[FlpUnknownDrv].Owner, "pool_corruption"))
    {
        PoolCorruption = TRUE;
    }

    BugCheckEntry = Get(DEBUG_FLR_BUGCHECK_STR);

    //
    // Loop three types to find the types of corruptors in order.
    // the order must match the order in which we generate the bucket name
    // for these types so the image name ends up correct.
    //

    for (ULONG TypeLoop = 0; TypeLoop < 3; TypeLoop++)
    {
        if ((TypeLoop == 0) && !BugCheckEntry)
        {
            continue;
        }
        if ((TypeLoop == 2) && !PoolCorruption)
        {
            continue;
        }

        for (ULONG Index = 0; Index < Loaded + Unloaded; Index++)
        {
            ULONG64 Base;
            DEBUG_FLR_PARAM_TYPE Type = (DEBUG_FLR_PARAM_TYPE)0;
            PCHAR Scan;
            PCHAR DriverName;
            DEBUG_MODULE_PARAMETERS Params;
            ULONG Start, End = 0;

            if (g_ExtSymbols->GetModuleByIndex(Index, &Base) != S_OK)
            {
                continue;
            }

            if (g_ExtSymbols->GetModuleNames(Index, Base,
                                             ImageName, MAX_PATH, NULL,
                                             Name, MAX_PATH, NULL,
                                             NULL, 0, NULL) != S_OK)
            {
                continue;
            }

            if (g_ExtSymbols->GetModuleParameters(1, &Base, Index,
                                                  &Params) != S_OK)
            {
                continue;
            }

            //
            // Strip the path
            //

            DriverName = ImageName;

            if (Scan = strrchr(DriverName, '\\'))
            {
                DriverName = Scan+1;
            }

            //
            // Look for the module in both the various bad drivers list.
            // poolcorruptor and memorycorruptor lists in triage.ini
            //

            switch (TypeLoop)
            {
            case 0:
                Type = DEBUG_FLR_BUGCHECKING_DRIVER;
                PrintString(CorruptModule, sizeof(CorruptModule), "%s_%s",
                            FA_ENTRY_DATA(PCHAR, BugCheckEntry), DriverName);
                g_pTriager->GetFollowupDate("bugcheckingDriver", CorruptModule,
                                            &Start, &End);
                break;

            case 1:
                Type = DEBUG_FLR_MEMORY_CORRUPTOR;
                g_pTriager->GetFollowupDate("memorycorruptors", DriverName,
                                            &Start, &End);
                break;

            case 2:
                //
                // Only look at kernel mode pool corruptors if the failure
                // is a kernel mode crash (and same for user mode), because
                // a kernel pool corruptor will almost never affect an app
                // (apps don't see data in pool blocks)
                //
                if ((BOOL)(GetFailureType() != DEBUG_FLR_KERNEL) ==
                    (BOOL)((Params.Flags & DEBUG_MODULE_USER_MODE) != 0))
                {
                    Type = DEBUG_FLR_POOL_CORRUPTOR;
                    g_pTriager->GetFollowupDate("poolcorruptors", DriverName,
                                                &Start, &End);
                }

                break;
            }

            //
            // Add it to the list if it's really known to be a bad driver.
            //

            if (End)
            {
                //
                // Check to see if the timestamp is older than a fixed
                // driver. If the module is unloaded and no fix is know,
                // then also mark it as bad
                //

                if ( (Params.TimeDateStamp &&
                      (Params.TimeDateStamp < End) &&
                      (Params.TimeDateStamp >= Start)) ||

                     ((Params.Flags & DEBUG_MODULE_UNLOADED) &&
                      (End == 0xffffffff)) )
                {
                    // Don't store the timestamp on memory corrupting
                    // modules to simplify bucketing annd allow for
                    // name lookup.
                    //
                    //sprintf(CorruptModule, "%s_%08lx",
                    //        DriverName, Params.TimeDateStamp);


                    //
                    // Store the first driver we find as the cause,
                    // bug accumulate the list of known memory corruptors.
                    //

                    if (!FoundCorruptor)
                    {
                        SetString(DEBUG_FLR_MODULE_NAME, Name);
                        SetString(DEBUG_FLR_IMAGE_NAME, DriverName);
                        SetUlong64(DEBUG_FLR_IMAGE_TIMESTAMP,
                                   Params.TimeDateStamp);
                        FoundCorruptor = TRUE;
                    }

                    //
                    // Remove the dot since we check the followup
                    // based on that string.
                    //

                    if (Scan = strrchr(DriverName, '.'))
                    {
                        *Scan = 0;
                    }

                    if (strlen(DriverName) < sizeof(CorruptModule))
                    {
                        CopyString(CorruptModule, DriverName,
                                   sizeof(CorruptModule));
                    }

                    Entry = Add(Type, strlen(CorruptModule) + 1);

                    if (Entry)
                    {
                        CopyString(FA_ENTRY_DATA(PCHAR, Entry),
                                   CorruptModule, Entry->FullSize);
                    }
                }

            }
        }
    }

    return FoundCorruptor;
}


void
DebugFailureAnalysis::SetSymbolNameAndModule()
{
    ULONG64 Address = 0;
    CHAR Buffer[MAX_PATH];
    ULONG64 Disp, Base = 0;
    ULONG Index;
    ULONG i;

    //
    // Store the best followup name in the analysis results
    //

    for (i = MaxFlpClass-1; i ; i--)
    {
        if (PossibleFollowups[i].Owner[0])
        {
            if (PossibleFollowups[i].InstructionOffset)
            {
                Address = PossibleFollowups[i].InstructionOffset;

                SetUlong64(DEBUG_FLR_FOLLOWUP_IP,
                           PossibleFollowups[i].InstructionOffset);

            }

            SetString(DEBUG_FLR_FOLLOWUP_NAME, PossibleFollowups[i].Owner);
            break;
        }
    }

    //
    // Now that we have the followip, get the module names.
    //
    // The address may not be set in the case where we just
    // had a driver name with no real address for it
    //

    if (Address)
    {
        //
        // Try to get the full symbol name.
        // leave space for Displacement
        //

        Buffer[0] = 0;
        if (FaGetSymbol(Address, Buffer, &Disp, sizeof(Buffer) - 20))
        {
            sprintf(Buffer + strlen(Buffer), "+%I64lx", Disp);
            SetString(DEBUG_FLR_SYMBOL_NAME, Buffer);
        }

        //
        // Now get the Mod name
        //

        g_ExtSymbols->GetModuleByOffset(Address, 0, &Index, &Base);

        if (Base)
        {
            CHAR ModBuf[100];
            CHAR ImageBuf[100];
            PCHAR Scan;
            PCHAR ImageName;

            if (g_ExtSymbols->GetModuleNames(Index, Base,
                                             ImageBuf,  sizeof(ImageBuf), NULL,
                                             ModBuf,    sizeof(ModBuf),   NULL,
                                             NULL, 0, NULL) == S_OK)
            {
                //
                // Check for unknown module.
                // If it's not, then we should have something valid.
                //

                if (!strstr(ModBuf, "Unknown"))
                {
                    //
                    // Strip the path - keep the extension
                    //

                    ImageName = ImageBuf;

                    if (Scan = strrchr(ImageName, '\\'))
                    {
                        ImageName = Scan+1;
                    }

                    SetString(DEBUG_FLR_MODULE_NAME, ModBuf);
                    SetString(DEBUG_FLR_IMAGE_NAME, ImageName);


                    DEBUG_MODULE_PARAMETERS Params;
                    ULONG TimeStamp = 0;

                    if (g_ExtSymbols->GetModuleParameters(1, &Base, Index,
                                                          &Params) == S_OK)
                    {
                        TimeStamp = Params.TimeDateStamp;
                    }

                    SetUlong64(DEBUG_FLR_IMAGE_TIMESTAMP, TimeStamp);

                    return;
                }
            }
        }
    }

    //
    // If we make it here there was an error getting module name,
    // so set things to "unknown".
    //

    if (!Get(DEBUG_FLR_MODULE_NAME))
    {
        SetUlong64(DEBUG_FLR_UNKNOWN_MODULE, 1);
        SetString(DEBUG_FLR_MODULE_NAME, "Unknown_Module");
        SetString(DEBUG_FLR_IMAGE_NAME, "Unknown_Image");
        SetUlong64(DEBUG_FLR_IMAGE_TIMESTAMP, 0);
    }
}





HRESULT
DebugFailureAnalysis::CheckModuleSymbols(PSTR ModName, PSTR ShowName)
{
    ULONG ModIndex;
    ULONG64 ModBase;
    DEBUG_MODULE_PARAMETERS ModParams;

    if (S_OK != g_ExtSymbols->GetModuleByModuleName(ModName, 0, &ModIndex,
                                                    &ModBase))
    {
        ExtErr("***** Debugger could not find %s in module list, "
               "dump might be corrupt.\n"
                "***** Followup with Debugger team\n\n",
               ModName);
        SetString(DEBUG_FLR_CORRUPT_MODULE_LIST, ModName);
        return E_FAILURE_CORRUPT_MODULE_LIST;
    }
    else if ((S_OK != g_ExtSymbols->GetModuleParameters(1, &ModBase, 0,
                                                        &ModParams))  ||
             (ModParams.SymbolType == DEBUG_SYMTYPE_NONE) ||
             (ModParams.SymbolType == DEBUG_SYMTYPE_EXPORT))

             // (ModParams.Flags & DEBUG_MODULE_SYM_BAD_CHECKSUM))
    {
        ExtErr("***** %s symbols are WRONG. Please fix symbols to "
               "do analysis.\n\n", ShowName);
        SetUlong64(DEBUG_FLR_WRONG_SYMBOLS, ModBase);
        return E_FAILURE_WRONG_SYMBOLS;
    }

    return S_OK;
}

void
DebugFailureAnalysis::ProcessInformation(void)
{
    //
    // Analysis of abstracted information.
    //
    // Now that raw information has been gathered,
    // perform abstract analysis of the gathered
    // information to produce even higher-level
    // information.  The process iterates until no
    // new information is produced.
    //

    AnalyzeStack();

    while (ProcessInformationPass())
    {
        // Iterate.
    }

    //
    // Only add corrupt modules if we did not find a specific solution.
    //
    // If we do find a memory corruptor, the followup and name will be set
    // from the module name as part of bucketing.

    if (!AddCorruptModules())
    {
        SetSymbolNameAndModule();
    }

    GenerateBucketId();

    DbFindBucketInfo();
}

ULONG64
GetControlTransferTargetX86(ULONG64 StackOffset, PULONG64 ReturnOffset)
{
    ULONG Done;
    UCHAR InstrBuf[8];
    ULONG StackReturn;
    ULONG64 Target;
    ULONG JumpCount;

    //
    // Check that we just performed a call, which implies
    // the first value on the stack is equal to the return address
    // computed during stack walk.
    //

    if (!ReadMemory(StackOffset, &StackReturn, 4, &Done) ||
        (Done != 4) ||
        StackReturn != (ULONG)*ReturnOffset)
    {
        return 0;
    }

    //
    // Check for call rel32 instruction.
    //

    if (!ReadMemory(*ReturnOffset - 5, InstrBuf, 5, &Done) ||
        (Done != 5) ||
        (InstrBuf[0] != 0xe8))
    {
        return 0;
    }

    Target = (LONG64)(LONG)
        ((ULONG)*ReturnOffset + *(ULONG UNALIGNED *)&InstrBuf[1]);
    // Adjust the return offset to point to the start of the instruction.
    (*ReturnOffset) -= 5;

    //
    // We may have called an import thunk or something else which
    // immediately jumps somewhere else, so follow jumps.
    //

    JumpCount = 8;
    for (;;)
    {
        if (!ReadMemory(Target, InstrBuf, 6, &Done) ||
            Done < 5)
        {
            // We expect to be able to read the target memory
            // as that's where we think IP is.  If this fails
            // we need to flag it as a problem.
            return Target;
        }

        if (InstrBuf[0] == 0xe9)
        {
            Target = (LONG64)(LONG)
                ((ULONG)Target + 5 + *(ULONG UNALIGNED *)&InstrBuf[1]);
        }
        else if (InstrBuf[0] == 0xff && InstrBuf[1] == 0x25)
        {
            ULONG64 Ind;

            if (Done < 6)
            {
                // We see a jump but we don't have all the
                // memory.  To avoid spurious errors we just
                // give up.
                return 0;
            }

            Ind = (LONG64)(LONG)*(ULONG UNALIGNED *)&InstrBuf[2];
            if (!ReadMemory(Ind, &Target, 4, &Done) ||
                Done != 4)
            {
                return 0;
            }

            Target = (LONG64)(LONG)Target;
        }
        else
        {
            break;
        }

        if (JumpCount-- == 0)
        {
            // We've been tracing jumps too long, just give up.
            return 0;
        }
    }

    return Target;
}

BOOL
DebugFailureAnalysis::ProcessInformationPass(void)
{
    ULONG Done;
    ULONG64 ExceptionCode;
    ULONG64 Arg1, Arg2;
    ULONG64 Values[2];
    ULONG PtrSize = IsPtr64() ? 8 : 4;
    FA_ENTRY* Entry;

    //
    // Determine if the current fault is due to inability
    // to execute an instruction.  The checks are:
    // 1.  A read access violation at the current IP indicates
    //     the current instruction memory is invalid.
    // 2.  An illegal instruction fault indicates the current
    //     instruction is invalid.
    //

    if (!Get(DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS))
    {
        if (GetUlong64(DEBUG_FLR_EXCEPTION_CODE, &ExceptionCode) &&
            (ExceptionCode == STATUS_ILLEGAL_INSTRUCTION) &&
            GetUlong64(DEBUG_FLR_FAULTING_IP, &Arg1))
        {
               // Invalid instruction.
               SetUlong64(DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS, Arg1);
               return TRUE;
        }

        if ( // ExceptionCode == STATUS_ACCESS_VIOLATION &&
            GetUlong64(DEBUG_FLR_READ_ADDRESS, &Arg1) &&
            GetUlong64(DEBUG_FLR_FAULTING_IP, &Arg2) &&
            Arg1 == Arg2)
        {
            // Invalid instruction.
            SetUlong64(DEBUG_FLR_FAILED_INSTRUCTION_ADDRESS, Arg1);
            return TRUE;
        }
    }

    //
    // If we've determined that the current failure is
    // due to inability to execute an instruction, check
    // and see whether there's a call to the instruction.
    // If the instruction prior at the return address can be analyzed,
    // check for known instruction sequences to see if perhaps
    // the processor incorrectly handled a control transfer.
    //

    if (!Get(DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER) &&
        (Entry = Get(DEBUG_FLR_LAST_CONTROL_TRANSFER)))
    {
        ULONG64 ReturnOffset = FA_ENTRY_DATA(PULONG64, Entry)[0];
        Arg2 = FA_ENTRY_DATA(PULONG64, Entry)[1];
        ULONG64 StackOffset = FA_ENTRY_DATA(PULONG64, Entry)[2];
        ULONG64 Target = 0;

        switch(g_TargetMachine)
        {
        case IMAGE_FILE_MACHINE_I386:
            Target = GetControlTransferTargetX86(StackOffset, &ReturnOffset);
            break;
        }

        if (Target && Target != Arg2)
        {
            char Sym1[MAX_PATH], Sym2[MAX_PATH];
            ULONG64 Disp;

            //
            // If both addresses are within the same function
            // we assume that there has been some execution
            // in the function and therefore this doesn't
            // actually indicate a problem.
            // NOTE - DbgBreakPointWithStatus has an internal label
            // which messes up symbols, so account for that too by
            // checking we are 10 bytes within the function.
            //

            FaGetSymbol(Target, Sym1, &Disp, sizeof(Sym1));
            FaGetSymbol(Arg2, Sym2, &Disp, sizeof(Sym2));

            if ((Arg2 - Target > 10) &&
                (strcmp(Sym1, Sym2) != 0))
            {
                PCHAR String;
                ULONG64 BitDiff;
                ULONG64 BitDiff2;

                Values[0] = ReturnOffset;
                Values[1] = Target;
                SetUlong64s(DEBUG_FLR_POSSIBLE_INVALID_CONTROL_TRANSFER,
                            2, Values);

                //
                // If the difference between the two address is a power of 2,
                // then it's a single bit error.
                // Also, to avoid sign extension issues due to a 1 bit error
                // in the top bit, check if the difference betweent the two is
                // only the sign extensions, and zero out the top 32 bits if
                // it's the case.
                //

                BitDiff = Arg2 ^ Target;

                if ((BitDiff >> 32) == 0xFFFFFFFF)
                {
                    BitDiff &= 0xFFFFFFFF;
                }

                if (!(BitDiff2 = (BitDiff & (BitDiff - 1))))
                {
                    Set(DEBUG_FLR_SINGLE_BIT_ERROR, 1);
                }

                if (!(BitDiff2 & (BitDiff2 - 1)))
                {
                    Set(DEBUG_FLR_TWO_BIT_ERROR, 1);
                }


                if (String = g_pTriager->GetFollowupStr("badcpu", ""))
                {
                    BestClassFollowUp = FlpSpecific;
                    CopyString(PossibleFollowups[FlpSpecific].Owner,
                               String,
                               sizeof(PossibleFollowups[FlpSpecific].Owner));

                    SetString(DEBUG_FLR_MODULE_NAME, "No_Module");
                    SetString(DEBUG_FLR_IMAGE_NAME, "No_Image");
                    SetUlong64(DEBUG_FLR_IMAGE_TIMESTAMP, 0);

                }

                return TRUE;
            }
        }
    }

    //
    // If the process is determine to be of importance to this failure,
    // also expose the process name.
    // This will overwrite the PROCESS_NAME of the default process.
    //

    if (GetUlong64(DEBUG_FLR_PROCESS_OBJECT, &Arg1) &&
        !Get(DEBUG_FLR_PROCESS_NAME))
    {
        ULONG NameOffset;
        CHAR  Name[17];

        if (!GetFieldOffset("nt!_EPROCESS", "ImageFileName", &NameOffset) &&
            NameOffset)
        {
            if (ReadMemory(Arg1 + NameOffset, Name, sizeof(Name), &Done) &&
                (Done == sizeof(Name)))
            {
                Name[16] = 0;
                SetString(DEBUG_FLR_PROCESS_NAME, Name);
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\crdb.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    crdb.h

Abstract:
    header for database communication APIS for crash data

Environment:

    User Mode.

--*/

#include <stdio.h>
#include <wtypes.h>
#include <objbase.h>
#include <tchar.h>

#define INITGUID
#include <initguid.h>    // Newly Required for ADO 1.5.
#include <adoid.h>
#include <adoint.h>
/////////////////////////////////////////////////////////////////////////////

#include <icrsint.h>

#define SOLUTION_TEXT_SIZE 4096
#define OS_VER_SIZE 50

//
// This definition needs to consistent with isapi dll
//
typedef enum _CI_SOURCE {
    CiSrcUser,     // 0 - User sitting at his desk types in (!dbaddcrash)
    CiSrcErClient, // 1 - Live site auto upload (ER CLIENT)
    CiSrcCER,      // 2 - CER
    CiSrcReserved3,// 3 - reserved for later use
    CiSrcReserved4,// 4 - reserved for later use
    CiSrcManual,   // 5 - Live site manual upload (using activex control)
    CiSrcStress,   // 6 - Stress team (Using special service and isapi.dll)
    CiSrcManualFullDump, // 7 - Full dump uploaded to server, for kd its same as 5 - isapi sends it to different message Q
    CiSrcManualPssSr,  // 8 - Dumps with a SR number associated with them, usually uploaded by Pss
    CiSrcMax,
} CI_SOURCE;

//
// This needs to be consistent with SolutionTypes in solutions database
//
typedef enum _CI_SOLUTION_TYPE {
    CiSolUnsolved = 0,    // 0  - Unsolved
    CiSolFixed = 1,       // 1  - Fix
    CiSolWorkaround = 3,  // 3  - Workaround
    CiSolTroubleStg = 4,  // 4  - Troubleshooting
    CiSolReferral = 9,    // 9  - Referral
    CiMakeItUlong = 0xffffffff,
} CI_SOLUTION_TYPE;

typedef enum _CI_OS_SKU {
    CiOsHomeEdition = 0,
    CiOsProfessional,
    CiOsServer,
    CiOsAdvancedServer,
    CiOsWebServer,
    CiOsDataCenter,
    CiOsMaxSKU
} CI_OS_SKU;

typedef struct _CRASH_INSTANCE {

    ULONG dwUnused;
    PSTR Path;
    PSTR OriginalDumpFileName;
    ULONG Build;

    ULONG iBucket;
    PSTR Bucket;
    ULONG BucketSize;

    ULONG iDefaultBucket;
    PSTR DefaultBucket;
    ULONG DefaultBucketSize;

    PSTR Followup;
    PSTR FaultyDriver;

    ULONG FailureType;
    CI_SOURCE SourceId;

    BOOL bSendMail;
    BOOL bResetBucket;
    BOOL bUpdateCustomer;

    ULONG Bug;
    ULONG OverClocked;
    ULONG UpTime;
    ULONG CrashTime;
    ULONG StopCode;

    union {
        struct {
            ULONG CpuId;
            ULONG CpuType:16;
            ULONG NumProc:16;
        };
        ULONG64 uCpu;
    };

    PSTR  MesgGuid;
    PSTR  MqConnectStr;

    BOOL  bSolutionLookedUp;
    CI_SOLUTION_TYPE SolutionType;
    ULONG SolutionId;
    PSTR  Solution;
    ULONG GenericSolId;

    BOOL  bExpendableDump;
    ULONG DumpClass;   // Full / Mini
    CI_OS_SKU Sku;
    ULONG NtTimeStamp;
    ULONG ServicePack;

    PSTR PssSr;

    ULONG OEMId;

    PSTR ArchiveFileName;
} CRASH_INSTANCE, *PCRASH_INSTANCE;

class COutputQueryRecords : public CADORecordBinding
{
public:
    void Output()
    {
        return;
    }
};

//This Class extracts crashInstances

class CCrashInstance : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CCrashInstance)

   //Column CrashId is the 1stt field in the recordset

   ADO_NUMERIC_ENTRY(1, adBigInt, m_CrashId,
         0, 0, m_lCrashIdStatus, TRUE)

   // Path, 3rd entry
   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_Path,
         sizeof(m_sz_Path), m_lPathStatus, TRUE)

   // Build, 4th
   ADO_NUMERIC_ENTRY(3, adInteger, m_iBuild,
         0, 0, m_lBuildSatus, TRUE)

   // Source, 5th
   ADO_VARIABLE_LENGTH_ENTRY2(4, adVarChar, m_sz_Source,
         sizeof(m_sz_Source), m_lSourceStatus, TRUE)

   // CpuId, 6th
   ADO_NUMERIC_ENTRY(5, adBigInt, m_iCpuId,
         0, 0, m_lCpuIdStatus, TRUE)

   // Date, 6th
//   ADO_FIXED_LENGTH_ENTRY(6, adDate, m_Date,
//                          m_lDateStatus, TRUE)

END_ADO_BINDING()

public:

   ULONG64 m_CrashId;
   ULONG m_lCrashIdStatus;

   CHAR   m_sz_Path[256];
   ULONG  m_lPathStatus;

   ULONG  m_iBuild;
   ULONG  m_lBuildSatus;

   CHAR   m_sz_Source[100];
   ULONG  m_lSourceStatus;

   ULONG64 m_iCpuId;
   ULONG  m_lCpuIdStatus;

//   DATE   m_Date;
//   ULONG  m_lDateStatus;

   BOOL InitData( PCRASH_INSTANCE Crash );

   void OutPut();
};

class CBucketMap : public CADORecordBinding
{
BEGIN_ADO_BINDING(CBucketMap)

   //Column CrashId is the 1stt field in the recordset

   ADO_NUMERIC_ENTRY(1, adBigInt, m_CrashId,
         0, 0, m_lCrashIdStatus, TRUE)

   //Column BucketId is the 2ndt field in the recordset

   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_BucketId,
         sizeof(m_sz_BucketId), m_lBucketIdStatus, TRUE)

END_ADO_BINDING()

public:

   ULONG64 m_CrashId;
   ULONG m_lCrashIdStatus;

   CHAR  m_sz_BucketId[100];
   ULONG m_lBucketIdStatus;


   BOOL InitData(ULONG64 CrashId, PCHAR Bucket);
};
//This Class extracts crashInstances

class COverClocked : public COutputQueryRecords
{
BEGIN_ADO_BINDING(COverClocked)

   //Column CrashId is the 1stt field in the recordset

   ADO_NUMERIC_ENTRY(1, adBigInt, m_CrashId,
         0, 0, m_lCrashIdStatus, TRUE)

END_ADO_BINDING()

public:

   ULONG64 m_CrashId;
   ULONG m_lCrashIdStatus;

   BOOL InitData(ULONG64 CrashId);

};

//This Class extracts buckets

class CBuckets : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CBuckets)

   //Column BucketId is the 1st field in the recordset

   ADO_VARIABLE_LENGTH_ENTRY2(1, adVarChar, m_sz_BucketId,
         sizeof(m_sz_BucketId), m_lBucketIdStatus, TRUE)

   // iBucket, 2nd entry
   ADO_NUMERIC_ENTRY(2, adInteger, m_iBucket,
         0, 0, m_liBucketStatus, TRUE)


END_ADO_BINDING()

public:

   CHAR  m_sz_BucketId[100];
   ULONG m_lBucketIdStatus;

   ULONG   m_iBucket;
   ULONG  m_liBucketStatus;

   BOOL InitData(PSTR Bucket);
   void Output() { return;};
};

//This Class extracts sp_CheckCrashExists

class CCheckCrashExists : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CCheckCrashExists)

   // CrashId 1st entry
   ADO_NUMERIC_ENTRY(1, adInteger, m_CrashIdExists,
         0, 0, m_CrashIdStatus, TRUE)


END_ADO_BINDING()

public:

   ULONG   m_CrashIdExists;
   ULONG  m_CrashIdStatus;

   void Output() { return;};
};

//This Class extracts sp_GetIntBucket

class CGetIntBucket : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CGetIntBucket)

   // iBucket, 1st entry
   ADO_NUMERIC_ENTRY(1, adInteger, m_iBucket1,
         0, 0, m_liBucketStatus1, TRUE)

   // iBucket, 2nd entry
   ADO_NUMERIC_ENTRY(2, adInteger, m_iBucket2,
         0, 0, m_liBucketStatus2, TRUE)


END_ADO_BINDING()

public:

   ULONG   m_iBucket1;
   ULONG   m_liBucketStatus1;

   ULONG   m_iBucket2;
   ULONG   m_liBucketStatus2;

   void Output() { return;};
};


//This Class extracts crashbuckets

class CFollowups : public CADORecordBinding
{
BEGIN_ADO_BINDING(CFollowups)

   // iBucket, 1st entry
   ADO_NUMERIC_ENTRY(1, adInteger, m_iBucket,
         0, 0, m_liBucketStatus, TRUE)

   // Followup, 2nd entry
   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_Followup,
         sizeof(m_sz_Followup), m_lFollowupStatus, TRUE)


END_ADO_BINDING()

public:

   ULONG  m_iBucket;
   ULONG  m_liBucketStatus;

   CHAR   m_sz_Followup[50];
   ULONG  m_lFollowupStatus;

   BOOL InitData(ULONG iBucket, PSTR Followup);

   void Output() { return;};
};

//This Class extracts machine info

class CMachineInfo : public CADORecordBinding
{
BEGIN_ADO_BINDING(CMachineInfo)

   // CpuId,
   ADO_NUMERIC_ENTRY(1, adBigInt, m_iCpuId,
         0, 0, m_lCpuIdStatus, TRUE)

   // Followup, 2nd entry
   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_Desc,
         sizeof(m_sz_Desc), m_lDescStatus, TRUE)

END_ADO_BINDING()

public:

   ULONG64 m_iCpuId;
   ULONG  m_lCpuIdStatus;

   CHAR   m_sz_Desc[50];
   ULONG  m_lDescStatus;

   BOOL InitData(ULONG64 CpuId, PSTR Desc);
};

//This Class extracts Solution
/*
    Expected fields queried:
        BucketId  - string
        SolutionText - large string
        OSVersion - string
*/

class CBucketSolution : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CBucketSolution)


   ADO_VARIABLE_LENGTH_ENTRY2(1, adVarChar, m_sz_BucketId,
         sizeof(m_sz_BucketId), m_lBucketIdStatus, TRUE)

    // Solution text is the 2nd entry

   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_SolText,
         sizeof(m_sz_SolText), m_lSolStatus, TRUE)

   // OS Version is the 3rd entry

   ADO_VARIABLE_LENGTH_ENTRY2(3, adVarChar, m_sz_OSVersion,
         sizeof(m_sz_OSVersion), m_lOSVerStatus, TRUE)

END_ADO_BINDING()

public:

   CHAR  m_sz_BucketId[100];
   ULONG m_lBucketIdStatus;

   CHAR   m_sz_SolText[SOLUTION_TEXT_SIZE];
   ULONG  m_lSolStatus;

   CHAR   m_sz_OSVersion[50];
   ULONG  m_lOSVerStatus;

   void Output();
};

//This Class extracts Raid bug
/*
    Expected fields queried:
        BucketId  - string
        RaidBug - bug number
*/

class CBucketRaid : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CBucketRaid)

   //Column BucketId is the 1st field in the recordset

   ADO_VARIABLE_LENGTH_ENTRY2(1, adVarChar, m_sz_BucketId,
         sizeof(m_sz_BucketId), m_lBucketIdStatus, TRUE)

   // RAID bug is the 2nd entry

   ADO_NUMERIC_ENTRY(2, adInteger, m_dw_Raid,
         0, 0, m_lRaidStatus, TRUE)

END_ADO_BINDING()

public:

   CHAR  m_sz_BucketId[100];
   ULONG m_lBucketIdStatus;

   ULONG  m_dw_Raid;
   ULONG  m_lRaidStatus;

   void Output();
};

//This Class extracts CheckSolutionExists

class CCheckSolutionExists : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CCheckSolutionExists)

   // CrashId 1st entry
   ADO_NUMERIC_ENTRY(1, adInteger, m_SolutionExists,
         0, 0, m_SolutionIdStatus, TRUE)


END_ADO_BINDING()

public:

   ULONG   m_SolutionExists;
   ULONG   m_SolutionIdStatus;

   void Output() { return;};
};

// This gets sBugcket and gBucket strings from DB
class CRetriveBucket : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CRetriveBucket)


   ADO_VARIABLE_LENGTH_ENTRY2(1, adVarChar, m_sz_sBucketId,
         sizeof(m_sz_sBucketId), m_lsBucketIdStatus, TRUE)

   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_gBucketId,
         sizeof(m_sz_gBucketId), m_lgBucketIdStatus, TRUE)


END_ADO_BINDING()

public:

   CHAR  m_sz_sBucketId[100];
   ULONG m_lsBucketIdStatus;

   CHAR  m_sz_gBucketId[100];
   ULONG m_lgBucketIdStatus;

   void Output() { return;};
};

// This gets bugid and comment strings from DB
class CBugAndComment : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CBugAndComment)


   ADO_NUMERIC_ENTRY(1, adInteger, m_dw_BugId,
         0, 0, m_lBugIdStatus, TRUE)

   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_CommentBy,
         sizeof(m_sz_CommentBy), m_lCommentByStatus, TRUE)

   ADO_VARIABLE_LENGTH_ENTRY2(3, adVarChar, m_sz_Comments,
         sizeof(m_sz_Comments), m_lCommentStatus, TRUE)


END_ADO_BINDING()

public:

   ULONG m_dw_BugId;
   ULONG m_lBugIdStatus;

   CHAR  m_sz_CommentBy[30];
   ULONG m_lCommentByStatus;

   CHAR  m_sz_Comments[300];
   ULONG m_lCommentStatus;

   void Output() { return;};
};


// This gets solution type and solution strings from DB
class CSolutionDesc : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CSolutionDesc)


   ADO_NUMERIC_ENTRY(1, adInteger, m_dw_SolType,
         0, 0, m_lSolTypeStatus, TRUE)

   ADO_VARIABLE_LENGTH_ENTRY2(2, adVarChar, m_sz_Solution,
         sizeof(m_sz_Solution), m_lSolutionStatus, TRUE)


END_ADO_BINDING()

public:

   ULONG m_dw_SolType;
   ULONG m_lSolTypeStatus;

   CHAR  m_sz_Solution[300];
   ULONG m_lSolutionStatus;

   void Output() { return;};
};

//This Class return value from store proc

class CIntValue : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CIntValue)

   // 1st entry is the int value

   ADO_NUMERIC_ENTRY(1, adInteger, m_dw_Value1,
         0, 0, m_lValue1Status, TRUE)
   // 1st entry is the int value

//   ADO_NUMERIC_ENTRY(2, adInteger, m_dw_Value2,
//         0, 0, m_lValue2Status, TRUE)

END_ADO_BINDING()

public:

   ULONG  m_dw_Value1;
   ULONG  m_lValue1Status;

//   ULONG  m_dw_Value2;
//   ULONG  m_lValue2Status;

   void Output() { return;};
};

//This Class return value from store proc

class CIntValue3 : public COutputQueryRecords
{
BEGIN_ADO_BINDING(CIntValue3)

   // 1st entry is the int value

   ADO_NUMERIC_ENTRY(1, adInteger, m_dw_Value1,
         0, 0, m_lValue1Status, TRUE)
   // 2nd entry is the int value

   ADO_NUMERIC_ENTRY(2, adInteger, m_dw_Value2,
         0, 0, m_lValue2Status, TRUE)

   // 3rd entry is the int value

   ADO_NUMERIC_ENTRY(3, adInteger, m_dw_Value3,
         0, 0, m_lValue3Status, TRUE)

END_ADO_BINDING()

public:

   ULONG  m_dw_Value1;
   ULONG  m_lValue1Status;

   ULONG  m_dw_Value2;
   ULONG  m_lValue2Status;

   ULONG  m_dw_Value3;
   ULONG  m_lValue3Status;

   void Output() { return;};
};



/////////////////////////////////////////////////////////////////////////////
// Conversion macros/inline functions - Variant

#define VTOLONG(v)      ((v).vt==VT_I4 ? (LONG)(v).lVal:0L)
#define VTODATE(v)      ((v).vt==VT_DATE ? (CTime)(v).iVal:0L)

#define MAX_QUERY 2000

class CVar : public VARIANT
        {
public:
        CVar();
        CVar(VARTYPE vt, SCODE scode = 0);
        CVar(VARIANT var);
        ~CVar();

        // ASSIGNMENT OPS.
        CVar & operator=(PCWSTR pcwstr);
        CVar & operator=(VARIANT var);

        // CAST OPS.
        // doesn't change type. only returns BSTR if variant is of type
        // bstr. asserts otherwise.
        operator BSTR() const;

        HRESULT Clear();
};

typedef struct _CRDB_ADOBSTR {
    ULONG dwLength;
    WCHAR bstrData[1];
} CRDB_ADOBSTR, *PCRDB_ADOBSTR;

typedef  void (WINAPI *OUTPUT_ROUTINE) ( void);

class DatabaseHandler
{
public:
    DatabaseHandler();
    ~DatabaseHandler();

    BOOL ConnectToDataBase(LPSTR szConnectStr);

    HRESULT GetRecords(PULONG pCount, BOOL EnumerateAll);

    HRESULT EnumerateAllRows();


    BOOL IsConnected() { return m_fConnected; };

    ADORecordset* m_piCrRecordSet;
    ADOCommand*   m_piCrCommandObj;
    BOOL          m_fConnected;
    BOOL          m_fRecordsetEmpty;
    COutputQueryRecords *m_pADOResult;
    BOOL          m_fPrintIt;
    PSTR          m_szDbName;

protected:
    ADOConnection*              m_piConnection;
    WCHAR         m_wszQueryCommand[MAX_QUERY];

};

class CrashDatabaseHandler : public DatabaseHandler
{
public:
    CrashDatabaseHandler();
    ~CrashDatabaseHandler();

    BOOL ConnectToDataBase()
    {
        return DatabaseHandler::ConnectToDataBase("crashdb");
    }

    HRESULT BuildQueryForCrashInstance(PCRASH_INSTANCE Crash);

    HRESULT AddCrashToDBByStoreProc(PCRASH_INSTANCE Crash);

    HRESULT UpdateBucketCount(PCRASH_INSTANCE Crash);

    HRESULT AddCrashBucketMap(ULONG64 CraashId,
                              PCHAR Bucket,
                              BOOL OverWrite);

    HRESULT AddBucketFollowup(PCRASH_INSTANCE Crash, BOOL bOverWrite);

    HRESULT AddMachineIndo(PCRASH_INSTANCE Crash, BOOL bOverWrite);

    HRESULT AddOverClockInfo(ULONG64 CrashId);


    HRESULT AddCrashInstance(PCRASH_INSTANCE Crash);

    HRESULT FindRaidBug(PSTR Bucket, PULONG RaidBug);
    HRESULT FindBucketId(PULONG isBucket, PULONG igBucket);

    HRESULT LookupCrashBucket(PSTR SBucket, PULONG iSBucket,
                              PSTR GBucket, PULONG iGBucket);

    BOOL CheckCrashExists(PCRASH_INSTANCE Crash);

    BOOL CheckSRExists(PSTR szSR, PCRASH_INSTANCE Crash);

    HRESULT LinkCrashToSR(PSTR szSR, PCRASH_INSTANCE Crash);

    HRESULT FindSRBuckets(PSTR szSR, PSTR szSBucket, ULONG sBucketSize,
                          PSTR szGBucket, ULONG gBucketSize);

    HRESULT GetBucketComments(PSTR szBucket, PSTR szComments,
                              ULONG SizeofComment, PULONG pBugId);
};


class CustDatabaseHandler : public DatabaseHandler
{
public:
    CustDatabaseHandler();
    ~CustDatabaseHandler();

    BOOL ConnectToDataBase()
    {
        return DatabaseHandler::ConnectToDataBase("custdb");
    }
    HRESULT AddCrashToDB(PCRASH_INSTANCE Crash);

};


class SolutionDatabaseHandler : public DatabaseHandler
{
public:
    SolutionDatabaseHandler();
    ~SolutionDatabaseHandler();

    BOOL ConnectToDataBase()
    {
        return DatabaseHandler::ConnectToDataBase("solndb");
    }

    HRESULT CheckSolutionExists(
        PSTR szSBucket, PSTR szGBucket,
        PULONG pSolnId, PULONG pSolutionType, PULONG pgSolutionId,
        BOOL bForceGSolLookup);

    HRESULT GetSolution(PCRASH_INSTANCE Crash);

    HRESULT GetSolutionFromDB(PSTR szBucket, PSTR szGBucket,LPSTR DriverName,
                              ULONG TimeStamp, ULONG OS, OUT PSTR pszSolution,
                              ULONG SolutionBufferSize, OUT PULONG pSolutionId,
                              OUT PULONG pSolutionType, OUT PULONG pGenericSolutionId);

    HRESULT PrintBucketInfo(PSTR sBucket, PSTR gBucket);
    HRESULT AddKnownFailureToDB(LPSTR Bucket);
    HRESULT GetSolutiontext(PSTR szBucket, PSTR szSolText,
                              ULONG SolTextSize);
};

// Functions from dbconnector.dll

typedef BOOL
(WINAPI* UpdateDbgInfo)(
       WCHAR *ConnectionString,
       WCHAR *SpString
       );

typedef BOOL
(WINAPI* UpdateCustomerDB)(
       WCHAR *ConnectionString,
       WCHAR *SpString
       );

typedef BOOL
(WINAPI* GetBucketIDs)(
       WCHAR *ConnectionString,
       WCHAR *SpString,
       ULONG *SBucket,
       ULONG *GBucket);

typedef BOOL
(WINAPI* CheckCrashExists)(
       WCHAR *ConnectionString,
       WCHAR *SpString,
       BOOL *Exists
       );

class CConnectDb
{
public:
    CConnectDb();
    ~CConnectDb() {
    };
    HRESULT Initialize();

private:
    WCHAR m_CrdbConnectString[MAX_PATH];
    WCHAR m_CustDbConnectString[MAX_PATH];
    WCHAR m_wszQueryBuffer[MAX_QUERY];

    // dll functions
    UpdateCustomerDB m_ProcUpdateCustomerDB;
    UpdateDbgInfo    m_ProcUpdateDbgInfo;
    GetBucketIDs     m_ProcGetBucketIDs;
    CheckCrashExists m_ProcCheckCrashExists;
    HMODULE          m_hDbConnector;
};

extern CrashDatabaseHandler *g_CrDb;
extern CustDatabaseHandler *g_CustDb;
extern SolutionDatabaseHandler *g_SolDb;


HRESULT
InitializeDatabaseHandlers(
    PDEBUG_CONTROL3 DebugControl,
    ULONG Flags
    );

HRESULT
UnInitializeDatabaseHandlers(BOOL bUninitCom);

HRESULT
_EFN_DbAddCrashDirect(
    PCRASH_INSTANCE Crash,
    PDEBUG_CONTROL3 DebugControl
    );

typedef HRESULT (WINAPI * DBADDCRACHDIRECT)(
    PCRASH_INSTANCE Crash,
    PDEBUG_CONTROL3 DebugControl
    );

HRESULT
ExtDllInitDynamicCalls(
    PDEBUG_CONTROL3 DebugControl
    );

HRESULT
AddCrashToDB(
    ULONG Flag,
    PCRASH_INSTANCE pCrash
    );

#ifndef dprintf
#define dprintf printf
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\makefile.inc ===
$O\bugchkex.cpp : gnbugcds.pl $(BASE_INC_PATH)\bugcodes.txt
        perl gnbugcds.pl -o $O\bugchkex.cpp -i $(BASE_INC_PATH)\bugcodes.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\outcap.hpp ===
//----------------------------------------------------------------------------
//
// Output capturing support.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __OUTCAP_HPP__
#define __OUTCAP_HPP__

//
// Output callback implementation which feeds into the
// output capture buffer.
//
class CaptureOutputCallbacks : public IDebugOutputCallbacks
{
public:
    CaptureOutputCallbacks(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );

    void Reset(void)
    {
        m_Insert = m_TextBuffer;
        if (m_Insert)
        {
            *m_Insert = 0;
        }
    }
    PSTR GetCapturedText(void)
    {
        return m_TextBuffer;
    }
    
protected:
    PSTR m_TextBuffer;
    ULONG m_TextBufferSize;
    PSTR m_Insert;
};

extern CaptureOutputCallbacks g_OutCapCb;

HRESULT CaptureCommandOutput(PSTR Command);

#endif // #ifndef __OUTCAP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INITGUID
#include <dbgeng.h>
#include <guiddef.h>
#include <extsfns.h>
#include <lmerr.h>
#define NTDLL_APIS
#include <dllimp.h>
#include "analyze.h"
#include "crdb.h"
#include "bugcheck.h"
#include "uexcep.h"
#include "outcap.hpp"
#include "triager.h"
#include <cmnutil.hpp>

// To get _open to work
#include <crt\io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>


#ifdef __cplusplus
extern "C" {
#endif

DWORD
_EFN_GetTriageFollowupFromSymbol(
    IN PDEBUG_CLIENT Client,
    IN PSTR SymbolName,
    OUT PDEBUG_TRIAGE_FOLLOWUP_INFO OwnerInfo
    );

HRESULT
_EFN_GetFailureAnalysis(
    IN PDEBUG_CLIENT Client,
    IN ULONG Flags,
    OUT PDEBUG_FAILURE_ANALYSIS* Analysis
    );

void
wchr2ansi(
    PWCHAR wstr,
    PCHAR astr
    );

void
ansi2wchr(
    const PCHAR astr,
    PWCHAR wstr
    );

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status;

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED        g_ExtAdvanced;
extern PDEBUG_CLIENT          g_ExtClient;
extern PDEBUG_DATA_SPACES3    g_ExtData;
extern PDEBUG_REGISTERS       g_ExtRegisters;
extern PDEBUG_SYMBOLS2        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;
extern PDEBUG_CONTROL3        g_ExtControl;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

// Error output.
void __cdecl ExtErr(PCSTR Format, ...);

HRESULT
FillTargetDebugInfo(
    PDEBUG_CLIENT Client,
    PTARGET_DEBUG_INFO pTargetInfo
    );

VOID
DecodeErrorForMessage(
    PDEBUG_DECODE_ERROR pDecodeError
    );

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG g_TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetQualifier;
extern ULONG g_TargetBuild;
extern ULONG g_TargetPlatform;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\outcap.cpp ===
//----------------------------------------------------------------------------
//
// Output capturing support.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

CaptureOutputCallbacks g_OutCapCb;
CHAR g_CaptureBuffer[65536];

CaptureOutputCallbacks::CaptureOutputCallbacks(void)
{
    // For now just use a static buffer.
    m_TextBuffer = g_CaptureBuffer;
    m_TextBufferSize = sizeof(g_CaptureBuffer);
    Reset();
}

STDMETHODIMP
CaptureOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CaptureOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
CaptureOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
CaptureOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    if (Text)
    {
        ULONG Len = strlen(Text) + 1;
        ULONG Space = m_TextBufferSize - (ULONG)(m_Insert - m_TextBuffer);

        if (Len > Space)
        {
            Len = Space;
        }
        if (Len > 0)
        {
            Len--;
            memcpy(m_Insert, Text, Len);
            m_Insert += Len;
            *m_Insert = 0;
        }
    }
    
    return S_OK;
}

HRESULT
CaptureCommandOutput(PSTR Command)
{
    HRESULT Status;
    PDEBUG_OUTPUT_CALLBACKS PrevCb;
    
    g_OutCapCb.Reset();
    g_ExtClient->GetOutputCallbacks(&PrevCb);
    g_ExtClient->SetOutputCallbacks(&g_OutCapCb);

    Status = g_ExtControl->Execute(DEBUG_OUTCTL_THIS_CLIENT, Command,
                                   DEBUG_EXECUTE_NOT_LOGGED);
    
    g_ExtClient->SetOutputCallbacks(PrevCb);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\ext.cpp ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    ext.cpp

Abstract:

    Generic cross-platform and cross-processor extensions.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <time.h>
#include <lm.h>

#include <strsafe.h>

extern CTriager *g_pTriager;

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   g_TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;
ULONG   g_TargetQualifier;
ULONG   g_TargetBuild;
ULONG   g_TargetPlatform;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED        g_ExtAdvanced;
PDEBUG_CLIENT          g_ExtClient;
PDEBUG_DATA_SPACES3    g_ExtData;
PDEBUG_REGISTERS       g_ExtRegisters;
PDEBUG_SYMBOLS2        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;
// Version 3 Interfaces
PDEBUG_CONTROL3        g_ExtControl;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces3),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects3),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl3),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
    EXT_RELEASE(g_ExtControl);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;

    // Ignore errors as there are no critical routines required.
    InitDynamicCalls(&g_NtDllCallsDesc);

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();

    return S_OK;

}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &g_TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG MajorVer, SrvPack;
                if ((Hr = DebugControl->GetSystemVersion(
                                         &g_TargetPlatform, &MajorVer,
                                         &g_TargetBuild, NULL,
                                         0, NULL,
                                         &SrvPack, NULL,
                                         0, NULL)) == S_OK) {
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &g_TargetQualifier)) == S_OK)
                {
                }

                ULONG EventType, EventProcess, EventThread;
                if (DebugControl->GetLastEventInformation(&EventType, &EventProcess, &EventThread,
                                                          NULL, 0, NULL, NULL, 0, NULL) == S_OK)
                {

                }
                DebugControl->Release();
            }

            if (g_pTriager == NULL)
            {
                g_pTriager = new CTriager();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        g_TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    if (g_pTriager)
    {
        delete g_pTriager;
        g_pTriager = NULL;
    }
    UnInitializeDatabaseHandlers(TRUE);
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        DebugExtensionUninitialize();
        break;

    case DLL_PROCESS_ATTACH:
        break;
    }

    return TRUE;
}

void
wchr2ansi(
    PWCHAR wstr,
    PCHAR astr
    )
{
    do
    {
        *astr++ = (CHAR)*wstr++;
    } while (*wstr);
}

void
ansi2wchr(
    const PCHAR astr,
    PWCHAR wstr
    )
// both could point to same buffer
{
    ULONG i = strlen(astr);
    do
    {
        wstr[i] = astr[i];
    } while (i--);
}

LegacyCommands()
{
    dprintf("\n");
    dprintf("  !cxr !exr, and !trap have been replaced with the new built-in debugger \n");
    dprintf("  commands .cxr, .exr, .trap and .tss.  There is also a new \".thread\" command. \n");
    dprintf("\n");
    dprintf("  These new commands no longer require symbols to work correctly.\n");
    dprintf("\n");
    dprintf("  Another change that comes with these new commands is that they actually\n");
    dprintf("  change the internal state of the debugger engine \"permanently\" (until\n");
    dprintf("  reverted).  Any other debugger or extension command issued after the \n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" command will be executed with the new context.\n");
    dprintf("\n");
    dprintf("  For example, commands such as stack walk (\"k\", \"kb\", \"kv\" ), \"r\" and \"dv\"\n");
    dprintf("  (show local variables) will all work based off the new context that was\n");
    dprintf("  supplied by \".cxr\", \".trap\" or \".thread\".\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" and \".thread\" also apply to WinDBG:\n");
    dprintf("  using \".cxr\" , \".trap\"  and \".thread\" will automatically show you the\n");
    dprintf("  new stack in the WinDBG stack window and allow you to click on a frame and\n");
    dprintf("  see local variables and source code (if source is available).\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" with no parameters will give you back the\n");
    dprintf("  default context that was in effect before the command was executed.\n");
    dprintf("\n");
    dprintf("  For example, to exactly duplicate \n");
    dprintf("\n");
    dprintf("        !cxr <foo>        !trap <foo>\n");
    dprintf("        !kb               !kb\n");
    dprintf("\n");
    dprintf("  you would now use\n");
    dprintf("\n");
    dprintf("        .cxr <foo>        .trap <foo>\n");
    dprintf("        kb                kb\n");
    dprintf("        .cxr              .trap\n");
    dprintf("\n");
    return S_OK;
}

DECLARE_API ( cxr )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( exr )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( trap )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( tss )
{
    dprintf("\n");
    dprintf("  !tss has been replaced with the new built-in debugger command .tss.\n");
    dprintf("\n");
    return S_OK;
}


DECLARE_API ( sel )
{
    dprintf("\n");
    dprintf("  !sel has been replaced with the built-in debugger command dg.\n");
    dprintf("\n");
    return S_OK;
}


DECLARE_API( cpuid )

/*++

Routine Description:

    Print out the version number for all CPUs, if available.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 Val;
    BOOL First = TRUE;
    ULONG Processor;
    ULONG NumProcessors;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL IdAll;
    ULONG Mhz;

    INIT_API();

    if (g_ExtControl->GetNumberProcessors(&NumProcessors) != S_OK)
    {
        NumProcessors = 0;
    }

    if (GetExpressionEx(args, &Val, &args))
    {
        //
        // The user specified a procesor number.
        //

        Processor = (ULONG)Val;
        if (Processor >= NumProcessors)
        {
            dprintf("Invalid processor number specified\n");
        }
        else
        {
            NumProcessors = Processor + 1;
        }
    }
    else
    {
        //
        // Enumerate all the processors
        //

        Processor = 0;
    }

    while (Processor < NumProcessors)
    {
        if (g_ExtData->
            ReadProcessorSystemData(Processor,
                                    DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                    &IdAll, sizeof(IdAll), NULL) != S_OK)
        {
            dprintf("Unable to get information for processor %d\n",
                    Processor);
            Processor++;
            continue;
        }

        if (g_ExtData->
            ReadProcessorSystemData(Processor,
                                    DEBUG_DATA_PROCESSOR_SPEED,
                                    &Mhz, sizeof(Mhz), NULL) != S_OK)
        {
            Mhz = 0;
        }

        switch( g_TargetMachine )
        {
        case IMAGE_FILE_MACHINE_I386:
            if (First)
            {
                dprintf("CP  F/M/S  Manufacturer");
                if (Mhz)
                {
                    dprintf("     MHz");
                }
                dprintf("\n");
            }

            dprintf("%2d %2d,%d,%-2d %-16.16s",
                    Processor,
                    IdAll.X86.Family,
                    IdAll.X86.Model,
                    IdAll.X86.Stepping,
                    IdAll.X86.VendorString);
            if (Mhz)
            {
                dprintf("%4d", Mhz);
            }
            dprintf("\n");

            break;

        case IMAGE_FILE_MACHINE_AMD64:

            if (First)
            {
                dprintf("CP  F/M/S  Manufacturer");
                if (Mhz)
                {
                    dprintf("     MHz");
                }
                dprintf("\n");
            }

            dprintf("%2d %2d,%d,%-2d %-16.16s",
                    Processor,
                    IdAll.Amd64.Family,
                    IdAll.Amd64.Model,
                    IdAll.Amd64.Stepping,
                    IdAll.Amd64.VendorString);
            if (Mhz)
            {
                dprintf("%4d", Mhz);
            }
            dprintf("\n");


            break;

        case IMAGE_FILE_MACHINE_IA64:
            if (First)
            {
                dprintf("CP M/R/F/A Manufacturer");
                if (Mhz)
                {
                    dprintf("     MHz");
                }
                dprintf("\n");
            }

            dprintf("%2d %d,%d,%d,%d %-16.16s",
                    Processor,
                    IdAll.Ia64.Model,
                    IdAll.Ia64.Revision,
                    IdAll.Ia64.Family,
                    IdAll.Ia64.ArchRev,
                    IdAll.Ia64.VendorString);
            if (Mhz)
            {
                dprintf("%4d", Mhz);
            }
            dprintf("\n");

            break;

        default:
            dprintf("Not supported for this target machine: %ld\n",
                    g_TargetMachine);
            Processor = NumProcessors;
            break;
        }

        Processor++;
        First = FALSE;
    }

    EXIT_API();

    return S_OK;
}


HRESULT
PrintTargetString(
    BOOL Unicode,
    PDEBUG_CLIENT Client,
    LPCSTR args
    )
{
    ULONG64 AddrString;
    ULONG64 Displacement;
    STRING32 String;
    UNICODE_STRING UnicodeString;
    ULONG64 AddrBuffer;
    CHAR Symbol[1024];
    LPSTR StringData;
    HRESULT hResult;
    BOOL b;


    AddrString = GetExpression(args);
    if (!AddrString)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol(AddrString, Symbol, &Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(AddrString, &String, sizeof(String), NULL);

    if ( !b )
    {
        return E_FAIL;
    }

    INIT_API();

    if (IsPtr64())
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING64, Buffer),
                             &AddrBuffer);
    }
    else
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING32, Buffer),
                             &AddrBuffer);
    }

    EXIT_API();

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    StringData = (LPSTR) LocalAlloc(LMEM_ZEROINIT,
                                    String.Length + sizeof(UNICODE_NULL));

    if (!StringData)
    {
        return E_FAIL;
    }

    dprintf("String(%d,%d)", String.Length, String.MaximumLength);
    if (Symbol[0])
    {
        dprintf(" %s+%p", Symbol, Displacement);
    }

    b = ReadMemory(AddrBuffer, StringData, String.Length, NULL);

    if ( b )
    {
        if (Unicode)
        {
            ANSI_STRING AnsiString;

            UnicodeString.Buffer = (PWSTR)StringData;
            UnicodeString.Length = String.Length;
            UnicodeString.MaximumLength = String.Length+sizeof(UNICODE_NULL);

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString,TRUE);

            dprintf(" at %p: %s\n", AddrString, AnsiString.Buffer);

            RtlFreeAnsiString(&AnsiString);
        }
        else
        {
            dprintf(" at %p: %s\n", AddrString, StringData);
        }

        LocalFree(StringData);
        return S_OK;
    }
    else
    {
        LocalFree(StringData);
        return E_FAIL;
    }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called to format and dump counted (ansi) string.

Arguments:

    args - Address

Return Value:

    None.

--*/
{
    return PrintTargetString(FALSE, Client, args);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called to format and dump counted (unicode) string.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    return PrintTargetString(TRUE, Client, args);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called to format and dump an object attributes structure.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    ULONG64 AddrObja;
    ULONG64 Displacement;
    ULONG64 AddrString;
    STRING32 String;
    ULONG64 StrAddr = NULL;
    CHAR Symbol[1024];
    LPSTR StringData;
    BOOL b;
    ULONG Attr;
    HRESULT hResult;
    ULONG ObjectNameOffset;
    ULONG AttrOffset;
    ULONG StringOffset;

    if (IsPtr64())
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, Attributes);
        StringOffset = FIELD_OFFSET(STRING64, Buffer);
    }
    else
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, Attributes);
        StringOffset = FIELD_OFFSET(STRING32, Buffer);
    }


    AddrObja = GetExpression(args);
    if (!AddrObja)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(AddrObja, Symbol, &Displacement);

    dprintf("Obja %s+%p at %p:\n", Symbol, Displacement, AddrObja);


    INIT_API();

    hResult = g_ExtData->ReadPointersVirtual(1,
                         AddrObja + ObjectNameOffset,
                         &AddrString);

    if ((hResult == S_OK) && AddrString)
    {
        b = ReadMemory(AddrString, &String, sizeof(String), NULL);

        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + StringOffset,
                             &StrAddr);
    }

    EXIT_API();


    if (!StrAddr)
    {
        dprintf("Could not read address of Object Name\n");
        return E_FAIL;
    }

    StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                   String.Length+sizeof(UNICODE_NULL));

    if (StringData)
    {

        b = ReadMemory(StrAddr, StringData, String.Length, NULL);

        if (b)
        {
            dprintf("\tName is %ws\n", StringData);
        }

        LocalFree(StringData);
    }

    b = ReadMemory(AddrObja + AttrOffset, &Attr, sizeof(Attr), NULL);

    if (!b)
    {
        return E_FAIL;
    }

    if (Attr & OBJ_INHERIT )
    {
        dprintf("\tOBJ_INHERIT\n");
    }
    if (Attr & OBJ_PERMANENT )
    {
        dprintf("\tOBJ_PERMANENT\n");
    }
    if (Attr & OBJ_EXCLUSIVE )
    {
        dprintf("\tOBJ_EXCLUSIVE\n");
    }
    if (Attr & OBJ_CASE_INSENSITIVE )
    {
        dprintf("\tOBJ_CASE_INSENSITIVE\n");
    }
    if (Attr & OBJ_OPENIF )
    {
        dprintf("\tOBJ_OPENIF\n");
    }


    return S_OK;
}


VOID
DecodeErrorForMessage(
    PDEBUG_DECODE_ERROR pDecodeError
    )
{
    PSTR Text;
    PSTR Source;
    BOOL TreatAsStatus = pDecodeError->TreatAsStatus;

    Text = FormatAnyStatus(pDecodeError->Code, NULL,
                           &TreatAsStatus, &Source);
    pDecodeError->TreatAsStatus = TreatAsStatus;
    CopyString(pDecodeError->Source, Source, sizeof(pDecodeError->Source));
    CopyString(pDecodeError->Message, Text, sizeof(pDecodeError->Message));
}

VOID
DecodeError(
    PSTR    Banner,
    ULONG   Code,
    BOOL    TreatAsStatus
    )
{
    DEBUG_DECODE_ERROR Err;

    Err.Code = Code;
    Err.TreatAsStatus = TreatAsStatus;
    DecodeErrorForMessage(&Err);
    if (!TreatAsStatus)
    {
        dprintf("%s: (%s) %#x (%u) - %s\n",
                Banner, Err.Source, Code, Code, Err.Message);
    }
    else
    {
        dprintf("%s: (%s) %#x - %s\n",
                Banner, Err.Source, Code, Err.Message);
    }
}

DECLARE_API( error )
{
    BOOL TreatAsStatus = FALSE ;
    ULONG64 err = 0;

    if (GetExpressionEx( args, &err, &args ))
    {
        TreatAsStatus = (BOOL) GetExpression(args);
    }
    DecodeError( "Error code", (ULONG) err, TreatAsStatus );

    return S_OK;
}


typedef BOOL
(CALLBACK *PENUMERATE_UMODE_THREADS_CALLBACK)(
     ULONG ThreadUserId,
     PVOID UserContext
     );

ULONG GetCurrentThreadUserID(void)
{
    ULONG Id;
    if (!g_ExtSystem) {
        return 0;
    }

    if (g_ExtSystem->GetCurrentThreadId(&Id) != S_OK) {
        return 0;
    }
    return Id;
}

BOOL
EnumerateUModeThreads(
    PENUMERATE_UMODE_THREADS_CALLBACK Callback,
    PVOID UserContext
    )
{
    ULONG CurrentThreadId;
    ULONG ThreadId;

    if (!g_ExtSystem) {
        return FALSE;
    }

    // Remember thread we started with
    if (g_ExtSystem->GetCurrentThreadId(&CurrentThreadId) != S_OK) {
        return FALSE;
    }

    // Loop through all threads
    for (ThreadId=0;;ThreadId++) {

        // set ThreadId as current thread
        if (g_ExtSystem->SetCurrentThreadId(ThreadId) != S_OK) {
            // finished enumerateing threads
            break;
        }

        // call the callback routine
        if (!((*Callback)(ThreadId, UserContext))) {
            // callback failed, break out
            break;
        }

    }

    // Set current thread back to original value
    g_ExtSystem->SetCurrentThreadId(CurrentThreadId);
    return TRUE;
}

BOOL
DumpLastErrorForTeb(
    ULONG64 Address
    )
{

    TEB Teb;

    if (ReadMemory( (ULONG_PTR)Address,
                    &Teb,
                    sizeof(Teb),
                    NULL
                    )
        ) {

        DecodeError( "LastErrorValue", Teb.LastErrorValue, FALSE );

        DecodeError( "LastStatusValue", Teb.LastStatusValue, TRUE );

        return TRUE;
    }


    dprintf("Unable to read TEB at %p\n", Address );

    return FALSE;
}

BOOL
DumpCurrentThreadLastError(
    ULONG CurrThreadID,
    PVOID Context
    )
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION ThreadInformation;
    ULONGLONG Address = 0;

    if (Context) {
        dprintf("Last error for thread %lx:\n", CurrThreadID);
    }
    Address = GetExpression("@$teb");

    if (Address) {
        DumpLastErrorForTeb(Address);
    } else {
        dprintf("Unable to read thread %lx's TEB\n", CurrThreadID );
    }
    if (Context) {
        dprintf("\n");
    }

    return TRUE;
}

DECLARE_API( gle )
{
    INIT_API();

    if (!strcmp(args, "-all")) {
        EnumerateUModeThreads(&DumpCurrentThreadLastError, Client);
    } else {
        DumpCurrentThreadLastError(GetCurrentThreadUserID(), NULL);
    }
    EXIT_API();
    return S_OK;
}


void
DispalyTime(
    ULONG64 Time,
    PCHAR TimeString
    )
{
    if (Time) {
        ULONG seconds = (ULONG) Time;
        ULONG minutes = seconds / 60;
        ULONG hours = minutes / 60;
        ULONG days = hours / 24;

        dprintf("%s %d days %d:%02d:%02d \n",
                TimeString,
                days, hours%24, minutes%60, seconds%60);
    }
}

extern PCHAR gTargetMode[], gAllOsTypes[];
#if 1

DECLARE_API( targetinfo )
{
    TARGET_DEBUG_INFO TargetInfo;
    EXT_TARGET_INFO GetTargetInfo;
    INIT_API();


    if (g_ExtControl->GetExtensionFunction(0, "GetTargetInfo", (FARPROC *)&GetTargetInfo) == S_OK) {
        TargetInfo.SizeOfStruct = sizeof(TargetInfo);
        if ((*GetTargetInfo)(Client, &TargetInfo) != S_OK) {
            dprintf("GetTargetInfo failed\n");
        } else {
            const char * time;

            dprintf("TargetInfo: ");
            dprintf("%s\n", gTargetMode[ TargetInfo.Mode ]);
            if ((time = ctime((time_t *) &TargetInfo.CrashTime)) != NULL) {
                dprintf("Crash Time: %s",       time);
            }
            if (TargetInfo.SysUpTime) {
                DispalyTime(TargetInfo.SysUpTime,
                            "System Uptime:");
            }
            else
            {
                dprintf("System Uptime: not available\n");
            }
            if (TargetInfo.Mode == UserModeTarget) {
                DispalyTime(TargetInfo.AppUpTime, "Process Uptime:");
            }
            if ((time = ctime((time_t *) &TargetInfo.EntryDate)) != NULL) {
                dprintf("Entry Date: %s", time);
            }
            if (TargetInfo.OsInfo.Type) {
                dprintf(gAllOsTypes[TargetInfo.OsInfo.Type]);
                dprintf(" ");
            }
//          dprintf("OS Type %lx, Product %lx, Suite %lx\n",
//                  TargetInfo.OsInfo.Type, TargetInfo.OsInfo.ProductType,
//                  TargetInfo.OsInfo.Suite);
            dprintf("%s, %s ",
                    TargetInfo.OsInfo.OsString,
                    TargetInfo.OsInfo.ServicePackString);
            dprintf("Version %ld.%ld\n",
                    TargetInfo.OsInfo.Version.Major, TargetInfo.OsInfo.Version.Minor);
            dprintf("%d procs, %d current processor, type %lx\n",
                    TargetInfo.Cpu.NumCPUs,
                    TargetInfo.Cpu.CurrentProc,
                    TargetInfo.Cpu.Type);
            for (ULONG i =0; i<TargetInfo.Cpu.NumCPUs; i++) {
                if (TargetInfo.Cpu.Type == IMAGE_FILE_MACHINE_I386) {
                    dprintf("CPU %lx Family %lx Model %lx Stepping %lx Vendor %-12.12s\n",
                            i,
                            TargetInfo.Cpu.ProcInfo[i].X86.Family,
                            TargetInfo.Cpu.ProcInfo[i].X86.Model,
                            TargetInfo.Cpu.ProcInfo[i].X86.Stepping,
                            TargetInfo.Cpu.ProcInfo[i].X86.VendorString);
                } else if (TargetInfo.Cpu.Type == IMAGE_FILE_MACHINE_IA64) {
                    dprintf("CPU %lx Family %lx Model %lx Revision %lx Vendor %-12.12s\n",
                            i,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Family,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Model,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Revision,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.VendorString);
                }
            }
        }
    }

    EXIT_API();
    return S_OK;
}
#endif

DWORD
_EFN_GetTriageFollowupFromSymbol(
    IN PDEBUG_CLIENT Client,
    IN PSTR SymbolName,
    OUT PDEBUG_TRIAGE_FOLLOWUP_INFO OwnerInfo
    )
{
    DWORD ret;
    BOOL Enter = (g_ExtClient != Client);


    if (!Client && Enter)
    {
        return FALSE;
    }
    if (OwnerInfo->SizeOfStruct != sizeof(DEBUG_TRIAGE_FOLLOWUP_INFO))
    {
        return FALSE;
    }

    if (Enter)
    {
        INIT_API()
    }
    if (g_pTriager == NULL)
    {
        g_pTriager = new CTriager();
    }
    if (g_pTriager != NULL)
    {
        ret = g_pTriager->GetFollowup(OwnerInfo->OwnerName,
                                      OwnerInfo->OwnerNameSize,
                                      SymbolName);
    } else
    {
        ret = TRIAGE_FOLLOWUP_FAIL;
    }
    if (Enter)
    {
        EXIT_API();
    }
    return ret;
}


DECLARE_API( owner )
{
    CHAR Input[2000];
    CHAR Owner[200];
    ULONG status = TRIAGE_FOLLOWUP_DEFAULT;
    PDEBUG_FAILURE_ANALYSIS pAnalysis = NULL;
    FA_ENTRY* Entry;

    INIT_API();

    Input[0] = 0;
    if (!sscanf(args, "%s", Input))
    {
        Input[0] = 0;
    }

    //
    // If we have a string, look for that - otherwise, do an analysis and
    // get the followup string from that.
    //

    if (*Input)
    {
        status = g_pTriager->GetFollowup(Owner, sizeof(Owner), Input);
    }
    else
    {
        _EFN_GetFailureAnalysis(Client, 0, &pAnalysis);

        if (pAnalysis)
        {
            Entry = pAnalysis->Get(DEBUG_FLR_FOLLOWUP_NAME);
            CopyString(Owner, FA_ENTRY_DATA(PCHAR, Entry), sizeof(Owner));
            pAnalysis->Release();
            status = TRIAGE_FOLLOWUP_SUCCESS;
        }
    }

    if (status == TRIAGE_FOLLOWUP_FAIL)
    {
        dprintf("Internal error getting followup - contact Debugger team\n");
    }
    else
    {
        dprintf("Followup:  %s\n", Owner);
    }

    EXIT_API();
    return S_OK;
}

void
_EFN_DecodeError(
    PDEBUG_DECODE_ERROR pDecodeError
    )
{
    if (pDecodeError->SizeOfStruct != sizeof(DEBUG_DECODE_ERROR))
    {
        return;
    }
    return DecodeErrorForMessage(pDecodeError);
}

DECLARE_API( elog_str )
{
    HANDLE EventSource = NULL;

    INIT_API();

    if (args)
    {
        while (isspace(*args))
        {
            args++;
        }
    }

    if (!args || !args[0])
    {
        Status = E_INVALIDARG;
        ExtErr("Usage: elog_str string\n");
        goto Exit;
    }

    // Get a handle to the NT application log.
    EventSource = OpenEventLog(NULL, "Application");
    if (!EventSource)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open event log, 0x%08X\n", Status);
        goto Exit;
    }

    if (!ReportEvent(EventSource, EVENTLOG_ERROR_TYPE, 0, 0, NULL,
                     1, 0, &args, NULL))
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to report event, 0x%08X\n", Status);
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (EventSource)
    {
        CloseEventLog(EventSource);
    }
    EXIT_API();
    return Status;
}

HRESULT
AnsiToUnicode(PCSTR StrA, PWSTR* StrW)
{
    ULONG Len;

    // No input is an error.
    if (NULL == StrA)
    {
        return E_INVALIDARG;
    }

    Len = strlen(StrA) + 1;
    *StrW = (PWSTR)malloc(Len * sizeof(WCHAR));
    if (*StrW == NULL)
    {
        ExtErr("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }

    if (0 == MultiByteToWideChar(CP_ACP, 0, StrA, Len, *StrW, Len))
    {
        HRESULT Status = HRESULT_FROM_WIN32(GetLastError());
        free(*StrW);
        ExtErr("Unable to convert string, 0x%08X\n", Status);
        return Status;
    }

    return S_OK;
}

typedef NET_API_STATUS (NET_API_FUNCTION* PFN_NetMessageBufferSend)
(
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname,
    IN  LPCWSTR  fromname,
    IN  LPBYTE   buf,
    IN  DWORD    buflen
);

DECLARE_API( net_send )
{
    PWSTR ArgsW = NULL;
    PWSTR Tokens[4];
    ULONG i;
    HMODULE NetLib = NULL;
    PFN_NetMessageBufferSend Send;
    ULONG Result;
    PWSTR ArgsEnd;

    INIT_API();

    NetLib = LoadLibrary("netapi32.dll");
    if (!NetLib)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Platform does not support net send\n");
        goto Exit;
    }
    Send = (PFN_NetMessageBufferSend)
        GetProcAddress(NetLib, "NetMessageBufferSend");
    if (!Send)
    {
        Status = E_NOTIMPL;
        ExtErr("Platform does not support net send\n");
        goto Exit;
    }

    Status = AnsiToUnicode(args, &ArgsW);
    if (Status != S_OK)
    {
        goto Exit;
    }
    ArgsEnd = ArgsW + wcslen(ArgsW);

    // The message text is the entire remainder of the argument
    // string after parsing the first separate tokens, so
    // only wcstok up to the next-to-last token.
    for (i = 0; i < sizeof(Tokens) / sizeof(Tokens[0]) - 1; i++)
    {
        Tokens[i] = wcstok(i == 0 ? ArgsW : NULL, L" \t");
        if (Tokens[i] == NULL)
        {
            Status = E_INVALIDARG;
            ExtErr("USAGE: net_send <targetserver> <targetuser> "
                   "<fromuser> <msg>\n");
            goto Exit;
        }
    }

    Tokens[i] = Tokens[i - 1] + wcslen(Tokens[i - 1]) + 1;
    while (Tokens[i] < ArgsEnd &&
           (*Tokens[i] == ' ' || *Tokens[i] == '\t'))
    {
        Tokens[i]++;
    }
    if (Tokens[i] >= ArgsEnd)
    {
        Status = E_INVALIDARG;
        ExtErr("USAGE: net_send <execmachine> <targetmachine> "
               "<sender> <msg>\n");
        goto Exit;
    }

    Result = Send(Tokens[0], Tokens[1], Tokens[2], (PBYTE)Tokens[3],
                  (wcslen(Tokens[3]) + 1) * sizeof(WCHAR));
    if (Result != NERR_Success)
    {
        Status = HRESULT_FROM_WIN32(Result);;
        ExtErr("Unable to send message, 0x%08X\n", Status);
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (ArgsW)
    {
        free(ArgsW);
    }
    if (NetLib)
    {
        FreeLibrary(NetLib);
    }
    EXIT_API();
    return Status;
}

// XXX drewb - This function just starts a mail message; the
// UI comes up and the user must finish and send the message.
// Therefore it doesn't have much value over the
// user just deciding to send a message.
#if 0

typedef ULONG (FAR PASCAL *PFN_MapiSendMail)
(
    LHANDLE lhSession,
    ULONG ulUIParam,
    lpMapiMessage lpMessage,
    FLAGS flFlags,
    ULONG ulReserved
);

DECLARE_API( mapi_send )
{
    HMODULE MapiLib = NULL;
    PFN_MapiSendMail Send;
    MapiMessage Mail;

    INIT_API();

    MapiLib = LoadLibrary("mapi.dll");
    if (!MapiLib)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Platform does not support MAPI\n");
        goto Exit;
    }
    Send = (PFN_MapiSendMail)
        GetProcAddress(MapiLib, "MAPISendMail");
    if (!Send)
    {
        Status = E_NOTIMPL;
        ExtErr("Platform does not support MAPI\n");
        goto Exit;
    }

    ZeroMemory(&Mail, sizeof(Mail));

    if (!Send(0,           // use implicit session.
              0,           // ulUIParam; 0 is always valid
              &Mail,       // the message being sent
              MAPI_DIALOG, // allow the user to edit the message
              0            // reserved; must be 0
              ))
    {
        Status = E_FAIL;
        ExtErr("Unable to send mail\n");
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (MapiLib)
    {
        FreeLibrary(MapiLib);
    }
    EXIT_API();
    return Status;
}

#endif

DECLARE_API( imggp )
{
    ULONG64 ImageBase;
    IMAGE_NT_HEADERS64 NtHdr;

    INIT_API();

    ImageBase = GetExpression(args);

    if (g_ExtData->ReadImageNtHeaders(ImageBase, &NtHdr) != S_OK)
    {
        ExtErr("Unable to read image header at %p\n", ImageBase);
        goto Exit;
    }

    if (NtHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        ExtErr("Image is not 64-bit\n");
        goto Exit;
    }
    if (NtHdr.OptionalHeader.NumberOfRvaAndSizes <=
        IMAGE_DIRECTORY_ENTRY_GLOBALPTR)
    {
        ExtErr("Image does not have a GP directory entry\n");
        goto Exit;
    }

    ExtOut("Image at %p has a GP value of %p\n",
           ImageBase, ImageBase +
           NtHdr.OptionalHeader.DataDirectory
           [IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress);

 Exit:
    EXIT_API();
    return S_OK;
}

DECLARE_API( imgreloc )
{
    ULONG64 ImageBase;
    IMAGE_NT_HEADERS64 NtHdr;
    ULONG NumMod;
    ULONG i;
    PDEBUG_MODULE_PARAMETERS Mod = NULL;

    INIT_API();

    ImageBase = GetExpression(args);

    if (g_ExtSymbols->GetNumberModules(&NumMod, &i) != S_OK ||
        !(Mod = (PDEBUG_MODULE_PARAMETERS)malloc(NumMod * sizeof(*Mod))) ||
        g_ExtSymbols->GetModuleParameters(NumMod, NULL, 0, Mod) != S_OK)
    {
        ExtErr("Unable to get module information\n");
        goto Exit;
    }

    for (i = 0; i < NumMod; i++)
    {
        char Name[MAX_PATH];

        if (g_ExtData->ReadImageNtHeaders(Mod[i].Base, &NtHdr) != S_OK)
        {
            ExtErr("Unable to read image header at %p\n", Mod[i].Base);
            continue;
        }

        if (FAILED(g_ExtSymbols->
                   GetModuleNames(DEBUG_ANY_ID, Mod[i].Base,
                                  NULL, 0, NULL,
                                  Name, sizeof(Name), NULL,
                                  NULL, 0, NULL)))
        {
            StringCchCopy(Name, sizeof(Name), "<Error>");
        }

        ExtOut("%p %s - ", Mod[i].Base, Name);

        if (NtHdr.OptionalHeader.ImageBase != Mod[i].Base)
        {
            ExtOut("RELOCATED from %p\n",
                   NtHdr.OptionalHeader.ImageBase);
        }
        else
        {
            ExtOut("at preferred address\n");
        }
    }

 Exit:
    free(Mod);
    EXIT_API();
    return S_OK;
}

VOID
GetNtTimeStamp(
    PULONG TimeStamp
    )
{
    ULONG64 ModBase;
    IMAGE_NT_HEADERS64 NtHdr;
    if (!TimeStamp)
    {
        return;
    }
    if (g_ExtSymbols->GetModuleByModuleName("nt", 0, NULL, &ModBase) != S_OK)
    {
        return;
    }
    NtHdr.FileHeader.TimeDateStamp = 0;
    if (g_ExtData->ReadImageNtHeaders(ModBase, &NtHdr) != S_OK)
    {
        return;
    }

    *TimeStamp = NtHdr.FileHeader.TimeDateStamp;
}

VOID
GetSkuFromProductType(
    ULONG ProductType,
    ULONG Suite,
    PULONG pSku
    )
{
    ULONG Sku = 0;
    if (!pSku)
    {
        return;
    }
    *pSku = 0;

    if (ProductType == VER_NT_WORKSTATION)
    {
        if (Suite & VER_SUITE_PERSONAL)
        {
            Sku = CiOsHomeEdition;
        }
        else
        {
            Sku = CiOsProfessional;
        }
    }
    else
    {
        if (Suite & VER_SUITE_DATACENTER)
        {
            Sku = CiOsDataCenter;
        }
        else if (Suite & VER_SUITE_ENTERPRISE)
        {
            Sku = CiOsAdvancedServer;
        }
        else if (Suite & VER_SUITE_BLADE)
        {
            Sku = CiOsWebServer;
        }
        else
        {
            Sku = CiOsServer;
        }
    }

    *pSku = Sku;
}

HRESULT
InitializeCrashInstance(
    PCRASH_INSTANCE pCrash
    )
{

    return 0;
}

PCHAR
GetLogFileName(
    void
    )
{
    static CHAR szLogFileName[MAX_PATH+50];
    PCHAR ExeDir;

    ExeDir = &szLogFileName[0];

    *ExeDir = 0;
    // Get the directory the debugger executable is in.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH))
    {
        // Error.  Use the current directory.
        StringCchCopy(ExeDir, sizeof(szLogFileName), ".");
    } else
    {
        // Remove the executable name.
        PCHAR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }
    }
    StringCchCat(ExeDir, sizeof(szLogFileName), "\\FailedAddCrash.log");
    return &szLogFileName[0];

}


#define DB_LOOKUP_CRASH 1
#define DB_ADD_CRASH    2
#define DB_RETRIAGE_CRASH 4
#define DB_PRINT_CRASH  8
#define DB_SEND_MAIL  0x10
#define DB_NO_CUSTOMER  0x20

HRESULT
AddCrashToDB(
    ULONG Flag,
    PCRASH_INSTANCE pCrash
    )
{
    HRESULT Hr;
    CrashDatabaseHandler *CrDb;
    PDEBUG_FAILURE_ANALYSIS Analysis;
    CHAR Bucket[100], Followup[50], DefaultBucket[100], Driver[100];
    TARGET_DEBUG_INFO TargetInfo;
    BOOL AddCrash = Flag & DB_ADD_CRASH;
    BOOL LookupCrash = Flag & DB_LOOKUP_CRASH;

    if ((Hr = _EFN_GetFailureAnalysis(g_ExtClient,
                                      0,
                                      &Analysis)) != S_OK)
    {
        return Hr;
    }

    // Construct CRASH_INSTANCE

    Followup[0] = Bucket[0] = Driver[0] = 0;
    Analysis->GetString(DEBUG_FLR_BUCKET_ID,
                        Bucket,
                        sizeof(Bucket));
    Analysis->GetString(DEBUG_FLR_DEFAULT_BUCKET_ID,
                        DefaultBucket,
                        sizeof(DefaultBucket));
    Analysis->GetString(DEBUG_FLR_FOLLOWUP_NAME,
                        Followup,
                        sizeof(Followup));
    Analysis->GetString(DEBUG_FLR_IMAGE_NAME,
                        Driver,
                        sizeof(Driver));
    if (!isprint(Driver[0]))
    {
        Driver[0] = 0;
    }
    if (Analysis->Get(DEBUG_FLR_CPU_OVERCLOCKED))
    {
        pCrash->OverClocked = TRUE;
    }
    else
    {
        pCrash->OverClocked = FALSE;
    }

    pCrash->StopCode = Analysis->GetFailureCode();
    pCrash->FailureType = Analysis->GetFailureType();
    pCrash->SolutionType =  CiSolUnsolved;
    Analysis->GetUlong(DEBUG_FLR_SOLUTION_ID, &pCrash->SolutionId);
    Analysis->GetUlong(DEBUG_FLR_SOLUTION_TYPE, (PULONG) &pCrash->SolutionType);
    Analysis->GetUlong(DEBUG_FLR_DEFAULT_SOLUTION_ID, &pCrash->GenericSolId);
    Analysis->Release();

    if (!Followup[0] || !Bucket[0])
    {
        return E_FAIL;
    }

    pCrash->Build = g_TargetBuild; // make room for service pack
    if (pCrash->Bucket)
    {
        StringCchCopy(pCrash->Bucket, pCrash->BucketSize, Bucket);
    } else
    {
        pCrash->Bucket = Bucket;
        pCrash->BucketSize = sizeof(Bucket);
    }
    if (pCrash->DefaultBucket)
    {
        StringCchCopy(pCrash->DefaultBucket, pCrash->DefaultBucketSize, DefaultBucket);
    } else
    {
        pCrash->DefaultBucket = DefaultBucket;
        pCrash->DefaultBucketSize = sizeof(DefaultBucket);
    }
    pCrash->Followup = Followup;
    pCrash->FaultyDriver = Driver;
    pCrash->DumpClass = g_TargetQualifier;
 //   GetNtTimeStamp(&pCrash->NtTimeStamp);

    //
    // extract the incident ID from the dump name
    // there are 2 types of filenames we could have to support.
    // The old version is id@*.*
    // The new version is id.*
    //

    CHAR FileName[MAX_PATH];
    DWORD ID;

    _splitpath(pCrash->Path, NULL, NULL, FileName, NULL);

    //
    // Extract the name of the original dump file in the cab.
    //

    pCrash->OriginalDumpFileName = NULL;

    if (g_ExtSystem->GetCurrentSystemServerName(FileName, sizeof(FileName),
                                                NULL) == S_OK)
    {
        pCrash->OriginalDumpFileName = strrchr(FileName, '_');

        if (pCrash->OriginalDumpFileName)
        {
            pCrash->OriginalDumpFileName +=1;
        }
    }

    TargetInfo.SizeOfStruct = sizeof(TARGET_DEBUG_INFO);

    if (FillTargetDebugInfo(g_ExtClient, &TargetInfo) == S_OK)
    {
        switch (TargetInfo.Cpu.Type)
        {
        case IMAGE_FILE_MACHINE_I386:
            pCrash->CpuId =
                (TargetInfo.Cpu.ProcInfo[0].X86.Family << 16) |
                (TargetInfo.Cpu.ProcInfo[0].X86.Model << 8) |
                (TargetInfo.Cpu.ProcInfo[0].X86.Stepping);
        break;
        case IMAGE_FILE_MACHINE_IA64:
            pCrash->CpuId =
                (TargetInfo.Cpu.ProcInfo[0].Ia64.Family << 16) |
                (TargetInfo.Cpu.ProcInfo[0].Ia64.Model << 8) |
                (TargetInfo.Cpu.ProcInfo[0].Ia64.Revision);
        break;
        case IMAGE_FILE_MACHINE_AMD64:
            pCrash->CpuId =
                (TargetInfo.Cpu.ProcInfo[0].Amd64.Family << 16) |
                (TargetInfo.Cpu.ProcInfo[0].Amd64.Model << 8) |
                (TargetInfo.Cpu.ProcInfo[0].Amd64.Stepping);
        break;
        }
        pCrash->CpuType = TargetInfo.Cpu.Type;
        pCrash->NumProc = TargetInfo.Cpu.NumCPUs;
        pCrash->UpTime = (ULONG) TargetInfo.SysUpTime;
        pCrash->CrashTime = (ULONG) TargetInfo.CrashTime;

        pCrash->ServicePack =
            (TargetInfo.OsInfo.SrvPackNumber & 0xFFFF0000) ?
            (TargetInfo.OsInfo.SrvPackNumber & 0xFFFF0000) >> 16 :
            ((TargetInfo.OsInfo.SrvPackNumber & 0xFFFF) >> 8) * 1000;

        GetSkuFromProductType(TargetInfo.OsInfo.ProductType,
                              TargetInfo.OsInfo.Suite,
                              (PULONG) &pCrash->Sku);

        if (Flag & DB_PRINT_CRASH)
        {
            dprintf("CRASH DATA FOR DB\n----------------------\n");
            dprintf("CrashId : %ld - %ld\n", pCrash->CrashTime , pCrash->UpTime);
            dprintf("BucketId : %s\n", pCrash->Bucket);
            dprintf("FollowUp : %s\n", pCrash->Followup);
            dprintf("Build : %u\n", pCrash->Build);
            dprintf("CpuId : %ld - %ld\n", pCrash->uCpu >> 32, (ULONG) pCrash->uCpu);
            dprintf("Overclocked : %s\n", pCrash->OverClocked ? "TRUE" : "FALSE");
        }
    }

    if (!(Flag & ~DB_PRINT_CRASH))
    {
        return S_OK;
    }

    pCrash->bSendMail = Flag & DB_SEND_MAIL;
    pCrash->bUpdateCustomer = FALSE; // Disable customer DB

    if (AddCrash && !(Flag & DB_RETRIAGE_CRASH))
    {
        Hr = _EFN_DbAddCrashDirect(pCrash, g_ExtControl);
    }
    else if (Flag & DB_RETRIAGE_CRASH)
    {
        // reset crash bucket mapping
        pCrash->bResetBucket = TRUE;
        pCrash->bUpdateCustomer = !(Flag & DB_NO_CUSTOMER);
        Hr = _EFN_DbAddCrashDirect(pCrash, g_ExtControl);
    }
    else if (LookupCrash)
    {
        CHAR SolText[ SOLUTION_TEXT_SIZE ], OSVer[ OS_VER_SIZE ];
        ULONG Count=0;
        CCrashInstance CrashInstance;

        if ((Hr = InitializeDatabaseHandlers(g_ExtControl, 7)) != S_OK)
        {
            return Hr;
        }

        g_CrDb->BuildQueryForCrashInstance(pCrash);
        g_CrDb->m_pADOResult = &CrashInstance;
        g_CrDb->m_fPrintIt = TRUE;
        g_CrDb->GetRecords(&Count, TRUE);
        if (Count)
        {
            dprintf("This crash has already been added to database\n");
            CrashInstance.OutPut();
        }
        g_CrDb->m_fPrintIt = FALSE;
        if (g_SolDb->GetSolution(pCrash) == S_OK)
        {
            dprintf("Solution found for bucket:\n%s\n", SolText);
        }
    }

    return Hr;
}

DECLARE_API( dbaddcrash )
{
    CHAR Path[MAX_PATH]={0};
    CHAR CrashGUID[50] = {0};
    CHAR MQConnectStr[100] = {0};
    CHAR SrNumber[100] = {0};
    CRASH_INSTANCE Crash = {0};
    CHAR Buffer[50];
    BOOL Retriage = FALSE;
    BOOL Print = FALSE;
    BOOL bParseError = FALSE;
    ULONG Flag = 0;
    HRESULT Hr;
    PCSTR argssave = args;


    INIT_API();

    while (*args)
    {
        if (*args ==  ' ' || *args == '\t')
        {
            ++args;
            continue;
        }
        else if (*args == '-' || *args == '/')
        {
            ++args;
            switch (*args)
            {
            case 'g': // GUID identifying this crash, return bucket along with this
                ++args;
                while (*args == ' ') ++args;
                if (!sscanf(args,"%50s", CrashGUID))
                {
                    CrashGUID[0] = 0;
                }
                args+=strlen(CrashGUID);
                Crash.MesgGuid = CrashGUID;
                break;

            case 'm':
                if (!strncmp(args, "mail", 4))
                {
                    Flag |= DB_SEND_MAIL ;
                    args+=4;
                }
                break;
            case 'n':
                if (!strncmp(args, "nocust", 6))
                {
                    Flag |= DB_NO_CUSTOMER ;
                    args+=6;
                }
                break;
            case 'o':
                Print = TRUE;
                break;
            case 'p':
                ++args;
                while (*args == ' ') ++args;
                if (!sscanf(args,"%240s", Path))
                {
                    Path[0] = 0;
                }
                args+=strlen(Path);
                Crash.Path = Path;
                break;
            case 'r':
                if (!strncmp(args, "retriage", 8))
                {
                    Retriage = TRUE;
                    args+=8;
                }
                break;
            case 's': // queue connection string to send bucketid back
                if (!strncmp(args, "source", 6))
                {
                    ULONG Source;

                    args+=6;
                    while (*args == ' ') ++args;

                    if (isdigit(*args))
                    {
                        Source = atoi(args);
                        if (Source < (ULONG) CiSrcMax)
                        {
                            Crash.SourceId = (CI_SOURCE) Source;
                        }
                        while (isdigit(*args)) ++args;
                    }
                } else if (!strncmp(args, "sr", 2))
                {
                    args+=2;
                    while (*args == ' ') ++args;
                    if (!sscanf(args,"%100s", SrNumber))
                    {
                        SrNumber[0] = 0;
                    }
                    args+= strlen(SrNumber);
                    Crash.PssSr = SrNumber;
                } else
                {
                    ++args;
                    while (*args == ' ') ++args;
                    if (!sscanf(args,"%100s", MQConnectStr))
                    {
                        MQConnectStr[0] = 0;
                    }
                    args+=strlen(MQConnectStr);
                    Crash.MqConnectStr = MQConnectStr;
                }
                break;
            default:
                ++args;
                break;
            }
        }
        else
        {
            dprintf("Error in '%s'\n", args);
            bParseError = TRUE;
            break;
        }
    }

    if (*Path && !bParseError)
    {
        if (Retriage)
        {
            dprintf("Retriag crash\n");
            Hr = AddCrashToDB(DB_RETRIAGE_CRASH | Flag, &Crash);
        }
        else
        {
            Hr = AddCrashToDB(DB_ADD_CRASH | Flag, &Crash);
        }
    }
    else if (Print && !bParseError)
    {
        Hr = AddCrashToDB(DB_PRINT_CRASH, NULL);
    }
    else
    {
        dprintf("Bad argument: %s\n", argssave);
        dprintf("Usage: !dbaddcrash -o -mail -p <dumppath> -retriage\n");
        Hr = E_FAIL;
    }

    if (FAILED (Hr))
    {
        int   g_LogFile;

        g_LogFile = _open(GetLogFileName(), O_APPEND | O_CREAT | O_RDWR,
                              S_IREAD | S_IWRITE);

        if (g_LogFile != -1)
        {
            _write(g_LogFile, Path, strlen(Path));
            _write(g_LogFile, "\n", strlen("\n"));
            _close(g_LogFile);
        }
    }

    EXIT_API();
    return S_OK;

}


DECLARE_API( dblookupcrash )
{
    CHAR Bucket[MAX_PATH]={0};

    INIT_API();
    while (*args)
    {
        if (*args ==  ' ' || *args == '\t')
        {
            ++args;
            continue;
        } else if (*args == '-' || *args == '/')
        {
            ++args;
            switch (*args)
            {
            case 'b':
                ++args;
                while (*args == ' ') ++args;
                if (sscanf(args,"%s", Bucket))
                {
                    args+=strlen(Bucket);
                }
                break;
            }
        }
        ++args;
    }

    AddCrashToDB(DB_LOOKUP_CRASH, NULL);

    EXIT_API();
    return S_OK;

}

DECLARE_API( help )
{
    dprintf("diskspace <DriveLetter>[:] - Displays free disk space for specified volume\n");
    dprintf("analyze [-v]               - Analyzes current exception or bugcheck\n");
    dprintf("cpuid [processor]          - Displays CPU version info for all CPUs\n");
    dprintf("elog_str <message>         - Logs simple message to host event log\n");
    dprintf("error [errorcode]          - Displays Win32 & NTSTATUS error string\n");
    dprintf("exchain                    - Displays exception chain for current thread\n");
    dprintf("gle [-all]                 - Displays last error & status for current thread\n");
    dprintf("imggp <imagebase>          - Displays GP directory entry for 64-bit image\n");
    dprintf("imgreloc <imagebase>       - Relocates modules for an image\n");
    dprintf("obja <address>             - Displays OBJECT_ATTRIBUTES[32|64]\n");
    dprintf("owner [symbol!module]      - Detects owner for current exception or\n");
    dprintf("                             bugcheck from triage.ini\n");
    dprintf("str <address>              - Displays ANSI_STRING or OEM_STRING\n");
    dprintf("ustr <address>             - Displays UNICODE_STRING\n");

    dprintf("\nType \".hh [command]\" for more detailed help\n");

    return S_OK;
}

void
DumpCrtEhX86(ULONG64 RecAddr)
{
    // struct _EH3_EXCEPTION_REGISTRATION *Next;
    // PVOID ExceptionHandler;
    // PSCOPETABLE_ENTRY ScopeTable;
    // DWORD TryLevel;
    ULONG64 Record[4];

    if (g_ExtData->ReadPointersVirtual(4, RecAddr, Record) != S_OK)
    {
        return;
    }

    ULONG64 ScopeBase = Record[2];
    LONG Level = (LONG)Record[3];

    while (Level > -1)
    {
        // int enclosing_level;
        // int (*filter)(PEXCEPTION_RECORD);
        // void (*specific_handler)(void);
        ULONG64 ScopeRec[3];

        if (g_ExtData->ReadPointersVirtual(3, ScopeBase + Level * 12,
                                           ScopeRec) != S_OK)
        {
            return;
        }

        ExtOut("  CRT scope %2d, ", Level);

        char Sym[256];
        ULONG64 Disp;

        if (ScopeRec[1])
        {
            ExtOut("filter: ");
            if (FAILED(g_ExtSymbols->
                       GetNameByOffset(ScopeRec[1], Sym, sizeof(Sym),
                                       NULL, &Disp)) ||
                !Sym[0])
            {
                ExtOut("%p", ScopeRec[1]);
            }
            else
            {
                ExtOut("%s+%I64x (%p)", Sym, Disp, ScopeRec[1]);
            }
            dprintf("\n                ");
        }

        ExtOut("func:   ");
        if (FAILED(g_ExtSymbols->
                   GetNameByOffset(ScopeRec[2], Sym, sizeof(Sym),
                                   NULL, &Disp)) ||
            !Sym[0])
        {
            ExtOut("%p", ScopeRec[2]);
        }
        else
        {
            ExtOut("%s+%I64x (%p)", Sym, Disp, ScopeRec[2]);
        }

        ExtOut("\n");

        Level = (LONG)ScopeRec[0];
    }
}

void
DumpExceptionChainX86(ULONG64 Teb)
{
    // struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    // PVOID StackBase;
    // PVOID StackLimit;
    ULONG64 TibInfo[3];

    if (g_ExtData->ReadPointersVirtual(3, Teb, TibInfo) != S_OK)
    {
        ExtErr("Unable to read TIB\n");
        return;
    }

    ULONG64 RecAddr = TibInfo[0];

    while (RecAddr != (ULONG64)-1)
    {
        ULONG64 Record[2];

        if (RecAddr < TibInfo[2] ||
            RecAddr + 8 > TibInfo[1] ||
            (RecAddr & 3))
        {
            ExtErr("Invalid exception stack at %p\n", RecAddr);
            return;
        }

        if (g_ExtData->ReadPointersVirtual(2, RecAddr, Record) != S_OK)
        {
            ExtErr("Unable to read exception record at %p\n", RecAddr);
            return;
        }

        char Sym[256];
        ULONG64 Disp;

        ExtOut("%p: ", RecAddr);
        if (FAILED(g_ExtSymbols->
                   GetNameByOffset(Record[1], Sym, sizeof(Sym),
                                   NULL, &Disp)) ||
            !Sym[0])
        {
            ExtOut("%p\n", Record[1]);
        }
        else
        {
            ExtOut("%s+%I64x (%p)\n", Sym, Disp, Record[1]);

            // Check and see if this is the CRT exception
            // handling function because in that case we
            // have to go through the CRT tables to
            // find the real exception handler.
            PSTR Scan = strchr(Sym, '!');
            if (Scan)
            {
                while (*++Scan == '_')
                {
                    // Empty.
                }
                if (!strcmp(Scan, "except_handler3"))
                {
                    DumpCrtEhX86(RecAddr);
                }
            }
        }

        RecAddr = Record[0];
    }
}

DECLARE_API( exchain )
{
    INIT_API();

    ULONG64 Teb;

    if (g_ExtSystem->GetCurrentThreadTeb(&Teb) != S_OK)
    {
        ExtErr("Unable to get TEB address\n");
        goto Exit;
    }

    switch(g_TargetMachine)
    {
    case IMAGE_FILE_MACHINE_I386:
        DumpExceptionChainX86(Teb);
        break;
    default:
        ExtErr("exchain is x86 only\n");
        break;
    }

 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\extapis.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    extapis.cpp

Abstract:
    Procedures exported by the dll which can be called by
    other extension dlls and debugger

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 2/1/2001

--*/

#include "precomp.h"
#include <time.h>


PCHAR gTargetMode[] = {
    "No Target",
    "Kernel Mode",
    "User Mode",
};

PCHAR gAllOsTypes[] = {
    "Windows 95",
    "Windows 98",
    "Windows ME",
    "Windows NT 4",
    "Windows 2000",
    "Windows XP",
};

HRESULT
GetProcessorInfo(
    PCPU_INFO pCpuInfo
    )
{
    HRESULT Hr;
    ULONG Processor;
    ULONG i;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL ProcId;

    pCpuInfo->Type = g_TargetMachine;
    if (g_ExtControl->GetNumberProcessors(&pCpuInfo->NumCPUs) != S_OK) {
        pCpuInfo->NumCPUs = 0;
    }

    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if ((Hr = g_ExtClient->QueryInterface(__uuidof(IDebugSystemObjects),
                                          (void **)&DebugSystem)) != S_OK) {
        return Hr;
    }
    DebugSystem->GetCurrentThreadHandle(&hCurrentThread);

    DebugSystem->Release();

    pCpuInfo->CurrentProc = (ULONG) hCurrentThread - 1;

    for (i=0; i<pCpuInfo->NumCPUs; i++) {
        // Get Info for all procs
        if ((Hr = g_ExtData->ReadProcessorSystemData(i,
                                                     DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                                     &pCpuInfo->ProcInfo[i],
                                                     sizeof(pCpuInfo->ProcInfo[i]), NULL)) != S_OK) {
            continue;
        }

    }
    return Hr;
}

void
GetOsType(ULONG PlatForm, PTARGET_DEBUG_INFO pTargetInfo)
{
    if (PlatForm == VER_PLATFORM_WIN32_NT)
    // If its nt target
    {
        if (pTargetInfo->OsInfo.Version.Minor > 2195) {
            pTargetInfo->OsInfo.Type = WIN_NT5_1;
        } else if (pTargetInfo->OsInfo.Version.Minor > 1381) {
            pTargetInfo->OsInfo.Type = WIN_NT5;
        } else {
            pTargetInfo->OsInfo.Type = WIN_NT4;
        }
    } else {
        if (pTargetInfo->OsInfo.Version.Minor > 2222) {
            pTargetInfo->OsInfo.Type = WIN_ME;
        } else if (pTargetInfo->OsInfo.Version.Minor > 950) {
            pTargetInfo->OsInfo.Type = WIN_98;
        } else if (pTargetInfo->OsInfo.Version.Minor > 950) {
            pTargetInfo->OsInfo.Type = WIN_95;
        }
    }
}


HRESULT
FillTargetDebugInfo(
    PDEBUG_CLIENT Client,
    PTARGET_DEBUG_INFO pTargetInfo
    )
{
    HRESULT Hr;
    ULONG Time;
    ULONG PlatForm, Qualifier;
    BOOL fUnInitialized = FALSE;

    if (pTargetInfo->SizeOfStruct != sizeof(TARGET_DEBUG_INFO)) {
        return E_FAIL;
    }

    if (!g_ExtClient)
    {
        fUnInitialized = TRUE;
    }
    ZeroMemory(pTargetInfo, sizeof(TARGET_DEBUG_INFO));
    pTargetInfo->SizeOfStruct = sizeof(TARGET_DEBUG_INFO);

    if (fUnInitialized)
    {
        // Do this to prevent multiple INIT_API calls in same extension call
        INIT_API();
    }

    pTargetInfo->Mode = (TARGET_MODE) g_TargetClass;
    Hr = GetProcessorInfo(&pTargetInfo->Cpu);

    Hr = g_ExtControl->GetCurrentSystemUpTime(&Time);
    if (Hr == S_OK) {
        pTargetInfo->SysUpTime = Time;
    }

    PDEBUG_SYSTEM_OBJECTS2 DebugSystem;
    ULONG64 hCurrentThread;

    if ((Hr = g_ExtClient->QueryInterface(__uuidof(IDebugSystemObjects),
                                          (void **)&DebugSystem)) == S_OK) {
        Hr = DebugSystem->GetCurrentProcessUpTime(&Time);


        DebugSystem->Release();
        if (Hr == S_OK) {
            pTargetInfo->AppUpTime = Time;
        }
    }
    Hr = g_ExtControl->GetCurrentTimeDate(&Time);
    if (Hr == S_OK) {
        pTargetInfo->CrashTime = Time;
    }

    time_t ltime;
    time( &ltime );

    pTargetInfo->EntryDate = (ULONG64) ltime;

    Hr = g_ExtControl->GetSystemVersion(&PlatForm,
                                        &pTargetInfo->OsInfo.Version.Major,
                                        &pTargetInfo->OsInfo.Version.Minor,
                                        &pTargetInfo->OsInfo.ServicePackString[0],
                                        sizeof(pTargetInfo->OsInfo.ServicePackString),
                                        NULL,
                                        &pTargetInfo->OsInfo.SrvPackNumber,
                                        &pTargetInfo->OsInfo.OsString[0],
                                        sizeof(pTargetInfo->OsInfo.OsString),
                                        NULL);
    GetOsType(PlatForm, pTargetInfo);
    pTargetInfo->Source = Debugger;

    Hr = g_ExtData->ReadDebuggerData(DEBUG_DATA_ProductType,
                                     &pTargetInfo->OsInfo.ProductType,
                                     sizeof(pTargetInfo->OsInfo.ProductType),
                                     NULL);
    if (FAILED(Hr))
    {
        pTargetInfo->OsInfo.ProductType = 0;
    }
    Hr = g_ExtData->ReadDebuggerData(DEBUG_DATA_SuiteMask,
                                     &pTargetInfo->OsInfo.Suite,
                                     sizeof(pTargetInfo->OsInfo.Suite),
                                     NULL);
    if (FAILED(Hr))
    {
        pTargetInfo->OsInfo.Suite = 0;
    }

    if (fUnInitialized)
    {
        EXIT_API();
    }
    return Hr;
}

HRESULT WINAPI
_EFN_GetTargetInfo
   (
    PDEBUG_CLIENT  Client,
    PTARGET_DEBUG_INFO pTargetInfo
    )
{
    return FillTargetDebugInfo(Client, pTargetInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\triager.h ===
//----------------------------------------------------------------------------
//
// triage.ini searching code
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __TRIAGER_H__
#define __TRIAGER_H__


typedef struct _TRIAGE_DATA {
    CHAR Module[50];
    CHAR Routine[100];
    CHAR Followup[200];

    CHAR fModulPartial:1; // Allow partial module match
    CHAR fRoutinePartial:1; // Alow partial routine match
} TRIAGE_DATA, *PTRIAGE_DATA;

class CTriager
{
public:
    CTriager();
    ~CTriager();

    DWORD GetFollowup(PSTR FollowupBuffer,
                      ULONG FollowupBufferSize,
                      PSTR SymbolName);

    void PrintTraigeInfo();

    void GetFollowupDate(PSTR Module,
                         PSTR Routine,
                         PULONG Start,
                         PULONG End);

    PSTR GetFollowupStr(PSTR Module,
                        PSTR Routine)
    {
        ULONG Index;

        if ((Index = MatchSymbol(Module, Routine)) < m_EntryCount)
        {
            return m_pTriageData[Index].Followup;
        }
        return NULL;
    }

private:

    ULONG        m_EntryCount;
    PTRIAGE_DATA m_pTriageData;

    ULONG MatchSymbol(PSTR Module, PSTR Routine);

};


extern CTriager *g_pTriager;


#endif // #ifndef __TRIAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\triager.cpp ===
//----------------------------------------------------------------------------
//
// triage.ini searching code
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

CTriager *g_pTriager = NULL;


typedef struct TRIAGE_LIST {
    TRIAGE_DATA TriageData;
    struct TRIAGE_LIST * Next;
} TRIAGE_LIST;

void DeleteList(TRIAGE_LIST* Start)
{
    TRIAGE_LIST * Next = NULL;
    while (Start)
    {
        Next = Start->Next;
        free(Start);
        Start = Next;
    }
}

TRIAGE_LIST* InsertEntry(
    TRIAGE_LIST* Start,
    PTRIAGE_DATA pData
    )
{
    TRIAGE_LIST* NewEntry;

    NewEntry = (TRIAGE_LIST*) malloc(sizeof(TRIAGE_LIST));
    if (!NewEntry)
    {
        DeleteList(Start);
        return NULL;
    }

    NewEntry->TriageData = *pData;

    TRIAGE_LIST *InsertAfter, *InsertBefore;

    InsertAfter = NULL; InsertBefore = Start;

    NewEntry->Next = InsertBefore;
    if (InsertAfter)
    {
        InsertAfter->Next = NewEntry;
    } else
    {
        return NewEntry;
    }
    return Start;
}

#define TRIAGE_FILE_OCA         0
#define TRIAGE_FILE_OSSPECIFIC  1
#define TRIAGE_FILE_DEFAULT     2

PCHAR
GetTriageFileName(
    ULONG TriageType
    )
{
    static CHAR szTriageFileName[MAX_PATH+50];


    PCHAR ExeDir;

    ExeDir = &szTriageFileName[0];

    *ExeDir = 0;
    // Get the directory the debugger executable is in.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH))
    {
        // Error.  Use the current directory.
        strcpy(ExeDir, ".");
    } else
    {
        // Remove the executable name.
        PCHAR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }
    }
    switch (TriageType)
    {
    case TRIAGE_FILE_OSSPECIFIC:
        {
            PSTR OsDir;
            if (g_TargetBuild <= 1381)
            {
                OsDir = "\\nt4fre";
            } else if (g_TargetBuild <= 2195)
            {
                OsDir = "\\w2kfre";
            } else
            {
                OsDir = "\\winxp";
            }
            CatString(ExeDir, OsDir, sizeof(szTriageFileName));
            CatString(ExeDir, "\\triage.ini", sizeof(szTriageFileName));
            break;
        }
    case TRIAGE_FILE_OCA:
        CatString(ExeDir, "\\triage\\oca.ini", sizeof(szTriageFileName));
        break;
    case TRIAGE_FILE_DEFAULT:
        CatString(ExeDir, "\\triage\\triage.ini", sizeof(szTriageFileName));
    }


    return &szTriageFileName[0];

}


int __cdecl
TriageDataCmp(const void* Data1, const void* Data2)
{
    TRIAGE_DATA *Triage1 , *Triage2;
    int ret;

    Triage1 = (TRIAGE_DATA*) Data1;
    Triage2 = (TRIAGE_DATA*) Data2;

    ret=_stricmp(Triage1->Module, Triage2->Module);

    if (!ret)
    {
        ret = _stricmp(Triage1->Routine, Triage2->Routine);
    }

    return ret;
}

CTriager::CTriager()
{
    CHAR FileLine[256];
    PCHAR pTriageFile;
    HANDLE hFile;
    ULONG Err;
    ULONG BytesRead;
    ULONG FileSize;
    PCHAR FileRead;
    PCHAR line;
    ULONG Index;
    ULONG TriageType;
    ULONG EntryCount;
    TRIAGE_DATA Entry;
    TRIAGE_LIST *Start, *Trav;

    Start = NULL;
    EntryCount = 0;
    TriageType = TRIAGE_FILE_OCA;

    //
    // We will always try to load the oca.ini file to get the connection
    // strings.
    // Then we will load the OS specific version of triage.ini when present
    // (it's an internal version of the file only) and load the default
    // triage\triage.ini if the specific one could not be opened.
    //

GatherTriageInfo:
    pTriageFile = GetTriageFileName(TriageType);

    hFile = CreateFile(pTriageFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        FileSize = GetFileSize(hFile, NULL);

        FileRead = (PCHAR) malloc(FileSize+1);

        if (!FileRead)
        {
            CloseHandle(hFile);
            return;
        }

        if (!ReadFile(hFile, FileRead, FileSize, &BytesRead, NULL))
        {
            CloseHandle(hFile);
            free( FileRead );
            return;
        }

        FileRead[FileSize] = 0;
        Index = 0;

        while (Index < FileSize)
        {
            ULONG LineLen = 0;
            line = &FileRead[Index];
            while (*line && (*line != '\n'))
            {
                if (*line != ' ' && *line > 0x20)
                {
                    FileLine[LineLen++] = *line;
                }
                ++line;
                ++Index;
            }
            FileLine[LineLen] = 0;
            ++Index; // skip newline

            if (FileLine[0] == '\0' || FileLine[0] == ';')
            {
                continue;
            }

            PCHAR Followup;
            PCHAR Bang;

            if ((Followup = strchr(FileLine,'=')))
            {
                *Followup++ = 0;

                Entry.fModulPartial = 1;
                Entry.fRoutinePartial = 1;
                if (Bang = strchr(FileLine, '!'))
                {
                    // An entry of type module[*]!routine[*]=followup
                    //                            ^          ^
                    //                           Bang       Followup

                    *Bang++ = 0;

                    ULONG eq = (ULONG) ((ULONG64)Followup - (ULONG64)Bang);
                    ULONG modbreak = (ULONG) ((ULONG64)Bang - (ULONG64)&FileLine[0]);

                    Entry.fModulPartial = 0;
                    FillStringBuffer(FileLine, 0, Entry.Module, sizeof(Entry.Module), NULL);
                    if (*(Bang-2) == '*')
                    {
                        Entry.fModulPartial = 1;
                        Entry.Module[modbreak-2] = 0;
                    }

                    modbreak++;

                    Entry.fRoutinePartial = 0;
                    FillStringBuffer(Bang, 0, Entry.Routine, sizeof(Entry.Routine), NULL);
                    if (*(Followup-2)=='*')
                    {
                        Entry.Routine[eq-2] = 0;
                        Entry.fRoutinePartial = 1;
                    }
                }
                else
                {
                    ULONG eq = (ULONG) ((ULONG64)Followup - (ULONG64)&FileLine[0]);
                    Entry.Routine[0] = 0;
                    Entry.fModulPartial = FALSE;
                    FillStringBuffer(FileLine, 0, Entry.Module, sizeof(Entry.Module), NULL);
                    if (*(Followup-2)=='*')
                    {
                        Entry.fModulPartial = TRUE;
                        Entry.Module[eq-2] = 0;
                    }
                    if (!_stricmp(Entry.Routine, "default"))
                    {
                        Entry.Routine[0] = 0;
                    }
                }

                CopyString(Entry.Followup , Followup, sizeof(Entry.Followup));

                    // dprintf("%s\n Mod %s Rou %s\n", FileLine, Entry.Module, Entry.Routine);
                Start = InsertEntry(Start, &Entry);
                if (Start)
                {
                    ++EntryCount;
                }
                else
                {
                    EntryCount = 0;
                    break;
                }
            }
        }
        free( FileRead );
        CloseHandle(hFile);
    }
    else
    {
        if (TriageType == TRIAGE_FILE_OSSPECIFIC)
        {
            TriageType = TRIAGE_FILE_DEFAULT;
            goto GatherTriageInfo;
        }
    }

    if (TriageType == TRIAGE_FILE_OCA)
    {
        TriageType = TRIAGE_FILE_OSSPECIFIC;
        goto GatherTriageInfo;
    }


    //
    // Now copy it to array for fast access;
    //
    if (EntryCount)
    {
        m_pTriageData = (PTRIAGE_DATA) malloc(EntryCount * sizeof(TRIAGE_DATA));
        if (!m_pTriageData)
        {
            DeleteList(Start);
            return;
        }
        m_EntryCount = EntryCount;
        Trav = Start;
        for (ULONG i = 0; i < m_EntryCount && Trav; ++i, Trav = Trav->Next)
        {
            m_pTriageData[i] = Trav->TriageData;
        }
        DeleteList(Start);
        qsort(m_pTriageData, m_EntryCount, sizeof(*m_pTriageData), &TriageDataCmp);
    } else
    {
        m_pTriageData = NULL;
        m_EntryCount = 0;
    }
}

CTriager::~CTriager()
{
    if (m_pTriageData)
    {
        free(m_pTriageData);
    }
}

void
CTriager::PrintTraigeInfo()
{
    dprintf("Triage data %lx entries:\n"
            "Module           Routine                       Followup\n",
            m_EntryCount);
    for (ULONG i = 0; i < m_EntryCount; ++i)
    {
        dprintf("%-15s%c%-29s%c%s\n",
                m_pTriageData[i].Module,
                m_pTriageData[i].fModulPartial ? '*' : ' ',
                m_pTriageData[i].Routine,
                m_pTriageData[i].fRoutinePartial ? '*' : ' ',
                m_pTriageData[i].Followup );
    }
}

ULONG
CTriager::MatchSymbol(
    PSTR Module,
    PSTR Routine
    )
{
    int Hi, Lo, Mid;
    int BestMatch;
    int cmp1, cmp2;
    TRIAGE_DATA *Trav;

    if (m_EntryCount == 0)
    {
        return -1;
    }

    Lo  = 0;
    Hi  = m_EntryCount-1;

    while (Lo <= Hi)
    {
        Mid = (Lo + Hi) / 2;

        Trav = &m_pTriageData[Mid];
        #if 0
        dprintf("%3lx: M: %s%c R: %s%c F: %s\n", Mid,m_pTriageData[Mid].Module,
                m_pTriageData[Mid].fModulPartial ? '*' : ' ',
                m_pTriageData[Mid].Routine,
                m_pTriageData[Mid].fRoutinePartial ? '*' : ' ',
                m_pTriageData[Mid].Followup);
        #endif //0
        cmp1 = _stricmp(m_pTriageData[Mid].Module, Module);
        if (!cmp1)
        {
            cmp1 =  _stricmp(m_pTriageData[Mid].Routine, Routine);
        }

        if (!cmp1)
        {
            return Mid;
        }
        else if (cmp1 > 0)
        {
            Hi = Mid - 1;
        }
        else
        {
            Lo = Mid + 1;
        }
    }

    // Backtrace from mid till we find good prefix match

    if (Lo >= (int)m_EntryCount)
    {
       Lo = m_EntryCount-1;
    }

    while (Lo)
    {
        if (m_pTriageData[Lo].fRoutinePartial ||
            m_pTriageData[Lo].fModulPartial)
        {
            // dprintf("- %3lx: M: %s R: %s F: %s\n",
            //         Lo, m_pTriageData[Lo].Module,
            //         m_pTriageData[Lo].Routine,m_pTriageData[Lo].Followup);

            if (!m_pTriageData[Lo].Routine || !Routine)
            {
                cmp2 = 0;
            }
            else if (m_pTriageData[Lo].fRoutinePartial)
            {
                cmp2 = _strnicmp(m_pTriageData[Lo].Routine, Routine,
                                 strlen(m_pTriageData[Lo].Routine));
            }
            else
            {
                cmp2 = _stricmp(m_pTriageData[Lo].Routine, Routine);
            }

            if (m_pTriageData[Lo].fModulPartial)
            {
                cmp1 = _strnicmp(m_pTriageData[Lo].Module, Module,
                                 strlen(m_pTriageData[Lo].Module));
            }
            else
            {
                cmp1 = _stricmp(m_pTriageData[Lo].Module, Module);
            }

            if (!cmp1 && !cmp2)
            {
                return Lo;
            }
        }

        --Lo;
    }

    return -1;
}

ULONG
CTriager::GetFollowup(
    PSTR FollowupBuffer,
    ULONG FollowupBufferSize,
    PSTR SymbolName
    )
{
    CHAR Module[100], Routine[2048];
    ULONG index;
    PCHAR Bang;
    ULONG ret;

    if (!SymbolName)
    {
        return TRIAGE_FOLLOWUP_FAIL;
    }

    Bang = strchr(SymbolName, '!');
    if (!Bang)
    {
        CopyString(Module, SymbolName, sizeof(Module));
        Routine[0] = 0;
    }
    else
    {
        ULONG len = (ULONG) ((ULONG64) Bang - (ULONG64)SymbolName);
        if (len > sizeof(Module)-1)
        {
            len = sizeof(Module)-1;
        }
        strncpy(Module,SymbolName, len);
        Module[len]=0;
        CopyString(Routine, Bang+1, sizeof(Routine));
    }

    //
    // Make sure we followup on image name instead of module name
    //
    ULONG Index;
    ULONG64 Base;
    if (strcmp(Module, "nt") &&
        (S_OK == g_ExtSymbols->
                   GetModuleByModuleName(Module, 0, &Index, &Base)))
    {
        CHAR ImageBuffer[MAX_PATH];

        if (g_ExtSymbols->
            GetModuleNames(Index, Base,
                           ImageBuffer, sizeof(ImageBuffer), NULL,
                           NULL, 0, NULL,
                           NULL, 0, NULL) == S_OK)
        {
            PCHAR Break = strrchr(ImageBuffer, '\\');
            if (Break)
            {
                CopyString(ImageBuffer, Break + 1, sizeof(ImageBuffer));
            }
            CopyString(Module, ImageBuffer, sizeof(Module));
            if (Break = strchr(Module, '.'))
            {
                *Break = 0;
            }
        }

    }

    PCHAR Followup;

    Followup = g_pTriager->GetFollowupStr(Module, Routine);

    if (Followup)
    {
        ret = TRIAGE_FOLLOWUP_SUCCESS;

        if (!strcmp(Followup, "ignore"))
        {
            ret = TRIAGE_FOLLOWUP_IGNORE;
        }
    }
    else
    {
        Followup = g_pTriager->GetFollowupStr("default", "");
        ret = TRIAGE_FOLLOWUP_DEFAULT;
    }

    if (Followup)
    {
        strncpy(FollowupBuffer, Followup, FollowupBufferSize);
        FollowupBuffer[FollowupBufferSize-1] = 0;
        return ret;
    }
    else
    {
        return TRIAGE_FOLLOWUP_FAIL;
    }
}


void
CTriager::GetFollowupDate(
    PSTR Module,
    PSTR Routine,
    PULONG Start,
    PULONG End)
{
    ULONG Index;
    CHAR DateEntry[32];
    PCHAR Break;
    PCHAR Stop;

    *Start = 0;
    *End = 0;

    if ((Index = MatchSymbol(Module, Routine)) >= m_EntryCount)
    {
        return;
    }

    CopyString(DateEntry, m_pTriageData[Index].Followup, sizeof(DateEntry));

    if (Break = strchr(DateEntry, ','))
    {
        *Start = strtoul(Break+1, &Stop, 16);
        *Break = 0;
    }

    *End = strtoul(DateEntry, &Stop, 16);

    //dprintf("%08lx\n %08lx\n", *Start, *End);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\atom.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    atom.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define MAXINTATOM 0xC000

VOID
AtomExtension(
    PCSTR lpArgumentString
    );

VOID DumpAtomTable(
    ULONG64 ppat,
    ULONG a
    );

DECLARE_API( atom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a user mode atom table

    Called as:

        !atom [address]

    If an address if not given or an address of 0 is given, then the
    process atom table is dumped.

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
//    AtomExtension( args );
//                           Copied its code here :-
    ULONG64 ppat, pat;
    ULONG a;
    INIT_API();
    try {
        while (*args == ' ') {
            args++;
        }

        if (*args && *args != 0xa) {
            a = (ULONG) GetExpression((LPSTR)args);
        } else {
            a = 0;
        }

        ppat = GetExpression("kernel32!BaseLocalAtomTable");
        if ((ppat != 0) &&
            ReadPointer(ppat, &pat)) {
            dprintf("\nLocal atom table ");
            DumpAtomTable(ppat, a);
            dprintf("Use 'dt _RTL_ATOM_TABLE %p'.\n", ppat);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
    EXIT_API();
    return S_OK;
}

CHAR szBaseLocalAtomTable[] = "kernel32!BaseLocalAtomTable";

VOID DumpAtomTable(
    ULONG64 ppat,
    ULONG a
    )
{
    ULONG64 pat;
    ULONG64 pate;
    ULONG iBucket, NumberOfBuckets, PtrSize, Off, NameOff;
    LPWSTR pwsz;
    BOOL fFirst;

    if (!ReadPointer(ppat, &pat) ||
        pat == 0) {
        dprintf("is not initialized.\n");
        return;
    }

    if (InitTypeRead(pat, _RTL_ATOM_TABLE)) {
        return;
    }
    if (a) {
        dprintf("\n");
    } else {
        dprintf("at %x\n", pat);
    }
    NumberOfBuckets = (ULONG) ReadField(NumberOfBuckets);

    GetFieldOffset("_RTL_ATOM_TABLE", "Buckets", &Off);
    GetFieldOffset("_RTL_ATOM_TABLE", "Name", &NameOff);
    PtrSize = IsPtr64() ? 8 : 4;

    for (iBucket = 0; iBucket < NumberOfBuckets; iBucket++) {
        if (!ReadPointer(pat + iBucket * PtrSize + Off, &pate))
        {
            pate = 0;
        }

        if (pate != 0 && !a) {
            dprintf("Bucket %2d:", iBucket);
        }
        fFirst = TRUE;
        while (pate != 0) {
            ULONG NameLength;

            if (!fFirst && !a) {
                dprintf("          ");
            }
            fFirst = FALSE;
            if (InitTypeRead(pate, _RTL_ATOM_TABLE_ENTRY)) {
                return;
            }
            NameLength = (ULONG) ReadField(NameLength);
            pwsz = (LPWSTR)LocalAlloc(LPTR, ((NameLength) + 1) * sizeof(WCHAR));
            ReadMemory(pate + NameOff, pwsz, NameLength * sizeof(WCHAR), NULL);
            pwsz[NameLength ] = L'\0';
            if (a == 0 || a == ((ULONG)ReadField(HandleIndex) | MAXINTATOM)) {
                dprintf("%hx(%2d) = %ls (%d)%s\n",
                        (ATOM)((ULONG)ReadField(HandleIndex) | MAXINTATOM),
                        (ULONG)ReadField(ReferenceCount),
                        pwsz, (NameLength),
                        (ULONG)ReadField(Flags) & RTL_ATOM_PINNED ? " pinned" : "");

                if (a) {
                    LocalFree(pwsz);
                    return;
                }
            }
            LocalFree(pwsz);
            if (pate == ReadField(HashLink)) {
                dprintf("Bogus hash link at %p\n", pate);
                break;
            }
            pate = ReadField(HashLink);
        }
    }
    if (a)
        dprintf("\n");
}


VOID
AtomExtension(
    PCSTR lpArgumentString
    )
{
    ULONG64 ppat;
    ULONG a;

    try {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString && *lpArgumentString != 0xa) {
            a = (ATOM)GetExpression((LPSTR)lpArgumentString);
        } else {
            a = 0;
        }

        ppat = GetExpression(szBaseLocalAtomTable);
        if (ppat != 0) {
            dprintf("\nLocal atom table ");
            DumpAtomTable(ppat, a);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\uexcep.h ===
//----------------------------------------------------------------------------
//
// User-mode exception analysis.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __UEXCEP_H__
#define __UEXCEP_H__

typedef struct _EX_STATE
{
    ULONG ProcId, ThreadId;
    EXCEPTION_RECORD64 Exr;
    ULONG FirstChance;
} EX_STATE, *PEX_STATE;

typedef struct _AVRF_STOP
{
    ULONG   Code;
    ULONG64 Params[4];
} AVRF_STOP, *PAVRF_STOP;

UserDebugFailureAnalysis*
UeAnalyze(
    OUT PEX_STATE ExState,
    ULONG Flags
    );

HRESULT
AnalyzeUserException(
    PCSTR args
    );

HRESULT
DoVerifierAnalysis(
    PEX_STATE ExState,
    DebugFailureAnalysis* Analysis
    );

#endif // #ifndef __UEXCEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extdll\uexcep.cpp ===
//----------------------------------------------------------------------------
//
// User-mode exception analysis.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop
#include "nturtl.h"

typedef void (*EX_STATE_ANALYZER)(PEX_STATE ExState,
                                  UserDebugFailureAnalysis* Analysis);

//----------------------------------------------------------------------------
//
// Exception-specific analyzers.
//
//----------------------------------------------------------------------------

#define IMPL_EXS_ANALYZER(Name)                 \
void                                            \
Exa_##Name(PEX_STATE ExState,                   \
           UserDebugFailureAnalysis* Analysis)

IMPL_EXS_ANALYZER(STATUS_ACCESS_VIOLATION)
{
    Analysis->SetUlong64(ExState->Exr.ExceptionInformation[0] ?
                         DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS,
                         ExState->Exr.ExceptionInformation[1]);

    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, "ACCESS_VIOLATION");
}


//----------------------------------------------------------------------------
//
// App verifier-specific analyzers.
//
//----------------------------------------------------------------------------

#define IMPL_AVRF_ANALYZER(Name)                 \
void                                            \
Avrf_##Name(PAVRF_STOP AvrfStop,                   \
           DebugFailureAnalysis* Analysis)


IMPL_AVRF_ANALYZER(APPLICATION_VERIFIER_INVALID_HANDLE)
{
    EXT_GET_HANDLE_TRACE pGetHandleTrace;

    if (AvrfStop->Params[1])
    {
        Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_RECORD, AvrfStop->Params[1]);
    }
    if (AvrfStop->Params[2])
    {
        Analysis->SetUlong64(DEBUG_FLR_CONTEXT, AvrfStop->Params[2]);
    }

    if ((g_TargetQualifier == DEBUG_DUMP_SMALL)   ||
        (g_TargetQualifier == DEBUG_DUMP_DEFAULT) ||
        (g_TargetQualifier == DEBUG_DUMP_FULL))
    {
        return;
    }

    // Look for most recent handle trace which resulted in
    // bad reference
    if (g_ExtControl->
        GetExtensionFunction(0, "GetHandleTrace",
                             (FARPROC*)&pGetHandleTrace) == S_OK &&
        pGetHandleTrace)
    {
        ULONG64 Handle = 0;
        ULONG64 Stack[10];


#ifndef HANDLE_TRACE_DB_BADREF
#define HANDLE_TRACE_DB_BADREF 3
#endif
        if ((*pGetHandleTrace)(g_ExtClient, HANDLE_TRACE_DB_BADREF,
                               0, &Handle,
                               Stack, sizeof(Stack)/sizeof(Stack[0])) == S_OK)
        {
            // Found the bad handle !!
            Analysis->SetUlong64(DEBUG_FLR_BAD_HANDLE, Handle);
        }
    }

    return;
}

IMPL_AVRF_ANALYZER(APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL)
{
    CHAR DllName[MAX_PATH];

    if (AvrfStop->Params[0])
    {
        Analysis->SetUlong64(DEBUG_FLR_CRITICAL_SECTION, AvrfStop->Params[0]);
    }
    if (AvrfStop->Params[2])
    {
        if (ReadMemory(AvrfStop->Params[2],
                       DllName,
                       sizeof(DllName),
                       NULL))
        {
            DllName[MAX_PATH-1] = DllName[MAX_PATH-2] = 0;
            if (DllName[0])
            {
                wchr2ansi((PWCHAR) DllName, DllName);

                Analysis->SetString(DEBUG_FLR_IMAGE_NAME, DllName);
                Analysis->SetUlong(DEBUG_FLR_FOLLOWUP_DRIVER_ONLY, 1);
            }
        }
    }
    if (AvrfStop->Params[3])
    {
        Analysis->SetUlong64(DEBUG_FLR_FAULTING_MODULE, AvrfStop->Params[3]);
    }
}

IMPL_AVRF_ANALYZER(APPLICATION_VERIFIER_ACCESS_VIOLATION)
{
    if (AvrfStop->Params[0])
    {
        Analysis->SetUlong64(DEBUG_FLR_INVALID_HEAP_ADDRESS, AvrfStop->Params[0]);
    }
    if (AvrfStop->Params[1])
    {
        Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, AvrfStop->Params[1]);
    }
    if (AvrfStop->Params[2])
    {
        Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_RECORD, AvrfStop->Params[2]);
    }
    if (AvrfStop->Params[3])
    {
        Analysis->SetUlong64(DEBUG_FLR_CONTEXT, AvrfStop->Params[3]);
    }
}

IMPL_AVRF_ANALYZER(APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK)
{
    if (AvrfStop->Params[1])
    {
        Analysis->SetUlong64(DEBUG_FLR_INVALID_HEAP_ADDRESS, AvrfStop->Params[1]);
    }
}

IMPL_AVRF_ANALYZER(APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP)
{
    CHAR DllName[MAX_PATH];

    if (AvrfStop->Params[0])
    {
        Analysis->SetUlong64(DEBUG_FLR_CRITICAL_SECTION, AvrfStop->Params[0]);
    }
}

BOOL
CheckAppVerifierEnabled(
    void
    )
{
    ULONG64 PebAddress;
    ULONG Flags;
    ULONG BytesRead;
    ULONG I;
    ULONG64 GlobalFlags;

    //
    // No app verifier on NT 4
    //
    if (g_TargetBuild < 2195)
    {
        return FALSE;
    }

    GetPebAddress(0, &PebAddress);

    if (PebAddress)
    {
        if (!InitTypeRead (PebAddress, ntdll!_PEB))
        {
            GlobalFlags = ReadField (NtGlobalFlag);


            if ((GlobalFlags & FLG_APPLICATION_VERIFIER))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL
GetVerifierDataFromException(
    PEX_STATE ExState,
    PULONG Code,
    PULONG64 Param1,
    PULONG64 Param2,
    PULONG64 Param3,
    PULONG64 Param4
    )
{
    CHAR Buffer[MAX_PATH];
    ULONG64 Disp;

    *Code = 0;
    if (ExState == NULL)
    {
        return FALSE;
    }
    if (ExState->FirstChance &&
        ExState->Exr.ExceptionCode == STATUS_INVALID_HANDLE)
    {
        if (FaIsFunctionAddr(ExState->Exr.ExceptionAddress,
                             "KiRaiseUserExceptionDispatcher"))
        {
            // Most likely this is a use of invalid handle, but verifier
            // couldn't catch it because app is under debugger

            *Code   = APPLICATION_VERIFIER_INVALID_HANDLE ; // INVALID_HANDLE;
            *Param1 = STATUS_INVALID_HANDLE;
            return TRUE;
        }
    }
    return FALSE;
}



BOOL
GetVerifierStopData(
    PULONG Code,
    PULONG64 Param1,
    PULONG64 Param2,
    PULONG64 Param3,
    PULONG64 Param4
    )
{
    ULONG64 CurrentStopAddress;
    ULONG PointerSize = IsPtr64() ? 8 : 4;

    *Code = 0;

    CurrentStopAddress = GetExpression("ntdll!AVrfpStopData");
    if (CurrentStopAddress == 0)
    {
        CurrentStopAddress = GetExpression("verifier!AVrfpStopData");
    }

    if (CurrentStopAddress == 0)
    {
        dprintf( "Unable to resolve AVrfpStopData symbol.\n");
        return FALSE;
    }

    if (!ReadMemory(CurrentStopAddress, Code, sizeof(*Code), NULL) ||
        !ReadPointer(CurrentStopAddress + PointerSize, Param1) ||
        !ReadPointer(CurrentStopAddress + 2*PointerSize, Param2) ||
        !ReadPointer(CurrentStopAddress + 3*PointerSize, Param3) ||
        !ReadPointer(CurrentStopAddress + 4*PointerSize, Param4))
    {
        dprintf("Cannot read AVrfpStopData values.\n");
        return FALSE;
    }
    if (*Code)
    {
        return TRUE;
    }
    return FALSE;
}

HRESULT
DoVerifierAnalysis(
    PEX_STATE ExState,
    DebugFailureAnalysis* Analysis
    )
{
    AVRF_STOP AvrfStop = {0};

    if (!GetVerifierStopData(&AvrfStop.Code, &AvrfStop.Params[0], &AvrfStop.Params[1],
                            &AvrfStop.Params[2], &AvrfStop.Params[3]) &&
        !GetVerifierDataFromException(ExState, &AvrfStop.Code, &AvrfStop.Params[0],
                                     &AvrfStop.Params[1], &AvrfStop.Params[2],
                                     &AvrfStop.Params[3]))
    {
        // Doesn't look like a verifier bug

        return S_FALSE;
    }
    CHAR BugCheckStr[40];

    sprintf(BugCheckStr, "AVRF_%lx", AvrfStop.Code);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);

#define CALL_AVRF_ANALYZER(Name)                 \
case Name:                                       \
Avrf_##Name(&AvrfStop,                   \
           Analysis);                    \
           break;

    switch (AvrfStop.Code)
    {
        CALL_AVRF_ANALYZER(APPLICATION_VERIFIER_INVALID_HANDLE);
        CALL_AVRF_ANALYZER(APPLICATION_VERIFIER_LOCK_IN_UNLOADED_DLL);
        CALL_AVRF_ANALYZER(APPLICATION_VERIFIER_CORRUPTED_HEAP_BLOCK);
        CALL_AVRF_ANALYZER(APPLICATION_VERIFIER_ACCESS_VIOLATION);

    case APPLICATION_VERIFIER_LOCK_DOUBLE_INITIALIZE:
    case APPLICATION_VERIFIER_LOCK_OVER_RELEASED:
    case APPLICATION_VERIFIER_LOCK_NOT_INITIALIZED:
    case APPLICATION_VERIFIER_LOCK_ALREADY_INITIALIZED:
    case APPLICATION_VERIFIER_LOCK_INVALID_LOCK_COUNT:
        CALL_AVRF_ANALYZER(APPLICATION_VERIFIER_LOCK_IN_FREED_HEAP);
    default:
        break;
    }
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Generic exception analysis handling.
//
//----------------------------------------------------------------------------

struct EX_ANALYZER_ENTRY
{
    ULONG Code;
    EX_STATE_ANALYZER Analyzer;
};

#define EXS_ANALYZER_ENTRY(Name) \
    Name, Exa_##Name

EX_ANALYZER_ENTRY g_ExAnalyzers[] =
{
    EXS_ANALYZER_ENTRY(STATUS_ACCESS_VIOLATION),
    0, NULL,
};

void
UeFillAnalysis(PEX_STATE ExState,
               UserDebugFailureAnalysis* Analysis)
{
    HRESULT Status;

    //
    // Add common analysis entries.
    //

    Analysis->SetFailureClass(DEBUG_CLASS_USER_WINDOWS);
    Analysis->SetFailureType(DEBUG_FLR_USER_CRASH);
    Analysis->SetFailureCode(ExState->Exr.ExceptionCode);

    Analysis->SetUlong64(DEBUG_FLR_FAULTING_IP, ExState->Exr.ExceptionAddress);
    Analysis->SetUlong64(DEBUG_FLR_EXCEPTION_RECORD, -1);

    CHAR BugCheckStr[40];

    sprintf(BugCheckStr, "%lx", ExState->Exr.ExceptionCode);
    Analysis->SetString(DEBUG_FLR_BUGCHECK_STR, BugCheckStr);
    Analysis->SetString(DEBUG_FLR_DEFAULT_BUCKET_ID, "APPLICATION_FAULT");


    CHAR ProcessName[512];
    ULONG Size;
    PCHAR Name;

    Status = g_ExtSystem->GetCurrentProcessExecutableName(ProcessName,
                                                          sizeof(ProcessName),
                                                          &Size);
    if ((Status == S_OK) && (Size > 1))
    {
        if (Name = strrchr(ProcessName, '\\'))
        {
            Name++;
        }
        else
        {
            Name = ProcessName;
        }

        Analysis->SetString(DEBUG_FLR_PROCESS_NAME, Name);

        if (!_stricmp("iexplore.exe", Name))
        {
            Analysis->SetFailureType(DEBUG_FLR_IE_CRASH);
        }
    }

    if (g_TargetPlatform == VER_PLATFORM_WIN32_NT)
    {
        Analysis->CheckModuleSymbols("ntdll", "OS");

        if (CheckAppVerifierEnabled())
        {
            // This proces has app verifier enabled
            DoVerifierAnalysis(ExState, Analysis);
        }
    }

    //
    // Find an analyzer for the exception and run it.
    //

    EX_ANALYZER_ENTRY* Entry = g_ExAnalyzers;
    while (Entry->Analyzer)
    {
        if (Entry->Code == ExState->Exr.ExceptionCode)
        {
            Entry->Analyzer(ExState, Analysis);
            break;
        }

        Entry++;
    }


    Analysis->ProcessInformation();
}

UserDebugFailureAnalysis*
UeAnalyze(
    PEX_STATE ExState,
    ULONG Flags
    )
{
    ULONG EventType;
    DEBUG_LAST_EVENT_INFO_EXCEPTION LastEx;

    if (g_ExtControl->GetLastEventInformation(&EventType,
                                              &ExState->ProcId,
                                              &ExState->ThreadId,
                                              &LastEx, sizeof(LastEx), NULL,
                                              NULL, 0, NULL) != S_OK)
    {
        ExtErr("Unable to get last event information\n");
        return NULL;
    }
    if (EventType != DEBUG_EVENT_EXCEPTION)
    {
        ExtErr("Event is not an exception\n");
        return NULL;
    }

    ExState->Exr = LastEx.ExceptionRecord;
    ExState->FirstChance = LastEx.FirstChance;

    UserDebugFailureAnalysis* Analysis = new UserDebugFailureAnalysis;
    if (Analysis)
    {
        Analysis->SetProcessingFlags(Flags);

        __try
        {
            UeFillAnalysis(ExState, Analysis);
        }
        __except(FaExceptionFilter(GetExceptionInformation()))
        {
            delete Analysis;
            Analysis = NULL;
        }
    }

    return Analysis;
}

HRESULT
AnalyzeUserException(
    PCSTR args
    )
{
    ULONG Flags = 0;

    if (g_TargetClass != DEBUG_CLASS_USER_WINDOWS)
    {
        dprintf("!analyzeuexception is for user mode only\n");
        return E_FAIL;
    }

    for (;;)
    {
        while (*args == ' ' || *args == '\t')
        {
            args++;
        }

        if (*args == '-')
        {
            ++args;
            switch(*args)
            {
            case 'v':
                Flags |= FAILURE_ANALYSIS_VERBOSE;
                break;

            case 'f':
                break;

            default:
                dprintf("Unknown option %c\n", *args);
                break;
            }
            ++args;
        }
        else
        {
            break;
        }
    }

    dprintf("*******************************************************************************\n");
    dprintf("*                                                                             *\n");
    dprintf("*                        Exception Analysis                                   *\n");
    dprintf("*                                                                             *\n");
    dprintf("*******************************************************************************\n");
    dprintf("\n");

    if (!(Flags & FAILURE_ANALYSIS_VERBOSE))
    {
        dprintf("Use !analyze -v to get detailed debugging information.\n\n");
    }

    EX_STATE ExState;
    UserDebugFailureAnalysis* Analysis = UeAnalyze(&ExState, Flags);

    if (!Analysis)
    {
        dprintf("\n\nFailure could not be analyzed\n\n");

        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, ".lastevent",
                              DEBUG_EXECUTE_DEFAULT);

        return E_FAIL;
    }

    Analysis->Output();

    delete Analysis;

    return S_OK;
}


DECLARE_API( analyzeuexception )
{
    INIT_API();

    HRESULT Hr = AnalyzeUserException(args);

    EXIT_API();

    return Hr;
}

//----------------------------------------------------------------------------
//
// UserDebugFailureAnalysis.
//
//----------------------------------------------------------------------------

UserDebugFailureAnalysis::UserDebugFailureAnalysis(void)
    : m_NtDllModule("ntdll"),
      m_Kernel32Module("kernel32"),
      m_Advapi32Module("advapi32")
{
}

DEBUG_POOL_REGION
UserDebugFailureAnalysis::GetPoolForAddress(ULONG64 Addr)
{
    return DbgPoolRegionUnknown;
}

PCSTR
UserDebugFailureAnalysis::DescribeAddress(ULONG64 Address)
{
    // XXX drewb - QueryVirtual to say something about the address?
    return NULL;
}

FOLLOW_ADDRESS
UserDebugFailureAnalysis::IsPotentialFollowupAddress(ULONG64 Address)
{
    // XXX drewb - Check against maximum user address, but there's
    // no guaranteed way to get the maximum user address.

    return FollowYes;
}

FOLLOW_ADDRESS
UserDebugFailureAnalysis::IsFollowupContext(ULONG64 Address1, ULONG64 Address2,
                                            ULONG64 Address3)
{
    // XXX drewb - Check against maximum user address, but there's
    // no guaranteed way to get the maximum user address.

    return FollowYes;
}

FlpClasses
UserDebugFailureAnalysis::GetFollowupClass(ULONG64 Address,
                                           PCSTR Module, PCSTR Routine)
{
    if (m_NtDllModule.Contains(Address)    ||
        m_Kernel32Module.Contains(Address) ||
        m_Advapi32Module.Contains(Address) ||
        (!_strcmpi(Module, "SharedUserData") &&
         Routine && !_strcmpi(Routine, "SystemCallStub")))
    {
        return FlpOSRoutine;
    }
    else if (!_strcmpi(Module, "shell32")  ||
             !_strcmpi(Module, "user32")   ||
             !_strcmpi(Module, "gdi32")    ||
             !_strcmpi(Module, "mshtml")   ||
             !_strcmpi(Module, "ole32")    ||
             !_strcmpi(Module, "verifier") ||
             !_strcmpi(Module, "rpcrt4"))
    {
        return FlpOSFilterDrv;
    }
    else
    {
        return FlpUnknownDrv;
    }
}


BOOL
UserDebugFailureAnalysis::CheckForCorruptionInHTE(
    ULONG64 hTableEntry,
    PCHAR Owner,
    ULONG OwnerSize
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\dlls.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    dlls.c

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
DllsExtension(
    PCSTR lpArgumentString,
    ULONG64 ProcessPeb
    );


DECLARE_API( dlls )

/*++

Routine Description:

    Dump user mode dlls (Kernel debugging)

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    ULONG64 Process, Peb;
    
    INIT_API();
    Peb = GetExpression("@$peb");
    DllsExtension( args, Peb );
    EXIT_API();
    return S_OK;

}

void 
ShowImageVersionInfo(
    ULONG64 DllBase
    )
{
    VS_FIXEDFILEINFO FixedVer;
    ULONG            SizeRead;
    CHAR             VersionBuffer[100];
    CHAR             FileStr[MAX_PATH]= {0};
    BOOL             ResFileVerStrOk = FALSE;
    BOOL             ResProdVerStrOk = FALSE;
    struct LANGANDCODEPAGE {
        WORD wLanguage;
        WORD wCodePage;
    } Translate;
    
    if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                  DllBase, "\\VarFileInfo\\Translation",
                                                  (PVOID) &Translate,
                                                  sizeof(Translate),
                                                  &SizeRead) == S_OK) {
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\CompanyName",
                Translate.wLanguage, Translate.wCodePage);

        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            FileStr[SizeRead] = 0;
            dprintf("      Company Name       %s\n", FileStr);
        }
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\ProductName",
                Translate.wLanguage, Translate.wCodePage);

        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            FileStr[SizeRead] = 0;
            dprintf("      Product Name       %s\n", FileStr);
        }
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\ProductVersion",
                Translate.wLanguage, Translate.wCodePage);

        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            ResProdVerStrOk = TRUE;
            FileStr[SizeRead] = 0;
            dprintf("      Product Version    %s\n", FileStr);
        }
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\OriginalFilename",
                Translate.wLanguage, Translate.wCodePage);

        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            FileStr[SizeRead] = 0;
            dprintf("      Original Filename  %s\n", FileStr);
        }
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\FileDescription",
                Translate.wLanguage, Translate.wCodePage);

        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            FileStr[SizeRead] = 0;
            dprintf("      File Description   %s\n", FileStr);
        }
        sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\FileVersion",
                Translate.wLanguage, Translate.wCodePage);
        if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                      DllBase, VersionBuffer,
                                                      (PVOID) FileStr,
                                                      sizeof(FileStr),
                                                      &SizeRead) == S_OK) {
            FileStr[SizeRead] = 0;
            dprintf("      File Version       %s\n", FileStr);
            ResFileVerStrOk = TRUE;
        }                    
    }

    if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
                                                  DllBase, "\\",
                                                  &FixedVer,
                                                  sizeof(FixedVer),
                                                  &SizeRead) == S_OK) {
        if (!ResFileVerStrOk) {
            dprintf("      File version       %d.%d.%d.%d\n",
                    FixedVer.dwFileVersionMS >> 16,
                    FixedVer.dwFileVersionMS & 0xFFFF,
                    FixedVer.dwFileVersionLS >> 16,
                    FixedVer.dwFileVersionLS & 0xFFFF);

        }
        if (!ResProdVerStrOk) {
            dprintf("      Product Version    %d.%d.%d.%d\n",
                    FixedVer.dwProductVersionMS >> 16,
                    FixedVer.dwProductVersionMS & 0xFFFF,
                    FixedVer.dwProductVersionLS >> 16,
                    FixedVer.dwProductVersionLS & 0xFFFF);
        }
    }
}

typedef enum {
    Memory = 1,
    Load = 2,
    Init = 3
} ELOAD_ORDER;

VOID
DllsExtension(
    PCSTR lpArgumentString,
    ULONG64 ProcessPeb
    )
{
    BOOL b;
    ULONG64 pLdrEntry;
    ULONG64 PebLdrAddress;
    ULONG   Offset;
    ULONG64 Next;
    WCHAR StringData[MAX_PATH+1];
    BOOL SingleEntry;
    BOOL DoHeaders;
    BOOL DoSections;
    BOOL DoAll;
    BOOL ShowVersionInfo;
    PSTR lpArgs = (PSTR)lpArgumentString;
    PSTR p;
    ULONG64 addrContaining = 0;
    ELOAD_ORDER OrderList = Load;
    ULONG64 OrderModuleListStart;
    ULONG64 DllBase;

    SingleEntry = FALSE;
    DoAll = FALSE;
    DoHeaders = FALSE;
    DoSections = FALSE;
    ShowVersionInfo = FALSE;

#if 0
    while ( lpArgumentString != NULL && *lpArgumentString ) {
        if (*lpArgumentString != ' ') {
            sscanf(lpArgumentString,"%lx",&pLdrEntry);
            SingleEntry = TRUE;
            goto dumpsingleentry;
            }

        lpArgumentString++;
        }
#endif

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
            }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                case 'c':   // dump only the dll containing the specified address
                case 'C':
                    lpArgs += 2;    // step over the c and the space.
                    addrContaining = GetExpression(lpArgs);

                    while (*lpArgs && (!isspace(*lpArgs))) {
                        lpArgs++;
                    }

                    if (addrContaining != 0) {
                        dprintf("Dump dll containing 0x%p:\n", addrContaining);
                    } else {
                        dprintf("-c flag requires and address arguement\n");
                        return;
                    }
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dlls [options] [address]\n");
                    dprintf("\n");
                    dprintf("Displays loader table entries.  Optionally\n");
                    dprintf("dumps image and section headers.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -c nnn  Dump dll containing address nnn\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -i      Dump dll's in Init order\n");
                    dprintf("   -l      Dump dll's in Load order (the default)\n");
                    dprintf("   -m      Dump dll's in Memory order\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("   -v      Dump version info from resource section\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 'm':   // dump in memory order
                case 'M':
                    ++lpArgs;
                    OrderList = Memory;
                    break;

                case 'i':   // dump in init order
                case 'I':
                    ++lpArgs;
                    OrderList = Init;
                    break;

                case 'l':   // dump in load order
                case 'L':
                    ++lpArgs;
                    OrderList = Load;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;
                case 'v':
                case 'V':
                    ++lpArgs;
                    ShowVersionInfo = TRUE;
                    break;
                }

            }
        else if (*lpArgs) {
            CHAR c;

            if (SingleEntry) {
                dprintf("Invalid extra argument\n");
                return;
                }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
                }
            c = *p;
            *p = 0;

            pLdrEntry = GetExpression(lpArgs);
            SingleEntry = TRUE;

            *p = c;
            lpArgs=p;

            }

        }

    if (SingleEntry) {
        goto dumpsingleentry;
        }

    //
    // Capture PebLdrData
    //

    GetFieldValue(ProcessPeb, "nt!_PEB", "Ldr", PebLdrAddress);
    if (InitTypeRead(PebLdrAddress, nt!_PEB_LDR_DATA)) {
        dprintf( "    Unable to read nt!_PEB_LDR_DATA type at %p\n", PebLdrAddress );
        return;
    }

    //
    // Walk through the loaded module table and display all ldr data
    //

    switch (OrderList) {
    case Memory:
        GetFieldOffset("nt!_PEB_LDR_DATA","InMemoryOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InMemoryOrderModuleList.Flink);
        break;

    case Init:
        GetFieldOffset("nt!_PEB_LDR_DATA","InInitializationOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InInitializationOrderModuleList.Flink);
        break;

    default:
    case Load:
        GetFieldOffset("nt!_PEB_LDR_DATA","InLoadOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InLoadOrderModuleList.Flink);
        break;
    }

    while (Next != OrderModuleListStart) {
        ULONG Length;

        if (CheckControlC()) {
            return;
            }

        
        switch (OrderList) {
        case Memory:
            GetFieldOffset("nt!_LDR_DATA_TABLE_ENTRY","InMemoryOrderLinks", &Offset);
            pLdrEntry = Next - Offset;
            break;

        case Init:
            GetFieldOffset("nt!_LDR_DATA_TABLE_ENTRY","InInitializationOrderLinks", &Offset);
            pLdrEntry = Next - Offset;
            break;

         default:
         case Load:
             GetFieldOffset("nt!_LDR_DATA_TABLE_ENTRY","InLoadOrderLinks", &Offset);
             pLdrEntry = Next - Offset;
             break;
        }

        //
        // Capture LdrEntry
        //
dumpsingleentry:


        if (InitTypeRead(pLdrEntry, nt!_LDR_DATA_TABLE_ENTRY)) {
            dprintf( "    Unable to read Ldr Entry at %p\n", pLdrEntry );
            return;
        }

        Length = (ULONG) ReadField(FullDllName.Length);
        if (Length >= sizeof(StringData))
        {
            Length = sizeof(StringData) -1;
        }
        ZeroMemory( StringData, sizeof( StringData ) );
        b = ReadMemory( ReadField(FullDllName.Buffer),
                        StringData,
                        Length,
                        NULL
                      );
        if (!b) {
            dprintf( "    Unable to read Module Name\n" );
            ZeroMemory( StringData, sizeof( StringData ) );
        }

        //
        // Dump the ldr entry data
        // (dump all the entries if no containing address specified)
        //
        if ((addrContaining == 0) ||
            ((ReadField(DllBase) <= addrContaining) &&
             (addrContaining <= (ReadField(DllBase) + ReadField(SizeOfImage)))
            )
           ) {
            ULONG Flags;

            dprintf( "\n" );
            dprintf( "0x%08p: %ws\n", pLdrEntry, StringData[0] ? StringData : L"Unknown Module" );
            dprintf( "      Base   0x%08p  EntryPoint  0x%08p  Size        0x%08p\n",
                     DllBase = ReadField(DllBase),
                     ReadField(EntryPoint),
                     ReadField(SizeOfImage)
                   );
            dprintf( "      Flags  0x%08x  LoadCount   0x%08x  TlsIndex    0x%08x\n",
                     Flags = (ULONG) ReadField(Flags),
                     (ULONG) ReadField(LoadCount),
                     (ULONG) ReadField(TlsIndex)
                   );

            if (Flags & LDRP_STATIC_LINK) {
                dprintf( "             LDRP_STATIC_LINK\n" );
                }
            if (Flags & LDRP_IMAGE_DLL) {
                dprintf( "             LDRP_IMAGE_DLL\n" );
                }
            if (Flags & LDRP_LOAD_IN_PROGRESS) {
                dprintf( "             LDRP_LOAD_IN_PROGRESS\n" );
                }
            if (Flags & LDRP_UNLOAD_IN_PROGRESS) {
                dprintf( "             LDRP_UNLOAD_IN_PROGRESS\n" );
                }
            if (Flags & LDRP_ENTRY_PROCESSED) {
                dprintf( "             LDRP_ENTRY_PROCESSED\n" );
                }
            if (Flags & LDRP_ENTRY_INSERTED) {
                dprintf( "             LDRP_ENTRY_INSERTED\n" );
                }
            if (Flags & LDRP_CURRENT_LOAD) {
                dprintf( "             LDRP_CURRENT_LOAD\n" );
                }
            if (Flags & LDRP_FAILED_BUILTIN_LOAD) {
                dprintf( "             LDRP_FAILED_BUILTIN_LOAD\n" );
                }
            if (Flags & LDRP_DONT_CALL_FOR_THREADS) {
                dprintf( "             LDRP_DONT_CALL_FOR_THREADS\n" );
                }
            if (Flags & LDRP_PROCESS_ATTACH_CALLED) {
                dprintf( "             LDRP_PROCESS_ATTACH_CALLED\n" );
                }
            if (Flags & LDRP_DEBUG_SYMBOLS_LOADED) {
                dprintf( "             LDRP_DEBUG_SYMBOLS_LOADED\n" );
                }
            if (Flags & LDRP_IMAGE_NOT_AT_BASE) {
                dprintf( "             LDRP_IMAGE_NOT_AT_BASE\n" );
                }
            if (Flags & LDRP_COR_IMAGE) {
                dprintf( "             LDRP_COR_IMAGE\n" );
                }
            if (Flags & LDRP_COR_OWNS_UNMAP) {
                dprintf( "             LDR_COR_OWNS_UNMAP\n" );
                }
        
            if (ShowVersionInfo) {
                ShowImageVersionInfo(DllBase);
            }
        }


        switch (OrderList) {
            case Memory:
                Next = ReadField(InMemoryOrderLinks.Flink);
                break;

            case Init:
                Next = ReadField(InInitializationOrderLinks.Flink);
                break;

            default:
            case Load:
                Next = ReadField(InLoadOrderLinks.Flink);
                break;
        }
        
        if (DoAll || DoHeaders || DoSections) {
            DumpImage( ReadField(DllBase),
                       DoAll || DoHeaders,
                       DoAll || DoSections );
        }

        if (SingleEntry) {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\deadlock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    deadlock.c

Abstract:

    This module implements the debug extension for the deadlock 
    verification package for critical section operations. 

Environment:

    User Mode

Author:

    Silviu Calinoiu (SilviuC) 6-Feb-2002

Revision History:

--*/
    
#include "precomp.h"
#pragma hdrstop

//
// This has to be in sync with the definition from
// base\win32\vrifier\deadlock.c
//

#define AVRF_DEADLOCK_HASH_BINS 0x1F

#if 0
typedef enum _AVRF_DEADLOCK_RESOURCE_TYPE {
    AVrfpDeadlockTypeUnknown = 0,
    AVrfpDeadlockTypeCriticalSection = 1,
    AVrfpDeadlockTypeMaximum = 2
} AVRF_DEADLOCK_RESOURCE_TYPE, *PAVRF_DEADLOCK_RESOURCE_TYPE;
#endif

PUCHAR ResourceTypes[] = 
{
    "Unknown",
    "Critical Section",
};

#define RESOURCE_TYPE_MAXIMUM 5

#define DEADLOCK_EXT_FLAG_DUMP_STACKS      1
#define DEADLOCK_EXT_FLAG_DUMP_NODES       2
#define DEADLOCK_EXT_FLAG_ANALYZE          4

extern
VOID
DumpSymbolicAddress(
    ULONG64 Address,
    PUCHAR  Buffer,
    BOOL    AlwaysShowHex
    );

#define MAX_DEADLOCK_PARTICIPANTS 32


#define VI_MAX_STACK_DEPTH 8
typedef struct _DEADLOCK_VECTOR 
{    
    ULONG64 Thread;
    ULONG64 Node;
    ULONG64 ResourceAddress;    
    ULONG64 StackAddress;
    ULONG64 ParentStackAddress;
    ULONG64 ThreadEntry;
    ULONG   Type;
    BOOLEAN TryAcquire;
} DEADLOCK_VECTOR, *PDEADLOCK_VECTOR;

//
// Functions from `verifier.c'
//

extern 
ULONG64
ReadPVOID (
    ULONG64 Address
    );

extern
ULONG
ReadULONG(
    ULONG64 Address
    );

#define ReadPvoid ReadPVOID
#define ReadUlong ReadULONG

//
// Forward declarations for local functions
//

VOID
PrintGlobalStatistics (
    ULONG64 GlobalsAddress
    );
    
BOOLEAN
SearchForResource (
    ULONG64 GlobalsAddress,
    ULONG64 ResourceAddress
    );

BOOLEAN
SearchForThread (
    ULONG64 GlobalsAddress,
    ULONG64 ThreadAddress
    );

BOOLEAN
AnalyzeResource (
    ULONG64 Resource,
    BOOLEAN Verbose
    );

BOOLEAN
AnalyzeResources (
    ULONG64 GlobalsAddress
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////// Deadlocks
/////////////////////////////////////////////////////////////////////

//
// Defines copied from nt\base\ntos\verifier\vfdeadlock.c .
//

#define AVRF_DEADLOCK_ISSUE_SELF_DEADLOCK           0x1000
#define AVRF_DEADLOCK_ISSUE_DEADLOCK_DETECTED       0x1001
#define AVRF_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE  0x1002
#define AVRF_DEADLOCK_ISSUE_UNEXPECTED_RELEASE      0x1003
#define AVRF_DEADLOCK_ISSUE_UNEXPECTED_THREAD       0x1004
#define AVRF_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION 0x1005
#define AVRF_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES  0x1006
#define AVRF_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE     0x1007



#define DUMP_FIELD(Name) dprintf ("%-20s %I64u \n", #Name, ReadField (Name))

DECLARE_API( udeadlock )

/*++

Routine Description:

    Verifier deadlock detection module extension.

Arguments:

    arg - not used for now.

Return Value:

    None.

--*/

{
    ULONG64 GlobalsPointer;
    ULONG64 GlobalsAddress;
    ULONG64 InitializedAddress;
    ULONG64 EnabledAddress;    
    ULONG64 InstigatorAddress;
    ULONG64 ParticipantAddress;
    ULONG64 LastResourceAddress;
    ULONG64 RootAddress;
    ULONG64 CurrentResourceAddress;
    ULONG64 CurrentThread;
    ULONG64 ThreadForChain;
    ULONG64 CurrentStack;
    ULONG64 NextStack;
    ULONG64 SymbolOffset;

    ULONG StackTraceSize;
            
    ULONG Processor=0;
    ULONG ParticipantOffset;
    ULONG StackOffset;
    ULONG ParentStackOffset;
    ULONG InitializedValue;
    ULONG EnabledValue;
    ULONG NumberOfParticipants;
    ULONG NumberOfResources;
    ULONG NumberOfThreads;
    ULONG ThreadNumber;
    ULONG ResourceNumber;
    ULONG ResourceType;
    ULONG TryAcquireUsed;
    
    
    ULONG PtrSize;
    ULONG J, I;

    BOOLEAN DumpStacks = FALSE;
    BOOLEAN DumpNodes  = FALSE;
    BOOLEAN Analyze = FALSE;

    ULONG64 Flags;

    UCHAR SymbolName[512];

    HANDLE CurrentThreadHandle = NULL;

    DEADLOCK_VECTOR Participants[MAX_DEADLOCK_PARTICIPANTS+1];

    ULONG64 Issue[4];
    ULONG64 SearchAddress = 0;

    INIT_API();
    
    //
    // Check if help requested
    //

    if (strstr (args, "?")) {
        
        dprintf ("\n");
        dprintf ("!deadlock             Statistics and deadlock layout \n");
        dprintf ("!deadlock 3           Detailed deadlock layout \n");
        dprintf ("!deadlock ADDRESS     Search for ADDRESS among deadlock verifier data \n");
        dprintf ("\n");
        Status = S_OK;
        goto Exit;
    }

    Flags = GetExpression(args);

    if (Flags > 0x10000000) {
        
        SearchAddress = Flags;
    }
    else {

        if (Flags & DEADLOCK_EXT_FLAG_DUMP_STACKS) {
            DumpStacks = TRUE;
        }

        if (Flags & DEADLOCK_EXT_FLAG_DUMP_NODES) {
            DumpNodes = TRUE;
        }
    
        if (Flags & DEADLOCK_EXT_FLAG_ANALYZE) {
            Analyze = TRUE;
        }
    }

    GlobalsPointer = (ULONG64) GetExpression ("verifier!AVrfpDeadlockGlobals");
    EnabledAddress = (ULONG64) GetExpression ("verifier!AVrfpDeadlockDetectionEnabled");    

    if (GlobalsPointer == 0 || EnabledAddress == 0) {
        dprintf ("Error: incorrect symbols for kernel \n");
        Status = E_INVALIDARG;
        goto Exit;
    }

    GlobalsAddress = 0;
    ReadPointer (GlobalsPointer, &GlobalsAddress);
    EnabledValue = ReadUlong (EnabledAddress);

    if (GlobalsAddress == 0) {
        dprintf ("Deadlock detection not initialized \n");
        Status = E_INVALIDARG;
        goto Exit;
    }
    
    InitializedValue = 1;

    if (EnabledValue == 0) {
        dprintf ("Deadlock detection not enabled \n");
        Status = E_INVALIDARG;
        goto Exit;
    }

    //
    // Do a search if this is requested.
    //

    if (SearchAddress) {
        
        BOOLEAN FoundSomething = FALSE;

        dprintf ("Searching for %p ... \n", SearchAddress);

        if (FoundSomething == FALSE) {
            FoundSomething = SearchForResource (GlobalsAddress, SearchAddress);
        }
        
        if (FoundSomething == FALSE) {
            FoundSomething = SearchForThread (GlobalsAddress, SearchAddress);
        }

        Status = S_OK;
        goto Exit;
    }

    //
    // Analyze if this is needed.
    //

    if (Analyze) {
        
        AnalyzeResources (GlobalsAddress);

        Status = S_OK;
        goto Exit;
    }

    //
    // Get the AVrfpDeadlockIssue[0..3] vector.
    //

    {
        ULONG ValueSize;
        ULONG64 IssueAddress;

        ValueSize = IsPtr64()? 8: 4;

        IssueAddress = GetExpression ("verifier!AVrfpDeadlockIssue");

        for (I = 0; I < 4; I += 1) {

            ReadPointer (IssueAddress + I * ValueSize, &(Issue[I]));
        }

        if (Issue[0] == 0) {

            dprintf ("\n");
            PrintGlobalStatistics (GlobalsAddress);
            dprintf ("\nNo deadlock verifier issues. \n");
            
            Status = S_OK;
            goto Exit;
        }
        else {
            
            if (ValueSize == 4) {
                dprintf ("issue: %08X %08X %08X %08X \n", 
                         Issue[0], Issue[1], Issue[2], Issue[3]);
            }
            else {
                dprintf ("issue: %I64X %I64X %I64X %I64X \n", 
                         Issue[0], Issue[1], Issue[2], Issue[3]);
            }
        }

        switch (Issue[0]) {
        
        case AVRF_DEADLOCK_ISSUE_SELF_DEADLOCK:
            dprintf ("Resource %I64X is acquired recursively. \n", Issue[1]);
            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_DEADLOCK_DETECTED:
            break;
        
        case AVRF_DEADLOCK_ISSUE_UNINITIALIZED_RESOURCE:
            dprintf ("Resource %I64X is used before being initialized. \n", Issue[1]);
            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_UNEXPECTED_RELEASE:
            dprintf ("Resource %I64X is released out of order. \n", Issue[2]);
            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_UNEXPECTED_THREAD:
            dprintf ("Current thread is releasing resource %I64X which was acquired in thread %I64X. \n", 
                     Issue[1], Issue[2]);
            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_MULTIPLE_INITIALIZATION:
            dprintf ("Resource %I64X has already been initialized. \n", Issue[1]);
            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_THREAD_HOLDS_RESOURCES:
            if (Issue[3] == 0) {
                dprintf ("Deleting thread %I64X (descriptor %I64X) "
                         "which still holds resources. \n",
                         Issue[1], Issue[2]);
            } else {
                dprintf ("Deleting thread %I64X which still holds resource %I64X "
                         "(descriptor %I64X). \n",
                         Issue[2], Issue[1], Issue[3]);
            }

            Status = S_OK;
            goto Exit;
        
        case AVRF_DEADLOCK_ISSUE_UNACQUIRED_RESOURCE:
            dprintf ("Releasing resource %I64X that was never acquired. \n", Issue[1]);
            Status = S_OK;
            goto Exit;
        
        default:
            dprintf ("Unrecognized issue code %I64X ! \n", Issue[0]);
            Status = S_OK;
            goto Exit;
        }
    }

    //
    // Figure out how big a pointer is
    //

    PtrSize = IsPtr64()? 8: 4;

    if (PtrSize == 0) {
        dprintf ("Cannot get size of PVOID \n");
        Status = E_INVALIDARG;
        goto Exit;
    }

    //
    // Dump the globals structure
    //

    InitTypeRead (GlobalsAddress, verifier!_AVRF_DEADLOCK_GLOBALS);

    //
    // Find out the address of the resource that causes the deadlock
    //         
    
    InstigatorAddress = ReadField(Instigator);
    
    NumberOfParticipants = (ULONG) ReadField(NumberOfParticipants);

    if (NumberOfParticipants > MAX_DEADLOCK_PARTICIPANTS) {
        dprintf("\nCannot have %x participants in a deadlock!\n",NumberOfParticipants);
        Status = E_INVALIDARG;
        goto Exit;

    }

    if (0 == NumberOfParticipants) {
        dprintf("\nNo deadlock detected\n");

        Status = S_OK;
        goto Exit;
    }

    GetFieldOffset("verifier!_AVRF_DEADLOCK_GLOBALS",
                   "Participant", 
                   &ParticipantOffset
                   );
    ParticipantAddress = GlobalsAddress + ParticipantOffset;

    //
    // Read the vector of AVRF_DEADLOCK_NODEs that
    // participate in the deadlock. 
    //
    //    

    for (J = 0; J < NumberOfParticipants; J++) {    
        Participants[J].Node = ReadPvoid(ParticipantAddress + J * PtrSize);
        // dprintf("Participant %c: %08x\n", 'A' + J, Participants[J].Node);
    }
    
    //
    // Gather the information we'll need to print out exact
    // context for the deadlock.
    //  
    GetFieldOffset("verifier!_AVRF_DEADLOCK_NODE",
                   "StackTrace",
                   &StackOffset
                   );
    GetFieldOffset("verifier!_AVRF_DEADLOCK_NODE",
                   "ParentStackTrace",
                   &ParentStackOffset
                   );
          
    
    //
    // The stack trace size is 1 on free builds and 6 (or bigger) on
    // checked builds. We assume that the ParentStackTrace field comes
    // immediately after StackTrace field in the NODE structure.
    //
    
    StackTraceSize = (ParentStackOffset - StackOffset) / PtrSize;

    for (J = 0; J < NumberOfParticipants; J++) {
        
        InitTypeRead (Participants[J].Node, verifier!_AVRF_DEADLOCK_NODE);
     

        RootAddress  = ReadField(Root);        

        GetFieldValue(RootAddress, 
                      "verifier!_AVRF_DEADLOCK_RESOURCE",
                      "ResourceAddress"                      , 
                      Participants[J].ResourceAddress
                      );

        GetFieldValue(RootAddress, 
                      "verifier!_AVRF_DEADLOCK_RESOURCE",
                      "Type", 
                      Participants[J].Type
                      );


        if (Participants[J].Type > RESOURCE_TYPE_MAXIMUM) {
            Participants[J].Type = 0;
        }        

        Participants[J].ThreadEntry         = ReadField(ThreadEntry);
        Participants[J].StackAddress        = Participants[J].Node + StackOffset;                                          
        Participants[J].ParentStackAddress  = Participants[J].Node + 
                                              ParentStackOffset;
        Participants[J].TryAcquire          = (BOOLEAN) ReadField(OnlyTryAcquireUsed);

        
        GetFieldValue(Participants[J].ThreadEntry, 
                     "verifier!_AVRF_DEADLOCK_THREAD",
                      "Thread", 
                      Participants[J].Thread
                      );        


    }

    if (Participants[0].ResourceAddress != InstigatorAddress) {
        dprintf("\nDeadlock Improperly formed participant list\n");
        Status = E_INVALIDARG;
        goto Exit;
    }

    //
    // The last participant is the Instigator of the deadlock
    //    
    
    Participants[NumberOfParticipants].Thread = 0;
    Participants[NumberOfParticipants].Node = 0;
    Participants[NumberOfParticipants].ResourceAddress = InstigatorAddress;
    Participants[NumberOfParticipants].StackAddress  = 0;
    Participants[NumberOfParticipants].ParentStackAddress = 
        Participants[NumberOfParticipants-1].StackAddress;    
    Participants[NumberOfParticipants].Type = 
        Participants[0].Type;
    Participants[NumberOfParticipants].TryAcquire = FALSE; // can't cause a deadlock with try
    Participants[NumberOfParticipants].ThreadEntry = 0;
    
    //
    // At this point we have all of the raw data we need.
    // We have to munge it up a bit so that we have the most
    // recent data. For instance, take the simple deadlock AB-BA.
    // The stack for A in the AB context may be wrong because
    // another thread may have come and taken A at a different point.
    // This is why we have the parent stack address.
    //
    // So the rules we have to adhere to are as follows:
    // Where we have a chain, (eg ABC meaning A taken then B then C),
    // the thread used will always be the thread for the last resource taken,
    // and the stacks used will be the the childs parent stack where
    // applicable.
    //
    // For example, if C was taken by thread 1, A & B would be munged
    // to use thread 1. Since in order to get to C, A and B must have
    // been taken by thread 1 at some point, even if the thread they
    // have saved now is a different one. C would use its own stack,
    // B would use C's parent stack, since that was the stack that
    // B had been acquired with when C was taken, and A will use
    // B's parent stack.
    //
    // We can identify the start of a chain when the same resource
    // is on the participant list twice in a row.
    //

    LastResourceAddress = InstigatorAddress;
    
    NumberOfResources   = 0;
    NumberOfThreads     = 0;

    for (J = 0; J <= NumberOfParticipants; J++) {
        I = NumberOfParticipants - J;

        CurrentResourceAddress = Participants[I].ResourceAddress;

        if (CurrentResourceAddress == LastResourceAddress) {

            //
            // This is the beginning of a chain. Use the current
            // stack and the current thread, and set the chain
            // thread to ours
            //

            ThreadForChain = Participants[I].Thread;
            CurrentStack   = Participants[I].StackAddress;
            NumberOfThreads++;
        } else {
            //
            // This is a resource we haven't seen before
            //
            NumberOfResources++;
        }

        NextStack = Participants[I].ParentStackAddress;


        Participants[I].StackAddress = CurrentStack;
        Participants[I].Thread       = ThreadForChain;        
        //
        // Parent stack isn't used any more -- nullify it.
        //
        Participants[I].ParentStackAddress = 0;

        CurrentStack = NextStack;
        LastResourceAddress = CurrentResourceAddress;
    }        

    //
    // Now that we've munged the vectors, we can go ahead and print out the 
    // deadlock information.
    //
    
    dprintf("\nDeadlock detected (%d resources in %d threads):\n\n",NumberOfResources, NumberOfThreads);

    if (! DumpStacks ) 
    {
        //
        // Print out the 'short' form 
        // Example:
        //
        // !dealock detected:
        // Thread 1: A B
        // Thread 2: B C
        // Thread 3: C A
        //
        // Thread 1 = <address>
        // Thread 2 = <address>
        // Thread 3 = <address>
        //
        // Lock A = <address> (spinlock)
        // Lock B = <address> (mutex)
        // Lock C = <address> (spinlock)
        //
        
        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
        
        //
        // Dump out the deadlock topology
        //
        
        while (J <= NumberOfParticipants)
        {
            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d: ",ThreadNumber);
            
            do {            
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                
                dprintf("%c ",
                    'A' + ResourceNumber                    
                    );                                                                                                 
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
            
            dprintf("\n");
            
            ThreadNumber++;
            ResourceNumber--;
        }
        dprintf("\nWhere:\n");
        
        //
        // Dump out the thread addresses
        //
        
        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
        while (J <= NumberOfParticipants) {

            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d = %08x\n",ThreadNumber, ThreadForChain);
            
            do {            
                
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
                                    
            ThreadNumber++;
            ResourceNumber--;
        }
        
        //
        // Dump out the resource addresses
        //

        ThreadNumber = 0;    
        ResourceNumber = 0;
        J=0;
#if 1
        while (J < NumberOfParticipants)
        {                                 
            while(J < NumberOfParticipants && Participants[J].ResourceAddress != Participants[J+1].ResourceAddress) {
                
                if (Participants[J].ResourceAddress != Participants[J+1].ResourceAddress) {
                    CHAR Buffer[0xFF];
                    ULONG64 Displacement = 0;
                    GetSymbol(Participants[J].ResourceAddress, Buffer, &Displacement);

                    dprintf("Lock %c =   %s", 'A' + ResourceNumber, Buffer );
                    if (Displacement != 0) {                    
                        dprintf("%s%x", (Displacement < 0xFFF)?"+0x":"",Displacement);
                    }                
                    dprintf(" Type '%s' ",ResourceTypes[Participants[J].Type]);                    
                    dprintf("\n");
                                        
                    ResourceNumber++;
                }
                J++;                                
            }                                    
            J++;            
        }
        
#endif        
    } else {
        
        //
        // Dump out verbose deadlock information -- with stacks
        // Here is an exapmle:
        //
        //        Deadlock detected (3 resources in 3 threads):
        //
        //Thread 0 (829785B0) took locks in the following order:
        //
        //    Lock A (Spinlock) @ bfc7c254
        //    Node:    82887F88
        //    Stack:   NDIS!ndisNotifyMiniports+0xC1
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //             ntkrnlmp!ExpWorkerThread+0x294
        //             ntkrnlmp!PspSystemThreadStartup+0x4B
        //
        //    Lock B (Spinlock) @ 8283b87c
        //    Node:    82879148
        //    Stack:   NDIS!ndisDereferenceRef+0x10F
        //             NDIS!ndisDereferenceDriver+0x3A
        //             NDIS!ndisNotifyMiniports+0xD1
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //
        //Thread 1 (829785B0) took locks in the following order:
        //
        //    Lock B (Spinlock) @ 8283b87c
        //    Node:    82879008
        //    Stack:   NDIS!ndisReferenceNextUnprocessedMiniport+0x3E
        //             NDIS!ndisNotifyMiniports+0xB3
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //             ntkrnlmp!PopPolicyWorkerThread+0x10F
        //             ntkrnlmp!ExpWorkerThread+0x294
        //
        //    Lock C (Spinlock) @ 82862b48
        //    Node:    8288D008
        //    Stack:   NDIS!ndisReferenceRef+0x10F
        //             NDIS!ndisReferenceMiniport+0x4A
        //             NDIS!ndisReferenceNextUnprocessedMiniport+0x70
        //             NDIS!ndisNotifyMiniports+0xB3
        //             NDIS!ndisPowerStateCallback+0x6E
        //             ntkrnlmp!ExNotifyCallback+0x72
        //             ntkrnlmp!PopDispatchCallback+0x13
        //             ntkrnlmp!PopPolicyWorkerNotify+0x8F
        //
        //Thread 2 (82978310) took locks in the following order:
        //
        //    Lock C (Spinlock) @ 82862b48
        //    Node:    82904708
        //    Stack:   NDIS!ndisPnPRemoveDevice+0x20B
        //             NDIS!ndisPnPDispatch+0x319
        //             ntkrnlmp!IopfCallDriver+0x62
        //             ntkrnlmp!IovCallDriver+0x9D
        //             ntkrnlmp!IopSynchronousCall+0xFA
        //             ntkrnlmp!IopRemoveDevice+0x11E
        //           ntkrnlmp!IopDeleteLockedDeviceNode+0x3AF
        //            ntkrnlmp!IopDeleteLockedDeviceNodes+0xF5
        //
        //    Lock A (Spinlock) @ bfc7c254
        //  Stack:   << Current stack >>
        //
        
        
        ThreadNumber = 0;
        ResourceNumber = 0;
        J=0;
        
        while (J <= NumberOfParticipants) {

            ThreadForChain = Participants[J].Thread;
            dprintf("Thread %d: %08X",ThreadNumber, ThreadForChain);
            if (DumpNodes && Participants[J].ThreadEntry) {
                    dprintf(" (ThreadEntry = %X)\n   ", (ULONG) Participants[J].ThreadEntry);
            }
            dprintf(" took locks in the following order:\n\n");
            
            
            //
            // This is a do .. while so that we can never get an infinite loop.
            //
            do {
                UINT64 CurrentStackAddress;
                UINT64 StackFrame;
                CHAR Buffer[0xFF];
                ULONG64 Displacement = 0;

                
                if (J == NumberOfParticipants) {
                    ResourceNumber = 0;
                }
                
                GetSymbol(Participants[J].ResourceAddress, Buffer, &Displacement);
                                                
                dprintf("    Lock %c -- %s", 'A' + ResourceNumber, Buffer );                
                if (Displacement != 0) {
                    dprintf("%s%x", (Displacement < 0xFFF)?"+0x":"",Displacement);
                }                
                dprintf(" (%s)\n",ResourceTypes[Participants[J].Type]);
                
                
                if (DumpNodes && Participants[J].Node)
                    dprintf("    Node:    %X\n", (ULONG) Participants[J].Node);
                
                dprintf("    Stack:   ");
                
                CurrentStackAddress = Participants[J].StackAddress;
                
                if (CurrentStackAddress == 0) {
                    
                    dprintf ("<< Current stack >>\n");
                    
                } else  {
                    
                    for (I = 0; I < StackTraceSize; I++) {

                        ULONG SourceLine;
                        
                        SymbolName[0] = '\0';
                        StackFrame = ReadPvoid(CurrentStackAddress);
                        if (0 == StackFrame)
                            break;
                        
                        GetSymbol(StackFrame, SymbolName, &SymbolOffset);
                        
                        if (I) {
                            dprintf("             ");
                        }
                        
                        if ((LONG64) SymbolOffset > 0 ) {
                            dprintf ("%s+0x%X", 
                                SymbolName, (ULONG) SymbolOffset);
                        } else {
                            dprintf ("%X", (ULONG) StackFrame);
                        }                    

                        if (SUCCEEDED(g_ExtSymbols->lpVtbl->GetLineByOffset
                                      (g_ExtSymbols, StackFrame,
                                       &SourceLine, SymbolName,
                                       sizeof(SymbolName), NULL,
                                       &Displacement))) {
                            dprintf (" [%s @ %d]", SymbolName, SourceLine);
                        }

                        dprintf ("\n");
                        
                        CurrentStackAddress += PtrSize;
                    }
                }
                
                dprintf("\n");
                J++;
                ResourceNumber++;
                
            } while( J <= NumberOfParticipants && Participants[J].ResourceAddress != Participants[J-1].ResourceAddress);
            
            ThreadNumber++;
            ResourceNumber--;
        }
    }

    Status = S_OK;
    
 Exit:
    EXIT_API();
    return Status;
}


VOID
PrintGlobalStatistics (
    ULONG64 GlobalsAddress
    )
{
    ULONG AllocationFailures;
    ULONG64 MemoryUsed;
    ULONG NodesTrimmed;
    ULONG MaxNodesSearched;
    ULONG SequenceNumber;

    //
    // Dump the globals structure
    //

    InitTypeRead (GlobalsAddress, verifier!_AVRF_DEADLOCK_GLOBALS);

    //
    // Print some simple statistics
    //

    dprintf ("Resources: %u\n", (ULONG) ReadField (Resources[0]));
    dprintf ("Nodes:     %u\n", (ULONG) ReadField (Nodes[0]));
    dprintf ("Threads:   %u\n", (ULONG) ReadField (Threads[0]));
    dprintf ("\n");

    MemoryUsed = ReadField (BytesAllocated);

    if (MemoryUsed > 1024 * 1024) {
        dprintf ("%I64u bytes of kernel pool used.\n", MemoryUsed);
    }

    AllocationFailures = (ULONG) ReadField (AllocationFailures);

    if (AllocationFailures > 0) {
        dprintf ("Allocation failures encountered (%u).\n", AllocationFailures);
    }

    NodesTrimmed = (ULONG) ReadField (NodesTrimmedBasedOnAge);
    dprintf ("Nodes trimmed based on age %u.\n", NodesTrimmed);
    NodesTrimmed = (ULONG) ReadField (NodesTrimmedBasedOnCount);
    dprintf ("Nodes trimmed based on count %u.\n", NodesTrimmed);

    dprintf ("Analyze calls %u.\n", (ULONG) ReadField (SequenceNumber));
    dprintf ("Maximum nodes searched %u.\n", (ULONG) ReadField (MaxNodesSearched));
}


BOOLEAN
SearchForResource (
    ULONG64 GlobalsAddress,
    ULONG64 ResourceAddress
    )
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    BOOLEAN ResourceFound = FALSE;
    ULONG64 SizeOfResource;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentResource;
    ULONG Magic;

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfResource = GetTypeSize("verifier!_AVRF_DEADLOCK_RESOURCE");

    GetFieldOffset("verifier!_AVRF_DEADLOCK_RESOURCE",
                   "HashChainList", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfResource == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, verifier!_AVRF_DEADLOCK_GLOBALS);

    Bucket = ReadField (ResourceDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get resource database address. \n");
        return FALSE;
    }

    for (I = 0; I < AVRF_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            InitTypeRead (Current - FlinkOffset, verifier!_AVRF_DEADLOCK_RESOURCE);
            CurrentResource = ReadField (ResourceAddress);

            if (CurrentResource == ResourceAddress || 
                ResourceAddress == Current - FlinkOffset) {
                
                CurrentResource = Current - FlinkOffset;
                ResourceFound = TRUE;
                break;
            }

            Current = ReadPvoid(Current);

            if (CheckControlC()) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        if (ResourceFound) {
            break;
        }

        dprintf (".");

        Bucket += SizeOfBucket;

    }

    dprintf ("\n");

    if (ResourceFound == FALSE) {

        dprintf ("No resource correspoding to %p has been found. \n", 
                 ResourceAddress);
    }
    else {

        dprintf ("Found a deadlock verifier resource descriptor @ %p \n", 
                CurrentResource);

    }

    return ResourceFound;
}


BOOLEAN
SearchForThread (
    ULONG64 GlobalsAddress,
    ULONG64 ThreadAddress
    )
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    BOOLEAN ThreadFound = FALSE;
    ULONG64 SizeOfThread;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentThread;

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfThread = GetTypeSize("verifier!_AVRF_DEADLOCK_THREAD");

    GetFieldOffset("verifier!_AVRF_DEADLOCK_THREAD",
                   "ListEntry", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfThread == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, verifier!_AVRF_DEADLOCK_GLOBALS);

    Bucket = ReadField (ThreadDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get thread database address. \n");
        return FALSE;
    }

    for (I = 0; I < AVRF_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            InitTypeRead (Current - FlinkOffset, verifier!_AVRF_DEADLOCK_THREAD);
            CurrentThread = ReadField (ThreadAddress);

            if (CurrentThread == ThreadAddress || 
                ThreadAddress == Current - FlinkOffset) {
                
                CurrentThread = Current - FlinkOffset;
                ThreadFound = TRUE;
                break;
            }

            Current = ReadPvoid(Current);
            
            if (CheckControlC()) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        if (ThreadFound) {
            break;
        }
        
        dprintf (".");

        Bucket += SizeOfBucket;

    }

    dprintf ("\n");

    if (ThreadFound == FALSE) {

        dprintf ("No thread correspoding to %p has been found. \n", 
                 ThreadAddress);
    }
    else {

        dprintf ("Found a deadlock verifier thread descriptor @ %p \n", 
                CurrentThread);

    }

    return ThreadFound;
}


VOID
DumpResourceStructure (
    )
{

}


ULONG
GetNodeLevel (
    ULONG64 Node
    )
{
    ULONG Level = 0;

    while (Node != 0) {
        
        Level += 1;

        if (Level > 12) {
            dprintf ("Level > 12 !!! \n");
            break;
        }

        InitTypeRead (Node, verifier!_AVRF_DEADLOCK_NODE);
        Node = ReadField (Parent);
    }

    return Level;
}

BOOLEAN
AnalyzeResource (
    ULONG64 Resource,
    BOOLEAN Verbose
    )
{
    ULONG64 Start;
    ULONG64 Current;
    ULONG64 Node;
    ULONG64 Parent;
    ULONG FlinkOffset;
    ULONG RootsCount = 0;
    ULONG NodesCount = 0;
    ULONG Levels[8];
    ULONG ResourceFlinkOffset;
    ULONG I;
    ULONG Level;
    ULONG NodeCounter = 0;

    ZeroMemory (Levels, sizeof Levels);

    GetFieldOffset("verifier!_AVRF_DEADLOCK_NODE",
                   "ResourceList", 
                   &FlinkOffset);

    GetFieldOffset("verifier!_AVRF_DEADLOCK_RESOURCE",
                   "ResourceList", 
                   &ResourceFlinkOffset);

    InitTypeRead (Resource, verifier!_AVRF_DEADLOCK_RESOURCE);

    if (! Verbose) {
        
        if (ReadField(NodeCount) < 4) {
            return TRUE;
        }

        dprintf ("Resource (%p) : %I64u %I64u %I64u ", 
                 Resource,
                 ReadField(Type), 
                 ReadField(NodeCount), 
                 ReadField(RecursionCount));
    }
    
    Start = Resource + ResourceFlinkOffset;
    Current = ReadPvoid (Start);

    while (Start != Current) {
        
        Node = Current - FlinkOffset;

        Level = (GetNodeLevel(Node) - 1) % 8;
        Levels[Level] += 1;

        NodesCount += 1;

        if (NodesCount && NodesCount % 1000 == 0) {
            dprintf (".");
        }

        Current = ReadPvoid (Current);

        if (CheckControlC()) {
            return FALSE;
        }
    }

    dprintf ("[");
    for (I = 0; I < 8; I += 1) {
        dprintf ("%u ", Levels[I]);
    }
    dprintf ("]\n");
    
    return TRUE;
}

BOOLEAN
AnalyzeResources (
    ULONG64 GlobalsAddress
    )
/*++

    This routine analyzes all resource to make sure we do not have
    zombie nodes laying around.

--*/
{
    ULONG I;
    ULONG64 Bucket;
    ULONG64 SizeOfBucket;
    ULONG64 SizeOfResource;
    ULONG FlinkOffset = 0;
    ULONG64 Current;
    ULONG64 CurrentResource;
    ULONG Magic;
    BOOLEAN Finished;
    ULONG ResourceCount = 0;

    dprintf ("Analyzing resources (%p) ... \n", GlobalsAddress);

    SizeOfBucket = GetTypeSize("LIST_ENTRY");
    SizeOfResource = GetTypeSize("verifier!_AVRF_DEADLOCK_RESOURCE");

    GetFieldOffset("verifier!_AVRF_DEADLOCK_RESOURCE",
                   "HashChainList", 
                   &FlinkOffset);

    if (SizeOfBucket == 0 || SizeOfResource == 0 || FlinkOffset == 0) {
        dprintf ("Error: cannot get size for verifier types. \n");
        return FALSE;
    }

    InitTypeRead (GlobalsAddress, verifier!_AVRF_DEADLOCK_GLOBALS);

    Bucket = ReadField (ResourceDatabase);

    if (Bucket == 0) {
        dprintf ("Error: cannot get resource database address. \n");
        return FALSE;
    }

    for (I = 0; I < AVRF_DEADLOCK_HASH_BINS; I += 1) {
        
        // traverse it ...

        Current = ReadPvoid(Bucket);

        while (Current != Bucket) {

            Finished = AnalyzeResource (Current - FlinkOffset, FALSE);
            ResourceCount += 1;

            if (ResourceCount % 256 == 0) {
                dprintf (".\n");
            }

            Current = ReadPvoid(Current);

            if (CheckControlC() || !Finished) {
                dprintf ("\nSearch interrupted ... \n");
                return TRUE;
            }
        }

        Bucket += SizeOfBucket;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\critsect.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    critsect.c

Abstract:

    Critical section debugger extension for both ntsd and kd.

Author:

    Daniel Mihai (DMihai) 8-Feb-2001

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////
BOOL
ReadStructFieldVerbose( ULONG64 AddrStructBase,
                        PCHAR StructTypeName,
                        PCHAR StructFieldName,
                        PVOID Buffer,
                        ULONG BufferSize )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        Success = ReadMemory (AddrStructBase + FieldOffset,
                              Buffer,
                              BufferSize,
                              NULL );

        if (Success != TRUE) {

            dprintf ("Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
    }
    else {

        dprintf ("Cannot get field offset of %s in %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////////////
BOOL
ReadPtrStructFieldVerbose( ULONG64 AddrStructBase,
                           PCHAR StructTypeName,
                           PCHAR StructFieldName,
                           PULONG64 Buffer )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset inside the structure 
    //

    ErrorCode = GetFieldOffset ( StructTypeName,
                                 StructFieldName,
                                 &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        if (ReadPointer(AddrStructBase + FieldOffset, Buffer) == FALSE) {

            dprintf ("Cannot read structure field value at 0x%p\n",
                     AddrStructBase + FieldOffset);
        }
        else {

            Success = TRUE;
        }
    }
    else {

        dprintf ("Cannot get field offset of %s in structure %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////////////////////
ULONG64
GetStackTraceAddress( ULONG StackTraceIndex,
                      ULONG PointerSize )
{
    ULONG64 TraceDatabaseAddress;
    ULONG64 TraceDatabase;
    ULONG64 EntryIndexArray;
    ULONG64 StackTraceAddress;
    ULONG64 StackTraceToDump;
    ULONG NumberOfEntriesAdded;
    ULONG ErrorCode;
    BOOL Success;

    StackTraceToDump = 0;

    //
    // Stack trace database address
    //

    TraceDatabaseAddress = GetExpression("&NTDLL!RtlpStackTraceDataBase");
    
    if ( TraceDatabaseAddress == 0 ) {
        dprintf( "!cs: Unable to resolve NTDLL!RtlpStackTraceDataBase\n"
                 "Please check your symbols\n" );

        goto Done;
    }

    if (ReadPointer (TraceDatabaseAddress, &TraceDatabase ) == FALSE) {

        dprintf( "!cs: Cannot read pointer at NTDLL!RtlpStackTraceDataBase\n" );
        
        goto Done;
    }
    else if (TraceDatabase == 0) {

        dprintf( "NTDLL!RtlpStackTraceDataBase is NULL. Probably the stack traces are not enabled.\n" );

        goto Done;
    }

    //
    // Read the number of entries in the database
    //

    Success = ReadStructFieldVerbose (TraceDatabase,
                                      "NTDLL!_STACK_TRACE_DATABASE",
                                      "NumberOfEntriesAdded",
                                      &NumberOfEntriesAdded,
                                      sizeof( NumberOfEntriesAdded ) );

    if( Success == FALSE ) {

        dprintf( "Cannot read the number of stack traces database entries\n" );
        goto Done;
    }
    else if( StackTraceIndex == 0 ) {

        dprintf( "No stack trace found.\n" );
        goto Done;
    } 
    else if( NumberOfEntriesAdded < StackTraceIndex ) {

        dprintf( "Stack trace index 0x%X is invalid, current number of stack traces is 0x%X\n",
                 StackTraceIndex,
                 NumberOfEntriesAdded );
        goto Done;
    }

    //
    // Find the array of stack traces
    //

    Success = ReadPtrStructFieldVerbose (TraceDatabase,
                                         "NTDLL!_STACK_TRACE_DATABASE",
                                         "EntryIndexArray",
                                         &EntryIndexArray );

    if( Success == FALSE ) {

        dprintf( "Cannot read the stack database array address\n" );
        goto Done;
    }
   
    //
    // Compute the address of our stack trace pointer
    //

    StackTraceAddress = EntryIndexArray - StackTraceIndex * PointerSize;

    //
    // Read the pointer to our trace entry in the array
    //

    if( ReadPointer (StackTraceAddress, &StackTraceToDump) == FALSE) {

        dprintf( "Cannot read stack trace address at 0x%p\n",
                 StackTraceAddress );

        StackTraceToDump = 0;
    }

Done:

    return StackTraceToDump;
}

//////////////////////////////////////////////////////////////////////
VOID
DumpStackTraceAtAddress (ULONG64 StackTraceAddress,
                         ULONG PointerSize)
{
    ULONG64 CrtTraceAddress;
    ULONG64 CodeAddress;
    ULONG64 Displacement;
    ULONG ErrorCode;
    ULONG BackTraceFieldOffset;
    USHORT Depth;
    USHORT CrtEntryIndex;
    BOOL Success;
    CHAR Symbol[ 1024 ];

    //
    // Read the stack trace depth
    //

    Success = ReadStructFieldVerbose (StackTraceAddress,
                                      "NTDLL!_RTL_STACK_TRACE_ENTRY",
                                      "Depth",
                                      &Depth,
                                      sizeof( Depth ));

    if( Success == FALSE ) {

        dprintf ("!cs: Cannot read depth for stack trace at 0x%p\n",
                 StackTraceAddress);

        goto Done;
    }

    //
    // Limit the depth to 20 to protect ourselves from corrupted data
    //

    Depth = __min( Depth, 20 );

    //
    // Get a pointer to the BackTrace array
    //

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_STACK_TRACE_ENTRY",
                                "BackTrace",
                                &BackTraceFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("!cs: Cannot get the BackTrace field offset\n");
        goto Done;
    }

    CrtTraceAddress = StackTraceAddress + BackTraceFieldOffset;

    //
    // Dump this stack trace
    //

    for( CrtEntryIndex = 0; CrtEntryIndex < Depth; CrtEntryIndex += 1 ) {

        if (ReadPointer (CrtTraceAddress, &CodeAddress) == FALSE) {

            dprintf ("!cs: Cannot read address at 0x%p\n",
                     CrtTraceAddress );
        }

        GetSymbol( CodeAddress,
                   Symbol,
                   &Displacement);

        dprintf ("0x%p: %s+0x%I64X\n",
                 CodeAddress,
                 Symbol,
                 Displacement );

        CrtTraceAddress += PointerSize;
    }

Done:
    
    NOTHING;
}

//////////////////////////////////////////////////////////////////////

BOOL
DumpCriticalSection ( ULONG64 AddrCritSec,  
                      ULONG64 AddrEndCritSect,
                      ULONG64 AddrDebugInfo,
                      ULONG PointerSize,
                      BOOL DumpStackTrace )
{
    ULONG64 DebugInfo;
    ULONG64 OtherDebugInfo;
    ULONG64 CritSec;
    ULONG64 SpinCount;
    ULONG64 OwningThread;
    ULONG64 LockSemaphore;
    ULONG64 StackTraceAddress;
    ULONG64 Displacement;
    LONG LockCount;
    LONG RecursionCount;
    USHORT CreatorBackTraceIndex;
    ULONG DebugInfoFieldOffset;
    ULONG CriticalSectionFieldOffset;
    ULONG ErrorCode;
    BOOL HaveGoodSymbols;
    BOOL Success;
    CHAR Symbol[1024];

    HaveGoodSymbols = FALSE;

    //
    // The caller must supply at least one of the 
    // critical section or debug information address.
    //

    if (AddrCritSec == 0 && AddrDebugInfo == 0) {

        dprintf ("Internal debugger extension error: Both critical section and debug info are NULL\n");
        goto Done;
    }

    //
    // Get the field offsets for various structures and check if we have
    // good symbols, with type information.
    //

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION",
                                "DebugInfo",
                                &DebugInfoFieldOffset );

    if (ErrorCode != S_OK)
    {
        dprintf( "Bad symbols for NTDLL (error %u). Aborting.\n",
                 ErrorCode );
        goto Done;
    }

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                "CriticalSection",
                                &CriticalSectionFieldOffset );

    if (ErrorCode != S_OK)
    {
        dprintf( "Bad symbols for NTDLL (error %u). Aborting.\n",
                 ErrorCode );
        goto Done;
    }

    HaveGoodSymbols = TRUE;

    //
    // Read all the rest of the information we need
    //

    CritSec = AddrCritSec;
    DebugInfo = AddrDebugInfo;

    if (AddrCritSec == 0 || (AddrEndCritSect != 0 && AddrDebugInfo != 0)) {

        //
        // Read the critical section address
        //

        if (ReadPointer (AddrDebugInfo + CriticalSectionFieldOffset, &CritSec) == FALSE ) {

            dprintf ("Cannot read the critical section address at 0x%p.\n"
                     "The memory is probably paged out or the active critical section list is corrupted.\n",
                     AddrDebugInfo + CriticalSectionFieldOffset );

            //
            // We don't have any useful information to dump 
            // since we can't read the address of the critical section structure.
            //
            // Just display the stack trace since the active critical section list
            // might be corrupted.
            //

            DumpStackTrace = TRUE;

            goto DisplayStackTrace;
        }

        if (AddrCritSec != 0 ) {

            //
            // We are dumpig all the critical sections in a range.
            //

            if (CritSec < AddrCritSec || CritSec > AddrEndCritSect) {

                //
                // We don't want to display this critical section
                // because it is out of the range.
                //

                goto Done;
            }
        }
        
        //
        // Read the the critical section address from the DebugInfo
        //

        dprintf( "-----------------------------------------\n" );

        dprintf ("DebugInfo          = 0x%p\n",
                 AddrDebugInfo );

        GetSymbol( CritSec,
                   Symbol,
                   &Displacement);

        dprintf ("Critical section   = 0x%p (%s+0x%I64X)\n",
                 CritSec,
                 Symbol,
                 Displacement );
    }
    else {
        
        //
        // We have the critical section address from our caller
        //

        GetSymbol( CritSec,
                   Symbol,
                   &Displacement);

        dprintf( "-----------------------------------------\n" );

        dprintf ("Critical section   = 0x%p (%s+0x%I64X)\n",
                 AddrCritSec, 
                 Symbol,
                 Displacement );
        
        if (DebugInfo == 0) {

            //
            // Read the DebugInfo address from the critical section structure
            //

            if (ReadPointer (AddrCritSec + DebugInfoFieldOffset, &DebugInfo) == FALSE) {

                dprintf ("Cannot read DebugInfo adddress at 0x%p. Possible causes:\n"
                         "\t- The critical section is not initialized, deleted or corrupted\n"
                         "\t- The critical section was a global variable in a DLL that was unloaded\n"
                         "\t- The memory is paged out\n",
                         AddrCritSec + DebugInfoFieldOffset );
            }
        }

        if (DebugInfo != 0) {

            dprintf ("DebugInfo          = 0x%p\n",
                     DebugInfo );
        }
        else {

            dprintf ("Uninitialized or deleted.\n");
        }
    }

    //
    // Read all the rest of the fields of this critical section
    //

    Success = ReadStructFieldVerbose (CritSec,
                                      "NTDLL!_RTL_CRITICAL_SECTION",
                                      "LockCount",
                                      &LockCount,
                                      sizeof( LockCount ) );

    if( Success != TRUE )
    {
        //
        // Couldn't read the LockCount so we cannot say if it's 
        // locked or not. This can happen especially in stress where everything is
        // paged out because of memory pressure.
        //

        dprintf ("Cannot determine if the critical section is locked or not.\n" );

        goto DisplayStackTrace;
    }
    
    //
    // Determine if the critical section is locked or not
    //

    if (LockCount == -1) {

        //
        // The critical section is not locked 
        //

        dprintf ("NOT LOCKED\n");
    }
    else {

        //
        // The critical section is currently locked
        //

        dprintf ("LOCKED\n"
                 "LockCount          = 0x%X\n",
                 LockCount );

        //
        // OwningThread 
        //

        Success = ReadPtrStructFieldVerbose( CritSec,
                                             "NTDLL!_RTL_CRITICAL_SECTION",
                                             "OwningThread",
                                             &OwningThread);

        if (Success != FALSE)
        {
            dprintf ("OwningThread       = 0x%p\n",
                     OwningThread );
        }

        //
        // RecursionCount 
        //

        Success = ReadStructFieldVerbose( CritSec,
                                          "NTDLL!_RTL_CRITICAL_SECTION",
                                          "RecursionCount",
                                          &RecursionCount,
                                          sizeof( RecursionCount ) );

        if (Success != FALSE)
        {
            dprintf ("RecursionCount     = 0x%X\n",
                     RecursionCount);
        }
    }

    //
    // LockSemaphore 
    //

    Success = ReadStructFieldVerbose (CritSec,
                                      "NTDLL!_RTL_CRITICAL_SECTION",
                                      "LockSemaphore",
                                      &LockSemaphore,
                                      sizeof( LockSemaphore ));

    if (Success != FALSE)
    {
        dprintf ("LockSemaphore      = 0x%X\n",
                 LockSemaphore );
    }

    //
    // SpinCount 
    //

    Success = ReadPtrStructFieldVerbose (CritSec,
                                         "NTDLL!_RTL_CRITICAL_SECTION",
                                         "SpinCount",
                                         &SpinCount);

    if (Success != FALSE)
    {
        dprintf ("SpinCount          = 0x%p\n",
                 SpinCount );
    }

    //
    // Simple checks for orphaned critical sections
    //

    if (AddrDebugInfo != 0) {

        //
        // AddrDebugInfo is a DebugInfo address from the active list.
        // Verify that the critical section's DebugInfo is pointing 
        // back to AddrDebugInfo.
        //

        Success = ReadPtrStructFieldVerbose (CritSec,
                                             "NTDLL!_RTL_CRITICAL_SECTION",
                                             "DebugInfo",
                                             &OtherDebugInfo );

        if (Success != FALSE && OtherDebugInfo != AddrDebugInfo)
        {
            dprintf ("\nWARNING: critical section DebugInfo = 0x%p doesn't point back\n"
                     "to the DebugInfo found in the active critical sections list = 0x%p.\n"
                     "The critical section was probably reused without calling DeleteCriticalSection.\n\n",
                     OtherDebugInfo,
                     AddrDebugInfo );

            Success = ReadStructFieldVerbose (OtherDebugInfo,
                                              "NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                              "CreatorBackTraceIndex",
                                              &CreatorBackTraceIndex,
                                              sizeof( CreatorBackTraceIndex ) );

            StackTraceAddress = GetStackTraceAddress (CreatorBackTraceIndex,
                                                      PointerSize );

            if (StackTraceAddress != 0)
            {
                dprintf ("\nStack trace for DebugInfo = 0x%p:\n\n",
                         OtherDebugInfo );

                DumpStackTraceAtAddress (StackTraceAddress,
                                         PointerSize);
            }

            //
            // Dump the second stack trace too
            // 

            DumpStackTrace = TRUE;
        }
    }

DisplayStackTrace:

    if (!DumpStackTrace || DebugInfo == 0) {

        goto Done;
    }

    //
    // Dump the initialization stack trace for this critical section
    //

    Success = ReadStructFieldVerbose (DebugInfo,
                                      "NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                      "CreatorBackTraceIndex",
                                      &CreatorBackTraceIndex, 
                                      sizeof (CreatorBackTraceIndex));

    if (Success != FALSE) {

        StackTraceAddress = GetStackTraceAddress (CreatorBackTraceIndex,
                                                  PointerSize );

        if (StackTraceAddress != 0)
        {
            dprintf ("\n\nStack trace for DebugInfo = 0x%p:\n\n",
                     DebugInfo );

            DumpStackTraceAtAddress (StackTraceAddress,
                                     PointerSize);
        }
    }

Done:
    
    return HaveGoodSymbols;
}

/////////////////////////////////////////////////////////////////////////////
ULONG CriticalSectionFieldOffset;
ULONG DebugInfoFieldOffset;
ULONG LeftChildFieldOffset;
ULONG RightChildFieldOffset;

ULONG EnterThreadFieldOffset;
ULONG WaitThreadFieldOffset;
ULONG TryEnterThreadFieldOffset;
ULONG LeaveThreadFieldOffset;


BOOL
DumpCSTreeRecursively (ULONG Level,
                       ULONG64 TreeRoot)
{
    ULONG64 CriticalSection;
    ULONG64 LeftChild;
    ULONG64 RightChild;
    ULONG64 DebugInfo;
    ULONG64 EnterThread;
    ULONG64 WaitThread;
    ULONG64 TryEnterThread;
    ULONG64 LeaveThread;
    ULONG64 ErrorCode;
    BOOL Continue = TRUE;

    if (CheckControlC()) {

        Continue = FALSE;
        goto Done;
    }

    //
    // Read the current CS address and dump information about it.
    // 

    if (ReadPointer (TreeRoot + CriticalSectionFieldOffset, &CriticalSection) == FALSE) {

        dprintf ("Cannot read CriticalSection address at %p\n",
                  TreeRoot + CriticalSectionFieldOffset);
        goto Done;
    }

    if (ReadPointer (TreeRoot + DebugInfoFieldOffset, &DebugInfo) == FALSE) {

        dprintf ("Cannot read DebugInfo address at %p\n",
                  TreeRoot + DebugInfoFieldOffset);
        goto Done;
    }

    //
    // Read the left child address.
    //

    if (ReadPointer (TreeRoot + LeftChildFieldOffset, &LeftChild) == FALSE) {

        dprintf ("Cannot read left child address at %p\n",
                  TreeRoot + LeftChildFieldOffset);
        goto Done;
    }

    //
    // Read the right child address.
    //

    if (ReadPointer (TreeRoot + RightChildFieldOffset, &RightChild) == FALSE) {

        dprintf ("Cannot read right child address at %p\n",
                  TreeRoot + RightChildFieldOffset);
        goto Done;
    }

    //
    // Dump the information about the current node.
    //

    dprintf ("%5u %p %p %p ",
             Level,
             TreeRoot,
             CriticalSection,
             DebugInfo);

    if (EnterThreadFieldOffset != 0 ) {

        //
        // Read the EnterThread
        //

        if (ReadPointer (TreeRoot + EnterThreadFieldOffset, &EnterThread) == FALSE) {

            dprintf ("Cannot read EnterThread at %p\n",
                      TreeRoot + EnterThreadFieldOffset);

            goto OlderThan3591;
        }

        //
        // Read the WaitThread
        //

        if (ReadPointer (TreeRoot + WaitThreadFieldOffset, &WaitThread) == FALSE) {

            dprintf ("Cannot read WaitThread at %p\n",
                      TreeRoot + WaitThreadFieldOffset);

            goto OlderThan3591;
        }

        //
        // Read the TryEnterThread
        //

        if (ReadPointer (TreeRoot + TryEnterThreadFieldOffset, &TryEnterThread) == FALSE) {

            dprintf ("Cannot read TryEnterThread at %p\n",
                      TreeRoot + TryEnterThreadFieldOffset);

            goto OlderThan3591;
        }

        //
        // Read the LeaveThread
        //

        if (ReadPointer (TreeRoot + LeaveThreadFieldOffset, &LeaveThread) == FALSE) {

            dprintf ("Cannot read right LeaveThread at %p\n",
                      TreeRoot + LeaveThreadFieldOffset);

            goto OlderThan3591;
        }

        dprintf ("%8p %8p %8p %8p\n",
                 EnterThread,
                 WaitThread,
                 TryEnterThread,
                 LeaveThread);
    }
    else {

        dprintf ("\n");
    }

OlderThan3591:

    //
    // Dump the left subtree.
    //

    if (LeftChild != 0) {

        Continue = DumpCSTreeRecursively (Level + 1,
                                          LeftChild);

        if (Continue == FALSE) {
            goto Done;
        }
    }

    //
    // Dump the right subtree.
    //

    if (RightChild != 0) {

        Continue = DumpCSTreeRecursively (Level + 1,
                                          RightChild);

        if (Continue == FALSE) {
            goto Done;
        }
    }

Done:

    return Continue;
}


/////////////////////////////////////////////////////////////////////////////
VOID
DisplayHelp( VOID )
{
    dprintf( "!cs [-s]                      - dump all the active critical sections in the current process.\n" );
    dprintf( "!cs [-s] address              - dump critical section at this address.\n" );
    dprintf( "!cs [-s] address1 address2    - dump all the active critical sections in this range.\n" );
    dprintf( "!cs [-s] -d address           - dump critical section corresponding to DebugInfo at this address.\n" );
    dprintf( "\n\"-s\" will dump the critical section initialization stack trace if it's available.\n" );
}

/////////////////////////////////////////////////////////////////////////////
DECLARE_API( cs )

/*++

Routine Description:

    Dump critical sections (both Kernel and User Debugger)

Arguments:

    args - [address] [options]

Return Value:

    None

--*/
{
    ULONG64 AddrCritSec;
    ULONG64 AddrEndCritSect;
    ULONG64 AddrDebugInfo;
    ULONG64 AddrListHead;
    ULONG64 ListHead;
    ULONG64 Next;
    ULONG64 AddrTreeRoot;
    ULONG64 TreeRoot = 0;
    LPCSTR Current;
    LPCSTR NextParam;
    BOOL StackTraces = FALSE;
    BOOL UseTree = FALSE;
    BOOL HaveGoodSymbols;
    ULONG ErrorCode;
    ULONG ProcessLocksListFieldOffset;
    ULONG Level;
    ULONG PointerSize;

    INIT_API();

    AddrDebugInfo = 0;
    AddrCritSec = 0;
    AddrEndCritSect = 0;

    //
    // Parse the command line arguments for:
    //
    // -s : dump initialization stack traces
    // -d : find the critical section using a DebugInfo pointer
    //

    for (Current = args; *Current != '\0'; Current += 1) {

        if (*Current == '-') {

            Current += 1;
            switch (*Current) {
                case '?':
                case 'h':
                case 'H':
                    
                    //
                    // Need some help.
                    //
                    
                    DisplayHelp();
                    
                    goto Done;


                case 's':
                case 'S':
                    
                    //
                    // Dump stack traces
                    //

                    StackTraces = TRUE;

                    if(*( Current + 1 ) != '\0') {

                        Current += 1;
                    }

                    break;

                case 't':
                case 'T':
                    
                    //
                    // Use the critical section tree
                    //

                    UseTree = TRUE;

                    if(*( Current + 1 ) != '\0') {

                        Current += 1;
                    }

                    do {

                        Current += 1;
                    } 
                    while (*Current == ' ');

                    if (*Current != '\0') {

                        TreeRoot = GetExpression(Current);
                    }

                    break;

                case 'd':
                case 'D':

                    //
                    // The next parameter should be the DebugInfo
                    //

                    do {

                        Current += 1;
                    } 
                    while (*Current == ' ');

                    AddrDebugInfo = GetExpression(Current);

                    if (AddrDebugInfo == 0) {

                        dprintf("!cs: expected DebugInfo address after -d\n");

                        //
                        // Decrement Current since the for loop will increment it again.
                        // Otherwise, if this is the end of the string we will overrun
                        // the args buffer.
                        //

                        Current -= 1;

                        goto Done;
                    }
                    else {

                        goto DoneParsingArguments;
                    }

                    break;

                case ' ':
                    Current += 1;
                    break;
        
                default:
                    dprintf ("!cs: invalid option flag '-%c'\n", 
                             *Current);
                    break;
            }
        }
        else if(*Current == ' ') {

            Current ++;
        }
        else {

            break;
        }
    }

DoneParsingArguments:

    //
    // Get the size of a pointer
    //

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        PointerSize = 4;
    }
    else {

        PointerSize = 8;
    }

    if( AddrDebugInfo == 0 && UseTree == FALSE )
    {
        //
        // If the user doesn't want us to use a DebugInfo
        // then he might have asked us to dump a critical section
        //

        if (*Current != '\0')
        {
            AddrCritSec = GetExpression(Current);

            if (AddrCritSec != 0) {

                //
                // We might have an additional argument if the user
                // wants to dump all the active critical sections in 
                // an address range.
                //

                NextParam = strchr (Current,
                                    ' ' );

                if (NextParam != NULL) {

                    AddrEndCritSect = GetExpression(NextParam);
                }
            }
        }
    }

    //
    // Start the real work
    //

    if ((AddrCritSec != 0 && AddrEndCritSect == 0) || AddrDebugInfo != 0)
    {
        //
        // The user wants details only about this critical section
        //

        DumpCriticalSection (AddrCritSec,        // critical section address
                             0,                  // end of address range if we are searching for critical sections
                             AddrDebugInfo,      // debug info address
                             PointerSize,
                             StackTraces );      // dump the stack trace
    }
    else
    {
        if (UseTree == FALSE) {

            //
            // Parse all the critical sections list
            //

            //
            // Get the offset of the list entry in the DebugInfo structure
            //

            ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                        "ProcessLocksList",
                                        &ProcessLocksListFieldOffset );

            if (ErrorCode != S_OK) {

                dprintf ("Bad symbols for NTDLL (error %u). Aborting.\n",
                         ErrorCode );
                goto Done;
            }

            //
            // Locate the address of the list head.
            //

            AddrListHead = GetExpression ("&NTDLL!RtlCriticalSectionList");
        
            if (AddrListHead == 0 ) {

                dprintf( "!cs: Unable to resolve NTDLL!RtlCriticalSectionList\n"
                         "Please check your symbols\n" );

                goto Done;
            }

            //
            // Read the list head
            //

            if (ReadPointer(AddrListHead, &ListHead) == FALSE) {

                dprintf( "!cs: Unable to read memory at NTDLL!RtlCriticalSectionList\n" );
                goto Done;
            }

            Next = ListHead;

            while (Next != AddrListHead) {

                if (CheckControlC()) {

                    break;
                }

                HaveGoodSymbols = DumpCriticalSection (
                                     AddrCritSec,                             // critical section address
                                     AddrEndCritSect,                         // end of address range if we are searching for critical sections
                                     Next - ProcessLocksListFieldOffset,      // debug info address
                                     PointerSize,
                                     StackTraces );                           // dump the stack trace

                //
                // Read the pointer to Next element from the list
                //

                if( HaveGoodSymbols == FALSE )
                {
                    break;
                }

                if (ReadPointer (Next, &Next) == FALSE) {

                    dprintf ("!cs: Unable to read list entry at 0x%p - aborting.\n",
                             Next);
                    goto Done;
                }
            }
        }
        else {

            //
            // Parse all the critical section tree in verifier.dll.
            //

            if (TreeRoot == 0) {

                AddrTreeRoot = GetExpression ("&verifier!CritSectSplayRoot");
        
                if (AddrTreeRoot == 0 ) {

                    dprintf( "!cs: Unable to resolve verifier!CritSectSplayRoot\n"
                             "Please check your symbols\n" );

                    goto Done;
                }

                //
                // Read the tree root.
                //

                if (ReadPointer(AddrTreeRoot, &TreeRoot) == FALSE) {

                    dprintf( "!cs: Unable to read memory at verifier!CritSectSplayRoot\n" );
                    goto Done;
                }
            }

            dprintf ("Tree root %p\n",
                     TreeRoot);

            //
            // Get the offset of the CriticalSection in the CRITICAL_SECTION_SPLAY_NODE structure.
            //

            ErrorCode = GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                        "CriticalSection",
                                        &CriticalSectionFieldOffset );

            if (ErrorCode != S_OK) {

                dprintf ("Bad symbols for verifier.dll (error %u). Aborting.\n",
                         ErrorCode );
                goto Done;
            }

            //
            // Get the offset of the DebugInfo in the CRITICAL_SECTION_SPLAY_NODE structure.
            //

            ErrorCode = GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                        "DebugInfo",
                                        &DebugInfoFieldOffset );

            if (ErrorCode != S_OK) {

                dprintf ("Bad symbols for verifier.dll (error %u). Aborting.\n",
                         ErrorCode );
                goto Done;
            }

            //
            // Get the offset of the LeftChild in the CRITICAL_SECTION_SPLAY_NODE structure.
            //

            ErrorCode = GetFieldOffset ("verifier!_RTL_SPLAY_LINKS",
                                        "LeftChild",
                                        &LeftChildFieldOffset );

            if (ErrorCode != S_OK) {

                dprintf ("Bad symbols for verifier.dll (error %u). Aborting.\n",
                         ErrorCode );
                goto Done;
            }

            //
            // Get the offset of the RightChild in the CRITICAL_SECTION_SPLAY_NODE structure.
            //

            ErrorCode = GetFieldOffset ("verifier!_RTL_SPLAY_LINKS",
                                        "RightChild",
                                        &RightChildFieldOffset );

            if (ErrorCode != S_OK) {

                dprintf ("Bad symbols for verifier.dll (error %u). Aborting.\n",
                         ErrorCode );
                goto Done;
            }

            //
            // Get the offset of the EnterThread, WaitThread, TryEnterThread, LeaveThread fields 
            // in the CRITICAL_SECTION_SPLAY_NODE structure.
            // These fields were added after build 3590 (.NET Server Beta 3).
            //

            ErrorCode = GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                        "EnterThread",
                                        &EnterThreadFieldOffset );

            if (ErrorCode == S_OK) {

                GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                "WaitThread",
                                &WaitThreadFieldOffset );

                GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                "TryEnterThread",
                                &TryEnterThreadFieldOffset );

                GetFieldOffset ("verifier!_CRITICAL_SECTION_SPLAY_NODE",
                                "LeaveThread",
                                &LeaveThreadFieldOffset );
            }
            else {

                //
                // These fields are either not defined or we have a problem with ths symbols.
                //

                EnterThreadFieldOffset = 0;
            }

            //
            // Dump the tree recursively.
            //
            
            if (PointerSize == 4 ) {

                dprintf ("Level %8s %8s %8s %8s %8s %8s %8s\n",
                         "Node",
                         "CS",
                         "Debug",
                         "Enter",
                         "Wait",
                         "TryEnter",
                         "Leave");

                dprintf ("--------------------------------------------------------------------\n");
            }
            else {

                dprintf ("Level %16s %16s %16s %8s %8s %8s %8s\n",
                         "Node",
                         "CS",
                         "Debug",
                         "Enter",
                         "Wait",
                         "TryEnter",
                         "Leave");
                
                dprintf ("--------------------------------------------------------------------------------------------\n");
            }
                        
            Level = 0;

            DumpCSTreeRecursively (Level,
                                   TreeRoot);
                                   
        }
    }

Done:

    EXIT_API();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\gflagext.c ===
#include "precomp.h"
#pragma hdrstop
#include <ntexapi.dbg>

DECLARE_API( gflag )

/*++

Routine Description:

    This function is called as an NTSD extension to dump or modify
    the contents of the NtGlobalFlag variable in NTDLL

    Called as:

        !gflag [value]

    If a value is not given then displays the current bits set in
    NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the
    following:

        -? - displays a list of valid flag abbreviations
        number - 32-bit number that becomes the new value stored into
                 NtGlobalFlag
        +number - specifies one or more bits to set in NtGlobalFlag
        +abbrev - specifies a single bit to set in NtGlobalFlag
        -number - specifies one or more bits to clear in NtGlobalFlag
        -abbrev - specifies a single bit to clear in NtGlobalFlag

Return Value:

    None.

--*/

{
    ULONG gflagOffset;
    ULONG64 pebAddress;
    ULONG64 pNtGlobalFlag = 0;
    ULONG ValidBits = FLG_USERMODE_VALID_BITS;
    ULONG i;
    ULONG OldGlobalFlags;
    ULONG NewGlobalFlagsClear;
    ULONG NewGlobalFlagsSet;
    ULONG NewGlobalFlags;
    LPSTR s, Arg;

    pNtGlobalFlag = GetExpression("nt!NtGlobalFlag");
    ValidBits = FLG_VALID_BITS;

    //
    // If we could not get the global variable from the kernel, try from the
    // PEB for user mode
    //

    if (!pNtGlobalFlag)
    {
        GetPebAddress(0, &pebAddress);

        if (pebAddress)
        {
            if (GetFieldOffset("nt!_PEB", "NtGlobalFlag", &gflagOffset))
            {
                dprintf("Could not find NtGlobalFlag in nt!_PEB\n");
                return E_FAIL;
            }
            pNtGlobalFlag = gflagOffset + pebAddress;
            ValidBits = FLG_USERMODE_VALID_BITS;
        }
    }

    if (!pNtGlobalFlag)
    {
        dprintf( "Unable to get address of NtGlobalFlag variable" );
        return E_FAIL;
    }

    if (!ReadMemory(pNtGlobalFlag,
                    &OldGlobalFlags,
                    sizeof(OldGlobalFlags),
                    NULL))
    {
        dprintf( "Unable to read contents of NtGlobalFlag variable at %p\n", pNtGlobalFlag );
        return E_FAIL;
    }

    OldGlobalFlags &= ValidBits;

    s = (LPSTR)args;
    if (!s)
    {
        s = "";
    }

    NewGlobalFlagsClear = 0;
    NewGlobalFlagsSet = 0;
    while (*s)
    {
        while (*s && *s <= ' ')
        {
            s += 1;
        }

        Arg = s;
        if (!*s)
        {
            break;
        }

        while (*s && *s > ' ')
        {
            s += 1;
        }

        if (*s)
        {
            *s++ = '\0';
        }

        if (!strcmp( Arg, "-?" ))
        {
            dprintf( "usage: !gflag [-? | flags]\n" );
            dprintf( "Flags may either be a single hex number that specifies all\n" );
            dprintf( "32-bits of the GlobalFlags value, or it can be one or more\n" );
            dprintf( "arguments, each beginning with a + or -, where the + means\n" );
            dprintf( "to set the corresponding bit(s) in the GlobalFlags and a -\n" );
            dprintf( "means to clear the corresponding bit(s).  After the + or -\n" );
            dprintf( "may be either a hex number or a three letter abbreviation\n" );
            dprintf( "for a GlobalFlag.  Valid abbreviations are:\n" );
            for (i=0; i<32; i++) {
                if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                    GlobalFlagInfo[i].Abbreviation != NULL)
                {
                    dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation,
                                                      GlobalFlagInfo[i].Description
                           );
                }
            }

            return E_FAIL;
        }

        if (*Arg == '+' || *Arg == '-')
        {
            if (strlen(Arg+1) == 3)
            {
                for (i=0; i<32; i++)
                {
                    if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                        !_stricmp( GlobalFlagInfo[i].Abbreviation, Arg+1 ))
                    {
                        if (*Arg == '-')
                        {
                            NewGlobalFlagsClear |= GlobalFlagInfo[i].Flag;
                        }
                        else
                        {
                            NewGlobalFlagsSet |= GlobalFlagInfo[i].Flag;
                        }

                        Arg += 4;
                        break;
                    }
                }

                if (*Arg != '\0')
                {
                    dprintf( "Invalid flag abbreviation - '%s'\n", Arg );
                    return E_FAIL;
                }
            }

            if (*Arg != '\0')
            {
                if (*Arg++ == '-')
                {
                    NewGlobalFlagsClear |= strtoul( Arg, &Arg, 16 );
                }
                else
                {
                    NewGlobalFlagsSet |= strtoul( Arg, &Arg, 16 );
                }
            }
        }
        else
        {
            NewGlobalFlagsSet = strtoul( Arg, &Arg, 16 );
            break;
        }
    }

    NewGlobalFlags = (OldGlobalFlags & ~NewGlobalFlagsClear) | NewGlobalFlagsSet;
    NewGlobalFlags &= ValidBits;
    if (NewGlobalFlags != OldGlobalFlags)
    {
        if (!WriteMemory( pNtGlobalFlag,
                          &NewGlobalFlags,
                          sizeof( NewGlobalFlags ),
                          NULL))
        {
            dprintf( "Unable to store new global flag settings.\n" );
            return E_FAIL;
        }

        dprintf( "New NtGlobalFlag contents: 0x%08x\n", NewGlobalFlags );
        OldGlobalFlags = NewGlobalFlags;
    }
    else
    {
        dprintf( "Current NtGlobalFlag contents: 0x%08x\n", OldGlobalFlags );
    }

    for (i=0; i<32; i++)
    {
        if (OldGlobalFlags & GlobalFlagInfo[i].Flag)
        {
            dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\exts.cpp ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;
ULONG   g_TargetBuild;
ULONG   g_Qualifier;
ULONG64 g_SharedUserData;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;

#define SKIP_WSPACE(s)  while (*s && (*s == ' ' || *s == '\t')) {++s;}

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        PDEBUG_SYSTEM_OBJECTS3 DebugSystem;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                    DEBUG_DATA_MmPageSize, &Page,
                    sizeof(Page), NULL)) == S_OK)
                {
                    PageSize = (ULONG)(ULONG_PTR)Page;
                }

                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                    DEBUG_DATA_SharedUserData, &g_SharedUserData,
                    sizeof(Page), NULL)) != S_OK)
                {
                    g_SharedUserData = (ULONG64) 0;
                }

                DebugDataSpaces->Release();
            }
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                ULONG Platform, MajorVer, MinorVer, SrvPack;

                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &g_Qualifier)) == S_OK)
                {
                }
                if ((Hr = DebugControl->GetSystemVersion(&Platform, &MajorVer,
                                                         &MinorVer, NULL,
                                                         0, NULL,
                                                         &SrvPack, NULL,
                                                         0, NULL)) == S_OK)
                {
                    g_TargetBuild = MinorVer;
                } else
                {
                    // for some reason we failed, assume target is a recent build
                    g_TargetBuild = 3600;
                }

                DebugControl->Release();
            }
            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


HRESULT
GetCurrentProcessor(
    IN PDEBUG_CLIENT Client,
    OPTIONAL OUT PULONG pProcessor,
    OPTIONAL OUT PHANDLE phCurrentThread
    )
{
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if (Client) {
        if (Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                   (void **)&DebugSystem) != S_OK) {
            return E_FAIL;
        }

        DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
        if (phCurrentThread) {
            *phCurrentThread = (HANDLE) hCurrentThread;
        }
        if (pProcessor) {
            *pProcessor = (ULONG) hCurrentThread - 1;
        }

        DebugSystem->Release();
        return S_OK;
    }
    if (phCurrentThread) {
        *phCurrentThread = NULL;
    }
    if (pProcessor) {
        *pProcessor = 0;
    }
    return E_FAIL;


}

HRESULT
GetCurrentProcessName( PSTR ProcessBuffer, ULONG BufferSIze )
{
    if (g_TargetClass == DEBUG_CLASS_USER_WINDOWS)
    {
        return g_ExtSystem->GetCurrentProcessExecutableName(ProcessBuffer, BufferSIze, NULL);
    }

    return S_FALSE;
}


typedef struct _LIST_TYPE_PARAMS {
    PCHAR Command;
    PCHAR CommandArgs;
    ULONG FieldOffset;
    ULONG nElement;
} LIST_TYPE_PARAMS, *PLIST_TYPE_PARAMS;

ULONG
ListCallback(
    PFIELD_INFO Field,
    PVOID Context
    )
{
    CHAR  Execute[MAX_PATH];
    PCHAR Buffer;
    PLIST_TYPE_PARAMS pListParams = (PLIST_TYPE_PARAMS) Context;


    // Execute command
    sprintf(Execute,
            "%s %I64lx %s",
            pListParams->Command,
            Field->address,// - pListParams->FieldOffset,
            pListParams->CommandArgs);
    g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Execute,DEBUG_EXECUTE_DEFAULT);
    dprintf("\n");

    if (CheckControlC()) {
        return TRUE;
    }

    return FALSE;
}

/*
    !list [-type <Type>]  [-x "<Command>"] <address>

    This dumps out a list starting at ginve <address>

    <Type>      If types is specified, it'll list that particular type accoring to
                the given field.

    <Command>   If specified it'll execute the command for every list element.

*/
DECLARE_API ( list )
{
    CHAR  Command[MAX_PATH], CmdArgs[MAX_PATH];
    CHAR  Type[MAX_PATH];
    CHAR  Field[MAX_PATH];
    ULONG64 Start;
    ULONG   i, Offset, Commandlen;
    ULONG64 Next, Current;
    LIST_TYPE_PARAMS ListParams;

    ZeroMemory(Type, sizeof(Type));
    ZeroMemory(Field, sizeof(Field));
    ZeroMemory(Command, sizeof(Command));
    CmdArgs[0] = 0;
    Start = 0;
    while (args && *args) {
        SKIP_WSPACE(args);

        if (*args == '-' || *args == '/') {
            ++args;
            if (*args == 't') {
                PCHAR Dot;

                args++;
                SKIP_WSPACE(args);

                Dot = strchr(args, '.');
                if (Dot) {
                    if ((ULONG) (ULONG_PTR) (Dot-args) < sizeof(Type))
                    {
                        strncpy(Type, args, (ULONG) (ULONG_PTR) (Dot-args));
                    }

                    Dot++;
                    i=0;
                    while (*Dot && (i < MAX_PATH-1) && (*Dot != ' ') && (*Dot != '\t'))
                           Field[i++] = *Dot++;
                    args = Dot;
                }
            } else if (*args == 'x') {
                ++args;

                SKIP_WSPACE(args);
                i=0;
                if (*args == '"') {
                    ++args;
                    while (*args && (i < MAX_PATH-1) && (*args != '"'))
                        Command[i++] = *args++;
                    ++args;
                } else {
                    dprintf("Invalid command specification. See !list -h\n");
                    return E_INVALIDARG;
                }
            } else if (*args == 'a') {
                ++args;

                SKIP_WSPACE(args);
                i=0;
                if (*args == '"') {
                    ++args;
                    while (*args && (i < MAX_PATH-1) && (*args != '"'))
                        CmdArgs[i++] = *args++;
                    ++args;
                    CmdArgs[i] = 0;
                } else {
                    dprintf("Invalid command argument specification. See !list -h\n");
                    return E_INVALIDARG;
                }
            } else if (*args == 'h' || *args == '?') {
                dprintf("Usage: !list -t [mod!]TYPE.Field <Start-Address>\n"
                        "             -x \"Command-for-each-element\"\n"
                        "             -a \"Command-arguments\"\n"
                        "             -h\n"
                        "Command after -x is executed for each list element. Its first argument is\n"
                        "list-head address and remaining arguments are specified after -a\n"
                        "eg. !list -t MYTYPE.l.Flink -x \"dd\" -a \"l2\" 0x6bc00\n"
                        "     dumps first 2 dwords in list of MYTYPE at 0x6bc00\n\n"
                        );
                return S_OK;
            } else {
                dprintf("Invalid flag -%c in !list\n", *args ? *args : ' ');
                return E_INVALIDARG;
            }
        } else {
            if (!GetExpressionEx(args, &Start, &args)) {
                dprintf("Invalid expression in %s\n", args);
                return E_FAIL;
            }
        }
    }

    Offset = 0;
    if (!Command[0]) {
        strcat(Command, "dp");
    }

    if (Type[0] && Field[0]) {

        if (GetFieldOffset(Type, Field, &Offset)) {
            dprintf("GetFieldOffset failed for %s.%s\n", Type, Field);
            return E_FAIL;
        }


        ListParams.Command = Command;
        ListParams.CommandArgs = CmdArgs;
        ListParams.FieldOffset = Offset;
        ListParams.nElement = 0;

        INIT_API();

        ListType(Type, Start, FALSE, Field, (PVOID) &ListParams, &ListCallback );

        EXIT_API();
        return S_OK;

    }
    Current = Start;
    Next = 0;
    INIT_API();

    while (Next != Start) {
        CHAR  Execute[MAX_PATH];
        PCHAR Buffer;

        // Execute command
        sprintf(Execute, "%s %I64lx %s", Command, Current, CmdArgs);
        g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Execute,DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");

        if (!ReadPointer(Current + Offset, &Next)) {
            dprintf("Cannot read next element at %p\n",
                    Current + Offset);
            break;
        }
        if (!Next) {
            break;
        }
        Next -= Offset;
        Current = Next;
        if (CheckControlC()) {
            break;
        }
    }

    EXIT_API();


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop
ULONG PageSize;

//
// Page heap extension function (defined in heappagx.c).
//

VOID
PageHeapExtension(
    IN PCSTR lpArgumentString
    );
VOID
DebugPageHeapExtensionXP(
    IN PCSTR lpArgumentString
    );

BOOL
GetPageSize()
{
    KDDEBUGGER_DATA64 kdd;

    if (GetDebuggerData('GBDK', &kdd, sizeof(kdd))) {
        //
        // Kernel target
        //
        PageSize =  (ULONG) kdd.MmPageSize;
        return TRUE;
    } else {
        //
        // User maode
        //
        SYSTEM_BASIC_INFORMATION sysInfo;
        if (!NtQuerySystemInformation( SystemBasicInformation,
                                       &sysInfo,
                                       sizeof(sysInfo),
                                       NULL)) {
            PageSize = sysInfo.PageSize;
            return TRUE;
        }
    }
    return FALSE;

}

/*
#if defined(TARGET_i386)
#define STACK_TRACE_DATABASE_SUPPORT 1
#elif defined(TARGET_ALPHA)
#define STACK_TRACE_DATABASE_SUPPORT 0
#elif i386
#define STACK_TRACE_DATABASE_SUPPORT 1
#else
#define STACK_TRACE_DATABASE_SUPPORT 0
#endif
*/
#define STACK_TRACE_DATABASE_SUPPORT 0

#if 0
// BUGBUG This was X86 specific := HOST_i386
ULONG
xRtlCompareMemoryUlong(
    PVOID Source,
    ULONG Length,
    ULONG Pattern
    )
{
    ULONG CountLongs;
    PULONG p = (PULONG)Source;
    PCHAR p1, p2;

    if (((ULONG)p & (sizeof( ULONG )-1)) ||
        (Length & (sizeof( ULONG )-1))
       ) {
        return( 0 );
        }

    CountLongs = Length / sizeof( ULONG );
    while (CountLongs--) {
        if (*p++ != Pattern) {
            p1 = (PCHAR)(p - 1);
            p2 = (PCHAR)&Pattern;
            Length = p1 - (PCHAR)Source;
            while (*p1++ == *p2++) {
                if (p1 > (PCHAR)p) {
                    break;
                    }

                Length++;
                }
            }
        }

    return( Length );
}

#define RtlCompareMemoryUlong  xRtlCompareMemoryUlong
#define RtlCompareMemory       memcmp

#endif

#define STOP_ON_ALLOC 1
#define STOP_ON_REALLOC 2
#define STOP_ON_FREE 3


typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;


typedef struct _HEAP_STATE {
    BOOLEAN ShowHelp;
    BOOLEAN ExitDumpLoop;
    BOOLEAN ComputeSummary;
    BOOLEAN ValidateHeap;
    BOOLEAN DumpHeapEntries;
    BOOLEAN DumpHeapTags;
    BOOLEAN DumpHeapPseudoTags;
    BOOLEAN DumpGlobalTags;
    BOOLEAN DumpHeapSegments;
    BOOLEAN DumpHeapFreeLists;
    BOOLEAN DumpStackBackTrace;
    BOOLEAN SetStopOnBreakPoint;
    BOOLEAN RemoveStopOnBreakPoint;
    BOOLEAN EnableHeapChecking;
    BOOLEAN EnableHeapValidateOnCall;
    BOOLEAN DisableHeapChecking;
    BOOLEAN DisableHeapValidateOnCall;
    BOOLEAN ToggleAPICallTracing;
    ULONG64 HeapToDump;
    ULONG64 HeapEntryToDump;
    ULONG64 ReservedSize;
    ULONG64 CommittedSize;
    ULONG64 AllocatedSize;
    ULONG64 FreeSize;
    ULONG64 OverheadSize;
    ULONG  NumberOfHeaps;
    ULONG  HeapIndex;
    PULONG64 HeapsList;
    ULONG  StopOnOperation;
    ULONG64 StopOnAddress;
    HEAP_STOP_ON_TAG StopOnTag;
    WCHAR  StopOnTagName[ 24 ];

    ULONG  FreeListCounts[ HEAP_MAXIMUM_FREELISTS ];
    ULONG64 TotalFreeSize;
    ULONG64 HeapAddress;
    ULONG64 Heap; // HEAP
    ULONG  SegmentNumber;
    ULONG64 SegmentAddress;
    ULONG64 Segments[ HEAP_MAXIMUM_SEGMENTS ]; // Ptr to HEAP_SEGMENT
} HEAP_STATE, *PHEAP_STATE;


BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    );

BOOL
GetHeapTagEntry(
    IN ULONG64 Heap,
    IN USHORT TagIndex,
    OUT PULONG64 TagEntry
    );

VOID
WalkHEAP(
    IN PHEAP_STATE State
    );

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    );

BOOL
ValidateHeapHeader(
    IN ULONG64 HeapAddress
//    IN PHEAP Heap
    );

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 PrevEntryAddress,
    IN ULONG64 PrevEntry,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    );

VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    );


#if STACK_TRACE_DATABASE_SUPPORT
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    );
#endif // STACK_TRACE_DATABASE_SUPPORT

BOOLEAN HeapExtInitialized;

ULONG64 pNtGlobalFlag;

ULONG64 pRtlpHeapInvalidBreakPoint;
ULONG64 pRtlpHeapInvalidBadAddress;

ULONG64 pRtlpGlobalTagHeap;
//HEAP MyLocalRtlpGlobalTagHeap;

#if STACK_TRACE_DATABASE_SUPPORT
ULONG64 pRtlpStackTraceDataBase;// PSTACK_TRACE_DATABASE *
ULONG64 RtlpStackTraceDataBase; // PSTACK_TRACE_DATABASE
STACK_TRACE_DATABASE StackTraceDataBase;
BOOLEAN HaveCopyOfStackTraceDataBase;
#endif // STACK_TRACE_DATABASE_SUPPORT

ULONG64 pRtlpHeapStopOn; // PHEAP_STOP_ON_VALUES

BOOLEAN RtlpHeapInvalidBreakPoint;
ULONG HeapEntryTypeSize = 8;

DECLARE_API( heap )

/*++

Routine Description:

    Dump user mode heap (Kernel debugging)

    If an address if not given or an address of 0 is given, then the
    process heap is dumped.  If the address is -1, then all the heaps of
    the process are dumped.  If detail is specified, it defines how much
    detail is shown.  A detail of 0, just shows the summary information
    for each heap.  A detail of 1, shows the summary information, plus
    the location and size of all the committed and uncommitted regions.
    A detail of 3 shows the allocated and free blocks contained in each
    committed region.  A detail of 4 includes all of the above plus
    a dump of the free lists.

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    BOOL b, GotHeapsList, ArgumentsSpecified;
    ULONG64 pHeapsList;
    ULONG PtrSize;
    ULONG NtGlobalFlag;
    LPSTR p;
    ULONG i;
    ULONG DashBArgumentState;
    ULONG64 AddressToDump;
    HEAP_STATE State;
    UCHAR ArgumentBuffer[ 16 ];
    ULONG TagIndex;
    ULONG64 pTagEntry; // PHEAP_TAG_ENTRY
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
    ULONG64 pPseudoTagEntry; // PHEAP_PSEUDO_TAG_ENTRY
//    HEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    BOOLEAN HeapHeaderModified;
    ULONG LocalHeapSignature;
    ULONG64 RtlpHeapInvalidBadAddress;
    ULONG AlOffset, FlagOffset, TagEntrySize, pseudoTagEntrySize;
    ULONG64 AlignRound;
    ULONG64 SystemRangeStart = GetExpression("NT!MmSystemRangeStart");
    ULONG64 ProcessPeb;
    PCSTR Current;

    //
    //  Parse the command line arguments for heap options
    //  that don't require to building the process heap list
    //  (i.e pageheap, leak detection, search a block)
    //

    for (Current = args; *Current != '\0'; Current++) {

        if (*Current == '-') {

            Current++;
            switch (*Current) {
                case 'p':


                    if (g_TargetBuild > 2600)
                    {
                        PageHeapExtension( ++Current );
                    } else
                    {
                        DebugPageHeapExtensionXP( ++Current );
                    }

                    return S_OK;

                case 'l':
                case 'L':
                    HeapDetectLeaks();
                    return S_OK;

                case 'x':
                case 'X':
                    HeapFindBlock( args );
                    return S_OK;
                case 's':
                case 'S':
                    HeapStat(++Current);
                    return S_OK;
            }
        }
    }


    // BUGBUG - not initializing the signature, as we have no local copy
    // MyLocalRtlpGlobalTagHeap.Signature = 0;
    LocalHeapSignature = 0;
#if STACK_TRACE_DATABASE_SUPPORT
    HaveCopyOfStackTraceDataBase = FALSE;
#endif // STACK_TRACE_DATABASE_SUPPORT

    memset( &State, 0, FIELD_OFFSET( HEAP_STATE, FreeListCounts ) );
    AddressToDump = (ULONG)-1;
    ArgumentsSpecified = FALSE;
    p = (LPSTR)args;
    if (p != NULL)
    while (*p) {
        if (*p == '-') {
            ArgumentsSpecified = TRUE;
            p += 1;
            while (*p && *p != ' ') {
                switch (*p) {
                case 'v':
                case 'V':
                    State.ValidateHeap = TRUE;
                    break;

                case 'a':
                case 'A':
                    State.DumpHeapEntries = TRUE;
                    State.DumpHeapFreeLists = TRUE;
                    State.DumpHeapSegments = TRUE;
                    break;

                case 'h':
                case 'H':
                    State.DumpHeapEntries = TRUE;
                    break;

                case 'f':
                case 'F':
                    State.DumpHeapFreeLists = TRUE;
                    break;

                case 'm':
                case 'M':
                    State.DumpHeapSegments = TRUE;
                    break;

                case 't':
                    State.DumpHeapTags = TRUE;
                    break;

                case 'T':
                    State.DumpHeapPseudoTags = TRUE;
                    break;

                case 'g':
                case 'G':
                    State.DumpGlobalTags = TRUE;
                    break;

                case 'k':
                case 'K':
                    State.DumpStackBackTrace = TRUE;
                    break;

                case 's':
                case 'S':
                    State.ComputeSummary = TRUE;
                    break;

                case 'd':
                    State.DisableHeapChecking = TRUE;
                    break;

                case 'D':
                    State.DisableHeapValidateOnCall = TRUE;
                    break;

                case 'e':
                    State.EnableHeapChecking = TRUE;
                    break;

                case 'E':
                    State.EnableHeapValidateOnCall = TRUE;
                    break;

                case 'B':
                    State.RemoveStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                case 'b':
                    State.SetStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                default:
                    dprintf( "HEAPEXT: !heap invalid option flag '-%c'\n", *p );
                case '?':
                    State.ShowHelp = TRUE;
                    break;
                }

                p += 1;
                }
            }
        else
        if (*p != ' ') {
            if (State.SetStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }

                        if (State.StopOnOperation == 0) {
                            dprintf( "HEAPEXT: Invalid first argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    case 1:
                        if (sscanf( p, "%ws", &State.StopOnTagName ) != 1) {
                            State.StopOnTagName[ 0 ] = UNICODE_NULL;
                            dprintf( "HEAPEXT: Invalid second argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -b switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else
            if (State.RemoveStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -B switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else {
                ArgumentsSpecified = TRUE;
                AddressToDump = GetExpression(p);
                }

            if ((p = strpbrk( p, " " )) == NULL) {
                p = "";
                }
            }
        else {
            p++;
            }
    }

    if (State.ShowHelp) {
        dprintf( "usage: !heap [address] [-? ] [-v] [[-a] | [-h] [-f] [-m]] [-t] [-s]\n" );
        dprintf( "                       [-d | -D | -e | -E]\n" );
        dprintf( "                       [-b [alloc | realloc | free] [tag]]\n" );
        dprintf( "                       [-B [alloc | realloc | free]]\n" );
        dprintf( "  address - specifies either a heap number (1-n), or a heap address.\n" );
        dprintf( "            Zero specifies all heaps in the process.\n" );
        dprintf( "            -1 is the default and specifies the process heap.\n" );
        dprintf( "  -?        displays this help message.\n" );
        dprintf( "  -v        validates the specified heap(s).\n" );
        dprintf( "  -a        displays all the information for the specified heap(s).\n" );
        dprintf( "            This can take a long time.\n" );
        dprintf( "  -h        displays all the entries for the specified heap(s).\n" );
        dprintf( "  -f        displays all the free list entries for the specified heap(s).\n" );
        dprintf( "  -l        detects leaked heap blocks.\n" );
        dprintf( "  -x        search the heap block containing the address.\n" );
        dprintf( "  -x -v     search the whole process virtual space for given address .\n" );
        dprintf( "  -k        displays any associated stack back trace for each entry (x86 only).\n" );
        dprintf( "  -m        displays all the segment entries for the specified heap(s).\n" );
        dprintf( "  -t        displays the tag information for the specified heap(s).\n" );
        dprintf( "  -T        displays the pseudo tag information for the specified heap(s).\n" );
        dprintf( "  -g        displays the global tag information generated by tag by DLL\n" );
        dprintf( "  -s        displays summary information for the specified heap(s).\n" );
        dprintf( "  -e        enables heap checking for the specified heap(s).\n" );
        dprintf( "  -d        disables heap checking for the specified heap(s).\n" );
        dprintf( "  -E        enables validate on call for the specified heap(s).\n" );
        dprintf( "  -D        disables validate on call for the specified heap(s).\n" );
        dprintf( "  -b        creates a conditional breakpoint in the heap manager.\n" );
        dprintf( "            alloc | realloc | free specifies which action to stop.\n" );
        dprintf( "            address either specifies the address of a block to stop on.\n" );
        dprintf( "            or a heap, in which case the tag argument is required,\n" );
        dprintf( "            and is the tag name within the heap specified by address.\n" );
        dprintf( "  -B        removes a conditional breakpoint in the heap manager.\n" );
        dprintf( "            if the type is not specified then all breakpoints are removed.\n" );
        dprintf ("  -p -?       extensive page heap related help.           \n");
        dprintf ("  -p          Dump all page heaps.                        \n");
        dprintf ("  -p -h ADDR  Detailed dump of page heap at ADDR.         \n");
        dprintf ("  -p -a ADDR  Figure out what heap block is at ADDR.      \n");
        dprintf ("  -p -fi [N]  Dump last N fault injection traces.\n");

        return S_OK;
    }

    i = (ULONG)State.EnableHeapChecking + (ULONG)State.EnableHeapValidateOnCall +
        (ULONG)State.DisableHeapChecking + (ULONG)State.DisableHeapValidateOnCall +
        (ULONG)State.ToggleAPICallTracing;

    if (i > 1) {
        dprintf( "HEAPEXT: -d, -D, -e and -E flags are mutually exclusive\n" );
        return E_INVALIDARG;
    }

    if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
        if (pRtlpHeapStopOn == 0) {
            dprintf( "HEAPEXT: Unable to %s heap breakpoint due to missing or invalid NTDLL symbols.\n",
                     State.SetStopOnBreakPoint ? "set" : "remove"
                   );
            return E_INVALIDARG;
        }

        if (State.HeapToDump == 0) {
            dprintf( "HEAPEXT: Must specify either heap index or heap address to -b command.\n" );
            return E_INVALIDARG;
        }
    }

    //
    // Ok, so this is a !heap command for NT heap manager.
    //

    if (!HeapExtInitialized) {
        pNtGlobalFlag = GetExpression( "NTDLL!NtGlobalFlag" );
        if (pNtGlobalFlag == 0 ||
            !ReadMemory( pNtGlobalFlag,
                         &NtGlobalFlag,
                         sizeof( NtGlobalFlag ),
                         NULL ) )
        {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!NtGlobalFlag.\n" );
            return E_INVALIDARG;
        }

        pRtlpHeapInvalidBreakPoint = GetExpression( "NTDLL!RtlpHeapInvalidBreakPoint" );
        if (pRtlpHeapInvalidBreakPoint == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBreakPoint.\n" );
            }

        pRtlpHeapInvalidBadAddress = GetExpression( "NTDLL!RtlpHeapInvalidBadAddress" );
        if (pRtlpHeapInvalidBadAddress == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBadAddress.\n" );
            }

        pRtlpGlobalTagHeap = GetExpression( "NTDLL!RtlpGlobalTagHeap" );
        if (pRtlpGlobalTagHeap == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpGlobalTagHeap.\n" );
            }
        if (!ReadPointer( pRtlpGlobalTagHeap,&pRtlpGlobalTagHeap)) {
            dprintf( "HEAPEXT: Unable to get address of *NTDLL!RtlpGlobalTagHeap.\n" );
        }

        pRtlpHeapStopOn = GetExpression( "NTDLL!RtlpHeapStopOn" );
        if (pRtlpHeapStopOn == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapStopOn\n" );
            }

#if STACK_TRACE_DATABASE_SUPPORT
        pRtlpStackTraceDataBase = GetExpression( "NTDLL!RtlpStackTraceDataBase" );
        if (pRtlpStackTraceDataBase == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpStackTraceDataBase\n" );
            }
#endif // STACK_TRACE_DATABASE_SUPPORT

        HeapExtInitialized = TRUE;
        }

    if (!GetPageSize()) {
        dprintf("Unable to get PageSize.\n");
        return E_INVALIDARG;

    }

    if (!ArgumentsSpecified) {
        if ((NtGlobalFlag & (FLG_HEAP_ENABLE_TAIL_CHECK |
                             FLG_HEAP_ENABLE_FREE_CHECK |
                             FLG_HEAP_VALIDATE_PARAMETERS |
                             FLG_HEAP_VALIDATE_ALL |
                             FLG_HEAP_ENABLE_TAGGING |
                             FLG_USER_STACK_TRACE_DB |
                             FLG_HEAP_DISABLE_COALESCING
                            )
            ) != 0
           ) {
            dprintf( "NtGlobalFlag enables following debugging aids for new heaps:" );
            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {
                dprintf( "    tail checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {
                dprintf( "    free checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {
                dprintf( "    validate parameters\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {
                dprintf( "    validate on call\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING) {
                dprintf( "    heap tagging\n" );
                }

            if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {
                dprintf( "    stack back traces\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {
                dprintf( "    disable coalescing of free blocks\n" );
            }
        }
    }



    {
    INIT_API();
    }

    GetPebAddress( 0, &ProcessPeb);

    if (AddressToDump == (ULONG64)-1) {
        GetFieldValue(ProcessPeb, "nt!_PEB", "ProcessHeaps", AddressToDump);
    }

    PtrSize = IsPtr64() ? 8 : 4;
    HeapEntryTypeSize = GetTypeSize("nt!_HEAP_ENTRY");
    GetFieldOffset("nt!_HEAP", "AlignRound", &AlOffset);
    GetFieldOffset("nt!_HEAP", "Flags", &FlagOffset);
    TagEntrySize = GetTypeSize( "nt!_HEAP_TAG_ENTRY");
    pseudoTagEntrySize = GetTypeSize( "nt!_HEAP_PSEUDO_TAG_ENTRY");



    GotHeapsList = FALSE;
    GetFieldValue(ProcessPeb, "nt!_PEB", "NumberOfHeaps", State.NumberOfHeaps);
    GetFieldValue(ProcessPeb, "nt!_PEB", "ProcessHeaps", pHeapsList);
    if (State.NumberOfHeaps == 0) {
        dprintf( "No heaps to display.\n" );
    }
    else if (!pHeapsList) {
        dprintf( "Unable to get address of ProcessHeaps array\n" );
    }
    else {
        State.HeapsList = malloc( State.NumberOfHeaps * sizeof(ULONG64) ); // To Keep  PHEAP
        if (State.HeapsList == NULL) {
            dprintf( "Unable to allocate memory to hold ProcessHeaps array\n" );
        }
        else {
            ULONG iHeap;
            //
            // Read the array of heap pointers
            //
            GotHeapsList = TRUE;
            for (iHeap=0;iHeap<State.NumberOfHeaps; iHeap++) {
                if (!ReadPointer( pHeapsList + iHeap*PtrSize,
                             &State.HeapsList[iHeap] )
                    ) {
                    dprintf( "%08p: Unable to read ProcessHeaps array\n", pHeapsList );
                    GotHeapsList = FALSE ;
                    break;
                }
            }
        }
    }

    if (GotHeapsList) {
retryArgs:
        if (!ArgumentsSpecified) {
            if (pRtlpHeapInvalidBreakPoint != 0) {
                b = ReadMemory( pRtlpHeapInvalidBreakPoint,
                                &RtlpHeapInvalidBreakPoint,
                                sizeof( RtlpHeapInvalidBreakPoint ),
                                NULL
                              );
                if (b && RtlpHeapInvalidBreakPoint) {
                    RtlpHeapInvalidBadAddress = 0;
                    if (pRtlpHeapInvalidBadAddress != 0) {
                        b = ReadPointer(pRtlpHeapInvalidBadAddress,
                                    &RtlpHeapInvalidBadAddress);
                        if (b) {
                            AddressToDump = RtlpHeapInvalidBadAddress;
                            }
                        }

                    dprintf( "Stop inside heap manager...validating heap address 0x%p\n", AddressToDump );
                    State.ValidateHeap = TRUE;
                    State.DumpStackBackTrace = TRUE;
                    ArgumentsSpecified = TRUE;
                    goto retryArgs;
                    }
                }
            }
        else
        if (AddressToDump != 0) {
            for (State.HeapIndex=0;
                 State.HeapIndex<State.NumberOfHeaps;
                 State.HeapIndex++
                ) {
                if (AddressToDump-1 == State.HeapIndex ||
                    AddressToDump == State.HeapsList[ State.HeapIndex ]
                   ) {
                    State.HeapToDump = State.HeapsList[ State.HeapIndex ];
                    break;
                    }
                }

            if (State.HeapToDump == 0) {
                if (AddressToDump >= SystemRangeStart) {
                    State.HeapToDump = AddressToDump;
                    }
                else {
                    State.HeapToDump = (ULONG64)-1;
                    }
                }
            }

        State.HeapIndex = 0;
    }
    else {
        if (!ArgumentsSpecified || AddressToDump < 0x10000) {
            dprintf( "You must specify the actual heap address since\n" );
            dprintf( "array of process heaps is inaccessable\n" );
            State.ExitDumpLoop = TRUE;
            }
        else {
            State.HeapToDump = AddressToDump;
            }
    }


    if (State.DumpGlobalTags) {
        dprintf( "Global Tags defined for each DLL that makes an untagged allocation.\n" );
        if (LocalHeapSignature != HEAP_SIGNATURE) {
            b = GetFieldValue( pRtlpGlobalTagHeap,
                               "nt!_HEAP",
                               "Signature",
                               LocalHeapSignature);
            if (b) {
                dprintf( "HEAPEXT: Unable to read RtlpGlobalTagHeap\n" );
                if (State.HeapsList != NULL) {
                    free( State.HeapsList );
                    }
                EXIT_API();
                return E_INVALIDARG;
                }
            }

        GetFieldValue(pRtlpGlobalTagHeap, "nt!_HEAP", "TagEntries", pTagEntry);
        if (pTagEntry == 0) {
            dprintf( "    no global tags currently defined.\n" );
            }
        else {
            ULONG NextAvailableTagIndex;

            GetFieldValue(pRtlpGlobalTagHeap, "nt!_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);

            dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
            for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {
                pTagEntry += TagEntrySize;
                b = (BOOL) InitTypeRead( pTagEntry, nt!_HEAP_TAG_ENTRY);
                if (b) {
                    dprintf( "%04x: unable to read nt!_HEAP_TAG_ENTRY at %p\n", TagIndex, pTagEntry );
                    break;
                    }
                else
                if ((ULONG)ReadField(Allocs) != 0 ||
                    (ULONG)ReadField(Frees) != 0 ||
                    (ULONG)ReadField(Size) != 0
                   )
                {
                    WCHAR TagName[50];

                    GetFieldValue(pTagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                    dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                             (ULONG)ReadField(TagIndex),
                             TagName,
                             (ULONG)ReadField(Allocs),
                             (ULONG)ReadField(Frees),
                             (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                             (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                           );
                }
            }
        }
    }

    //
    // Walk the list of heaps
    //
    while (!State.ExitDumpLoop &&
           !CheckControlC() &&
           (!GotHeapsList || (State.HeapIndex < State.NumberOfHeaps ))
          ) {
        ULONG Flags;
        WCHAR TagName[ 24 ];

        memset( &State.FreeListCounts, 0, sizeof( State.FreeListCounts ) );
        State.TotalFreeSize = 0;
        if (!GotHeapsList) {
            State.HeapAddress = State.HeapToDump;
            State.ExitDumpLoop = TRUE;
        }
        else {
            State.HeapAddress = State.HeapsList[ State.HeapIndex ];
        }


        State.Heap = State.HeapAddress;

        b = (BOOL) InitTypeRead( (State.HeapAddress), nt!_HEAP);
        if (State.HeapIndex == 0) {
            dprintf( "Index   Address  Name      Debugging options enabled\n" );
        }

        dprintf( "%3u:   %08p ", State.HeapIndex + 1, State.HeapAddress );
        Flags = (ULONG) ReadField(Flags);
        if (b) {
            dprintf( " - heap headers inaccessable, skipping\n" );
        }
        else
        if (!ArgumentsSpecified) {
            if (!GetHeapTagEntry( State.HeapAddress, 0, &TagEntry )) {
                TagName[ 0 ] = UNICODE_NULL;
            } else {
                GetFieldValue(TagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
            }
            dprintf( " %-14.14ws", TagName );

            if (Flags & HEAP_TAIL_CHECKING_ENABLED) {
                dprintf( " tail checking" );
            }

            if (Flags & HEAP_FREE_CHECKING_ENABLED) {
                dprintf( " free checking" );
            }

            if (Flags & HEAP_VALIDATE_PARAMETERS_ENABLED) {
                dprintf( " validate parameters" );
                }

            if (Flags & HEAP_VALIDATE_ALL_ENABLED) {
                dprintf( " validate on call" );
                }

            dprintf( "\n" );
            }
        else
        if (State.HeapAddress == State.HeapToDump ||
            State.HeapToDump == 0 ||
            State.HeapToDump == (ULONG64)-1
           ) {
            ULONG Off;
            ULONG64 LastValidEntry;

            GetFieldOffset("nt!_HEAP", "Segments", &Off);
            dprintf( "\n" );
            for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
                ReadPointer(State.HeapAddress + Off + i*PtrSize,
                        &State.Segments[i]);
                if (State.Segments[ i ] != 0) {
                    b = (BOOL) InitTypeRead(State.Segments[ i ], nt!_HEAP_SEGMENT);
                    if (b) {
                        dprintf( "    Unable to read _HEAP_SEGMENT structure at %p\n", State.Segments[ i ] );
                        }
                    else {
                        LastValidEntry = ReadField(LastValidEntry);
                        dprintf( "    Segment at %p to %p (%08x bytes committed)\n",
                                 i == 0 ? State.HeapAddress : State.Segments[ i ],
                                 LastValidEntry,
                                 (LastValidEntry -
                                    (i == 0 ? State.HeapAddress : State.Segments[ i ])-
                                    (ReadField(NumberOfUnCommittedPages) * PageSize)
                               ));

                        if (State.HeapToDump == (ULONG)-1) {
                            if (AddressToDump >= State.Segments[ i ] &&
                                AddressToDump < LastValidEntry
                               ) {
                                State.HeapToDump = State.HeapAddress;
                                if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                                    State.StopOnAddress = AddressToDump;
                                    }
                                else {
                                    State.HeapEntryToDump = AddressToDump;
                                    }
                                }
                            }
                        }
                    }
                }

            if (State.HeapToDump == (ULONG64)-1) {
                State.HeapIndex += 1;
                continue;
                }

            if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                ULONG64 pul;
                ULONG AllocOff;
                PSTR TypeHSOV = "nt!_HEAP_STOP_ON_VALUES";

                switch( State.StopOnOperation) {
                    case STOP_ON_ALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset(TypeHSOV,"AllocAddress", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        else {
                            GetFieldOffset(TypeHSOV,"AllocTag.HeapAndTagIndex", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        break;

                    case STOP_ON_REALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset(TypeHSOV,"ReAllocAddress", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        else {
                            GetFieldOffset(TypeHSOV,"ReAllocTag.HeapAndTagIndex", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        break;

                    case STOP_ON_FREE:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset(TypeHSOV,"FreeAddress", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        else {
                            GetFieldOffset(TypeHSOV,"FreeTag.HeapAndTagIndex", &AllocOff);
                            pul = pRtlpHeapStopOn + AllocOff;;
                            }
                        break;
                    default:
                        pul = 0;
                        break;
                    }

                if (pul != 0) {
                    if (State.StopOnTagName[0] == UNICODE_NULL) {
                        if (State.RemoveStopOnBreakPoint) {
                            State.StopOnAddress = 0;
                            }
                        b = WriteMemory( pul,
                                         &State.StopOnAddress,
                                         PtrSize,
                                         NULL
                                       );
                        }
                    else {
                        if (!ConvertTagNameToIndex( &State )) {
                            dprintf( "HEAPEXT: Unable to convert tag name %ws to an index\n", State.StopOnTagName );
                            b = TRUE;
                            }
                        else {
                            b = WriteMemory( pul,
                                             &State.StopOnTag.HeapAndTagIndex,
                                             sizeof( State.StopOnTag.HeapAndTagIndex ),
                                             NULL
                                           );
                            }
                        }

                    if (!b) {
                        dprintf( "HEAPEXT: Unable to set heap breakpoint - write memory to %x failed\n", pul );
                        }
                    else {
                        if (State.SetStopOnBreakPoint) {
                            if (State.StopOnTagName[0] == UNICODE_NULL) {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block %x\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnAddress
                                       );
                                }
                            else {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block with tag %ws\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnTagName
                                       );
                                }
                            }
                        else {
                            dprintf( "HEAPEXT: Disabled heap breakpoint for %s\n",
                                     State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                     State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                     "Free"
                                   );
                            }
                        }
                    }
                }

            if (State.ValidateHeap) {
                ValidateHeapHeader( State.HeapAddress );
                }

            HeapHeaderModified = FALSE;
            GetFieldValue(State.HeapAddress, "nt!_HEAP", "AlignRound", AlignRound);
            if (State.EnableHeapChecking || State.EnableHeapValidateOnCall) {

                if (!(Flags & HEAP_TAIL_CHECKING_ENABLED)) {
                    AlignRound += CHECK_HEAP_TAIL_SIZE;
                    b = WriteMemory( (State.HeapAddress + AlOffset),
                                     &AlignRound,
                                     sizeof( AlignRound ),
                                     NULL
                                   );
                }
                else {
                    b = TRUE;
                }


                if (b) {
                    HeapHeaderModified = TRUE;
                    Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED |
                                        HEAP_TAIL_CHECKING_ENABLED |
                                        HEAP_FREE_CHECKING_ENABLED;
                    if (State.EnableHeapValidateOnCall) {
                        Flags |= HEAP_VALIDATE_ALL_ENABLED;
                        }

                    b = WriteMemory( (State.HeapAddress + FlagOffset),
                                     (LPCVOID)&Flags,
                                     sizeof( Flags ),
                                     NULL
                                   );
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to enable heap checking for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), nt!_HEAP);
                }
                else {
                    if (State.EnableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Enabled validate on call heap checking for heap %p\n", State.HeapAddress );
                    }
                    else {
                        dprintf( "HEAPEXT: Enabled heap checking for heap %p\n", State.HeapAddress );
                    }
                }
            }
            else
            if (State.DisableHeapChecking || State.DisableHeapValidateOnCall) {
                if (State.DisableHeapValidateOnCall) {
                    if (Flags & HEAP_VALIDATE_ALL_ENABLED) {
                        Flags &= ~HEAP_VALIDATE_ALL_ENABLED;
                        b = WriteMemory( State.HeapAddress + FlagOffset,
                                         (LPCVOID)&Flags,
                                         sizeof( Flags ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }
                    }
                else {
                    if (Flags & HEAP_TAIL_CHECKING_ENABLED) {
                        HeapHeaderModified = TRUE;
                        AlignRound -= CHECK_HEAP_TAIL_SIZE;
                        b = WriteMemory( State.HeapAddress + AlOffset,
                                         (LPCVOID)&AlignRound,
                                         sizeof( AlignRound ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }

                    if (b) {
                        Flags &= ~(HEAP_VALIDATE_PARAMETERS_ENABLED |
                                   HEAP_VALIDATE_ALL_ENABLED |
                                   HEAP_TAIL_CHECKING_ENABLED |
                                   HEAP_FREE_CHECKING_ENABLED
                                   );
                        b = WriteMemory( State.HeapAddress + FlagOffset,
                                         (LPCVOID)&Flags,
                                         sizeof( Flags ),
                                         NULL
                                       );
                        }
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to disable heap checking for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), nt!_HEAP);
                    }
                else {
                    if (State.DisableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Disabled validate on call heap checking for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled heap checking for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.ToggleAPICallTracing) {
                Flags ^= HEAP_CREATE_ENABLE_TRACING;
                b = WriteMemory( State.HeapAddress + FlagOffset,
                                 (LPCVOID)&Flags,
                                 sizeof( Flags ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to toggle API call tracing for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), nt!_HEAP);
                    }
                else {
                    HeapHeaderModified = TRUE;
                    if (Flags & HEAP_CREATE_ENABLE_TRACING) {
                        dprintf( "HEAPEXT: Enabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.DumpHeapTags) {
                GetFieldValue(State.HeapAddress, "nt!_HEAP", "TagEntries", pTagEntry);
                if (pTagEntry == 0) {
                    dprintf( "    no tags currently defined for this heap.\n" );
                    }
                else {
                    ULONG NextAvailableTagIndex;

                    GetFieldValue(State.HeapAddress, "nt!_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);

                    dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {
                        pTagEntry += TagEntrySize;
                        b = (BOOL) InitTypeRead( pTagEntry, nt!_HEAP_TAG_ENTRY);

                        if (b) {
                            dprintf( "%04x: unable to read nt!_HEAP_TAG_ENTRY at %p\n", TagIndex, pTagEntry );
                            }
                        else
                        if ((ULONG)ReadField(Allocs) != 0 ||
                            (ULONG)ReadField(Frees) != 0 ||
                            (ULONG)ReadField(Size) != 0
                           ) {

                            GetFieldValue(pTagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                            dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                                     (ULONG)ReadField(TagIndex),
                                     TagName,
                                     (ULONG)ReadField(Allocs),
                                     (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                                   );
                            }
                        }
                    }
                }
            else
            if (State.DumpHeapPseudoTags) {
                GetFieldValue(State.HeapAddress, "nt!_HEAP", "PseudoTagEntries", pPseudoTagEntry);
                if (pPseudoTagEntry == 0) {
                    dprintf( "    no pseudo tags currently defined for this heap.\n" );
                    }
                else {
                    dprintf( " Tag Name            Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {
                        pPseudoTagEntry += pseudoTagEntrySize;
                        b = (BOOL) InitTypeRead( pPseudoTagEntry, nt!_HEAP_PSEUDO_TAG_ENTRY);
                        if (b) {
                            dprintf( "%04x: unable to read HEAP_PSEUDO_TAG_ENTRY at %p\n", TagIndex, pPseudoTagEntry );
                            }
                        else
                        if ((ULONG)ReadField(Allocs) != 0 ||
                            (ULONG)ReadField(Frees) != 0 ||
                            (ULONG)ReadField(Size) != 0
                           ) {
                            if (TagIndex == 0) {
                                dprintf( "%04x: Objects>%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else
                            if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
                                dprintf( "%04x: Objects=%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         TagIndex << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else {
                                dprintf( "%04x: VirtualAlloc", TagIndex | HEAP_PSEUDO_TAG_FLAG );
                            }
                            dprintf( " %8d %8d %6d %8d\n",
                                     (ULONG)ReadField(Allocs),
                                     (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                                   );
                        }
                    }
                }
            }

            // BUGBUG - Cannot write whole struct - change to write specific fields only
            //
            /*
            if (HeapHeaderModified && (State.Heap.HeaderValidateCopy != NULL)) {
                b = WriteMemory( (ULONG_PTR)State.Heap.HeaderValidateCopy,
                                 &State.Heap,
                                 sizeof( State.Heap ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to update header validation copy at %p\n", State.Heap.HeaderValidateCopy );
                }
            }*/

            if (State.HeapEntryToDump != 0 ||
                State.DumpHeapEntries ||
                State.DumpHeapSegments ||
                State.DumpHeapFreeLists
               ) {
                WalkHEAP( &State );
            }
        }
        else {
            dprintf( "\n" );
        }

        State.HeapIndex += 1;
    }

    if (State.HeapsList != NULL) {
        free( State.HeapsList );
    }

    EXIT_API();

    return S_OK;
}

BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    )
{
    ULONG TagIndex;
    ULONG64 pTagEntry; // PHEAP_TAG_ENTRY
    ULONG64 pPseudoTagEntry;
    BOOL b;
    PWSTR s;
    WCHAR TagName[ 24 ];

    ULONG NextAvailableTagIndex, TagEntrySize;

    if (State->RemoveStopOnBreakPoint) {
        State->StopOnTag.HeapAndTagIndex = 0;
        return TRUE;
        }

    if (!_wcsnicmp( State->StopOnTagName, L"Objects", 7 )) {
        GetFieldValue(State->Heap, "nt!_HEAP", "PseudoTagEntries", pPseudoTagEntry);
        if (pPseudoTagEntry == 0) {
            return FALSE;
            }

        s = &State->StopOnTagName[ 7 ];
        if (*s == L'>') {
            GetFieldValue(State->Heap, "nt!_HEAP", "ProcessHeapsListIndex", State->StopOnTag.HeapIndex);
            State->StopOnTag.TagIndex = HEAP_PSEUDO_TAG_FLAG;
            return TRUE;
            }
        else
        if (*s == L'=') {
            while (*++s == L' ') ;
            State->StopOnTag.TagIndex = (USHORT)_wtoi( s );
            if (State->StopOnTag.TagIndex > 0 &&
                State->StopOnTag.TagIndex < (HEAP_MAXIMUM_FREELISTS >> HEAP_GRANULARITY_SHIFT)
               ) {
                GetFieldValue(State->Heap, "nt!_HEAP", "ProcessHeapsListIndex", State->StopOnTag.HeapIndex);
                State->StopOnTag.TagIndex = (State->StopOnTag.TagIndex >> HEAP_GRANULARITY_SHIFT) |
                                             HEAP_PSEUDO_TAG_FLAG;
                return TRUE;
                }
            }
        }

    GetFieldValue(State->Heap, "nt!_HEAP", "TagEntries", pTagEntry);
    if (pTagEntry == 0) {
        return FALSE;
        }


    GetFieldValue(State->HeapAddress, "nt!_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);
    TagEntrySize = GetTypeSize("nt!_HEAP_TAG_ENTRY");

    for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {

        pTagEntry += TagEntrySize;
        b = GetFieldValue( pTagEntry,"nt!_HEAP_TAG_ENTRY","TagName",TagName);
        if (!b && !_wcsicmp( State->StopOnTagName, TagName )) {
            GetFieldValue( pTagEntry,"nt!_HEAP_TAG_ENTRY","TagIndex",State->StopOnTag.TagIndex);
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
GetHeapTagEntry(
    IN ULONG64 Heap,
    IN USHORT TagIndex,
    OUT PULONG64 TagEntry
    )
{
    BOOL b;
    ULONG64 pTagEntries;// PHEAP_TAG_ENTRY
    ULONG NextAvailableTagIndex;
    ULONG64 pPseudoTagEntries; // PHEAP_PSEUDO_TAG_ENTRY

    b = FALSE;
    if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {
        TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;
        GetFieldValue(Heap, "nt!_HEAP", "PseudoTagEntries", pPseudoTagEntries);
        if (pPseudoTagEntries == 0) {
            return FALSE;
        }
        // BUGBUG - Cannot copy name
        /*
        if (TagIndex == 0) {
            swprintf( TagEntry->TagName, L"Objects>%4u",
                      HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                      );
        }
        else
        if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
            swprintf( TagEntry->TagName, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );
        }
        else {
            swprintf( TagEntry->TagName, L"VirtualAlloc" );
        }
        TagEntry->TagIndex = TagIndex;
        TagEntry->CreatorBackTraceIndex = 0;*/

        *TagEntry = pPseudoTagEntries + TagIndex * GetTypeSize("nt!_HEAP_PSEUDO_TAG_ENTRY");

        b = !InitTypeRead(*TagEntry, nt!_HEAP_TAG_ENTRY);
    }
    else
    if (TagIndex & HEAP_GLOBAL_TAG) {

        if (GetFieldValue(pRtlpGlobalTagHeap, "nt!_HEAP", "NextAvailableTagIndex",NextAvailableTagIndex)) {
                return FALSE;
        }
        TagIndex &= ~HEAP_GLOBAL_TAG;
        if (TagIndex < NextAvailableTagIndex) {
            GetFieldValue(pRtlpGlobalTagHeap, "nt!_HEAP", "TagEntries", pTagEntries);
            if (pTagEntries == 0) {
                return FALSE;
            }
            *TagEntry = pTagEntries;
            b = ! (BOOL) InitTypeRead(pTagEntries, nt!_HEAP_TAG_ENTRY);
        }
    }
    else {
        if (GetFieldValue(Heap, "nt!_HEAP", "NextAvailableTagIndex",NextAvailableTagIndex)) {
                return FALSE;
        }
        if (TagIndex < NextAvailableTagIndex) {
            GetFieldValue(Heap, "nt!_HEAP", "TagEntries", pTagEntries);
            if (pTagEntries == 0) {
                return FALSE;
            }

            *TagEntry = pTagEntries;
            b = ! (BOOL) InitTypeRead(pTagEntries, nt!_HEAP_TAG_ENTRY);
        }
    }

    return b;
}


VOID
WalkHEAP(
    IN PHEAP_STATE State
    )
{
    BOOL b;
    ULONG64 FreeListHead;
    ULONG i;
    ULONG64 Head, Next;
//    HEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocEntry;
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
    ULONG64 FreeEntryAddress;
    ULONG64 FreeEntry; // HEAP_FREE_ENTRY
    ULONG64 UCRSegment, UnusedUnCommittedRanges;
    ULONG64 CapturedUCRSegment; // HEAP_UCR_SEGMENT
    ULONG AlignRound, Offset, ListSize, FreeListOffset;

    GetFieldOffset("nt!_HEAP", "VirtualAllocdBlocks", &Offset);
    if (InitTypeRead(State->HeapAddress, nt!_HEAP)) {
        return;
    }

    AlignRound = (ULONG)ReadField(AlignRound) - GetTypeSize( "nt!_HEAP_ENTRY" );
    if ((ULONG)ReadField(Flags) & HEAP_TAIL_CHECKING_ENABLED) {
        AlignRound -= CHECK_HEAP_TAIL_SIZE;
        }

    dprintf( "    Flags:               %08x\n", (ULONG)ReadField(Flags) );
    dprintf( "    ForceFlags:          %08x\n", (ULONG)ReadField(ForceFlags) );
    dprintf( "    Granularity:         %u bytes\n", AlignRound + 1 );
    dprintf( "    Segment Reserve:     %08x\n", (ULONG)ReadField(SegmentReserve) );
    dprintf( "    Segment Commit:      %08x\n", (ULONG)ReadField(SegmentCommit) );
    dprintf( "    DeCommit Block Thres:%08x\n", (ULONG)ReadField(DeCommitFreeBlockThreshold) );
    dprintf( "    DeCommit Total Thres:%08x\n", (ULONG)ReadField(DeCommitTotalFreeThreshold) );
    dprintf( "    Total Free Size:     %08x\n", (ULONG)ReadField(TotalFreeSize) );
    dprintf( "    Max. Allocation Size:%08x\n", (ULONG)ReadField(MaximumAllocationSize) );
    dprintf( "    Lock Variable at:    %08x\n", (ULONG)ReadField(LockVariable) );
    dprintf( "    Next TagIndex:       %04x\n", (ULONG)ReadField(NextAvailableTagIndex) );
    dprintf( "    Maximum TagIndex:    %04x\n", (ULONG)ReadField(MaximumTagIndex) );
    dprintf( "    Tag Entries:         %08x\n", (ULONG)ReadField(TagEntries) );
    dprintf( "    PsuedoTag Entries:   %08x\n", (ULONG)ReadField(PseudoTagEntries) );
    dprintf( "    Virtual Alloc List:  %08p\n", State->HeapAddress + Offset);

    UCRSegment = ReadField(UCRSegments);
    UnusedUnCommittedRanges = ReadField(UnusedUnCommittedRanges);
    Head = State->HeapAddress + Offset;
    Next = ReadField(VirtualAllocdBlocks.Flink);
    while (Next != Head) {
        ULONG Flags, TagIndex;

        if (InitTypeRead( Next, nt!_HEAP_VIRTUAL_ALLOC_ENTRY)) {
            dprintf( "    Unable to read nt!_HEAP_VIRTUAL_ALLOC_ENTRY structure at %p\n", Next );
            break;
        }

        if (State->DumpHeapEntries) {
            dprintf( "        %08p: %08x [%02x] - busy (%x)",
                     Next,
                     (ULONG)ReadField(CommitSize),
                     (ULONG)ReadField(CommitSize) - (ULONG)ReadField(BusyBlock.Size),
                     Flags = (ULONG)ReadField(BusyBlock.Flags)
                   );

            if ((ULONG)ReadField(BusyBlock.Flags) & HEAP_ENTRY_FILL_PATTERN) {
                dprintf( ", tail fill" );
            }
            if ((ULONG)ReadField(ExtraStuff.Settable)) {
                dprintf( " (Handle %08x)", (ULONG)ReadField(ExtraStuff.Settable) );
            }

            if (TagIndex = (ULONG)ReadField(ExtraStuff.TagIndex)) {
                WCHAR TagName[32];
                if (GetHeapTagEntry( State->Heap, (USHORT) (TagIndex), &TagEntry )) {
                    GetFieldValue(TagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                    dprintf( " (%ws)", TagName );
                }
                else {
                    dprintf( " (Tag %x)", (TagIndex) );
                }
            }

            if ((Flags) & HEAP_ENTRY_SETTABLE_FLAGS) {
                dprintf( ", user flags (%x)", ((Flags) & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
            }

            dprintf( "\n" );
#if STACK_TRACE_DATABASE_SUPPORT
            DumpStackBackTraceIndex( State, (ULONG)ReadField(ExtraStuff.AllocatorBackTraceIndex) );
#endif // STACK_TRACE_DATABASE_SUPPORT
        }

        if (ReadField(Entry.Flink) == Next) {
            dprintf( "        **** List is hosed\n");
            break;
        }

        Next = ReadField(Entry.Flink);
    }

    dprintf( "    UCR FreeList:        %p\n", UnusedUnCommittedRanges );
    while (UCRSegment != 0) {
        b = (BOOL) InitTypeRead( UCRSegment, nt!_HEAP_UCR_SEGMENT);
        if (b) {
            dprintf( "    Unable to read _HEAP_UCR_SEGMENT structure at %08p\n", UCRSegment );
            break;
        }
        else {
            dprintf( "    UCRSegment - %08p: %08I64x . %08I64x\n",
                     UCRSegment,
                     ReadField(CommittedSize),
                     ReadField(ReservedSize)
                     );
        }

        if (State->ComputeSummary) {
            State->OverheadSize += ReadField(CommittedSize);
        }

        UCRSegment = ReadField(Next);
    }

    InitTypeRead(State->HeapAddress, nt!_HEAP);

    dprintf( "    FreeList Usage:      %08x %08x %08x %08x\n",
             (ULONG)ReadField(u.FreeListsInUseUlong[0]),
             (ULONG)ReadField(u.FreeListsInUseUlong[1]),
             (ULONG)ReadField(u.FreeListsInUseUlong[2]),
             (ULONG)ReadField(u.FreeListsInUseUlong[3])
           );

    if (State->ComputeSummary) {
        State->OverheadSize += GetTypeSize( "nt!_HEAP" );
        dprintf( "Committed   Allocated     Free      OverHead\n" );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );

    }


    GetFieldOffset ("nt!_HEAP", "FreeLists", &Offset);
    ListSize = GetTypeSize("nt!_LIST_ENTRY");
    GetFieldOffset ("nt!_HEAP_FREE_ENTRY", "FreeList", &FreeListOffset);

    for (i=0; i<HEAP_MAXIMUM_FREELISTS; i++) {
        ULONG64 Flink, Blink;

        FreeListHead = State->HeapAddress + Offset + ListSize * i;

        GetFieldValue(FreeListHead, "nt!_LIST_ENTRY", "Flink", Flink);
        GetFieldValue(FreeListHead, "nt!_LIST_ENTRY", "Blink", Blink);

        if (Flink != Blink ||
            Flink != FreeListHead
            ) {

            ULONG Count = 0;

            dprintf( "    FreeList[ %02x ] at %08p: %08p . %08p  ",
                     i,
                     FreeListHead,
                     Blink,
                     Flink
                     );

            if (State->DumpHeapFreeLists) {
                dprintf("\n");
            }

            Next = Flink;
            while (Next != FreeListHead) {
                Count++;
                FreeEntryAddress = Next - FreeListOffset;
                b = (BOOL) InitTypeRead ( FreeEntryAddress, nt!_HEAP_FREE_ENTRY);
                if (b) {
                    dprintf( "    Unable to read nt!_HEAP_FREE_ENTRY structure at %08p\n", FreeEntryAddress );
                    break;
                    }

                if (State->DumpHeapFreeLists) {
                    dprintf( "        %08x: %05x . %05x [%02x] - free\n",
                             FreeEntryAddress,
                             (ULONG)ReadField(PreviousSize) << HEAP_GRANULARITY_SHIFT,
                             (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT,
                             (ULONG)ReadField(Flags)
                           );
                    }

                Next = ReadField(FreeList.Flink);

                if (CheckControlC()) {
                    return;
                    }
                }

                if (!State->DumpHeapFreeLists) {

                    dprintf( " (%ld block%c)\n",
                             Count,
                             (Count == 1 ? ' ' : 's')
                           );
                }
            }
        }

    for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
        if (State->Segments[ i ] != 0) {
            State->SegmentNumber = i;
            State->SegmentAddress = State->Segments[ i ];
            WalkHEAP_SEGMENT( State );
        }

        if (State->ExitDumpLoop || CheckControlC()) {
            break;
        }
    }

    if (State->HeapAddress == State->HeapToDump) {
        State->ExitDumpLoop = TRUE;
    }

    return;
}

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    )
{
    ULONG64 Segment; // PHEAP_SEGMENT
    BOOL b;
    BOOLEAN DumpEntry;
    ULONG64 EntryAddress, PrevEntryAddress, NextEntryAddress; // PHEAP_ENTRY
    ULONG64 Entry, PrevEntry;
    ULONG64 UnCommittedRanges; // PHEAP_UNCOMMMTTED_RANGE
    ULONG64 UnCommittedRangeStart, UnCommittedRange, UnCommittedRangeEnd;
    ULONG64 BaseAddress, LastValidEntry;
    ULONG NumberOfUnCommittedPages, NumberOfPages;
    ULONG EntryOffset;

    Segment = State->Segments[ State->SegmentNumber ];
    if (State->ComputeSummary) {
        State->OverheadSize += GetTypeSize( "nt!_HEAP_SEGMENT" );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    InitTypeRead(Segment, nt!_HEAP_SEGMENT);

    if (State->DumpHeapSegments) {
        dprintf( "    Segment%02u at %08x:\n", State->SegmentNumber, State->SegmentAddress );
        dprintf( "        Flags:           %08x\n", (ULONG)ReadField(Flags) );
        dprintf( "        Base:            %08p\n",
                 BaseAddress = ReadField(BaseAddress) );
        dprintf( "        First Entry:     %08x\n", (ULONG)ReadField(FirstEntry) );
        dprintf( "        Last Entry:      %08p\n",
                 LastValidEntry = ReadField(LastValidEntry) );
        dprintf( "        Total Pages:     %08x\n",
                 NumberOfPages = (ULONG)ReadField(NumberOfPages) );
        dprintf( "        Total UnCommit:  %08x\n",
                 NumberOfUnCommittedPages = (ULONG)ReadField(NumberOfUnCommittedPages) );
        dprintf( "        Largest UnCommit:%08x\n", (ULONG)ReadField(LargestUnCommittedRange) );
        dprintf( "        UnCommitted Ranges: (%u)\n", (ULONG)ReadField(NumberOfUnCommittedRanges) );
        }

    UnCommittedRangeStart = UnCommittedRanges = ReadField(UnCommittedRanges);
    while (UnCommittedRanges != 0) {
        b = (BOOL) InitTypeRead( UnCommittedRanges, nt!_HEAP_UNCOMMMTTED_RANGE);
        if (b) {
            dprintf( "            unable to read uncommited range structure at %p\n",
                     UnCommittedRanges
                   );
            return;
            }

        if (State->DumpHeapSegments) {
            dprintf( "            %08I64x: %08x\n", ReadField(Address), (ULONG) ReadField(Size) );
        }

        UnCommittedRanges = ReadField(Next);

        if (CheckControlC()) {
            break;
            }
        }

    if (State->DumpHeapSegments) {
        dprintf( "\n" );
        }

    if (!GetPageSize()) {
        dprintf("Unable to get PageSize.\n");
        return;

    }

    State->CommittedSize += ( NumberOfPages -
                                    NumberOfUnCommittedPages
                                  ) * PageSize;
    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    if (State->DumpHeapEntries) {
        dprintf( "    Heap entries for Segment%02u in Heap %p\n", State->SegmentNumber, State->HeapAddress );
        }

    UnCommittedRangeEnd = UnCommittedRanges;
    UnCommittedRanges = UnCommittedRangeStart;
    if (BaseAddress == State->HeapAddress) {
        GetFieldOffset("nt!_HEAP", "Entry", &EntryOffset);
        EntryAddress = State->HeapAddress + EntryOffset;
    }
    else {
        GetFieldOffset("nt!_HEAP_SEGMENT", "Entry", &EntryOffset);
        EntryAddress = State->Segments[ State->SegmentNumber ] + EntryOffset;
    }

    PrevEntryAddress = 0;
    while (EntryAddress < LastValidEntry) {
        ULONG Flags, Size, UnusedBytes;

        b = (BOOL) InitTypeRead(EntryAddress, nt!_HEAP_ENTRY);
        if (b) {
            dprintf( "            unable to read heap entry at %08p\n", EntryAddress );
            break;
        }

        NextEntryAddress = EntryAddress + (Size = (ULONG) ReadField(Size) * HeapEntryTypeSize);
        Flags = (ULONG) ReadField(Flags);
        UnusedBytes = (ULONG) ReadField(UnusedBytes);

        if (State->DumpHeapEntries) {
            DumpEntry = TRUE;
        }
        else
        if (PrevEntryAddress != 0 &&
            (State->HeapEntryToDump == PrevEntryAddress ||
             (State->HeapEntryToDump > PrevEntryAddress &&
              State->HeapEntryToDump <= NextEntryAddress
              )
             )
            ) {
           DumpEntry = TRUE;
        }
        else {
            DumpEntry = FALSE;
        }

        if (DumpEntry) {
            DumpHeapEntry( State, EntryAddress, EntryAddress );
        }

        if (!(Flags & HEAP_ENTRY_BUSY)) {
            State->TotalFreeSize += Size;
        }

        if (State->ComputeSummary) {
            if (Flags & HEAP_ENTRY_BUSY) {
                State->AllocatedSize += (ULONG64) Size << HEAP_GRANULARITY_SHIFT;
                State->AllocatedSize -= UnusedBytes;
                State->OverheadSize += UnusedBytes;
            }
            else {
                State->FreeSize += (ULONG64) Size << HEAP_GRANULARITY_SHIFT;
            }
        }

        if (State->ValidateHeap) {
            if (!ValidateHeapEntry( State,
                                    PrevEntryAddress,
                                    PrevEntryAddress,
                                    EntryAddress,
                                    EntryAddress
                                    )
                ) {
                if (State->DumpHeapEntries) {
                    break;
                }
            }
        }

        if (Size == 0 || CheckControlC()) {
            break;
        }

        PrevEntryAddress = EntryAddress;
        // PrevEntry = Entry;
        EntryAddress = NextEntryAddress;
        if (Flags & HEAP_ENTRY_LAST_ENTRY) {

            if (State->ComputeSummary) {
                dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                         State->CommittedSize,
                         State->AllocatedSize,
                         State->FreeSize,
                         State->OverheadSize
                         );
            }

            InitTypeRead(UnCommittedRanges, nt!_HEAP_UNCOMMMTTED_RANGE);

            if (EntryAddress == ReadField(Address)) {

                Size = (ULONG) ReadField(Size);

                if (DumpEntry) {
                    dprintf( "        %p:      %08x      - uncommitted bytes.\n",
                             EntryAddress,
                             Size
                             );
                }

                PrevEntryAddress = 0;
                EntryAddress += Size;

                UnCommittedRanges = ReadField(Next);;
            }
            else {
                break;
            }
        }
    }

    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
    }

    return;
}

struct {
    BOOL  HaveOffset;
    ULONG Offset;
    LPSTR Description;
} FieldOffsets[] = {
    0, 0,    "Entry",
    0, 0,    "Signature",
    0, 0,    "Flags",
    0, 0,    "ForceFlags",
    0, 0,    "VirtualMemoryThreshold",
    0, 0,    "SegmentReserve",
    0, 0,    "SegmentCommit",
    0, 0,    "DeCommitFreeBlockThreshold",
    0, 0,    "DeCommitTotalFreeThreshold",
    0, 0,    "TotalFreeSize",
    0, 0,    "MaximumAllocationSize",
    0, 0,    "ProcessHeapsListIndex",
    0, 0,    "HeaderValidateLength",
    0, 0,    "HeaderValidateCopy",
    0, 0,    "NextAvailableTagIndex",
    0, 0,    "MaximumTagIndex",
    0, 0,    "TagEntries",
    0, 0,    "UCRSegments",
    0, 0,    "UnusedUnCommittedRanges",
    0, 0,    "AlignRound",
    0, 0,    "AlignMask",
    0, 0,    "VirtualAllocdBlocks",
    0, 0,    "Segments",
    0, 0,    "FreeListsInUse",
    0, 0,    "FreeListsInUseTerminate",
    0, 0,    "AllocatorBackTraceIndex",
    0, 0,    "Reserved1",
    0, 0,    "PseudoTagEntries",
    0, 0,    "FreeLists",
    0, 0,    "LockVariable",
//     1, GetTypeSize("HEAP"),                                     "Uncommitted Ranges",
    0, 0xFFFF, NULL
};

BOOL
ValidateHeapHeader(
    IN ULONG64 HeapAddress
    )
{
    PVOID CurrentHeaderValidate;
    PVOID PreviousHeaderValidate;
    ULONG i, n, nEqual;
    ULONG64 HeaderValidateCopy;
    ULONG64 HeapSignature;
    BOOL b;

    if (InitTypeRead(HeapAddress, nt!_HEAP)) {
        return FALSE;
    }

    HeapSignature = ReadField(Signature);
    if ( (ULONG)HeapSignature != HEAP_SIGNATURE ) {
        dprintf( "Heap at %p contains invalid signature %I64X.\n",
                  HeapAddress,
                  HeapSignature );
        return FALSE;
        }

    n = (ULONG) ReadField(HeaderValidateLength);
    if (n == 0 || (HeaderValidateCopy = ReadField(HeaderValidateCopy)) == 0) {
        return TRUE;
    }

    b = FALSE;
    CurrentHeaderValidate = malloc( n );
    if (CurrentHeaderValidate != NULL) {
        PreviousHeaderValidate = malloc( n );
        if (PreviousHeaderValidate != NULL) {
            b = ReadMemory( HeapAddress,
                            CurrentHeaderValidate,
                            n,
                            NULL
                          );
            if (b) {
                b = ReadMemory( (HeaderValidateCopy),
                                PreviousHeaderValidate,
                                n,
                                NULL
                              );
                if (b) {
                    nEqual = (ULONG)RtlCompareMemory( CurrentHeaderValidate,
                                               PreviousHeaderValidate,
                                               n
                                             );
                    if (nEqual != n) {
                        dprintf( "HEAPEXT: Heap %p - headers modified (%p is %x instead of %x)\n",
                                 HeapAddress,
                                 HeapAddress + nEqual,
                                 *(PULONG)((PCHAR)CurrentHeaderValidate  + nEqual),
                                 *(PULONG)((PCHAR)PreviousHeaderValidate + nEqual)
                               );
                        for (i=0; FieldOffsets[ i ].Description != NULL; i++) {

                            if (!FieldOffsets[i].HaveOffset) {
                                GetFieldOffset("nt!_HEAP", FieldOffsets[i].Description, &FieldOffsets[i].Offset);
                                FieldOffsets[i].HaveOffset = TRUE;
                            }
                            if (nEqual >= FieldOffsets[ i ].Offset &&
                                nEqual < FieldOffsets[ i+1 ].Offset
                               ) {
                                dprintf( "    This is located in the %s field of the heap header.\n",
                                         FieldOffsets[ i ].Description
                                       );
                                }
                            }

                        b = FALSE;
                    }
                }
                else {
                    dprintf( "HEAPEXT: Unable to read copy of heap headers.\n" );
                }
            }
            else {
                dprintf( "HEAPEXT: Unable to read heap headers.\n" );
            }
        }
        else {
            dprintf( "HEAPEXT: Unable to allocate memory for heap header copy.\n" );
        }
    }
    else {
        dprintf( "HEAPEXT: Unable to allocate memory for heap header.\n" );
    }

    return b;
}

UCHAR CheckHeapFillPattern[ 20 ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL
};

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 PrevEntryAddress,
    IN ULONG64 PrevEntry,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    )
{
    UCHAR EntryTail[ 20  ]; // CHECK_HEAP_TAIL_SIZE
    ULONG FreeFill[ 256 ];
    ULONG64 FreeAddress;
    ULONG tSize, cb, cbEqual;
    BOOL b;
    ULONG PreviousSize, Flags, Size, UnusedBytes, SmallTagIndex;
    ULONG SizeOfEntry;

    SizeOfEntry = GetTypeSize("nt!_HEAP_ENTRY");
    InitTypeRead(EntryAddress, nt!_HEAP_ENTRY);
    (PreviousSize = (ULONG) ReadField(PreviousSize));
    (Size = (ULONG) ReadField(Size));
    (Flags = (ULONG) ReadField(Flags));
    UnusedBytes = (ULONG) ReadField(UnusedBytes);
    SmallTagIndex = (ULONG) ReadField(SmallTagIndex);

    InitTypeRead(PrevEntryAddress, nt!_HEAP_ENTRY);
    if (PrevEntryAddress == 0 && PreviousSize != 0) {
        dprintf( "    PreviousSize field is non-zero when it should be zero to mark first entry\n" );
        return FALSE;
    }

    if (PrevEntryAddress != 0 && PreviousSize != (ULONG) ReadField(Size)) {
        dprintf( "    PreviousSize field does not match size in previous entry\n" );
        return FALSE;
    }

    if (Flags & HEAP_ENTRY_BUSY) {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            tSize = (Size << HEAP_GRANULARITY_SHIFT) - UnusedBytes;
            b = ReadMemory( (EntryAddress+ HeapEntryTypeSize + tSize),
                            EntryTail,
                            sizeof( EntryTail ),
                            NULL
                          );
            if (b) {
                cbEqual = (ULONG)RtlCompareMemory( EntryTail,
                                            CheckHeapFillPattern,
                                            CHECK_HEAP_TAIL_SIZE
                                          );
                if (cbEqual != CHECK_HEAP_TAIL_SIZE) {
                    dprintf( "    Heap block at %p modified at %p past requested size of %x (%x * 8 - %x)\n",
                             EntryAddress,
                             EntryAddress + HeapEntryTypeSize + tSize + cbEqual,
                             tSize, Size, UnusedBytes
                           );
                    return FALSE;
                    }
                }
            else {
                dprintf( "    Unable to read tail of heap block at %p\n", EntryAddress );
                return FALSE;
                }
            }
        }
    else {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            tSize = (Size - 2) << HEAP_GRANULARITY_SHIFT;
            if (Flags & HEAP_ENTRY_EXTRA_PRESENT &&
                tSize > GetTypeSize( "nt!_HEAP_FREE_ENTRY_EXTRA" )
               ) {
                tSize -= GetTypeSize( "nt!_HEAP_FREE_ENTRY_EXTRA" );
                }
            FreeAddress = EntryAddress + GetTypeSize("nt!_HEAP_FREE_ENTRY");
            while (tSize != 0) {
                if (tSize > sizeof( FreeFill )) {
                    cb = sizeof( FreeFill );
                }
                else {
                    cb = tSize;
                }
                b = ReadMemory( FreeAddress,
                                FreeFill,
                                cb,
                                NULL
                                );
                if (b) {
                    cbEqual = (ULONG)RtlCompareMemoryUlong( FreeFill, cb, FREE_HEAP_FILL );
                    if (cbEqual != cb) {                                                            \
                        dprintf( "    Free Heap block %p modified at %p after it was freed\n",
                                 EntryAddress,
                                 FreeAddress + cbEqual
                                 );

                    return FALSE;
                    }
                }
                else {
                    dprintf( "    Unable to portion of free heap block at %p\n", EntryAddress );
                    return FALSE;
                }

                tSize -= cb;
            }
        }
    }

    return TRUE;
}


VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    )
{
    BOOL b;
    WCHAR TagName[32];
//    HEAP_ENTRY_EXTRA EntryExtra;
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
//    HEAP_FREE_ENTRY_EXTRA FreeExtra;
    ULONG64 p;
    USHORT BackTraceIndex;
    ULONG PreviousSize, Size, Flags, UnusedBytes, SmallTagIndex;
    ULONG SizeOfEntry;

    SizeOfEntry = GetTypeSize("nt!_HEAP_ENTRY");
    InitTypeRead(EntryAddress, nt!_HEAP_ENTRY);
    dprintf( "        %p: %05x . %05x [%02x]",
             EntryAddress,
             (PreviousSize = (ULONG) ReadField(PreviousSize)) << HEAP_GRANULARITY_SHIFT,
             (Size = (ULONG) ReadField(Size)) << HEAP_GRANULARITY_SHIFT,
             (Flags = (ULONG) ReadField(Flags))
           );
    BackTraceIndex = 0;
    UnusedBytes = (ULONG) ReadField(UnusedBytes);
    SmallTagIndex = (ULONG) ReadField(SmallTagIndex);
    if (Flags & HEAP_ENTRY_BUSY) {
        dprintf( " - busy (%x)",
                 (Size << HEAP_GRANULARITY_SHIFT) - UnusedBytes
               );
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( ", tail fill" );
            }
        if (Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = EntryAddress + SizeOfEntry * (Size - 1);
            b = (BOOL) InitTypeRead( p, nt!_HEAP_ENTRY_EXTRA);
            if (b) {
                dprintf( " - unable to read heap entry extra at %p", p );
            }
            else {
                BackTraceIndex = (USHORT)ReadField(AllocatorBackTraceIndex);
                if ((ULONG)ReadField(Settable)) {
                    dprintf( " (Handle %08x)", (ULONG)ReadField(Settable) );
                }
                if ((ULONG)ReadField(TagIndex)) {
                    if (GetHeapTagEntry( State->Heap, (USHORT)ReadField(TagIndex), &TagEntry )) {
                        GetFieldValue(TagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                        dprintf( " (%ws)", TagName );
                    }
                    else {
                        dprintf( " (Tag %x)", (ULONG)ReadField(TagIndex) );
                    }
                }
            }
        }
        else
        if (SmallTagIndex) {
            if (GetHeapTagEntry( State->Heap, (USHORT) SmallTagIndex, &TagEntry )) {
                GetFieldValue(TagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                dprintf( " (%ws)", TagName );
                }
            else {
                dprintf( " (Tag %x)", SmallTagIndex );
                }
            }

        if (Flags & HEAP_ENTRY_SETTABLE_FLAGS) {
            dprintf( ", user flags (%x)", (Flags & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
            }

        dprintf( "\n" );
        }
    else {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( " free fill" );
            }

        if (Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = (EntryAddress + SizeOfEntry * (Size - 1));
            b = (BOOL) InitTypeRead( p, nt!_HEAP_ENTRY_EXTRA);
            if (b) {
                dprintf( " - unable to read heap free extra at %p", p );
                }
            else {
                BackTraceIndex = (USHORT)ReadField(FreeBackTraceIndex);
                if (GetHeapTagEntry( State->Heap, (USHORT)ReadField(TagIndex), &TagEntry )) {
                    GetFieldValue(TagEntry, "nt!_HEAP_TAG_ENTRY", "TagName", TagName);
                    dprintf( " (%ws)", TagName );
                    }
                else {
                    dprintf( " (Tag %x at %p)", (ULONG)ReadField(TagIndex), p );
                    }
                }
            }

        dprintf( "\n" );
        }

#if STACK_TRACE_DATABASE_SUPPORT
    DumpStackBackTraceIndex( State, BackTraceIndex );
#endif // STACK_TRACE_DATABASE_SUPPORT
    return;
}


#if STACK_TRACE_DATABASE_SUPPORT && 0
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    )
{
    BOOL b;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    RTL_STACK_TRACE_ENTRY BackTraceEntry;
    ULONG i;
    CHAR Symbol[ 1024 ];
    ULONG_PTR Displacement;

    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    if (State->DumpStackBackTrace &&
        BackTraceIndex != 0 &&
        pRtlpStackTraceDataBase != NULL
       ) {
        if (!HaveCopyOfStackTraceDataBase) {
            b = ReadMemory( (ULONG_PTR)pRtlpStackTraceDataBase,
                            &RtlpStackTraceDataBase,
                            sizeof( RtlpStackTraceDataBase ),
                            NULL
                          );
            if (!b || RtlpStackTraceDataBase == NULL) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            b = ReadMemory( (ULONG_PTR)RtlpStackTraceDataBase,
                            &StackTraceDataBase,
                            sizeof( StackTraceDataBase ),
                            NULL
                          );
            if (!b) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            HaveCopyOfStackTraceDataBase = TRUE;
            }

        if (BackTraceIndex < StackTraceDataBase.NumberOfEntriesAdded) {
            b = ReadMemory( (ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                            &pBackTraceEntry,
                            sizeof( pBackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace index (%x) entry at %p\n",
                         BackTraceIndex,
                         (StackTraceDataBase.EntryIndexArray - BackTraceIndex)
                       );
                return;
                }

            b = ReadMemory( (ULONG_PTR)pBackTraceEntry,
                            &BackTraceEntry,
                            sizeof( BackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace entry at %p\n",
                         BackTraceIndex,
                         pBackTraceEntry
                       );
                return;
                }

            dprintf( "            Stack trace (%u) at %x:\n", BackTraceIndex, pBackTraceEntry );
            for (i=0; i<BackTraceEntry.Depth; i++) {
                GetSymbol( (LPVOID)BackTraceEntry.BackTrace[ i ],
                           Symbol,
                           &Displacement
                         );
                dprintf( "                %08x: %s", BackTraceEntry.BackTrace[ i ], Symbol );
                if (Displacement != 0) {
                    dprintf( "+0x%p", Displacement );
                    }
                dprintf( "\n" );
                }
            }
        }
}
#endif // STACK_TRACE_DATABASE_SUPPORT

#if 0
int
__cdecl
_wtoi(
    const wchar_t *nptr
    )
{
    NTSTATUS Status;
    ULONG Value;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, nptr );
    Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &Value );
    if (NT_SUCCESS( Status )) {
        return (int)Value;
        }
    else {
        return 0;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    WinDbg Extension Api

Author:

    Kshitiz K Sharma

Environment:

    User/Kernel Mode.

Revision History:

--*/

#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PageSize) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0


#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001


#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE GetTypeSize("nt!_HEAP_ENTRY")
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#define HEAP_NO_SERIALIZE               0x00000001      // winnt
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_CREATE_ALIGN_16            0x00010000      // winnt Create heap with 16 byte alignment (obsolete)
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      // winnt Create heap call tracing enabled (obsolete)

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800
#define HEAP_SETTABLE_USER_FLAGS        0x00000E00

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
#define HEAP_CLASS_MASK                 0x0000F000

#define HEAP_MAXIMUM_TAG                0x0FFF              // winnt
#define HEAP_GLOBAL_TAG                 0x0800
#define HEAP_PSEUDO_TAG_FLAG            0x8000              // winnt
#define HEAP_TAG_SHIFT                  18                  // winnt
#define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))  // winnt
#define HEAP_TAG_MASK                  (HEAP_MAXIMUM_TAG << HEAP_TAG_SHIFT)

#define HEAP_CREATE_VALID_MASK         (HEAP_NO_SERIALIZE |             \
                                        HEAP_GROWABLE |                 \
                                        HEAP_GENERATE_EXCEPTIONS |      \
                                        HEAP_ZERO_MEMORY |              \
                                        HEAP_REALLOC_IN_PLACE_ONLY |    \
                                        HEAP_TAIL_CHECKING_ENABLED |    \
                                        HEAP_FREE_CHECKING_ENABLED |    \
                                        HEAP_DISABLE_COALESCE_ON_FREE | \
                                        HEAP_CLASS_MASK |               \
                                        HEAP_CREATE_ALIGN_16 |          \
                                        HEAP_CREATE_ENABLE_TRACING)

//
// Definitions from \nt\base\ntos\inc\heappage.h
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_NO_UMDH_SUPPORT           0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040 // obsolete
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000
#define PAGE_HEAP_USE_READONLY              0x8000

//
//  heap walking contexts.
//

#define CONTEXT_START_GLOBALS   11

#define CONTEXT_START_HEAP      1
#define CONTEXT_END_HEAP        2

#define CONTEXT_START_SEGMENT   3
#define CONTEXT_END_SEGMENT     4

#define CONTEXT_FREE_BLOCK      5
#define CONTEXT_BUSY_BLOCK      6
#define CONTEXT_LOOKASIDE_BLOCK 7
#define CONTEXT_VIRTUAL_BLOCK   8
#define CONTEXT_END_BLOCKS      9

#define CONTEXT_ERROR           10

#define CONTEXT_LFH_HEAP         11
#define CONTEXT_START_SUBSEGMENT 12
#define CONTEXT_END_SUBSEGMENT   13

#define SCANPROCESS 1
#define SCANHEAP    2
#define SCANSEGMENT 3

extern ULONG ScanLevel;


typedef BOOLEAN (*HEAP_ITERATOR_CALLBACK)(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    );


void
ScanProcessHeaps (
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb,
    HEAP_ITERATOR_CALLBACK HeapCallback
    );

void InspectLeaks (
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb
    );

void
DumpEntryHeader();

void
DumpEntryInfo(
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    ULONG64 EntryAddress
    );

void
DumpEntryFlagDescription (
    ULONG Flags
    );

BOOLEAN
SearchVMReference (
    HANDLE hProcess,
    ULONG64 Base,
    ULONG64 EndAddress
    );


extern ULONG PageSize;
extern ULONG HeapEntrySize;
extern ULONG PointerSize;

BOOLEAN
InitializeHeapExtension();

VOID
HeapDetectLeaks();

VOID
HeapFindBlock (
    LPCTSTR szArguments
    );

VOID
HeapStat(
    LPCTSTR szArguments
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\exts\extsdll\heapfind.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heapleak.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian Marinescu (adrmarin) 04/17/2000

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop


ULONG64 AddressToFind;

ULONG64 HeapAddressFind;
ULONG64 SegmentAddressFind;
ULONG64 HeapEntryFind;
ULONG64 HeapEntryFindSize;
BOOLEAN Lookaside;

BOOLEAN VerifyBlocks;

ULONG64 DumpOptions = 0xffffff;

#define HEAP_DUMP_FREE_LISTS 1
#define HEAP_DUMP_GFLAGS     2
#define HEAP_DUMP_GTAGS      4
#define HEAP_DUMP_FREE_LISTS_DETAILS 8

BOOLEAN ScanVM;

ULONG
GetFieldSize (
    IN  LPCSTR  Type,
    IN  LPCSTR  Field
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};

   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };

   ULONG RetVal;

   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   return flds.size;
}


ULONG
ReadLongValue(LPTSTR Symbol)
{
    ULONG64 Address;
    ULONG Value = 0;

    Address = GetExpression( Symbol );

    if ( (Address == 0) ||
         !ReadMemory( Address, &Value, sizeof( Value ), NULL )) {

        dprintf( "HEAPEXT: Unable to read %s\n", Symbol );
    }

    return Value;
}



#define CheckAndPrintFlag(x)\
    if (Flags & (x)) dprintf(#x" ");

void
DumpFlagDescription(ULONG Flags)
{
    CheckAndPrintFlag(HEAP_NO_SERIALIZE);
    CheckAndPrintFlag(HEAP_GROWABLE);
    CheckAndPrintFlag(HEAP_GENERATE_EXCEPTIONS);
    CheckAndPrintFlag(HEAP_ZERO_MEMORY);
    CheckAndPrintFlag(HEAP_REALLOC_IN_PLACE_ONLY);
    CheckAndPrintFlag(HEAP_TAIL_CHECKING_ENABLED);
    CheckAndPrintFlag(HEAP_FREE_CHECKING_ENABLED);
    CheckAndPrintFlag(HEAP_DISABLE_COALESCE_ON_FREE);
    CheckAndPrintFlag(HEAP_CREATE_ALIGN_16);
    CheckAndPrintFlag(HEAP_CREATE_ENABLE_TRACING);
}

void
DumpEntryFlagDescription(ULONG Flags)
{
    if (Flags & HEAP_ENTRY_BUSY) dprintf("busy "); else dprintf("free ");
    if (Flags & HEAP_ENTRY_EXTRA_PRESENT) dprintf("extra ");
    if (Flags & HEAP_ENTRY_FILL_PATTERN) dprintf("fill ");
    if (Flags & HEAP_ENTRY_VIRTUAL_ALLOC) dprintf("virtual ");
    if (Flags & HEAP_ENTRY_LAST_ENTRY) dprintf("last ");
    if (Flags & HEAP_ENTRY_SETTABLE_FLAGS) dprintf("user_flag ");
}

void
DumpEntryHeader()
{
    dprintf("Entry     User      Heap      Segment       Size  PrevSize  Flags\n");
    dprintf("----------------------------------------------------------------------\n");
}

void
DumpEntryInfo(
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    ULONG64 EntryAddress
    )
{
    ULONG SizeOfEntry;
    ULONG PreviousSize;
    ULONG Flags;
    ULONG Size;
    UCHAR SegmentIndex;
    UCHAR SmallTagIndex;

    SizeOfEntry = GetTypeSize("nt!_HEAP_ENTRY"); // same as granularity
    InitTypeRead(EntryAddress, nt!_HEAP_ENTRY);

    PreviousSize = (ULONG)ReadField(PreviousSize) * SizeOfEntry;
    Size = (ULONG) ReadField(Size) * SizeOfEntry;
    Flags = (ULONG) ReadField(Flags);
    SegmentIndex = (UCHAR) ReadField(SegmentIndex);
    SmallTagIndex = (UCHAR) ReadField(SmallTagCode);

    if (SegmentIndex != 0xff) {

        dprintf("%p  %p  %p  %p  %8lx  %8lx  ",
                EntryAddress,
                EntryAddress + SizeOfEntry,
                HeapAddress,
                SegmentAddress,
                Size,
                PreviousSize
                );

        DumpEntryFlagDescription(Flags);

        if (Lookaside) {
            dprintf(" - lookaside ");
        }

    } else {

        ULONG64 SubSegment = ReadField(SubSegment);
        ULONG64 BlockSize;

        GetFieldValue(SubSegment, "ntdll!_HEAP_SUBSEGMENT", "BlockSize", BlockSize);

        Size = (ULONG)BlockSize * SizeOfEntry;

        dprintf("%p  %p  %p  %p  %8lx      -     ",
                EntryAddress,
                EntryAddress + SizeOfEntry,
                HeapAddress,
                SegmentAddress,
                Size
                );

        if (SmallTagIndex) {

            dprintf("LFH_BUSY; ");
        } else {
            dprintf("LFH_FREE; ");
        }
        DumpEntryFlagDescription(Flags);
    }

    dprintf("\n");
}

void
DumpHeapStructure (ULONG64 HeapAddress)
{
    ULONG AlignRound, Offset;

    if (InitTypeRead(HeapAddress, nt!_HEAP)) {

        return;
    }

    GetFieldOffset("nt!_HEAP", "VirtualAllocdBlocks", &Offset);
    AlignRound = (ULONG)ReadField(AlignRound) - GetTypeSize( "nt!_HEAP_ENTRY" );

    if ((ULONG)ReadField(Flags) & HEAP_TAIL_CHECKING_ENABLED) {

        AlignRound -= CHECK_HEAP_TAIL_SIZE;
    }

    AlignRound += 1;

    dprintf( "    Flags:               %08x ", (ULONG)ReadField(Flags) );
    DumpFlagDescription((ULONG)ReadField(Flags)); dprintf("\n");

    dprintf( "    ForceFlags:          %08x ", (ULONG)ReadField(ForceFlags) );
    DumpFlagDescription((ULONG)ReadField(ForceFlags)); dprintf("\n");

    dprintf( "    Granularity:         %u bytes\n", AlignRound );
    dprintf( "    Segment Reserve:     %08x\n", (ULONG)ReadField(SegmentReserve));
    dprintf( "    Segment Commit:      %08x\n", (ULONG)ReadField(SegmentCommit) );
    dprintf( "    DeCommit Block Thres:%08x\n", (ULONG)ReadField(DeCommitFreeBlockThreshold) );
    dprintf( "    DeCommit Total Thres:%08x\n", (ULONG)ReadField(DeCommitTotalFreeThreshold) );
    dprintf( "    Total Free Size:     %08x\n", (ULONG)ReadField(TotalFreeSize) );
    dprintf( "    Max. Allocation Size:%08x\n", (ULONG)ReadField(MaximumAllocationSize) );
    dprintf( "    Lock Variable at:    %p\n", ReadField(LockVariable) );
    dprintf( "    Next TagIndex:       %04x\n", (ULONG)ReadField(NextAvailableTagIndex) );
    dprintf( "    Maximum TagIndex:    %04x\n", (ULONG)ReadField(MaximumTagIndex) );
    dprintf( "    Tag Entries:         %08x\n", (ULONG)ReadField(TagEntries) );
    dprintf( "    PsuedoTag Entries:   %08x\n", (ULONG)ReadField(PseudoTagEntries) );
    dprintf( "    Virtual Alloc List:  %p\n", HeapAddress + Offset);

    if (DumpOptions & (HEAP_DUMP_FREE_LISTS | HEAP_DUMP_FREE_LISTS_DETAILS)) {

        ULONG i, ListSize, FreeListOffset;

        dprintf( "    FreeList Usage:      %08x %08x %08x %08x\n",
                 (ULONG)ReadField(u.FreeListsInUseUlong[0]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[1]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[2]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[3])
               );

        GetFieldOffset ("nt!_HEAP", "FreeLists", &Offset);
        ListSize = GetTypeSize("nt!_LIST_ENTRY");
        GetFieldOffset ("nt!_HEAP_FREE_ENTRY", "FreeList", &FreeListOffset);

        for (i=0; i<HEAP_MAXIMUM_FREELISTS; i++) {

            ULONG64 Flink, Blink, Next;
            ULONG64 FreeListHead;
            ULONG Count = 0;
            ULONG MinSize = 0, MaxSize = 0;

            FreeListHead = HeapAddress + Offset + ListSize * i;

            GetFieldValue(FreeListHead, "nt!_LIST_ENTRY", "Flink", Flink);
            GetFieldValue(FreeListHead, "nt!_LIST_ENTRY", "Blink", Blink);

            if (Flink != FreeListHead) {

                dprintf( "    FreeList[ %02x ] at %08p",
                         i,
                         FreeListHead
                         );

                if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                    dprintf("\n");
                }

                Next = Flink;
                while (Next != FreeListHead) {

                    ULONG Size, PrevSize, Flags;
                    ULONG64 FreeEntryAddress;

                    FreeEntryAddress = Next - FreeListOffset;

                    if (InitTypeRead ( FreeEntryAddress, nt!_HEAP_FREE_ENTRY)) {

                        if (Count) {
                            dprintf( "     Total: %ld blocks (%08lx, %08lx)  * Error reading %p\n",
                                     Count,
                                     MinSize,
                                     MaxSize,
                                     FreeEntryAddress
                                   );
                        } else {
                            dprintf( "     No blocks in list. Error reading %p\n",
                                     FreeEntryAddress
                                   );
                        }

                        break;
                    }

                    Size = (ULONG)ReadField(Size) * AlignRound;
                    PrevSize = (ULONG)ReadField(PreviousSize) * AlignRound;
                    Flags = (ULONG)ReadField(Flags);

                    if (!Count) {

                        MinSize = MaxSize = Size;

                    } else {

                        if (Size < MinSize) MinSize = Size;
                        if (Size > MaxSize) MaxSize = Size;
                    }

                    if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                        dprintf( "        %08p: %05x . %05x [%02x] - ",
                                 FreeEntryAddress,
                                 PrevSize,
                                 Size,
                                 Flags
                               );

                        DumpEntryFlagDescription(Flags);

                        dprintf("\n");
                    }

                    Count += 1;

                    ReadPointer(Next, &Next);

                    if (CheckControlC()) {
                        return;
                    }
                }

                if (Count) {

                    if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                        dprintf("       ");
                    }

                    dprintf( " * Total %ld block(s) (%08lx, %08lx)\n",
                             Count,
                             MinSize,
                             MaxSize
                           );
                }
            }
        }
    }
}

void
DumpGlobals()
{
    ULONG64 pNtGlobalFlag, NtGlobalFlag = 0;
    ULONG64 pNtTempGlobal, NtTempGlobal = 0;

    NtGlobalFlag = ReadLongValue("NTDLL!NtGlobalFlag");

    if ((NtGlobalFlag & (FLG_HEAP_ENABLE_TAIL_CHECK |
                         FLG_HEAP_ENABLE_FREE_CHECK |
                         FLG_HEAP_VALIDATE_PARAMETERS |
                         FLG_HEAP_VALIDATE_ALL |
                         FLG_HEAP_ENABLE_TAGGING |
                         FLG_USER_STACK_TRACE_DB |
                         FLG_HEAP_DISABLE_COALESCING )) != 0 ) {

        dprintf( "NtGlobalFlag enables following debugging aids for new heaps:" );

        if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {
            dprintf( "    tail checking\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {
            dprintf( "    free checking\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {
            dprintf( "    validate parameters\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {
            dprintf( "    validate on call\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING) {
            dprintf( "    heap tagging\n" );
        }

        if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {
            dprintf( "    stack back traces\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {
            dprintf( "    disable coalescing of free blocks\n" );
        }
    }

    NtTempGlobal = ReadLongValue( "NTDLL!RtlpDisableHeapLookaside" );

    if (NtTempGlobal) {

        dprintf( "The process has the following heap extended settings %08lx:\n", (ULONG)NtTempGlobal );

        if (NtTempGlobal & 1) {

            dprintf("   - Lookasides disabled\n");
        }

        if (NtTempGlobal & 2) {

            dprintf("   - Large blocks cache disabled\n");
        }

        if (NtTempGlobal & 8) {

            dprintf("   - Low Fragmentation Heap activated for all heaps\n");
        }

        dprintf("\n");
    }

    pNtTempGlobal = GetExpression( "NTDLL!RtlpAffinityState" );

    if ( pNtTempGlobal ) {

        ULONG64 TempValue;
        ULONG64 AffinitySwaps;
        ULONG64 AffinityResets;
        ULONG64 AffinityAllocs;

        GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "Limit", TempValue);

        if (TempValue) {

            dprintf("Affinity manager status:\n");
            dprintf("   - Virtual affinity limit %I64ld\n", TempValue);

            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "CrtLimit", TempValue);
            dprintf("   - Current entries in use %ld\n", (LONG)TempValue);

            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinitySwaps", AffinitySwaps);
            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinityResets", AffinityResets);
            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinityAllocs", AffinityAllocs);

            dprintf("   - Statistics:  Swaps=%I64ld, Resets=%I64ld, Allocs=%I64ld\n\n",
                    AffinitySwaps,
                    AffinityResets,
                    AffinityAllocs
                    );
        }
    }
}

BOOLEAN HeapFindRoutine(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    switch (Context) {

    case CONTEXT_START_HEAP:

        //
        //  we found a block, we won't need then to search in other heaps
        //

        if (HeapEntryFind) {
            ScanLevel = 0;
        }

        break;

    case CONTEXT_FREE_BLOCK:
    case CONTEXT_BUSY_BLOCK:
    case CONTEXT_LOOKASIDE_BLOCK:
    case CONTEXT_VIRTUAL_BLOCK:

        if ((AddressToFind >= EntryAddress) &&
            (AddressToFind < (EntryAddress + Data))) {

            if (HeapEntryFind == 0) {

                HeapAddressFind = HeapAddress;
                SegmentAddressFind = SegmentAddress;
            }

            if (Context == CONTEXT_LOOKASIDE_BLOCK) {

                Lookaside = TRUE;

                ScanLevel = 0;
            }

            HeapEntryFind = EntryAddress;
            HeapEntryFindSize = Data;
        }

        break;

    case CONTEXT_ERROR:

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
                HeapAddress,
                SegmentAddress,
                EntryAddress,
                (LPSTR) (ULONG_PTR) Data
               );

        break;
    }
    return TRUE;
}

BOOLEAN
SearchVMReference (
    HANDLE hProcess,
    ULONG64 Base,
    ULONG64 EndAddress
    )
{
    NTSTATUS Status;
    SIZE_T BufferLen;
    ULONG_PTR lpAddress = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    PVOID MemoryBuffer;

    if ( hProcess ) {

        MemoryBuffer = malloc(PageSize);

        if (!MemoryBuffer) {

           dprintf("Not enough memory. Abording.\n");

           return FALSE;
        }

        dprintf("Search VM for address range %p - %p : ",Base, EndAddress);

        BufferLen = sizeof(Buffer);

        while (BufferLen) {

            BufferLen = VirtualQueryEx( hProcess,
                                        (LPVOID)lpAddress,
                                        &Buffer,
                                        sizeof(Buffer)
                                      );

            if (BufferLen) {

                if ((Buffer.AllocationProtect & (PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY)) /*&&
                    (Buffer.Type == MEM_PRIVATE)*/) {

                    ULONG64 NumPages;
                    ULONG i, j;

                    NumPages = Buffer.RegionSize / PageSize;

                    for (i = 0; i < NumPages; i++) {

                        if (ReadMemory( (ULONG64)(lpAddress + i * PageSize),
                                         MemoryBuffer,
                                         PageSize,
                                         NULL
                                         )) {

                            ULONG_PTR * Pointers = (ULONG_PTR *)MemoryBuffer;

                            for (j = 0; j < PageSize/sizeof(ULONG_PTR); j++) {

                                ULONG_PTR Address = lpAddress + i * PageSize + j * sizeof(ULONG_PTR);

                                if ((*Pointers >= Base) &&
                                    (*Pointers <= EndAddress)) {

                                    dprintf("%08lx (%08lx), ",
                                           Address,
                                           *Pointers
                                           );
                                }

                                Pointers += 1;
                            }
                        }
                    }
                }

                lpAddress += Buffer.RegionSize;
            }
        }

        dprintf("\n");
        free(MemoryBuffer);
    }

    return TRUE;
}

VOID
HeapStat(LPCTSTR szArguments);

VOID
HeapFindBlock(LPCTSTR szArguments)
{
    ULONG64 Process;
    ULONG64 ThePeb;
    HANDLE hProcess;


    if (!InitializeHeapExtension()) {

        return;
    }

    HeapEntryFind = 0;
    HeapEntryFindSize = 0;
    HeapAddressFind = 0;
    SegmentAddressFind = 0;
    Lookaside = FALSE;
    AddressToFind = 0;

    GetPebAddress( 0, &ThePeb);
    GetCurrentProcessHandle( &hProcess );

    ScanVM = FALSE;

    {
        LPSTR p = (LPSTR)szArguments;

        while (p && *p) {

            if (*p == '-') {

                p++;

                if (toupper(*p) == 'V') {

                    ScanVM = TRUE;
                }

            } else if (isxdigit(*p)) {

                GetExpressionEx(p, &AddressToFind, &p);

                continue;
            }

            p++;
        }
    }

    if (AddressToFind == 0) {

        dprintf("Syntax:\n!heap -x [-v] address\n");
        return;
    }

    ScanProcessHeaps( 0,
                      ThePeb,
                      HeapFindRoutine
                      );

    if (HeapEntryFind) {

        DumpEntryHeader();

        DumpEntryInfo(HeapAddressFind, SegmentAddressFind, HeapEntryFind);

        dprintf("\n");

        if (ScanVM) {

            SearchVMReference(hProcess, HeapEntryFind, HeapEntryFind + HeapEntryFindSize - 1);
        }
    } else {

        if (ScanVM) {
            SearchVMReference(hProcess, AddressToFind, AddressToFind);
        }
    }
}

//
//  Heap stat implementation
//

typedef struct _SIZE_INFO {
    ULONG Busy;
    ULONG Free;
    ULONG FrontHeapAllocs;
    ULONG FrontHeapFrees;
}SIZE_INFO, *PSIZE_INFO;

typedef struct _HEAP_STATS {

    ULONG   HeapIndex;
    ULONG64 HeapAddress;
    ULONG64 ReservedMemory;
    ULONG64 CommitedMemory;
    ULONG64 VirtualBytes;
    ULONG64 FreeSpace;
    ULONG   Flags;
    ULONG   FreeListLength;
    ULONG   VirtualBlocks;
    ULONG   UncommitedRanges;
    ULONG64 LockContention;
    ULONG   FrontEndHeapType;
    ULONG64 FrontEndHeap;

    BOOLEAN ScanningSubSegment;

}HEAP_STATS, *PHEAP_STATS;

HEAP_STATS CrtHeapStat;
PSIZE_INFO SizeInfo = NULL;
ULONG BucketSize;
ULONG LargestBucketIndex = 0;
ULONG64 StatHeapAddress;
ULONG DumpBlocksSize = 0;

ULONG
FASTCALL
HeapStatSizeToSizeIndex(ULONG64 Size)
{
    ULONG Index = (ULONG)(Size / BucketSize);

    if (Index >= LargestBucketIndex) {

        Index = LargestBucketIndex - 1;
    }

    return Index;
}


VOID
HeapStatDumpBlocks()
{
    ULONG Index;
    ULONG64 Busy = 0, Free = 0, FEBusy = 0, FEFree = 0;


    dprintf("\n                    Default heap   Front heap  \n");
    dprintf("   Range (bytes)     Busy  Free    Busy   Free \n");
    dprintf("----------------------------------------------- \n");
    if (SizeInfo == NULL) {

        return;
    }

    for ( Index = 0; Index < LargestBucketIndex; Index++ ) {

        if (SizeInfo[Index].Busy
            ||
     