        if (m_et.scWellKnownMode.Count > 0)
            m_dgObjectURIs.CurrentCell = new DataGridCell(0,0);

        for (int i=0; i<m_et.scWellKnownMode.Count; i++)
            m_et.scWellKnownUri[i]=(String)m_dtObjectURIs.Rows[i]["URI"];

        String sSettingCommand = "ExposedTypes";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;

        return CConfigStore.SetSetting(sSettingCommand, m_et);
    }// ApplyData
}// class CRemotingProp2

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cresourcestore.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CResourceStore.cs
//
// This will be used to manage all the data that needs to 
// be shared across all classes. It currently deals with 
// localized strings and icons 
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Resources;
using System.Reflection;
using System.Runtime.InteropServices;
using System.IO;
using System.Drawing;
using System.Collections;


//-------------------------------------------------
// struct ImgInfo
//
// For each img we pre-cache the handle and some sort
// of string identifier for it
//-------------------------------------------------
internal struct ImgInfo
{
    internal IntPtr handle;
    internal int iType;
    internal String id;
    internal int iWidth;
    internal int iHeight;
}// struct ImgInfo

internal class CResourceStore    
{   
    // Image type identifiers
    private const int  ICON    = 1;
    private const int  BITMAP  = 2;

    static private ResourceManager m_rResourceManager; // Used to read strings
    static private ResourceManager m_rResourceManagerHTML;

    static private Assembly        m_aAssem;           // Used to fetch resources 
    static private IntPtr          m_hModule;          // Used to fetch resources

    static private ArrayList       m_olImgs;           // Cached images

    //-------------------------------------------------
    // CResourceStore
    //
    // This function generates a Resource manager and 
    // creates our Icon cache with 1 open slot
    //-------------------------------------------------
    static CResourceStore()
    {
        m_aAssem = Assembly.GetExecutingAssembly();
        String s = m_aAssem.FullName;
        m_hModule = (IntPtr)Marshal.GetHINSTANCE((m_aAssem.GetLoadedModules())[0]);        

        m_rResourceManager = new ResourceManager("mscorcfgstrings", 
                                                    m_aAssem, 
                                                    null);
                                                    
        m_rResourceManagerHTML = new ResourceManager("mscorcfghtml", 
                                                    m_aAssem, 
                                                    null);

        m_olImgs = new ArrayList();
        
    }// CResourceManager

    //-------------------------------------------------
    // Shutdown
    //
    // This function should be called before the process
    // exits. It will release any icon and bitmap handles
    // that are opened.
    //-------------------------------------------------
    static internal void Shutdown()
    {
        for(int i=0; i<m_olImgs.Count; i++)
        {
            if (((ImgInfo)m_olImgs[i]).iType == ICON)
                DestroyIcon(((ImgInfo)m_olImgs[i]).handle);
            else
                DeleteObject(((ImgInfo)m_olImgs[i]).handle);
        }

        m_olImgs = new ArrayList();
    }// Shutdown

    //-------------------------------------------------
    // GetHTMLFile
    //
    // This function will return the specified HTML
    // document
    //-------------------------------------------------
    static internal String GetHTMLFile(String sFilename)
    {
        return m_rResourceManagerHTML.GetString(sFilename);
    }// GetHTMLFile

    static internal IntPtr GetDialogTemplate()
    {
        IntPtr hresinfo = FindResource(m_hModule, "IDD_WFCWRAPPERPROP", 5);
        int iSizeOfFile = SizeofResource(m_hModule, hresinfo);
    	IntPtr h = LoadResource(m_hModule, hresinfo);
    	IntPtr pstr = LockResource(h);
        return pstr;
    }// GetHTMLFile

    //-------------------------------------------------
    // GetGIF
    //
    // This function will return a GIF
    //-------------------------------------------------
    static internal Byte[] GetGIF(String sFilename)
    {
        return GetFile(sFilename);
    }// GetGIF

    //-------------------------------------------------
    // GetMSI
    //
    // This function will return a MSI File
    //-------------------------------------------------
    static internal Byte[] GetMSI(String sFilename)
    {
        return GetFile(sFilename);
    }// GetMSI

    //-------------------------------------------------
    // GetFile
    //
    // This function will return a file that was stored in the resource
    //-------------------------------------------------
    static private Byte[] GetFile(String sFilename)
    {
        // Find the file Resource
        Stream s = m_aAssem.GetManifestResourceStream(sFilename);
        BinaryReader br = new BinaryReader(s);
        // This shouldn't be a big deal. Stream.Length is stored as
        // a Int64 and BinaryReader.ReadBytes takes in an Int32.
        // However, our files shouldn't get very big so casing the Int64
        // to an Int32 shouldn't cause any problems.
        return br.ReadBytes((int)s.Length);
    }// GetFile

    //-------------------------------------------------
    // StoreHIcon
    //
    // If the snapin obtains a HIcon during execution,
    // we can pass it into here, where it will be remembered
    // and assigned a cookie
    //-------------------------------------------------
    static internal int StoreHIcon(IntPtr hIcon)
    {
        // Store this away in our cache
        ImgInfo ii = new ImgInfo();
        ii.id = "";
        ii.iType = ICON;
        ii.handle = hIcon;
        m_olImgs.Add(ii);

        return m_olImgs.Count-1;
    }// StoreHIcon

    //-------------------------------------------------
    // GetHIcon
    //
    // This function will return a handle to an icon
    // given it's resource name
    //-------------------------------------------------
    static internal IntPtr GetHIcon(String s)
    {
        ImgInfo ii;

        // If we don't have this icon cached/loaded, we'll
        // go load it now
        if (FindIcon(s, out ii) == -1)
            ii = LoadIcon(s);

        return ii.handle;
    }// GetHIcon

    //-------------------------------------------------
    // GetIconCookie
    //
    // This function will return the cookie associated
    // with this given icon. This cookie usually corresponds
    // to an index number in an image list 
    //-------------------------------------------------
    static internal int GetIconCookie(String s)
    {
        ImgInfo ii;
        int iCookie = FindIcon(s, out ii);
        // If we couldn't find the icon, then go ahead and load the icon,
        // cache it, and assign it a cookie.
        if (iCookie == -1)
        {
            LoadIcon(s);
            iCookie = m_olImgs.Count-1;
        }
        return iCookie;
    }// GetIconCookie(String s)

    //-------------------------------------------------
    // GetIconCookie
    //
    // Same as above, but takes in an hIcon instead
    // of the resource string
    //-------------------------------------------------
    static internal int GetIconCookie(IntPtr hIcon)
    {
        return FindIcon(hIcon);
    }// GetIconCookie(int hIcon)

    //-------------------------------------------------
    // LoadIcon
    //
    // This function will load an icon resource and store
    // it in a ImgInfo structure. Since the majority of 
    // the icon work in this snapin is done through interop, 
    // we cache HICONs instead of Icon objects.
    //-------------------------------------------------
    static private ImgInfo LoadIcon(String s)
    {
        ImgInfo ii = new ImgInfo();
        ii.id = s;
        ii.iType = ICON;

        Bitmap newbp = new Bitmap(GetManResource(s));
        ii.handle = newbp.GetHicon();

        // Once we're loaded this icon, store it in our cache.
        m_olImgs.Add(ii);
        return ii;
     
    }// LoadIcon

    //-------------------------------------------------
    // FindIcon
    //
    // This will look through the icon cache for an icon  
    // based on the resource description
    //-------------------------------------------------
    static private int FindIcon(String s, out ImgInfo ii)
    {
        ii=new ImgInfo();
        for(int i=0; i<m_olImgs.Count; i++)
            if (((ImgInfo)m_olImgs[i]).iType == ICON && s.Equals(((ImgInfo)m_olImgs[i]).id))
            {   
                ii = (ImgInfo)m_olImgs[i];
                return i;
            }
        // Didn't find a match
        return -1;
    }// FindIcon

    //-------------------------------------------------
    // FindIcon
    //
    // This will look through the icon cache for an icon  
    // based on the hicon
    //-------------------------------------------------
    static private int FindIcon(IntPtr hIcon)
    {
        for(int i=0; i<m_olImgs.Count; i++)
            if (((ImgInfo)m_olImgs[i]).iType == ICON && hIcon == ((ImgInfo)m_olImgs[i]).handle)
            {   
                return i;
            }
        // Didn't find a match
        return -1;
    }// FindIcon

    static internal IntPtr GetHBitmap(String s, int iWidth, int iHeight, bool fCache)
    {   
        if (fCache)
            // GetHBitmap will cache our bitmap handle so it can be used
            // again if needed. We also track the handle and free it on shutdown
            return GetHBitmap(s, iWidth, iHeight, true);
        else
            // LoadHBitmap skips the whole caching of the bitmap and lets
            // whoever created it be responsible for freeing it
            return LoadHBitmap(s, iWidth, iHeight);
        
    }// GetHBitmap

    static internal IntPtr CreateWindowBitmap(int nWidth, int nHeight)
    {
        // See if we already have this bitmap
        ImgInfo ii;

        // If we don't have this icon cached/created, we'll
        // go create it
        if (FindBitmap("WindowBitmap", nWidth, nHeight,  out ii) == -1)
        {    
            Bitmap bm = new Bitmap(nWidth, nHeight);
            // This is ugly
            for(int i=0; i<nWidth; i++)
                for (int j=0; j<nHeight; j++)
                    bm.SetPixel(i, j, SystemColors.Window);

            ii = new ImgInfo();
            ii.handle = TranslateBitmapToBeCompatibleWithScreen(bm.GetHbitmap());
            ii.iType = BITMAP;
            ii.id = "WindowBitmap";
            ii.iWidth = nWidth;
            ii.iHeight = nHeight;
            // Once we're loaded this bitmap, store it in our cache.
            m_olImgs.Add(ii);
         }
         
         return ii.handle;
    
    }// CreateWindowBitmap
    
    //-------------------------------------------------
    // GetBitmap
    //
    // This will return a HBITMAP. This result is not
    // cached. Currently, we pull bitmaps out of Win32
    // Resource files using PInvoke. 
    //-------------------------------------------------
    static internal IntPtr GetHBitmap(String s, int iWidth, int iHeight)
    {   
        ImgInfo ii;

        // If we don't have this icon cached/loaded, we'll
        // go load it now
        if (FindBitmap(s, iWidth, iHeight,  out ii) == -1)
            ii = LoadBitmap(s, iWidth, iHeight);
           
        return ii.handle;
    }// GetHBitmap

    //-------------------------------------------------
    // FindBitmap
    //
    // This will search through the image cache looking for
    // the specified bitmap
    //-------------------------------------------------
    static private int FindBitmap(String s, int iWidth, int iHeight, out ImgInfo ii)
    {   
        ii=new ImgInfo();
        for(int i=0; i<m_olImgs.Count; i++)
            if (((ImgInfo)m_olImgs[i]).iType == BITMAP && s.Equals(((ImgInfo)m_olImgs[i]).id) 
                && ((ImgInfo)m_olImgs[i]).iWidth==iWidth && ((ImgInfo)m_olImgs[i]).iHeight==iHeight)
            {   
                ii = (ImgInfo)m_olImgs[i];
                return i;
            }
        // Didn't find a match
        return -1;
    }// FindBitmap

    //-------------------------------------------------
    // LoadBitmap
    //
    // This will load a bitmap and store it in our cache
    //-------------------------------------------------
    static private ImgInfo LoadBitmap(String sName, int iWidth, int iHeight)
    {   
        ImgInfo ii = new ImgInfo();
        ii.handle = LoadHBitmap(sName, iWidth, iHeight);
        ii.iType = BITMAP;
        ii.id = sName;
        ii.iWidth = iWidth;
        ii.iHeight = iHeight;

        // Once we're loaded this bitmap, store it in our cache.
        m_olImgs.Add(ii);

        return ii;
    }// LoadBitmap

    //-------------------------------------------------
    // LoadHBitmap
    //
    // This will load a hbitmap and translate it so it
    // can be displayed on the screen
    //-------------------------------------------------
    static private IntPtr LoadHBitmap(String sName, int iWidth, int iHeight)
    {   
        Stream s = m_aAssem.GetManifestResourceStream(sName);
        Bitmap bm = new Bitmap(s);
        
        IntPtr handle = new Bitmap(bm, iWidth, iHeight).GetHbitmap();

        return TranslateBitmapToBeCompatibleWithScreen(handle);
    }// LoadHBitmap

    //-------------------------------------------------
    // GetString
    //
    // This will fetch a string resource. Note that strings
    // are not cached.
    //-------------------------------------------------
    static internal String GetString(String s)
    {
        String st = m_rResourceManager.GetString(s);
        if (st == null || st.Length == 0)
            return s;
        return st;
    }// GetString

    //-------------------------------------------------
    // GetInt
    //
    // This will fetch an int resource. We've stored the
    // int as a string, so we'll need to parse the string
    // into an int
    //-------------------------------------------------
    
    static internal int GetInt(String s)
    {
        String st = m_rResourceManager.GetString(s);
        if (st == null || st.Length==0)
            return 0;

        return Int32.Parse(st);
    }// GetInt


    //-------------------------------------------------
    // GetCoString
    //
    // This will fetch a string resource and return a 'pointer'
    // to it using memory allocated by CoTaskMemAlloc
    //-------------------------------------------------
    static internal IntPtr GetCoString(String s)
    {
        return Marshal.StringToCoTaskMemUni(GetString(s));
    }// GetCoString           

    //-------------------------------------------------
    // GetManResource
    //
    // This will return a managed resource contained in a
    // stream
    //-------------------------------------------------
    static internal Stream GetManResource(String s)
    {
        Stream st =  m_aAssem.GetManifestResourceStream(s);
        if (st == null)
            throw new Exception("Unable to find resource " + s);
        return st;    
    }// GetManResource

    //-------------------------------------------------
    // TranslateBitmapToBeCompatibleWithScreen
    //
    // This is really messy. A quick explanation of what's going on....
    //
    // If we were to call Bitmap.GetHbitmap, we'll get back an HBitmap that
    // is intended for 32-bit displays. 
    //
    // MMC expects the HBITMAP it gets to be compatible with the screen. So, 
    // if the current video display is not set to 32 bit, MMC will fail to show the bitmap.
    //
    // So what do we do? We translate the bitmaps into the color depth that the screen
    // is currently displaying
    //-------------------------------------------------
    internal static IntPtr TranslateBitmapToBeCompatibleWithScreen(IntPtr hBitmap)
    {
        IntPtr hFinalHBitmap = IntPtr.Zero;
        
        // Get a DC that is compatible with the display
        IntPtr hdc = CreateCompatibleDC(IntPtr.Zero);

        // Now get the BITMAP information on this guy
        DIBSECTION ds = new DIBSECTION();
        int nLen = GetObject(hBitmap, Marshal.SizeOf(typeof(DIBSECTION)), ref ds);

        // Create a BITMAPINFO structure and put in the appropriate values
        BITMAPINFO bmi = new BITMAPINFO();
        bmi.bmiHeader = ds.dsBmih;

        // Now, we want to change the color depth from 32 bpp to whatever the screen supports...
        int nOldDepth = bmi.bmiHeader.biBitCount;
        bmi.bmiHeader.biBitCount = (ushort)GetDeviceCaps(hdc, 12 /* BITSPIXEL */);

        IntPtr bits; // Garbage variable... just need it for the function call

        // This will create a bitmap handle with the color depth of the current screen
        hFinalHBitmap = CreateDIBSection(hdc, ref bmi, 0 /* DIB_RGB_COLORS */, out bits, IntPtr.Zero, 0);  

        // Put back the bitmap's original color depth
        bmi.bmiHeader.biBitCount = (ushort)nOldDepth;
        
        // Translate the 32bpp pixels to something the screen can show
        SetDIBits(hdc, hFinalHBitmap, 0, bmi.bmiHeader.biHeight, ds.dsBm.bmBits, ref bmi, 0);

        // Cleanup
        DeleteDC(hdc);
        
        return hFinalHBitmap;
    }// TranslateBitmapToBeCompatibleWithScreen

    //-------------------------------------------------
    // We need to import the Win32 API calls used to deal with
    // image loading.
    //-------------------------------------------------
    [DllImport("gdi32.dll")]
    public static extern IntPtr CreateCompatibleDC(IntPtr hdc);
    [DllImport("gdi32.dll")]
    public static extern uint DeleteDC(IntPtr hdc);
    [DllImport("gdi32.dll")]
    internal static extern int GetObject(IntPtr hgdiobj, int cbBuffer, ref DIBSECTION lpvObject);
    [DllImport("gdi32.dll")]
    internal static extern int SetDIBits(IntPtr hdc, IntPtr hbmp, uint uStartScan, int uScanLines, IntPtr lpvBits, ref BITMAPINFO lpbmi, uint fuColorUse);
    [DllImport("gdi32.dll")]
    internal static extern IntPtr CreateDIBSection(IntPtr hdc, ref BITMAPINFO pbmi, uint iUsage, out IntPtr ppvBits, IntPtr hSection, uint dwOffset);
    [DllImport("gdi32.dll")]
    internal static extern int GetDeviceCaps(IntPtr hdc, int nIndex);

	//-------------------------------------------------
    // We need to import the Win32 API calls used to deal with
    // image loading.
    //-------------------------------------------------
    [DllImport("gdi32.dll")]
    internal static extern int DeleteObject(IntPtr hObject);
    [DllImport("user32.dll")]
    internal static extern int DestroyIcon(IntPtr hIcon);
    [DllImport("kernel32.dll", CharSet=CharSet.Ansi)]
    internal static extern IntPtr FindResource(IntPtr mod, String sFilename, int type);
    [DllImport("kernel32.dll")]
    internal static extern IntPtr LoadResource(IntPtr mod, IntPtr hresinfo);
    [DllImport("kernel32.dll")]
	internal static extern IntPtr LockResource(IntPtr h);
	[DllImport("kernel32.dll")]
	internal static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);
	
	[DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);
   }// class CResourceStore
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecurityadjustmentwiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security.Policy;
using System.Security;


internal class CSecurityAdjustmentWiz2 : CWizardPage
{
    // Controls on the page
    private Label m_lblSelectZone;
    private GroupBox m_gbChooseLevel;
    private ListView m_lvZones;
    private Label m_lblNoTrust;
    private Label m_lblFullTrust;
    private Button m_btnDefault;
        
    private Label m_lblTrustDescription;
    private TrackBar m_tbLevelOfTrust;
    private Label m_lblZoneDescription;

    // Internal data
    String[]            m_sZoneDescriptions;
    String[]            m_sSecLevelDescriptions;
    int[]               m_nZoneLevels;
    int[]               m_nDefaultLevels;
    int[]               m_nMaxLevels;
    ImageList           m_ilIcons;
    String              m_sOriginalGBText;

    internal CSecurityAdjustmentWiz2()
    {
        m_sTitle=CResourceStore.GetString("CSecurityAdjustmentWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CSecurityAdjustmentWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CSecurityAdjustmentWiz2:HeaderSubTitle");

        // Set up the zone descriptions
        m_sZoneDescriptions = new String[] { CResourceStore.GetString("CSecurityAdjustmentWiz2:MyComputerDes"),
                                             CResourceStore.GetString("CSecurityAdjustmentWiz2:IntranetDes"),
                                             CResourceStore.GetString("CSecurityAdjustmentWiz2:InternetDes"),
                                             CResourceStore.GetString("CSecurityAdjustmentWiz2:TrustedDes"),
                                             CResourceStore.GetString("CSecurityAdjustmentWiz2:UntrustedDes")
                                            };

        m_sSecLevelDescriptions = new String[] { 
                                                CResourceStore.GetString("TightSecurityDes"),
                                                CResourceStore.GetString("FairlyTightSecurityDes"),
                                                CResourceStore.GetString("FairlyLooseSecurityDes"),
                                                CResourceStore.GetString("LooseSecurityDes"),
                                                CResourceStore.GetString("CSecurityAdjustmentWiz2:Custom")
                                               };

                                                        
        m_nDefaultLevels = new int[] {PermissionSetType.FULLTRUST, 
                                      PermissionSetType.INTRANET, 
                                      PermissionSetType.INTERNET, 
                                      PermissionSetType.INTERNET, 
                                      PermissionSetType.NONE};
                                      
        m_nZoneLevels = null;
       
    }// CSecurityAdjustmentWiz2

    internal int[] SecurityLevels
    {
        get
        {
            return m_nZoneLevels;
        }
        set
        {
            m_nZoneLevels = value;    
        }
    }// SecurityLevels

    internal int[] MaxLevels
    {
        get
        {
            return m_nMaxLevels;
        }
        set
        {
            m_nMaxLevels=value;
        }

    }// MaxLevels
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSecurityAdjustmentWiz2));
        this.m_lblSelectZone = new System.Windows.Forms.Label();
        this.m_gbChooseLevel = new System.Windows.Forms.GroupBox();
        this.m_lvZones = new System.Windows.Forms.ListView();
        this.m_lblNoTrust = new System.Windows.Forms.Label();
        this.m_lblFullTrust = new System.Windows.Forms.Label();
        this.m_btnDefault = new System.Windows.Forms.Button();
        this.m_lblZoneDescription = new System.Windows.Forms.Label();
        this.m_lblTrustDescription = new System.Windows.Forms.Label();
        this.m_tbLevelOfTrust = new System.Windows.Forms.TrackBar();
        ((System.ComponentModel.ISupportInitialize)(this.m_tbLevelOfTrust)).BeginInit();
/*        this.m_lblSelectZone.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSelectZone.Location")));
        this.m_lblSelectZone.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSelectZone.Size")));
        this.m_lblSelectZone.TabIndex = ((int)(resources.GetObject("m_lblSelectZone.TabIndex")));
        this.m_lblSelectZone.Text = resources.GetString("m_lblSelectZone.Text");
  */
        this.m_lblSelectZone.Visible = false;
        this.m_gbChooseLevel.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblTrustDescription,
                        this.m_lblNoTrust,
                        this.m_lblFullTrust,
                        this.m_tbLevelOfTrust,
                        this.m_btnDefault});
        this.m_gbChooseLevel.Location = ((System.Drawing.Point)(resources.GetObject("m_gbChooseLevel.Location")));
        this.m_gbChooseLevel.Size = ((System.Drawing.Size)(resources.GetObject("m_gbChooseLevel.Size")));
        this.m_gbChooseLevel.TabIndex = ((int)(resources.GetObject("m_gbChooseLevel.TabIndex")));
        this.m_gbChooseLevel.TabStop = false;
        this.m_gbChooseLevel.Text = resources.GetString("m_gbChooseLevel.Text");
        m_gbChooseLevel.Name = "ChooseLevelBox";
        m_sOriginalGBText = m_gbChooseLevel.Text;
        this.m_lvZones.Location = ((System.Drawing.Point)(resources.GetObject("m_lvZones.Location")));
        this.m_lvZones.Size = ((System.Drawing.Size)(resources.GetObject("m_lvZones.Size")));
        this.m_lvZones.TabIndex = ((int)(resources.GetObject("m_lvZones.TabIndex")));
        m_lvZones.Name = "Zones";
        this.m_lblNoTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_lblNoTrust.Location")));
        this.m_lblNoTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_lblNoTrust.Size")));
        this.m_lblNoTrust.TabIndex = ((int)(resources.GetObject("m_lblNoTrust.TabIndex")));
        this.m_lblNoTrust.Text = resources.GetString("m_lblNoTrust.Text");
        m_lblNoTrust.TextAlign = ContentAlignment.MiddleCenter;
        m_lblNoTrust.Name = "NoTrustLabel";
        this.m_lblFullTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_lblFullTrust.Location")));
        this.m_lblFullTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_lblFullTrust.Size")));
        this.m_lblFullTrust.TabIndex = ((int)(resources.GetObject("m_lblFullTrust.TabIndex")));
        this.m_lblFullTrust.Text = resources.GetString("m_lblFullTrust.Text");
        m_lblFullTrust.Name = "FullTrustLabel";
        m_lblFullTrust.TextAlign = ContentAlignment.MiddleCenter;

        this.m_btnDefault.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDefault.Location")));
        this.m_btnDefault.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDefault.Size")));
        this.m_btnDefault.TabIndex = ((int)(resources.GetObject("m_btnDefault.TabIndex")));
        this.m_btnDefault.Text = resources.GetString("m_btnDefault.Text");
        m_btnDefault.Name = "Default";

        this.m_lblZoneDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblZoneDescription.Location")));
        this.m_lblZoneDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblZoneDescription.Size")));
        this.m_lblZoneDescription.TabIndex = ((int)(resources.GetObject("m_lblZoneDescription.TabIndex")));
        m_lblZoneDescription.Name = "ZoneDescription";
        this.m_lblTrustDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblTrustDescription.Location")));
        this.m_lblTrustDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblTrustDescription.Size")));
        this.m_lblTrustDescription.TabIndex = ((int)(resources.GetObject("m_lblTrustDescription.TabIndex")));
        m_lblTrustDescription.Name = "TrustDescription";
        this.m_tbLevelOfTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_tbLevelOfTrust.Location")));
        this.m_tbLevelOfTrust.Maximum = 3;
        this.m_tbLevelOfTrust.Orientation = System.Windows.Forms.Orientation.Vertical;
        this.m_tbLevelOfTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_tbLevelOfTrust.Size")));
        this.m_tbLevelOfTrust.TabIndex = ((int)(resources.GetObject("m_tbLevelOfTrust.TabIndex")));
        this.m_tbLevelOfTrust.LargeChange = 1;
        m_tbLevelOfTrust.Name = "TrustLevel";
        
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblZoneDescription,
                        this.m_lvZones,
                        this.m_gbChooseLevel,
                        this.m_lblSelectZone});
        ((System.ComponentModel.ISupportInitialize)(this.m_tbLevelOfTrust)).EndInit();

        // Some tweaks on the listview
        // Create an image list of icons we'll be displaying
        m_ilIcons = new ImageList();
        m_ilIcons.ImageSize = new Size(32, 32);
        // Keep the order of these consistant with the const's declared at the top
        // of this class
        m_ilIcons.Images.Add(Bitmap.FromHbitmap(CResourceStore.GetHBitmap("IDB_MYCOMPUTER", 32, 32)));
        m_ilIcons.Images.Add(Bitmap.FromHbitmap(CResourceStore.GetHBitmap("IDB_INTRANET", 32, 32)));
        m_ilIcons.Images.Add(Bitmap.FromHbitmap(CResourceStore.GetHBitmap("IDB_INTERNET", 32, 32)));
        m_ilIcons.Images.Add(Bitmap.FromHbitmap(CResourceStore.GetHBitmap("IDB_TRUSTED", 32, 32)));
        m_ilIcons.Images.Add(Bitmap.FromHbitmap(CResourceStore.GetHBitmap("IDB_UNTRUSTED", 32, 32)));
        m_ilIcons.TransparentColor = Color.White;

        // Some customizations we've made....
        m_lvZones.LargeImageList = m_ilIcons;
        m_lvZones.MultiSelect = false;
        m_lvZones.View = View.LargeIcon;
        m_lvZones.Activation = System.Windows.Forms.ItemActivation.OneClick;
        m_lvZones.HideSelection=false;

        PutValuesinPage();
        
        m_lvZones.Items[0].Selected = true;
        // Hook up the event handlers
        m_tbLevelOfTrust.ValueChanged += new EventHandler(onLevelChange);
        m_lvZones.SelectedIndexChanged += new EventHandler(onZoneChange);
        m_btnDefault.Click += new EventHandler(onResetClick);

        return 1;
    }// InsertPropSheetPageControls

    void AdjustTrackbarForZone(int nZoneNum)
    {
        // See if we can do anything yet....
        if (m_nZoneLevels == null)
            return;
            
    
        bool fShowTrackbar = true;

        // Always try to make this button visible....
        m_btnDefault.Visible=true;
        
        m_lblZoneDescription.Text = m_sZoneDescriptions[nZoneNum];
        m_lblTrustDescription.Text = m_sSecLevelDescriptions[m_nZoneLevels[nZoneNum]];

        // Put the default text into the groupbox
        m_gbChooseLevel.Text = m_sOriginalGBText;

        if (m_nZoneLevels[nZoneNum] == PermissionSetType.UNKNOWN)
        {
            fShowTrackbar = false;
        }
        else
        {
            String[] sVals = new String[] {
                    CResourceStore.GetString("CSecurityAdjustmentWiz3:NoTrustName"),
                    CResourceStore.GetString("CSecurityAdjustmentWiz3:InternetName"),
                    CResourceStore.GetString("CSecurityAdjustmentWiz3:LocalIntranetName"),
                    CResourceStore.GetString("CSecurityAdjustmentWiz3:FullTrustName")
                    };

            // Ok, now we shouldn't allow the user to increase the security level past
            // the allowed max value
            if (MaxLevels != null)
            {

                m_tbLevelOfTrust.Maximum = MaxLevels[nZoneNum];

                // Ok, this sucks... the user can't modify the policy at all....
                if (m_tbLevelOfTrust.Maximum == m_tbLevelOfTrust.Minimum)
                {
                    fShowTrackbar=false;
                    m_btnDefault.Visible=false;
                    m_gbChooseLevel.Text = CResourceStore.GetString("CSecurityAdjustmentWiz2:CantChange");
                }


                // We also need to change the label text of the maximum value to be 
                // something other that 'no trust'
                m_lblFullTrust.Text = sVals[MaxLevels[nZoneNum]];
            }
            
            // Now put in the value into the trackbar
            m_tbLevelOfTrust.Value = m_nZoneLevels[nZoneNum];
        }

        m_tbLevelOfTrust.Visible = fShowTrackbar;
        m_lblNoTrust.Visible = fShowTrackbar;
        m_lblFullTrust.Visible = fShowTrackbar;
        if (!m_lvZones.Items[nZoneNum].Selected)
            m_lvZones.Items[nZoneNum].Selected = true;


    }// AdjustTrackbarForZone

    void onZoneChange(Object o, EventArgs e)
    {
        if (m_lvZones.SelectedIndices.Count > 0)
        {
            AdjustTrackbarForZone(m_lvZones.SelectedIndices[0]);
        }
            
    }// onZoneChange

    void onLevelChange(Object o, EventArgs e)
    {
        m_lblTrustDescription.Text = m_sSecLevelDescriptions[m_tbLevelOfTrust.Value];
        if (m_lvZones.SelectedIndices.Count > 0)
            m_nZoneLevels[m_lvZones.SelectedIndices[0]] = m_tbLevelOfTrust.Value;
    }// onLevelChange

    void onResetClick(Object o, EventArgs e)
    {
        if (m_lvZones.SelectedIndices.Count > 0)
        {   
            // See if we can select the default value....
            if (m_nDefaultLevels[m_lvZones.SelectedIndices[0]] > MaxLevels[m_lvZones.SelectedIndices[0]] || MaxLevels[m_lvZones.SelectedIndices[0]]== PermissionSetType.UNKNOWN)
                MessageBox(CResourceStore.GetString("CSecurityAdjustmentWiz2:CantGoToDefaultPolicy"),
                           CResourceStore.GetString("CSecurityAdjustmentWiz2:CantGoToDefaultPolicyTitle"),
                           MB.ICONEXCLAMATION);
                            
                            
            else
            {
                m_nZoneLevels[m_lvZones.SelectedIndices[0]] = m_nDefaultLevels[m_lvZones.SelectedIndices[0]];
                onZoneChange(null, null);
            }
        }
    }// onResetClick

    internal void PutValuesinPage()
    {
        // Put stuff in the List view
        m_lvZones.Items.Clear();
        m_lvZones.Items.Add(CResourceStore.GetString("MyComputer"), 0);
        m_lvZones.Items.Add(CResourceStore.GetString("LocalIntranet"), 1);
        m_lvZones.Items.Add(CResourceStore.GetString("Internet"), 2);
        m_lvZones.Items.Add(CResourceStore.GetString("Trusted"), 3);
        m_lvZones.Items.Add(CResourceStore.GetString("Untrusted"), 4);
        AdjustTrackbarForZone(0);

    }// PutValuesinPage
  
}// class CSecurityAdjustmentWiz2
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecurityadjustmentwiz3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Security.Policy;
using System.Security;

internal class CSecurityAdjustmentWiz3 : CWizardPage
{
    // Controls on the page

    DataTable           m_dt;
    Label               m_lblSummary;
    DataGrid            m_dg;
    Label               m_lblDes;
    DataSet             m_ds;
    Label               m_lblUserProblem;

    // Internal data
    int[]                m_nLevels;
    bool                 m_fUserProblems;

    
    internal CSecurityAdjustmentWiz3()
    {
        m_sTitle=CResourceStore.GetString("CSecurityAdjustmentWiz3:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz3:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CSecurityAdjustmentWiz3:HeaderSubTitle");
        m_nLevels = null;
        m_fUserProblems = false;
    }// CSecurityAdjustmentWiz3

    internal void Init(int[] nLevels)
    {
        m_nLevels = nLevels;  
        CreateTable();
        m_lblUserProblem.Visible = m_fUserProblems;

    }// Init

    internal bool UserProblems
    {
        set{m_fUserProblems = value;}
    }// UserProblems

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSecurityAdjustmentWiz3));
        this.m_dg = new System.Windows.Forms.DataGrid();
        this.m_lblSummary = new System.Windows.Forms.Label();
        this.m_lblDes = new System.Windows.Forms.Label();
        m_lblUserProblem = new System.Windows.Forms.Label();
        // Set up the GUI-type stuff for the data grid
        this.m_dg.DataMember = "";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        m_dg.BackgroundColor = Color.White;

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcZone = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcSecurityLevel = new DataGridTextBoxColumn();
         
        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;
        // Set up the column info for the Property column
        dgtbcZone.MappingName = "Zone";
        dgtbcZone.HeaderText = CResourceStore.GetString("CSecurityAdjustmentWiz3:ZoneColumn");
        dgtbcZone.ReadOnly = true;
        dgtbcZone.Width = ScaleWidth(CResourceStore.GetInt("CSecurityAdjustmentWiz3:ZoneColumnWidth"));
        dgts.GridColumnStyles.Add(dgtbcZone);

        // Set up the column info for the Value column
        dgtbcSecurityLevel.MappingName = "Security Level";
        dgtbcSecurityLevel.HeaderText = CResourceStore.GetString("CSecurityAdjustmentWiz3:SecurityLevelColumn");
        dgtbcSecurityLevel.Width = ScaleWidth(CResourceStore.GetInt("CSecurityAdjustmentWiz3:SecurityLevelColumnWidth"));
        dgts.GridColumnStyles.Add(dgtbcSecurityLevel);


        this.m_lblSummary.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSummary.Location")));
        this.m_lblSummary.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSummary.Size")));
        this.m_lblSummary.TabIndex = ((int)(resources.GetObject("m_lblSummary.TabIndex")));
        this.m_lblSummary.Text = resources.GetString("m_lblSummary.Text");
        m_lblSummary.Name = "Summary";
        this.m_lblDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDes.Location")));
        this.m_lblDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDes.Size")));
        this.m_lblDes.TabIndex = ((int)(resources.GetObject("m_lblDes.TabIndex")));
        this.m_lblDes.Text = resources.GetString("m_lblDes.Text");
        m_lblDes.Name = "Description";

        this.m_lblUserProblem.Location = ((System.Drawing.Point)(resources.GetObject("m_lblUserProblem.Location")));
        this.m_lblUserProblem.Size = ((System.Drawing.Size)(resources.GetObject("m_lblUserProblem.Size")));
        this.m_lblUserProblem.TabIndex = ((int)(resources.GetObject("m_lblUserProblem.TabIndex")));
        this.m_lblUserProblem.Text = resources.GetString("m_lblUserProblem.Text");
        m_lblUserProblem.Name = "UserProblem";


        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblDes,
                        this.m_dg,
                        this.m_lblSummary,
                        m_lblUserProblem
                        });

        // Additional UI tweaks
        m_dg.ReadOnly=true;
        m_dg.CaptionVisible=false;
        PageControls.Add(m_dg);
        
        CreateTable();
        return 1;
    }// InsertPropSheetPageControls

    void CreateTable()
    {
        // Let's build our data table

        m_dt = new DataTable("Stuff");

        // Create the "Zone" Column
        DataColumn dcZone = new DataColumn();
        dcZone.ColumnName = "Zone";
        dcZone.DataType = typeof(String);
        m_dt.Columns.Add(dcZone);

        // Create the "Security Level" Column
        DataColumn dcSecurityLevel = new DataColumn();
        dcSecurityLevel.ColumnName = "Security Level";
        dcSecurityLevel.DataType = typeof(String);
        m_dt.Columns.Add(dcSecurityLevel);

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);
        m_dg.DataSource = m_dt;

        if (m_nLevels != null)
        {
      
            String[] sZones = new String[]{
                                    CResourceStore.GetString("MyComputer"), 
                                    CResourceStore.GetString("LocalIntranet"),
                                    CResourceStore.GetString("Internet"),
                                    CResourceStore.GetString("Trusted"),
                                    CResourceStore.GetString("Untrusted")
                                          };



            DataRow newRow;
            for(int i=0; i<5; i++)
            {
                newRow = m_dt.NewRow();
                newRow["Zone"]=sZones[i];
                newRow["Security Level"]=TurnSecurityLevelNumberIntoString(m_nLevels[i]);
                m_dt.Rows.Add(newRow);
            }

        }

    }// CreateTable

    private String TurnSecurityLevelNumberIntoString(int nNumber)
    {
        switch(nNumber)
        {
            case PermissionSetType.NONE:
                        return CResourceStore.GetString("CSecurityAdjustmentWiz3:NoTrustName");
            case PermissionSetType.INTERNET:
                        return CResourceStore.GetString("CSecurityAdjustmentWiz3:InternetName");
            case PermissionSetType.INTRANET:
                        return CResourceStore.GetString("CSecurityAdjustmentWiz3:LocalIntranetName");
            case PermissionSetType.FULLTRUST:
                        return CResourceStore.GetString("CSecurityAdjustmentWiz3:FullTrustName");
            case PermissionSetType.UNKNOWN:
                        return CResourceStore.GetString("Custom");
            default:
                        return CResourceStore.GetString("<unknown>");
        }
    }// TurnSecurityLevelNumberIntoString

}// class CSecurityAdjustmentWiz3
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecurityproppage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
internal class CSecurityPropPage : CPropPage
{
    protected bool ReadOnly
    {
        get
        {
            // Check out our parent and see if he's null
            CSecurityNode node = CNodeManager.GetNode(m_iCookie) as CSecurityNode;
            if (node != null)
                return node.ReadOnly;
            else
                return false;
        }
    }// ReadOnly

    protected bool CanMakeChanges()
    {
        if (ReadOnly)
        {
            MessageBox(CResourceStore.GetString("CSecurityPropPage:ReadOnlyPolLevel"),
                       CResourceStore.GetString("CSecurityPropPage:ReadOnlyPolLevelTitle"),
                       MB.ICONEXCLAMATION);
            return false;                       
        }
        return true;
    }// CanMakeChanges



    internal void SecurityPolicyChanged()
    {
        // Tell our parent node something changed
        CSecurityNode node = CNodeManager.GetNode(m_iCookie) as CSecurityNode;

        if (node != null)
            node.SecurityPolicyChanged();
    }// SecurityPolicyChanged

}// class CSecurityPropPage

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecuritynode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;

internal class CSecurityNode : CNode
{
    protected CodeGroup     m_cg;
    protected PolicyLevel   m_pl;
    protected bool          m_fReadOnly;

    internal bool ReadOnly
    {
        get{return m_fReadOnly;}
        set{m_fReadOnly=value;}

    }// ReadOnly
    
    internal PolicyLevel MyPolicyLevel
    {
        get
        {
            return m_pl;
        }
    }// PolicyLevel

    internal CodeGroup MyCodeGroup
    {
        get
        {
            return m_cg;
        }            
    
    }// CodeGroup

    internal void SecurityPolicyChanged()
    {
        SecurityPolicyChanged(true);
    }// SecurityPolicyChanged

    internal virtual void SecurityPolicyChanged(bool fShowDialog)
    {
        // Let's tell the policy level node that security policy changed...
        CNode node = CNodeManager.GetNodeByHScope(ParentHScopeItem);

        // If this is a Security Policy node, just send it up one
        if (this is CSecurityPolicy)
            ((CSecurityNode)node).SecurityPolicyChanged(fShowDialog);

        while(!(node is CRootNode) && !(node is CSecurityPolicy))
            node = CNodeManager.GetNodeByHScope(node.ParentHScopeItem);
            
        if (node is CSecurityPolicy)
            ((CSecurityPolicy)node).SecurityPolicyChanged(fShowDialog);

    }// PolicyChanged
}// CSecurityNode
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecuritypolicy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{

using System;
using System.Security;
using System.Collections;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.IO;
using System.Reflection;

internal class CSecurityPolicy : CSecurityNode
{

    String          m_sPolicyName;
    String          m_sOriginalConfigFile;

    bool            m_fRedo;
    bool            m_fUndo;

    internal CSecurityPolicy(String sPolName, PolicyLevel pl)
    {
        m_sGuid = "FCB061F5-A43B-43b3-91B6-36249F29E60B";
        m_sHelpSection = "";

        m_aPropSheetPage = null;

        m_sPolicyName = sPolName;

        m_sDisplayName = LocalizedPolicyName;

        if (pl == null)
            pl = Security.GetMachinePolicyLevelFromLabel(sPolName);

        m_pl = pl;
        DiscoverModifyofPolicy();

        // Put in the icon
        if (m_sPolicyName.Equals("Enterprise"))
            m_hIcon = CResourceStore.GetHIcon("enterprisepolicy_ico"); 
        else if (m_sPolicyName.Equals("Machine"))
            m_hIcon = CResourceStore.GetHIcon("machinepolicy_ico"); 
        else if (m_sPolicyName.Equals("User"))
            m_hIcon = CResourceStore.GetHIcon("userpolicy_ico"); 



        if (ReadOnly)
            m_sDisplayName = String.Format(CResourceStore.GetString("CSecurityPolicy:ReadOnlyPolicy"), LocalizedPolicyName);

        m_oResults= new CSecurityPolicyTaskPad(this, m_sDisplayName, m_pl.StoreLocation, m_pl.StoreLocation, m_fReadOnly);

        m_sOriginalConfigFile = m_pl.StoreLocation;
        m_fRedo = false;
        m_fUndo = false;
    }// CSecurityPolicy

    internal String LocalizedPolicyName
    {
        get{return CResourceStore.GetString(m_sPolicyName);}
    }// LocalizedPolicyName

    private void DiscoverModifyofPolicy()
    {
        // We don't want this to mess up the 'old' file on this trivial save
        String sSecFilename = m_pl.StoreLocation;

        // Now this sucks, we try to save the policy and see what happens
        try
        {
            SecurityManager.SavePolicyLevel(m_pl);
            ReadOnly = false;
        }
        catch(Exception)
        {
            ReadOnly = true;
        }
   }// DiscoverModifyofPolicy
    
    internal bool isNoSave
    {
        get{return m_fReadOnly;}
    }// isNoSave


    internal void SetNewSecurityPolicyLevel(PolicyLevel pl)
    {
        m_pl = pl;

        m_sDisplayName = LocalizedPolicyName;

        DiscoverModifyofPolicy();

        if (ReadOnly)
            m_sDisplayName = String.Format(CResourceStore.GetString("CSecurityPolicy:ReadOnlyPolicy"), LocalizedPolicyName);

        m_oResults= new CSecurityPolicyTaskPad(this, m_sDisplayName, m_pl.StoreLocation, m_sOriginalConfigFile, m_fReadOnly);
        RedoChildren();
        
        RefreshDisplayName();
        RefreshResultView();

        // Check to see if this affects us at all
        base.SecurityPolicyChanged(false);
        m_fUndo = false;
    }// SetNewSecurityPolicyLevel

    internal String ComputerPolicyFilename
    {
        get{return m_sOriginalConfigFile;}
    }
    
    internal override void SecurityPolicyChanged(bool fShowDialog)
    {
        // We should save
        SavePolicy(fShowDialog);
       
        base.SecurityPolicyChanged(!isNoSave&&fShowDialog);
        m_fRedo = false;
    }// SecurityPolicyChanged

    internal void SavePolicy(bool fUI)
    {
        if (isNoSave)
        {
            if (fUI)
                MessageBox(String.Format(CResourceStore.GetString("CSecurityPolicy:CannotSave"), m_sPolicyName),
                           CResourceStore.GetString("CSecurityPolicy:CannotSaveTitle"),
                           MB.ICONEXCLAMATION);
            return;
        }

        // Refresh our root codegroup
        try
        {
            SecurityManager.SavePolicyLevel(m_pl);
            m_fUndo = true;
        }
        catch(Exception)
        {
            // Ok, we got an error somehow. This should be pretty rare, and could happen
            // if another process has the policy file locked. Inform the user and see
            // what they want to do.
            bool fSaved = false;
            bool fRetry = true;

            while(!fSaved && fRetry)
            {
                int nRet = MessageBox(String.Format(CResourceStore.GetString("CSecurityPolicy:SaveFailedRetry"), 
                                                    m_pl.StoreLocation),
                                      CResourceStore.GetString("CSecurityPolicy:SaveFailedRetryTitle"),
                                      MB.RETRYCANCEL|MB.ICONEXCLAMATION);
                if (nRet == MB.IDRETRY)
                {
                    try
                    {
                        SecurityManager.SavePolicyLevel(m_pl);
                        m_fUndo = true;
                        fSaved = true;
                     }
                    catch(Exception)
                    {}
                }
                else
                    fRetry = false;
            }

            if (!fSaved)
                MessageBox(String.Format(CResourceStore.GetString("CSecurityPolicy:SaveFailed"),
                                         LocalizedPolicyName,
                                         m_pl.StoreLocation),
                           CResourceStore.GetString("CSecurityPolicy:SaveFailedTitle"),
                           MB.ICONEXCLAMATION);
        }
    }// SavePolicy

     
    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {  
        CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
    
         // See if we're allowed to insert an item in the "view" section
        if (!ReadOnly && (pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;
            newitem.strName = CResourceStore.GetString("CSecurityPolicy:ResetOption");
            newitem.strStatusBarText = CResourceStore.GetString("CSecurityPolicy:ResetOptionDes");
            newitem.lCommandID = COMMANDS.RESET_POLICY;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            if (!isNoSave)
            {
                // See if we can have a recover policy option
                if (m_fUndo && File.Exists(m_pl.StoreLocation + ".old"))
                {
                    // Add the save... item to the menu
                    if (m_fRedo)
                    {
                        newitem.strName = CResourceStore.GetString("CSecurityPolicy:RedoOption");
                        newitem.strStatusBarText = CResourceStore.GetString("CSecurityPolicy:RedoOptionDes");
                    }
                    else
                    {
                        newitem.strName = CResourceStore.GetString("CSecurityPolicy:UndoOption");
                        newitem.strStatusBarText = CResourceStore.GetString("CSecurityPolicy:UndoOptionDes");
                    }
                    newitem.lCommandID = COMMANDS.UNDO_SECURITYPOLICY;
                    // Now add this item through the callback
                    piCallback.AddItem(ref newitem);
                }
            }
        }
    }// AddMenuItems

    internal override void MenuCommand(int iCommandID)
    {

        if (iCommandID == COMMANDS.UNDO_SECURITYPOLICY)
        {
            // Do the undo
            String sLocation = m_pl.StoreLocation;
            m_pl.Recover();
            PolicyLevel pl;
            try
            {
                // If this is a policy level that affects the current machine, go retrieve
                // it again from the security manager
                if (m_sOriginalConfigFile.Equals(m_pl.StoreLocation))
                    pl = Security.GetMachinePolicyLevelFromLabel(m_sPolicyName);
                else            
                    pl = SecurityManager.LoadPolicyLevelFromFile(sLocation, Security.GetPolicyLevelTypeFromLabel(m_sPolicyName));
            }
            catch
            {
                MessageBox(CResourceStore.GetString("CSecurityPolicy:ErrorOnRestore"),
                           CResourceStore.GetString("CSecurityPolicy:ErrorOnRestoreTitle"),
                           MB.ICONEXCLAMATION);
                return;
            }
            SetNewSecurityPolicyLevel(pl);
            m_fRedo = !m_fRedo;
            m_fUndo = true;
        }
        
        else if (iCommandID == COMMANDS.RESET_POLICY)
        {
            // Let's reset this policy
            int nRes = MessageBox(CResourceStore.GetString("CSecurityPolicy:VerifyReset"),
                                  CResourceStore.GetString("CSecurityPolicy:VerifyResetTitle"),
                                  MB.YESNO|MB.ICONQUESTION);
            if (nRes == MB.IDYES)
            {
                // Sometimes this can take a long time... let's put up the hourglass
                StartWaitCursor();
                ResetSecurityPolicy();    
                EndWaitCursor();
            }
        }
    }// MenuCommand

    internal void ResetSecurityPolicy()
    {
        m_pl.Reset();
        // Clear the tree and then re-add everything
        RedoChildren();
        SecurityPolicyChanged();
    }// ResetSecurityPolicy

    internal CSingleCodeGroup GetRootCodeGroupNode()
    {
        CCodeGroups node = (CCodeGroups)FindChild(CResourceStore.GetString("CCodeGroups:DisplayName"));
        return node.GetRootCodeGroupNode();
    }

    internal CSinglePermissionSet AddPermissionSet(NamedPermissionSet nps)
    {
        return PermissionSetNode.AddPermissionSet(nps);
    }// AddPermissionSet

    private CPermissionSet PermissionSetNode
    {
        get{return (CPermissionSet)CNodeManager.GetNode(Child[1]);}
    }// PermissionSetNode

    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
    {
        CNode   node=null;
        int     iCookie=0;
        
        node = new CCodeGroups(ref m_pl, ReadOnly);
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);

        node = new CPermissionSet(m_pl, ReadOnly);
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);

        node = new CTrustedAssemblies(m_pl, ReadOnly);
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);


    }// CreateChildren
}// class CSecurityPolicy
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecuritypolicytaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

class CSecurityPolicyTaskPad : CTaskPad
{
    private String  m_sRealPolicyFile;
    private String  m_sCurrentPolicyFile;
    private String  m_sPolicyLevel;    
    private bool    m_fReadOnly;

    internal CSecurityPolicyTaskPad(CNode n, String sPolicyLevel, String sCurrentPolFile, String sRealPolFile, bool fReadOnly) : base(n)
    {
        m_sPolicyLevel = sPolicyLevel;    

        m_sRealPolicyFile = sRealPolFile;
        m_sCurrentPolicyFile= sCurrentPolFile;

        m_fReadOnly = fReadOnly;
    }// CSecurityPolicyTaskPad

     protected override String GetHTMLFilename()
    {
        return "SECURITYPOLICY_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[4];
        args[0] = m_sPolicyLevel;
        if (m_sRealPolicyFile.Equals(m_sCurrentPolicyFile))
            args[1] = CResourceStore.GetString("CSecurityPolicyTaskpad:PolicyOnThisMachine");
        else
            args[1] = CResourceStore.GetString("CSecurityPolicyTaskpad:PolicyOnFile");
        
        args[2] = m_sCurrentPolicyFile;

        // The will display a string if we cannot access this file
        if (m_fReadOnly)
            args[3] = CResourceStore.GetString("CSecurityPolicyTaskpad:ReadOnlyPolicy");
        else
            args[3] = "";
       
        return GetHTMLFile(args);    
    }// GetHTMLFile
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

}// class CIntroTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecurityadjustmentwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;
using System.Reflection;
using System.Security.Permissions;
using System.Collections;
using System.Threading;



internal class CSecurityAdjustmentWizard: CSecurityWizard
{
    private ArrayList   m_alNewCodeGroups;
    private PolicyLevel m_pl;
    private bool        m_fWizardFinished;
    private int[]       m_iMaxLevelsMachine;
    private int[]       m_iMaxLevelsUser;
    private int[]       m_iCurrentLevelsUser;
    private int[]       m_iCurrentLevelsMachine;
    private Thread      m_tLevels;
   
    internal CSecurityAdjustmentWizard(bool fMachineReadOnly, bool fUserReadOnly)
    {
        m_sName="Security Adjustment Wizard";
        m_aPropSheetPage = new CPropPage[] {
                                            new CSecurityAdjustmentWiz1(fMachineReadOnly, fUserReadOnly), 
                                            new CSecurityAdjustmentWiz2(),
                                            new CSecurityAdjustmentWiz3()
                                           };

        m_alNewCodeGroups = new ArrayList(); 
        m_tLevels = null;
    }// CSecurityAdjustmentWizard

    private CSecurityAdjustmentWiz2 Page2
    { get{return (CSecurityAdjustmentWiz2)m_aPropSheetPage[1];}}

    private CSecurityAdjustmentWiz3 Page3
    { get{return (CSecurityAdjustmentWiz3)m_aPropSheetPage[2];}}

    private bool IsHomeUser
    {
        get
        {
            return ((CSecurityAdjustmentWiz1)m_aPropSheetPage[0]).isForHomeUser;
        }            
    }// IsHomeUser

    protected override int WizSetActive(IntPtr hwnd)
    {
        m_alNewCodeGroups.Clear();
        m_fWizardFinished = false;
        // Find out which property page this is....
        switch(GetPropPage(hwnd))
        {
            case 0:
                    // Let's get our thread working...
                    if (m_tLevels == null)
                    {
                        m_tLevels = new Thread(new ThreadStart(DiscoverLevels)); 
                        m_tLevels.Start();
                    }
                    TurnOnNext(true);
                    break;
            case 1:
                    // Wait for these helper threads to finish
                    SetThreadPriority(m_tLevels, ThreadPriority.Highest);
                    m_tLevels.Join();

                    // Grab the results of our threads...
                    if (IsHomeUser)
                    {
                        Page2.MaxLevels = m_iMaxLevelsMachine;
                        Page2.SecurityLevels = m_iCurrentLevelsMachine;
                    }
                    else
                    {
                        Page2.MaxLevels = m_iMaxLevelsUser;
                        Page2.SecurityLevels = m_iCurrentLevelsUser;
                    }

                    // We need to put the values back in the page, since we
                    // just changed all the security levels.
                    Page2.PutValuesinPage();
                    TurnOnNext(true);
                    break;
            case 2:
                    // See if machine level settings are going to be negated because
                    // user policy is more strict
                    bool fUserProblems = false;

                    if (IsHomeUser)
                    {
                        // Check what the max levels are in user policy
                        int[] levels = GetLevels(new PolicyLevel[] 
                                                    {
                                                    Security.GenSecurityNode.UserNode.MyPolicyLevel,
                                                    });
                        // Now see if the machine levels are set higher than these levels
                        for(int i=0; i<levels.Length; i++)
                            if(levels[i] < Page2.SecurityLevels[i])
                                fUserProblems = true;

                    }
                    Page3.UserProblems = fUserProblems;
                    
                    Page3.Init(Page2.SecurityLevels);  
                    TurnOnFinish(true);
                    break;
        }
        return base.WizSetActive(hwnd);
    }// WizSetActive

    private void DiscoverLevels()
    {
        m_iCurrentLevelsUser = GetCurrentLevelsUser();
        m_iCurrentLevelsMachine = GetCurrentLevelsMachine();
        m_iMaxLevelsMachine = GetMaxLevels(true);
        m_iMaxLevelsUser = GetMaxLevels(false);
        
    }// DiscoverMaxLevels

    private void SetThreadPriority(Thread t, ThreadPriority tp)
    {
        try
        {
            t.Priority = tp;
        }
        // This exception will get thrown if the thread is already dead
        catch(ThreadStateException)
        {}
    }// SetThreadPriority

    internal bool didUserPolicyChange
    {
        get
        {
            return !IsHomeUser && m_fWizardFinished;
        }

    }// didUserPolicyChange

    internal bool didMachinePolicyChange
    {
        get
        {
            return IsHomeUser && m_fWizardFinished;
        }

    }// didMachinePolicyChange

    protected override int WizFinish()
    {
        // This is the main things that the wizard needs to do.
        // If mucking with the machine level
        //
        // 1. Apply appropriate settings to the security zone codegroups.
        //
        // If mucking with the user level
        //
        // 1. Change the user policylevel's root codegroup's permission set to Nothing
        // 2. Apply appropriate settings to the security zone codegroups
        // 3. Copy the entire machine policy into a child codegroup in the user policy
        // 4. Skip the top level of the copied policy looking for zone codegroups. Set
        //    their permission set to nothing, and remove child file and net codegroups.
        // 5. Walk through the entire copied policy and remove any exclusive codegroups

        
        // We have some different behavior depending on what type of policy we're after
        String sPolicyLevel = IsHomeUser?"Machine":"User";
        
        PolicyLevel pl = Security.GetPolicyLevelFromLabel(sPolicyLevel);
        
        SecurityZone[] sz = new SecurityZone[] { 
                                                SecurityZone.MyComputer,
                                                SecurityZone.Intranet,
                                                SecurityZone.Internet,
                                                SecurityZone.Trusted,
                                                SecurityZone.Untrusted
                                               };
        m_alNewCodeGroups.Clear();

        for(int i=0; i<5; i++)
        {
            // Only do this if we know how to assign a permission set
            if (Page2.SecurityLevels[i] != PermissionSetType.UNKNOWN)
            {
                // Find the Codegroup with the appropriate Membership Condition
                CodeGroup cgParent = null;
                CodeGroup cg = GetCGWithMembershipCondition(pl.RootCodeGroup, sz[i], out cgParent);

                // Remove this codegroup from the heirarchy
                if (cg != null)
                {
                    if (cgParent == null)
                        throw new Exception("I should have a parent");
                    cgParent.RemoveChild(cg);
                }
            
                // We have to create this Codegroup
                if (cg == null)
                {
                    ZoneMembershipCondition zmc = new ZoneMembershipCondition(sz[i]);
                    cg = new UnionCodeGroup(zmc, new PolicyStatement(new PermissionSet(PermissionState.None)));                    
                    // Add a name and description
                    cg.Name = GetCodegroupName(sz[i]);
    
                    m_alNewCodeGroups.Add(cg);
                    m_pl = pl;
                    cgParent = pl.RootCodeGroup;
                }
                // If was an internet or intranet codegroup, we'll need to remove child codegroups of type
                // NetCodeGroup or FileCodeGroup
                if (cg.PermissionSetName != null && (cg.PermissionSetName.Equals("Internet") || cg.PermissionSetName.Equals("LocalIntranet")))
                {
                    IEnumerator enumCodeGroups = cg.Children.GetEnumerator();
                    while (enumCodeGroups.MoveNext())
                    {
                        CodeGroup group = (CodeGroup)enumCodeGroups.Current;
                        if (group is NetCodeGroup || group is FileCodeGroup)
                            cg.RemoveChild(group);
                    }
                }      
               
                // Now give this codegroup the appropriate permission set
                PolicyStatement ps = cg.PolicyStatement;
                ps.PermissionSet = GetPermissionSetNameFromSecurityLevel(pl, Page2.SecurityLevels[i]);

                // Put in the helper codegroups if necessary
                if (Page2.SecurityLevels[i] == PermissionSetType.INTRANET)
                {
                    if (!DoesCGHaveCodegroup(cg, typeof(NetCodeGroup)))
                    {
                        CodeGroup cgChild = new NetCodeGroup(new AllMembershipCondition());
                        cgChild.Name = Security.FindAGoodCodeGroupName(pl, "NetCodeGroup_");
                        cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                        cg.AddChild(cgChild);
                    }
                    if (!DoesCGHaveCodegroup(cg, typeof(FileCodeGroup)))
                    {
                        CodeGroup cgChild = new FileCodeGroup(new AllMembershipCondition(), FileIOPermissionAccess.Read|FileIOPermissionAccess.PathDiscovery);
                        cgChild.Name = Security.FindAGoodCodeGroupName(pl, "FileCodeGroup_");
                        cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                        cg.AddChild(cgChild);
                    }
                }
                else if (Page2.SecurityLevels[i] == PermissionSetType.INTERNET)
                {
                    if (!DoesCGHaveCodegroup(cg, typeof(NetCodeGroup)))
                    {
                        CodeGroup cgChild = new NetCodeGroup(new AllMembershipCondition());
                        cgChild.Name = Security.FindAGoodCodeGroupName(pl, "NetCodeGroup_");
                        cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                        cg.AddChild(cgChild);
                    }
                }
               
                cg.PolicyStatement = ps;
                // Now let's build the code group description
                String sPermissionSetDes = "";
                if (ps.PermissionSet is NamedPermissionSet)
                    sPermissionSetDes += ((NamedPermissionSet)ps.PermissionSet).Description;


                cg.Description = String.Format(CResourceStore.GetString("CSecurityAdjustmentWizard:CodeGroupDescription"),
                                            cg.PermissionSetName,
                                            GetCodegroupName(sz[i]),
                                            sPermissionSetDes);
                // Now add this child back in
                cgParent.AddChild(cg);
            }
        }

        // Check to see if this is for the user. 
        if (!IsHomeUser)
        {
            // Let's start on our list....
            PolicyLevel plUser = Security.GetPolicyLevelFromLabel("User");
            // Change the root codegroup's permission set to nothing
            CodeGroup cgRoot = plUser.RootCodeGroup;
            PolicyStatement ps = cgRoot.PolicyStatement;
            ps.PermissionSet = plUser.GetNamedPermissionSet("Nothing");
            cgRoot.PolicyStatement = ps;

            // Now copy the entire machine level's policy into a child codegroup
            // of the user policy
            PolicyLevel plMachine = Security.GetPolicyLevelFromLabel("Machine");
            CodeGroup cgMachine = plMachine.RootCodeGroup.Copy();
            // Change the codegroup's name to something more interesting...
            cgMachine.Name = "Wizard_Machine_Policy";
            cgMachine.Description = CResourceStore.GetString("CSecurityAdjustmentWizard:CopiedMachinePolicyDes");
            // Now skim through the top level looking for Zone codegroups, set
            // their permission sets to nothing, and delete any child net and file
            // codegroups
            IEnumerator enumCodeGroups = cgMachine.Children.GetEnumerator();
            while (enumCodeGroups.MoveNext())
            {
                CodeGroup zoneGroup = (CodeGroup)enumCodeGroups.Current;

                if (zoneGroup.MembershipCondition is ZoneMembershipCondition)
                {
                    // Ok, we need to change this codegroup
                    cgMachine.RemoveChild(zoneGroup);
                    PolicyStatement zoneps = zoneGroup.PolicyStatement;
                    zoneps.PermissionSet = plUser.GetNamedPermissionSet("Nothing");
                    zoneGroup.PolicyStatement = zoneps;
                    // Now run through its children looking for a file or net codegroup
                    IEnumerator enumChildCodeGroups = zoneGroup.Children.GetEnumerator();
                    while (enumChildCodeGroups.MoveNext())
                    {
                        CodeGroup zoneChildGroup = (CodeGroup)enumChildCodeGroups.Current;
                        if (zoneChildGroup is NetCodeGroup || zoneChildGroup is FileCodeGroup)
                            zoneGroup.RemoveChild(zoneChildGroup);
                    }
                    cgMachine.AddChild(zoneGroup);
                }
            }      

            // Now run through the tree and remove any exclusive code groups
            // We're best to do this recursively....
            if ((cgMachine.PolicyStatement.Attributes & PolicyStatementAttribute.Exclusive)==PolicyStatementAttribute.Exclusive)
            {
                // Remove the exclusive bit
                PolicyStatement psMachine = cgMachine.PolicyStatement;
                psMachine.Attributes = psMachine.Attributes & ~PolicyStatementAttribute.Exclusive;
                cgMachine.PolicyStatement = psMachine;
            }
            Security.RemoveExclusiveCodeGroups(cgMachine);


            // Now run through the user policy looking for codegroups named 
            // "Wizard_Machine_Policy" and delete those as well.
            enumCodeGroups = cgRoot.Children.GetEnumerator();
            while (enumCodeGroups.MoveNext())
            {
                CodeGroup group = (CodeGroup)enumCodeGroups.Current;
                if (group.Name.Equals("Wizard_Machine_Policy"))
                    cgRoot.RemoveChild(group);
            }

            // Add finally this to the root codegroup of the user policy

            Security.PrepCodeGroupTree(cgMachine, plMachine, plUser);
            cgRoot.AddChild(cgMachine);
            plUser.RootCodeGroup = cgRoot;

        }

        m_fWizardFinished = true;
      
        return 0;
    }// WizFinish

    private bool DoesCGHaveCodegroup(CodeGroup cg, Type t)
    {
        // Run through this codegroups children looking for a net codegroup
        if (cg != null && cg.Children != null)
        {
            IEnumerator enumCodeGroups = cg.Children.GetEnumerator();

            while (enumCodeGroups.MoveNext())
            {
                CodeGroup group = (CodeGroup)enumCodeGroups.Current;
                if (t.IsInstanceOfType(group))
                    return true;
            }
        }
        return false;
    }// DoesCGHaveNetCodegroup

    private CodeGroup GetCGWithMembershipCondition(CodeGroup cg, SecurityZone sz, out CodeGroup cgParent)
    {
        // Run through this code group's children and look for a codegroup with a
        // ZoneMembership Condition with the specified security zone
        IEnumerator enumCodeGroups = cg.Children.GetEnumerator();

        while (enumCodeGroups.MoveNext())
        {
            CodeGroup group = (CodeGroup)enumCodeGroups.Current;

            if (group.MembershipCondition is ZoneMembershipCondition)
                if (((ZoneMembershipCondition)group.MembershipCondition).SecurityZone == sz)
                {
                    cgParent = cg;
                    return group;
                }
        }

        // If we're here, then we couldn't find it.
        cgParent = null;
        return null;
    }// GetCGWithMembershipCondition

    private int[] GetMaxLevels(bool fForMachine)
    {

        // If it's for the machine, the max levels are defined in the Enterprise policy
        if (fForMachine)
        {
            return GetLevels(new PolicyLevel[] {Security.GenSecurityNode.EnterpriseNode.MyPolicyLevel});
        }

       
        // Else, if this is a corporate user, the max level is found in the combination of the 
        // enterprise or machine policy
        
        return GetLevels(new PolicyLevel[] {Security.GenSecurityNode.EnterpriseNode.MyPolicyLevel,
                                            Security.GenSecurityNode.MachineNode.MyPolicyLevel});
    }// GetMaxLevels

    private int[] GetCurrentLevelsUser()
    {
        
        return GetLevels(new PolicyLevel[] {Security.GenSecurityNode.EnterpriseNode.MyPolicyLevel,
                                            Security.GenSecurityNode.MachineNode.MyPolicyLevel,
                                            Security.GenSecurityNode.UserNode.MyPolicyLevel});
    }// GetCurrentLevelsUser

    private int[] GetCurrentLevelsMachine()
    {
        
        return GetLevels(new PolicyLevel[] {Security.GenSecurityNode.EnterpriseNode.MyPolicyLevel,
                                            Security.GenSecurityNode.MachineNode.MyPolicyLevel
                                            });
    }// GetCurrentLevelsMachine


    private int[] GetLevels(PolicyLevel[] polLevels)
    {
        
        Zone[] zones = new Zone[] { 
                                    new Zone(SecurityZone.MyComputer),
                                    new Zone(SecurityZone.Intranet),
                                    new Zone(SecurityZone.Internet),
                                    new Zone(SecurityZone.Trusted),
                                    new Zone(SecurityZone.Untrusted)
                                               };
        int[] nLevels = new int[5];


        // Try and find some good url evidence (a url that doesn't trigger any codegroups
        // with url membership conditions).
        // We need the url evidence in order to trigger the File and Net Custom codegroups
        // that typically reside off of the Internet and LocalIntranet codegroups
        Url localUrlEvidence = null;
        int nCount=0;
        Evidence eTmp;
        // Note, it doesn't matter if c: actually exists or if it is on the local machine or not.
        // We just need the piece of evidence.... If c: is actually a mapped drive, there is no
        // harm because we control the evidence that tells the security manager where the drive
        // is located.
        do
        {
            nCount++;
            String sURL = "file://c:\\";
            for(int i=0; i< nCount; i++)
                sURL += "z";
            sURL += "\\app.exe";
            localUrlEvidence = new Url(sURL);
            eTmp = new Evidence();
            eTmp.AddHost(localUrlEvidence);
        }while (Security.DoesHitURLCodegroup(eTmp, polLevels));

        // We'll do the same for URL evidence
        Url RemoteUrlEvidence = null;
        nCount = 0;
        // Note, it doesn't matter if http://z (or http://zzzzzz, or whatever) is the actual name
        // of the machine... we just need the evidence. There is no harm because we control 
        // the evidence that tells the security manager where the http address is located.
        
        do
        {
            nCount++;
            String sURL = "http://";
            for(int i=0; i< nCount; i++)
                sURL += "z";
                
            RemoteUrlEvidence = new Url(sURL);
            eTmp = new Evidence();
            eTmp.AddHost(RemoteUrlEvidence);
        }while (Security.DoesHitURLCodegroup(eTmp, polLevels));

        // Now run through each zone and get the current settings for that zone
        
        for(int i=0; i<5; i++)
        {
            // Build some evidence for the evaluation
            Evidence e = new Evidence();
            // Add the zone evidence
            e.AddHost(zones[i]);
            
            // Add the some file url evidence
            e.AddHost(localUrlEvidence);

            int nLocalEvidenceLevel = Security.FindCurrentPermissionSet(e, polLevels);

            // Now try this with http evidence
            e = new Evidence();
            // Add the zone evidence
            e.AddHost(zones[i]);
            e.AddHost(RemoteUrlEvidence);

            int nRemoteEvidenceLevel = Security.FindCurrentPermissionSet(e, polLevels);

            // if they're the same... it's all good.
            if (nRemoteEvidenceLevel == nLocalEvidenceLevel)
                nLevels[i] = nRemoteEvidenceLevel;
            // Else, something funky is going on here... give it an unknown
            else
                nLevels[i] = PermissionSetType.UNKNOWN;

        }
        return nLevels;
    }// GetCurrentLevels

    private String GetCodegroupName(SecurityZone sz)
    {
        switch(sz)
        {
            case SecurityZone.MyComputer:
                return CResourceStore.GetString("CSecurityAdjustmentWizard:My_Computer_Zone");
            case SecurityZone.Intranet:
                return CResourceStore.GetString("CSecurityAdjustmentWizard:LocalIntranet_Zone");
            case SecurityZone.Internet:
                return CResourceStore.GetString("CSecurityAdjustmentWizard:Internet_Zone");
            case SecurityZone.Trusted:
                return CResourceStore.GetString("CSecurityAdjustmentWizard:Trusted_Zone");
            case SecurityZone.Untrusted:
                return CResourceStore.GetString("CSecurityAdjustmentWizard:Restricted_Zone");
            default:
                return CResourceStore.GetString("<unknown>");
        }


    }// GetCodegroupName

    private PermissionSet GetPermissionSetNameFromSecurityLevel(PolicyLevel pl, int nLevel)
    {
        String sNameOfPermissionSet = null;
    
        switch(nLevel)
        {
            case PermissionSetType.NONE:
                        sNameOfPermissionSet = "Nothing";
                        break;
            case PermissionSetType.INTERNET:
                        sNameOfPermissionSet = "Internet";
                        break;
            case PermissionSetType.INTRANET:
                        sNameOfPermissionSet = "LocalIntranet";
                        break;
            case PermissionSetType.FULLTRUST:
                        sNameOfPermissionSet = "FullTrust";
                        break;
            default:
                        throw new Exception("Help! I don't know about this security level");
        }

        return pl.GetNamedPermissionSet(sNameOfPermissionSet);
    }// GetPermissionSetNameFromSecurityLevel
    

}// class CFullTrustWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglecodegroupprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Security.Policy;

internal class CSingleCodeGroupProp : CSecurityPropPage
{
    // Controls on the page
    private CheckBox m_chkOnlyUseThisPL;
    private TextBox m_txtCGName;
    private Label m_lblCGDes;
    private TextBox m_txtCGDes;
    private CheckBox m_chkUseOnlyThisCG;
    private Label m_lblCGName;
    private GroupBox m_gbSpecialConds;

    // internal data
    CodeGroup       m_cg;
    PolicyLevel     m_pl;

    internal CSingleCodeGroupProp(PolicyLevel pl, CodeGroup cg)
    {
        m_sTitle = CResourceStore.GetString("CSingleCodeGroupProp:PageTitle"); 
        m_pl = pl;
        m_cg = cg;
    }// CSingleCodeGroupProp 

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSingleCodeGroupProp));
        this.m_chkOnlyUseThisPL = new System.Windows.Forms.CheckBox();
        this.m_txtCGName = new System.Windows.Forms.TextBox();
        this.m_lblCGDes = new System.Windows.Forms.Label();
        this.m_txtCGDes = new System.Windows.Forms.TextBox();
        this.m_chkUseOnlyThisCG = new System.Windows.Forms.CheckBox();
        this.m_lblCGName = new System.Windows.Forms.Label();
        this.m_gbSpecialConds = new System.Windows.Forms.GroupBox();
        this.m_chkOnlyUseThisPL.Location = ((System.Drawing.Point)(resources.GetObject("m_chkOnlyUseThisPL.Location")));
        this.m_chkOnlyUseThisPL.Size = ((System.Drawing.Size)(resources.GetObject("m_chkOnlyUseThisPL.Size")));
        this.m_chkOnlyUseThisPL.TabIndex = ((int)(resources.GetObject("m_chkOnlyUseThisPL.TabIndex")));
        this.m_chkOnlyUseThisPL.Text = resources.GetString("m_chkOnlyUseThisPL.Text");
        m_chkOnlyUseThisPL.Name = "LevelFinal";
        this.m_txtCGName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtCGName.Location")));
        this.m_txtCGName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtCGName.Size")));
        this.m_txtCGName.TabIndex = ((int)(resources.GetObject("m_txtCGName.TabIndex")));
        m_txtCGName.Name = "Name";
        this.m_lblCGDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCGDes.Location")));
        this.m_lblCGDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCGDes.Size")));
        this.m_lblCGDes.TabIndex = ((int)(resources.GetObject("m_lblCGDes.TabIndex")));
        this.m_lblCGDes.Text = resources.GetString("m_lblCGDes.Text");
        m_lblCGDes.Name = "DescriptionLabel";
        this.m_txtCGDes.Location = ((System.Drawing.Point)(resources.GetObject("m_txtCGDes.Location")));
        this.m_txtCGDes.Multiline = true;
        this.m_txtCGDes.Size = ((System.Drawing.Size)(resources.GetObject("m_txtCGDes.Size")));
        this.m_txtCGDes.TabIndex = ((int)(resources.GetObject("m_txtCGDes.TabIndex")));
        m_txtCGDes.Name = "Description";
        this.m_chkUseOnlyThisCG.Location = ((System.Drawing.Point)(resources.GetObject("m_chkUseOnlyThisCG.Location")));
        this.m_chkUseOnlyThisCG.Size = ((System.Drawing.Size)(resources.GetObject("m_chkUseOnlyThisCG.Size")));
        this.m_chkUseOnlyThisCG.TabIndex = ((int)(resources.GetObject("m_chkUseOnlyThisCG.TabIndex")));
        this.m_chkUseOnlyThisCG.Text = resources.GetString("m_chkUseOnlyThisCG.Text");
        m_chkUseOnlyThisCG.Name = "Exclusive";
        this.m_lblCGName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCGName.Location")));
        this.m_lblCGName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCGName.Size")));
        this.m_lblCGName.TabIndex = ((int)(resources.GetObject("m_lblCGName.TabIndex")));
        this.m_lblCGName.Text = resources.GetString("m_lblCGName.Text");
        m_lblCGName.Name = "NameLabel";
        this.m_gbSpecialConds.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_chkOnlyUseThisPL,
                        this.m_chkUseOnlyThisCG});
        this.m_gbSpecialConds.Location = ((System.Drawing.Point)(resources.GetObject("m_gbSpecialConds.Location")));
        this.m_gbSpecialConds.Size = ((System.Drawing.Size)(resources.GetObject("m_gbSpecialConds.Size")));
        this.m_gbSpecialConds.TabIndex = ((int)(resources.GetObject("m_gbSpecialConds.TabIndex")));
        this.m_gbSpecialConds.TabStop = false;
        this.m_gbSpecialConds.Text = resources.GetString("m_gbSpecialConds.Text");
        m_gbSpecialConds.Name = "SpecialConditionsBox";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_gbSpecialConds,
                        this.m_lblCGName,
                        this.m_txtCGName,
                        this.m_lblCGDes,
                        this.m_txtCGDes
                        });
        // Fill in the data
        PutValuesinPage();
		m_txtCGName.TextChanged += new EventHandler(onChange);
        m_txtCGDes.TextChanged += new EventHandler(onChange);
        m_chkOnlyUseThisPL.CheckStateChanged += new EventHandler(onChange);
        m_chkUseOnlyThisCG.CheckStateChanged += new EventHandler(onChange);

		return 1;
    }// InsertPropSheetPageControls

    private void PutValuesinPage()
    {
        // Get info that we'll need from the node
        m_txtCGName.Text = m_cg.Name;
        m_txtCGDes.Text = m_cg.Description;

		if (m_cg.PolicyStatement != null)
		{
	        PolicyStatementAttribute psa = m_cg.PolicyStatement.Attributes;
    	    if ((psa & PolicyStatementAttribute.Exclusive) > 0)
        	    m_chkUseOnlyThisCG.Checked=true;
        	if ((psa & PolicyStatementAttribute.LevelFinal) > 0)
            	m_chkOnlyUseThisPL.Checked=true;
		}
    }// PutValuesinPage

    internal override bool ValidateData()
    {
        // See if they can make these changes
        if (!CanMakeChanges())
            return false;

        // Make sure the name is unique
        if (m_cg.Name != null && !m_cg.Name.Equals(m_txtCGName.Text) && Security.isCodeGroupNameUsed(m_pl.RootCodeGroup, m_txtCGName.Text))
        {
            MessageBox(String.Format(CResourceStore.GetString("Codegroupnameisbeingused"),m_txtCGName.Text),
                       CResourceStore.GetString("CodegroupnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);

            return false;
        }
        // Everything is ok then...
        return true;
    }// ValidateData


    internal override bool ApplyData()
    {
        PolicyStatementAttribute psa = new PolicyStatementAttribute();
        if (m_chkUseOnlyThisCG.Checked)
            psa |= PolicyStatementAttribute.Exclusive;
        if (m_chkOnlyUseThisPL.Checked)
            psa |= PolicyStatementAttribute.LevelFinal;
 
        PolicyStatement ps = m_cg.PolicyStatement;
        if (ps == null)
        	ps = new PolicyStatement(null);
        ps.Attributes = psa;
        m_cg.PolicyStatement = ps;
        m_cg.Name = m_txtCGName.Text;
        m_cg.Description = m_txtCGDes.Text;

        SecurityPolicyChanged();
   
        return true;
    }// ApplyData

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CSingleCodeGroupProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglecodegrouppsetprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Security.Policy;
using System.Security.Permissions;
using System.Net;

internal class CSingleCodeGroupPSetProp : CSecurityPropPage
{
    const int   UNRESTRICTEDIMAGEINDEX  = 0;
    const int   PARTIALIMAGEINDEX       = 1;
    

    Button m_btnViewPerm;
    ComboBox m_cbPermissionSet;
    Label m_lblPermissionSet;
    Label m_lblHelp;
    Label m_lblHasThesePermissions;
    ListView m_lvPermissions;
    ImageList   m_ilIcons;
    // Internal data
    NamedPermissionSet  m_npsCurPermSet;
    NamedPermissionSet  m_npsCreatedPermSet;
    PermissionSet       m_psOriginalPermSet;
    
    CodeGroup           m_cg;
    PolicyLevel         m_pl;
    


    internal CSingleCodeGroupPSetProp(ref PolicyLevel pl, ref CodeGroup cg)
    {
        m_sTitle = CResourceStore.GetString("Csinglecodegrouppsetprop:PageTitle"); 
        m_pl = pl;
        m_cg = cg;
    }// CSingleCodeGroupPSetProp
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSingleCodeGroupPSetProp));
        this.m_btnViewPerm = new System.Windows.Forms.Button();
        this.m_cbPermissionSet = new System.Windows.Forms.ComboBox();
        this.m_lblPermissionSet = new System.Windows.Forms.Label();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblHasThesePermissions = new System.Windows.Forms.Label();
        this.m_lvPermissions = new System.Windows.Forms.ListView();
        this.m_btnViewPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_btnViewPerm.Location")));
        this.m_btnViewPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_btnViewPerm.Size")));
        this.m_btnViewPerm.TabIndex = ((int)(resources.GetObject("m_btnViewPerm.TabIndex")));
        this.m_btnViewPerm.Text = resources.GetString("m_btnViewPerm.Text");
        m_btnViewPerm.Name = "ViewPermission";
        this.m_cbPermissionSet.DropDownWidth = 336;
        this.m_cbPermissionSet.Location = ((System.Drawing.Point)(resources.GetObject("m_cgPermissionSet.Location")));
        this.m_cbPermissionSet.Size = ((System.Drawing.Size)(resources.GetObject("m_cgPermissionSet.Size")));
        this.m_cbPermissionSet.TabIndex = ((int)(resources.GetObject("m_cgPermissionSet.TabIndex")));
        this.m_cbPermissionSet.Text = resources.GetString("m_cgPermissionSet.Text");
        m_cbPermissionSet.Name = "PermissionSet";
        this.m_lblPermissionSet.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPermissionSet.Location")));
        this.m_lblPermissionSet.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPermissionSet.Size")));
        this.m_lblPermissionSet.TabIndex = ((int)(resources.GetObject("m_lblPermissionSet.TabIndex")));
        this.m_lblPermissionSet.Text = resources.GetString("m_lblPermissionSet.Text");
        m_lblPermissionSet.Name = "PermissionSetLabel";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblHasThesePermissions.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHasThesePermissions.Location")));
        this.m_lblHasThesePermissions.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHasThesePermissions.Size")));
        this.m_lblHasThesePermissions.TabIndex = ((int)(resources.GetObject("m_lblHasThesePermissions.TabIndex")));
        this.m_lblHasThesePermissions.Text = resources.GetString("m_lblHasThesePermissions.Text");
        m_lblHasThesePermissions.Name = "HasThesePermissions";
        this.m_lvPermissions.Location = ((System.Drawing.Point)(resources.GetObject("m_lvPermissions.Location")));
        this.m_lvPermissions.Size = ((System.Drawing.Size)(resources.GetObject("m_lvPermissions.Size")));
        this.m_lvPermissions.TabIndex = ((int)(resources.GetObject("m_lvPermissions.TabIndex")));
        m_lvPermissions.Name = "Permissions";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblPermissionSet,
                        this.m_cbPermissionSet,
                        this.m_lblHasThesePermissions,
                        this.m_lvPermissions,
                        this.m_lblHelp,
                        this.m_btnViewPerm});

        // Now do some custom additions
 		m_cbPermissionSet.DropDownStyle = ComboBoxStyle.DropDownList;

        // Create an image list of icons we'll be displaying
        m_ilIcons = new ImageList();
        // Keep the order of these consistant with the const's declared at the top
        // of this class
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("permission_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("permission_ico")));


        m_lvPermissions.SmallImageList = m_ilIcons;
        m_lvPermissions.MultiSelect = false;
        m_lvPermissions.View = View.Details;

        m_lvPermissions.HeaderStyle = ColumnHeaderStyle.None;
        ColumnHeader ch = new ColumnHeader();
        ch.Text = CResourceStore.GetString("Permission");
        ch.Width = ((System.Drawing.Size)(resources.GetObject("m_lvPermissions.Size"))).Width-17;
        m_lvPermissions.Columns.Add(ch);

        // Fill in the data
        PutValuesinPage();

		// Now hook up the event handlers....
		m_cbPermissionSet.SelectedIndexChanged += new EventHandler(onPermissionSetChange);
 		m_lvPermissions.SelectedIndexChanged += new EventHandler(onPermissionChange);
		m_lvPermissions.DoubleClick += new EventHandler(onViewPermsClick);
        m_btnViewPerm.Click += new EventHandler(onViewPermsClick);

		return 1;
    }// InsertPropSheetPageControls

    internal NamedPermissionSet ChoosenNamedPermissionSet
    {
        get{return m_npsCurPermSet;}
    }// PermissionSetName

    private void PutValuesinPage()
    {
        // Fill the Permission Set Combo Box
        m_cbPermissionSet.Items.Clear();
        m_npsCurPermSet = null;
        m_npsCreatedPermSet = null;
        m_psOriginalPermSet = null;

        IEnumerator permsetEnumerator = m_pl.NamedPermissionSets.GetEnumerator();
                   
        m_cbPermissionSet.Text = CResourceStore.GetString("<unknown>");
        while (permsetEnumerator.MoveNext())
        {
            NamedPermissionSet permSet = (NamedPermissionSet)permsetEnumerator.Current;
            m_cbPermissionSet.Items.Add(permSet.Name); 
            if (m_cg == null || (m_cg.PermissionSetName != null && m_cg.PermissionSetName.Equals(permSet.Name)))
                m_npsCurPermSet = permSet;    
        }
        
        // Select the permission set that's the current one
        if (m_npsCurPermSet == null && m_cg != null && m_cg.PolicyStatement != null)
        {
            if (m_cg.PolicyStatement.PermissionSet is NamedPermissionSet)
            {
                // We didn't find our named permission set here. Put in an entry for it
                m_npsCurPermSet = (NamedPermissionSet)m_cg.PolicyStatement.PermissionSet;
                m_cbPermissionSet.Items.Add(m_npsCurPermSet.Name);
                m_psOriginalPermSet = m_npsCreatedPermSet = m_npsCurPermSet; 
            }


            else 
            {
                // We have a permission set assigned to this codegroup
                // that is not a NamedPermissionSet. We should still be cool and show this to the
                // user.
                m_npsCreatedPermSet = new NamedPermissionSet(CResourceStore.GetString("<unknown>"), m_cg.PolicyStatement.PermissionSet);
                m_psOriginalPermSet = m_cg.PolicyStatement.PermissionSet;
                m_cbPermissionSet.Items.Add(m_npsCreatedPermSet.Name);
                m_npsCurPermSet = m_npsCreatedPermSet;
            }
        }


        if (m_npsCurPermSet != null)
            m_cbPermissionSet.Text = m_npsCurPermSet.Name;


        // Fill in the permissions with this permission set
        PutInPermissions(m_npsCurPermSet);
    }// PutValuesinPage

    private void PutInPermissions(NamedPermissionSet ps)
    {
        // Display the various permissions in the currently selected permission set
        m_lvPermissions.Items.Clear();
        if (ps != null)
        {
            IEnumerator permEnumerator = ps.GetEnumerator();
            while (permEnumerator.MoveNext())
            {
                IPermission perm = (IPermission)permEnumerator.Current;
                int nImageIndex = DeterminePermissionIcon(perm);
                ListViewItem lvi = new ListViewItem(Security.GetDisplayStringForPermission(perm), nImageIndex);
                m_lvPermissions.Items.Add(lvi);
            }
        }
    }// PutInPermissions

    private int DeterminePermissionIcon(IPermission perm)
    {
        if (perm is IUnrestrictedPermission)
        {
            IUnrestrictedPermission permission = (IUnrestrictedPermission)perm;
            // If this is unrestricted....
            if (permission.IsUnrestricted())
                return UNRESTRICTEDIMAGEINDEX;

            // else, this has partial permissions....
            return PARTIALIMAGEINDEX;
        }
        // Otherwise... we don't know...
        return PARTIALIMAGEINDEX;
    }
 
    internal override bool ApplyData()
    {
        // See if they can make these changes
        if (!CanMakeChanges())
            return false;

        // First, apply the condition type
        // We need more info on this, so we'll save that for later. :)

        // Apply the permission set
        
        PolicyStatement ps = m_cg.PolicyStatement;
        if (ps == null)
        	ps = new PolicyStatement(null);

        if (m_npsCurPermSet != m_npsCreatedPermSet)
            ps.PermissionSet = m_npsCurPermSet;

        // If this was the original unnamed permission set or a namedpermission set that didn't
        // exist in the policy, then give it back the original permission set 
        // (don't try and sneak a new one in there)
        else
            ps.PermissionSet = m_psOriginalPermSet;
        
        m_cg.PolicyStatement = ps;
        SecurityPolicyChanged();
        return true;
    }// ApplyData

    void onPermissionSetChange(Object o, EventArgs e)
    {
        m_npsCurPermSet = null;

        // We need to find the new permission set
        IEnumerator permsetEnumerator = m_pl.NamedPermissionSets.GetEnumerator();

        
        while (permsetEnumerator.MoveNext())
        {
            NamedPermissionSet permSet = (NamedPermissionSet)permsetEnumerator.Current;
            if (permSet.Name.Equals(m_cbPermissionSet.Text))
            {
                m_npsCurPermSet = permSet;
                break;
            }
        }    

        // If we couldn't find the permission set in the policy, then it must be the 
        // unnamed one that the codegroup initially had
        if (m_npsCurPermSet == null)
            m_npsCurPermSet = m_npsCreatedPermSet;
        
        PutInPermissions(m_npsCurPermSet);
        m_btnViewPerm.Enabled=false;
        ActivateApply();

    }// onPermissionSetChange

    void onPermissionChange(Object o, EventArgs e)
    {
        if (m_lvPermissions.SelectedIndices.Count > 0)
            m_btnViewPerm.Enabled=true;
        else
            m_btnViewPerm.Enabled=false;
    }// onPermissionChange


    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

    void onViewPermsClick(Object o, EventArgs e)
    {
    
        int iIndex=0;
        if (m_lvPermissions.SelectedIndices.Count > 0 && m_npsCurPermSet != null)
        {
            // Set cursor to wait cursor
            IntPtr hOldCursor = SetCursorToWait();

            IEnumerator permEnumerator = m_npsCurPermSet.GetEnumerator();
            while (permEnumerator.MoveNext() && iIndex != m_lvPermissions.SelectedIndices[0])
                iIndex++;


            new CReadOnlyPermission((IPermission)permEnumerator.Current).ShowDialog();

            SetCursor(hOldCursor);
        }

    }// onViewPermsClick
}// class CSingleCodeGroupPSetProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglecodegroup.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CSingleCodeGroup.cs
//
// This class presents the a code group node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Drawing;
using System.Collections;
using System.Security.Policy;
using System.Runtime.InteropServices;
using System.Security;

class CSingleCodeGroup : CSecurityNode
{

    CodeGroup   m_cgOld;
    bool        m_fIAmDeleted;
    
    internal CSingleCodeGroup(ref PolicyLevel pl, ref CodeGroup cg, bool fReadOnly)
    {
        ReadOnly = fReadOnly;
        m_sGuid = "E1768EA0-51D6-42ea-BA97-C9BC7F4C5CC0";
        m_sHelpSection = "";
       
        if (cg.Name != null && cg.Name.Length > 0)
            m_sDisplayName = cg.Name;
        else
            m_sDisplayName = CResourceStore.GetString("CSingleCodeGroup:NoName");
           
        m_aPropSheetPage = null;

        if (cg is UnionCodeGroup)
        {
            m_hIcon = CResourceStore.GetHIcon("singlecodegroup_ico");  
            m_oResults=new CSingleCodeGroupTaskPad(this, cg);
        }
        else
        {
            m_hIcon = CResourceStore.GetHIcon("customcodegroup_ico");  
            m_oResults = new CNonUnionCGTaskPad(this, cg);
        }
        
        m_cg = cg;
        m_cgOld = m_cg.Copy();
        m_pl = pl;
        m_fIAmDeleted=false;
    }// CSingleCodeGroup
  
    protected override void CreatePropertyPages()
    {
        if (m_cg is UnionCodeGroup)
            m_aPropSheetPage = new CPropPage[] {new CSingleCodeGroupProp(m_pl, m_cg),
                                                new CSingleCodeGroupMemCondProp(m_cg),
                                                new CSingleCodeGroupPSetProp(ref m_pl, ref m_cg)
                                               };
        else // Non-Union Code group
            m_aPropSheetPage = new CPropPage[] {new CSingleCodeGroupProp(m_pl, m_cg),
                                                new CCustomCodeGroupProp(m_cg)
                                               };
        
    }// CreatePropertyPages

    internal CSinglePermissionSet AddPermissionSet(NamedPermissionSet nps)
    {
        // Run up until we come to the policy node
        CNode node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
        while(!(node is CSecurityPolicy))
            node = CNodeManager.GetNodeByHScope(node.ParentHScopeItem);

        // Ok, we have the policy node. Let's tell it to add this permission set
        return ((CSecurityPolicy)node).AddPermissionSet(nps);
    }// AddPermissionSet

    internal CSingleCodeGroup AddCodeGroup(CodeGroup ucg)
    {
       return AddCodeGroup(ucg, true, m_pl); 
    }// AddCodeGroup
    
    protected CSingleCodeGroup AddCodeGroup(CodeGroup ucg, bool fPrepTree, PolicyLevel polSrc)
    {
        if (fPrepTree)
        {
            // Check for codegroups with multiple names, and permission sets that 
            // may not exist in this policy level
            Security.PrepCodeGroupTree(ucg, polSrc, m_pl);
        }
        m_cg.AddChild(ucg);

        // Now add this codegroup (and its children) to the policy tree
        CNode nodeFirst = null;
        ArrayList al = new ArrayList();

        // The ArrayList is laid out as follows...
        
        // A parent CNode is placed in the ArrayList first, and then 
        // CodeGroups follow that should be wrapped in a CNode and be children 
        // to the first 'parent' CNode.

        // So the ArrayList could look like this
        //
        // Node1 -> CG1 -> CG2 -> CG3 -> Node2 -> CG4 -> CG5 -> Node3 -> .....
        //
        // So CG1, CG2, and CG3 should all be nodes that are children of Node1.
        // CG4 and CG5 should be nodes that are children of Node2, and so on.
        
        al.Add(this);
        al.Add(ucg);

        while(al.Count > 0)
        {
            // First item should be a node
            CNode nodeParent = (CNode)al[0];
            
            // Remove the parent node
            al.RemoveAt(0);

            // Now we should have (possibly) multiple codegroups
            while(al.Count > 0 && !(al[0] is CNode))
            {
                CodeGroup cg = (CodeGroup)al[0];
                CNode nodeChild = new CSingleCodeGroup(ref m_pl, ref cg, ReadOnly);
                if (nodeFirst == null)
                    nodeFirst = nodeChild;
                    
                int nCookie = CNodeManager.AddNode(ref nodeChild);

                // Inform the parent that it has a new child
                nodeParent.AddChild(nCookie);

                // And place this new node in the tree
                nodeParent.InsertSpecificChild(nCookie);

                // If this codegroup has any children, we'll need to worry about that too
                bool fHaveChildren = false;

                // Iterate through this guy's children
                IEnumerator enumCodeGroups = cg.Children.GetEnumerator();

                while (enumCodeGroups.MoveNext())
                {
                    if (!fHaveChildren)
                    {
                        // Put this new 'parent node' in the array list
                        al.Add(nodeChild);
                        fHaveChildren = true;
                    }
                    // And then add all its children
                    CodeGroup cgChild = (CodeGroup)enumCodeGroups.Current;
                    al.Add(cgChild);
                }
                // Remove this child codegroup
                al.RemoveAt(0);
            }
        }

        SecurityPolicyChanged();
        return (CSingleCodeGroup)nodeFirst;
    }// AddCodeGroup

    internal override void onSelect(IConsoleVerb icv)
    {
        int nEnable = ReadOnly?0:1;

           
        icv.SetVerbState(MMC_VERB.RENAME, MMC_BUTTON_STATE.ENABLED, nEnable);
        icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, nEnable);
        icv.SetVerbState(MMC_VERB.PASTE, MMC_BUTTON_STATE.ENABLED, nEnable);
        // We can also delete this node if it's not the root codegroup
        if (Security.GetRootCodeGroupNode(m_pl) != this)
            icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, nEnable);
    }// onSelect

    internal override int doAcceptPaste(IDataObject ido)
    {
        // Only accept a CSingleCodeGroup Node
        if (ido is CDO)
        {
            CDO cdo = (CDO)ido;
            if (cdo.Node is CSingleCodeGroup && cdo.Node != this)
                return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// doAcceptPaste

    internal override int Paste(IDataObject ido)
    {
        // We have two different things we have to do. We need to remove this CodeGroup
        // from it's current parent and parent it to this codegroup
        
        CDO cdo = (CDO)ido;
        CSingleCodeGroup scg = (CSingleCodeGroup)cdo.Node;
        AddCodeGroup(scg.m_cg.Copy(), !(scg.m_pl == m_pl), scg.m_pl);

        // If we're moving codegroups between policy levels, don't remove
        // the codegroup. If we're moving the codegroup within the same policy
        // level, then remove it
        if (scg.m_pl == m_pl)
        {
            scg.RemoveThisCodegroup();
            SecurityPolicyChanged();
        }
        Showing();
        
        // Now expand with our new things...
        //CNodeManager.CNamespace.Expand(HScopeItem);
        return HRESULT.S_OK;
    }// Paste

    internal override int onRename(String sNewName)
    {
        // We should do some checking to see if this name exists elsewhere....
        if (Security.isCodeGroupNameUsed(m_pl.RootCodeGroup, sNewName))
        {
            MessageBox(String.Format(CResourceStore.GetString("Codegroupnameisbeingused"),sNewName),
                       CResourceStore.GetString("CodegroupnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);

            return HRESULT.S_FALSE;
        }
        // Else, we're ok to make the name change
        m_sDisplayName = sNewName;
        m_cg.Name = sNewName;
        SecurityPolicyChanged();

        return HRESULT.S_OK;
    }// onRename

    internal override int onDelete(Object o)
    {
        // Let's remove this codegroup from the current policy
        int nRes = MessageBox(CResourceStore.GetString("CSingleCodeGroup:VerifyDelete"),
                              CResourceStore.GetString("CSingleCodeGroup:VerifyDeleteTitle"),
                              MB.YESNO|MB.ICONQUESTION);
        if (nRes == MB.IDYES)
        {
            RemoveThisCodegroup();
            return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// onDelete

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {  
         // See if we're allowed to insert an item in the "view" section
         if (!ReadOnly && (pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
         {
            // Stuff common to the top menu
            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            newitem.strName = CResourceStore.GetString("CSingleCodeGroup:NewOption");
            newitem.strStatusBarText = CResourceStore.GetString("CSingleCodeGroup:NewOptionDes");
            newitem.lCommandID = COMMANDS.CREATE_CODEGROUP;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);


            newitem.strName = CResourceStore.GetString("CSingleCodeGroup:DuplicateOption");
            newitem.strStatusBarText = CResourceStore.GetString("CSingleCodeGroup:DuplicateOptionDes");
            newitem.lCommandID = COMMANDS.DUPLICATE_CODEGROUP;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
         }
     }// AddMenuItems

     internal override void MenuCommand(int nCommandID)
     {

        if (nCommandID == COMMANDS.CREATE_CODEGROUP)
        {
            CNewCodeGroupWizard wiz = new CNewCodeGroupWizard(m_pl);
            wiz.LaunchWizard(Cookie);
            // Ok, let's see what goodies we have...
            String sPermSetName = null; 
            if (wiz.CreatedPermissionSet != null)
            {
                sPermSetName = AddPermissionSet(wiz.CreatedPermissionSet).DisplayName;
                SecurityPolicyChanged();
            }
            if (wiz.CreatedCodeGroup != null)
            {
                try
                {
                    CodeGroup cg = wiz.CreatedCodeGroup;
                    if (sPermSetName != null)
                    {
                        PermissionSet ps = m_pl.GetNamedPermissionSet(sPermSetName);
                        PolicyStatement pols = cg.PolicyStatement;
                        pols.PermissionSet = ps;
                        cg.PolicyStatement = pols;                
                    }
                    CSingleCodeGroup node = AddCodeGroup(wiz.CreatedCodeGroup);
                    // Put the focus on the newly created codegroup
                    CNodeManager.SelectScopeItem(node.HScopeItem);
                }
                catch(Exception)
                {
                    MessageBox(CResourceStore.GetString("CSingleCodeGroup:ErrorCreatingCodegroup"),
                               CResourceStore.GetString("CSingleCodeGroup:ErrorCreatingCodegroupTitle"),
                               MB.ICONEXCLAMATION);
                }
            }
        }
        else if (nCommandID == COMMANDS.DUPLICATE_CODEGROUP)
        {
            CNode node;

            CodeGroup newcg = m_cg.Copy();

            // Change this code group's name

            String sBaseName = newcg.Name;
            newcg.Name = String.Format(CResourceStore.GetString("CSingleCodeGroup:PrependtoDupCodegroups"), newcg.Name);
            int nCounter = 1;
            // make sure it's not already used
            while(Security.isCodeGroupNameUsed(m_pl.RootCodeGroup, newcg.Name))
            {   
                nCounter++;
                newcg.Name = String.Format(CResourceStore.GetString("CSingleCodeGroup:NumPrependtoDupCodegroups"), nCounter.ToString(), sBaseName);
            }

            CNode newCodeGroup = null;
            // If we are the root codegroup, then we'll add this as a child                     
            if (Security.GetRootCodeGroupNode(m_pl) == this)
            {
                newCodeGroup = AddCodeGroup(newcg);
                node = this;
            }
            else
            {
                node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
                newCodeGroup = ((CSingleCodeGroup)node).AddCodeGroup(newcg);
            }

            // Select the new item
            CNodeManager.SelectScopeItem(newCodeGroup.HScopeItem);
        }
    }// MenuCommand

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        if ((int)arg == 1)
        {
            OpenMyPropertyPage();
        }
        else if ((int)arg == 2)
        {
            // We want to Add a child code group to this codegroup
            MenuCommand(COMMANDS.CREATE_CODEGROUP);
        }
    }// TaskPadTaskNotify



    private void RemoveThisCodegroup()
    {
        // Grab our parent codegroup and tell him to remove us
        CNode node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
        if (node is CSingleCodeGroup)
            ((CSingleCodeGroup)node).RemoveChildCodegroup(this);
        else
        {
            // "Help! I don't know who my parent is!"
            // In this case, we'll just return and do nothing
            return;
        }
                
        // Now let's remove ourselves from the tree

        // Make sure we close all open property pages
        CloseAllMyPropertyPages();
        
        CNodeManager.GetNodeByHScope(ParentHScopeItem).RemoveSpecificChild(Cookie);
        m_fIAmDeleted=true;
    }// RemoveThisCodegroup

    private void RemoveChildCodegroup(CSingleCodeGroup cg)
    {
        Security.RemoveChildCodegroup(this, cg);    
        SecurityPolicyChanged();
    }// RemoveChildCodegroup

    internal override void SecurityPolicyChanged(bool fShowDialog)
    {
        if (!m_fIAmDeleted)
        {
            // We need to catch this policy change in the event that our display name
            // has changed
            if (m_cg.Name == null || m_cg.Name.Length==0)
                m_sDisplayName = CResourceStore.GetString("CSingleCodeGroup:NoName");
            else
            {   
                m_sDisplayName = m_cg.Name;
            }

            // We need to remove this node from the policy tree, then replace it
            // with the updated Codegroup
            if (Security.GetRootCodeGroupNode(m_pl) == this)
            {
                // This is the easy case... we'll just replace the root code
                m_pl.RootCodeGroup=m_cg;
            }
            else
            {
                // We need to do a big deal update
                Security.UpdateCodegroup(m_pl, this);
            }
            m_cgOld = m_cg.Copy();
            RefreshResultView();
        }
        base.SecurityPolicyChanged(fShowDialog);
    }// SecurityPolicyChanged
 }// class CSingleCodeGroup
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglepermissionsetprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Security.Policy;

internal class CSinglePermissionSetProp : CSecurityPropPage
{
    // Controls on the page
    private TextBox m_txtPSetName;
    private Label m_lblPSetDes;
    private Label m_lblPSetName;
    private TextBox m_txtPSetDes;

    // internal data
    CPSetWrapper        m_psetWrapper;
    bool                m_fReadOnly;

    internal CSinglePermissionSetProp(CPSetWrapper psw, bool fReadOnly)
    {
        m_sTitle = CResourceStore.GetString("CSinglePermissionSetProp:PageTitle"); 
        m_psetWrapper = psw;
        m_fReadOnly = fReadOnly;
    }// CSinglePermissionSetProp 

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSinglePermissionSetProp));
        this.m_txtPSetName = new System.Windows.Forms.TextBox();
        this.m_lblPSetDes = new System.Windows.Forms.Label();
        this.m_lblPSetName = new System.Windows.Forms.Label();
        this.m_txtPSetDes = new System.Windows.Forms.TextBox();
        this.m_txtPSetName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPSetName.Location")));
        this.m_txtPSetName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPSetName.Size")));
        this.m_txtPSetName.TabIndex = ((int)(resources.GetObject("m_txtPSetName.TabIndex")));
        m_txtPSetName.Name = "Name";
        this.m_lblPSetDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPSetDes.Location")));
        this.m_lblPSetDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPSetDes.Size")));
        this.m_lblPSetDes.TabIndex = ((int)(resources.GetObject("m_lblPSetDes.TabIndex")));
        this.m_lblPSetDes.Text = resources.GetString("m_lblPSetDes.Text");
        m_lblPSetDes.Name = "DescriptionLabel";
        this.m_lblPSetName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPSetName.Location")));
        this.m_lblPSetName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPSetName.Size")));
        this.m_lblPSetName.TabIndex = ((int)(resources.GetObject("m_lblPSetName.TabIndex")));
        this.m_lblPSetName.Text = resources.GetString("m_lblPSetName.Text");
        m_lblPSetName.Name = "NameLabel";
        this.m_txtPSetDes.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPSetDes.Location")));
        this.m_txtPSetDes.Multiline = true;
        this.m_txtPSetDes.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPSetDes.Size")));
        this.m_txtPSetDes.TabIndex = ((int)(resources.GetObject("m_txtPSetDes.TabIndex")));
        m_txtPSetDes.Name = "Description";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
						this.m_lblPSetName,
                        this.m_txtPSetName,
                        this.m_lblPSetDes,
        				this.m_txtPSetDes
                        });

        // Fill in the data
        PutValuesinPage();

		m_txtPSetName.TextChanged += new EventHandler(onChange);
		m_txtPSetDes.TextChanged += new EventHandler(onChange);

		m_txtPSetName.ReadOnly = m_fReadOnly;
		m_txtPSetDes.ReadOnly = m_fReadOnly;

		m_txtPSetName.Select(0,0);
		m_txtPSetDes.Select(0,0);
		

		return 1;
    }// InsertPropSheetPageControls

    private void PutValuesinPage()
    {
        m_txtPSetName.Text = m_psetWrapper.PSet.Name;
        m_txtPSetDes.Text = m_psetWrapper.PSet.Description;

    }// PutValuesinPage

    internal override bool ValidateData()
    {
        // Make sure the name is unique
        if (m_psetWrapper.PSet.Name != null && !m_psetWrapper.PSet.Name.Equals(m_txtPSetName.Text) && Security.isPermissionSetNameUsed(m_psetWrapper.PolLevel, m_txtPSetName.Text))
        {
            MessageBox(String.Format(CResourceStore.GetString("PermissionSetnameisbeingused"), m_txtPSetName.Text), 
                       CResourceStore.GetString("PermissionSetnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);

            return false;
        }
        // Everything is ok then...
        return true;
    }// ValidateData



    internal override bool ApplyData()
    {
        // We'll set the description first and pass that through changeNamedPermissionSet
        m_psetWrapper.PSet.Description = m_txtPSetDes.Text;
        m_psetWrapper.PolLevel.ChangeNamedPermissionSet(m_psetWrapper.PSet.Name, m_psetWrapper.PSet);

        // If the user modified the permission set name, that will be caught during the
        // SecurityPolicyChanged call.
        m_psetWrapper.PSet.Name= m_txtPSetName.Text;

        SecurityPolicyChanged();
   
        return true;
    }// ApplyData

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CSinglePermissionSetProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csharedassemblies.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CSharedAssemblies.cs
//
// This class represents the shared assemblies node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.IO;
using System.Drawing;
using System.Windows.Forms;
using System.Collections;
using System.Runtime.InteropServices;
using System.Globalization;

class CSharedAssemblies : CNode
{
    private ArrayList  m_olAssems;

    private bool        m_fShowHTMLPage;
    private bool        m_fReadShowHTML;
    
    private CTaskPad    m_taskPad;
    
    private IntPtr      m_hBlankIcon;
    private int         m_iBlankIconIndex;

    private IntPtr      m_hGACIcon;
    private int         m_iGACIconIndex;

    private IntPtr      m_hZAPIcon;
    private int         m_iZAPIconIndex;

    private ArrayList   m_alResultPropPages;

    private class PropPagePairs
    {
        internal CPropPage[]  ppages;
        internal AssemInfo    ai;
    }// class PropPagePairs

    internal CSharedAssemblies()
    {
        m_sGuid = "96821C0B-CBE2-4dc9-AC52-756A3361B07F";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("sharedassemblies_ico");  
        DisplayName = CResourceStore.GetString("CSharedAssemblies:DisplayName");
        Name = "Assembly Cache";

        m_taskPad = new CGenericTaskPad(this, "SHAREDASSEM_HTML");
        m_fReadShowHTML = false;

        m_olAssems = Fusion.ReadFusionCache();

        m_alResultPropPages = new ArrayList();
        

        // Set up the blank icon
        m_hBlankIcon = CResourceStore.GetHIcon("blank_ico");  
        m_iBlankIconIndex = CResourceStore.GetIconCookie(m_hBlankIcon);

        m_hGACIcon = CResourceStore.GetHIcon("gac_ico");  
        m_iGACIconIndex = CResourceStore.GetIconCookie(m_hGACIcon);

        m_hZAPIcon = CResourceStore.GetHIcon("zap_ico");  
        m_iZAPIconIndex = CResourceStore.GetIconCookie(m_hZAPIcon);

        m_fAllowMultiSelectResults=true;
               
    }// CSharedAssemblies
    
         
    internal override void ResultItemSelected(IConsole2 con, Object oResults)
    {
    
        IConsoleVerb icv;       
        // Get the IConsoleVerb interface from MMC
        con.QueryConsoleVerb(out icv);

        icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 1);

        if (oResults is AssemInfo)
        {
            AssemInfo ai = (AssemInfo)oResults;

            // We only want to user to be able to copy this item if it is a GAC Assembly

            if (ai.nCacheType == ASM_CACHE.GAC)
                icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 1);

        }
        else if (oResults is ArrayList)
        {
            // Run through the array list. If everything is from the GAC, then
            // we'll enable the copy verb
            ArrayList al = (ArrayList)oResults;
            bool fFoundZap = false;
            int nIndex = 0;
            while (!fFoundZap && nIndex < al.Count)
            {
                if (((AssemInfo)m_olAssems[(int)(al[nIndex])-1]).nCacheType != ASM_CACHE.GAC)
                    fFoundZap = true;
                nIndex++;
            }
            if (!fFoundZap)
            {
                icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 1);
            }
        }

        icv.SetVerbState(MMC_VERB.CUT, MMC_BUTTON_STATE.ENABLED, 0);


    }// ResultItemSelected

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {  
         CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
         // See if we're allowed to insert an item in the "view" section
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
         {
            // Stuff common to the top menu
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            if (oResultItem == null)
            {
                newitem.strName = CResourceStore.GetString("CSharedAssemblies:AddOption");
                newitem.strStatusBarText = CResourceStore.GetString("CSharedAssemblies:AddOptionDes");
                newitem.lCommandID = COMMANDS.ADD_GACASSEMBLY;
                // Now add this item through the callback
                piCallback.AddItem(ref newitem);

            }
         }
         // See if we can insert in the view menu
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_VIEW) > 0)
         {
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If we're showing the taskpad right now
            if (m_oResults is CGenericTaskPad)
            {
                newitem.strName = CResourceStore.GetString("CSharedAssemblies:ViewAssembliesOption");
                newitem.strStatusBarText = CResourceStore.GetString("CSharedAssemblies:ViewAssembliesOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_LISTVIEW;
            }
            // Currently, we're showing the list view
            else
            {
                newitem.strName = CResourceStore.GetString("CSharedAssemblies:ViewHTMLOption");
                newitem.strStatusBarText = CResourceStore.GetString("CSharedAssemblies:ViewHTMLOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_TASKPAD;
            }
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            // Add a 'Refresh' menu item
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;
            newitem.strName = CResourceStore.GetString("CSharedAssemblies:RefreshOption");
            newitem.strStatusBarText = CResourceStore.GetString("CSharedAssemblies:RefreshOptionDes");
            newitem.lCommandID = COMMANDS.REFRESH_DISPLAY;
            piCallback.AddItem(ref newitem);

            
         }
     }// AddMenuItems

     internal override void MenuCommand(int iCommandID, Object oResultItem)
     {
    
        if (iCommandID == COMMANDS.ADD_GACASSEMBLY)
        {
            // Pop up a file dialog so the user can find an assembly
            OpenFileDialog fd = new OpenFileDialog();
            fd.Title = CResourceStore.GetString("CSharedAssemblies:AddAssemFDTitle");
            fd.Filter = CResourceStore.GetString("AssemFDMask");
            fd.Multiselect = true;
            System.Windows.Forms.DialogResult dr = fd.ShowDialog();
            if (dr == System.Windows.Forms.DialogResult.OK)
            {
                for(int i=0; i<fd.FileNames.Length; i++)
                    if (!AddAssemToFusion(fd.FileNames[i]))
                        // If we can't add assemblies due to an access denied, then
                        // just stop trying with our list of assemblies
                        break;
            }
            
            // Find the assembly we just added in order to select it
            int nCount = getNumRows();
            for(int i=0; i<nCount; i++)
            {
                if (TurnCodebaseToFilename(GetAssemInfo(i).Codebase).ToLower(CultureInfo.InvariantCulture).Equals(fd.FileNames[0].ToLower(CultureInfo.InvariantCulture)))
                {
                    IResultData ResultData = (IResultData)CNodeManager.CConsole;

                    RESULTDATAITEM rdi = new RESULTDATAITEM();
                    rdi.mask = RDI.STATE;
                    rdi.nCol = 0;
                    rdi.nIndex = i;
                    rdi.nState = LVIS.SELECTED;
                    ResultData.SetItem(ref rdi);
                    break;
                }
            }
        }
        else if (iCommandID == COMMANDS.SHOW_LISTVIEW)
        {
            m_oResults=this;
            RefreshResultView();
            m_fShowHTMLPage=false;
        }

        else if (iCommandID == COMMANDS.SHOW_TASKPAD)
        {
            m_oResults=m_taskPad;
            m_fShowHTMLPage = true;

            // The HTML pages comes displayed with this checkbox marked. Make
            // sure we update the xml setting
            CConfigStore.SetSetting("ShowHTMLForSharedAssem", "yes");
            RefreshResultView();
        }

        else if (iCommandID == COMMANDS.REFRESH_DISPLAY)
        {
            RefreshResultView();
        }
            
    }// MenuCommand


    private String TurnCodebaseToFilename(String sCodebase)
    {
        try
        {
            if (sCodebase != null && sCodebase.Length > 0)
            {
                Uri uCodebase = new Uri(sCodebase);
                return uCodebase.AbsolutePath;
            }
        }
        catch(Exception)
        {
        }
        return "";
    }// TurnCodebaseToFilename

    internal override int onDoubleClick(Object o)
    {
        if (o != null)
        {
            
            AssemInfo ai = (AssemInfo)o;
            CDO cdo = new CDO(this);
            cdo.Data = o;

            OpenMyResultPropertyPage(ai.Name, cdo);
            return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
     }// onDoubleClick

    internal override int onDelete(Object o)
    {   
        String sMessage;

        if (o is ArrayList)
            sMessage = CResourceStore.GetString("CSharedAssemblies:VerifyDelete");
        else
            sMessage = String.Format(CResourceStore.GetString("CSharedAssemblies:VerifyDeleteSingle"),((AssemInfo)o).Name);

            
        int nRes = MessageBox(sMessage,
                              CResourceStore.GetString("CSharedAssemblies:VerifyDeleteTitle"),
                              MB.ICONQUESTION|MB.YESNO);
        if (nRes == MB.IDYES)
        {
            if (o is ArrayList)
            {
                ArrayList al = (ArrayList)o;
                for(int i=0; i<al.Count; i++)
                {
                    int nVictim = ((int)al[i])-1;
                    if (!Fusion.RemoveAssemblyFromGac((AssemInfo)m_olAssems[nVictim]))
                    {
                        MessageBox(String.Format(CResourceStore.GetString("CSharedAssemblies:ErrorRemoving"), ((AssemInfo)m_olAssems[nVictim]).Name),
                                   CResourceStore.GetString("CSharedAssemblies:ErrorRemovingTitle"),
                                   MB.ICONEXCLAMATION);

                    }
                }
            }
            else
            {
                AssemInfo ai = (AssemInfo)o;
                if (!Fusion.RemoveAssemblyFromGac(ai))
                {
                    MessageBox(String.Format(CResourceStore.GetString("CSharedAssemblies:ErrorRemoving"), ai.Name),
                               CResourceStore.GetString("CSharedAssemblies:ErrorRemovingTitle"),
                               MB.ICONEXCLAMATION);

                }
            }
               
            m_olAssems = Fusion.ReadFusionCache();
            CNodeManager.Console.SelectScopeItem(HScopeItem);
        }
                                 
        return HRESULT.S_OK;
    }// onDelete



    internal override void Showing()
    {
        m_olAssems = Fusion.ReadFusionCache();

        if (!m_fReadShowHTML)        
        {
            m_fShowHTMLPage = ((String)CConfigStore.GetSetting("ShowHTMLForSharedAssem")).Equals("yes");
            
            if (m_fShowHTMLPage)
                m_oResults=m_taskPad;
            else
                m_oResults=this;
            m_fReadShowHTML = true;
        }
    }// Showing

    internal unsafe override int onRestoreView(MMC_RESTORE_VIEW mrv, IntPtr param)
    {
        // See if we should be displaying our HTML page or the result view
        if (mrv.pViewType == (IntPtr)0)
        {
            // We should display the column view
            m_oResults = this;
        }
        else
        {
            m_oResults = m_taskPad;
        }
        // Now we need to tell MMC we handled this.
        *((int*)param) = 1;
        
        //Marshal.WriteInt32(param, 1);
        return HRESULT.S_OK;
    }// onRestoreView


    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 1) 
       {
            CConfigStore.SetSetting("ShowHTMLForSharedAssem", (bool)param?"yes":"no");
            m_fShowHTMLPage = (bool)param;

            // We'll change the result object but we won't refresh our result view
            // because the user doesn't necesarily want that to happen. However, 
            // the next time the user visits this node, they will see the new result
            // view
            m_oResults = m_fShowHTMLPage?(Object)m_taskPad:(Object)this;                

       }
       else if ((int)arg == 0)
       {
            m_oResults = this;
            RefreshResultView();
       }
       else if ((int) arg == 2)
       {
            MenuCommand(COMMANDS.ADD_GACASSEMBLY, null);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.ADD_GACASSEMBLY);
       }
    }// TaskPadTaskNotify

    internal override int doAcceptPaste(IDataObject ido)
    {
        // Don't accept any data objects from the snapin
        // Files from the shell pass in a data object that does not support
        // the IDropSource interface, while any strings we try to paste in does...
        // this is a quick way to see if we will accept any strings from the snapin
        if (ido is CDO || ido is IDropSource)
        {
            return HRESULT.S_FALSE;
        }
        return HRESULT.S_OK;
    }// doAcceptPaste

    internal override int Paste(IDataObject ido)
    {
        if (ido is CDO || ido is IDropSource)
            throw new Exception("A bad DataObject got in here");
       
        // Get the filename we're looking at
        FORMATETC   ft = new FORMATETC();
        STGMEDIUM   st = new STGMEDIUM();

        ft.cfFormat = CF.HDROP;
        ft.ptd      = 0;
        ft.dwAspect = DVASPECT.CONTENT;
        ft.lindex   = -1;
        ft.tymed    = TYMED.HGLOBAL;

        int hr = ido.GetData(ref ft, ref st);

        if (hr != HRESULT.S_OK)
        {
            // Crud... we don't want to be here.
            return HRESULT.S_FALSE;
        }    

        // See if we have a filename
        uint dwNumFiles = DragQueryFile(st.hGlobal, unchecked((uint)-1), (IntPtr)0, 0);
        String sFilename=null;
        
        for(uint i=0; i<dwNumFiles; i++)
        {
            uint dwLength = DragQueryFile(st.hGlobal, i, (IntPtr)0, 0);
            if (dwLength > 0)
            {
                // Allocate memory for the string (remember the extra for the double null)
                IntPtr pString = Marshal.AllocCoTaskMem((int)dwLength+2);
                DragQueryFile(st.hGlobal, i, pString, dwLength+2);
                // Create a string from this pointer we have
                sFilename = Marshal.PtrToStringAnsi(pString);
                if (sFilename != null)
                    if (!AddAssemToFusion(sFilename))
                        // If this returns false, then we couldn't add the assembly
                        // because we don't have access to the GAC. Stop trying
                        // to process any other files.
                        break;

                // Free the memory that was created
                Marshal.FreeCoTaskMem(pString);
            }
        }
        ReleaseStgMedium(ref st);

        return HRESULT.S_OK;
    }// Paste

    private bool AddAssemToFusion(String sFilename)
    {
        if (Fusion.isManaged(sFilename))
        {
            int hr = Fusion.AddAssemblytoGac(sFilename);
            if (hr != HRESULT.S_OK)
            {
                if (hr == HRESULT.E_ACCESSDENIED)
                {
                    MessageBox(CResourceStore.GetString("CSharedAssemblies:AddAssemFailNoAccess"),
                               CResourceStore.GetString("CSharedAssemblies:AddAssemFailNoAccessTitle"),
                               MB.ICONEXCLAMATION);
                    // If this happens, they won't be able to add any items to the gac
                    return false;
                }
                else
                    MessageBox(CResourceStore.GetString("CSharedAssemblies:AddAssemFail"),
                               CResourceStore.GetString("CSharedAssemblies:AddAssemFailTitle"),
                               MB.ICONEXCLAMATION);
            }
            // Don't bother refreshing the screen unless we added an assembly
            else
            {
                m_olAssems = Fusion.ReadFusionCache();
                CNodeManager.Console.SelectScopeItem(HScopeItem);
            }
        }
        else
            MessageBox(CResourceStore.GetString("isNotManagedCode"),
                       CResourceStore.GetString("isNotManagedCodeTitle"),
                       MB.ICONEXCLAMATION);
        return true;                       
    }// AddAssemToFusion

    internal AssemInfo GetAssemInfo(int iIndex)
    {
        return (AssemInfo)m_olAssems[iIndex];
    }// GetAssemInfo

    internal override bool ResultQDO(int nCookie, out Object o)
    {
        o = GetAssemInfo((int)((nCookie & 0xFFFF0000) >> 16) - 1);
        return true;
    }// ResultQDO

    internal override bool ResultCompareObjects(Object o1, Object o2, out bool fEqual)
    {
        if (o1 is AssemInfo && o2 is AssemInfo)
        {
            fEqual = Fusion.CompareAssemInfo((AssemInfo)o1, (AssemInfo)o2);
            return true;
        }
        MessageBox("Ack. I'm in ResultCompareObjects and they aren't AssemInfos!", "", 0);
        fEqual = false;
        return false;
    }// ResultCompareObjects


    //-------------------------------------------------
    // Methods to implement the IColumnResultView interface
    //-------------------------------------------------
    public override int getNumColumns()
    {
        // We will always have 4 columns in the result view
        return 4;
    }// getNumColumns
    public override int getNumRows()
    {
        return m_olAssems.Count;
    }// GetNumRows
    public override String getColumnTitles(int iIndex)
    {
        String[] Titles= new String[] { CResourceStore.GetString("Assembly Name"), 
                                        CResourceStore.GetString("Version"),
                                        CResourceStore.GetString("Locale"),
                                        CResourceStore.GetString("Public Key Token"),
                                      };
        // Make sure they're in range
        if (iIndex >= 0 && iIndex< getNumColumns())
            return Titles[iIndex];
        else
            throw new Exception("Index out of bounds");
    }// getColumnTitles
    public override String getValues(int nRow, int nColumn)
    {
         // Make sure the indicies they give us are valid
        if (nRow >=0 && nRow<getNumRows() && nColumn>=0 && nColumn<getNumColumns())
        {
            switch(nColumn)
            {
                case 0:
                    return GetAssemInfo(nRow).Name;
                case 1:
                    return GetAssemInfo(nRow).Version;
                case 2:
                    return GetAssemInfo(nRow).Locale;
                case 3:
                    return GetAssemInfo(nRow).PublicKeyToken;
            }                    
            // This shouldn't happen, but the compiler thinks it could
            return null;
            
        }
        else
            return "";

    }// getValues
    public override void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hBlankIcon, m_iBlankIconIndex);
        il.ImageListSetIcon(m_hGACIcon, m_iGACIconIndex);
        il.ImageListSetIcon(m_hZAPIcon, m_iZAPIconIndex);
    }// AddImages
    public override int GetImageIndex(int i)
    {
        uint nCacheType = GetAssemInfo(i).nCacheType;

        switch(nCacheType)
        {
            case ASM_CACHE.ZAP:
                return m_iZAPIconIndex;
            case ASM_CACHE.GAC:
                return m_iGACIconIndex;
            default:
                // We should return the blank image index
                return m_iBlankIconIndex;
        }
    }// GetImageIndex

    public override bool DoesItemHavePropPage(Object o)
    {
        // If it's a single item, then yes, we have a property page
        if (o is AssemInfo)
            return true;
        else
            return false;
    }// DoesItemHavePropPage

    public override CPropPage[] CreateNewPropPages(Object o)
    {
        return GetPropertyPages((AssemInfo)o);
    }// ApplyPropPages

    private CPropPage[] GetPropertyPages(AssemInfo ai)
    {
        // Let's see if we already have an entry for this assemby item
        int nLen = m_alResultPropPages.Count;
        for(int i=0; i<nLen; i++)
            if (Fusion.CompareAssemInfo(((PropPagePairs)m_alResultPropPages[i]).ai, ai))
                return ((PropPagePairs)m_alResultPropPages[i]).ppages;

        // If we're here, then we have a new property page to add
        PropPagePairs ppp = new PropPagePairs();
        ppp.ppages = new CPropPage[1] { new CAssemGenProps(ai)};
        ppp.ai = ai;
        m_alResultPropPages.Add(ppp);
        return ppp.ppages;
    }// GetPropertyPages

    [DllImport("shell32.dll")]
    internal static extern uint DragQueryFile(IntPtr hDrop, uint iFile, IntPtr lpszFile, uint cch);

    [DllImport("ole32.dll")]
    internal static extern void ReleaseStgMedium(ref STGMEDIUM pmedium);

}// class CSharedAssemblies
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglecodegrouptaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security.Policy;
using System.Security;
using System.Runtime.InteropServices;

class CSingleCodeGroupTaskPad : CTaskPad
{
    CodeGroup   m_cg;
    bool        m_fReadOnly;


    internal CSingleCodeGroupTaskPad(CSingleCodeGroup node, CodeGroup cg) : base(node)
    {   
        m_cg = cg;
        m_fReadOnly = node.ReadOnly;
    }// CSingleCodeGroupTaskPad
 
    protected override String GetHTMLFilename()
    {
        return "SINGLECODEGROUP_HTML";
    }// GetHTMLFilename


    internal override String GetHTMLFile()
    {
        String [] args = new String[8];
        // The first element should be the name of the code group
        args[0] = (m_cg.Name != null && m_cg.Name.Length > 0)?m_cg.Name:CResourceStore.GetString("Unnamed");

        // The second element should be the description of the code group
        args[1] = m_cg.Description;

        // The third element should be the membership condition
        args[2] = Security.BuildMCDisplayName(m_cg.MembershipCondition.ToString());

   
        // The fourth element should be the permission set associated with the codegroup
        args[3] = m_cg.PermissionSetName;
        // the 5th element should be a description of the Permission Set Name
        args[4] = "";
        if (m_cg.PolicyStatement != null && m_cg.PolicyStatement.PermissionSet!= null && m_cg.PolicyStatement.PermissionSet is NamedPermissionSet)
            args[4] = ((NamedPermissionSet)m_cg.PolicyStatement.PermissionSet).Description;                    

        // And finally the 6th element should talk about level final and exclusivity.
        args[5] = "";
        if ((m_cg.PolicyStatement.Attributes & PolicyStatementAttribute.Exclusive) == PolicyStatementAttribute.Exclusive)
            args[5] += CResourceStore.GetString("CSingleCodeGroupTaskPad:ExclusiveCodeGroup") + "<BR><BR>";
            
        if ((m_cg.PolicyStatement.Attributes & PolicyStatementAttribute.LevelFinal) == PolicyStatementAttribute.LevelFinal)
            args[5] += CResourceStore.GetString("CSingleCodeGroupTaskPad:LevelFinalCodeGroup");

        // The 6th and 7th are used to comment out blocks that shouldn't be
        // displayed on read-only codegroups
        if (m_fReadOnly)
        {
            args[6] = "<!--";
            args[7] = "-->";
        }

        return GetHTMLFile(args);
    }// GetHTMLFile
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

}// class CSingleCodeGroupTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglepermissionset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CSinglePermissionSet.cs
//
// This class presents the a code group node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Drawing;
using System.Security;
using System.Collections;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Security.Policy;
using System.Net;
using System.DirectoryServices;
using System.Diagnostics;
using System.Drawing.Printing;
using System.ServiceProcess;
using System.Data.SqlClient;
using System.Data.OleDb;
using System.Messaging;

internal class CPSetWrapper
{
    NamedPermissionSet   m_permSet;
    PolicyLevel          m_pl;
    internal NamedPermissionSet PSet
    {
        get{return m_permSet;}
        set{m_permSet = value;}
    }
    internal PolicyLevel PolLevel
    {
        get{return m_pl;}
        set{m_pl = value;}
    }
}// class CPSetWrapper

class CSinglePermissionSet : CSecurityNode
{

    private ArrayList           m_alPermissions;

    private bool        m_fShowHTMLPage;
    private bool        m_fReadShowHTML;

    private CPropPage[]         m_permProps;

    private int                 m_iDisplayedPerm;

    private IntPtr              m_hRestrictedIcon;
    private int                 m_iRestrictedIndex;

    private IntPtr              m_hUnRestrictedIcon;
    private int                 m_iUnRestrictedIndex;

    private CPSetWrapper        m_psetWrapper;
    private bool                m_fReadOnlyPermissionSet;

    private String[]            m_sItems;    

    private const int           CUSTOM    = -1;
    private ArrayList           m_alCustomPropPages;
    private CTaskPad            m_taskpad;

    private bool                m_fDeleted;

    private struct CustomPages
    {
        internal int          nIndex;
        internal CPropPage    ppage;
    }// struct CustomPages

    internal CSinglePermissionSet(NamedPermissionSet permSet, PolicyLevel pl, bool fReadOnly)
    {
        base.ReadOnly = fReadOnly;
        m_sGuid = "E90A7E88-FB3C-4734-8245-0BEBCB4E6D63";
        m_sHelpSection = "";
        m_fReadShowHTML = false;
        m_fDeleted = false;
        m_pl = pl;

        m_psetWrapper = new CPSetWrapper();
        m_psetWrapper.PSet = permSet;
        m_psetWrapper.PolLevel = m_pl;

        m_hIcon = CResourceStore.GetHIcon("permissionset_ico");  
        m_sDisplayName = permSet.Name;

        m_alCustomPropPages = new ArrayList();
   
        // Set up the icons we'll be displaying for each permission
        m_hRestrictedIcon = CResourceStore.GetHIcon("permission_ico");
        m_iRestrictedIndex = CResourceStore.GetIconCookie(m_hRestrictedIcon);

        m_hUnRestrictedIcon = CResourceStore.GetHIcon("permission_ico");
        m_iUnRestrictedIndex = CResourceStore.GetIconCookie(m_hUnRestrictedIcon);

        m_fReadOnlyPermissionSet = false;
        try
        {
            // This line will throw an exception if we're trying to do this with a 
            // reserved permission set
            m_pl.ChangeNamedPermissionSet(permSet.Name, permSet);
        }
        catch(Exception)
        {
            m_fReadOnlyPermissionSet = true;
        }

        m_taskpad = new CSinglePermSetTaskPad(this);

        m_oResults = m_taskpad;
        m_aPropSheetPage = null;

        // Get the permissions
        GenerateGivenPermissionsStringList();

        m_permProps = null;
                
    }// CSinglePermissionSet

    internal new bool ReadOnly
    {
        get{return m_fReadOnlyPermissionSet|m_fReadOnly;}
    }// ReadOnly
    

    internal NamedPermissionSet PSet
    {
        get{return m_psetWrapper.PSet;}
    }// PSet

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        if ((int)arg == 0) 
        {
            m_oResults = this;
            RefreshResultView();
        }
        else if ((int)arg == 1)
        {
            MenuCommand(COMMANDS.ADD_PERMISSIONS);
        }
        else if ((int)arg == 2)
        {
            OpenMyPropertyPage();    
        }
        else if ((int)arg == 3)
        {
            CConfigStore.SetSetting("ShowHTMLForPermissionSet", (bool)param?"yes":"no");
            m_fShowHTMLPage = (bool)param;

            // We'll change the result object but we won't refresh our result view
            // because the user doesn't necesarily want that to happen. However, 
            // the next time the user visits this node, they will see the new result
            // view
            m_oResults = m_fShowHTMLPage?(Object)m_taskpad:(Object)this;                
        }
       
    }// TaskPadTaskNotify

    protected override void CreatePropertyPages()
    {
        if (m_aPropSheetPage == null)
            m_aPropSheetPage = new CPropPage[] {new CSinglePermissionSetProp(m_psetWrapper, ReadOnly)};

        // Create property pages for each permission type we know about
        if (m_permProps == null)
        {
            m_permProps = new CPropPage[19];
            m_permProps[0] = new CUIPermPropPage(m_psetWrapper);
            m_permProps[1] = new CSecPermPropPage(m_psetWrapper);
            m_permProps[2] = new CReflectPermPropPage(m_psetWrapper);
            m_permProps[3] = new CIsoStoragePermPropPage(m_psetWrapper);
            m_permProps[4] = new CDNSPermPropPage(m_psetWrapper);
            m_permProps[5] = new CEnvPermPropPage(m_psetWrapper);
            m_permProps[6] = new CFileIOPermPropPage(m_psetWrapper);
            m_permProps[7] = new CRegPermPropPage(m_psetWrapper);
            m_permProps[8] = new CSocketPermPropPage(m_psetWrapper);
            m_permProps[9] = new CWebPermPropPage(m_psetWrapper);
            m_permProps[10] = new CDirectoryServicesPermPropPage(m_psetWrapper);
            m_permProps[11] = new CEventLogPermPropPage(m_psetWrapper);
            m_permProps[12] = new CFileDialogPermPropPage(m_psetWrapper);
            m_permProps[13] = new CPerformanceCounterPermPropPage(m_psetWrapper);
            m_permProps[14] = new CPrintingPermPropPage(m_psetWrapper);
            m_permProps[15] = new CServiceControllerPermPropPage(m_psetWrapper);
            m_permProps[16] = new CSQLClientPermPropPage(m_psetWrapper);
            m_permProps[17] = new COleDbPermPropPage(m_psetWrapper);
            m_permProps[18] = new CMessageQueuePermPropPage(m_psetWrapper);
        }
    }// CreatePropertyPages


    internal override void onSelect(IConsoleVerb icv)
    {
        icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 1);

        if (!ReadOnly)
        {
            icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 1);
            icv.SetVerbState(MMC_VERB.RENAME, MMC_BUTTON_STATE.ENABLED, 1);
        }
    }// onSelect

    internal override void ResultItemSelected(IConsole2 con, Object oResults)
    {
        // Only care about this if this isn't a read-only permission set
        if (!ReadOnly)
        {
            IConsoleVerb icv;       
            // Get the IConsoleVerb interface from MMC
            con.QueryConsoleVerb(out icv);

            // We want to enable drag-drop actions
            icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 1);

        }
    }// ResultItemSelected

    internal override int onDelete(Object o)
    {
        // This is for the node
        if (o == null)
        {
            // First, make sure none of the code groups use this permission set
            CodeGroup cg = m_pl.RootCodeGroup;
            cg = GetCGUsingPermissionSet(cg);
            if (cg != null)
            {
                MessageBox(String.Format(CResourceStore.GetString("CSinglePermissionSet:isUsingPermissionSet"), cg.Name),
                           CResourceStore.GetString("CSinglePermissionSet:isUsingPermissionSetTitle"),
                           MB.ICONEXCLAMATION);
            }
            else
            {
                int nRes = MessageBox(CResourceStore.GetString("CSinglePermissionSet:ConfirmDeletePSet"),
                                      CResourceStore.GetString("CSinglePermissionSet:ConfirmDeletePSetTitle"),
                                      MB.YESNO|MB.ICONQUESTION);
                if (nRes == MB.IDYES)
                {
                    m_pl.RemoveNamedPermissionSet(m_psetWrapper.PSet);

                    // Close all the property pages associated with this node
                    CloseAllMyPropertyPages();
                    // Now let's remove ourselves from the tree
                    CNodeManager.GetNodeByHScope(ParentHScopeItem).RemoveSpecificChild(Cookie);
                    m_fDeleted = true;
                    SecurityPolicyChanged();
                    // Ok, all references to this node should be gone.
                    return HRESULT.S_OK;
                }
            }
            return HRESULT.S_FALSE;
        }
        else // this is a result item --- a permission
        {

            int nRes  = MessageBox(CResourceStore.GetString("CSinglePermissionSet:ConfirmDeletePerm"),
                                   CResourceStore.GetString("CSinglePermissionSet:ConfirmDeletePermTitle"),
                                   MB.YESNO|MB.ICONQUESTION);
            if (nRes == MB.IDYES)
            {
                int iResultItem = (int)o - 1;

                m_psetWrapper.PSet.RemovePermission(m_alPermissions[iResultItem].GetType());
                m_psetWrapper.PolLevel.ChangeNamedPermissionSet(m_psetWrapper.PSet.Name, m_psetWrapper.PSet);

                // Remove this from our list of permissions
                m_alPermissions.RemoveAt(iResultItem);

                // Now we need to re-create our permissions array
                String[] newItems = new String[m_sItems.Length-1];
                int nIndex=0;
                for(int i=0; i<m_sItems.Length; i++)
                {
                    if (i != iResultItem)
                        newItems[nIndex++] = m_sItems[i];
                }
                
                m_sItems = newItems; 
                
                // Now, re-select this node to update our changes
                CNodeManager.Console.SelectScopeItem(HScopeItem);
                SecurityPolicyChanged();
                return HRESULT.S_OK;
            }
        }
        return HRESULT.S_FALSE;
    }// onDelete



    internal override int onRename(String sNewName)
    {
        // We should do some checking to see if this name exists elsewhere....
        if (Security.isPermissionSetNameUsed(m_pl, sNewName))
        {
            MessageBox(String.Format(CResourceStore.GetString("PermissionSetnameisbeingused"), sNewName),
                       CResourceStore.GetString("PermissionSetnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);

            return HRESULT.S_FALSE;
        }
        // Else, we're ok to make the name change
        m_psetWrapper.PSet.Name = sNewName;
       
        SecurityPolicyChanged();

        return HRESULT.S_OK;
    }// onRename

    internal override void Showing()
    {
        // See if we've read from the XML file yet whether we're supposed to
        // show the HTML file
        if (!m_fReadShowHTML)
        {
            // Now tell my taskpad that I'm ready....
            m_fShowHTMLPage = ((String)CConfigStore.GetSetting("ShowHTMLForPermissionSet")).Equals("yes");

            if (m_fShowHTMLPage)
                m_oResults=m_taskpad;
            else
                m_oResults=this;

            m_fReadShowHTML = true;
        }
    }// Showing

    internal override void SecurityPolicyChanged(bool fShowDialog)
    {

        // If the display name changed, then we need to apply the changes
        if (!m_sDisplayName.Equals(m_psetWrapper.PSet.Name))
        {
            // We need to rename this permission set.
            // To accomplish this, we need to remove the permission set and then add it back in
            m_psetWrapper.PolLevel.RemoveNamedPermissionSet(m_sDisplayName);
            m_psetWrapper.PolLevel.AddNamedPermissionSet(m_psetWrapper.PSet);
            m_sDisplayName = m_psetWrapper.PSet.Name;
            RefreshDisplayName();
        }
        else if (!m_fDeleted)
        {
            m_psetWrapper.PolLevel.ChangeNamedPermissionSet(m_psetWrapper.PSet.Name, m_psetWrapper.PSet);
            // And make sure we update all our codegroups to have this new permission set
            Security.UpdateAllCodegroups(m_psetWrapper.PolLevel, m_psetWrapper.PSet);
        }

        // Let's refresh the result view, in case some of our permissions change
        // from unrestricted to restricted

        // We can only refresh ourself if we didn't delete ourself
        if (!m_fDeleted)
            RefreshResultView();
        
        base.SecurityPolicyChanged(fShowDialog);
    }// SecurityPolicyChanged


    void GenerateGivenPermissionsStringList()
    {
        // Get the permissions
        m_alPermissions = new ArrayList();
        
        IEnumerator permEnumerator = m_psetWrapper.PSet.GetEnumerator();
        while (permEnumerator.MoveNext())
            m_alPermissions.Add(permEnumerator.Current);

        // Build the list of items we'll display in the result view
        m_sItems = new String[m_alPermissions.Count];
        for(int i=0; i<m_alPermissions.Count; i++)
            m_sItems[i] = Security.GetDisplayStringForPermission((IPermission)m_alPermissions[i]);

    }

    int GetPermissionIndex(IPermission perm)
    {
        if (perm is UIPermission)
            return 0;

        if (perm is SecurityPermission)
            return 1;
            
        if (perm is ReflectionPermission)
            return 2;
            
        if (perm is IsolatedStoragePermission)
            return 3;
            
        if (perm is DnsPermission)
            return 4;
            
        if (perm is EnvironmentPermission)
            return 5;
            
        if (perm is FileIOPermission)
            return 6;
            
        if (perm is RegistryPermission)
            return 7;

        if (perm is SocketPermission)
            return 8;

        if (perm is WebPermission)
            return 9;
            
        if (perm is DirectoryServicesPermission)
            return 10;
            
        if (perm is EventLogPermission)
            return 11;
            
        if (perm is FileDialogPermission)
            return 12;

        if (perm is PerformanceCounterPermission)
            return 13;

        if (perm is PrintingPermission)
            return 14;

        if (perm is ServiceControllerPermission)
            return 15;

        if (perm is SqlClientPermission)
            return 16;

        if (perm is OleDbPermission)
            return 17;

        if (perm is MessageQueuePermission)
            return 18;
            
        // We don't know about this permission... let's display it as a custom permission
        return CUSTOM;

    }// GetPermissionIndex
    

         
    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {  
        // See if we're allowed to insert an item in the "view" section
        if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_VIEW) > 0 && oResultItem == null)
        {
            CONTEXTMENUITEM newitem;
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If we're showing the taskpad right now
            if (m_oResults != this)
            {
                newitem.strName = CResourceStore.GetString("CSinglePermissionSet:ViewPermissionsOption");
                newitem.strStatusBarText = CResourceStore.GetString("CSinglePermissionSet:ViewPermissionsOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_LISTVIEW;
            }

            // Currently, we're showing the list view
            else
            {
                newitem.strName = CResourceStore.GetString("CSinglePermissionSet:ViewHTMLOption");
                newitem.strStatusBarText = CResourceStore.GetString("CSinglePermissionSet:ViewHTMLOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_TASKPAD;
            }
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
        }


        // See if we can insert on the top
        if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {

            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            // Stuff common to the top menu
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If they are right clicking on the node item
            if (oResultItem == null)
            {

                if (!ReadOnly)
                {
                    newitem.strName = CResourceStore.GetString("CSinglePermissionSet:AddPermOption");
                    newitem.strStatusBarText = CResourceStore.GetString("CSinglePermissionSet:AddPermOptionDes");
                    newitem.lCommandID = COMMANDS.ADD_PERMISSIONS;
            
                    // Now add this item through the callback
                    piCallback.AddItem(ref newitem);
                }
                // We only care if the policy level is read only in this case... if the
                // permission set is read only, we still want to display this menu option
                if (!base.ReadOnly)
                {
                    newitem.strName = CResourceStore.GetString("CSinglePermissionSet:DuplicateOption");
                    newitem.strStatusBarText = CResourceStore.GetString("CSinglePermissionSet:DuplicateOptionDes");
                    newitem.lCommandID = COMMANDS.DUPLICATE_PERMISSIONSET;
            
                    // Now add this item through the callback
                    piCallback.AddItem(ref newitem);
                }
            }
            // They right-clicked on one of the permissions shown in the result view
            else
            {
                // If this is a read-only permission set, then provide an option to view the current permission
                if (ReadOnly)
                {
                    newitem.strName = CResourceStore.GetString("CSinglePermissionSet:ViewPermOption");
                    newitem.strStatusBarText = CResourceStore.GetString("CSinglePermissionSet:ViewPermOptionDes");
                    newitem.lCommandID = COMMANDS.VIEW_PERMISSION;
            
                    // Now add this item through the callback
                    piCallback.AddItem(ref newitem);
                }
            }
            
        }
    }// AddMenuItems

    internal override void MenuCommand(int nCommandID, Object oResultItem)
    {
    
        if (nCommandID == COMMANDS.DUPLICATE_PERMISSIONSET)
        {
            NamedPermissionSet nps = (NamedPermissionSet)m_psetWrapper.PSet.Copy();

            String sBaseName = nps.Name;
         
            nps.Name = String.Format(CResourceStore.GetString("CSinglePermissionSet:PrependtoDupPSets"), nps.Name);
            int nCounter = 1;
            // make sure it's not already used
            while(Security.isPermissionSetNameUsed(m_pl, nps.Name))
            {   
                nCounter++;
                nps.Name = String.Format(CResourceStore.GetString("CSinglePermissionSet:NumPrependtoDupPSets"), nCounter.ToString(), sBaseName);
            }

            
            CNode node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
            CSinglePermissionSet newNode = ((CPermissionSet)node).AddPermissionSet(nps);
            newNode.SecurityPolicyChanged();
            // Put the selection on the new permission set we just created
            CNodeManager.SelectScopeItem(newNode.HScopeItem);
         }

        else if (nCommandID == COMMANDS.VIEW_PERMISSION)
        {
            int iResultItem = (int)oResultItem - 1;
            // Pop up the Dialog Box for this permission
            (new CReadOnlyPermission((IPermission)m_alPermissions[iResultItem])).ShowDialog();
        }

        else if (nCommandID == COMMANDS.ADD_PERMISSIONS)
        {
            CAddPermissionsWizard wiz = new CAddPermissionsWizard(m_psetWrapper);
            wiz.LaunchWizard(Cookie);
            if (wiz.didFinish)
            {
                SecurityPolicyChanged();
                GenerateGivenPermissionsStringList();
                CNodeManager.Console.SelectScopeItem(HScopeItem);
            }    
        }
        else if (nCommandID == COMMANDS.SHOW_LISTVIEW)
        {
            m_oResults=this;
            RefreshResultView();
            m_fShowHTMLPage = false;
        }

        else if (nCommandID == COMMANDS.SHOW_TASKPAD)
        {
            m_oResults=m_taskpad;
            m_fShowHTMLPage = true;
            // The HTML pages comes displayed with this checkbox marked. Make
            // sure we update the xml setting
            CConfigStore.SetSetting("ShowHTMLForPermissionSet", "yes");
            RefreshResultView();
        }


    }// MenuCommand


    internal override int onDoubleClick(Object o)
    {
        if (o != null)
        {
            // If it's a read-only permission set, show the permission dialog
            if (ReadOnly)
            {
                MenuCommand(COMMANDS.VIEW_PERMISSION, o);
            }
            else // Bring up the property page
            {
                int iResultItem = (int)o;
                CDO cdo = new CDO(this);
                cdo.Data = iResultItem;

                OpenMyResultPropertyPage(getValues(iResultItem-1, 0), cdo);
            }
            return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// onDoubleClick



    private CodeGroup GetCGUsingPermissionSet(CodeGroup cg)
    {
        // See if we should even check this
        if (cg == null)
            return null;

        // See if this code group uses the permission set
        if (cg.PermissionSetName != null)
            if (cg.PermissionSetName.Equals(m_psetWrapper.PSet.Name))
                return cg;

        // Run through this code group's children and see if they use this
        // permission set
        
        IEnumerator enumCodeGroups = cg.Children.GetEnumerator();

        while (enumCodeGroups.MoveNext())
        {
            cg = (CodeGroup)enumCodeGroups.Current;
            CodeGroup cgUsing = GetCGUsingPermissionSet(cg);
            if (cgUsing != null)
                return cgUsing;
        }

        // Nobody here is using this permission set
        return null;
    }// GetCGUsingPermissionSet
    //-------------------------------------------------
    // Methods to implement the IColumnResultView interface
    //-------------------------------------------------
    public override int getNumColumns()
    {
        // We will always have 1 columns in the result view
        return 1;
    }// getNumColumns
    public override int getNumRows()
    {
        return m_sItems.Length;
    }// GetNumRows
    public override String getColumnTitles(int iIndex)
    {
        if (iIndex == 0)
            return CResourceStore.GetString("Permission");
        else
            throw new Exception("Index out of bounds");
    }// getColumnTitles

    public override String getValues(int nRow, int nColumn)
    {
         // Make sure the indicies they give us are valid
        if (nRow >=0 && nRow<getNumRows() && nColumn>=0 && nColumn<getNumColumns())
            return m_sItems[nRow];
        else
            return "";
    }// getValues
    
    public override void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hUnRestrictedIcon, m_iUnRestrictedIndex);
        il.ImageListSetIcon(m_hRestrictedIcon, m_iRestrictedIndex);
    }// AddImages
    public override int GetImageIndex(int i)
    {
        // Figure out if we have settings for this specific permission


        // A permission needs to implement the IUnrestrictedPermission interface if 
        // we want to be able to assign it a meaningful icon...
        
        if (m_psetWrapper.PSet.GetPermission(m_alPermissions[i].GetType()) is IUnrestrictedPermission)
        {
            IUnrestrictedPermission permission = (IUnrestrictedPermission)m_psetWrapper.PSet.GetPermission(m_alPermissions[i].GetType());
            // If we don't have this permission
            if (permission == null)
                return m_iRestrictedIndex;
            // If this is unrestricted....
            if (permission.IsUnrestricted())
                return m_iUnRestrictedIndex;

            // else, this has partial permissions....
            return m_iRestrictedIndex;
        }
        // Otherwise... we don't know. We'll just display the restricted permission icon
        return m_iRestrictedIndex;
    }// GetImageIndex

    public override bool DoesItemHavePropPage(Object o)
    {
        // Every item here has a property page if the permission set is not readonly
        return !ReadOnly;
    }// DoesItemHavePropPage

    public override CPropPage[] CreateNewPropPages(Object o)
    {
        int iIndex = (int)o;
    
        m_iDisplayedPerm = iIndex-1;
        int nPropPageIndex = GetPermissionIndex((IPermission)m_alPermissions[m_iDisplayedPerm]);


        if (nPropPageIndex == CUSTOM)
        {
            CPropPage page = FindCustomPropPage(iIndex-1);
            if (page == null)
            {
                page = new CCustomPermPropPage((IPermission)m_alPermissions[m_iDisplayedPerm]);
                AddCustomPropPage(page, iIndex-1);
            }
            return new CPropPage[] {page};
        }
        else
        {
            if (m_permProps == null)
                CreatePropertyPages();
                
            return new CPropPage[] {m_permProps[nPropPageIndex]};
        }
    }// ApplyPropPages


    private void AddCustomPropPage(CPropPage page, int nIndex)
    {
        CustomPages cp = new CustomPages();
        cp.nIndex = nIndex;
        cp.ppage = page;
        m_alCustomPropPages.Add(cp);
    }// AddCustomPropPage

    private CPropPage FindCustomPropPage(int nIndex)
    {
        for(int i=0; i<m_alCustomPropPages.Count; i++)
            if (((CustomPages)m_alCustomPropPages[i]).nIndex == nIndex)
                return ((CustomPages)m_alCustomPropPages[i]).ppage;

        return null;
    }// FindCustomPropPage

    protected override void CloseAllMyPropertyPages()
    {
        base.CloseAllMyPropertyPages();

        // Close all the result pages
        if (m_permProps != null)
            for(int i=0; i<m_permProps.Length; i++)
                m_permProps[i].CloseSheet();

        if (m_alCustomPropPages != null)
            for(int i=0; i<m_alCustomPropPages.Count; i++)
                ((CustomPages)m_alCustomPropPages[i]).ppage.CloseSheet();        
    }// CloseAllMyPropertyPages
    
}// class CSinglePermissionSet
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz1.cs
//
// This class provides the Wizard page that allows the user to
// choose between making changes for the machine or for the user
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;

internal class CTrustAppWiz1 : CWizardPage
{
    // Controls on the page
    Label m_lblHomeUserDes;
    Label m_lblChooseType;
    RadioButton m_radHomeUser;
    LinkLabel m_lblHomeUserHelp;
    RadioButton m_radCorpUser;
    LinkLabel m_lblCorpUserHelp;
    Label m_lblCorpUserDes;               	


    bool m_fMachineReadOnly;
    bool m_fUserReadOnly;
    
    internal CTrustAppWiz1(bool fMachineReadOnly, bool fUserReadOnly)
    {
        m_fMachineReadOnly = fMachineReadOnly;
        m_fUserReadOnly = fUserReadOnly;
        
        m_sTitle=CResourceStore.GetString("CTrustAppWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz1:HeaderSubTitle");
    }// CTrustAppWiz1

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz1));
        this.m_radCorpUser = new System.Windows.Forms.RadioButton();
        this.m_lblHomeUserDes = new System.Windows.Forms.Label();
        this.m_lblCorpUserHelp = new System.Windows.Forms.LinkLabel();
        this.m_lblChooseType = new System.Windows.Forms.Label();
        this.m_radHomeUser = new System.Windows.Forms.RadioButton();
        this.m_lblCorpUserDes = new System.Windows.Forms.Label();
        this.m_lblHomeUserHelp = new System.Windows.Forms.LinkLabel();
        this.m_radCorpUser.Location = ((System.Drawing.Point)(resources.GetObject("m_radCorpUser.Location")));
        this.m_radCorpUser.Size = ((System.Drawing.Size)(resources.GetObject("m_radCorpUser.Size")));
        this.m_radCorpUser.TabStop = true;
        this.m_radCorpUser.Text = resources.GetString("m_radCorpUser.Text");
        m_radCorpUser.Name = "User";
        this.m_lblHomeUserDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHomeUserDes.Location")));
        this.m_lblHomeUserDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHomeUserDes.Size")));
        this.m_lblHomeUserDes.TabIndex = ((int)(resources.GetObject("m_lblHomeUserDes.TabIndex")));
        this.m_lblHomeUserDes.Text = resources.GetString("m_lblHomeUserDes.Text");
        m_lblHomeUserDes.Name = "MachineDescription";
        this.m_lblCorpUserHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCorpUserHelp.Location")));
        this.m_lblCorpUserHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCorpUserHelp.Size")));
        this.m_lblCorpUserHelp.TabIndex = ((int)(resources.GetObject("m_lblCorpUserHelp.TabIndex")));
        this.m_lblCorpUserHelp.Text = resources.GetString("m_lblCorpUserHelp.Text");
        m_lblCorpUserHelp.Name = "UserHelp";
        // Change the color of the linklabel
        m_lblCorpUserHelp.LinkColor = m_lblCorpUserHelp.ActiveLinkColor = m_lblCorpUserHelp.VisitedLinkColor = SystemColors.ActiveCaption;
        this.m_lblChooseType.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseType.Location")));
        this.m_lblChooseType.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseType.Size")));
        this.m_lblChooseType.TabIndex = ((int)(resources.GetObject("m_lblChooseType.TabIndex")));
        this.m_lblChooseType.Text = resources.GetString("m_lblChooseType.Text");
        m_lblChooseType.Name = "ChooseType";
        this.m_radHomeUser.Location = ((System.Drawing.Point)(resources.GetObject("m_radHomeUser.Location")));
        this.m_radHomeUser.Size = ((System.Drawing.Size)(resources.GetObject("m_radHomeUser.Size")));
        this.m_radHomeUser.TabStop = true;
        this.m_radHomeUser.Text = resources.GetString("m_radHomeUser.Text");
        m_radHomeUser.Name = "Machine";
        this.m_lblCorpUserDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCorpUserDes.Location")));
        this.m_lblCorpUserDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCorpUserDes.Size")));
        this.m_lblCorpUserDes.TabIndex = ((int)(resources.GetObject("m_lblCorpUserDes.TabIndex")));
        this.m_lblCorpUserDes.Text = resources.GetString("m_lblCorpUserDes.Text");
        m_lblCorpUserDes.Name = "UserDescription";
        this.m_lblHomeUserHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHomeUserHelp.Location")));
        this.m_lblHomeUserHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHomeUserHelp.Size")));
        this.m_lblHomeUserHelp.TabIndex = ((int)(resources.GetObject("m_lblHomeUserHelp.TabIndex")));
        this.m_lblHomeUserHelp.Text = resources.GetString("m_lblHomeUserHelp.Text");
        m_lblHomeUserHelp.Name = "MachineHelp";
        // Change the color of the linklabel
        m_lblHomeUserHelp.LinkColor = m_lblHomeUserHelp.ActiveLinkColor = m_lblHomeUserHelp.VisitedLinkColor = SystemColors.ActiveCaption;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblCorpUserHelp,
                        this.m_lblCorpUserDes,
                        this.m_radHomeUser,
                        this.m_radCorpUser,
                        this.m_lblHomeUserHelp,
                        this.m_lblHomeUserDes,
                        this.m_lblChooseType});
        // Put in some of our own tweaks now
        m_radHomeUser.Checked = true;
        m_lblHomeUserHelp.Click+=new EventHandler(onHomeUserHelp);
        m_lblCorpUserHelp.Click+=new EventHandler(onCorpUserHelp);

        // Turn off the radio buttons the user can't select
        m_radHomeUser.Enabled = !m_fMachineReadOnly;
        m_radCorpUser.Enabled = !m_fUserReadOnly;

        if (m_fMachineReadOnly)
            m_radCorpUser.Checked = true;
            
        return 1;
    }// InsertPropSheetPageControls

    internal bool isForHomeUser
    {
        get{return m_radHomeUser.Checked;}
    }// isForHomeUser

    void onHomeUserHelp(Object o, EventArgs e)
    {
        CHelpDialog hd = new CHelpDialog(CResourceStore.GetString("CTrustAppWiz1:HomeUserHelp"),
                                         new Point(m_lblHomeUserHelp.Location.X + this.Location.X,
                                         		   m_lblHomeUserHelp.Location.Y + this.Location.Y));
        hd.Show();                                         
    }// onHomeUserHelp

    void onCorpUserHelp(Object o, EventArgs e)
    {
        CHelpDialog hd = new CHelpDialog(CResourceStore.GetString("CTrustAppWiz1:CorpUserHelp"),
                                         new Point(m_lblCorpUserHelp.Location.X + this.Location.X,
                                         		   m_lblCorpUserHelp.Location.Y + this.Location.Y));
        hd.Show();                                         

    }// onCorpUserHelp

}// class CTrustAppWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglepermsettaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security;

class CSinglePermSetTaskPad : CTaskPad
{
    private bool                m_fReadOnly;
    private NamedPermissionSet  m_ps;

    internal CSinglePermSetTaskPad(CSinglePermissionSet n) : base(n)
    {
        m_ps = n.PSet;
        m_fReadOnly = n.ReadOnly;
    }// CSinglePermSetTaskPad

     protected override String GetHTMLFilename()
    {
        if (m_ps.IsUnrestricted())
            return "FULLTRUST_HTML";
        else
            return "SINGLEPERMISSIONSET_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[4];
        args[0] = m_ps.Name;
        args[1] = m_ps.Description;
        if (m_fReadOnly)
        {
            args[2] = "<!--";
            args[3] = "-->";
        }

       
        return GetHTMLFile(args);    
    }// GetHTMLFile
}// class CSinglePermSetTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

abstract class CTaskPad
{
    String m_sHTMLName;
    protected CNode  m_myNode;

    internal CTaskPad(CNode node)
    {
        m_myNode = node;
        m_sHTMLName = null;
    }// CTaskPad

    internal bool HaveGroup(String sGroup)
    {  
        if (sGroup.Equals(m_myNode.DisplayName + m_sHTMLName))
            return true;
        return false;
    }// HaveGroup
    
    internal virtual void Notify(Object arg, Object param, IConsole2 con, CData com)
    {
        throw new Exception("I don't support his notification");
    }// Notify

    internal String GetTitle()
    {
        return CResourceStore.GetString(".NET Configuration");
    }// GetTitle
    internal String GetDescription()
    {
        return CResourceStore.GetString(".NET Configuration");
    }
    internal MMC_TASK_DISPLAY_OBJECT GetBackground()
    {
        return new MMC_TASK_DISPLAY_OBJECT();
    }// GetBackground
    internal MMC_LISTPAD_INFO GetListPadInfo()
    {
        return new MMC_LISTPAD_INFO();
    }// GetListPadInfo

    protected abstract String GetHTMLFilename();

    internal virtual String GetHTMLFile()
    {
        return GetHTMLFile(null);
    }// GetHTMLFile

    
    internal String GetHTMLFile(String[] args)
    {
        if (m_sHTMLName == null)
            m_sHTMLName = GetHTMLFilename();

          return CHTMLFileGen.GenHTMLFile(m_sHTMLName, args);
    }// GetHTMLFile
}// class CGenAppTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz2.cs
//
// This class provides the Wizard page that allows the user to
// choose the assembly they want to trust
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;

internal class CTrustAppWiz2 : CWizardPage
{
    // Controls on the page
    TextBox m_txtFilename;
    Button m_btnBrowse;
    Label m_lblEnterPath;

    internal CTrustAppWiz2()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz2:HeaderSubTitle");
    }// CTrustAppWiz2

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz2));
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_lblEnterPath = new System.Windows.Forms.Label();
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        m_txtFilename.Name = "Filename";
        
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_lblEnterPath.Location = ((System.Drawing.Point)(resources.GetObject("m_lblEnterPath.Location")));
        this.m_lblEnterPath.Size = ((System.Drawing.Size)(resources.GetObject("m_lblEnterPath.Size")));
        this.m_lblEnterPath.TabIndex = ((int)(resources.GetObject("m_lblEnterPath.TabIndex")));
        this.m_lblEnterPath.Text = resources.GetString("m_lblEnterPath.Text");
        m_lblEnterPath.Name = "Help";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblEnterPath,
                        this.m_txtFilename,
                        this.m_btnBrowse
                        });

        // Put in some of our own tweaks now
        m_btnBrowse.Click+= new EventHandler(onBrowse);
        m_txtFilename.TextChanged += new EventHandler(onTextChange);
        return 1;
    }// InsertPropSheetPageControls

    internal String Filename
    {
        get{return m_txtFilename.Text;}
    }// isForHomeUser

    void onTextChange(Object o, EventArgs e)
    {
        CFullTrustWizard wiz = (CFullTrustWizard)CNodeManager.GetNode(m_iCookie);
        // The assembly we were looking at changed.
        wiz.WipeEvidence();
        if (m_txtFilename.Text.Length > 0)
        {
            wiz.TurnOnNext(true);
        }
        else
            wiz.TurnOnNext(false);
        
    }// onTextChange

    void onBrowse(Object o, EventArgs e)
    {
        // Pop up a file dialog so the user can find an assembly
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("CTrustAppWiz2:ChooseAssemFDTitle");
        fd.Filter = CResourceStore.GetString("AssemFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            if (Fusion.isManaged(fd.FileName))
            {
                m_txtFilename.Text = fd.FileName;
                // Inform our wizard that we have a new assembly for it to try and load
                CFullTrustWizard wiz = (CFullTrustWizard)CNodeManager.GetNode(m_iCookie);
                wiz.NewAssembly();

            }
            else
                MessageBox(CResourceStore.GetString("isNotManagedCode"), 
                           CResourceStore.GetString("isNotManagedCodeTitle"),
                           MB.ICONEXCLAMATION);
        }
    }// onBrowse


}// class CTrustAppWiz2
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctablepermcontrols.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Data;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Security;

internal class CTablePermControls : CPermControls
{
    // Controls on the page
    protected Button m_btnDeleteRow;
    protected MyDataGrid          m_dg;
    protected DataTable           m_dt;
    private   DataSet             m_ds;

    // Internal data
    private int                   m_nColumn1Width;

    internal CTablePermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        m_nColumn1Width = 0;
    }// CTablePermControls

    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTablePermControls));
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_btnDeleteRow = new System.Windows.Forms.Button();
        this.m_dg = new MyDataGrid();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_btnDeleteRow.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDeleteRow.Location")));
        this.m_btnDeleteRow.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDeleteRow.Size")));
        this.m_btnDeleteRow.TabIndex = ((int)(resources.GetObject("m_btnDeleteRow.TabIndex")));
        this.m_btnDeleteRow.Text = resources.GetString("m_btnDeleteRow.Text");
        m_btnDeleteRow.Name = "DeleteRow";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_dg,
                        this.m_btnDeleteRow
                        });
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantFollowingPermission.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantFollowingPermission.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantFollowingPermission.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantFollowingPermission.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted
                        });

        m_dt = CreateDataTable(m_dg);
        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dg.DataSource = m_dt;
        m_dg.BackgroundColor = Color.White;

    
        // Set up the GUI-type stuff for the data grid
        m_dg.CaptionVisible=false;
               
        // Fill in the data
        PutValuesinPage();

        // Set up any callbacks
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_dg.TheVertScrollBar.VisibleChanged += new EventHandler(onVisibleChange);
        m_dg.CurrentCellChanged+=new EventHandler(onChange);        
        m_btnDeleteRow.Click += new EventHandler(onDeleteEntireRow);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_dg.CurrentCellChanged += new EventHandler(onCellChange);

        // Get the datagrid to be the color we want
        onChangeUnRestrict(null, null);
        // Get the delete entry button set to the correct state
        onCellChange(null, null);
        return 1;
    }// InsertPropSheetPageControls

    
    protected virtual DataTable CreateDataTable(DataGrid dg)
    {
        return null;
    }// CreateDataTable

    protected override void onChangeUnRestrict(Object o, EventArgs e)
    {
        base.onChangeUnRestrict(o, e);

        // We'll make the datagrid look enabled or disabled
        if (m_ucOptions.Enabled)
            m_dg.BackgroundColor = Color.White;
        else
            m_dg.BackgroundColor = Color.Gray;

        ActivateApply();
    }// onChangeUnRestrict

    protected virtual void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onClick

    void onDeleteEntireRow(Object o, EventArgs e)
    {
        if (m_dg.CurrentRowIndex != -1)
        {
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
            {
                // Try moving to a different cell to 'submit' this data
                int nOldRow = m_dg.CurrentRowIndex;
                m_dg.CurrentCell = new DataGridCell(0, 0);
                // And now move back to the original row                
                m_dg.CurrentCell = new DataGridCell(nOldRow, 0);
            }
            // They're trying to delete a non-existant row
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
                return;

            int nRet = MessageBox(CResourceStore.GetString("ConfirmDeleteEntry"), 
                                  CResourceStore.GetString("ConfirmDeleteEntryTitle"),
                                  MB.ICONQUESTION|MB.YESNO);

            if (nRet == MB.IDYES)
            {
                int nRowToDelete = m_dg.CurrentRowIndex;
                int nRowToMoveTo = 0;

                if (nRowToDelete == 0)
                    nRowToMoveTo=1;

                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo,0);
                m_dt.Rows.Remove(m_dt.Rows[nRowToDelete]);

                // See if we need to add more rows again....
        
                // We want at least 1 row so it looks pretty
                while(m_dt.Rows.Count < 1)
                    AddEmptyRow(m_dt);
                
                if (nRowToDelete >= m_dt.Rows.Count)
                    nRowToMoveTo = nRowToDelete-1;
                else
                    nRowToMoveTo = nRowToDelete;

                // End up with the cursor on the point right after the delete item    
                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo,0);
                ActivateApply();
            }
        }
    }// onDeleteEntireRow

    protected virtual void AddEmptyRow(DataTable dt)
    {
    }// AddEmptyRow

    internal void onVisibleChange(Object o, EventArgs e)
    {
    
        // Grab the original width of this column
        if (m_nColumn1Width == 0)
            m_nColumn1Width = m_dg.TableStyles[0].GridColumnStyles[0].Width;
    
        // If the scrollbar is visible, then reduce the first column by 13 pixels
        if (m_dg.TheVertScrollBar.Visible)
        {       
            m_dg.TableStyles[0].GridColumnStyles[0].Width = m_nColumn1Width - m_dg.TheVertScrollBar.Width;
            m_dg.Refresh();
        }   
        else
        {
            m_dg.TableStyles[0].GridColumnStyles[0].Width = m_nColumn1Width;
            m_dg.Refresh();
        }

    }// onVisibleChange

    void onCellChange(Object o, EventArgs e)
    {
        bool fEnable = false;
        
        if (m_dg.CurrentRowIndex != -1)
        {
            // See if we're on a valid row
            if (m_dg.CurrentRowIndex < m_dt.Rows.Count)
            {
                if (isThereValidColumns(m_dg.CurrentRowIndex))
                    fEnable = true;
            }
        }
        m_btnDeleteRow.Enabled = fEnable;
    }// onCellChange

    protected void onKeyPress(Object o, KeyPressEventArgs e)
    {
        ActivateApply();
    }// onKeyPress


    // Constants used to figure out if columns are valid
    
    private const int YES = 0;
    private const int NO = 1;
    private const int MAYBE = 2;

    private bool isValidRow(int nRowNum)
    {
        // Figure out how many rows we have
        int nNumColumns = m_dg.TableStyles[0].GridColumnStyles.Count;
        int nColumn = 0;
        bool fValid = true;
        // If any of these columns are invalid, return false
        while(fValid && nColumn < nNumColumns)
            fValid = isValidColumn(nRowNum, nColumn++)!=NO;
        
        return fValid;
    }// isValidRow
    
    private int isValidColumn(int nRowNum, int nColumnNum)
    {
        // We'll only validate DataGridTextBoxColumns and DataGridBoolColumns
        if (m_dg.TableStyles[0].GridColumnStyles[nColumnNum] is DataGridTextBoxColumn)
        {
            try
            {
                if ((m_dg[nRowNum, nColumnNum] is String) && ((String)m_dg[nRowNum, nColumnNum]).Length > 0)
                    return YES;
            }
            catch(Exception)
            {}
            return NO;            
         }
        else if (m_dg.TableStyles[0].GridColumnStyles[nColumnNum] is DataGridBoolColumn)
        {
                if ((bool)m_dg[nRowNum, nColumnNum])
                    return YES;
                // If it's not checked, then maybe it's ok... but it doesn't need to be deleted
                return MAYBE;
        }
        else // all other types are ok...
            return MAYBE;            
    }// isValidColumn

    private bool isThereValidColumns(int nRowNum)
    {
        // Figure out how many rows we have
        int nNumColumns = m_dg.TableStyles[0].GridColumnStyles.Count;
        int nColumn = 0;
        bool fValid = false;
        // If any of these columns are valid, return true
        while(!fValid && nColumn < nNumColumns)
            fValid = isValidColumn(nRowNum, nColumn++)==YES;
        
        return fValid;
    }// isThereValidColumns


    
}// class CRegPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz8.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz8.cs
//
// This class provides the Wizard page that allows the user to
// view the summary of what the wizard is going to do.
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

internal class CTrustAppWiz8 : CWizardPage
{
    // Controls on the page
    DataGrid m_dg;
    DataTable m_dt;
    DataSet m_ds;
    String[] m_sInfo;
    
    internal CTrustAppWiz8()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz8:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz8:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz8:HeaderSubTitle");
        m_sInfo = null;
    }// CTrustAppWiz8

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz8));
        this.m_dg = new System.Windows.Forms.DataGrid();
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.ReadOnly = true;
        this.m_dg.RowHeadersVisible = false;
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        m_dg.BackgroundColor = Color.White;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_dg});

        // Do some tweaking...
        m_dg.ReadOnly=true;
        m_dg.CaptionVisible=false;

        // Now tell our datagrid how to display its columns
        DataGridTableStyle dgts = new DataGridTableStyle();
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        m_dg.TableStyles.Add(dgts);

        String[] sColNames = new String[] {CResourceStore.GetString("CTrustAppWiz8:NameColumn"),
                                              CResourceStore.GetString("CTrustAppWiz8:ValueColumn")};

        int[] nColWidths = new int[]{
                                     ScaleWidth(CResourceStore.GetInt("CTrustAppWiz8:NameColumnWidth")),
                                     ScaleWidth(CResourceStore.GetInt("CTrustAppWiz8:ValueColumnWidth"))
                                    };


        

        for(int i=0; i< sColNames.Length; i++)
        {
            DataGridTextBoxColumn dgtbc = new DataGridTextBoxColumn();
         
            // Set up the column info for the Property column
            dgtbc.MappingName = sColNames[i];
            dgtbc.HeaderText = sColNames[i];
            dgtbc.ReadOnly = true;
            dgtbc.Width = nColWidths[i];
            dgts.GridColumnStyles.Add(dgtbc);
        }



        CreateTable();
     
        return 1;
    }// InsertPropSheetPageControls

    internal String[] TableInfo
    {
        set{
        m_sInfo = value;
        CreateTable();
        }
    }// TableInfo

    void CreateTable()
    {
        if (m_dg == null || m_sInfo == null)
            return;
            
        m_dt = new DataTable("Stuff");

        // Put the columns in our data table
        String[] sColNames = new String[] {CResourceStore.GetString("CTrustAppWiz8:NameColumn"),
                                              CResourceStore.GetString("CTrustAppWiz8:ValueColumn")};
                                            
        for(int i=0; i< sColNames.Length; i++)
        {
            DataColumn dc = new DataColumn();
            dc.ColumnName = sColNames[i];
            dc.DataType = typeof(String);
            m_dt.Columns.Add(dc);
        }

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);
        m_dg.DataSource = m_dt;


        // Now put the data into the datagrid
        DataRow newRow;
        for(int i=0; i<m_sInfo.Length; i+=2)
        {
            newRow = m_dt.NewRow();
            for(int j=0; j< 2; j++)
                newRow[j]=m_sInfo[i+j];

            m_dt.Rows.Add(newRow);
        }
    }// CreateTable


    
}// class CTrustAppWiz8
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz5.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz5.cs
//
// This class provides the Wizard page that allows the user to
// use a slider to determine what permission set to assign to 
// a specified assembly
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Security;
using System.Security.Policy;

internal class CTrustAppWiz5 : CWizardPage
{
    // Controls on the page

    Label m_lblDes;
    Label m_lblFT;
    TrackBar m_tbTrust;
    LinkLabel m_lblTrustHelp;
    Label m_lblTrustDes;
    GroupBox m_gbChooseTrust;
    Label m_lblNoT;

    String[] m_sSecLevelDescriptions;
    int      m_nTrustLevel;
    int      m_nMaxTrustLevel;

    internal CTrustAppWiz5()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz5:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz5:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz5:HeaderSubTitle");

        m_sSecLevelDescriptions = new String[] { 
                                                CResourceStore.GetString("TightSecurityDes"),
                                                CResourceStore.GetString("FairlyTightSecurityDes"),
                                                CResourceStore.GetString("FairlyLooseSecurityDes"),
                                                CResourceStore.GetString("LooseSecurityDes")
                                               };


    }// CTrustAppWiz5

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz5));
        this.m_lblDes = new System.Windows.Forms.Label();
        this.m_lblFT = new System.Windows.Forms.Label();
        this.m_tbTrust = new System.Windows.Forms.TrackBar();
        this.m_lblTrustHelp = new System.Windows.Forms.LinkLabel();
        this.m_lblTrustDes = new System.Windows.Forms.Label();
        this.m_gbChooseTrust = new System.Windows.Forms.GroupBox();
        this.m_lblNoT = new System.Windows.Forms.Label();

        this.m_lblDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDes.Location")));
        this.m_lblDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDes.Size")));
        this.m_lblDes.TabIndex = ((int)(resources.GetObject("m_lblDes.TabIndex")));
        this.m_lblDes.Text = resources.GetString("m_lblDes.Text");
        m_lblDes.Name = "Description";
        this.m_lblFT.Location = ((System.Drawing.Point)(resources.GetObject("m_lblFT.Location")));
        this.m_lblFT.Size = ((System.Drawing.Size)(resources.GetObject("m_lblFT.Size")));
        this.m_lblFT.TabIndex = ((int)(resources.GetObject("m_lblFT.TabIndex")));
        this.m_lblFT.Text = resources.GetString("m_lblFT.Text");
        m_lblFT.Name = "FullTrustLabel";
        m_lblFT.TextAlign = ContentAlignment.MiddleCenter;
        this.m_tbTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_tbTrust.Location")));
        this.m_tbTrust.Maximum = 3;
        this.m_tbTrust.Orientation = System.Windows.Forms.Orientation.Vertical;
        this.m_tbTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_tbTrust.Size")));
        this.m_tbTrust.TabIndex = ((int)(resources.GetObject("m_tbTrust.TabIndex")));
        this.m_tbTrust.Value = 1;
        this.m_tbTrust.LargeChange = 1;
        m_tbTrust.Name = "TrustBar";
        this.m_lblTrustHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblTrustHelp.Location")));
        this.m_lblTrustHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblTrustHelp.Size")));
        this.m_lblTrustHelp.TabIndex = ((int)(resources.GetObject("m_lblTrustHelp.TabIndex")));
        this.m_lblTrustHelp.Text = resources.GetString("m_lblTrustHelp.Text");
        m_lblTrustHelp.Name = "TrustHelp";
        // Change the color of the linklabel
        m_lblTrustHelp.LinkColor = m_lblTrustHelp.ActiveLinkColor = m_lblTrustHelp.VisitedLinkColor = SystemColors.ActiveCaption;
        // And we're not actually going to show this anymore
        m_lblTrustHelp.Visible = false;

        this.m_lblTrustDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblTrustDes.Location")));
        this.m_lblTrustDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblTrustDes.Size")));
        this.m_lblTrustDes.TabIndex = ((int)(resources.GetObject("m_lblTrustDes.TabIndex")));
        this.m_lblTrustDes.Text = resources.GetString("m_lblTrustDes.Text");
        m_lblTrustDes.Name = "TrustDescription";

        this.m_gbChooseTrust.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblNoT,
                        this.m_lblFT,
                        this.m_lblTrustHelp,
                        this.m_lblTrustDes,
                        this.m_tbTrust
                        });
        this.m_gbChooseTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_gbChooseTrust.Location")));
        this.m_gbChooseTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_gbChooseTrust.Size")));
        this.m_gbChooseTrust.TabIndex = ((int)(resources.GetObject("m_gbChooseTrust.TabIndex")));
        this.m_gbChooseTrust.TabStop = false;
        this.m_gbChooseTrust.Text = resources.GetString("m_gbChooseTrust.Text");
        m_gbChooseTrust.Name = "ChooseTrustBox";
        this.m_lblNoT.Location = ((System.Drawing.Point)(resources.GetObject("m_lblNoT.Location")));
        this.m_lblNoT.Size = ((System.Drawing.Size)(resources.GetObject("m_lblNoT.Size")));
        this.m_lblNoT.TabIndex = ((int)(resources.GetObject("m_lblNoT.TabIndex")));
        this.m_lblNoT.Text = resources.GetString("m_lblNoT.Text");
        m_lblNoT.Name = "NoTrustLabel";
        m_lblNoT.TextAlign = ContentAlignment.MiddleCenter;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_gbChooseTrust,
                        this.m_lblDes});
        // Put in some of our own tweaks now
		m_tbTrust.ValueChanged += new EventHandler(onLevelChange);
        m_lblTrustHelp.Click += new EventHandler(onTrustHelp);
        PutValuesInPage();
        return 1;
    }// InsertPropSheetPageControls

    internal void PutValuesInPage()
    {
        // See if we can do this yet...
        if (m_tbTrust == null)
            return;

        switch(m_nTrustLevel)
        {
            case PermissionSetType.FULLTRUST:
                m_tbTrust.Value = 3;
                break;
            case PermissionSetType.INTRANET:
                m_tbTrust.Value = 2;
                break;
            case PermissionSetType.INTERNET:
                m_tbTrust.Value = 1;
                break;
            case PermissionSetType.NONE:
                m_tbTrust.Value = 0;
                break;
        }
        // We need to limit the height of the trackbar
        switch(m_nMaxTrustLevel)
        {
            case PermissionSetType.FULLTRUST:
                m_tbTrust.Maximum = 3;
                m_lblFT.Text = CResourceStore.GetString("CSecurityAdjustmentWiz3:FullTrustName");
                break;
            case PermissionSetType.INTRANET:
                m_tbTrust.Maximum = 2;
                m_lblFT.Text = CResourceStore.GetString("CSecurityAdjustmentWiz3:LocalIntranetName");
                break;
            case PermissionSetType.INTERNET:
                m_tbTrust.Maximum = 1;
                m_lblFT.Text = CResourceStore.GetString("CSecurityAdjustmentWiz3:InternetName");
                break;
        }

        // Now put in the text description for the level
        onLevelChange(null, null);
        
    }// PutValuesInPage

    internal int MyTrustLevel
    {
        get{return m_nTrustLevel;}
        set{m_nTrustLevel = value;}
    }// MyTrustLevel   

    internal int MaxTrustLevel
    {
        get{return m_nMaxTrustLevel;}
        set{m_nMaxTrustLevel = value;}
    }

    void onLevelChange(Object o, EventArgs e)
    {
        m_lblTrustDes.Text = m_sSecLevelDescriptions[m_tbTrust.Value];
        
        switch(m_tbTrust.Value)
        {
            case 3:
                m_nTrustLevel = PermissionSetType.FULLTRUST;
                break;
            case 2:
                m_nTrustLevel = PermissionSetType.INTRANET;
                break;
            case 1:
                m_nTrustLevel = PermissionSetType.INTERNET;
                break;
            case 0:
                m_nTrustLevel = PermissionSetType.NONE;
                break;
        }
    }// onLevelChange

    void onTrustHelp(Object o, EventArgs e)
    {
        
        String sTitle="";
        String sBody="";
        switch(m_tbTrust.Value)
        {
            case 3:
                sTitle=CResourceStore.GetString("CTrustAppWiz5:FullTrustHelpTitle");
                sBody=CResourceStore.GetString("CTrustAppWiz5:FullTrustHelp");
                break;
            case 2:
                sTitle=CResourceStore.GetString("CTrustAppWiz5:IntranetHelpTitle");
                sBody=CResourceStore.GetString("CTrustAppWiz5:IntranetHelp");
                break;
            case 1:
                sTitle=CResourceStore.GetString("CTrustAppWiz5:InternetHelpTitle");
                sBody=CResourceStore.GetString("CTrustAppWiz5:InternetHelp");
                break;
            case 0:
                sTitle=CResourceStore.GetString("CTrustAppWiz5:NoneHelpTitle");
                sBody=CResourceStore.GetString("CTrustAppWiz5:NoneHelp");
                break;
        }

        
        
        CHelpDialog hd = new CHelpDialog(sBody,
                                         new Point(m_lblTrustHelp.Location.X + this.Location.X,
                                                   m_lblTrustHelp.Location.Y + this.Location.Y));

        hd.Show();                                         
    }// onTrustHelp

}// class CTrustAppWiz5
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz3.cs
//
// This class provides the Wizard page that allows the user to
// choose how they want to trust the assembly.
//
// This page is visited if the assembly has a publisher certificate
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Security.Policy;

internal class CTrustAppWiz3 : CWizardPage
{
    String m_sFilename;

    // Controls on the page
    Label m_lblSelectedAssem;
    TextBox m_txtSelectedAssem;
    Label m_lblHowToTrust;
    RadioButton m_radOneAssem;
    RadioButton m_radPublisher;
    Label m_lblPublisher;
    TextBox m_txtPublisher;
    RadioButton m_radStrongName;
    Label m_lblPublicKeyToken;
    TextBox m_txtPublicKeyToken;
    CheckBox m_chkVersion;
    TextBox m_txtVersion;
    LinkLabel m_llblHelp;
 
    X509Certificate m_x509 = null;
    StrongName      m_sn   = null;
    
    internal CTrustAppWiz3()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz3:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz3:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz3:HeaderSubTitle");
    }// CTrustAppWiz3

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz3));
        this.m_lblSelectedAssem = new System.Windows.Forms.Label();
        this.m_txtSelectedAssem = new System.Windows.Forms.TextBox();
        this.m_lblHowToTrust = new System.Windows.Forms.Label();
        this.m_radOneAssem = new System.Windows.Forms.RadioButton();
        this.m_radPublisher = new System.Windows.Forms.RadioButton();
        this.m_lblPublisher = new System.Windows.Forms.Label();
        this.m_txtPublisher = new System.Windows.Forms.TextBox();
        this.m_radStrongName = new System.Windows.Forms.RadioButton();
        this.m_lblPublicKeyToken = new System.Windows.Forms.Label();
        this.m_txtPublicKeyToken = new System.Windows.Forms.TextBox();
        this.m_chkVersion = new System.Windows.Forms.CheckBox();
        this.m_txtVersion = new System.Windows.Forms.TextBox();
        this.m_llblHelp = new System.Windows.Forms.LinkLabel();
        // 
        // m_lblSelectedAssem
        // 
        this.m_lblSelectedAssem.AccessibleDescription = ((string)(resources.GetObject("m_lblSelectedAssem.AccessibleDescription")));
        this.m_lblSelectedAssem.AccessibleName = ((string)(resources.GetObject("m_lblSelectedAssem.AccessibleName")));
        this.m_lblSelectedAssem.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblSelectedAssem.Anchor")));
        this.m_lblSelectedAssem.AutoSize = ((bool)(resources.GetObject("m_lblSelectedAssem.AutoSize")));
        this.m_lblSelectedAssem.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblSelectedAssem.Cursor")));
        this.m_lblSelectedAssem.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblSelectedAssem.Dock")));
        this.m_lblSelectedAssem.Enabled = ((bool)(resources.GetObject("m_lblSelectedAssem.Enabled")));
        this.m_lblSelectedAssem.Font = ((System.Drawing.Font)(resources.GetObject("m_lblSelectedAssem.Font")));
        this.m_lblSelectedAssem.Image = ((System.Drawing.Image)(resources.GetObject("m_lblSelectedAssem.Image")));
        this.m_lblSelectedAssem.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblSelectedAssem.ImageAlign")));
        this.m_lblSelectedAssem.ImageIndex = ((int)(resources.GetObject("m_lblSelectedAssem.ImageIndex")));
        this.m_lblSelectedAssem.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblSelectedAssem.ImeMode")));
        this.m_lblSelectedAssem.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSelectedAssem.Location")));
        this.m_lblSelectedAssem.Name = "SelectedAssemblyLabel";
        this.m_lblSelectedAssem.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblSelectedAssem.RightToLeft")));
        this.m_lblSelectedAssem.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSelectedAssem.Size")));
        this.m_lblSelectedAssem.Text = resources.GetString("m_lblSelectedAssem.Text");
        this.m_lblSelectedAssem.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblSelectedAssem.TextAlign")));
        this.m_lblSelectedAssem.Visible = ((bool)(resources.GetObject("m_lblSelectedAssem.Visible")));
        // 
        // m_txtSelectedAssem
        // 
        this.m_txtSelectedAssem.AccessibleDescription = ((string)(resources.GetObject("m_txtSelectedAssem.AccessibleDescription")));
        this.m_txtSelectedAssem.AccessibleName = ((string)(resources.GetObject("m_txtSelectedAssem.AccessibleName")));
        this.m_txtSelectedAssem.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_txtSelectedAssem.Anchor")));
        this.m_txtSelectedAssem.AutoSize = ((bool)(resources.GetObject("m_txtSelectedAssem.AutoSize")));
        this.m_txtSelectedAssem.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_txtSelectedAssem.BackgroundImage")));
        this.m_txtSelectedAssem.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_txtSelectedAssem.Cursor")));
        this.m_txtSelectedAssem.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_txtSelectedAssem.Dock")));
        this.m_txtSelectedAssem.Enabled = ((bool)(resources.GetObject("m_txtSelectedAssem.Enabled")));
        this.m_txtSelectedAssem.Font = ((System.Drawing.Font)(resources.GetObject("m_txtSelectedAssem.Font")));
        this.m_txtSelectedAssem.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_txtSelectedAssem.ImeMode")));
        this.m_txtSelectedAssem.Location = ((System.Drawing.Point)(resources.GetObject("m_txtSelectedAssem.Location")));
        this.m_txtSelectedAssem.MaxLength = ((int)(resources.GetObject("m_txtSelectedAssem.MaxLength")));
        this.m_txtSelectedAssem.Multiline = ((bool)(resources.GetObject("m_txtSelectedAssem.Multiline")));
        this.m_txtSelectedAssem.Name = "SelectedAssembly";
        this.m_txtSelectedAssem.PasswordChar = ((char)(resources.GetObject("m_txtSelectedAssem.PasswordChar")));
        this.m_txtSelectedAssem.ReadOnly = true;
        this.m_txtSelectedAssem.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_txtSelectedAssem.RightToLeft")));
        this.m_txtSelectedAssem.ScrollBars = ((System.Windows.Forms.ScrollBars)(resources.GetObject("m_txtSelectedAssem.ScrollBars")));
        this.m_txtSelectedAssem.Size = ((System.Drawing.Size)(resources.GetObject("m_txtSelectedAssem.Size")));
        this.m_txtSelectedAssem.TabStop = false;
        this.m_txtSelectedAssem.Text = resources.GetString("m_txtSelectedAssem.Text");
        this.m_txtSelectedAssem.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("m_txtSelectedAssem.TextAlign")));
        this.m_txtSelectedAssem.Visible = ((bool)(resources.GetObject("m_txtSelectedAssem.Visible")));
        this.m_txtSelectedAssem.WordWrap = ((bool)(resources.GetObject("m_txtSelectedAssem.WordWrap")));
        // 
        // m_lblHowToTrust
        // 
        this.m_lblHowToTrust.AccessibleDescription = ((string)(resources.GetObject("m_lblHowToTrust.AccessibleDescription")));
        this.m_lblHowToTrust.AccessibleName = ((string)(resources.GetObject("m_lblHowToTrust.AccessibleName")));
        this.m_lblHowToTrust.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblHowToTrust.Anchor")));
        this.m_lblHowToTrust.AutoSize = ((bool)(resources.GetObject("m_lblHowToTrust.AutoSize")));
        this.m_lblHowToTrust.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblHowToTrust.Cursor")));
        this.m_lblHowToTrust.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblHowToTrust.Dock")));
        this.m_lblHowToTrust.Enabled = ((bool)(resources.GetObject("m_lblHowToTrust.Enabled")));
        this.m_lblHowToTrust.Font = ((System.Drawing.Font)(resources.GetObject("m_lblHowToTrust.Font")));
        this.m_lblHowToTrust.Image = ((System.Drawing.Image)(resources.GetObject("m_lblHowToTrust.Image")));
        this.m_lblHowToTrust.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblHowToTrust.ImageAlign")));
        this.m_lblHowToTrust.ImageIndex = ((int)(resources.GetObject("m_lblHowToTrust.ImageIndex")));
        this.m_lblHowToTrust.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblHowToTrust.ImeMode")));
        this.m_lblHowToTrust.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHowToTrust.Location")));
        this.m_lblHowToTrust.Name = "HowToTrustLabel";
        this.m_lblHowToTrust.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblHowToTrust.RightToLeft")));
        this.m_lblHowToTrust.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHowToTrust.Size")));
        this.m_lblHowToTrust.Text = resources.GetString("m_lblHowToTrust.Text");
        this.m_lblHowToTrust.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblHowToTrust.TextAlign")));
        this.m_lblHowToTrust.Visible = ((bool)(resources.GetObject("m_lblHowToTrust.Visible")));
        // 
        // m_radOneAssem
        // 
        this.m_radOneAssem.AccessibleDescription = ((string)(resources.GetObject("m_radOneAssem.AccessibleDescription")));
        this.m_radOneAssem.AccessibleName = ((string)(resources.GetObject("m_radOneAssem.AccessibleName")));
        this.m_radOneAssem.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_radOneAssem.Anchor")));
        this.m_radOneAssem.Appearance = ((System.Windows.Forms.Appearance)(resources.GetObject("m_radOneAssem.Appearance")));
        this.m_radOneAssem.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_radOneAssem.BackgroundImage")));
        this.m_radOneAssem.CheckAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radOneAssem.CheckAlign")));
        this.m_radOneAssem.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_radOneAssem.Cursor")));
        this.m_radOneAssem.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_radOneAssem.Dock")));
        this.m_radOneAssem.Enabled = ((bool)(resources.GetObject("m_radOneAssem.Enabled")));
        this.m_radOneAssem.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_radOneAssem.FlatStyle")));
        this.m_radOneAssem.Font = ((System.Drawing.Font)(resources.GetObject("m_radOneAssem.Font")));
        this.m_radOneAssem.Image = ((System.Drawing.Image)(resources.GetObject("m_radOneAssem.Image")));
        this.m_radOneAssem.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radOneAssem.ImageAlign")));
        this.m_radOneAssem.ImageIndex = ((int)(resources.GetObject("m_radOneAssem.ImageIndex")));
        this.m_radOneAssem.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_radOneAssem.ImeMode")));
        this.m_radOneAssem.Location = ((System.Drawing.Point)(resources.GetObject("m_radOneAssem.Location")));
        this.m_radOneAssem.Name = "TrustThisOneAssembly";
        this.m_radOneAssem.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_radOneAssem.RightToLeft")));
        this.m_radOneAssem.Size = ((System.Drawing.Size)(resources.GetObject("m_radOneAssem.Size")));
        this.m_radOneAssem.Text = resources.GetString("m_radOneAssem.Text");
        this.m_radOneAssem.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radOneAssem.TextAlign")));
        this.m_radOneAssem.Visible = ((bool)(resources.GetObject("m_radOneAssem.Visible")));
        // 
        // m_radPublisher
        // 
        this.m_radPublisher.AccessibleDescription = ((string)(resources.GetObject("m_radPublisher.AccessibleDescription")));
        this.m_radPublisher.AccessibleName = ((string)(resources.GetObject("m_radPublisher.AccessibleName")));
        this.m_radPublisher.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_radPublisher.Anchor")));
        this.m_radPublisher.Appearance = ((System.Windows.Forms.Appearance)(resources.GetObject("m_radPublisher.Appearance")));
        this.m_radPublisher.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_radPublisher.BackgroundImage")));
        this.m_radPublisher.CheckAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radPublisher.CheckAlign")));
        this.m_radPublisher.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_radPublisher.Cursor")));
        this.m_radPublisher.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_radPublisher.Dock")));
        this.m_radPublisher.Enabled = ((bool)(resources.GetObject("m_radPublisher.Enabled")));
        this.m_radPublisher.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_radPublisher.FlatStyle")));
        this.m_radPublisher.Font = ((System.Drawing.Font)(resources.GetObject("m_radPublisher.Font")));
        this.m_radPublisher.Image = ((System.Drawing.Image)(resources.GetObject("m_radPublisher.Image")));
        this.m_radPublisher.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radPublisher.ImageAlign")));
        this.m_radPublisher.ImageIndex = ((int)(resources.GetObject("m_radPublisher.ImageIndex")));
        this.m_radPublisher.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_radPublisher.ImeMode")));
        this.m_radPublisher.Location = ((System.Drawing.Point)(resources.GetObject("m_radPublisher.Location")));
        this.m_radPublisher.Name = "TrustByPublisher";
        this.m_radPublisher.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_radPublisher.RightToLeft")));
        this.m_radPublisher.Size = ((System.Drawing.Size)(resources.GetObject("m_radPublisher.Size")));
        this.m_radPublisher.Text = resources.GetString("m_radPublisher.Text");
        this.m_radPublisher.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radPublisher.TextAlign")));
        this.m_radPublisher.Visible = ((bool)(resources.GetObject("m_radPublisher.Visible")));
        // 
        // m_lblPublisher
        // 
        this.m_lblPublisher.AccessibleDescription = ((string)(resources.GetObject("m_lblPublisher.AccessibleDescription")));
        this.m_lblPublisher.AccessibleName = ((string)(resources.GetObject("m_lblPublisher.AccessibleName")));
        this.m_lblPublisher.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblPublisher.Anchor")));
        this.m_lblPublisher.AutoSize = ((bool)(resources.GetObject("m_lblPublisher.AutoSize")));
        this.m_lblPublisher.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblPublisher.Cursor")));
        this.m_lblPublisher.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblPublisher.Dock")));
        this.m_lblPublisher.Enabled = ((bool)(resources.GetObject("m_lblPublisher.Enabled")));
        this.m_lblPublisher.Font = ((System.Drawing.Font)(resources.GetObject("m_lblPublisher.Font")));
        this.m_lblPublisher.Image = ((System.Drawing.Image)(resources.GetObject("m_lblPublisher.Image")));
        this.m_lblPublisher.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblPublisher.ImageAlign")));
        this.m_lblPublisher.ImageIndex = ((int)(resources.GetObject("m_lblPublisher.ImageIndex")));
        this.m_lblPublisher.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblPublisher.ImeMode")));
        this.m_lblPublisher.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublisher.Location")));
        this.m_lblPublisher.Name = "PublisherLabel";
        this.m_lblPublisher.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblPublisher.RightToLeft")));
        this.m_lblPublisher.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublisher.Size")));
        this.m_lblPublisher.Text = resources.GetString("m_lblPublisher.Text");
        this.m_lblPublisher.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblPublisher.TextAlign")));
        this.m_lblPublisher.Visible = ((bool)(resources.GetObject("m_lblPublisher.Visible")));
        // 
        // m_txtPublisher
        // 
        this.m_txtPublisher.AccessibleDescription = ((string)(resources.GetObject("m_txtPublisher.AccessibleDescription")));
        this.m_txtPublisher.AccessibleName = ((string)(resources.GetObject("m_txtPublisher.AccessibleName")));
        this.m_txtPublisher.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_txtPublisher.Anchor")));
        this.m_txtPublisher.AutoSize = ((bool)(resources.GetObject("m_txtPublisher.AutoSize")));
        this.m_txtPublisher.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_txtPublisher.BackgroundImage")));
        this.m_txtPublisher.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_txtPublisher.Cursor")));
        this.m_txtPublisher.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_txtPublisher.Dock")));
        this.m_txtPublisher.Enabled = ((bool)(resources.GetObject("m_txtPublisher.Enabled")));
        this.m_txtPublisher.Font = ((System.Drawing.Font)(resources.GetObject("m_txtPublisher.Font")));
        this.m_txtPublisher.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_txtPublisher.ImeMode")));
        this.m_txtPublisher.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublisher.Location")));
        this.m_txtPublisher.MaxLength = ((int)(resources.GetObject("m_txtPublisher.MaxLength")));
        this.m_txtPublisher.Multiline = ((bool)(resources.GetObject("m_txtPublisher.Multiline")));
        this.m_txtPublisher.Name = "Publisher";
        this.m_txtPublisher.PasswordChar = ((char)(resources.GetObject("m_txtPublisher.PasswordChar")));
        this.m_txtPublisher.ReadOnly = true;
        this.m_txtPublisher.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_txtPublisher.RightToLeft")));
        this.m_txtPublisher.ScrollBars = ((System.Windows.Forms.ScrollBars)(resources.GetObject("m_txtPublisher.ScrollBars")));
        this.m_txtPublisher.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublisher.Size")));
        this.m_txtPublisher.TabStop = false;
        this.m_txtPublisher.Text = resources.GetString("m_txtPublisher.Text");
        this.m_txtPublisher.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("m_txtPublisher.TextAlign")));
        this.m_txtPublisher.Visible = ((bool)(resources.GetObject("m_txtPublisher.Visible")));
        this.m_txtPublisher.WordWrap = ((bool)(resources.GetObject("m_txtPublisher.WordWrap")));
        // 
        // m_radStrongName
        // 
        this.m_radStrongName.AccessibleDescription = ((string)(resources.GetObject("m_radStrongName.AccessibleDescription")));
        this.m_radStrongName.AccessibleName = ((string)(resources.GetObject("m_radStrongName.AccessibleName")));
        this.m_radStrongName.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_radStrongName.Anchor")));
        this.m_radStrongName.Appearance = ((System.Windows.Forms.Appearance)(resources.GetObject("m_radStrongName.Appearance")));
        this.m_radStrongName.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_radStrongName.BackgroundImage")));
        this.m_radStrongName.CheckAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radStrongName.CheckAlign")));
        this.m_radStrongName.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_radStrongName.Cursor")));
        this.m_radStrongName.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_radStrongName.Dock")));
        this.m_radStrongName.Enabled = ((bool)(resources.GetObject("m_radStrongName.Enabled")));
        this.m_radStrongName.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_radStrongName.FlatStyle")));
        this.m_radStrongName.Font = ((System.Drawing.Font)(resources.GetObject("m_radStrongName.Font")));
        this.m_radStrongName.Image = ((System.Drawing.Image)(resources.GetObject("m_radStrongName.Image")));
        this.m_radStrongName.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radStrongName.ImageAlign")));
        this.m_radStrongName.ImageIndex = ((int)(resources.GetObject("m_radStrongName.ImageIndex")));
        this.m_radStrongName.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_radStrongName.ImeMode")));
        this.m_radStrongName.Location = ((System.Drawing.Point)(resources.GetObject("m_radStrongName.Location")));
        this.m_radStrongName.Name = "TrustByStrongName";
        this.m_radStrongName.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_radStrongName.RightToLeft")));
        this.m_radStrongName.Size = ((System.Drawing.Size)(resources.GetObject("m_radStrongName.Size")));
        this.m_radStrongName.Text = resources.GetString("m_radStrongName.Text");
        this.m_radStrongName.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_radStrongName.TextAlign")));
        this.m_radStrongName.Visible = ((bool)(resources.GetObject("m_radStrongName.Visible")));
        // 
        // m_lblPublicKeyToken
        // 
        this.m_lblPublicKeyToken.AccessibleDescription = ((string)(resources.GetObject("m_lblPublicKeyToken.AccessibleDescription")));
        this.m_lblPublicKeyToken.AccessibleName = ((string)(resources.GetObject("m_lblPublicKeyToken.AccessibleName")));
        this.m_lblPublicKeyToken.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblPublicKeyToken.Anchor")));
        this.m_lblPublicKeyToken.AutoSize = ((bool)(resources.GetObject("m_lblPublicKeyToken.AutoSize")));
        this.m_lblPublicKeyToken.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblPublicKeyToken.Cursor")));
        this.m_lblPublicKeyToken.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblPublicKeyToken.Dock")));
        this.m_lblPublicKeyToken.Enabled = ((bool)(resources.GetObject("m_lblPublicKeyToken.Enabled")));
        this.m_lblPublicKeyToken.Font = ((System.Drawing.Font)(resources.GetObject("m_lblPublicKeyToken.Font")));
        this.m_lblPublicKeyToken.Image = ((System.Drawing.Image)(resources.GetObject("m_lblPublicKeyToken.Image")));
        this.m_lblPublicKeyToken.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblPublicKeyToken.ImageAlign")));
        this.m_lblPublicKeyToken.ImageIndex = ((int)(resources.GetObject("m_lblPublicKeyToken.ImageIndex")));
        this.m_lblPublicKeyToken.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblPublicKeyToken.ImeMode")));
        this.m_lblPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublicKeyToken.Location")));
        this.m_lblPublicKeyToken.Name = "PublicKeyTokenLabel";
        this.m_lblPublicKeyToken.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblPublicKeyToken.RightToLeft")));
        this.m_lblPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublicKeyToken.Size")));
        this.m_lblPublicKeyToken.Text = resources.GetString("m_lblPublicKeyToken.Text");
        this.m_lblPublicKeyToken.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblPublicKeyToken.TextAlign")));
        this.m_lblPublicKeyToken.Visible = ((bool)(resources.GetObject("m_lblPublicKeyToken.Visible")));
        // 
        // m_txtPublicKeyToken
        // 
        this.m_txtPublicKeyToken.AccessibleDescription = ((string)(resources.GetObject("m_txtPublicKeyToken.AccessibleDescription")));
        this.m_txtPublicKeyToken.AccessibleName = ((string)(resources.GetObject("m_txtPublicKeyToken.AccessibleName")));
        this.m_txtPublicKeyToken.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_txtPublicKeyToken.Anchor")));
        this.m_txtPublicKeyToken.AutoSize = ((bool)(resources.GetObject("m_txtPublicKeyToken.AutoSize")));
        this.m_txtPublicKeyToken.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_txtPublicKeyToken.BackgroundImage")));
        this.m_txtPublicKeyToken.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_txtPublicKeyToken.Cursor")));
        this.m_txtPublicKeyToken.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_txtPublicKeyToken.Dock")));
        this.m_txtPublicKeyToken.Enabled = ((bool)(resources.GetObject("m_txtPublicKeyToken.Enabled")));
        this.m_txtPublicKeyToken.Font = ((System.Drawing.Font)(resources.GetObject("m_txtPublicKeyToken.Font")));
        this.m_txtPublicKeyToken.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_txtPublicKeyToken.ImeMode")));
        this.m_txtPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublicKeyToken.Location")));
        this.m_txtPublicKeyToken.MaxLength = ((int)(resources.GetObject("m_txtPublicKeyToken.MaxLength")));
        this.m_txtPublicKeyToken.Multiline = ((bool)(resources.GetObject("m_txtPublicKeyToken.Multiline")));
        this.m_txtPublicKeyToken.Name = "PublicKeyToken";
        this.m_txtPublicKeyToken.PasswordChar = ((char)(resources.GetObject("m_txtPublicKeyToken.PasswordChar")));
        this.m_txtPublicKeyToken.ReadOnly = true;
        this.m_txtPublicKeyToken.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_txtPublicKeyToken.RightToLeft")));
        this.m_txtPublicKeyToken.ScrollBars = ((System.Windows.Forms.ScrollBars)(resources.GetObject("m_txtPublicKeyToken.ScrollBars")));
        this.m_txtPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublicKeyToken.Size")));
        this.m_txtPublicKeyToken.TabStop = false;
        this.m_txtPublicKeyToken.Text = resources.GetString("m_txtPublicKeyToken.Text");
        this.m_txtPublicKeyToken.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("m_txtPublicKeyToken.TextAlign")));
        this.m_txtPublicKeyToken.Visible = ((bool)(resources.GetObject("m_txtPublicKeyToken.Visible")));
        this.m_txtPublicKeyToken.WordWrap = ((bool)(resources.GetObject("m_txtPublicKeyToken.WordWrap")));
        // 
        // m_chkVersion
        // 
        this.m_chkVersion.AccessibleDescription = ((string)(resources.GetObject("m_chkVersion.AccessibleDescription")));
        this.m_chkVersion.AccessibleName = ((string)(resources.GetObject("m_chkVersion.AccessibleName")));
        this.m_chkVersion.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_chkVersion.Anchor")));
        this.m_chkVersion.Appearance = ((System.Windows.Forms.Appearance)(resources.GetObject("m_chkVersion.Appearance")));
        this.m_chkVersion.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_chkVersion.BackgroundImage")));
        this.m_chkVersion.CheckAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_chkVersion.CheckAlign")));
        this.m_chkVersion.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_chkVersion.Cursor")));
        this.m_chkVersion.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_chkVersion.Dock")));
        this.m_chkVersion.Enabled = ((bool)(resources.GetObject("m_chkVersion.Enabled")));
        this.m_chkVersion.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_chkVersion.FlatStyle")));
        this.m_chkVersion.Font = ((System.Drawing.Font)(resources.GetObject("m_chkVersion.Font")));
        this.m_chkVersion.Image = ((System.Drawing.Image)(resources.GetObject("m_chkVersion.Image")));
        this.m_chkVersion.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_chkVersion.ImageAlign")));
        this.m_chkVersion.ImageIndex = ((int)(resources.GetObject("m_chkVersion.ImageIndex")));
        this.m_chkVersion.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_chkVersion.ImeMode")));
        this.m_chkVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_chkVersion.Location")));
        this.m_chkVersion.Name = "VersionCheckbox";
        this.m_chkVersion.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_chkVersion.RightToLeft")));
        this.m_chkVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_chkVersion.Size")));
        this.m_chkVersion.Text = resources.GetString("m_chkVersion.Text");
        this.m_chkVersion.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_chkVersion.TextAlign")));
        this.m_chkVersion.Visible = ((bool)(resources.GetObject("m_chkVersion.Visible")));
        // 
        // m_txtVersion
        // 
        this.m_txtVersion.AccessibleDescription = ((string)(resources.GetObject("m_txtVersion.AccessibleDescription")));
        this.m_txtVersion.AccessibleName = ((string)(resources.GetObject("m_txtVersion.AccessibleName")));
        this.m_txtVersion.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_txtVersion.Anchor")));
        this.m_txtVersion.AutoSize = ((bool)(resources.GetObject("m_txtVersion.AutoSize")));
        this.m_txtVersion.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_txtVersion.BackgroundImage")));
        this.m_txtVersion.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_txtVersion.Cursor")));
        this.m_txtVersion.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_txtVersion.Dock")));
        this.m_txtVersion.Enabled = ((bool)(resources.GetObject("m_txtVersion.Enabled")));
        this.m_txtVersion.Font = ((System.Drawing.Font)(resources.GetObject("m_txtVersion.Font")));
        this.m_txtVersion.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_txtVersion.ImeMode")));
        this.m_txtVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_txtVersion.Location")));
        this.m_txtVersion.MaxLength = ((int)(resources.GetObject("m_txtVersion.MaxLength")));
        this.m_txtVersion.Multiline = ((bool)(resources.GetObject("m_txtVersion.Multiline")));
        this.m_txtVersion.Name = "Version";
        this.m_txtVersion.PasswordChar = ((char)(resources.GetObject("m_txtVersion.PasswordChar")));
        this.m_txtVersion.ReadOnly = true;
        this.m_txtVersion.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_txtVersion.RightToLeft")));
        this.m_txtVersion.ScrollBars = ((System.Windows.Forms.ScrollBars)(resources.GetObject("m_txtVersion.ScrollBars")));
        this.m_txtVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_txtVersion.Size")));
        this.m_txtVersion.TabStop = false;
        this.m_txtVersion.Text = resources.GetString("m_txtVersion.Text");
        this.m_txtVersion.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("m_txtVersion.TextAlign")));
        this.m_txtVersion.Visible = ((bool)(resources.GetObject("m_txtVersion.Visible")));
        this.m_txtVersion.WordWrap = ((bool)(resources.GetObject("m_txtVersion.WordWrap")));
        // 
        // m_llblHelp
        // 
        this.m_llblHelp.AccessibleDescription = ((string)(resources.GetObject("m_llblHelp.AccessibleDescription")));
        this.m_llblHelp.AccessibleName = ((string)(resources.GetObject("m_llblHelp.AccessibleName")));
        this.m_llblHelp.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_llblHelp.Anchor")));
        this.m_llblHelp.AutoSize = ((bool)(resources.GetObject("m_llblHelp.AutoSize")));
        this.m_llblHelp.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_llblHelp.Cursor")));
        this.m_llblHelp.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_llblHelp.Dock")));
        this.m_llblHelp.Enabled = ((bool)(resources.GetObject("m_llblHelp.Enabled")));
        this.m_llblHelp.Font = ((System.Drawing.Font)(resources.GetObject("m_llblHelp.Font")));
        this.m_llblHelp.Image = ((System.Drawing.Image)(resources.GetObject("m_llblHelp.Image")));
        this.m_llblHelp.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_llblHelp.ImageAlign")));
        this.m_llblHelp.ImageIndex = ((int)(resources.GetObject("m_llblHelp.ImageIndex")));
        this.m_llblHelp.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_llblHelp.ImeMode")));
        this.m_llblHelp.LinkArea = ((System.Windows.Forms.LinkArea)(resources.GetObject("m_llblHelp.LinkArea")));
        this.m_llblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_llblHelp.Location")));
        this.m_llblHelp.Name = "Help";
        this.m_llblHelp.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_llblHelp.RightToLeft")));
        this.m_llblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_llblHelp.Size")));
        this.m_llblHelp.TabStop = true;
        this.m_llblHelp.Text = resources.GetString("m_llblHelp.Text");
        this.m_llblHelp.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_llblHelp.TextAlign")));
        this.m_llblHelp.Visible = ((bool)(resources.GetObject("m_llblHelp.Visible")));
        m_llblHelp.LinkColor = m_llblHelp.ActiveLinkColor = m_llblHelp.VisitedLinkColor = SystemColors.ActiveCaption;

        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radOneAssem,
                        this.m_radPublisher,
                        this.m_radStrongName,
                        this.m_chkVersion,
                        this.m_llblHelp,
                        this.m_txtVersion,
                        this.m_txtPublicKeyToken,
                        this.m_lblPublicKeyToken,
                        this.m_txtPublisher,
                        this.m_lblPublisher,
                        this.m_lblHowToTrust,
                        this.m_txtSelectedAssem,
                        this.m_lblSelectedAssem});
        
        m_radOneAssem.Click += new EventHandler(onRadioButtonChange);
        m_radPublisher.Click += new EventHandler(onRadioButtonChange);
        m_radStrongName.Click += new EventHandler(onRadioButtonChange);
        m_llblHelp.Click += new EventHandler(onHelpClick);

        // Put in some of our own tweaks now
        return 1;
    }// InsertPropSheetPageControls

    internal X509Certificate x509
    {
        set{m_x509 = value;}
        get{return m_x509;}
    }// x509

    internal StrongName sn
    {
        set{m_sn = value;}
        get{return sn;}
    }// sn

    void onHelpClick(Object o, EventArgs e)
    {
        CHelpDialog hd = new CHelpDialog(CResourceStore.GetString("CTrustAppWiz3:WhatIsDiff"),
                                         new Point(m_llblHelp.Location.X + this.Location.X,
                                                   m_llblHelp.Location.Y + this.Location.Y));

        hd.Show();                                         
    }// onHelpClick

    private void EnableOneAssem(bool fDoOption, bool fEnable)
    {   
        if (fDoOption)
            m_radOneAssem.Enabled = fEnable;
    }// EnableOneAssem

    private void EnablePublisher(bool fDoOption, bool fEnable)
    {   
        if (fDoOption)
            m_radPublisher.Enabled = fEnable;
        m_lblPublisher.Enabled = fEnable;
        m_txtPublisher.Enabled = fEnable;
    }// EnablePublisher

    private void EnableStrongName(bool fDoOption, bool fEnable)
    {
        if (fDoOption)
            m_radStrongName.Enabled = fEnable;
        m_chkVersion.Enabled = fEnable;
        m_txtVersion.Enabled = fEnable;
        m_txtPublicKeyToken.Enabled = fEnable;
        m_lblPublicKeyToken.Enabled = fEnable;
    }// EnableStrongName

    internal void PutValuesInPage()
    {
        // First, enable all the radio buttons
        EnableOneAssem(true, true);
        EnablePublisher(true, true);
        EnableStrongName(true, true);

        // Put in the assembly name
        m_txtSelectedAssem.Text = m_sFilename;


        // Start off just trusting one app
        m_radOneAssem.Checked = true;

        // Decide what radio buttons to disable
        
        // Check the strong name
        if (m_sn == null)
            EnableStrongName(true, false);
        else
        {
            // Put in the strong name info
            m_txtVersion.Text = m_sn.Version.ToString();
            m_chkVersion.Checked = true;
            m_txtPublicKeyToken.Text = m_sn.PublicKey.ToString();
        }
                
        // Check the publisher certificate
        if (m_x509 == null)
            EnablePublisher(true, false);
        else
        {
            // Put in the certifcate info
            m_txtPublisher.Text = m_x509.GetName();
        }
        onRadioButtonChange(null, null);
    }// PutValuesInPage

    void onRadioButtonChange(Object o, EventArgs e)
    {
        // See what controls to enable
        // Disable them all
        EnableOneAssem(false, false);
        EnablePublisher(false, false);
        EnableStrongName(false, false);

        if (m_radOneAssem.Checked)
            EnableOneAssem(false, true);
        else if (m_radPublisher.Checked)
            EnablePublisher(false, true);
        else
            EnableStrongName(false, true);
    }// onRadioButtonChange

    internal String Filename
    {
        get{return m_sFilename;}
        set{m_sFilename = value;}
    }// Filename

    internal int HowToTrust
    {
        get
        {
            // Figure out how we're going to trust this thing....
            if (m_radOneAssem.Checked)
            {
                // If we have a strong name, we'll trust by that
                if (m_sn != null)
                    return TrustBy.SNAME|TrustBy.SNAMEVER|TrustBy.SNAMENAME;
                // It has to be hash 
                else
                    return TrustBy.HASH;
            }

            else if (m_radPublisher.Checked)
                return TrustBy.PUBCERT;
            else    // They want to trust many apps by strong name
            {
                int nTrust = TrustBy.SNAME;
                if (m_chkVersion.Checked)
                    nTrust = nTrust|TrustBy.SNAMEVER;
                    
                return nTrust;
            }
        }
    }// HowToTrust


}// class CTrustAppWiz3
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz4.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz4.cs
//
// This class provides the Wizard page that allows the user to
// give an assembly full trust. It only consists of a checkbox
// to assign permissions.... no slider is presented
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Security;
using System.Security.Policy;

internal class CTrustAppWiz4 : CWizardPage
{
    // Controls on the page

    LinkLabel m_lblHelpFT;
    CheckBox m_chkGiveFull;
    Label m_lblDes;
    GroupBox m_gbIncreaseToFull;
    Label m_lblDesOfFT;

    internal CTrustAppWiz4()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz4:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz4:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz4:HeaderSubTitle");
    }// CTrustAppWiz4

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz4));
        this.m_lblHelpFT = new System.Windows.Forms.LinkLabel();
        this.m_chkGiveFull = new System.Windows.Forms.CheckBox();
        this.m_lblDes = new System.Windows.Forms.Label();
        this.m_gbIncreaseToFull = new System.Windows.Forms.GroupBox();
        this.m_lblDesOfFT = new System.Windows.Forms.Label();

        this.m_lblHelpFT.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelpFT.Location")));
        this.m_lblHelpFT.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelpFT.Size")));
        this.m_lblHelpFT.TabIndex = ((int)(resources.GetObject("m_lblHelpFT.TabIndex")));
        this.m_lblHelpFT.Text = resources.GetString("m_lblHelpFT.Text");
        m_lblHelpFT.Name = "FullTrustHelp";
        // Change the color of the linklabel
        m_lblHelpFT.LinkColor = m_lblHelpFT.ActiveLinkColor = m_lblHelpFT.VisitedLinkColor = SystemColors.ActiveCaption;
        this.m_chkGiveFull.Location = ((System.Drawing.Point)(resources.GetObject("m_chkGiveFull.Location")));
        this.m_chkGiveFull.Size = ((System.Drawing.Size)(resources.GetObject("m_chkGiveFull.Size")));
        this.m_chkGiveFull.TabIndex = ((int)(resources.GetObject("m_chkGiveFull.TabIndex")));
        this.m_chkGiveFull.Text = resources.GetString("m_chkGiveFull.Text");
        m_chkGiveFull.Name = "GiveFullTrust";
        this.m_lblDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDes.Location")));
        this.m_lblDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDes.Size")));
        this.m_lblDes.TabIndex = ((int)(resources.GetObject("m_lblDes.TabIndex")));
        this.m_lblDes.Text = resources.GetString("m_lblDes.Text");
        m_lblDes.Name = "Help";
        this.m_gbIncreaseToFull.Location = ((System.Drawing.Point)(resources.GetObject("m_gbIncreaseToFull.Location")));
        this.m_gbIncreaseToFull.Size = ((System.Drawing.Size)(resources.GetObject("m_gbIncreaseToFull.Size")));
        this.m_gbIncreaseToFull.TabIndex = ((int)(resources.GetObject("m_gbIncreaseToFull.TabIndex")));
        this.m_gbIncreaseToFull.TabStop = false;
        this.m_gbIncreaseToFull.Text = resources.GetString("m_gbIncreaseToFull.Text");
        m_gbIncreaseToFull.Name = "IncreaseToFullBox";
        this.m_lblDesOfFT.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDesOfFT.Location")));
        this.m_lblDesOfFT.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDesOfFT.Size")));
        this.m_lblDesOfFT.TabIndex = ((int)(resources.GetObject("m_lblDesOfFT.TabIndex")));
        this.m_lblDesOfFT.Text = resources.GetString("m_lblDesOfFT.Text");
        m_lblDesOfFT.Name = "FullTrustDescription";
    
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_gbIncreaseToFull,
                        this.m_lblDes});

        

        this.m_gbIncreaseToFull.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_chkGiveFull,
                        this.m_lblHelpFT,
                        this.m_lblDesOfFT
                        });

        m_lblHelpFT.Click += new EventHandler(onHelpFT);
        m_chkGiveFull.CheckStateChanged += new EventHandler(onCheckChange);

        // Put in some of our own tweaks now
        return 1;
    }// InsertPropSheetPageControls

    void onCheckChange(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
        wiz.TurnOnNext(m_chkGiveFull.Checked);
    }// onCheckChange

    internal bool GiveFullTrust
    {
        get
        {
            if (m_chkGiveFull != null)
                return m_chkGiveFull.Checked;
            else
                return false;
        }
    }// GiveFullTrust

    internal void onHelpFT(Object o, EventArgs e)
    {
        CHelpDialog hd = new CHelpDialog(CResourceStore.GetString("CTrustAppWiz5:FullTrustHelp"),
                                         new Point(m_lblHelpFT.Location.X + this.Location.X + m_gbIncreaseToFull.Location.X,
                                                   m_lblHelpFT.Location.Y + this.Location.Y + m_gbIncreaseToFull.Location.Y));
        hd.Show();                                         

    }// onHelpFT

}// class CTrustAppWiz4
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csinglecodegroupmemcondprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Security.Policy;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Reflection;
using System.Globalization;
using System.Security.Cryptography.X509Certificates;
using System.Data;
using System.Runtime.Remoting;


internal class CSingleCodeGroupMemCondProp : CSecurityPropPage
{
   protected Label m_lblAllCodeDes;
   protected Label m_lblAppDirectoryHelp;
   protected Label m_lblHash;
   protected Button m_btnImportHash;
   protected RadioButton m_radMD5;
   protected Label m_lblHashAlgo;
   protected Label m_ImportHashHelp;
   protected TextBox m_txtHash;
   protected UserControl m_ucAllCode;
   protected Label m_lblHashHelp;
   protected RadioButton m_radSHA1;
   protected UserControl m_ucAppDir;
   protected UserControl m_ucPublisher;
   protected Label m_lblPublisherHelp;
   protected Button m_btnImportPubFromFile;
   protected Label m_lblPublisherCertificate;
   protected UserControl m_ucHash;
   protected Button m_btnImportCertFromCertFile;
   protected UserControl m_ucSite;
   protected Label m_lblSiteForExample;
   protected TextBox m_txtSite;
   protected Label m_lblSiteHelp;
   protected Label m_lblSiteName;
   protected Label m_lblSiteExample2;
   protected Label m_lblSiteExampleHelp;
   protected TextBox m_txtStrongNameVersion;
   protected Label m_lblPublicKey;
   protected TextBox m_txtPublicKey;
   protected Label m_lblStrongName3Parts;
   protected CheckBox m_chkStrongNameVersion;
   protected CheckBox m_chkStrongNameName;
   protected UserControl m_ucStrongName;
   protected TextBox m_txtStrongNameName;
   protected Label m_lblStrongNameHelp;
   protected Label m_lblImportStrongNameHelp;
   protected Button m_btnImportStrongName;
   protected Label m_lblURLExample1;
   protected UserControl m_ucUrl;
   protected Label m_lblURLForExample;
   protected Label m_lblURLExample2;
   protected Label m_lblURLHelp;
   protected Label m_lblSiteEntryHelp;
   protected Label m_lblURLSiteName;
   protected TextBox m_txtURL;
   protected Label m_lblZoneDes;
   protected Label m_lblZoneHelp;
   protected Label m_lblZone;
   protected ComboBox m_cbZone;
   protected UserControl m_ucZone;
   protected UserControl m_ucCustom;
   protected Label m_lblImportXMLHelp;
   protected Button m_btnImportXML;
   protected TextBox m_txtXML;
   protected Label m_lblXML;
   protected Label m_lblCustomHelp;
   protected ComboBox m_cbConditionType;
   protected Label m_lblConditionType;
   protected Label m_lblMCHelp;
   protected UserControl m_ucTop;
   protected DataGrid m_dg;
   protected Label m_lblSiteExample1;
 
    // Internal data
    protected ArrayList         m_alOtherControls;
    protected CodeGroup         m_cg;
    protected DataTable         m_dt;
    protected X509Certificate   m_x509;
    protected Point             m_point2ndPiece;
    protected String            m_sXMLFilename;
    protected DataSet           m_ds;

    protected Hash              m_hHash;

    private const int  ALL = 0;
    private const int  APPLICATIONDIRECTORY = 1;
    private const int  HASH = 2;
    private const int  PUBLISHER = 3;
    private const int  SITE = 4;
    private const int  STRONGNAME = 5;
    private const int  URL = 6;
    private const int  ZONE = 7;
    private const int  CUSTOM = 8;

    private const int  INTERNET = 0;
    private const int  INTRANET = 1;
    private const int  MYCOMPUTER = 2;
    private const int  TRUSTED = 3;
    private const int  UNTRUSTED = 4;

    internal CSingleCodeGroupMemCondProp(CodeGroup cg)
    {
        m_sTitle = CResourceStore.GetString("Csinglecodegroupmemcondprop:PageTitle"); 
        m_alOtherControls = new ArrayList();
        m_cg = cg;
        m_x509=null;
        m_point2ndPiece = new Point(0, 107);
        m_hHash = null;
    }// CSingleCodeGroupMemCondProp
    
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSingleCodeGroupMemCondProp));
        this.m_txtStrongNameVersion = new TextBox();
        this.m_ucCustom = new System.Windows.Forms.UserControl();
        this.m_lblPublicKey = new System.Windows.Forms.Label();
        this.m_lblHash = new System.Windows.Forms.Label();
        this.m_lblImportStrongNameHelp = new System.Windows.Forms.Label();
        this.m_txtPublicKey = new System.Windows.Forms.TextBox();
        this.m_lblPublisherCertificate = new System.Windows.Forms.Label();
        this.m_lblImportXMLHelp = new System.Windows.Forms.Label();
        this.m_btnImportPubFromFile = new System.Windows.Forms.Button();
        this.m_lblZoneDes = new System.Windows.Forms.Label();
        this.m_btnImportStrongName = new System.Windows.Forms.Button();
        this.m_lblURLExample1 = new System.Windows.Forms.Label();
        this.m_btnImportHash = new System.Windows.Forms.Button();
        this.m_lblPublisherHelp = new System.Windows.Forms.Label();
        this.m_lblStrongName3Parts = new System.Windows.Forms.Label();
        this.m_lblZoneHelp = new System.Windows.Forms.Label();
        this.m_btnImportXML = new System.Windows.Forms.Button();
        this.m_lblZone = new System.Windows.Forms.Label();
        this.m_lblHashAlgo = new System.Windows.Forms.Label();
        this.m_ucAllCode = new System.Windows.Forms.UserControl();
        this.m_cbConditionType = new System.Windows.Forms.ComboBox();
        this.m_lblSiteExample2 = new System.Windows.Forms.Label();
        this.m_ucUrl = new System.Windows.Forms.UserControl();
        this.m_lblSiteHelp = new System.Windows.Forms.Label();
        this.m_txtSite = new System.Windows.Forms.TextBox();
        this.m_lblURLForExample = new System.Windows.Forms.Label();
        this.m_lblSiteForExample = new System.Windows.Forms.Label();
        this.m_lblURLExample2 = new System.Windows.Forms.Label();
        this.m_txtXML = new System.Windows.Forms.TextBox();
        this.m_ucHash = new System.Windows.Forms.UserControl();
        this.m_lblConditionType = new System.Windows.Forms.Label();
        this.m_lblXML = new System.Windows.Forms.Label();
        this.m_lblURLHelp = new System.Windows.Forms.Label();
        this.m_lblAllCodeDes = new System.Windows.Forms.Label();
        this.m_ucSite = new System.Windows.Forms.UserControl();
        this.m_chkStrongNameVersion = new System.Windows.Forms.CheckBox();
        this.m_btnImportCertFromCertFile = new System.Windows.Forms.Button();
        this.m_ImportHashHelp = new System.Windows.Forms.Label();
        this.m_radMD5 = new System.Windows.Forms.RadioButton();
        this.m_lblMCHelp = new System.Windows.Forms.Label();
        this.m_ucTop = new System.Windows.Forms.UserControl();
        this.m_chkStrongNameName = new System.Windows.Forms.CheckBox();
        this.m_ucStrongName = new System.Windows.Forms.UserControl();
        this.m_cbZone = new System.Windows.Forms.ComboBox();
        this.m_radSHA1 = new System.Windows.Forms.RadioButton();
        this.m_ucPublisher = new System.Windows.Forms.UserControl();
        this.m_lblSiteEntryHelp = new System.Windows.Forms.Label();
        this.m_ucZone = new System.Windows.Forms.UserControl();
        this.m_lblURLSiteName = new System.Windows.Forms.Label();
        this.m_lblSiteExampleHelp = new System.Windows.Forms.Label();
        this.m_lblAppDirectoryHelp = new System.Windows.Forms.Label();
        this.m_dg = new System.Windows.Forms.DataGrid();
        this.m_ucAppDir = new System.Windows.Forms.UserControl();
        this.m_lblSiteExample1 = new System.Windows.Forms.Label();
        this.m_lblHashHelp = new System.Windows.Forms.Label();
        this.m_txtURL = new System.Windows.Forms.TextBox();
        this.m_txtStrongNameName = new System.Windows.Forms.TextBox();
        this.m_lblStrongNameHelp = new System.Windows.Forms.Label();
        this.m_lblSiteName = new System.Windows.Forms.Label();
        this.m_txtHash = new System.Windows.Forms.TextBox();
        this.m_lblCustomHelp = new System.Windows.Forms.Label();
        this.m_txtStrongNameVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_txtStrongNameVersion.Location")));
        this.m_txtStrongNameVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_txtStrongNameVersion.Size")));
        this.m_txtStrongNameVersion.TabIndex = ((int)(resources.GetObject("m_txtStrongNameVersion.TabIndex")));
        this.m_txtStrongNameVersion.Text = resources.GetString("m_txtStrongNameVersion.Text");
        m_txtStrongNameVersion.Name = "StrongNameVersion";
        this.m_ucCustom.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnImportXML,
                        this.m_lblImportXMLHelp,
                        this.m_txtXML,
                        this.m_lblXML,
                        this.m_lblCustomHelp});
        this.m_ucCustom.Location = m_point2ndPiece;
        this.m_ucCustom.Size = ((System.Drawing.Size)(resources.GetObject("m_ucCustom.Size")));
        this.m_ucCustom.TabIndex = ((int)(resources.GetObject("m_ucCustom.TabIndex")));
        m_ucCustom.Name = "ucCustom";
        this.m_lblPublicKey.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublicKey.Location")));
        this.m_lblPublicKey.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublicKey.Size")));
        this.m_lblPublicKey.TabIndex = ((int)(resources.GetObject("m_lblPublicKey.TabIndex")));
        this.m_lblPublicKey.Text = resources.GetString("m_lblPublicKey.Text");
        m_lblPublicKey.Name = "PublicKeyLabel";
        this.m_lblHash.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHash.Location")));
        this.m_lblHash.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHash.Size")));
        this.m_lblHash.TabIndex = ((int)(resources.GetObject("m_lblHash.TabIndex")));
        this.m_lblHash.Text = resources.GetString("m_lblHash.Text");
        m_lblHash.Name = "HashLabel";
        this.m_lblImportStrongNameHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblImportStrongNameHelp.Location")));
        this.m_lblImportStrongNameHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblImportStrongNameHelp.Size")));
        this.m_lblImportStrongNameHelp.TabIndex = ((int)(resources.GetObject("m_lblImportStrongNameHelp.TabIndex")));
        this.m_lblImportStrongNameHelp.Text = resources.GetString("m_lblImportStrongNameHelp.Text");
        m_lblImportStrongNameHelp.Name = "ImportStrongNameHelp";
        this.m_txtPublicKey.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublicKey.Location")));
        this.m_txtPublicKey.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublicKey.Size")));
        this.m_txtPublicKey.TabIndex = ((int)(resources.GetObject("m_txtPublicKey.TabIndex")));
        this.m_txtPublicKey.Text = resources.GetString("m_txtPublicKey.Text");
        m_txtPublicKey.Name = "PublicKey";
        this.m_lblPublisherCertificate.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublisherCertificate.Location")));
        this.m_lblPublisherCertificate.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublisherCertificate.Size")));
        this.m_lblPublisherCertificate.TabIndex = ((int)(resources.GetObject("m_lblPublisherCertificate.TabIndex")));
        this.m_lblPublisherCertificate.Text = resources.GetString("m_lblPublisherCertificate.Text");
        m_lblPublisherCertificate.Name = "PublisherCertificateLabel";
        this.m_lblImportXMLHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblImportXMLHelp.Location")));
        this.m_lblImportXMLHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblImportXMLHelp.Size")));
        this.m_lblImportXMLHelp.TabIndex = ((int)(resources.GetObject("m_lblImportXMLHelp.TabIndex")));
        this.m_lblImportXMLHelp.Text = resources.GetString("m_lblImportXMLHelp.Text");
        m_lblImportXMLHelp.Name = "ImportXMLHelp";
        this.m_btnImportPubFromFile.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImportPubFromFile.Location")));
        this.m_btnImportPubFromFile.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImportPubFromFile.Size")));
        this.m_btnImportPubFromFile.TabIndex = ((int)(resources.GetObject("m_btnImportPubFromFile.TabIndex")));
        this.m_btnImportPubFromFile.Text = resources.GetString("m_btnImportPubFromFile.Text");
        m_btnImportPubFromFile.Name = "ImportPubFromFile";
        this.m_lblZoneDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblZoneDes.Location")));
        this.m_lblZoneDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblZoneDes.Size")));
        this.m_lblZoneDes.TabIndex = ((int)(resources.GetObject("m_lblZoneDes.TabIndex")));
        m_lblZoneDes.Name = "ZoneDescription";
        this.m_btnImportStrongName.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImportStrongName.Location")));
        this.m_btnImportStrongName.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImportStrongName.Size")));
        this.m_btnImportStrongName.TabIndex = ((int)(resources.GetObject("m_btnImportStrongName.TabIndex")));
        this.m_btnImportStrongName.Text = resources.GetString("m_btnImportStrongName.Text");
        m_btnImportStrongName.Name = "ImportStrongName";
        this.m_lblURLExample1.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURLExample1.Location")));
        this.m_lblURLExample1.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURLExample1.Size")));
        this.m_lblURLExample1.TabIndex = ((int)(resources.GetObject("m_lblURLExample1.TabIndex")));
        this.m_lblURLExample1.Text = resources.GetString("m_lblURLExample1.Text");
        m_lblURLExample1.Name = "URLExample1";
        this.m_btnImportHash.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImportHash.Location")));
        this.m_btnImportHash.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImportHash.Size")));
        this.m_btnImportHash.TabIndex = ((int)(resources.GetObject("m_btnImportHash.TabIndex")));
        this.m_btnImportHash.Text = resources.GetString("m_btnImportHash.Text");
        m_btnImportHash.Name = "ImportHash";
        this.m_lblPublisherHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublisherHelp.Location")));
        this.m_lblPublisherHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublisherHelp.Size")));
        this.m_lblPublisherHelp.TabIndex = ((int)(resources.GetObject("m_lblPublisherHelp.TabIndex")));
        this.m_lblPublisherHelp.Text = resources.GetString("m_lblPublisherHelp.Text");
        m_lblPublisherHelp.Name = "PublisherHelp";
        this.m_lblStrongName3Parts.Location = ((System.Drawing.Point)(resources.GetObject("m_lblStrongName3Parts.Location")));
        this.m_lblStrongName3Parts.Size = ((System.Drawing.Size)(resources.GetObject("m_lblStrongName3Parts.Size")));
        this.m_lblStrongName3Parts.TabIndex = ((int)(resources.GetObject("m_lblStrongName3Parts.TabIndex")));
        this.m_lblStrongName3Parts.Text = resources.GetString("m_lblStrongName3Parts.Text");
        m_lblStrongName3Parts.Name = "StrongName3Parts";
        this.m_lblZoneHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblZoneHelp.Location")));
        this.m_lblZoneHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblZoneHelp.Size")));
        this.m_lblZoneHelp.TabIndex = ((int)(resources.GetObject("m_lblZoneHelp.TabIndex")));
        this.m_lblZoneHelp.Text = resources.GetString("m_lblZoneHelp.Text");
        m_lblZoneHelp.Name = "ZoneHelp";
        this.m_btnImportXML.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImportXML.Location")));
        this.m_btnImportXML.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImportXML.Size")));
        this.m_btnImportXML.TabIndex = ((int)(resources.GetObject("m_btnImportXML.TabIndex")));
        this.m_btnImportXML.Text = resources.GetString("m_btnImportXML.Text");
        m_btnImportXML.Name = "ImportXML";
        this.m_lblZone.Location = ((System.Drawing.Point)(resources.GetObject("m_lblZone.Location")));
        this.m_lblZone.Size = ((System.Drawing.Size)(resources.GetObject("m_lblZone.Size")));
        this.m_lblZone.TabIndex = ((int)(resources.GetObject("m_lblZone.TabIndex")));
        this.m_lblZone.Text = resources.GetString("m_lblZone.Text");
        m_lblZone.Name = "ZoneLabel";
        this.m_lblHashAlgo.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHashAlgo.Location")));
        this.m_lblHashAlgo.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHashAlgo.Size")));
        this.m_lblHashAlgo.TabIndex = ((int)(resources.GetObject("m_lblHashAlgo.TabIndex")));
        this.m_lblHashAlgo.Text = resources.GetString("m_lblHashAlgo.Text");
        m_lblHashAlgo.Name = "HashAlgorithm";
        this.m_ucAllCode.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblAllCodeDes});
        this.m_ucAllCode.Location = m_point2ndPiece;
        this.m_ucAllCode.Size = ((System.Drawing.Size)(resources.GetObject("m_ucAllCode.Size")));
        this.m_ucAllCode.TabIndex = ((int)(resources.GetObject("m_ucAllCode.TabIndex")));
        m_ucAllCode.Name = "ucAllCode";
        this.m_cbConditionType.DropDownWidth = 264;
        this.m_cbConditionType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbConditionType.Location = ((System.Drawing.Point)(resources.GetObject("m_cbConditionType.Location")));
        this.m_cbConditionType.Size = ((System.Drawing.Size)(resources.GetObject("m_cbConditionType.Size")));
        this.m_cbConditionType.TabIndex = ((int)(resources.GetObject("m_cbConditionType.TabIndex")));
        m_cbConditionType.Name = "ConditionType";
        this.m_lblSiteExample2.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteExample2.Location")));
        this.m_lblSiteExample2.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteExample2.Size")));
        this.m_lblSiteExample2.TabIndex = ((int)(resources.GetObject("m_lblSiteExample2.TabIndex")));
        this.m_lblSiteExample2.Text = resources.GetString("m_lblSiteExample2.Text");
        m_lblSiteExample2.Name = "SiteExample2";
        this.m_ucUrl.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblURLExample2,
                        this.m_lblURLExample1,
                        this.m_lblURLForExample,
                        this.m_lblSiteEntryHelp,
                        this.m_lblURLSiteName,
                        this.m_txtURL,
                        this.m_lblURLHelp});
        this.m_ucUrl.Location = m_point2ndPiece;
        this.m_ucUrl.Size = ((System.Drawing.Size)(resources.GetObject("m_ucUrl.Size")));
        this.m_ucUrl.TabIndex = ((int)(resources.GetObject("m_ucUrl.TabIndex")));
        m_ucUrl.Name = "ucUrl";
        this.m_lblSiteHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteHelp.Location")));
        this.m_lblSiteHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteHelp.Size")));
        this.m_lblSiteHelp.TabIndex = ((int)(resources.GetObject("m_lblSiteHelp.TabIndex")));
        this.m_lblSiteHelp.Text = resources.GetString("m_lblSiteHelp.Text");
        m_lblSiteHelp.Name = "SiteHelp";
        this.m_txtSite.Location = ((System.Drawing.Point)(resources.GetObject("m_txtSite.Location")));
        this.m_txtSite.Size = ((System.Drawing.Size)(resources.GetObject("m_txtSite.Size")));
        this.m_txtSite.TabIndex = ((int)(resources.GetObject("m_txtSite.TabIndex")));
        this.m_txtSite.Text = resources.GetString("m_txtSite.Text");
        m_txtSite.Name = "Site";
        this.m_lblURLForExample.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURLForExample.Location")));
        this.m_lblURLForExample.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURLForExample.Size")));
        this.m_lblURLForExample.TabIndex = ((int)(resources.GetObject("m_lblURLForExample.TabIndex")));
        this.m_lblURLForExample.Text = resources.GetString("m_lblURLForExample.Text");
        m_lblURLForExample.Name = "URLForExample";
        this.m_lblSiteForExample.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteForExample.Location")));
        this.m_lblSiteForExample.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteForExample.Size")));
        this.m_lblSiteForExample.TabIndex = ((int)(resources.GetObject("m_lblSiteForExample.TabIndex")));
        this.m_lblSiteForExample.Text = resources.GetString("m_lblSiteForExample.Text");
        m_lblSiteForExample.Name = "SiteForExample";
        this.m_lblURLExample2.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURLExample2.Location")));
        this.m_lblURLExample2.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURLExample2.Size")));
        this.m_lblURLExample2.TabIndex = ((int)(resources.GetObject("m_lblURLExample2.TabIndex")));
        this.m_lblURLExample2.Text = resources.GetString("m_lblURLExample2.Text");
        m_lblURLExample2.Name = "URLExample2";
        this.m_txtXML.Location = ((System.Drawing.Point)(resources.GetObject("m_txtXML.Location")));
        this.m_txtXML.Multiline = true;
        this.m_txtXML.ReadOnly = true;
        this.m_txtXML.Size = ((System.Drawing.Size)(resources.GetObject("m_txtXML.Size")));
        this.m_txtXML.TabStop = false;
        this.m_txtXML.Text = resources.GetString("m_txtXML.Text");
        m_txtXML.Name = "XML";
        this.m_ucHash.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnImportHash,
                        this.m_ImportHashHelp,
                        this.m_lblHash,
                        this.m_txtHash,
                        this.m_radSHA1,
                        this.m_radMD5,
                        this.m_lblHashAlgo,
                        this.m_lblHashHelp});
        this.m_ucHash.Location = m_point2ndPiece;
        this.m_ucHash.Size = ((System.Drawing.Size)(resources.GetObject("m_ucHash.Size")));
        this.m_ucHash.TabIndex = ((int)(resources.GetObject("m_ucHash.TabIndex")));
        m_ucHash.Name = "ucHash";
        this.m_lblConditionType.Location = ((System.Drawing.Point)(resources.GetObject("m_lblConditionType.Location")));
        this.m_lblConditionType.Size = ((System.Drawing.Size)(resources.GetObject("m_lblConditionType.Size")));
        this.m_lblConditionType.TabIndex = ((int)(resources.GetObject("m_lblConditionType.TabIndex")));
        this.m_lblConditionType.Text = resources.GetString("m_lblConditionType.Text");
        m_lblConditionType.Name = "ConditionTypeLabel";
        this.m_lblXML.Location = ((System.Drawing.Point)(resources.GetObject("m_lblXML.Location")));
        this.m_lblXML.Size = ((System.Drawing.Size)(resources.GetObject("m_lblXML.Size")));
        this.m_lblXML.TabIndex = ((int)(resources.GetObject("m_lblXML.TabIndex")));
        this.m_lblXML.Text = resources.GetString("m_lblXML.Text");
        m_lblXML.Name = "XMLLabel";
        this.m_lblURLHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURLHelp.Location")));
        this.m_lblURLHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURLHelp.Size")));
        this.m_lblURLHelp.TabIndex = ((int)(resources.GetObject("m_lblURLHelp.TabIndex")));
        this.m_lblURLHelp.Text = resources.GetString("m_lblURLHelp.Text");
        m_lblURLHelp.Name = "URLHelp";
        this.m_lblAllCodeDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAllCodeDes.Location")));
        this.m_lblAllCodeDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAllCodeDes.Size")));
        this.m_lblAllCodeDes.TabIndex = ((int)(resources.GetObject("m_lblAllCodeDes.TabIndex")));
        this.m_lblAllCodeDes.Text = resources.GetString("m_lblAllCodeDes.Text");
        m_lblAllCodeDes.Name = "AllCodeDescription";
        this.m_ucSite.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblSiteExample2,
                        this.m_lblSiteExample1,
                        this.m_lblSiteForExample,
                        this.m_lblSiteExampleHelp,
                        this.m_lblSiteName,
                        this.m_txtSite,
                        this.m_lblSiteHelp});
        this.m_ucSite.Location = m_point2ndPiece;
        this.m_ucSite.Size = ((System.Drawing.Size)(resources.GetObject("m_ucSite.Size")));
        this.m_ucSite.TabIndex = ((int)(resources.GetObject("m_ucSite.TabIndex")));
        m_ucSite.Name = "ucSite";
        this.m_chkStrongNameVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_chkStrongNameVersion.Location")));
        this.m_chkStrongNameVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_chkStrongNameVersion.Size")));
        this.m_chkStrongNameVersion.TabIndex = ((int)(resources.GetObject("m_chkStrongNameVersion.TabIndex")));
        this.m_chkStrongNameVersion.Text = resources.GetString("m_chkStrongNameVersion.Text");
        m_chkStrongNameVersion.Name = "StrongNameVersionCheck";
        this.m_btnImportCertFromCertFile.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImportCertFromCertFile.Location")));
        this.m_btnImportCertFromCertFile.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImportCertFromCertFile.Size")));
        this.m_btnImportCertFromCertFile.TabIndex = ((int)(resources.GetObject("m_btnImportCertFromCertFile.TabIndex")));
        this.m_btnImportCertFromCertFile.Text = resources.GetString("m_btnImportCertFromCertFile.Text");
        m_btnImportCertFromCertFile.Name = "ImportCertFromCertFile";
        this.m_ImportHashHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_ImportHashHelp.Location")));
        this.m_ImportHashHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_ImportHashHelp.Size")));
        this.m_ImportHashHelp.TabIndex = ((int)(resources.GetObject("m_ImportHashHelp.TabIndex")));
        this.m_ImportHashHelp.Text = resources.GetString("m_ImportHashHelp.Text");
        m_ImportHashHelp.Name = "ImportHashHelp";
        this.m_radMD5.Location = ((System.Drawing.Point)(resources.GetObject("m_radMD5.Location")));
        this.m_radMD5.Size = ((System.Drawing.Size)(resources.GetObject("m_radMD5.Size")));
        this.m_radMD5.TabIndex = ((int)(resources.GetObject("m_radMD5.TabIndex")));
        this.m_radMD5.Text = resources.GetString("m_radMD5.Text");
        m_radMD5.Name = "MD5";
        this.m_lblMCHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblMCHelp.Location")));
        this.m_lblMCHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblMCHelp.Size")));
        this.m_lblMCHelp.TabIndex = ((int)(resources.GetObject("m_lblMCHelp.TabIndex")));
        this.m_lblMCHelp.Text = resources.GetString("m_lblMCHelp.Text");
        m_lblMCHelp.Name = "MCHelp";
        this.m_ucTop.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblConditionType,
                        this.m_cbConditionType,
                        this.m_lblMCHelp});
        this.m_ucTop.Location = new Point(0,0);
        this.m_ucTop.Size = ((System.Drawing.Size)(resources.GetObject("m_ucTop.Size")));
        this.m_ucTop.TabIndex = ((int)(resources.GetObject("m_ucTop.TabIndex")));
        m_ucTop.Name = "ucTop";
        this.m_chkStrongNameName.Location = ((System.Drawing.Point)(resources.GetObject("m_chkStrongNameName.Location")));
        this.m_chkStrongNameName.Size = ((System.Drawing.Size)(resources.GetObject("m_chkStrongNameName.Size")));
        this.m_chkStrongNameName.TabIndex = ((int)(resources.GetObject("m_chkStrongNameName.TabIndex")));
        this.m_chkStrongNameName.Text = resources.GetString("m_chkStrongNameName.Text");
        m_chkStrongNameName.Name = "StrongNameNameCheck";
        this.m_ucStrongName.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblPublicKey,
                        this.m_txtPublicKey,
                        this.m_lblImportStrongNameHelp,
                        this.m_chkStrongNameName,
                        this.m_txtStrongNameName,
                        this.m_chkStrongNameVersion,
                        this.m_txtStrongNameVersion,
                        this.m_lblStrongName3Parts,
                        this.m_lblStrongNameHelp,
                        this.m_btnImportStrongName});
        this.m_ucStrongName.Location = m_point2ndPiece;
        this.m_ucStrongName.Size = ((System.Drawing.Size)(resources.GetObject("m_ucStrongName.Size")));
        this.m_ucStrongName.TabIndex = ((int)(resources.GetObject("m_ucStrongName.TabIndex")));
        m_ucStrongName.Name = "ucStrongName";
        this.m_cbZone.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbZone.DropDownWidth = 296;
        this.m_cbZone.Location = ((System.Drawing.Point)(resources.GetObject("m_cbZone.Location")));
        this.m_cbZone.Size = ((System.Drawing.Size)(resources.GetObject("m_cbZone.Size")));
        this.m_cbZone.TabIndex = ((int)(resources.GetObject("m_cbZone.TabIndex")));
        m_cbZone.Name = "Zone";
        this.m_radSHA1.Location = ((System.Drawing.Point)(resources.GetObject("m_radSHA1.Location")));
        this.m_radSHA1.Size = ((System.Drawing.Size)(resources.GetObject("m_radSHA1.Size")));
        this.m_radSHA1.TabIndex = ((int)(resources.GetObject("m_radSHA1.TabIndex")));
        this.m_radSHA1.Text = resources.GetString("m_radSHA1.Text");
        m_radSHA1.Name = "SHA1";
        this.m_ucPublisher.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnImportCertFromCertFile,
                        this.m_btnImportPubFromFile,
                        this.m_dg,
                        this.m_lblPublisherCertificate,
                        this.m_lblPublisherHelp});
        this.m_ucPublisher.Location = m_point2ndPiece;
        this.m_ucPublisher.Size = ((System.Drawing.Size)(resources.GetObject("m_ucPublisher.Size")));
        this.m_ucPublisher.TabIndex = ((int)(resources.GetObject("m_ucPublisher.TabIndex")));
        m_ucPublisher.Name = "ucPublisher";
        this.m_lblSiteEntryHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteEntryHelp.Location")));
        this.m_lblSiteEntryHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteEntryHelp.Size")));
        this.m_lblSiteEntryHelp.TabIndex = ((int)(resources.GetObject("m_lblSiteEntryHelp.TabIndex")));
        this.m_lblSiteEntryHelp.Text = resources.GetString("m_lblSiteEntryHelp.Text");
        m_lblSiteEntryHelp.Name = "SiteEntryHelp";
        this.m_ucZone.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblZoneDes,
                        this.m_lblZone,
                        this.m_cbZone,
                        this.m_lblZoneHelp});
        this.m_ucZone.Location = m_point2ndPiece;
        this.m_ucZone.Size = ((System.Drawing.Size)(resources.GetObject("m_ucZone.Size")));
        this.m_ucZone.TabIndex = ((int)(resources.GetObject("m_ucZone.TabIndex")));
        m_ucZone.Name = "ucZone";
        this.m_lblURLSiteName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURLSiteName.Location")));
        this.m_lblURLSiteName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURLSiteName.Size")));
        this.m_lblURLSiteName.TabIndex = ((int)(resources.GetObject("m_lblURLSiteName.TabIndex")));
        this.m_lblURLSiteName.Text = resources.GetString("m_lblURLSiteName.Text");
        m_lblURLSiteName.Name = "URLSiteNameLabel";
        this.m_lblSiteExampleHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteExampleHelp.Location")));
        this.m_lblSiteExampleHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteExampleHelp.Size")));
        this.m_lblSiteExampleHelp.TabIndex = ((int)(resources.GetObject("m_lblSiteExampleHelp.TabIndex")));
        this.m_lblSiteExampleHelp.Text = resources.GetString("m_lblSiteExampleHelp.Text");
        m_lblSiteExampleHelp.Name = "SiteExampleHelp";
        this.m_lblAppDirectoryHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAppDirectoryHelp.Location")));
        this.m_lblAppDirectoryHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAppDirectoryHelp.Size")));
        this.m_lblAppDirectoryHelp.TabIndex = ((int)(resources.GetObject("m_lblAppDirectoryHelp.TabIndex")));
        this.m_lblAppDirectoryHelp.Text = resources.GetString("m_lblAppDirectoryHelp.Text");
        m_lblAppDirectoryHelp.Name = "AppDirectoryHelp";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.BackgroundColor = Color.White;
        m_dg.Name = "Grid";
        this.m_ucAppDir.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblAppDirectoryHelp});
        this.m_ucAppDir.Location = m_point2ndPiece;
        this.m_ucAppDir.Size = ((System.Drawing.Size)(resources.GetObject("m_ucAppDir.Size")));
        this.m_ucAppDir.TabIndex = ((int)(resources.GetObject("m_ucAppDir.TabIndex")));
        m_ucAppDir.Name = "ucAppDir";
        this.m_lblSiteExample1.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteExample1.Location")));
        this.m_lblSiteExample1.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteExample1.Size")));
        this.m_lblSiteExample1.TabIndex = ((int)(resources.GetObject("m_lblSiteExample1.TabIndex")));
        this.m_lblSiteExample1.Text = resources.GetString("m_lblSiteExample1.Text");
        m_lblSiteExample1.Name = "SiteExample1";
        this.m_lblHashHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHashHelp.Location")));
        this.m_lblHashHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHashHelp.Size")));
        this.m_lblHashHelp.TabIndex = ((int)(resources.GetObject("m_lblHashHelp.TabIndex")));
        this.m_lblHashHelp.Text = resources.GetString("m_lblHashHelp.Text");
        m_lblHashHelp.Name = "HashHelp";
        this.m_txtURL.Location = ((System.Drawing.Point)(resources.GetObject("m_txtURL.Location")));
        this.m_txtURL.Size = ((System.Drawing.Size)(resources.GetObject("m_txtURL.Size")));
        this.m_txtURL.TabIndex = ((int)(resources.GetObject("m_txtURL.TabIndex")));
        this.m_txtURL.Text = resources.GetString("m_txtURL.Text");
        m_txtURL.Name = "URL";
        this.m_txtStrongNameName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtStrongNameName.Location")));
        this.m_txtStrongNameName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtStrongNameName.Size")));
        this.m_txtStrongNameName.TabIndex = ((int)(resources.GetObject("m_txtStrongNameName.TabIndex")));
        this.m_txtStrongNameName.Text = resources.GetString("m_txtStrongNameName.Text");
        m_txtStrongNameName.Name = "StrongName";
        this.m_lblStrongNameHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblStrongNameHelp.Location")));
        this.m_lblStrongNameHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblStrongNameHelp.Size")));
        this.m_lblStrongNameHelp.TabIndex = ((int)(resources.GetObject("m_lblStrongNameHelp.TabIndex")));
        this.m_lblStrongNameHelp.Text = resources.GetString("m_lblStrongNameHelp.Text");
        m_lblStrongNameHelp.Name = "StrongNameHelp";
        this.m_lblSiteName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSiteName.Location")));
        this.m_lblSiteName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSiteName.Size")));
        this.m_lblSiteName.TabIndex = ((int)(resources.GetObject("m_lblSiteName.TabIndex")));
        this.m_lblSiteName.Text = resources.GetString("m_lblSiteName.Text");
        m_lblSiteName.Name = "SiteNameLabel";
        this.m_txtHash.Location = ((System.Drawing.Point)(resources.GetObject("m_txtHash.Location")));
        this.m_txtHash.Size = ((System.Drawing.Size)(resources.GetObject("m_txtHash.Size")));
        this.m_txtHash.TabIndex = ((int)(resources.GetObject("m_txtHash.TabIndex")));
        this.m_txtHash.Text = resources.GetString("m_txtHash.Text");
        m_txtHash.Name = "Hash";
        this.m_lblCustomHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCustomHelp.Location")));
        this.m_lblCustomHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCustomHelp.Size")));
        this.m_lblCustomHelp.TabIndex = ((int)(resources.GetObject("m_lblCustomHelp.TabIndex")));
        this.m_lblCustomHelp.Text = resources.GetString("m_lblCustomHelp.Text");
        m_lblCustomHelp.Name = "CustomHelp";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_ucTop,
                        this.m_ucCustom,
                        this.m_ucZone,
                        this.m_ucUrl,
                        this.m_ucStrongName,
                        this.m_ucSite,
                        this.m_ucPublisher,
                        this.m_ucHash,
                        this.m_ucAllCode,
                        this.m_ucAppDir});

        //----------- Build Data Table ------------------------
        
        m_dt = new DataTable("Stuff");

        // Create the "Property" Column
        DataColumn dcProperty = new DataColumn();
        dcProperty.ColumnName = "Property";
        dcProperty.DataType = typeof(String);
        m_dt.Columns.Add(dcProperty);

        // Create the "Value" Column
        DataColumn dcValue = new DataColumn();
        dcValue.ColumnName = "Value";
        dcValue.DataType = typeof(String);
        m_dt.Columns.Add(dcValue);

        // Set up the GUI-type stuff for the data grid
        m_dg.ReadOnly = true;
        m_dg.CaptionVisible=false;

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcProperty = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcValue = new DataGridTextBoxColumn();
         
        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;
        dgts.ReadOnly=false;
        
        // Set up the column info for the Property column
        dgtbcProperty.MappingName = "Property";
        dgtbcProperty.HeaderText = CResourceStore.GetString("Csinglecodegroupmemcondprop:PropertyColumn");
        dgtbcProperty.Width = ScaleWidth(CResourceStore.GetInt("Csinglecodegroupmemcondprop:PropertyColumnWidth"));
        dgts.GridColumnStyles.Add(dgtbcProperty);

        // Set up the column info for the Value column
        dgtbcValue.MappingName = "Value";
        dgtbcValue.HeaderText = CResourceStore.GetString("Csinglecodegroupmemcondprop:ValueColumn");
        dgtbcValue.Width = ScaleWidth(CResourceStore.GetInt("Csinglecodegroupmemcondprop:ValueColumnWidth"));
        // Allows us to filter what is typed into the box
        dgts.GridColumnStyles.Add(dgtbcValue);

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dg.DataSource = m_dt;

        DataRow newRow;
        newRow = m_dt.NewRow();
        newRow["Property"]=CResourceStore.GetString("Csinglecodegroupmemcondprop:NameValue");
        newRow["Value"]="";
        m_dt.Rows.Add(newRow);

        newRow = m_dt.NewRow();
        newRow["Property"]=CResourceStore.GetString("Csinglecodegroupmemcondprop:IssuerValue");
        newRow["Value"]="";
        m_dt.Rows.Add(newRow);

        newRow = m_dt.NewRow();
        newRow["Property"]=CResourceStore.GetString("Csinglecodegroupmemcondprop:IssuerHash");
        newRow["Value"]="";
        m_dt.Rows.Add(newRow);


        //--------------- End Building Data Table ----------------------------


        // Fill in the data
        PutValuesinPage();
        
        // A little UI tweaking
        m_txtXML.ScrollBars = ScrollBars.Both;
        
        // Put in event handlers
        m_cbZone.SelectedIndexChanged += new EventHandler(UpdateZoneText);
        m_cbZone.SelectedIndexChanged += new EventHandler(onChange);
        m_txtHash.TextChanged += new EventHandler(onChange);
        m_btnImportHash.Click += new EventHandler(onImportHash);
        m_txtSite.TextChanged += new EventHandler(onChange);
        m_txtPublicKey.TextChanged += new EventHandler(onChange);
        m_txtStrongNameName.TextChanged += new EventHandler(onChange);
        m_txtStrongNameVersion.TextChanged += new EventHandler(onChange);
        m_txtURL.TextChanged += new EventHandler(onChange);
        m_btnImportStrongName.Click += new EventHandler(onImportSName);
        m_btnImportXML.Click += new EventHandler(ImportCustom);
        m_btnImportPubFromFile.Click += new EventHandler(ImportFromSigned);
        m_btnImportCertFromCertFile.Click += new EventHandler(ImportFromCert);
        m_cbConditionType.SelectedIndexChanged += new EventHandler(NewCondType);
        m_chkStrongNameVersion.Click += new EventHandler(onStrongNameVersionClick);
        m_chkStrongNameName.Click += new EventHandler(onStrongNameNameClick);
        this.m_radMD5.Click += new EventHandler(onChange);
        this.m_radSHA1.Click += new EventHandler(onChange);
        this.m_radMD5.Click += new EventHandler(onHashTypeChange);
        this.m_radSHA1.Click += new EventHandler(onHashTypeChange);


        
        // Set the state on the checkboxes/textboxes
        onStrongNameVersionClick(null, null);
        onStrongNameNameClick(null, null);

        return 1;
    }// InsertPropSheetPageControls

    internal CodeGroup MyCodeGroup
    {
        get
        {
            return m_cg;
        }
        set
        {
            m_cg = value;
            PutValuesinPage();
        }
    }// MyCodeGroup

    protected void PutValuesinPage()
    {
        if (MyCodeGroup != null && m_btnImportXML!= null)
        {
            // Let's fill the Condition Type Combo Box
            m_cbConditionType.Items.Clear();
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:AllCode"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:ApplicationDirectory"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:Hash"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:Publisher"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:Site"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:StrongName"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:URL"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:Zone"));
            m_cbConditionType.Items.Add(CResourceStore.GetString("Csinglecodegroupmemcondprop:custom"));

            m_cbConditionType.SelectedIndex = GetIndexNumber(MyCodeGroup.MembershipCondition);

            // Put in the various zone types
            m_cbZone.Items.Clear();
            m_cbZone.Items.Add(CResourceStore.GetString("Internet"));
            m_cbZone.Items.Add(CResourceStore.GetString("LocalIntranet"));
            m_cbZone.Items.Add(CResourceStore.GetString("MyComputer"));
            m_cbZone.Items.Add(CResourceStore.GetString("Trusted"));
            m_cbZone.Items.Add(CResourceStore.GetString("Untrusted"));

            BuildSecondPieceOfUI(MyCodeGroup.MembershipCondition);
        }
    }// PutValuesinPage

    private int GetIndexNumber(IMembershipCondition imc)
    {
        if (imc is AllMembershipCondition)
            return ALL;
        if (imc is ApplicationDirectoryMembershipCondition)
            return APPLICATIONDIRECTORY;
        if (imc is HashMembershipCondition)
            return HASH;
        if (imc is PublisherMembershipCondition)
            return PUBLISHER;
        if (imc is SiteMembershipCondition)
            return SITE;
        if (imc is StrongNameMembershipCondition)
            return STRONGNAME;
        if (imc is UrlMembershipCondition)
            return URL;
        if (imc is ZoneMembershipCondition)
            return ZONE;
        // This is a custom Membership Condition
        return CUSTOM;
    }// GetIndexNumber

    private void BuildSecondPieceOfUI(int iIndex)
    {
        BuildSecondPieceOfUI(null, iIndex);
    }// BuildSecondPieceOfUI
    
    private void BuildSecondPieceOfUI(IMembershipCondition imc)
    {
        BuildSecondPieceOfUI(imc, GetIndexNumber(imc));
    }// BuildSecondPieceOfUI

    private void BuildSecondPieceOfUI(IMembershipCondition imc, int iIndex)
    {
        // Make all the optional controls invisible
        MakeOptionalControlsInvisible();
    
        switch(iIndex){
            case ALL: // AllMembershipCondition
                m_ucAllCode.Visible = true;
                break;
            case APPLICATIONDIRECTORY: // ApplicationDirectory
                m_ucAppDir.Visible = true;
                  break;
            case HASH: // HashMembership
                m_ucHash.Visible = true;
                HashMembershipCondition hmc = (HashMembershipCondition)imc;
                if (hmc != null)
                {
                    // Put in our hash info
                    if (hmc.HashAlgorithm is MD5)
                        m_radMD5.Checked = true;
                    else if (hmc.HashAlgorithm is SHA1)
                        m_radSHA1.Checked = true;
                    else
                        MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:UnknownHashAlgorithm"),
                                   CResourceStore.GetString("Csinglecodegroupmemcondprop:UnknownHashAlgorithmTitle"),
                                   MB.ICONEXCLAMATION);

                    m_txtHash.Text = ByteArrayToString(hmc.HashValue);
                    // In this case, the user shouldn't be able to change the hash type
                    m_radMD5.Enabled = false;
                    m_radSHA1.Enabled = false;
                }
                // Select the SHA1 one by default
                m_radSHA1.Checked = true;
                break;
            case PUBLISHER: // Publisher
                m_ucPublisher.Visible = true;
                
                PublisherMembershipCondition pmc = (PublisherMembershipCondition)imc;
                if (pmc != null)
                {
                    // Put in our info
                    m_x509 = pmc.Certificate;
                    PutInCertificateInfo();
                }
                break;
            case SITE: // SiteMembership
                m_ucSite.Visible = true;

                SiteMembershipCondition smc = (SiteMembershipCondition)imc;
                // Put in the site name if we have it
                if (smc != null)
                    m_txtSite.Text = smc.Site;
            
                break;
            case STRONGNAME: // StrongName
                m_ucStrongName.Visible = true;

                StrongNameMembershipCondition snmc = (StrongNameMembershipCondition)imc;
                if (snmc != null)
                {
                    m_txtPublicKey.Text = snmc.PublicKey.ToString();
                    m_txtStrongNameName.Text = snmc.Name;
                    m_txtStrongNameVersion.Text = (snmc.Version != null)?snmc.Version.ToString():null;
                    if (m_txtStrongNameName.Text.Length > 0)
                        m_chkStrongNameName.Checked = true;
                    if (m_txtStrongNameVersion.Text.Length > 0)
                        m_chkStrongNameVersion.Checked = true;
                    
                    m_txtPublicKey.Select(0,0);
                }
            
                break;
            case URL: // URL
                m_ucUrl.Visible = true;

                UrlMembershipCondition umc = (UrlMembershipCondition)imc;
                // Put in the site name if we have it
                if (umc != null)
                    m_txtURL.Text = umc.Url;

                break;
            case ZONE:
                // Make the zone-specific controls visible
                m_ucZone.Visible = true;
                
                // Get the Index of the SecurityZone
                if (imc != null)
                    m_cbZone.SelectedIndex = GetZoneIndexNumber(((ZoneMembershipCondition)imc).SecurityZone);
                else
                    m_cbZone.SelectedIndex = 0;
                UpdateZoneText(null, null);    
                break;

            default:    // Custom
                m_ucCustom.Visible = true;
                // Only put in the XML for the custom membership condition
                // if we have one to show
                if (imc != null)
                    m_txtXML.Text = imc.ToXml().ToString();
                break;
        }
    }// BuildSecondPieceOfUI

    protected void UpdateZoneText(Object o, EventArgs e)
    {
        String[] sZoneDes = new String[] {
                                CResourceStore.GetString("InternetZoneDes"),
                                CResourceStore.GetString("IntranetZoneDes"),
                                CResourceStore.GetString("MyComputerZoneDes"),
                                CResourceStore.GetString("TrustedZoneDes"),
                                CResourceStore.GetString("UntrustedZoneDes")
                                                };
        if (m_cbZone.SelectedIndex != -1)
            m_lblZoneDes.Text = sZoneDes[m_cbZone.SelectedIndex];
    }// UpdateZoneText



    private int GetZoneIndexNumber(SecurityZone sz)
    {
        switch(sz) {
            case SecurityZone.Internet:
                return INTERNET;
            case SecurityZone.Intranet:
                return INTRANET;
            case SecurityZone.MyComputer:
                return MYCOMPUTER;
            case SecurityZone.Trusted:
                return TRUSTED;
            case SecurityZone.Untrusted:
                return UNTRUSTED;
            default:
                return -1;
        }
    }// GetZoneIndexNumber

    private SecurityZone GetSecurityZone(int iZone)
    {
        switch(iZone) {
            case INTERNET:
                return SecurityZone.Internet;
            case INTRANET:
                return SecurityZone.Intranet;
            case MYCOMPUTER:
                return SecurityZone.MyComputer;
            case TRUSTED:
                return SecurityZone.Trusted;
            case UNTRUSTED:
                return SecurityZone.Untrusted;
            default:
                throw new Exception("Unknown Zone");
        }
    }// GetSecurityZone

    private void MakeOptionalControlsInvisible()
    {
        m_ucAllCode.Visible = false;
        m_ucAppDir.Visible  = false;
        m_ucPublisher.Visible  = false;
        m_ucHash.Visible  = false;
        m_ucSite.Visible  = false;
        m_ucStrongName.Visible  = false;
        m_ucUrl.Visible  = false;
        m_ucZone.Visible  = false;
        m_ucCustom.Visible  = false;
    }// MakeOptionalControlsInvisible

    internal IMembershipCondition GetCurrentMembershipCondition()
    {
        // If it is a Zone
        if (m_cbConditionType.SelectedIndex == ZONE)
            return new ZoneMembershipCondition(GetSecurityZone(m_cbZone.SelectedIndex));
        // If it is the All code type
        else if (m_cbConditionType.SelectedIndex == ALL)
            return new AllMembershipCondition();

        else if (m_cbConditionType.SelectedIndex == APPLICATIONDIRECTORY)
            return new ApplicationDirectoryMembershipCondition();
        else if (m_cbConditionType.SelectedIndex == HASH)
        {
            // Determine which Hash Algorithm to use
            HashAlgorithm ha;
            if (m_radMD5.Checked)
                ha = MD5.Create();
            else
                ha = SHA1.Create();
            Byte[]  ba = ByteStringToByteArray(m_txtHash.Text);
            return new HashMembershipCondition(ha, ba);
        }
        else if (m_cbConditionType.SelectedIndex == SITE)
            return new SiteMembershipCondition(m_txtSite.Text);
        else if (m_cbConditionType.SelectedIndex == URL)
            return new UrlMembershipCondition(m_txtURL.Text);
        else if (m_cbConditionType.SelectedIndex == STRONGNAME)
        {
            StrongNamePublicKeyBlob snpkb = new StrongNamePublicKeyBlob(ByteStringToByteArray(m_txtPublicKey.Text));
            // Now verify our version
            Version ver = null;
            if (m_chkStrongNameVersion.Checked && m_txtStrongNameVersion.Text.Length > 0)
                ver = new Version(m_txtStrongNameVersion.Text);
            
            // Grab the name if we need to
            String sName = null;
            if (m_chkStrongNameName.Checked)
                sName = m_txtStrongNameName.Text;
           
            return new StrongNameMembershipCondition(snpkb, sName, ver);
        }
        else if (m_cbConditionType.SelectedIndex == PUBLISHER)
            return new PublisherMembershipCondition(m_x509);    

        else if (m_cbConditionType.SelectedIndex == CUSTOM)
            return GetCustomMembershipCondition();
    
        return null;
    }// GetCurrentMembershipCondition
    
    internal override bool ApplyData()
    {
        // See if they can make these changes
        if (!CanMakeChanges())
            return false;
            
        m_cg.MembershipCondition = GetCurrentMembershipCondition();

        SecurityPolicyChanged();
        return true;
    }// ApplyData

    protected void NewCondType(Object o, EventArgs e)
    {
        BuildSecondPieceOfUI(m_cbConditionType.SelectedIndex);
        ActivateApply();
    }// NewCondType

    internal override bool ValidateData()
    {
        // Run through and make sure the given inputs are correct
        if (m_cbConditionType.SelectedIndex == HASH)
        {
            if (m_txtHash.Text.Length == 0)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedFileForHash"), 
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedFileForHashTitle"), 
                           MB.ICONEXCLAMATION);
                return false;
            }
            else
            {
                // Determine which Hash Algorithm to use
                HashAlgorithm ha;
                if (m_radMD5.Checked)
                    ha = MD5.Create();
                else
                    ha = SHA1.Create();
                try
                {
                    Byte[]  ba = ByteStringToByteArray(m_txtHash.Text);
                    HashMembershipCondition hmc = new HashMembershipCondition(ha, ba);
                }
                catch(Exception)
                {
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidHash"), 
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidHashTitle"),
                               MB.ICONEXCLAMATION);
                    return false;
                }
            }
        }
        else if (m_cbConditionType.SelectedIndex == SITE)
        {       
            try
            {
                SiteMembershipCondition smc = new SiteMembershipCondition(m_txtSite.Text);
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidSite"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidSiteTitle"),
                           MB.ICONEXCLAMATION);
                return false;
            }
        }
        else if (m_cbConditionType.SelectedIndex == URL)
        {
            try
            {
                UrlMembershipCondition umc = new UrlMembershipCondition(m_txtURL.Text);
            }
            catch(Exception)
            {
                MessageBox(String.Format(CResourceStore.GetString("IsNotAValidURLTitle"), m_txtURL.Text),
                           CResourceStore.GetString("IsNotAValidURLTitle"),
                           MB.ICONEXCLAMATION);
                return false;
            }
        }
        else if (m_cbConditionType.SelectedIndex == STRONGNAME)
        {
            // Let's verify our data first
            if (m_txtPublicKey.Text ==  null || m_txtPublicKey.Text.Length == 0)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedPublicKey"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedPublicKeyTitle"),
                           MB.ICONEXCLAMATION);
                return false;
            }                    

            StrongNamePublicKeyBlob snpkb = null;
            try
            {
                snpkb = new StrongNamePublicKeyBlob(ByteStringToByteArray(m_txtPublicKey.Text));
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidPublicKey"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:InvalidPublicKeyTitle"),
                           MB.ICONEXCLAMATION);
                return false;
            }

            Version ver=null; 
            try
            {
                // Now verify our version
                if (m_chkStrongNameVersion.Checked && m_txtStrongNameVersion.Text != null && m_txtStrongNameVersion.Text.Length > 0)
                    ver = new Version(m_txtStrongNameVersion.Text);
            }
            catch(Exception)
            {
                MessageBox(String.Format(CResourceStore.GetString("isanInvalidVersion"), m_txtStrongNameVersion.Text),
                           CResourceStore.GetString("isanInvalidVersionTitle"),
                           MB.ICONEXCLAMATION);
                return false;

            }

            try
            {
                StrongNameMembershipCondition snmc = new StrongNameMembershipCondition(snpkb, m_txtStrongNameName.Text, ver);
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:BadSN"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:BadSNTitle"),
                           MB.ICONEXCLAMATION);
                return false;

            }
            
        }
        else if (m_cbConditionType.SelectedIndex == PUBLISHER)
        {
            if (m_x509 == null || ((String)m_dg[0,1]).Length == 0)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedPubCert"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedPubCertTitle"),
                           MB.ICONEXCLAMATION);
                return false;
            }
        }
        else if (m_cbConditionType.SelectedIndex == CUSTOM)
        {
            if (m_txtXML.Text.Length == 0)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedImport"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:NeedImportTitle"),
                           MB.ICONEXCLAMATION);
                return false;

            }
            IMembershipCondition imc = GetCustomMembershipCondition();
            if (imc == null)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXML"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXMLTitle"),
                           MB.ICONEXCLAMATION);
                return false;


            }



        }

        // If we survived this long, then our data is correct
        return true;
    }// ValidateData

    

    protected void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

    protected void onImportHash(Object o, EventArgs e)
    {

        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDHashTitle");
        fd.Filter = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDHashMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            AssemblyLoader al = new AssemblyLoader();

            try
            {
            
                AssemblyRef ar = al.LoadAssemblyInOtherAppDomainFrom(fd.FileName);
            
                m_hHash = ar.GetHash();

                if (m_radMD5.Checked)
                    m_txtHash.Text = ByteArrayToString(m_hHash.MD5);
                else 
                    m_txtHash.Text = ByteArrayToString(m_hHash.SHA1);

                // Let them change the hash type now
                m_radMD5.Enabled = true;
                m_radSHA1.Enabled = true;
            }
            catch(Exception)
            {
                // Let's figure out why this failed...
                if (!File.Exists(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailNoFile"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailNoFileTitle"),
                               MB.ICONEXCLAMATION);
                               
                else if (!Fusion.isManaged(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailNotManaged"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailNotManagedTitle"),
                               MB.ICONEXCLAMATION);
                    
                else        
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailOther"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:HashFailOtherTitle"),
                               MB.ICONEXCLAMATION);
            }
            al.Finished();
        }
    }// onImportHash

    protected void onHashTypeChange(Object o, EventArgs e)
    {
        if (m_hHash != null)
        {
            if (m_radMD5.Checked)
                m_txtHash.Text = ByteArrayToString(m_hHash.MD5);
            else 
                m_txtHash.Text = ByteArrayToString(m_hHash.SHA1);
        }
    }// onHashTypeChange


    protected void ImportCustom(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDMCTitle");
        fd.Filter = CResourceStore.GetString("XMLFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            try
            {
                FileStream f = File.Open(fd.FileName, FileMode.Open, FileAccess.Read); 
                String sXML = new StreamReader(f).ReadToEnd();
                m_sXMLFilename = fd.FileName;
                m_txtXML.Text = sXML;
                f.Close();
            }
            catch(Exception)
            {
                if (!File.Exists(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:MCFailNoFile"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:MCFailNoFile"),
                               MB.ICONEXCLAMATION);
                  
                else        
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:MCFailOther"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:MCFailOtherTitle"),
                               MB.ICONEXCLAMATION);
            }
            // See if this is valid XML
            IMembershipCondition imc = GetCustomMembershipCondition();
            if (imc == null)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXML"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXMLTitle"),
                           MB.ICONEXCLAMATION);
            }
        }
    }// ImportCustom
    

    protected void onImportSName(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDSNTitle");
        fd.Filter = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDHashMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            AssemblyLoader al = new AssemblyLoader();
            try
            {
                // Load this assembly
                AssemblyRef ar = null;
                ar = al.LoadAssemblyInOtherAppDomainFrom(fd.FileName);
                AssemblyName an = ar.GetName();
             
                m_txtPublicKey.Text = ByteArrayToString(an.GetPublicKey());
                if (m_txtPublicKey.Text.Length == 0)
                {
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNoSN"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNoSNTitle"),
                               MB.ICONEXCLAMATION);
                    return;
                }

                    
                m_txtStrongNameName.Text = an.Name;
                m_txtStrongNameVersion.Text = an.Version.ToString();
                
            }
            catch(Exception)
            {
                // Figure out why we failed....
                if (!File.Exists(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNoFile"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNoFileTitle"),
                               MB.ICONEXCLAMATION);
                               
                else if (!Fusion.isManaged(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNotManaged"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailNotManagedTitle"),
                               MB.ICONEXCLAMATION);
                    
                else        
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailOther"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:SNFailOtherTitle"),
                               MB.ICONEXCLAMATION);
            }
            al.Finished();
        }
    }// onImportSName

    protected void onStrongNameVersionClick(Object o, EventArgs e)
    {
        m_txtStrongNameVersion.Enabled = m_chkStrongNameVersion.Checked;
    }// onStrongNameVersionClick

    protected void onStrongNameNameClick(Object o, EventArgs e)
    {
        m_txtStrongNameName.Enabled = m_chkStrongNameName.Checked;
    }// onStrongNameVersionClick

    protected void ImportFromSigned(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDPCFromFileTitle");
        fd.Filter = CResourceStore.GetString("AssemFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            AssemblyLoader al = new AssemblyLoader();
            try
            {
                // Load this assembly
                AssemblyRef ar = null;
                ar = al.LoadAssemblyInOtherAppDomainFrom(fd.FileName);
                m_x509 = ar.GetCertificate();
                if (m_x509 == null)
                {
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFromFileFailNoCert"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFromFileFailNoCertTitle"),
                               MB.ICONEXCLAMATION);
                    al.Finished();
                    return;
                }
                PutInCertificateInfo();
            }
            catch(Exception)
            {
                // Let's see if can can figure out what failed...
                if (File.Exists(fd.FileName) && !Fusion.isManaged(fd.FileName))
                    MessageBox(CResourceStore.GetString("isNotManagedCode"),
                               CResourceStore.GetString("isNotManagedCodeTitle"),
                               MB.ICONEXCLAMATION);
                else
                    MessageBox(String.Format(CResourceStore.GetString("CantLoadAssembly"), fd.FileName),
                               CResourceStore.GetString("CantLoadAssemblyTitle"),
                               MB.ICONEXCLAMATION);
            }
            al.Finished();
       }
    }// ImportFromSigned
    
    protected void ImportFromCert(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDPCTitle");
        fd.Filter = CResourceStore.GetString("Csinglecodegroupmemcondprop:FDPCMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();

        if (dr == System.Windows.Forms.DialogResult.OK)
        {

            try
            {
                m_x509 = X509Certificate.CreateFromCertFile(fd.FileName);
                PutInCertificateInfo();
            }
            catch(Exception)
            {
                // Figure out why we failed....
                if (!File.Exists(fd.FileName))
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFailNoFile"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFailNoFileTitle"),
                               MB.ICONEXCLAMATION);
                               
                else 
                    MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFailOther"),
                               CResourceStore.GetString("Csinglecodegroupmemcondprop:PCFailOtherTitle"),
                               MB.ICONEXCLAMATION);
            }
        }
    }// ImportFromCert

    private void PutInCertificateInfo()
    {
        // Let's put the certificate stuff in.
        m_dg[0,1]=(m_x509!=null)?m_x509.GetName():"";
        m_dg[1,1]=(m_x509!=null)?m_x509.GetIssuerName():"";
        m_dg[2,1]=(m_x509!=null)?m_x509.GetCertHashString():"";
    }// PutInCertificateInfo

    private IMembershipCondition GetCustomMembershipCondition()
    {
        try
        {
            // Grab the class name and create the proper membership condition;
            SecurityElement element = SecurityXMLStuff.GetSecurityElementFromXMLFile(m_sXMLFilename);

            if (element == null)
            {
                throw new Exception();
            }
            IMembershipCondition cond = null;
            Type type;
            String className = element.Attribute( "class" );

            if (className == null)
                throw new Exception();
        
            type = Type.GetType( className );

            cond = (IMembershipCondition)Activator.CreateInstance (type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);

            if (cond == null)
                throw new Exception();

            cond.FromXml( element );

            return cond;
        }
        catch(Exception)
        {
            return null;
        }
        
    }// GetCustomMembershipCondition
    
    private String ByteArrayToString(Byte[] b)
    {
        String s = "";
        String sPart;
        if (b != null)
        {
            for(int i=0; i<b.Length; i++)
            {
                sPart = b[i].ToString("X");
                // If the byte was only one character in length, make sure we add
                // a zero. We want all bytes to be 2 characters long
                if (b[i] < 0x10)
                    sPart = "0" + sPart;
                
                s+=sPart;
            }
        }
        return s;
    }// ByteArrayToString

    private Byte[] ByteStringToByteArray(String s)
    {
        Byte[] b = new Byte[s.Length/2];

        for(int i=0; i<s.Length; i+=2)
        {
            String sPart = s.Substring(i, 2);
            b[i/2] = Byte.Parse(sPart, NumberStyles.HexNumber);
        }
        return b;
    }// ByteStringToByteArray
}// class CSingleCodeGroupMemCondProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustappwiz7.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustAppWiz7.cs
//
// This class provides the Wizard page that tells the user
// that policy is tool complicated and we're not able to make any changes
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;

internal class CTrustAppWiz7 : CWizardPage
{
    // Controls on the page

    protected Label m_lblHelp;

    internal CTrustAppWiz7()
    {
        m_sTitle=CResourceStore.GetString("CTrustAppWiz7:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CTrustAppWiz7:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CTrustAppWiz7:HeaderSubTitle");

    }// CTrustAppWiz7

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTrustAppWiz7));
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblHelp});
        return 1;
    }// InsertPropSheetPageControls
}// class CTrustAppWiz7
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\customperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Net;
using System.Collections;

internal class CCustomPermDialog: CPermDialog
{
    internal CCustomPermDialog(IPermission perm) : base()
    {
        this.Text = CResourceStore.GetString("CustomPerm:PermName"); 
        m_PermControls = new CCustomPermControls(perm, this);
        Init();        
    }// CCustomPermDialog(IPermission)  
}// class CCustomPermDialog

internal class CCustomPermPropPage: CPermPropPage
{
    internal CCustomPermPropPage(IPermission perm) : base(null)
    {
        m_PermControls = new CCustomPermControls(perm, this);
        m_sTitle=CResourceStore.GetString("CustomPerm:PermName"); 
    }// CCustomPermPropPage

    internal override bool ApplyData()
    {
        return true;
    }// ApplyData

}// class CCustomPermPropPage

internal class CCustomPermControls : CPermControls
{
    // Controls on the page
    private TextBox             m_txtXML;

    internal CCustomPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            throw new Exception("Can't have null Custom Permissions");
    }// CCustomPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        m_txtXML = new TextBox();
        
        m_txtXML.Location = new Point(10, 10);
        m_txtXML.Size = new Size(330, 280);
        m_txtXML.TabIndex = 0;
        m_txtXML.TabStop = false;
        m_txtXML.Multiline = true;
        m_txtXML.ReadOnly=true;
        m_txtXML.Name = "XML";
        cc.Add(m_txtXML);

        return 1;
    }// InsertPropSheetPageControls

    protected override void PutValuesinPage()
    {
        m_txtXML.Text = m_perm.ToXml().ToString();
    }// PutValuesinPage
}// class CCustomPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ctrustedassemblies.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CTrustedAssemblies.cs
//
// This class presents the a code group node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Drawing;
using System.Collections;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.Security.Permissions;
using System.Reflection;
using System.Globalization;

class CTrustedAssemblies : CSecurityNode
{
    ArrayList   m_ol;

    private bool        m_fShowHTMLPage;
    private bool        m_fReadShowHTML;
    private CTaskPad    m_taskPad;
    
    private IntPtr      m_hTrustedIcon;
    private int         m_iTrustedIconIndex;



    internal CTrustedAssemblies(PolicyLevel pl, bool fReadOnly)
    {
        ReadOnly = fReadOnly;
        
        m_sGuid = "E519DA92-C787-4abc-BF84-60BF9CD6A7E6";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("policyassemblies_ico");  
        m_sDisplayName = CResourceStore.GetString("CTrustedAssemblies:DisplayName");
        m_aPropSheetPage = null;
        m_pl = pl;
        m_ol = null;

        m_fReadShowHTML = false;


        // Set up the icon
        m_hTrustedIcon = CResourceStore.GetHIcon("policyassembly_ico");  
        m_iTrustedIconIndex = CResourceStore.GetIconCookie(m_hTrustedIcon);

           
    }// CTrustedAssemblies


    internal override void ResultItemSelected(IConsole2 con, Object oResults)
    {
    
        IConsoleVerb icv;       
        // Get the IConsoleVerb interface from MMC
        con.QueryConsoleVerb(out icv);
        // Turn on the delete verb for the result data items
        icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, ReadOnly?0:1);
    }// ResultItemSelected

         
    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {  
        CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();

        // See if we're allowed to insert an item in the "view" section
        if (!ReadOnly && (pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {
            // Stuff common to the top menu
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            if (oResultItem == null)
            {
                newitem.strName = CResourceStore.GetString("CTrustedAssemblies:AddOption");
                newitem.strStatusBarText = CResourceStore.GetString("CTrustedAssemblies:AddOptionDes");
                newitem.lCommandID = COMMANDS.ADD_ASSEMBLY;
                // Now add this item through the callback
                piCallback.AddItem(ref newitem);

            }
        }

        // See if we can insert in the view menu
        if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_VIEW) > 0)
        {
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If we're showing the taskpad right now
            if (m_oResults is CGenericTaskPad)
            {
                newitem.strName = CResourceStore.GetString("CTrustedAssemblies:ViewAssems");
                newitem.strStatusBarText = CResourceStore.GetString("CTrustedAssemblies:ViewAssemsDes");
                newitem.lCommandID = COMMANDS.SHOW_LISTVIEW;
            }
            // Currently, we're showing the list view
            else
            {
                newitem.strName = CResourceStore.GetString("CTrustedAssemblies:ViewHTML");
                newitem.strStatusBarText = CResourceStore.GetString("CTrustedAssemblies:ViewHTMLDes");
                newitem.lCommandID = COMMANDS.SHOW_TASKPAD;
            }
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
        }



    }// AddMenuItems

    internal override void MenuCommand(int nCommandID, Object oResultItem)
    {
    
        if (nCommandID == COMMANDS.ADD_ASSEMBLY)
        {
            CFusionNoVersionDialog fd = new CFusionNoVersionDialog();
            System.Windows.Forms.DialogResult dr = fd.ShowDialog();
            if (dr == System.Windows.Forms.DialogResult.OK)
                AddAssembly(fd.Assem);
        }
    
        else if (nCommandID == COMMANDS.SHOW_LISTVIEW)
        {
            m_oResults=this;
            RefreshResultView();
            m_fShowHTMLPage=false;
        }

        else if (nCommandID == COMMANDS.SHOW_TASKPAD)
        {
            m_oResults=m_taskPad;
            m_fShowHTMLPage = true;

            // The HTML pages comes displayed with this checkbox marked. Make
            // sure we update the xml setting
            CConfigStore.SetSetting("ShowHTMLForFullTrustAssem", "yes");
            RefreshResultView();
        }


    }// MenuCommand

    internal override void Showing()
    {
        // Figure out what to display
        if (!m_fReadShowHTML)
        {
            m_taskPad = new CGenericTaskPad(this, "FULLTRUSTASSEM_HTML");
    
            m_fShowHTMLPage = ((String)CConfigStore.GetSetting("ShowHTMLForFullTrustAssem")).Equals("yes");

            if (m_fShowHTMLPage)
                m_oResults=m_taskPad;
            else
                m_oResults=this;
            m_fReadShowHTML = true;
        }
    }// Showing

    internal override int onRestoreView(MMC_RESTORE_VIEW mrv, IntPtr param)
    {
        // See if we should be displaying our HTML page or the result view
        if (mrv.pViewType == (IntPtr)0)
        {
            // We should display the column view
            m_oResults = this;
        }
        else
        {
            m_fShowHTMLPage = true;
            m_oResults = m_taskPad;
        }
        // Now we need to tell MMC we handled this.
        Marshal.WriteIntPtr(param, (IntPtr)1);
        return HRESULT.S_OK;
    }// onRestoreView

    internal override int onDelete(Object o)
    {   
        int nResultItem = (int)o - 1;
        int hr = MessageBox(String.Format(CResourceStore.GetString("CTrustedAssemblies:VerifyRemove"), ((StrongNameMembershipCondition)m_ol[nResultItem]).Name),
                            CResourceStore.GetString("CTrustedAssemblies:VerifyRemoveTitle"), 
                            MB.ICONQUESTION|MB.YESNO);
        if (hr == MB.IDYES)
        {
            StrongNameMembershipCondition snmc = (StrongNameMembershipCondition)m_ol[nResultItem];
            m_pl.RemoveFullTrustAssembly(snmc);
            SecurityPolicyChanged();
            RefreshData();
            RefreshResultView();
        }
        return HRESULT.S_OK;
    }// onDelete

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        if ((int)arg == 1) 
        {
            CConfigStore.SetSetting("ShowHTMLForFullTrustAssem", (bool)param?"yes":"no");
            m_fShowHTMLPage = (bool)param;

            // We'll change the result object but we won't refresh our result view
            // because the user doesn't necesarily want that to happen. However, 
            // the next time the user visits this node, they will see the new result
            // view
            m_oResults = m_fShowHTMLPage?(Object)m_taskPad:(Object)this;                

        }
        else if ((int)arg == 0)
        {
            m_oResults = this;
            RefreshResultView();
        }
    }// TaskPadTaskNotify

    internal override int doAcceptPaste(IDataObject ido)
    {
        // Only accept an assembly from the Shared Assemblies Node
        if (!ReadOnly && ido is CDO)
        {
            CDO cdo = (CDO)ido;
            if (cdo.Node is CSharedAssemblies)
                // Make sure we're looking at a result item
                if (cdo.Data != null)
                    // Make sure we're not trying to drag this on ourselves
                    if (cdo.Node != this)
                        return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// doAcceptPaste

    internal override int Paste(IDataObject ido)
    {
        CDO cdo = (CDO)ido;

        // See if this is coming from the Shared Assemblies node
        if (cdo.Node is CSharedAssemblies)
            AddAssembly((AssemInfo)cdo.Data);

        return HRESULT.S_OK;
    }// Paste

    internal void AddAssembly(AssemInfo asinfo)
    {
        try
        {
        // Let's create a strong name....
        byte[] baPublicKey;
        
        if (asinfo.PublicKey == null || asinfo.PublicKey.Length == 0)
        {
            // The codebase is of the form file:///c:\somefile\sdfsf
            // We need to translate it to a simple path
            Uri uCodebase = new Uri(asinfo.Codebase);
       
            // We need to load the assembly to get this info
            AssemblyLoader al = new AssemblyLoader();
            AssemblyRef ar = al.LoadAssemblyInOtherAppDomainFrom(uCodebase.AbsolutePath);
               
            AssemblyName an = ar.GetName();
            baPublicKey = an.GetPublicKey();
            al.Finished();

        }
        else
            baPublicKey = StringToByteArray(asinfo.PublicKey);
            
        StrongNamePublicKeyBlob snpkb = new StrongNamePublicKeyBlob(baPublicKey);
        StrongNameMembershipCondition snmc = new StrongNameMembershipCondition(snpkb, asinfo.Name, null);

        m_pl.AddFullTrustAssembly(snmc);
        SecurityPolicyChanged();
        RefreshData();
        RefreshResultView();
        }
        catch(Exception)
        {
            MessageBox(CResourceStore.GetString("CTrustedAssemblies:TrustAssemFail"), 
                       CResourceStore.GetString("CTrustedAssemblies:TrustAssemFailTitle"), 
                       MB.ICONEXCLAMATION);
        }
    }// AddAssembly

    private void RefreshData()
    {
        m_ol = new ArrayList();

        IEnumerator enumerator = m_pl.FullTrustAssemblies.GetEnumerator();

        // Transfer the Strong names from the Policy Level to our Array List
        while (enumerator.MoveNext())
            m_ol.Add(enumerator.Current);
       
    }// RefreshData

    //-------------------------------------------------
    // Methods to implement the IColumnResultView interface
    //-------------------------------------------------
    public override void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hTrustedIcon, m_iTrustedIconIndex);
    }// AddImages

    public override int GetImageIndex(int i)
    {
        return m_iTrustedIconIndex;
    }// GetImageIndex

    public override int getNumColumns()
    {
        // We will always have 3 columns in the result view
        return 3;
    }// getNumColumns
    public override int getNumRows()
    {
        if (m_ol == null)
            RefreshData();

        return m_ol.Count;
    }// GetNumRows

    public override String getColumnTitles(int iIndex)
    {
        String[] Titles= new String[] { CResourceStore.GetString("Assembly Name"), 
                                        CResourceStore.GetString("Public Key Token"),
                                        CResourceStore.GetString("Version"),
                                      };
        // Make sure they're in range
        if (iIndex >= 0 && iIndex< getNumColumns())
            return Titles[iIndex];
        else
            throw new Exception("Index out of bounds");
    }// getColumnTitles
    public override String getValues(int nRow, int nColumn)
    {
        if (nRow >=0 && nRow<getNumRows() && nColumn>=0 && nColumn<getNumColumns())
        {
            switch(nColumn)
            {
                case 0:
                    return ((StrongNameMembershipCondition)m_ol[nRow]).Name;
                case 1:
                    AssemblyName an = new AssemblyName();
                    an.Flags |= AssemblyNameFlags.PublicKey;
                    String sPublicKey = ((StrongNameMembershipCondition)m_ol[nRow]).PublicKey.ToString();
                    Byte[] bArray = ValueStringToByteArray(sPublicKey);
                
                    an.SetPublicKey(bArray);
                    return ByteArrayToString(an.GetPublicKeyToken());
                case 2:
                    Version v = ((StrongNameMembershipCondition)m_ol[nRow]).Version;  
                    return ((Object) v != null)?v.ToString():"";
            }
        }
        return "";
    }// getValues

    private Byte[] ValueStringToByteArray(String s)
    {
        Byte[] ba = new Byte[s.Length/2];
        for(int i=0; i<s.Length; i+=2)
            ba[i/2] = Byte.Parse(s.Substring(i, 2), NumberStyles.HexNumber);
        
        return ba;        
    }// ValueStringToByteArray
    
}// class CTrustedAssemblies
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cversionpolicytaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security;

class CVersionPolicyTaskPad : CTaskPad
{
    private bool                m_fForMachine;

    internal CVersionPolicyTaskPad(CNode n, bool fForMachine) : base(n)
    {
        m_fForMachine = fForMachine;
    }// CSinglePermSetTaskPad

     protected override String GetHTMLFilename()
    {
        return "CONFIGASSEM_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[1];

        if (m_fForMachine)
            args[0] = CResourceStore.GetString("CVersionPolicyTaskpad:ForMachine");
        else
            args[0] = CResourceStore.GetString("CVersionPolicyTaskpad:ForApp");
       
        return GetHTMLFile(args);    
    }// GetHTMLFile
}// class CVersionPolicyTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\datagridcombobox.cs ===
using System;
using System.Windows.Forms;

namespace Microsoft.CLRAdmin
{
	/// <summary>
	/// Summary description for DataGridComboBox.
	/// </summary>
	public class DataGridComboBox : ComboBox
	{
        public DataGridComboBox() {
            
            DropDownStyle = ComboBoxStyle.DropDownList;
		}


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;

internal class CWizard: CNode
{
    private int         m_nCookie;
    private IntPtr      m_hWnd;
    private IntPtr      m_pphWnd;
    private DialogProc  m_dlgHook;         // Hook to allow subclassing of a property page
    protected int       m_nParentNodeCookie;
    protected   String  m_sName;
    bool                m_fFinish;
    bool                m_fBack;
    bool                m_fNext;
    bool                m_fDisabledFinish;
   
    internal CWizard()
    {
        // Register this Wizard with the node manager
        CNode me = this;
        m_nCookie = CNodeManager.AddNode(ref me);
        // Set our Property Page Template to use that of wizards
        m_sPropPageTemplate = "IDD_WFCWRAPPERWIZARD";
        m_fFinish = false;
        m_fBack = false;
        m_fNext = false;
        m_fDisabledFinish=false;
    }// CWizard

    internal void LaunchWizard(int nParentCookie)
    {
        m_nParentNodeCookie = nParentCookie;
        // Let's hook into all the property pages that are in our wizard
        for(int i=0; i<m_aPropSheetPage.Length; i++)
            m_aPropSheetPage[i].DialogProcHook = new DialogProc(PropPageDialogProc);

        IPropertySheetProvider psp = (IPropertySheetProvider)CNodeManager.Console;
        psp.CreatePropertySheet("", 0, m_nCookie, new CDO(this), MMC_PSO.HASHELP|MMC_PSO.NEWWIZARDTYPE);
        psp.AddPrimaryPages(CNodeManager.Data, 1, 0, 1);

        m_hWnd=(IntPtr)0;
        CNodeManager.Console.GetMainWindow(out m_hWnd);
        psp.Show(m_hWnd,0);
    }// Launch Wizard

    internal virtual void TurnOnFinish(bool fOn)
    {
        m_fFinish = fOn;
        if (!fOn)
            m_fDisabledFinish = true;

        //if (fOn)
            m_fNext = false;
        DealWithButtons();
    }// TurnOnFinish

    internal void TurnOnNext(bool fOn)
    {
        m_fNext = fOn;
        m_fFinish=m_fDisabledFinish=false;
        DealWithButtons();
    }// TurnOnNext

    internal void DealWithButtons()
    {
        uint nMask=0;

        if (m_fBack)
            nMask|=PSWIZB.BACK;
        if (m_fNext)
            nMask|=PSWIZB.NEXT;
        if (m_fFinish)
            nMask|=PSWIZB.FINISH;
        if (m_fDisabledFinish)
            nMask|=PSWIZB.DISABLEDFINISH;
         
       PostMessage(GetParent(m_pphWnd), PSM.SETWIZBUTTONS, (IntPtr)0, (IntPtr)nMask);
       SetWindowLong(m_pphWnd, 0, 0);
    }

    //-------------------------------------------------
    // DialogProcHook - Property
    //
    // Allows owners/inherited property pages to insert a 
    // 'hook' to get first crack at processing dialogproc
    // messages
    //-------------------------------------------------
    internal DialogProc DialogProcHook
    {
        get
        {
            return m_dlgHook;
        }
        set
        {
            m_dlgHook = value;
        }

    }// DialogProcHook

    //-------------------------------------------------
    // PropSheetDialogProc
    //
    // This function will handle all messages coming sent
    // to the property page
    //-------------------------------------------------
    internal bool PropPageDialogProc(IntPtr hwndDlg, uint msg, IntPtr wParam, IntPtr lParam)
    {
        m_pphWnd = hwndDlg;
        
        // See if we've been subclassed...
        if (m_dlgHook != null)
            // If our hook handled the message, then we don't need to do
            // anything anymore. :)
            if (m_dlgHook(hwndDlg, msg, wParam, lParam))
                return true;
        switch (msg)
        {
            case WM.NOTIFY:

                // lParam really is a pointer to a NMHDR structure....
                NMHDR nm = new NMHDR();
                nm = (NMHDR)Marshal.PtrToStructure(lParam, nm.GetType());

                switch(nm.code)
                {   
                    case PSN.SETACTIVE:
                        SetWindowLong(hwndDlg, 0, WizSetActive(hwndDlg));
                        return true;
                    case PSN.WIZBACK:
                        SetWindowLong(hwndDlg, 0, WizBack(hwndDlg));
                        return true;
                    case PSN.WIZNEXT:

                        StartWaitCursor();
                        SetWindowLong(hwndDlg, 0, WizNext(hwndDlg));
                        EndWaitCursor();
                        
                        return true;
                    case PSN.WIZFINISH:
                        SetWindowLong(hwndDlg, 0, WizFinish(hwndDlg));
                        return true;
                }
                break;
            default:
                // We didn't handle this message
                return false;
        }
        return false;
    }// PropPageDialogProc

    protected virtual int WizSetActive(IntPtr hwnd)
    {
        if (GetPropPage(hwnd) == 0)
            m_fBack = false;
    
        DealWithButtons();
        return 0;
    }// WizSetActive

    protected virtual int WizBack(IntPtr hwnd)
    {
        if (GetPropPage(hwnd) == 0)
            m_fBack=false;
        DealWithButtons();
        return 0;
    }// WizBack

    protected virtual int WizNext(IntPtr hwnd)
    {
        if (m_aPropSheetPage[GetPropPage(hwnd)].ValidateData())
        {
            m_fBack=true;
           
            DealWithButtons();
            return 0;
        }
    
        // We had some problems with the currently displayed page. Don't let
        // the user progress to the next page
        return -1;
    }// WizNext

    protected virtual int WizFinish(IntPtr hWnd)
    {
        return WizFinish();
    }// WizFinish


    protected virtual int WizFinish()
    {
        return 0;
    }// WizFinish

    protected int GetPropPage(IntPtr hWnd)
    {
        int nCurrentPage=0;
        while(m_aPropSheetPage[nCurrentPage].hWnd != hWnd)
            nCurrentPage++;
        return nCurrentPage;
    }// GetPropPage

    [DllImport("user32.dll")]
    internal static extern int PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    internal static extern int SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);
    [DllImport("user32.dll")]
    internal static extern int SetWindowLong(IntPtr hWnd, int a, int b);
    [DllImport("user32.dll")]
    internal static extern IntPtr GetParent(IntPtr hWnd); 

}// CWizard

internal class CSecurityWizard : CWizard
{
    protected void SecurityPolicyChanged()
    {
        // Let's tell our parent that security policy changed...
        CNode node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
        if (node is CSecurityNode)
            ((CSecurityNode)node).SecurityPolicyChanged();
    }// SecurityPolicyChanged

    

}// class CSecurityWizard

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cversionpolicy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CVersionPolicy.cs
//
// This class presents a version policy node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Windows.Forms;
using System.Collections;
using System.Runtime.InteropServices;

class CVersionPolicy : CNode
{

    private class PropPagePairs
    {
        internal CPropPage[]          ppages;
        internal BindingRedirInfo     bri;
    }// struct PropPagePairs


    ArrayList m_ol;
    private String m_sConfigFile;

    private bool        m_fShowHTMLPage;
    private bool        m_fReadShowHTML;

    private CTaskPad    m_taskPad;

    private ArrayList   m_alResultPropPages;

    private IntPtr      m_hGACIcon;
    private int         m_iGACIconIndex;



    internal CVersionPolicy()
    {
        Setup(null);
    }// CVersionPolicy()
     
    internal CVersionPolicy(String sConfigFile)
    {
        Setup(sConfigFile);
    }// CVersionPolicy (String)

    private void Setup(String sConfigFile)
    {
        m_sGuid = "1F84E89D-6357-47c0-AA50-F1F438A7EA6E";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("configassemblies_ico");  
        m_oResults=this;
        DisplayName = CResourceStore.GetString("CVersionPolicy:DisplayName");
        Name = "Configured Assemblies";
        m_aPropSheetPage = null;
        m_taskPad = new CVersionPolicyTaskPad(this, sConfigFile==null);
        m_fReadShowHTML = false;

        m_ol=null;
        m_sConfigFile = sConfigFile;

        m_fAllowMultiSelectResults=true;

        m_alResultPropPages = new ArrayList();

        m_hGACIcon = CResourceStore.GetHIcon("gac_ico");  
        m_iGACIconIndex = CResourceStore.GetIconCookie(m_hGACIcon);
    }// Setup
         
    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {  
        CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();

        // See if we're allowed to insert an item in the "view" section
        if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {
            if (oResultItem == null)
            {
                // Stuff common to the top menu
                newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
                newitem.fFlags = 0;
                newitem.fSpecialFlags=0;

                newitem.strName = CResourceStore.GetString("CVersionPolicy:AddOption");
                newitem.strStatusBarText = CResourceStore.GetString("CVersionPolicy:AddOptionDes");
                newitem.lCommandID = COMMANDS.ADD_ASSEMBLY;
                // Now add this item through the callback
                piCallback.AddItem(ref newitem);
            }
        }

         // See if we can insert in the view menu
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_VIEW) > 0)
         {
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If we're showing the taskpad right now
            if (m_oResults is CVersionPolicyTaskPad)
            {
                newitem.strName = CResourceStore.GetString("CVersionPolicy:ViewAssemOption");
                newitem.strStatusBarText = CResourceStore.GetString("CVersionPolicy:ViewAssemOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_LISTVIEW;
            }
            // Currently, we're showing the list view
            else
            {
                newitem.strName = CResourceStore.GetString("CVersionPolicy:ViewHTML");
                newitem.strStatusBarText = CResourceStore.GetString("CVersionPolicy:ViewHTMLDes");
                newitem.lCommandID = COMMANDS.SHOW_TASKPAD;
            }
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
         }
    }// AddMenuItems

    internal override void MenuCommand(int iCommandID, Object oResultNum)
    {
        if (iCommandID == COMMANDS.ADD_ASSEMBLY)
        {
            CApplicationDepends appDepends = null;
            // Let's trace through our parents looking for an Application node
            CNode node = CNodeManager.GetNode(m_iCookie);
            // If this node's parent is an Application node, then we know we're
            // configuring assemblies on a per app basis
            int iParentHScope = node.ParentHScopeItem;
            if (iParentHScope != -1)
                node = CNodeManager.GetNodeByHScope(iParentHScope);
            
            // If this is an application node, make sure we tell the config store
            // about it
            if (node is CApplication)
            {
                // Cool, we have a dependent assemblies node
                appDepends = ((CApplication)node).AppDependsNode;
            }

            CConfigAssemWizard wiz = new CConfigAssemWizard(appDepends);
            wiz.LaunchWizard(Cookie);
            if (wiz.NewAssembly != null)
            {
                if (AddConfiguredAssembly(wiz.NewAssembly))
                    onDoubleClick(wiz.NewAssembly);
            }
        }
        else if (iCommandID == COMMANDS.SHOW_LISTVIEW)
        {
            m_oResults=this;
            RefreshResultView();
            m_fShowHTMLPage=false;
        }

        else if (iCommandID == COMMANDS.SHOW_TASKPAD)
        {
            m_oResults=m_taskPad;
            m_fShowHTMLPage = true;

            // The HTML pages comes displayed with this checkbox marked. Make
            // sure we update the xml setting
            CConfigStore.SetSetting("ShowHTMLForConfigAssem", "yes");
            RefreshResultView();
        }


        
     }// MenuCommand

     internal override void ResultItemSelected(IConsole2 con, Object oIndex)
     {
        IConsoleVerb icv;       
        // Get the IConsoleVerb interface from MMC
        con.QueryConsoleVerb(out icv);

        // We want to enable drag-drop actions
        icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 1);
        icv.SetVerbState(MMC_VERB.PASTE, MMC_BUTTON_STATE.ENABLED, 1);
        icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 1);
        icv.SetVerbState(MMC_VERB.CUT, MMC_BUTTON_STATE.ENABLED, 0);
    }// ResultItemSelected

    internal override int doAcceptPaste(IDataObject ido)
    {
        // Only accept an assembly from the Shared Assemblies Node
        if (ido is CDO)
        {
            CDO cdo = (CDO)ido;
            if (cdo.Node is CSharedAssemblies || cdo.Node is CVersionPolicy || cdo.Node is CApplicationDepends)
                // Make sure we're looking at a result item
                if (cdo.Data != null)
                    // Make sure we're not trying to drag this on ourselves
                    if (cdo.Node != this)
                        return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// doAcceptPaste

    private void AddAssemInfo(AssemInfo asinfo)
    {
        BindingRedirInfo bri = new BindingRedirInfo();
        bri.Name = asinfo.Name;
        bri.PublicKeyToken = asinfo.PublicKeyToken;
        AddConfiguredAssembly(bri);
    }// AddAssmInfo

    private bool isRepeatBindingRedirInfo(BindingRedirInfo bri)
    {
        int iLen = m_ol.Count;
        for(int i=0; i<iLen; i++)
        {
            BindingRedirInfo tmp = (BindingRedirInfo)m_ol[i];
            if (tmp.Name.Equals(bri.Name) && tmp.PublicKeyToken.Equals(bri.PublicKeyToken))
                return true;
        }
        return false;
    }// isRepeatBindingRedirInfo

    internal override int Paste(IDataObject ido)
    {

        CDO cdo = (CDO)ido;
        BindingRedirInfo bri = new BindingRedirInfo();

        // See if this is coming from the Shared Assemblies node
        if (cdo.Node is CSharedAssemblies)
        {
            CSharedAssemblies shared = (CSharedAssemblies)(cdo.Node);
            if (cdo.Data is AssemInfo)
                AddAssemInfo((AssemInfo)cdo.Data);
            // This is an array list... with bunches of stuff in it
            else
            {
                ArrayList al = (ArrayList)cdo.Data;
                for(int i=0; i< al.Count; i++)
                    AddAssemInfo(shared.GetAssemInfo((int)al[i] - 1));
            }
        }
        else if (cdo.Node is CApplicationDepends)
        {
            CApplicationDepends appDepends = (CApplicationDepends)(cdo.Node);
            if (cdo.Data is int)
                AddAssemInfo(appDepends.GetAssemInfo((int)cdo.Data - 1));
            // This is an array list... with bunches of stuff in it
            else
            {
                ArrayList al = (ArrayList)cdo.Data;
                for(int i=0; i< al.Count; i++)
                    AddAssemInfo(appDepends.GetAssemInfo((int)al[i] - 1));
            }


        }
        // This is coming from another Version Policy Node
        // We'll copy over all the binding policy this node has
        else
        {
            ArrayList   alStuff = new ArrayList();
            CVersionPolicy verpol = (CVersionPolicy)(cdo.Node);


            if (cdo.Data is BindingRedirInfo)
                alStuff.Add(cdo.Data);
            else
            {
                // Run through and change all the indexes to BindingRedirInfos
                ArrayList alIndexes = (ArrayList)cdo.Data;
                for(int i=0; i<alIndexes.Count; i++)
                    alStuff.Add(verpol.GetBindRedirInfo((int)alIndexes[i] - 1));
            }
        
            bool fSkipWarningDialog = false;
            for(int i=0; i<alStuff.Count; i++)
            {
                bri = (BindingRedirInfo)alStuff[i];

                // Let's see if we have this item
                bool fHaveItem=isRepeatBindingRedirInfo(bri);

                bool fAddItem = !fHaveItem;
                if (fHaveItem && !fSkipWarningDialog)
                {
                    String sMessageText = "";
                    if (alStuff.Count == 1)
                        sMessageText = String.Format(CResourceStore.GetString("CVersionPolicy:ConfigInfoExistsForOneAssem"), bri.Name);
                    else
                        sMessageText = CResourceStore.GetString("CVersionPolicy:ConfigInfoExists");

                    int hr = MessageBox(sMessageText,
                                        CResourceStore.GetString("CVersionPolicy:ConfigInfoExistsTitle"),
                                        MB.ICONQUESTION|MB.YESNO);
                    if (hr == MB.IDYES)
                        fAddItem=true;
                    fSkipWarningDialog = fAddItem;
                }

                if (fAddItem)
                {
                    // Set up some strings we need
                    String sFirstPartOfBinding = "BindingPolicyFor" + bri.Name + "," + bri.PublicKeyToken;
                    String sFirstPartOfCodebase =  "CodeBasesFor" + bri.Name + "," + bri.PublicKeyToken;           
                    String sFirstPartOfPubPol = "PublisherPolicyFor" + bri.Name + "," + bri.PublicKeyToken;

                    // If we are getting and writing this to an App config file, 
                    // let's add that info
                    String sSecondPartOnIncoming = "";
                    if (verpol.m_sConfigFile != null)
                        sSecondPartOnIncoming = "," + verpol.m_sConfigFile;

                    String sSecondPartOnDest = "";
                    if (m_sConfigFile != null)
                        sSecondPartOnDest += "," + m_sConfigFile;

                    AddConfiguredAssembly(bri);

                    //--------------------------------------------
                    // First, read the stuff from the config store
                    //--------------------------------------------
                    // First get the binding policy
                    String sGetSettingString = sFirstPartOfBinding + sSecondPartOnIncoming;
                    BindingPolicy bp = (BindingPolicy)CConfigStore.GetSetting(sGetSettingString);

                    // Now get the codebase info
                    sGetSettingString = sFirstPartOfCodebase + sSecondPartOnIncoming;
                    CodebaseLocations cbl = (CodebaseLocations)CConfigStore.GetSetting(sGetSettingString);

                    sGetSettingString = sFirstPartOfPubPol + sSecondPartOnIncoming;
                    bool fPubPolicy = (bool)CConfigStore.GetSetting(sGetSettingString);


                    //---------------------------------------------
                    // Now let's write this stuff to our config file
                    //---------------------------------------------
                
                    // First write the binding policy
                    String sSetSettingString = sFirstPartOfBinding + sSecondPartOnDest;
                    if (!CConfigStore.SetSetting(sSetSettingString, bp))
                        return HRESULT.S_FALSE;

                    // Now Set the codebase info
                    sSetSettingString = sFirstPartOfCodebase + sSecondPartOnDest;
                    if (!CConfigStore.SetSetting(sSetSettingString, cbl))
                        return HRESULT.S_FALSE;

                    sSetSettingString = sFirstPartOfPubPol + sSecondPartOnDest;
                    if (!CConfigStore.SetSetting(sSetSettingString, fPubPolicy))
                        return HRESULT.S_FALSE;

                }
            }// for loop
        }// coming from another version policy node


        return HRESULT.S_OK;
    }// Paste

    internal override int onDoubleClick(Object o)
    {
        if (o != null)
        {
            
            BindingRedirInfo bri = (BindingRedirInfo)o;
            CDO cdo = new CDO(this);
            cdo.Data = o;
            OpenMyResultPropertyPage(bri.Name, cdo);

            return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
     }// onDoubleClick

    

    internal override int onDelete(Object o)
    {   
        String sMessage;
        if (o is ArrayList)
            sMessage = CResourceStore.GetString("CVersionPolicy:ConfirmDeleteConfig");
        else
            sMessage = String.Format(CResourceStore.GetString("CVersionPolicy:ConfirmDeleteSingleConfig"), ((BindingRedirInfo)o).Name);

        int nRes = MessageBox(sMessage,
                              CResourceStore.GetString("CVersionPolicy:ConfirmDeleteConfigTitle"),
                              MB.ICONQUESTION|MB.YESNO);


        if (nRes == MB.IDYES)
        {
            // Let's trace through our parents looking for an Application node
            CNode node = CNodeManager.GetNode(m_iCookie);
            // If this node's parent is an Application node, then we know we're
            // configuring assemblies on a per app basis
            int iParentHScope = node.ParentHScopeItem;
            if (iParentHScope != -1)
                node = CNodeManager.GetNodeByHScope(iParentHScope);
            
            String sPostFix="";
            // If this is an application node, make sure we tell the config store
            // about it
            if (node is CApplication)
                sPostFix = "," + ((CApplication)node).AppConfigFile;

            if (o is ArrayList)
            {
                ArrayList al = (ArrayList)o;
                int nLen = al.Count;
                for(int i=0; i<nLen; i++)
                {
                    int iResultNum = ((int)al[i])-1;
                
                    CConfigStore.SetSetting("ConfiguredAssembliesDelete" + sPostFix, ((BindingRedirInfo)m_ol[iResultNum])); 
                }
            }
            else
            {
                CConfigStore.SetSetting("ConfiguredAssembliesDelete" + sPostFix, (BindingRedirInfo)o); 
            }
            // Now we'll Refresh ourselves
            RefreshResultView();            
        }
        return HRESULT.S_OK;
    }// onDelete

    internal override void Showing()
    {
        if (!m_fReadShowHTML)
        {
        
            m_fShowHTMLPage = ((String)CConfigStore.GetSetting("ShowHTMLForConfigAssem")).Equals("yes");

            if (m_fShowHTMLPage)
                m_oResults=m_taskPad;
            else
                m_oResults=this;
                
            m_fReadShowHTML = true;
        }
    }// Showing

    internal override int onRestoreView(MMC_RESTORE_VIEW mrv, IntPtr param)
    {
        // See if we should be displaying our HTML page or the result view
        if (mrv.pViewType == (IntPtr)0)
        {
            // We should display the column view
            m_oResults = this;
        }
        else
        {
            m_fShowHTMLPage = true;
            m_oResults = m_taskPad;
        }
        // Now we need to tell MMC we handled this.
        Marshal.WriteIntPtr(param, (IntPtr)1);
        return HRESULT.S_OK;
    }// onRestoreView



    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        if ((int)arg == 1) 
        {
            CConfigStore.SetSetting("ShowHTMLForConfigAssem", (bool)param?"yes":"no");
            m_fShowHTMLPage = (bool)param;

            // We'll change the result object but we won't refresh our result view
            // because the user doesn't necesarily want that to happen. However, 
            // the next time the user visits this node, they will see the new result
            // view
            m_oResults = m_fShowHTMLPage?(Object)m_taskPad:(Object)this;                

        }
        else if ((int)arg == 0)
        {
            m_oResults = this;
            RefreshResultView();
        }
        else if ((int)arg == 2)
            MenuCommand(COMMANDS.ADD_ASSEMBLY, null);   
    }// TaskPadTaskNotify




    internal bool AddConfiguredAssembly(BindingRedirInfo bri)
    {
        // Let's trace through our parents looking for an Application node
        // If this node's parent is an Application node, then we know we're
        // configuring assemblies on a per app basis
        CNode node=null;
        if (ParentHScopeItem != -1)
            node = CNodeManager.GetNodeByHScope(ParentHScopeItem);
            
        String sPostFix="";
        // If this is an application node, make sure we tell the config store
        // about it
        if (node is CApplication)
            sPostFix = "," + ((CApplication)node).AppConfigFile;

        if (!CConfigStore.SetSetting("ConfiguredAssemblies" + sPostFix, bri))
            return false;

        // Now we'll tell out node to Refresh itself,
        // but only if we're showing the list view
        if (m_oResults == this)
            RefreshResultView();

        return true;
    }// AddConfiguredAssembly

    
    internal String ConfigFile
    {
        get
        {
            return m_sConfigFile;
        }
    }// ConfigFile

    internal override bool ResultQDO(int nCookie, out Object o)
    {
        o = GetBindRedirInfo((int)((nCookie & 0xFFFF0000) >> 16) - 1);
        // This was only successful if we actually got a binding info returned
        return (o != null);
    }// ResultQDO

    internal override bool ResultCompareObjects(Object o1, Object o2, out bool fEqual)
    {
        if (o1 is BindingRedirInfo && o2 is BindingRedirInfo)
        {
            fEqual = CompareBindingRedirInfo((BindingRedirInfo)o1, (BindingRedirInfo)o2);
            return true;
        }
        MessageBox("Ack. I'm in ResultCompareObjects and they aren't BindingRedirInfos!", "", 0);
        fEqual = false;
        return false;
    }// ResultCompareObjects

    internal BindingRedirInfo GetBindRedirInfo(int iIndex)
    {
        if (m_ol != null)
        {
            if (m_ol.Count > iIndex)
                return (BindingRedirInfo)m_ol[iIndex];
            else
                return null;
        }
        throw new Exception("I don't have any BindingRedirInfo");
    }// GetBindRedirInfo

    private bool CompareBindingRedirInfo(BindingRedirInfo b1, BindingRedirInfo b2)
    {
        // We won't compare the two bools in this class, since the class is identified
        // by its name and internal key token members

        if (!b1.Name.Equals(b2.Name))
            return false;

        if (b1.PublicKeyToken == null && b2.PublicKeyToken == null)
            return true;
            
        if (b1.PublicKeyToken != null && b1.PublicKeyToken.Equals(b2.PublicKeyToken))
            return true;

        return false;
    }// CompareBindingRedirInfo


    internal override void RefreshResultView()
    {
        if (m_sConfigFile == null)
            m_ol=(ArrayList)CConfigStore.GetSetting("ConfiguredAssemblies");
        else
            m_ol=(ArrayList)CConfigStore.GetSetting("ConfiguredAssemblies," + m_sConfigFile);

        base.RefreshResultView();
    }// RefreshResultView

    //-------------------------------------------------
    // Methods to implement the IColumnResultView interface
    //-------------------------------------------------
    public override int getNumColumns()
    {
        // We will always have 4 columns in the result view
        return 4;
    }// getNumColumns
    public override int getNumRows()
    {
        if (m_ol == null)
        {
            if (m_sConfigFile == null)
                m_ol=(ArrayList)CConfigStore.GetSetting("ConfiguredAssemblies");
            else
                m_ol=(ArrayList)CConfigStore.GetSetting("ConfiguredAssemblies," + m_sConfigFile);
        }
        return m_ol.Count;
    }// GetNumRows

    public override String getColumnTitles(int iIndex)
    {
        String[] Titles= new String[] { CResourceStore.GetString("Assembly Name"), 
                                        CResourceStore.GetString("Public Key Token"),
                                        CResourceStore.GetString("CVersionPolicy:HasBindingPolicyColumn"),
                                        CResourceStore.GetString("CVersionPolicy:HasCodebaseColumn"),
                                      };
        // Make sure they're in range
        if (iIndex >= 0 && iIndex< getNumColumns())
            return Titles[iIndex];
        else
            throw new Exception("Index out of bounds");
    }// getColumnTitles
    public override String getValues(int nRow, int nColumn)
    {
        // Verify that the row they're checking exists
        if (m_ol.Count <=nRow)
            return "";
            
        switch(nColumn)
        {
            case 0:
                return ((BindingRedirInfo)m_ol[nRow]).Name;
            case 1:
                return ((BindingRedirInfo)m_ol[nRow]).PublicKeyToken;
            case 2:
                return ((BindingRedirInfo)m_ol[nRow]).fHasBindingPolicy?CResourceStore.GetString("Yes"):CResourceStore.GetString("No");
            case 3:
                return ((BindingRedirInfo)m_ol[nRow]).fHasCodebase?CResourceStore.GetString("Yes"):CResourceStore.GetString("No");
        }
        return null;
    }// getValues

    public override void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hGACIcon, m_iGACIconIndex);
    }// AddImages
    public override int GetImageIndex(int i)
    {
        return m_iGACIconIndex;
    }// GetImageIndex

    internal override bool DoesResultHavePropertyPage(Object o)
    {
        // We only have property pages if one item is selected
        if (o is BindingRedirInfo)
            return true;
        else
            return false;
    }// DoesResultHavePropPage

    public override CPropPage[] CreateNewPropPages(Object o)
    {   
        return GetPropertyPages((BindingRedirInfo)o);
    }// ApplyPropPages

    private CPropPage[] GetPropertyPages(BindingRedirInfo bri)
    {
        // Let's see if we already have an entry for this assemby item
        int nLen = m_alResultPropPages.Count;
        for(int i=0; i<nLen; i++)
            if (CompareBindingRedirInfo(((PropPagePairs)m_alResultPropPages[i]).bri, bri))
                return ((PropPagePairs)m_alResultPropPages[i]).ppages;

        // If we're here, then we have a new property page to add
        PropPagePairs ppp = new PropPagePairs();
        ppp.ppages = new CPropPage[] { new CConfigAssemGeneralProp(bri), new CAssemBindPolicyProp(bri), new CAssemVerCodebases(bri)};
        ppp.bri = bri;
        m_alResultPropPages.Add(ppp);
        return ppp.ppages;
    }// GetPropertyPages



    
}// class CVersionPolicy
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\dnsperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Net;

internal class CDNSPermDialog: CPermDialog
{
    internal CDNSPermDialog(DnsPermission perm)
    {
        this.Text = CResourceStore.GetString("Dnsperm:PermName");

        m_PermControls = new CDNSPermControls(perm, this);
        Init();        
    }// CDNSPermDialog  
 }// class CDNSPermDialog

internal class CDNSPermPropPage: CPermPropPage
{
    internal CDNSPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("Dnsperm:PermName"); 
    }// CDNSPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(DnsPermission));
        m_PermControls = new CDNSPermControls(perm, this);
    }// CreateControls

    
}// class CDNSPermPropPage


internal class CDNSPermControls : CPermControls
{
    // Controls on the page
    private Label m_lblNoDNSDescription;

    internal CDNSPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new DnsPermission(PermissionState.None);
    }// CDNSPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CDNSPermControls));
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_lblNoDNSDescription = new System.Windows.Forms.Label();
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radNoAccess.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radNoAccess.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radNoAccess.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radNoAccess.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_lblNoDNSDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblNoDNSDescription.Location")));
        this.m_lblNoDNSDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblNoDNSDescription.Size")));
        this.m_lblNoDNSDescription.TabIndex = ((int)(resources.GetObject("m_lblNoDNSDescription.TabIndex")));
        this.m_lblNoDNSDescription.Text = resources.GetString("m_lblNoDNSDescription.Text");
        m_lblNoDNSDescription.Name = "NoDNSDescription";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblNoDNSDescription,
                        this.m_radUnrestricted,
                        this.m_radGrantFollowingPermission});

        // Fill in the data
        PutValuesinPage();

        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);

        return 1;
    }// InsertPropSheetPageControls

    protected override void PutValuesinPage()
    {
        if (((DnsPermission)m_perm).IsUnrestricted())
            m_radUnrestricted.Checked=true;
        else
            m_radGrantFollowingPermission.Checked=true;
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        DnsPermission perm;
        if (m_radUnrestricted.Checked == true)
            perm = new DnsPermission(PermissionState.Unrestricted);
        else
            perm = new DnsPermission(PermissionState.None);

        return perm;
    }// GetCurrentPermissions
}// class CUIPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\datagridcomboboxcolumnstyle.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;

namespace Microsoft.CLRAdmin {
	/// <summary>
	/// A sample DataGrid ComboBox column
	/// </summary>
	public class DataGridComboBoxColumnStyle : DataGridColumnStyle	{

        // UI Constants
        private int              xMargin =           2;
        private int              yMargin =           1;
        private DataGridComboBox combo;

        // Used to track editing state
        private string oldValue = null;
        private bool   inEdit   = false;

        /// <summary>
        ///     Create a new column
        /// </summary>
        public DataGridComboBoxColumnStyle() {
            combo = new DataGridComboBox();
            combo.Visible = false;
        }


        //----------------------------------------------------------
        //Properties to allow us to set up the datasource for the ComboBox
        //----------------------------------------------------------

        /// <summary>
        ///     The DataSource for values to display in the ComboBox
        /// </summary>
        public object DataSource {
/*            get {
                return combo.DataSource;
            }
*/
              set {
                    DataGridComboBoxEntry[] entries = (DataGridComboBoxEntry[])value;

                    for(int i=0; i<entries.Length; i++)
                        combo.Items.Add(entries[i].Value);
  
                //                combo.DataSource = value;
                }
        }

        public ComboBox ComboBox
        {
            get{return combo;}
        }
     
        //----------------------------------------------------------
        //Methods overridden from DataGridColumnStyle
        //----------------------------------------------------------

        protected override void Abort(int rowNum)  {
            RollBack();
            HideComboBox();
            EndEdit();
        }


        protected override bool Commit(CurrencyManager dataSource, int rowNum) { 

            HideComboBox();

            //If we are not in an edit then simply return
            if (!inEdit) {
                return true; 
            }

            try {
                String s = combo.Text;
                SetColumnValueAtRow(dataSource, rowNum, s);
            }
            catch (Exception) {
                RollBack();
                return false;
            }
            EndEdit();
            return true;

        }


        protected override void ConcedeFocus() {
            combo.Visible = false;
        }


        protected override void Edit(CurrencyManager source,
            int rowNum,
            Rectangle bounds,
            bool readOnly,
            string instantText,
            bool cellIsVisible) {

            combo.Text = "" ;

            Rectangle originalBounds = bounds;

            combo.SelectedIndex = FindSelectedIndex(GetText(GetColumnValueAtRow(source, rowNum)));
            
            if (instantText != null) {
                combo.SelectedIndex = FindSelectedIndex(instantText);
            }

            oldValue = combo.Text;

            if (cellIsVisible) {
                bounds.Offset(xMargin, yMargin);
                bounds.Width  -= xMargin*2;
                bounds.Height -= yMargin;
                combo.Bounds = bounds;

                combo.Visible = true;
            }
            else {
                combo.Bounds = originalBounds;
                combo.Visible = false;
            }

            combo.RightToLeft = this.DataGridTableStyle.DataGrid.RightToLeft;

            combo.Focus();
            
            if (instantText == null)
                combo.SelectAll();
            else {
                int end = combo.Text.Length;
                combo.Select(end, 0);
            }

            if (combo.Visible) {
                DataGridTableStyle.DataGrid.Invalidate(originalBounds);
            }

            inEdit = true;
        }

        private int FindSelectedIndex(String sText)
        {
            for(int i=0; i<combo.Items.Count; i++)
            {
                if (((String)combo.Items[i]).Equals(sText))
                    return i;
            }

            return -1;
        }// FindSelectedIndex

        protected override int GetMinimumHeight() {
            //Set the minimum height to the height of the combobox
            return combo.PreferredHeight + yMargin;
        }


        protected override int GetPreferredHeight(Graphics g, object value)  {
            int newLineIndex = 0;
            int newLines = 0;
            string valueString = this.GetText(value);
            while (newLineIndex != -1 ) {
                newLineIndex = valueString.IndexOf("\r\n", newLineIndex + 1);
                newLines ++;
            }

            return FontHeight * newLines + yMargin;
        }

        protected override Size GetPreferredSize(Graphics g, object value) {
            Size extents = Size.Ceiling(g.MeasureString(GetText(value), this.DataGridTableStyle.DataGrid.Font));
            extents.Width += xMargin*2 + DataGridTableGridLineWidth;
            extents.Height += yMargin;
            return extents;
        }

        
        protected override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum) {
            Paint(g, bounds, source, rowNum, false);
        }

        protected override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum, bool alignToRight) {
            //NOTE: Text to paint should really be driven off 
            //      DisplayMember/ValueMember for Combo-box
            string text = GetText(GetColumnValueAtRow(source, rowNum));
            PaintText(g, bounds, text, alignToRight);
        }

        protected override void Paint(Graphics g, Rectangle bounds, CurrencyManager source, int rowNum,
            Brush backBrush, Brush foreBrush, bool alignToRight) {
            string text = GetText(GetColumnValueAtRow(source, rowNum));
            PaintText(g, bounds, text, backBrush, foreBrush, alignToRight);
        }

        protected override void SetDataGridInColumn(DataGrid value) {
            base.SetDataGridInColumn(value);
            if (combo.Parent != value) {
                if (combo.Parent != null) {
                    combo.Parent.Controls.Remove(combo);
                }
            }
            if (value != null) {
                value.Controls.Add(combo);
            }

        }

        protected override void UpdateUI(CurrencyManager source, int rowNum, string instantText) {
            combo.Text = GetText(GetColumnValueAtRow(source, rowNum));
            if (instantText != null) {
                combo.Text = instantText;
            }
        }



        //----------------------------------------------------------
        //Helper Methods 
        //----------------------------------------------------------


        private int DataGridTableGridLineWidth {
            get {
                return this.DataGridTableStyle.GridLineStyle == DataGridLineStyle.Solid ? 1 : 0;
            }
        }

        private void EndEdit() {
            inEdit = false;
            Invalidate();
        }

        private string GetText(object value) {
            if (value is System.DBNull) {
                return NullText;
            }
            return(value != null ? value.ToString() : "");
        }

        private void HideComboBox() {
            if (combo.Focused) {
                this.DataGridTableStyle.DataGrid.Focus();
            }
            combo.Visible = false;
        }

        private void RollBack() {
            combo.Text = oldValue;
        }

        private void PaintText(Graphics g, Rectangle bounds, string text, bool alignToRight) {
            Brush backBrush = new SolidBrush(this.DataGridTableStyle.BackColor);
            Brush foreBrush = new SolidBrush(this.DataGridTableStyle.ForeColor);
            PaintText(g, bounds, text, backBrush, foreBrush, alignToRight);
        }

        private void PaintText(Graphics g, Rectangle textBounds, string text, Brush backBrush, Brush foreBrush, bool alignToRight) {

            Rectangle rect = textBounds;

            StringFormat format = new StringFormat();
            if (alignToRight) {
                format.FormatFlags |= StringFormatFlags.DirectionRightToLeft;
            }

            format.Alignment = this.Alignment == HorizontalAlignment.Left ? StringAlignment.Near : this.Alignment == HorizontalAlignment.Center ? StringAlignment.Center : StringAlignment.Far;

            format.FormatFlags |= StringFormatFlags.NoWrap;

            g.FillRectangle(backBrush, rect);

            // by design, painting  leaves a little padding around the rectangle.
            // so do not deflate the rectangle.
            rect.Offset(0,yMargin);
            rect.Height -= yMargin;
            g.DrawString(text, this.DataGridTableStyle.DataGrid.Font, foreBrush, rect, format);
            format.Dispose();
        }

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(IntPtr hWnd, String Message, String Header, uint type);


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\directoryservicesperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.DirectoryServices;

internal class CDirectoryServicesPermDialog: CPermDialog
{
    internal CDirectoryServicesPermDialog(DirectoryServicesPermission perm)
    {
        this.Text = CResourceStore.GetString("DirectoryServicesPerm:PermName");
        m_PermControls = new CDirectoryServicesPermControls(perm, this);
        Init();        
    }// CDirectoryServicesPermDialog  
}// class CDirectoryServicesPermDialog

internal class CDirectoryServicesPermPropPage: CPermPropPage
{
    internal CDirectoryServicesPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("DirectoryServicesPerm:PermName"); 
    }// CDirectoryServicesPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(DirectoryServicesPermission));
        m_PermControls = new CDirectoryServicesPermControls(perm, this);
    }// CreateControls
   
}// class CDirectoryServicesPermPropPage


internal class CDirectoryServicesPermControls : CTablePermControls
{

    internal CDirectoryServicesPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new DirectoryServicesPermission(PermissionState.None);
    }// CDirectoryServicesPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Path" Column
        DataColumn dcPath = new DataColumn();
        dcPath.ColumnName = "Path";
        dcPath.DataType = typeof(String);
        dt.Columns.Add(dcPath);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);

       
        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcPath = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle();

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Host column
        dgtbcPath.MappingName = "Path";
        dgtbcPath.HeaderText = CResourceStore.GetString("DirectoryServicesPermission:Path");
        dgtbcPath.Width = ScaleWidth(CResourceStore.GetInt("DirectoryServicesPerm:PathColumnWidth"));
        dgtbcPath.NullText = "";
        dgtbcPath.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcPath);

        // Set up the column info for the Port column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("DirectoryServicesPermission:Access");
        dgccAccess.NullText = "";
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("DirectoryServicesPerm:AccessColumnWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("DirectoryServicesPermission:Browse")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("DirectoryServicesPermission:Write"))
                                                };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);


        dgts.GridColumnStyles.Add(dgccAccess);

        return dt;
    }// CreateDataTable

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("DirectoryServicesPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("DirectoryServicesPerm:GrantFollowing");

        DirectoryServicesPermission perm = (DirectoryServicesPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.PermissionEntries.GetEnumerator();
            while (enumer.MoveNext())
            {
                DirectoryServicesPermissionEntry dspp = (DirectoryServicesPermissionEntry)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();
                newRow["Path"]=dspp.Path;
                
                String sAccessString = "";
                if (dspp.PermissionAccess == DirectoryServicesPermissionAccess.Browse)
                    sAccessString = CResourceStore.GetString("DirectoryServicesPermission:Browse");
                else if (dspp.PermissionAccess == DirectoryServicesPermissionAccess.Write)
                    sAccessString = CResourceStore.GetString("DirectoryServicesPermission:Write");
                else 
                    sAccessString = CResourceStore.GetString("<unknown>");
               
                newRow["Access"]=new DataGridComboBoxEntry(sAccessString);
                m_dt.Rows.Add(newRow);
            }
          
        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Path"]="";
        newRow["Access"]=CResourceStore.GetString("DirectoryServicesPermission:Browse");
           
        dt.Rows.Add(newRow);
    }// AddEmptyRow


    internal override IPermission GetCurrentPermission()
    {
    
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);


        DirectoryServicesPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new DirectoryServicesPermission(PermissionState.Unrestricted);
        else
        {
            perm = new DirectoryServicesPermission(PermissionState.None);
            
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a socket permission to add
                if (m_dg[i, 0] is String && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sPath = (String)m_dg[i, 0];
                
                    DirectoryServicesPermissionAccess dspa;
                    
                    if (((String)m_dg[i, 1]).Equals(CResourceStore.GetString("DirectoryServicesPermission:Browse")))
                        dspa = DirectoryServicesPermissionAccess.Browse;
                    else
                        dspa = DirectoryServicesPermissionAccess.Write;

                    perm.PermissionEntries.Add(new DirectoryServicesPermissionEntry(dspa, sPath));        
                }
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox

        if (m_dg[iSelRow, 1] == DBNull.Value)
            m_dg[iSelRow, 1] = CResourceStore.GetString("DirectoryServicesPermission:Browse");
                
        ActivateApply();
      
    }// onClick
}// class CDirectoryServicesPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\environmentperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;

internal class CEnvPermDialog: CPermDialog
{
    internal CEnvPermDialog(EnvironmentPermission perm)
    {
        this.Text = CResourceStore.GetString("EnvironmentPerm:PermName");

        m_PermControls = new CEnvPermControls(perm, this);
        Init();        
    }// CEnvPermDialog  
}// class CEnvPermDialog

internal class CEnvPermPropPage: CPermPropPage
{
    internal CEnvPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("EnvironmentPerm:PermName"); 
    }// CEnvPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(EnvironmentPermission));
        m_PermControls = new CEnvPermControls(perm, this);
    }// CreateControls
   
}// class CEnvPermPropPage


internal class CEnvPermControls : CTablePermControls
{
    internal CEnvPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        if (perm == null)
            m_perm = new EnvironmentPermission(PermissionState.None);

    
    }// CEnvPermControls

    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Variable" Column
        DataColumn dcVariable = new DataColumn();
        dcVariable.ColumnName = "Variable";
        dcVariable.DataType = typeof(String);
        dt.Columns.Add(dcVariable);

        // Create the "Read" Column
        DataColumn dcRead = new DataColumn();
        dcRead.ColumnName = "Read";
        dcRead.DataType = typeof(bool);
        dt.Columns.Add(dcRead);


        // Create the "Write" Column
        DataColumn dcWrite = new DataColumn();
        dcWrite.ColumnName = "Write";
        dcWrite.DataType = typeof(bool);
        dt.Columns.Add(dcWrite);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridBoolColumn dgbcRead = new DataGridBoolColumn();
        DataGridBoolColumn dgbcWrite = new DataGridBoolColumn();
        DataGridTextBoxColumn dgtbcVariable = new DataGridTextBoxColumn();
         
        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Variable column
        dgtbcVariable.MappingName = "Variable";
        dgtbcVariable.HeaderText = CResourceStore.GetString("EnvironmentPermission:Variable");
        dgtbcVariable.Width = ScaleWidth(CResourceStore.GetInt("EnvironmentPerm:VariableColumnWidth"));
        dgtbcVariable.NullText = "";
        dgtbcVariable.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcVariable);

        // Set up the column info for the Read column
        dgbcRead.MappingName = "Read";
        dgbcRead.HeaderText = CResourceStore.GetString("EnvironmentPermission:Read");
        dgbcRead.AllowNull = false;
        dgbcRead.Width = ScaleWidth(CResourceStore.GetInt("EnvironmentPerm:ReadColumnWidth"));
        dgbcRead.NullValue = false;
        dgbcRead.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcRead);

        // Set up the column info for the Write column
        dgbcWrite.MappingName = "Write";
        dgbcWrite.HeaderText = CResourceStore.GetString("EnvironmentPermission:Write");
        dgbcWrite.AllowNull = false;
        dgbcWrite.Width = ScaleWidth(CResourceStore.GetInt("EnvironmentPerm:WriteColumnWidth"));
        dgbcWrite.NullValue = false;
        dgbcWrite.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcWrite);

        return dt;
    }// CreateDataTable
    
    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("EnvironmentPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("EnvironmentPerm:GrantFollowing");

        EnvironmentPermission perm = (EnvironmentPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            
            StringCollection scReadVars = new StringCollection();
            StringCollection scWriteVars = new StringCollection();
            StringCollection scAllVars = new StringCollection();
    
            // Get the environment variables the user has access to
            String sReads = perm.GetPathList(EnvironmentPermissionAccess.Read);
            if (sReads != null && sReads.Length > 0)
                scReadVars.AddRange(sReads.Split(new char[] {';'}));

            String sWrites = perm.GetPathList(EnvironmentPermissionAccess.Write);
            if (sWrites != null && sWrites.Length > 0)
                scWriteVars.AddRange(sWrites.Split(new char[] {';'})); 

            // Intersect these to find those variables that can be both read and written
            scAllVars = PathListFunctions.IntersectCollections(ref scReadVars, ref scWriteVars);

            StringCollection[] scCollections = new StringCollection[] {scReadVars, scWriteVars, scAllVars};

            // Ok, let's add these items to our grid
            for(int i=0; i<scCollections.Length; i++)
            {   
                for(int j=0; j<scCollections[i].Count; j++)
                {
                    DataRow newRow = m_dt.NewRow();
                    newRow["Variable"]=scCollections[i][j];
                    newRow["Read"]= (i==0 || i==2);
                    newRow["Write"]= (i==1 || i==2);
                    m_dt.Rows.Add(newRow);
                }
            }
        }

        // We want at least 1 rows so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage
    
    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Variable"]="";
        newRow["Read"]=false;
        newRow["Write"]=false;
        dt.Rows.Add(newRow);
    }// AddEmptyRow


    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);


        EnvironmentPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new EnvironmentPermission(PermissionState.Unrestricted);
        else
        {
            perm = new EnvironmentPermission(PermissionState.None);

            StringCollection scRead = new StringCollection();
            StringCollection scWrite = new StringCollection();
            StringCollection scAll = new StringCollection();
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have an environment permission to add
                if (m_dg[i, 0] is String && ((String)m_dg[i, 0]).Length > 0)
                {
                    // Does this variable have all permissions?
                    if ((bool)m_dg[i, 1] && (bool)m_dg[i, 2])
                        scAll.Add((String)m_dg[i, 0]);
                    // Does this variable have read permissions
                    else if ((bool)m_dg[i, 1])
                        scRead.Add((String)m_dg[i, 0]);
                    // This must have write permissions
                    else if ((bool)m_dg[i, 2])
                        scWrite.Add((String)m_dg[i, 0]);
                }
                else
                {
                    // Make sure they didn't check any boxes and not include
                    // an empty path
                    bool fCheckedBox = false;
                    for(int j=1; j<=2 && !fCheckedBox; j++)
                        fCheckedBox = (bool)m_dg[i, j];

                    if (fCheckedBox)
                    {            
                        MessageBox(CResourceStore.GetString("EnvironmentPerm:NeedEnvName"),
                                   CResourceStore.GetString("EnvironmentPerm:NeedEnvNameTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;    
                    }
                   }
            }
                
           
            String sAdd = PathListFunctions.JoinStringCollection(scRead);
            if (sAdd.Length > 0)
                perm.AddPathList(EnvironmentPermissionAccess.Read, sAdd);

            String sWrite = PathListFunctions.JoinStringCollection(scWrite);
            if (sWrite.Length > 0)
                perm.AddPathList(EnvironmentPermissionAccess.Write, sWrite);

            String sAll = PathListFunctions.JoinStringCollection(scAll);
            if (sAll.Length > 0)
                perm.AddPathList(EnvironmentPermissionAccess.AllAccess, sAll);

        }
        return perm;
    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        for(int i=1; i<3; i++)
            if (m_dg[iSelRow, i] == DBNull.Value)
                m_dg[iSelRow, i]=false;
        
        ActivateApply();
    }// onClick

 
}// class CEnvPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\eventlogpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;

internal class CEventLogPermDialog: CPermDialog
{
    
    internal CEventLogPermDialog(EventLogPermission perm)
    {
        this.Text = CResourceStore.GetString("EventLogPermission:PermName");

        m_PermControls = new CEventLogPermControls(perm, this);
        Init();        
     }// CEventLogPermDialog  
}// class CEventLogPermDialog

internal class CEventLogPermPropPage: CPermPropPage
{

    internal CEventLogPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("EventLogPermission:PermName"); 
    }// CEventLogPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(EventLogPermission));
        m_PermControls = new CEventLogPermControls(perm, this);
    }// CreateControls
    
}// class CEventLogPermPropPage

internal class CEventLogPermControls : CTablePermControls
{

    internal CEventLogPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new EventLogPermission(PermissionState.None);
    }// CEventLogPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Machine Name" Column
        DataColumn dcMachine = new DataColumn();
        dcMachine.ColumnName = "Machine";
        dcMachine.DataType = typeof(String);
        dt.Columns.Add(dcMachine);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);

       
        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcMachine = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle();

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Machine column
        dgtbcMachine.MappingName = "Machine";
        dgtbcMachine.HeaderText = CResourceStore.GetString("EventLogPermission:Machine");
        dgtbcMachine.Width = ScaleWidth(CResourceStore.GetInt("EventLogPermission:MachineColumnWidth"));
        dgtbcMachine.NullText = "";
        dgtbcMachine.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcMachine);

        // Set up the column info for the Access column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("EventLogPermission:Access");
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("EventLogPermission:AccessColumnWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("None")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("EventLogPermission:Browse")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("EventLogPermission:Instrument")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("EventLogPermission:Audit"))
                                             };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);


        dgts.GridColumnStyles.Add(dgccAccess);

        return dt;
    }// CreateDataTable

  
    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("EventLogPermission:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("EventLogPermission:GrantFollowing");


        EventLogPermission perm = (EventLogPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.PermissionEntries.GetEnumerator();
            while (enumer.MoveNext())
            {
                EventLogPermissionEntry elpp = (EventLogPermissionEntry)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();

                newRow["Machine"]=elpp.MachineName;

                String sAccess = CResourceStore.GetString("None");
                if ((elpp.PermissionAccess&EventLogPermissionAccess.Audit) == EventLogPermissionAccess.Audit)
                    sAccess = CResourceStore.GetString("EventLogPermission:Audit");
                else if ((elpp.PermissionAccess&EventLogPermissionAccess.Instrument) == EventLogPermissionAccess.Instrument)
                    sAccess = CResourceStore.GetString("EventLogPermission:Instrument");
                else if ((elpp.PermissionAccess&EventLogPermissionAccess.Browse) == EventLogPermissionAccess.Browse)
                    sAccess = CResourceStore.GetString("EventLogPermission:Browse");
                    
                newRow["Access"] = new DataGridComboBoxEntry(sAccess);
                

                m_dt.Rows.Add(newRow);
            }
          
        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Machine"]="";
        newRow["Access"]=CResourceStore.GetString("None");
           
        dt.Rows.Add(newRow);
    }// AddEmptyRow


    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        EventLogPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new EventLogPermission(PermissionState.Unrestricted);
        else
        {
            perm = new EventLogPermission(PermissionState.None);
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a socket permission to add
                if (m_dg[i, 0] is String && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sName = (String)m_dg[i, 0];
                
                    EventLogPermissionAccess elpa = EventLogPermissionAccess.None;

                    if (((String)m_dg[i, 1]).Equals(CResourceStore.GetString("EventLogPermission:Browse")))
                        elpa |= EventLogPermissionAccess.Browse;
                    else if (((String)m_dg[i, 1]).Equals(CResourceStore.GetString("EventLogPermission:Instrument")))
                        elpa |= EventLogPermissionAccess.Instrument;
                    else if (((String)m_dg[i, 1]).Equals(CResourceStore.GetString("EventLogPermission:Audit")))
                        elpa |= EventLogPermissionAccess.Audit;

                    perm.PermissionEntries.Add(new EventLogPermissionEntry(elpa, sName));        
                }
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        if (m_dg[iSelRow, 1] == DBNull.Value)
            m_dg[iSelRow, 1] = CResourceStore.GetString("None");

        ActivateApply();
      
    }// onClick
}// class CEventLogPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\filedialogperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;

internal class CFileDialogPermDialog: CPermDialog
{
    internal CFileDialogPermDialog(FileDialogPermission perm)
    {
        this.Text = CResourceStore.GetString("FileDialogPerm:PermName");
        m_PermControls = new CFileDialogPermControls(perm, this);
        Init();        
    }// CFileDialogPermDialog(FileIOPermission)  
}// class CFileDialogPermDialog

internal class CFileDialogPermPropPage: CPermPropPage
{
    internal CFileDialogPermPropPage(CPSetWrapper nps) :  base(nps)
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(FileDialogPermission));

        m_PermControls = new CFileDialogPermControls(perm, this);
        m_sTitle=CResourceStore.GetString("FileDialogPerm:PermName"); 
    }// CFileDialogPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(FileDialogPermission));
        m_PermControls = new CFileDialogPermControls(perm, this);
    }// CreateControls
   
}// class CFileDialogPermPropPage


internal class CFileDialogPermControls : CComboBoxPermissionControls
{
    internal CFileDialogPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new FileDialogPermission(PermissionState.None);
    }// CFileDialogPermControls

    protected override String GetTextForIndex(int nIndex)
    {
        switch(nIndex)
        {
            case 0:
                return CResourceStore.GetString("FileDialogPerm:NoneDes");
            case 1:
                return CResourceStore.GetString("FileDialogPerm:OpenDes");
            case 2:
                return CResourceStore.GetString("FileDialogPerm:SaveDes");
            case 3:
                return CResourceStore.GetString("FileDialogPerm:OpenAndSaveDes");
        }
        return "";
    }// GetTextForIndex


    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("FileDialogPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("FileDialogPerm:GrantFollowing");
        
        m_cbOptions.Items.Clear();
        m_cbOptions.Items.Add(CResourceStore.GetString("None"));
        m_cbOptions.Items.Add(CResourceStore.GetString("Open Dialog"));
        m_cbOptions.Items.Add(CResourceStore.GetString("Save Dialog"));
        m_cbOptions.Items.Add(CResourceStore.GetString("Open and Save Dialogs"));

        FileDialogPermission perm = (FileDialogPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            if ((perm.Access&FileDialogPermissionAccess.OpenSave) == FileDialogPermissionAccess.OpenSave)
                m_cbOptions.SelectedIndex = 3;
            else if ((perm.Access&FileDialogPermissionAccess.Open) == FileDialogPermissionAccess.Open)
                m_cbOptions.SelectedIndex = 1;
            else if ((perm.Access&FileDialogPermissionAccess.Save) == FileDialogPermissionAccess.Save)
                m_cbOptions.SelectedIndex = 2;
            else
                m_cbOptions.SelectedIndex = 0;
        }
        else
            m_cbOptions.SelectedIndex = 3;
        
        onOptionChange(null, null);
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        FileDialogPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new FileDialogPermission(PermissionState.Unrestricted);
        else
        {
            perm = new FileDialogPermission(PermissionState.None);
            FileDialogPermissionAccess fdpa = FileDialogPermissionAccess.None;
            if (m_cbOptions.SelectedIndex == 1)
                fdpa = FileDialogPermissionAccess.Open;
            else if (m_cbOptions.SelectedIndex == 2)
                fdpa = FileDialogPermissionAccess.Save;
            else if (m_cbOptions.SelectedIndex == 3)
                fdpa = FileDialogPermissionAccess.OpenSave;
         
            perm.Access = fdpa;
        }
        return perm;
    }// GetCurrentPermission
}// class CFileDialogPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\folderbrowser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

namespace Microsoft.CLRAdmin {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Sequential)]
    internal class BROWSEINFO 
    {
        internal IntPtr hwndOwner;       //HWND        hwndOwner;    // HWND of the owner for the dialog
        internal int  pidlRoot;        //LPCITEMIDLIST pidlRoot;   // Root ITEMIDLIST

        // For interop purposes, send over a buffer of MAX_PATH size. 
        internal IntPtr pszDisplayName;  //LPWSTR       pszDisplayName;	// Return display name of item selected.

        [MarshalAs(UnmanagedType.LPWStr)]
        internal string lpszTitle;    //LPCWSTR      lpszTitle;		// text to go in the banner over the tree.
        internal int ulFlags;         //UINT         ulFlags;			// Flags that control the return stuff
        internal IntPtr lpfn;            //BFFCALLBACK  lpfn;            // Call back pointer
        internal int lParam;          //LPARAM       lParam;			// extra info that's passed back in callbacks
        internal IntPtr iImage;          //int          iImage;			// output var: where to return the Image index.
    }
    internal enum DialogResult
    {
        None = 0,
        OK = 1,
        Cancel = 2,
        Abort = 3,
        Retry = 4,
        Ignore = 5,
        Yes = 6,
        No = 7,
    }

    internal class Shell32 {

        // Disallow construction.
        private Shell32() {}

        [DllImport("shell32", EntryPoint="SHGetSpecialFolderLocation")]
        internal static extern int SHGetSpecialFolderLocation(IntPtr hwnd, int csidl, [Out, MarshalAs(UnmanagedType.LPArray)] int [] ppidl);
        //SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);

        [DllImport("shell32", EntryPoint="SHGetPathFromIDListW")]
        internal static extern bool SHGetPathFromIDList(int pidl, int pszPath);
        //SHSTDAPI_(BOOL) SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
        
        [DllImport("shell32", EntryPoint="SHBrowseForFolderW")]
        internal static extern int SHBrowseForFolder([In] BROWSEINFO lpbi);
        //SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderW(LPBROWSEINFOW lpbi);

        [DllImport("shell32", EntryPoint="SHGetMalloc")]
        internal static extern int SHGetMalloc([@out, MarshalAs(UnmanagedType.LPArray)] IMalloc[] ppMalloc);
        //SHSTDAPI SHGetMalloc(LPMALLOC * ppMalloc);
    }

    [Guid("00000002-0000-0000-c000-000000000046")]
    [ComImport, InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IMalloc 
    {
        [return : MarshalAs(UnmanagedType.I4)]
        int Alloc(
            [In, MarshalAs(UnmanagedType.I4)]
            int cb);

        void Free(
            [In, MarshalAs(UnmanagedType.I4)]
            int pv);

        [return : MarshalAs(UnmanagedType.I4)]
        int Realloc(
            [In, MarshalAs(UnmanagedType.I4)]
            int pv,
            [In, MarshalAs(UnmanagedType.I4)]
            int cb);

        [return : MarshalAs(UnmanagedType.I4)]
        int GetSize(
            [In, MarshalAs(UnmanagedType.I4)]
            int pv);

        [return : MarshalAs(UnmanagedType.I4)]
        int DidAlloc(
            [In, MarshalAs(UnmanagedType.I4)]
            int pv);

        void HeapMinimize();
    }
    
    internal sealed class FolderBrowser : Component {

        private static readonly int MAX_PATH = 260;

        // Root node of the tree view.
        private FolderBrowserFolders startLocation = FolderBrowserFolders.Desktop;

        // Browse info options
        private FolderBrowserStyles publicOptions = FolderBrowserStyles.RestrictToFilesystem;
        private uint privateOptions = 0x40;

        // Description text to show.
        private string descriptionText = String.Empty;

        // Folder picked by the user.
        private string directoryPath = String.Empty;

        internal FolderBrowserStyles Style {
            get {
                return publicOptions;
            }
            set {
                publicOptions = value;
            }
        }

        internal string DirectoryPath {
            get {
                return directoryPath;
            }
        }

        internal FolderBrowserFolders StartLocation {
            get {
                return startLocation;
            }
            set {
                startLocation = value;
            }
        }

        internal string Description {
            get {
                return descriptionText;
            }
            set {
                descriptionText = (value == null) ? String.Empty: value;
            }
        }

        private static IMalloc GetSHMalloc() {
            IMalloc[] malloc = new IMalloc[1];

            Shell32.SHGetMalloc(malloc);

            return malloc[0];
        }
        internal DialogResult ShowDialog() {
            IWin32Window owner = null;        
            int[] pidlRoot = new int[1];

            // Get/find an owner HWND for this dialog
            IntPtr hwndOwner;
             
            if (owner != null) {
                hwndOwner = owner.Handle;
            }
            else {
                hwndOwner = GetActiveWindow();
            }

            // Get the IDL for the specific startLocation
            Shell32.SHGetSpecialFolderLocation(hwndOwner, (int) startLocation, pidlRoot);

            if (pidlRoot[0] == 0) {
                // UNDONE, fabioy:
                // Show we throw an exception here instead?
                return DialogResult.Cancel;
            }
            
            int mergedOptions = (int)publicOptions | (int)privateOptions;
            
            // UNDONE, fabioy:
            // Expose the display name as another property.
            int pidlRet = 0;

            try {
                // Construct a BROWSEINFO
                BROWSEINFO bi = new BROWSEINFO();

                IntPtr buffer = (IntPtr)Marshal.AllocHGlobal(MAX_PATH);

                bi.pidlRoot = pidlRoot[0];
                bi.hwndOwner = hwndOwner;
                bi.pszDisplayName = buffer;
                bi.lpszTitle = descriptionText;
                bi.ulFlags = mergedOptions;
                bi.lpfn = (IntPtr)0;
                bi.lParam = 0;
                bi.iImage = (IntPtr)0;

                // And show the dialog
                pidlRet = Shell32.SHBrowseForFolder(bi);

                if (pidlRet == 0) {
                    // User pressed Cancel
                    return DialogResult.Cancel;
                }

                // Then retrieve the path from the IDList
                //Shell32.SHGetPathFromIDList(pidlRet, buffer);

                // Convert to a string
                directoryPath = Marshal.PtrToStringUni(buffer);

                // Then free all the stuff we've allocated or the SH API gave us
                Marshal.FreeHGlobal(buffer);
            }
            finally {
                IMalloc malloc = GetSHMalloc();
                malloc.Free(pidlRoot[0]);

                if (pidlRet != 0) {
                    malloc.Free(pidlRet);
                }
            }

            return DialogResult.OK;
        }

        [DllImport("user32.dll")]
	    internal static extern IntPtr GetActiveWindow();

    }

     internal enum FolderBrowserStyles {
        
        BrowseForComputer = 0x1000,
        BrowseForEverything = 0x4000,
        BrowseForPrinter = 0x2000,
        RestrictToDomain = 0x2,
        RestrictToFilesystem = 0x1,
        RestrictToSubfolders = 0x8,
        ShowTextBox = 0x10,
    }
        internal enum FolderBrowserFolders {
        Desktop                   = 0x0000,
        Favorites                 = 0x0006,
        MyComputer                = 0x0011,
        MyDocuments               = 0x0005,
        MyPictures                = 0x0027,
        NetAndDialUpConnections   = 0x0031,
        NetworkNeighborhood       = 0x0012,
        Printers                  = 0x0004,
        Recent                    = 0x0008,
        SendTo                    = 0x0009,
        StartMenu                 = 0x000b,
        Templates                 = 0x0015,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\fusioninterfaces.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// FusionInterfaces.cs
//
// This implements wrappers to Fusion interfaces
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Threading;


//-------------------------------------------------------------
// Interfaces defined by fusion
//-------------------------------------------------------------
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("21b8916c-f28e-11d2-a473-00c04f8ef448")]
internal interface IAssemblyEnum
{
    [PreserveSig()]
    int GetNextAssembly(out IApplicationContext ppAppCtx, out IAssemblyName ppName, uint dwFlags);
    [PreserveSig()]
    int Reset();
    [PreserveSig()]
    int Clone(out IAssemblyEnum ppEnum);
}// IAssemblyEnum

[ComImport,InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("7c23ff90-33af-11d3-95da-00a024a85b51")]
internal interface IApplicationContext
{
    void SetContextNameObject(IAssemblyName pName);
    void GetContextNameObject(out IAssemblyName ppName);
    void Set([MarshalAs(UnmanagedType.LPWStr)] String szName, int pvValue, uint cbValue, uint dwFlags);
    void Get([MarshalAs(UnmanagedType.LPWStr)] String szName, out int pvValue, ref uint pcbValue, uint dwFlags);
    void GetDynamicDirectory(out int wzDynamicDir, ref uint pdwSize);
}// IApplicationContext

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
internal interface IAssemblyName
{
    [PreserveSig()]
    int SetProperty(uint PropertyId, IntPtr pvProperty, uint cbProperty);
    [PreserveSig()]
    int GetProperty(uint PropertyId, IntPtr pvProperty, ref uint pcbProperty);
    [PreserveSig()]
    int Finalize();
    [PreserveSig()]
    int GetDisplayName(IntPtr szDisplayName, ref uint pccDisplayName, uint dwDisplayFlags);
    [PreserveSig()]
    int BindToObject(Object /*REFIID*/ refIID, 
                      Object /*IAssemblyBindSink*/ pAsmBindSink, 
                      IApplicationContext pApplicationContext,
                      [MarshalAs(UnmanagedType.LPWStr)] String szCodeBase,
                      Int64 llFlags,
                      int pvReserved,
                      uint cbReserved,
                      out int ppv);
    [PreserveSig()]
    int GetName(out uint lpcwBuffer, out int pwzName);
    [PreserveSig()]
    int GetVersion(out uint pdwVersionHi, out uint pdwVersionLow);
    [PreserveSig()]
    int IsEqual(IAssemblyName pName, uint dwCmpFlags);
    [PreserveSig()]
    int Clone(out IAssemblyName pName);
}// IAssemblyName

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
internal interface IAssemblyCache
{
    [PreserveSig()]
    int UninstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName, IntPtr pvReserved, out uint pulDisposition);
    [PreserveSig()]
    int QueryAssemblyInfo(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName, IntPtr pAsmInfo);
    [PreserveSig()]
    int CreateAssemblyCacheItem(uint dwFlags, IntPtr pvReserved, out IAssemblyCacheItem ppAsmItem, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName);
    [PreserveSig()]
    int CreateAssemblyScavenger(out Object ppAsmScavenger);
    [PreserveSig()]
    int InstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszManifestFilePath, IntPtr pvReserved);
 }// IAssemblyCache

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")]
internal interface IAssemblyCacheItem
{
    void CreateStream([MarshalAs(UnmanagedType.LPWStr)] String pszName,uint dwFormat, uint dwFlags, uint dwMaxSize, out IStream ppStream);
    void IsNameEqual(IAssemblyName pName);
    void Commit(uint dwFlags);
    void MarkAssemblyVisible(uint dwFlags);
}// IAssemblyCacheItem

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("1d23df4d-a1e2-4b8b-93d6-6ea3dc285a54")]
internal interface IHistoryReader
{
    [PreserveSig()]
    int GetFilePath(IntPtr wzFilePath, ref uint pdwSize);
    [PreserveSig()]
    int GetApplicationName(IntPtr wzAppName, ref uint pdwSize);
    [PreserveSig()]
    int GetEXEModulePath(IntPtr wzExePath, ref uint pdwSize);
    void GetNumActivations(out uint pdwNumActivations);
    void GetActivationDate(uint dwIdx, out FILETIME pftDate);
    void GetRunTimeVersion(ref FILETIME pftActivationDate, IntPtr wzRunTimeVersion, out uint pdwSize);
    void GetNumAssemblies(ref FILETIME pftActivationDate, out uint pdwNumAsms);
    void GetHistoryAssembly(ref FILETIME pftActivationDate, uint dwIdx, out Object ppHistAsm);
}// interface IHistoryReader


internal class ASM_CACHE
{
    internal const uint ZAP          = 0x1;
    internal const uint GAC          = 0x2;
    internal const uint DOWNLOAD     = 0x4;
}// class ASM_CACHE

internal class STREAM_FORMAT
{
    internal const uint COMPLIB_MODULE   = 0;
    internal const uint COMPLIB_MANIFEST = 1;
    internal const uint WIN32_MODULE     = 2;
    internal const uint WIN32_MANIFEST   = 4;
}// class STREAM_FORMAT

internal class ASM_COMMIT
{
    internal const uint DOCOMMIT         = 0x0;
    internal const uint INVISIBLE        = 0x1;
    internal const uint RECOMMIT         = 0x2;
}// class ASM_COMMIT


internal class ASM_DISPLAYF
{   
    internal const uint VERSION             = 0x1;
    internal const uint LOCALE              = 0x2;
    internal const uint FLAGS               = 0x4;
    internal const uint PUBLIC_KEY_TOKEN    = 0x8;
    internal const uint PUBLIC_KEY          = 0x10;
    internal const uint CUSTOM              = 0x20;
    internal const uint PROCESSORARCHITECTURE   = 0x40;
    internal const uint LANGUAGEID          = 0x80;
}// class ASM_DISPLAYF

internal class ASM_CMPF
{   
    internal const uint NAME                = 0x1;
    internal const uint MAJOR_VERSION       = 0x2;
    internal const uint MINOR_VERSION       = 0x4;
    internal const uint REVISION_NUMBER = 0x8;
    internal const uint BUILD_NUMBER        = 0x10;
    internal const uint PUBLIC_KEY_TOKEN    = 0x20;
    internal const uint LOCALE          = 0x40;
    internal const uint CUSTOM          = 0x80;
    internal const uint ALL             = NAME | MAJOR_VERSION | MINOR_VERSION | REVISION_NUMBER | BUILD_NUMBER | PUBLIC_KEY_TOKEN | LOCALE | CUSTOM;
    internal const uint DEFAULT         = 0x100;
}// class ASM_CMPF

internal class ASM_NAME
{   
    internal const uint PUBLIC_KEY            = 0;
    internal const uint PUBLIC_KEY_TOKEN      = PUBLIC_KEY + 1;
    internal const uint HASH_VALUE            = PUBLIC_KEY_TOKEN + 1;
    internal const uint NAME                  = HASH_VALUE + 1;
    internal const uint MAJOR_VERSION           = NAME + 1;
    internal const uint MINOR_VERSION           = MAJOR_VERSION + 1;
    internal const uint BUILD_NUMBER          = MINOR_VERSION + 1;
    internal const uint REVISION_NUMBER       = BUILD_NUMBER + 1;
    internal const uint CULTURE                = REVISION_NUMBER + 1;
    internal const uint PROCESSOR_ID_ARRAY    = CULTURE + 1;
    internal const uint OSINFO_ARRAY          = PROCESSOR_ID_ARRAY + 1;
    internal const uint HASH_ALGID          = OSINFO_ARRAY + 1;
    internal const uint ALIAS                   = HASH_ALGID + 1;
    internal const uint CODEBASE_URL          = ALIAS + 1;
    internal const uint CODEBASE_LASTMOD      = CODEBASE_URL + 1;
    internal const uint NULL_PUBLIC_KEY     = CODEBASE_LASTMOD + 1;
    internal const uint NULL_PUBLIC_KEY_TOKEN  = NULL_PUBLIC_KEY + 1;
    internal const uint CUSTOM              = NULL_PUBLIC_KEY_TOKEN + 1;
    internal const uint NULL_CUSTOM         = CUSTOM + 1;
    internal const uint MVID                    = NULL_CUSTOM + 1;
    internal const uint _32_BIT_ONLY            = MVID + 1;
    internal const uint MAX_PARAMS          = _32_BIT_ONLY + 1;
}// ASM_NAME

internal struct AssemInfo
{
    internal String Name;
    internal String Version;
    internal String Locale;
    internal String PublicKey;
    internal String PublicKeyToken;
    internal String Modified;
    internal String Codebase;
    internal String ProcType;
    internal String OSType;
    internal String OSVersion;
    internal uint   nCacheType;
    // This will aid us in deleting items
    internal String sCustom;

    internal String sFusionName;
}// struct AssemInfo


internal class Fusion
{
    private static StringCollection m_scFusionApps;
    private static Thread           m_tGetFusionApps;

    static Fusion()
    {
        // Spin off a thread to discover all the fusion apps
        m_tGetFusionApps = new Thread(new ThreadStart(DiscoverFusionApps));
        m_tGetFusionApps.Start();
    }// Fusion
    
    internal static bool CompareAssemInfo(AssemInfo ai1, AssemInfo ai2)
    {
        if (!ai1.Name.Equals(ai2.Name))
            return false;
        if (!ai1.Version.Equals(ai2.Version))
            return false;
        if (!ai1.Locale.Equals(ai2.Locale))
            return false;
        if (!ai1.PublicKey.Equals(ai2.PublicKey))
            return false;
        if (!ai1.PublicKeyToken.Equals(ai2.PublicKeyToken))
            return false;
        if (!ai1.Modified.Equals(ai2.Modified))
            return false;
        if (!ai1.Codebase.Equals(ai2.Codebase))
            return false;
        if (!ai1.ProcType.Equals(ai2.ProcType))
            return false;
        if (!ai1.OSType.Equals(ai2.OSType))
            return false;
        if (!ai1.OSVersion.Equals(ai2.OSVersion))
            return false;
        if (ai1.nCacheType != ai2.nCacheType)
            return false;
        if (!ai1.sCustom.Equals(ai2.sCustom))
            return false;

        // If we got this far, then these two asseminfos are equal
        return true;
    }// CompareAssemInfo


    internal static String GetCacheTypeString(uint nFlag)
    {
        switch(nFlag)
        {
            case ASM_CACHE.ZAP:
                return CResourceStore.GetString("Fusioninterfaces:Zap");
            case ASM_CACHE.GAC:
                return CResourceStore.GetString("Fusioninterfaces:Gac");
            case ASM_CACHE.DOWNLOAD:
                return CResourceStore.GetString("Fusioninterfaces:Download");
            default:
                return CResourceStore.GetString("<unknown>");
        }
    }// GetCacheTypeString

    internal static ArrayList ReadFusionCacheJustGAC()
    {
        ArrayList alAssems = new ArrayList();
        // We'll just read the GAC Cache
        ReadCache(alAssems, ASM_CACHE.GAC);
        // We've decided to not read the download cache. If we reverse that
        // decision, just uncomment the line below
        // ReadCache(alAssems, ASM_CACHE.DOWNLOAD);
        return alAssems;     
    }// ReadFusionCacheJustGAC



    internal static ArrayList ReadFusionCache()
    {
        ArrayList alAssems = new ArrayList();
        // We'll get the ZAP Cache, the GAC Cache, and the Download Cache
        ReadCache(alAssems, ASM_CACHE.ZAP);
        ReadCache(alAssems, ASM_CACHE.GAC);
        // We've decided to not read the download cache. If we reverse that
        // decision, just uncomment the line below
        // ReadCache(alAssems, ASM_CACHE.DOWNLOAD);
        return alAssems;     
    }// ReadFusionCache

    private static void ReadCache(ArrayList alAssems, uint nFlag)
    {
        IAssemblyEnum aEnum         = null;
        IApplicationContext AppCtx  = null;
        IAssemblyName   aName       = null;
        
        int hr = CreateAssemblyEnum(out aEnum, null, null, nFlag, 0); 
        while (hr == HRESULT.S_OK)
        {
            hr = aEnum.GetNextAssembly(out AppCtx, out aName, 0);
            if (hr == HRESULT.S_OK)
            {
                uint iLen=0;
                IntPtr pDisplayName=(IntPtr)0;
                // Get the length of the string we need
                aName.GetDisplayName((IntPtr)0, ref iLen, 0);
                if (iLen > 0)
                {
                    // Do some yucky memory allocating here
                    // We need to assume that a wide character is 2 bytes.
                    pDisplayName = Marshal.AllocHGlobal(((int)iLen+1)*2);
                    aName.GetDisplayName(pDisplayName, ref iLen, 0);
                    String sDisplayName = Marshal.PtrToStringUni(pDisplayName);
                    Marshal.FreeHGlobal(pDisplayName);


                    AssemInfo newguy = new AssemInfo();
                    newguy.sFusionName = sDisplayName;
                    
                    // Our info is in a comma seperated list. Let's pull it out
                    String[] sFields = sDisplayName.Split(new char[] {','});

                    newguy.Name = sFields[0];
                    // The version string is represented as Version=######
                    // Let's take out the 'Version='
                    newguy.Version = sFields[1].Substring(sFields[1].IndexOf('=')+1);
                    // Same goes for the locale
                    newguy.Locale = sFields[2].Substring(sFields[2].IndexOf('=')+1);
                    // And the internal key token
                    sFields[3]=sFields[3].Substring(sFields[3].IndexOf('=')+1);
                    if (sFields[3].Equals("null"))
                        sFields[3] = CResourceStore.GetString("None");
                        
                    newguy.PublicKeyToken = sFields[3];
                    
                    // Now get some more stuff we can't get from a 'GetDisplayName' call
                    newguy.PublicKey = GetFusionString(aName, ASM_NAME.PUBLIC_KEY); 
                    newguy.Codebase = GetFusionString(aName, ASM_NAME.CODEBASE_URL);

                    // newguy.Modified = GetFusionString(aName, ASM_NAME.CODEBASE_LASTMOD);
                    // Currently, there's a fusion bug which prevents us from getting this information
                    // We'll go out to the file system and get the data right now.
                    newguy.Modified = "";
                    try
                    {
                        if (newguy.Codebase != null && newguy.Codebase.Length > 0)
                        {
                            Uri uCodebase   = new Uri(newguy.Codebase);
                            String sAbsolutePath = uCodebase.AbsolutePath;
                            if (File.Exists(sAbsolutePath))
                                newguy.Modified = File.GetLastWriteTime(sAbsolutePath).ToString();
                        }
                    }
                    catch(Exception)
                    {
                    }
                    newguy.ProcType = GetFusionString(aName, ASM_NAME.PROCESSOR_ID_ARRAY);
                    newguy.OSType = GetFusionString(aName, ASM_NAME.OSINFO_ARRAY);
                    newguy.OSVersion = ""; // We'll need to munge the OSINFO_ARRAY a bit
                    // This will grab the ZAP signature
                    newguy.sCustom = GetFusionString(aName, ASM_NAME.CUSTOM);
                    newguy.nCacheType = nFlag;
                    alAssems.Add(newguy);
                }
            }
        }
    }// ReadFusionCache

    private static String GetFusionString(IAssemblyName asmName, uint item)
    {
        String sRetVal="?";
        uint iLen = 0;
        IntPtr pString = (IntPtr)0;
        asmName.GetProperty(item, (IntPtr)0, ref iLen);
        pString = Marshal.AllocHGlobal(((int)iLen+1)*2);
        int hr = asmName.GetProperty(item, pString, ref iLen);

        if (iLen== 0)
        {
            sRetVal="";
        }
        else if (item == ASM_NAME.CODEBASE_LASTMOD)
        { 
            SYSTEMTIME st = new SYSTEMTIME();
            FileTimeToSystemTime(pString, ref st);
            Calendar c = CultureInfo.CurrentCulture.Calendar;
            
            DateTime dt = new DateTime(st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, c);

            sRetVal = dt.ToString();
        }
        else
        {
            sRetVal = Marshal.PtrToStringUni(pString);
        }

        Marshal.FreeHGlobal(pString);
        return sRetVal;
    }// GetFusionString

    internal static int AddAssemblytoGac(String sAssemFilename)
    {
        IAssemblyCache ac = null;
        int hr = CreateAssemblyCache(out ac, 0);
        if (hr != HRESULT.S_OK)
            return hr;

        return ac.InstallAssembly(0, sAssemFilename, (IntPtr)0);
    }// AddAssemblyToGac

    internal static bool RemoveAssemblyFromGac(AssemInfo aInfo)
    {
        IAssemblyCache ac = null;
        int hr = CreateAssemblyCache(out ac, 0);
        uint n;

        if (aInfo.sCustom.Length > 0)
        {
            // We need to take this string, byte-ify it, then string-ify it.
            // Why?
            // We need our string:
            // ZAP........
            // to be
            // 900041005000.......
            aInfo.sFusionName += ",Custom=" + ByteArrayToString(StringToByteArray(aInfo.sCustom));
        }

        int nRet = ac.UninstallAssembly(0, aInfo.sFusionName, (IntPtr)0, out n);
        
        if (nRet != HRESULT.S_OK)
        {
            // Ok, something kind of funky happened.... let's see if this item really did get removed from the cache
            ArrayList al = new ArrayList();
            ReadCache(al, aInfo.nCacheType);
            
            // See if our item is in here.....
            for(int i=0; i<al.Count; i++)
            {
                AssemInfo ai = (AssemInfo)al[i];
                if (ai.Name.Equals(aInfo.Name) && ai.PublicKeyToken.Equals(aInfo.PublicKeyToken) && ai.Version.Equals(aInfo.Version))
                    return false;
            }
            
        }
        return true;
    }// RemoveAssemblyFromGac

    internal static void DiscoverFusionApps()
    {
        StringCollection sc = new StringCollection();
        WIN32_FIND_DATA fd = new WIN32_FIND_DATA();
        IHistoryReader  pReader;
        
        IntPtr psw = Marshal.AllocCoTaskMem(500*2);
        uint nLen = 500;
        
        GetHistoryFileDirectory(psw, ref nLen);
        String sHistoryPath = Marshal.PtrToStringUni(psw);

        String sSearchPath = sHistoryPath + "\\*.ini";

        IntPtr h;
        int fContinue = 1;

        h = FindFirstFile(sSearchPath, out fd);

        while(h != (IntPtr)(-1) && fContinue == 1)
        {
            if (CreateHistoryReader(sHistoryPath + "\\" + fd.cFileName, out pReader) != HRESULT.S_OK)
                break;

            nLen = 500;
            if (pReader.GetEXEModulePath(psw, ref nLen) != HRESULT.S_OK)
                break;

            String sAppName = Marshal.PtrToStringAuto(psw);
            // Check to see if this app still exists
            if (File.Exists(sAppName))
                sc.Add(sAppName);

            fContinue = FindNextFile(h, out fd);
        }
        
        m_scFusionApps = sc;
    }// DiscoverFusionApps

    internal static StringCollection GetKnownFusionApps()
    {
        m_tGetFusionApps.Join();
        return m_scFusionApps;
    }// GetKnownFusionApps
   
    internal static bool isManaged(String sFilename)
    {

        try
        {
            byte[] Data = new byte[4096];
        
            Stream fin = File.OpenRead(sFilename);
        
            int iRead = fin.Read(Data, 0, 4096);

            fin.Close();
        
            // Verify this is a executable/dll
            if ((Data[1] << 8 | Data[0]) != 0x5a4d)
                throw new Exception("Not an executable");

            // This will get the address for the WinNT header
            int iWinNTHdr = Data[63]<<24 | Data[62]<<16 | Data[61] << 8 | Data[60];

            // Verify this is an NT address
            if ((Data[iWinNTHdr+3] << 24 | Data[iWinNTHdr+2] << 16 | Data[iWinNTHdr+1] << 8 | Data[iWinNTHdr]) != 0x00004550)
                throw new Exception("Didn't have an NT address");
        
            int iLightningAddr = iWinNTHdr + 24 + 208;

            int iSum=0;
            int iTop = iLightningAddr + 8;
        
            for(int i=iLightningAddr; i<iTop; i++)
                iSum|=Data[i];
        
            if (iSum == 0)
                return false;
            else
                return true;
        }
        catch(Exception)
        {
            return false;
        }

    }// isManaged


    private static String ByteArrayToString(Byte[] b)
    {
        String s = "";
        String sPart;
        if (b != null)
        {
            for(int i=0; i<b.Length; i++)
            {
                sPart = b[i].ToString("X");
                // If the byte was only one character in length, make sure we add
                // a zero. We want all bytes to be 2 characters long
                if (b[i] < 0x10)
                    sPart = "0" + sPart;
                
                s+=sPart;
            }
        }
        return s.ToLower(CultureInfo.InvariantCulture);
    }// ByteArrayToString



    //-------------------------------------------------
    // StringToByteArray
    //
    // This function will convert a string to a byte array so
    // it can be sent across the global stream in CDO 
    //-------------------------------------------------
    private static byte[] StringToByteArray(String input)
    {
        int i;
        int iStrLength = input.Length;
        // Since MMC treats all its strings as unicode, 
        // each character must be 2 bytes long
        byte[] output = new byte[(iStrLength + 1)*2];
        char[] cinput = input.ToCharArray();

        int j=0;
        
        for(i=0; i<iStrLength; i++)
        {
            output[j++] = (byte)cinput[i];
            output[j++] = 0;
        }

        // For the double null
        output[j++]=0;
        output[j]=0;
        

        return output;

     }// StringToByteArray




    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int CreateAssemblyNameObject(out IAssemblyName ppEnum, String szAssemblyName, uint dwFlags, int pvReserved);

    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int CreateAssemblyEnum(out IAssemblyEnum ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, uint dwFlags, int pvReserved);

    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int CreateAssemblyCacheItem(out IAssemblyCacheItem ppasm,
                                                     IAssemblyName pName,
                                                     [MarshalAs(UnmanagedType.LPWStr)]String pszCodebase,
                                                     ref FILETIME pftLastMod,
                                                     uint dwInstaller,
                                                     uint dwReserved);

    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int CreateAssemblyCache(out IAssemblyCache ppAsmCache, uint dwReserved);

    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int GetHistoryFileDirectory(IntPtr wzDir, ref uint pdwSize);

    [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
    internal static extern int CreateHistoryReader(String wzFilePath, out IHistoryReader ppHistReader);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr FindFirstFile(String lpFileName, out WIN32_FIND_DATA lpFindFileData);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    internal static extern int FindNextFile(IntPtr hFindFile, out WIN32_FIND_DATA lpFindFileData);

    [DllImport("kernel32.dll")]
    internal static extern int FileTimeToSystemTime(IntPtr FILETIME, ref SYSTEMTIME b);
}// class Fusion



}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\inheritedassemblydialogs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Collections;
using System.Runtime.InteropServices;

internal class CFusionDialog : CAssemblyDialog
{
    internal CFusionDialog()
    {
        this.Text = CResourceStore.GetString("InheritedAssemblyDialogs:ChooseFromGac");
        m_ol = Fusion.ReadFusionCacheJustGAC();
        PutInAssemblies();
    }// CFusionDialog
}// class CFusionDialog

internal class CFusionNoVersionDialog : CAssemblyDialog
{
    internal CFusionNoVersionDialog() : base(false)
    {
        this.Text = CResourceStore.GetString("InheritedAssemblyDialogs:ChooseFromGac");
        m_ol = Fusion.ReadFusionCacheJustGAC();

        // Filter out duplicate versions....
        for(int i=0; i< m_ol.Count; i++)
        {
            AssemInfo ai = (AssemInfo)m_ol[i];
            // Run through and see if anybody else has this name and public key token
            for(int j=i+1; j< m_ol.Count; j++)
            {
                AssemInfo ai2 = (AssemInfo)m_ol[j];
                if (ai2.Name.Equals(ai.Name) && ai2.PublicKeyToken.Equals(ai.PublicKeyToken))
                {
                    m_ol.RemoveAt(j);
                    j--;
                }
            }
        }
        PutInAssemblies();
    }// CFusionNoVersionDialog
}// class CFusionNoVersionDialog


internal class CDependAssembliesDialog : CAssemblyDialog
{
    CApplicationDepends m_appDepends;

    internal CDependAssembliesDialog(CApplicationDepends appDepends)
    {
        m_appDepends = appDepends;
        m_ol = GenerateAssemblyList();
        PutInAssemblies();
        this.Text = CResourceStore.GetString("InheritedAssemblyDialogs:ChooseFromDepend");
    }// CFusionDialog
    
    private ArrayList GenerateAssemblyList()
    {
        // We'll set the cursor to an hourglass, since this
        // can take some time....
        
        IntPtr hWaitCursor = LoadCursor((IntPtr)0, 32514);

        // Make sure we grab onto the current cursor
        IntPtr hOldCursor = SetCursor(hWaitCursor);
        
        // Now generate the dependent assemblies
        m_appDepends.GenerateDependentAssemblies();
        ArrayList al = m_appDepends.DependentAssemblies;
        
        // Change back
        SetCursor(hOldCursor);

        return al;
    }// GenerateAssemblyList

    [DllImport("user32.dll")]
    internal static extern IntPtr SetCursor(IntPtr hCursor);
    [DllImport("user32.dll")]
    internal static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

    
}// class CDependAssembliesDialog
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\iassemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about Assembly Manifests.
//

namespace Microsoft.CLRAdmin
  {
  using System;
  using System.Collections;

  // Makes information about an Assembly available.
  //
  // Exists because we needed to expose "invalid" assemblies. For example,
  // a valid (could be loaded) assembly could reference an invalid (can't 
  // be loaded) assembly.  Instead of aborting the entire operation, it
  // would be preferrable to accept the "invalid" assembly, and continue.
  //
  // Doing this requires at least two implementations--one for valid a
  // assemblies and one for invalid assemblies.  Inheritence could have
  // been used, but it didn't make sense to have the 
  // AssemblyExceptionInfo class inherit from the AssemblyInfo class.
  // The use of an interface made more sense, so this is what's being used.
  internal interface IAssemblyInfo
    {
    AssemblyRef GetAssembly ();

    /** @return The full name of the assembly. */
    String Name
      {get;}

    Exception Error
      {get;}

    // Makes available the full names (as String objects) of all assemblies
    // that the Assembly returned by GetAssembly() is dependant on.
    ICollection ReferencedAssemblies
      {get;}

    } /* interface IAssemblyInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\fileioperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;

internal class CFileIOPermDialog: CPermDialog
{
    internal CFileIOPermDialog(FileIOPermission perm)
    {
        this.Text = CResourceStore.GetString("FileIOPerm:PermName");
        m_PermControls = new CFileIOPermControls(perm, this);
        Init();        
    }// CFileIOPermDialog(FileIOPermission)  
}// class CFileIOPermDialog

internal class CFileIOPermPropPage: CPermPropPage
{
    internal CFileIOPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("FileIOPerm:PermName"); 
    }// CFileIOPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(FileIOPermission));
        m_PermControls = new CFileIOPermControls(perm, this);
    }// CreateControls
}// class CFileIOPermPropPage


internal class FilePermInfo
{
    public String sPath;
    public bool fRead;
    public bool fWrite;
    public bool fAppend;
    public bool fPDiscovery;

    public FilePermInfo(String sThePath, int nType)
    {
        this.sPath = sThePath;
        fRead=false;
        fWrite=false;
        fAppend=false;
        fPDiscovery=false;
        AddSetting(nType);
    }

    public void AddSetting(int nType)
    {
        if (nType==FILEPERMS.READ)
            fRead=true;
        else if (nType==FILEPERMS.WRITE)
            fWrite=true;
        else if (nType==FILEPERMS.APPEND)
            fAppend=true;
        else if (nType==FILEPERMS.PDISC)
            fPDiscovery=true;
    }// AddSetting

    public String GetPermissionString()
    {
        String s="";
        if (fRead)
            s+=CResourceStore.GetString("FileIOPermission:Read");
        if (fWrite)
        {
            if (s.Length > 0)
                s+=CResourceStore.GetString("FileIOPerm:Seperator");
            s+=CResourceStore.GetString("FileIOPermission:Write");
            
        }
        if (fAppend)
        {
            if (s.Length > 0)
                s+=CResourceStore.GetString("FileIOPerm:Seperator");
            s+=CResourceStore.GetString("FileIOPermission:Append");
            
        }
        if (fPDiscovery)
        {
            if (s.Length > 0)
                s+=CResourceStore.GetString("FileIOPerm:Seperator");
            s+=CResourceStore.GetString("FileIOPermission:PathDiscovery");
            
        }

        return s;
    }// GetPermissionString
        
 }// class FilePermInfo



internal class CFileIOPermControls : CTablePermControls
{
    internal CFileIOPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new FileIOPermission(PermissionState.None);
    }// CFileIOPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Path" Column
        DataColumn dcVariable = new DataColumn();
        dcVariable.ColumnName = "Path";
        dcVariable.DataType = typeof(String);
        dt.Columns.Add(dcVariable);

        // Create the "Read" Column
        DataColumn dcRead = new DataColumn();
        dcRead.ColumnName = "Read";
        dcRead.DataType = typeof(bool);
        dt.Columns.Add(dcRead);


        // Create the "Write" Column
        DataColumn dcWrite = new DataColumn();
        dcWrite.ColumnName = "Write";
        dcWrite.DataType = typeof(bool);
        dt.Columns.Add(dcWrite);

        // Create the "Append" Column
        DataColumn dcAppend = new DataColumn();
        dcAppend.ColumnName = "Append";
        dcAppend.DataType = typeof(bool);
        dt.Columns.Add(dcAppend);

        // Create the "Path Discovery" Column
        DataColumn dcPDisc = new DataColumn();
        dcPDisc.ColumnName = "PDiscovery";
        dcPDisc.DataType = typeof(bool);
        dt.Columns.Add(dcPDisc);


        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridBoolColumn dgbcRead = new DataGridBoolColumn();
        DataGridBoolColumn dgbcWrite = new DataGridBoolColumn();
        DataGridBoolColumn dgbcAppend = new DataGridBoolColumn();
        DataGridBoolColumn dgbcPDisc = new DataGridBoolColumn();
        DataGridTextBoxColumn dgtbcPath = new DataGridTextBoxColumn();
         
        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Path column
        dgtbcPath.MappingName = "Path";
        dgtbcPath.HeaderText = CResourceStore.GetString("FileIOPermission:FilePath");
        dgtbcPath.Width = ScaleWidth(CResourceStore.GetInt("FileIOPerm:PathColumnWidth"));
        dgtbcPath.NullText = "";
        dgtbcPath.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcPath);

        // Set up the column info for the Read column
        dgbcRead.MappingName = "Read";
        dgbcRead.HeaderText = CResourceStore.GetString("FileIOPermission:Read");
        dgbcRead.AllowNull = false;
        dgbcRead.Width = ScaleWidth(CResourceStore.GetInt("FileIOPerm:ReadColumnWidth"));
        dgbcRead.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcRead);

        // Set up the column info for the Write column
        dgbcWrite.MappingName = "Write";
        dgbcWrite.HeaderText = CResourceStore.GetString("FileIOPermission:Write");
        dgbcWrite.AllowNull = false;
        dgbcWrite.Width = ScaleWidth(CResourceStore.GetInt("FileIOPerm:WriteColumnWidth"));
        dgbcWrite.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcWrite);

        // Set up the column info for the Append column
        dgbcAppend.MappingName = "Append";
        dgbcAppend.HeaderText = CResourceStore.GetString("FileIOPermission:Append");
        dgbcAppend.AllowNull = false;
        dgbcAppend.Width = ScaleWidth(CResourceStore.GetInt("FileIOPerm:AppendColumnWidth"));
        dgbcAppend.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcAppend);

        // Set up the column info for the Path Discovery column
        dgbcPDisc.MappingName = "PDiscovery";
        dgbcPDisc.HeaderText = CResourceStore.GetString("FileIOPermission:PathDiscovery");
        dgbcPDisc.AllowNull = false;
        dgbcPDisc.Width = ScaleWidth(CResourceStore.GetInt("FileIOPerm:PDiscoverColumnWidth"));
        dgbcPDisc.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcPDisc);

        return dt;
    }// CreateDataTable

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("FileIOPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("FileIOPerm:GrantFollowing");

        FileIOPermission perm = (FileIOPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            ArrayList alFiles = new ArrayList();

            AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Read), FILEPERMS.READ);
            AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Write), FILEPERMS.WRITE);
            AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Append), FILEPERMS.APPEND);
            AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.PathDiscovery), FILEPERMS.PDISC);
            

            for(int i=0; i<alFiles.Count; i++)
            {
                FilePermInfo fpi = (FilePermInfo)alFiles[i];
            
                DataRow newRow;
                // See if we have some info for this one
                if (fpi.sPath.Length > 0)
                {
                    newRow = m_dt.NewRow();
                    newRow["Path"]=fpi.sPath;
                    newRow["Read"]=fpi.fRead;
                    newRow["Write"]=fpi.fWrite;
                    newRow["Append"]=fpi.fAppend;
                    newRow["PDiscovery"]=fpi.fPDiscovery;
                    m_dt.Rows.Add(newRow);
                }
            }
        }

        // We want at least 1 row
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
  
    }// PutValuesinPage

    internal static void AddFiles(ArrayList alFiles, String[] files, int nType)
    {   
        if (files != null)
        {
            for(int i=0; i<files.Length; i++)
            {
                int j;
                for(j=0; j<alFiles.Count; j++)
                    if (((FilePermInfo)alFiles[j]).sPath.Equals(files[i]))
                    {
                        // We have a match... just muck with this guy's setting
                        ((FilePermInfo)alFiles[j]).AddSetting(nType);
                        // Cause our inner for loop to bail...
                        break;
                    }

                if (j == alFiles.Count)
                {
                    // We didn't find a match in our existing file infos....
                    if (files[i].Length>0)
                    {
                        FilePermInfo fpi = new FilePermInfo(files[i], nType);
                        alFiles.Add(fpi);
                    }
                }
            }
        }
    }// AddFiles
    
    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Path"]="";
        newRow["Read"]=false;
        newRow["Write"]=false;
        newRow["Append"]=false;
        newRow["PDiscovery"]=false;
        dt.Rows.Add(newRow);
    }// AddEmptyRow


    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        FileIOPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new FileIOPermission(PermissionState.Unrestricted);
        else
        {
            perm = new FileIOPermission(PermissionState.None);

            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have an file permission to add
                if (m_dg[i, 0] != DBNull.Value && ((String)m_dg[i, 0]).Length > 0)
                {
                    FileIOPermissionAccess pa = FileIOPermissionAccess.NoAccess;
                
                    // Does this path have read permissions
                    if ((bool)m_dg[i, 1])
                        pa |= FileIOPermissionAccess.Read;
                    // Does this path have write permissions
                    if ((bool)m_dg[i, 2])
                        pa |= FileIOPermissionAccess.Write;
                    // Does this have append permissions
                    if ((bool)m_dg[i, 3])
                        pa |= FileIOPermissionAccess.Append;
                    // See if it has path discovery permission
                    if ((bool)m_dg[i, 4])
                        pa |= FileIOPermissionAccess.PathDiscovery;
                    try
                    {
                        perm.AddPathList(pa, (String)m_dg[i, 0]);    
                    }
                    catch(Exception)
                    {
                        MessageBox(String.Format(CResourceStore.GetString("FileIOPerm:BadPaths"), (String)m_dg[i, 0]),
                                   CResourceStore.GetString("FileIOPerm:BadPathsTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;
                    }
                }
                else
                {
                    // Make sure they didn't check any boxes and not include
                    // an empty path
                    bool fCheckedBox = false;
                    for(int j=1; j<=4 && !fCheckedBox; j++)
                        fCheckedBox = (bool)m_dg[i, j];

                    if (fCheckedBox)
                    {            
                        MessageBox(CResourceStore.GetString("FileIOPerm:NeedPaths"),
                                   CResourceStore.GetString("FileIOPerm:NeedPathsTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;
                       }
                    }
            }
        }
        return perm;
    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        for(int i=1; i<5; i++)
            if (m_dg[iSelRow, i] == DBNull.Value)
                m_dg[iSelRow, i]=false;
                
        ActivateApply();
    }// onClick
}// class CEnvPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\genericpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Net;
using System.Collections;

internal class CPermDialog: Form
{
    protected CPermControls m_PermControls;
    
    internal CPermDialog()
    {
        // Need to globalize this...
        this.AutoScaleBaseSize = new Size(5, 13);
        this.ClientSize = new Size(390, 387);
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.Icon = null;
        this.Name = "Win32Form1";
    }// CCustomPermDialog(IPermission)  

    internal IPermission GetPermission()
    {
        return m_PermControls.GetCurrentPermission();
    }// GetPermission

    protected void Init()
    {
        // we need to insert the controls now
        m_PermControls.InsertPropSheetPageControls(Controls, true);
    }// Init
   
}// class CCustomPermDialog

internal class CPermPropPage: CSecurityPropPage
{
    protected CPermControls m_PermControls;
    protected CPSetWrapper m_pSetWrap;

    internal CPermPropPage(CPSetWrapper pSetWrap)
    {
        m_pSetWrap = pSetWrap;
    }// CPermPropPage

    protected virtual void CreateControls()
    {}
    
    internal override int InsertPropSheetPageControls()
    {
        CreateControls();
        return m_PermControls.InsertPropSheetPageControls(PageControls, false);
    }// InsertPropSheetPageControls

    internal override bool ValidateData()
    {
        return m_PermControls.ValidateData();
    }// ValidateData

    internal override bool ApplyData()
    {
        IPermission perm = m_PermControls.GetCurrentPermission();

        // If there was an error generating this permission, let's bail
        if (perm == null)
            return false;

        m_pSetWrap.PSet.SetPermission(perm);
        // Now put this permission set in the current policy
        m_pSetWrap.PolLevel.ChangeNamedPermissionSet(m_pSetWrap.PSet.Name, m_pSetWrap.PSet);

        SecurityPolicyChanged();
        return true;
    }// ApplyData
}// class CPermPropPage


internal class CPermControls
{
    // Controls on the page
    protected UserControl   m_ucOptions;
    protected RadioButton m_radUnrestricted;
    protected RadioButton m_radGrantFollowingPermission;

    private Button          m_btnCancel;
    private Button          m_btnOk;
    private Object          m_pOwner;
    // Internal data
    protected IPermission   m_perm;

    internal CPermControls(IPermission perm, Object oParent)
    {
        m_perm = perm;
        m_pOwner = oParent;
    }// CPermControls

    internal int InsertPropSheetPageControls(Control.ControlCollection cc, bool fAddButtons)
    {
        m_ucOptions = new UserControl();
       
        InsertPropSheetPageControls(cc);
        
        // We need to put an OK/Cancel button in here if this is a dialog box
        if (fAddButtons)
        {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CTablePermControls));
            this.m_btnOk = new System.Windows.Forms.Button();
            this.m_btnCancel = new System.Windows.Forms.Button();
            this.m_btnOk.Location = ((System.Drawing.Point)(resources.GetObject("m_btnOk.Location")));
            this.m_btnOk.Size = ((System.Drawing.Size)(resources.GetObject("m_btnOk.Size")));
            this.m_btnOk.TabIndex = ((int)(resources.GetObject("m_btnOk.TabIndex")));
            this.m_btnOk.Text = resources.GetString("m_btnOk.Text");
            m_btnOk.Name = "OK";
            this.m_btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
            this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
            this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
            this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
            m_btnCancel.Name = "Cancel";
            m_btnOk.Click += new EventHandler(onOk);

            cc.Add(m_btnOk);
            cc.Add(m_btnCancel);

        }
        return 1;
    }// InsertPropSheetPageControls

    internal virtual int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        return 1;
    }// InsertPropSheetPageControls(ControlCollection)

    void onOk(Object o, EventArgs e)
    {
        if (ValidateData())
        {
            // We need to tell our form to close.
            if (m_pOwner != null && m_pOwner is Form)
                ((Form)m_pOwner).DialogResult = DialogResult.OK; 
           
        }
    }// onOK

    protected void ActivateApply()
    {
        if (m_pOwner != null && m_pOwner is CPropPage)
            ((CPropPage)m_pOwner).ActivateApply();
    }// ActivateApply

    protected int ScaleWidth(int nWidth)
    {
        // We only need to scale if we're parented to a property page
        if (m_pOwner != null && m_pOwner is CPropPage)
            return ((CPropPage)m_pOwner).ScaleWidth(nWidth);
        else
            // The value is already scaled on a managed form
            return nWidth;
    }// ScaleWidth


    internal virtual bool ValidateData()
    {
        return true;
    }// ValidateData

    internal IPermission StoredPermission
    {
        set
        {
            m_perm = value;
        }

    }// StoredPermission

    protected virtual void PutValuesinPage()
    {
    }// PutValuesinPage

    internal virtual IPermission GetCurrentPermission()
    {
        return m_perm;
    }// GetCurrentPermission

    protected void CheckUnrestricted(IUnrestrictedPermission perm)
    {
        if (perm.IsUnrestricted())
        {
            m_radUnrestricted.Checked=true;
            m_ucOptions.Enabled = false;
        }
        else
            m_radGrantFollowingPermission.Checked=true;

    }// CheckUnrestricted

    protected virtual void onChangeUnRestrict(Object o, EventArgs e)
    {
        // Let's disable the options if we're giving unrestricted access
        if (m_ucOptions != null)
            m_ucOptions.Enabled = m_radGrantFollowingPermission.Checked;

        ActivateApply();
    }// onChangeUnRestrict



    protected int MessageBox(String sMessage, String sHeader, uint dwOptions)
    {
        if (m_pOwner != null && m_pOwner is CPropPage)
            return ((CPropPage)m_pOwner).MessageBox(sMessage, sHeader, dwOptions);
        else if (m_pOwner != null && m_pOwner is Form)
            return MessageBox(((Form)m_pOwner).Handle, sMessage, sHeader, dwOptions);
        else
            return MessageBox((IntPtr)0, sMessage, sHeader, dwOptions);
    }

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    private static extern int MessageBox(IntPtr hWnd, String Message, String Header, uint type);
}// class CEnvPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
	copy mscorcfg.msc $(URTTARGET)
	copy clruireg.vrg $(URTTARGET)
        copy mscorcfg11.reg $(URTTARGET) 
	regasm $(COOL_TARGET) /regfile:$(O)\mscorcfg.reg
	gacutil -i $(COOL_TARGET)

resources: 
	ResGen /compile resource/dlgtemplates/ReadOnlyPermission.resx,$(O)\Microsoft.CLRAdmin.CReadOnlyPermission.resources \
	resource/dlgtemplates/AssemblyDialog.resx,$(O)\Microsoft.CLRAdmin.CAssemblyDialog.resources \
	resource/dlgtemplates/TrustAppWizardPage1.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz1.resources \
	resource/dlgtemplates/TrustAppWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz2.resources \
	resource/dlgtemplates/TrustAppWizardPage3.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz3.resources \
	resource/dlgtemplates/TrustAppWizardPage4.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz4.resources \
	resource/dlgtemplates/TrustAppWizardPage5.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz5.resources \
	resource/dlgtemplates/TrustAppWizardPage7.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz7.resources \
	resource/dlgtemplates/TrustAppWizardPage8.resx,$(O)\Microsoft.CLRAdmin.CTrustAppWiz8.resources \
	resource/dlgtemplates/AdjustSecurityWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CSecurityAdjustmentWiz2.resources \
	resource/dlgtemplates/AdjustSecurityWizardPage3.resx,$(O)\Microsoft.CLRAdmin.CSecurityAdjustmentWiz3.resources \
	resource/dlgtemplates/CodeGroupPermissionSetProp.resx,$(O)\Microsoft.CLRAdmin.CSingleCodeGroupPSetProp.resources \
	resource/dlgtemplates/EvaluateAssemblyWizardPage1.resx,$(O)\Microsoft.CLRAdmin.CEvalAssemWiz1.resources \
	resource/dlgtemplates/EvaluateAssemblyWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CEvalAssemWiz2.resources \
	resource/dlgtemplates/EvaluateAssemblyWizardPage3.resx,$(O)\Microsoft.CLRAdmin.CEvalAssemWiz3.resources \
	resource/dlgtemplates/MyComputerProps.resx,$(O)\Microsoft.CLRAdmin.CGeneralMachineProps.resources \
	resource/dlgtemplates/RemotingProp1.resx,$(O)\Microsoft.CLRAdmin.CRemotingProp1.resources \
	resource/dlgtemplates/RemotingProp2.resx,$(O)\Microsoft.CLRAdmin.CRemotingProp2.resources \
	resource/dlgtemplates/RemotingProp3.resx,$(O)\Microsoft.CLRAdmin.CRemotingProp3.resources \
	resource/dlgtemplates/NewSecurityPolicyDialog.resx,$(O)\Microsoft.CLRAdmin.CNewSecurityPolicyDialog.resources \
	resource/dlgtemplates/OpenSecurityPolicyDialog.resx,$(O)\Microsoft.CLRAdmin.COpenSecurityPolicyDialog.resources \
	resource/dlgtemplates/CustomCodegroupProp.resx,$(O)\Microsoft.CLRAdmin.CCustomCodeGroupProp.resources \
	resource/dlgtemplates/SharedAssembliesGeneralProp.resx,$(O)\Microsoft.CLRAdmin.CAssemGenProps.resources \
	resource/dlgtemplates/SharedAssembliesPlatformProp.resx,$(O)\Microsoft.CLRAdmin.CAssemPlatformProps.resources \
	resource/dlgtemplates/SinglePermissionSetProp.resx,$(O)\Microsoft.CLRAdmin.CSinglePermissionSetProp.resources \
	resource/dlgtemplates/SingleCodeGroupProp.resx,$(O)\Microsoft.CLRAdmin.CSingleCodeGroupProp.resources \
	resource/dlgtemplates/CodeGroupMembershipConditions.resx,$(O)\Microsoft.CLRAdmin.CSingleCodeGroupMemCondProp.resources \
	resource/dlgtemplates/ApplicationProp.resx,$(O)\Microsoft.CLRAdmin.CAppProps.resources \
	resource/dlgtemplates/ChooseAppDialog.resx,$(O)\Microsoft.CLRAdmin.CChooseAppDialog.resources \
	resource/dlgtemplates/ConfigureAssemblyWizardPage1.resx,$(O)\Microsoft.CLRAdmin.CConfigAssemWiz1.resources \
	resource/dlgtemplates/ConfigAssemGeneralProp.resx,$(O)\Microsoft.CLRAdmin.CConfigAssemGeneralProp.resources \
	resource/dlgtemplates/ConfigAssemBindingPolicyProp.resx,$(O)\Microsoft.CLRAdmin.CAssemBindPolicyProp.resources \
	resource/dlgtemplates/ConfigAssemCodebaseProp.resx,$(O)\Microsoft.CLRAdmin.CAssemVerCodebases.resources \
	resource/dlgtemplates/CreateCodegroupWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz2.resources \
	resource/dlgtemplates/CreateDeploymentPackageWizardPage1.resx,$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz1.resources \
	resource/dlgtemplates/DeploymentPackageWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz2.resources \
	resource/dlgtemplates/CreateDeploymentPackageWizardPage3.resx,$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz3.resources \
	resource/dlgtemplates/NewPermissionSetWizardPage1.resx,$(O)\Microsoft.CLRAdmin.CNewPermSetWiz1.resources \
	resource/dlgtemplates/NewPermissionSetWizardPage2.resx,$(O)\Microsoft.CLRAdmin.CNewPermSetWiz2.resources \
	resource/dlgtemplates/NewCodegroupWizardPage3.resx,$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz3.resources \
	resource/dlgtemplates/NewCodegroupWizardPage4.resx,$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz4.resources \
	resource/dlgtemplates/TablePermission.resx,$(O)\Microsoft.CLRAdmin.CTablePermControls.resources \
	resource/dlgtemplates/IsolatedStoragePermission.resx,$(O)\Microsoft.CLRAdmin.CIsoStoragePermControls.resources \
	resource/dlgtemplates/ReflectionPermission.resx,$(O)\Microsoft.CLRAdmin.CReflectPermControls.resources \
	resource/dlgtemplates/SecurityPermissions.resx,$(O)\Microsoft.CLRAdmin.CSecPermControls.resources \
	resource/dlgtemplates/UIPermission.resx,$(O)\Microsoft.CLRAdmin.CUIPermControls.resources \
	resource/dlgtemplates/DNSPermission.resx,$(O)\Microsoft.CLRAdmin.CDNSPermControls.resources \
	resource/dlgtemplates/ComboBoxPermission.resx,$(O)\Microsoft.CLRAdmin.CComboBoxPermissionControls.resources \
	resource/dlgtemplates/SQLClientPermission.resx,$(O)\Microsoft.CLRAdmin.CSQLClientPermControls.resources \
	resource/dlgtemplates/OleDBPermission.resx,$(O)\Microsoft.CLRAdmin.COleDbPermControls.resources \
	resource/dlgtemplates/MessageQueuePermission.resx,$(O)\Microsoft.CLRAdmin.CMessageQueuePermControls.resources \
	resource/dlgtemplates/PropertyPage.resx,$(O)\Microsoft.CLRAdmin.CPropPage.resources \
	resource/dlgtemplates/WizardPage.resx,$(O)\Microsoft.CLRAdmin.CWizardPage.resources \
	mscorcfgstrings.txt,$(O)\mscorcfgstrings.resources \
	resource/html/mscorcfghtml.resx,$(O)\mscorcfghtml.resources

@$(O)\dlg_source:    
	echo 	/res:$(O)\Microsoft.CLRAdmin.CPropPage.resources \
	        /res:$(O)\Microsoft.CLRAdmin.CWizardPage.resources \
	        /res:$(O)\Microsoft.CLRAdmin.CMessageQueuePermControls.resources \
	        /res:$(O)\Microsoft.CLRAdmin.COleDbPermControls.resources \
            /res:$(O)\Microsoft.CLRAdmin.CSQLClientPermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CComboBoxPermissionControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CDNSPermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CUIPermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSecPermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CReflectPermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CIsoStoragePermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CTablePermControls.resources \
			/res:$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz3.resources \
			/res:$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz4.resources \
			/res:$(O)\Microsoft.CLRAdmin.CNewPermSetWiz1.resources \
			/res:$(O)\Microsoft.CLRAdmin.CNewPermSetWiz2.resources \
			/res:$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz1.resources \
			/res:$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz2.resources \
			/res:$(O)\Microsoft.CLRAdmin.CCreateDeploymentPackageWiz3.resources \
			/res:$(O)\Microsoft.CLRAdmin.CNewCodeGroupWiz2.resources \
			/res:$(O)\Microsoft.CLRAdmin.CEvalAssemWiz1.resources \
			/res:$(O)\Microsoft.CLRAdmin.CEvalAssemWiz2.resources \
			/res:$(O)\Microsoft.CLRAdmin.CEvalAssemWiz3.resources \
			/res:$(O)\Microsoft.CLRAdmin.CAssemVerCodebases.resources \
			/res:$(O)\Microsoft.CLRAdmin.CAssemBindPolicyProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CConfigAssemGeneralProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CConfigAssemWiz1.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSingleCodeGroupProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSinglePermissionSetProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CAppProps.resources \
			/res:$(O)\Microsoft.CLRAdmin.CChooseAppDialog.resources \
			/res:$(O)\Microsoft.CLRAdmin.CAssemGenProps.resources \
			/res:$(O)\Microsoft.CLRAdmin.CAssemPlatformProps.resources \
			/res:$(O)\Microsoft.CLRAdmin.CCustomCodegroupProp.resources \
		  	/res:$(O)\Microsoft.CLRAdmin.COpenSecurityPolicyDialog.resources \
    	  	/res:$(O)\Microsoft.CLRAdmin.CNewSecurityPolicyDialog.resources \
			/res:$(O)\Microsoft.CLRAdmin.CRemotingProp3.resources \
			/res:$(O)\Microsoft.CLRAdmin.CRemotingProp2.resources \
 			/res:$(O)\Microsoft.CLRAdmin.CRemotingProp1.resources \
 			/res:$(O)\Microsoft.CLRAdmin.CGeneralMachineProps.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSingleCodeGroupMemCondProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSingleCodeGroupPSetProp.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSecurityAdjustmentWiz2.resources \
			/res:$(O)\Microsoft.CLRAdmin.CSecurityAdjustmentWiz3.resources \
			/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz8.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz7.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz5.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz4.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz3.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz2.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CTrustAppWiz1.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CAssemblyDialog.resources \
    		/res:$(O)\Microsoft.CLRAdmin.CReadOnlyPermission.resources  > $(O)\dlg_source
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\loadassemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about how Assemblies should be loaded.
//

namespace Microsoft.CLRAdmin
  {
  using System;

  // The information to use when creating an Assembly or AssemblyName object.
  //
  // This provides the union of all data needed for each style of loading
  // an Assembly.  See AssemblyLoadAs.
  //
  // Multiple properties can be specified at the same time, if desired.
  // This is why Properties aren't used, and why each ``Set'' method returns
  // a LoadAssemblyInfo object.  This allows such things as:
  //
  //    LoadAssemblyInfo i = new LoadAssemblyInfo().SetAppPath ("D:\tmp");
  //
  // This is also useful in constructor base lists, which require that 
  // their parameters be done as one statement.
   internal class LoadAssemblyInfo
    {
    /** How to create Assembly & AssemblyName objects. */
    private AssemblyLoadAs m_load = AssemblyLoadAs.Custom;

    /** Paths to use when creating a new AppDomain. */
    private string  m_abp = null;
    private string  m_rsp = null;

    internal LoadAssemblyInfo ()
      {}

    /** Specify how Assemblies should be loaded. */
    internal LoadAssemblyInfo LoadAs (AssemblyLoadAs a)
      {m_load = a;
      return this;}

    /** How should Assemblies be loaded? */
    internal AssemblyLoadAs LoadAs ()
      {return m_load;}

    /** Specify the Application Base Path when creating an AppDomain. */
    internal LoadAssemblyInfo AppPath (string s)
      {m_abp = s;
      return this;}

    /** The Application Base Path for creating an AppDomain. */
    internal string AppPath ()
      {return m_abp;}

    /** Specify the Relative Search Path when creating an AppDomain. */
    internal LoadAssemblyInfo RelPath (string s)
      {m_rsp = s;
      return this;}

    /** The Relative Search Path for creating an AppDomain. */
    internal string RelPath ()
      {return m_rsp;}
    } /* class LoadAssemblyInfo */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\loadassembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Assembly loading.
//

namespace Microsoft.CLRAdmin
  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;
  using System.Runtime.Remoting;  // ObjectHandle

  // Defines:
  //  - The common interface for objects that create Assembly and 
  //    AssemblyName objects.
  //  - A way to create these objects based on the LoadAssemblyInfo object.
  internal abstract class LoadAssembly
    {
    /** Creates an object derived from LoadAssembly. */
    private delegate LoadAssembly _creator (LoadAssemblyInfo cai);

    // map<AssemblyLoadAs, _creator>
    private static IDictionary m_tbl;

    // Static class constructor which creates the map for use
    // in CreateLoader().
    static LoadAssembly ()
      {
      m_tbl = new Hashtable ();
      m_tbl.Add (AssemblyLoadAs.Default, new _creator(_create_default));
      m_tbl.Add (AssemblyLoadAs.Custom, new _creator(_create_custom));
      m_tbl.Add (AssemblyLoadAs.CustomGet, new _creator(_create_custom_get));
      }

    private static LoadAssembly _create_default (LoadAssemblyInfo cai)
      {return new LoadDefaultAssembly ();}

    private static LoadAssembly _create_custom (LoadAssemblyInfo cai)
      {return new LoadCustomAssembly (cai);}

    private static LoadAssembly _create_custom_get (LoadAssemblyInfo cai)
      {return new LoadCustomGetAssembly (cai);}

    // Create the Assembly referred to by ``an''.
    internal abstract AssemblyRef LoadAssemblyFrom (AssemblyName an);

    // Create an AssemblyName for the file-name ``name''.
    internal abstract AssemblyName LoadAssemblyName (string name);

    // Close/cleanup any resources created for all calls to LoadAssembly
    // & LoadAssemblyName.
    internal abstract void Dispose ();

    // Create a LoadAssembly object based on ``i''.
    //
    // If ``i.LoadAs()'' doesn't return a value from the AssemblyLoadAs
    // enumeration, then an exception is thrown.
    internal static LoadAssembly CreateLoader (LoadAssemblyInfo i)
      {
      Trace.WriteLine ("Creating Assembly Loader for:");
      Trace.WriteLine ("  LoadAs: " + i.LoadAs().ToString());
      Trace.WriteLine ("  AppBasePath: " + i.AppPath());
      Trace.WriteLine ("  RelativeSearchPath: " + i.RelPath());

      _creator c = (_creator) m_tbl[i.LoadAs()];

      if (c==null)
        throw 
          new Exception ("internal error: Invalid AssemblyLoadAs specified");

      return c (i);
      }
    }


  // Loads Assemblies into the current AppDomain.
  //
  // Corresponds to AssemblyLoadAs.Default.
  internal class LoadDefaultAssembly : LoadAssembly
    {
    /** Load the Assembly into the current AppDomain. */
    internal override AssemblyRef LoadAssemblyFrom (AssemblyName an)
      {
      Trace.WriteLine ("Loading a default assembly: " + an.FullName);
      AssemblyRef a = new AssemblyRef ();
      a.Load (an);
      return a;
      }

    /** Read the AssemblyName information from the file ``name''. */
    internal override AssemblyName LoadAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Shared AssemblyName");
      return AssemblyName.GetAssemblyName (name);
      }

    /** Don't do anything, as we never allocated any resources. */
    internal override void Dispose ()
      {}
    }


  // Loads Assemblies into their own AppDomain, using the paths
  // specified in the LoadAssemblyInfo object passed in the constructor.
  //
  // Corresponds to AssemblyLoadAs.Custom.
  internal class LoadCustomAssembly : LoadAssembly
    {
    LoadAssemblyInfo m_info;

    // list<AppDomain>
    IList m_ads = new ArrayList ();

    internal LoadCustomAssembly (LoadAssemblyInfo i)
      {m_info = i;}

    // Create the Assembly in its own AppDOmain.  In doing so, it
    // uses the custom paths (AppBase and Relative)
    // specified by the LoadAssemblyInfo object passed when this
    // object was created.
    internal override AssemblyRef LoadAssemblyFrom (AssemblyName an)
      {
      Trace.WriteLine ("Loading a custom assembly for: " + an.FullName);
      String fname = "";
      //String.Format (Localization.FMT_APPDOMAIN_NAME, 
      //  an.FullName);
      Trace.WriteLine ("  -- Friendly Name of new AppDomain: " + fname);
      AppDomain ad = AppDomain.CreateDomain (
        an.FullName,                // friendlyName
        null,                 // securityInfo
        m_info.AppPath(),     // appBasePath
        m_info.RelPath(),     // relativeSearchPath
        false                 // shadowCopyFiles
        );
      m_ads.Add (ad);
      Trace.WriteLine ("  -- created AppDomain");

      Type t = typeof (AssemblyRef);
      string aname = Assembly.GetExecutingAssembly().FullName;
      Trace.WriteLine ("Assembly containing AssemblyRef: " + aname);
      Trace.WriteLine ("Type full name: " + t.FullName);
      Trace.WriteLine ("Type name: " + t.Name);

      ObjectHandle oh = ad.CreateInstance (
        aname,                // Assembly file name
        t.FullName,           // Type name
        false,                // ignore case
        BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, // binding attributes
        null,                 // binder
        null,                 // args
        null,                 // culture info
        null,                 // activation attributes
        Assembly.GetExecutingAssembly().Evidence    // security attributes
        );

      AssemblyRef ar = (AssemblyRef) oh.Unwrap ();
      
      ar.Load (an);
      return ar;
      }

    /** Create an AssemblyName obect. */
    internal override AssemblyName LoadAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Shared AssemblyName");
      return AssemblyName.GetAssemblyName (name);
      }

    /** Shutdown all the AppDomains opened. */
    internal override void Dispose ()
      {
      foreach (AppDomain ad in m_ads)
        AppDomain.Unload (ad);
      m_ads.Clear ();
      }
    }


  // Loads Assemblies into their own AppDomain, but uses
  // AssemblyName.GetAssemblyName to read a file to get the AssemblyName.
  //
  // Corresponds to AssemblyLoadAs.CustomGet.
  internal class LoadCustomGetAssembly : LoadCustomAssembly
    {
    internal LoadCustomGetAssembly (LoadAssemblyInfo i)
      : base (i)
      {}

    /** Create an AssemblyName obect. */
    internal override AssemblyName LoadAssemblyName (string name)
      {
      Trace.WriteLine ("Creating Custom AssemblyName");
      AssemblyName an = new AssemblyName ();
      an.CodeBase = name;
      return an;
      }
    } /* class LoadCustomGetAssembly */

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\mmcinterfaces.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// mmcInterfaces.cs
//
// Contains definitions for various interfaces used by a MMC snapin
//
// NOTE: This is not an all-encompasing list of every interface
// available to a snapin
//-------------------------------------------------------------


namespace Microsoft.CLRAdmin
{

using System;
using System.Runtime.InteropServices;

//-------------------------------------------------------------
// Note on all interfaces:
//
// Though C# and .NET intend to use namespaces to replace GUIDs, 
// they must still be used here with every interface. This is 
// necessary because, when creating a MMC snapin,  we are dealing 
// with a classic COM server and client; hence, we must use the
// GUIDs so the classic COM portion of MMC does not get 
// confused.
//-------------------------------------------------------------

//------------------------------------------\\
// Interfaces that need to be implemented   \\ 
//------------------------------------------\\

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("955AB28A-5218-11D0-A985-00C04FD8D565")]
public interface IComponentData
{
    void Initialize([MarshalAs(UnmanagedType.Interface)] Object pUnknown);
 	void CreateComponent(out IComponent ppComponent);
    [PreserveSig()]
	int Notify(IDataObject lpDataObject, uint aevent, IntPtr arg, IntPtr param);
    void Destroy();
    void QueryDataObject(int cookie, uint type, out IDataObject ppDataObject);
    void GetDisplayInfo(ref SCOPEDATAITEM ResultDataItem);
    [PreserveSig()]
    int CompareObjects(IDataObject lpDataObjectA, IDataObject lpDataObjectB);
}// interface IComponentData

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("43136EB2-D36C-11CF-ADBC-00AA00A80033")]
public interface IComponent
{
 	void Initialize([MarshalAs(UnmanagedType.Interface)]Object lpConsole);
    [PreserveSig()]
	int Notify(IntPtr lpDataObject, uint aevent, IntPtr arg, IntPtr param);
 	void Destroy(int cookie);
 	void QueryDataObject(int cookie, uint type, out IDataObject ppDataObject);
    [PreserveSig()]
	int GetResultViewType(int cookie, out IntPtr ppViewType, out uint pViewOptions);
    void GetDisplayInfo(ref RESULTDATAITEM ResultDataItem);
    [PreserveSig()]
	int CompareObjects(IDataObject lpDataObjectA, IDataObject lpDataObjectB);
}// interface IComponent

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("1245208C-A151-11D0-A7D7-00C04FD909DD")]
public interface ISnapinAbout
{
	void GetSnapinDescription(out IntPtr lpDescription);
	void GetProvider(out IntPtr pName);
	void GetSnapinVersion(out IntPtr lpVersion);
	void GetSnapinImage(out IntPtr hAppIcon);
	void GetStaticFolderImage(out IntPtr hSmallImage, out IntPtr hSmallImageOpen, out IntPtr hLargeImage, out int cMask);
}// interface ISnapinAbout

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("0000010e-0000-0000-C000-000000000046")]
public interface IDataObject
{
    [PreserveSig()]
    int GetData(ref FORMATETC pFormatEtc, ref STGMEDIUM b);
    [PreserveSig()]
    int GetDataHere(ref FORMATETC pFormatEtc, ref STGMEDIUM b);
    [PreserveSig()]
    int QueryGetData(IntPtr a);
    [PreserveSig()]
    int GetCanonicalFormatEtc(IntPtr a, IntPtr b);
    [PreserveSig()]
    int SetData(IntPtr a, IntPtr b, int c);
    [PreserveSig()]
    int EnumFormatEtc(uint a, IntPtr b);
    [PreserveSig()]
    int DAdvise(IntPtr a, uint b, IntPtr c, ref uint d);
    [PreserveSig()]
    int DUnadvise(uint a);
    [PreserveSig()]
    int EnumDAdvise(IntPtr a);
}// interface IDataObject

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("4861A010-20F9-11d2-A510-00C04FB6DD2C")]
public interface ISnapinHelp2
{
    [PreserveSig()]
    int GetHelpTopic(out IntPtr lpCompiledHelpFile);
    [PreserveSig()]
    int GetLinkedTopics(out IntPtr lpCompiledHelpFiles);
}// ISnapinHelp2


[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("cc593830-b926-11d1-8063-0000f875a9ce")]
public interface IDisplayHelp
{
    void ShowTopic([MarshalAs(UnmanagedType.LPWStr)] String pszHelpTopic);
}// IDisplayHelp


[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0")]
public interface IExtendContextMenu
{
    void AddMenuItems(IDataObject piDataObject, IContextMenuCallback piCallback, ref int pInsertionAllowed);
    void Command(int lCommandID, IDataObject piDataObject);
}// IExtendContextMenu

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("49506520-6F40-11D0-A98B-00C04FD8D565")]
public interface IExtendControlbar
{
    void SetControlbar(IControlbar pControlbar);
    [PreserveSig()]
    int ControlbarNotify(uint aevent, int arg, int param);
}// IExtendControlbar

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("85DE64DC-EF21-11cf-A285-00C04FD8DBE6")]
public interface IExtendPropertySheet
{
    [PreserveSig()]
    int CreatePropertyPages(IPropertySheetCallback lpProvider, IntPtr handle, IDataObject lpIDataObject);
    [PreserveSig()]
    int QueryPagesFor(IDataObject lpDataObject);
}// IExtendPropertySheet


[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("B7A87232-4A51-11D1-A7EA-00C04FD909DD")]
public interface IExtendPropertySheet2
{
    [PreserveSig()]
    int CreatePropertyPages(IPropertySheetCallback lpProvider, IntPtr handle, IDataObject lpIDataObject);
    [PreserveSig()]
    int QueryPagesFor(IDataObject lpDataObject);
    [PreserveSig()]
    int GetWatermarks(IDataObject lpIDataObject, out IntPtr lphWatermark, out IntPtr lphHeader, out IntPtr lphPalette, out int bStretch);
}// IExtendPropertySheet2

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("8dee6511-554d-11d1-9fea-00600832db4a")]
public interface IExtendTaskPad
{
    void TaskNotify(IDataObject pdo, ref Object arg, ref Object param);
    void EnumTasks(IDataObject pdo, [MarshalAs(UnmanagedType.LPWStr)] String szTaskGroup, [MarshalAs(UnmanagedType.Interface)] out IEnumTASK ppEnumTASK);
    void GetTitle([MarshalAs(UnmanagedType.LPWStr)] String pszGroup, [MarshalAs(UnmanagedType.LPWStr)] out String pszTitle);
    void GetDescriptiveText([MarshalAs(UnmanagedType.LPWStr)] String pszGroup, [MarshalAs(UnmanagedType.LPWStr)] out String pszDescriptiveText);
    void GetBackground([MarshalAs(UnmanagedType.LPWStr)] String pszGroup, out MMC_TASK_DISPLAY_OBJECT pTDO);
    void GetListPadInfo([MarshalAs(UnmanagedType.LPWStr)] String pszGroup, out MMC_LISTPAD_INFO lpListPadInfo);
}// IExtendTaskPad        

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("338698b1-5a02-11d1-9fec-00600832db4a")]
public interface IEnumTASK
{
    [PreserveSig()]
    int Next(uint celt, ref MMC_TASK rgelt, ref uint pceltFetched);
    [PreserveSig()]
    int Skip(uint celt);
    [PreserveSig()]
    int Reset();
    [PreserveSig()]
    int Clone(ref IEnumTASK ppenum);
}// interface IEnumTASK

//------------------------------------------\\
// Interfaces implemented by MMC            \\ 
// (No need to implement them... yeah!)     \\
//------------------------------------------\\
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("85DE64DE-EF21-11cf-A285-00C04FD8DBE6")]
public interface IPropertySheetProvider
{
    void CreatePropertySheet([MarshalAs(UnmanagedType.LPWStr)]String title, int type, int cookie, IDataObject pIDataObjectm, uint dwOptions);
    [PreserveSig()]
    int FindPropertySheet(int cookie, IComponent lpComponent, IDataObject lpDataObject);
    void AddPrimaryPages([MarshalAs(UnmanagedType.Interface)]Object lpUnknown, int bCreateHandle, int hNotifyWindow,int bScopePane);
    void AddExtensionPages();
    void Show(IntPtr window, int page);
}// IPropertySheetProvider   

[ComImport, Guid("43136EB5-D36C-11cf-ADBC-00AA00A80033")]
class NodeManager
{
}// NodeManager   

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("85DE64DD-EF21-11cf-A285-00C04FD8DBE6")]
public interface IPropertySheetCallback
{
    void AddPage(IntPtr hPage);
    void RemovePage(IntPtr hPage);
}// IPropertySheetCallback

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("255F18CC-65DB-11D1-A7DC-00C04FD8D565")]
public interface IConsoleNameSpace2
{
    void InsertItem(ref SCOPEDATAITEM a);
    void DeleteItem(int a, int b);
    void SetItem(ref SCOPEDATAITEM a);
    void GetItem(ref SCOPEDATAITEM a);
    void GetChildItem(uint a, ref uint b, ref int c);
    void GetNextItem(uint a, ref uint b, ref int c);
    void GetParentItem(int a, out int b, out int c);
    void Expand(int a);
    void AddExtension(CLSID a, ref SCOPEDATAITEM b); 
}// IConsoleNameSpace2

  
[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("43136EB3-D36C-11CF-ADBC-00AA00A80033")]
public interface IHeaderCtrl
{
    void InsertColumn(int nCol, [MarshalAs(UnmanagedType.LPWStr)] String title,int nFormat,int nWidth);
    void DeleteColumn(int nCol);
    void SetColumnText(int nCol, [MarshalAs(UnmanagedType.LPWStr)] String title);
    void GetColumnText(int nCol,out int pText);
    void SetColumnWidth(int nCol, int nWidth);
    void GetColumnWidth(int nCol, out int pWidth);
 }// IHeaderCtrl

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6")]
public interface IResultData 
{
    void InsertItem(ref RESULTDATAITEM item);
    void DeleteItem(uint itemID, int nCol);
    void FindItemByLParam(int lParam, out uint pItemID);
    void DeleteAllRsltItems();
    void SetItem(ref RESULTDATAITEM item);
    [PreserveSig()]
    int  GetItem(ref RESULTDATAITEM item);
    [PreserveSig()]
    int  GetNextItem(ref RESULTDATAITEM item);
    void ModifyItemState(int nIndex, uint itemID, uint uAdd, uint uRemove);
    void ModifyViewStyle(int add, int remove);
    void SetViewMode(int lViewMode);
    void GetViewMode(out int lViewMode);
    void UpdateItem(uint itemID);
    void Sort(int nColumn, uint dwSortOptions, int lUserParam);
    void SetDescBarText(int DescText);
    void SetItemCount(int nItemCount, uint dwOptions);
}// IResultData

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("43136EB8-D36C-11CF-ADBC-00AA00A80033")]
public interface IImageList
{
    void ImageListSetIcon(IntPtr pIcon, int nLoc);
    void ImageListSetStrip(int pBMapSm, int pBMapLg, int nStartLoc, int cMask);
}// IImageList

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("103D842A-AA63-11D1-A7E1-00C04FD8D565")]
public interface IConsole2
{
    void SetHeader(ref IHeaderCtrl pHeader);
    void SetToolbar([MarshalAs(UnmanagedType.Interface)] ref Object pToolbar); // Needs to be LPTOOLBAR 
    void QueryResultView([MarshalAs(UnmanagedType.Interface)] out Object pUnknown);
    void QueryScopeImageList(out IImageList ppImageList);
    void QueryResultImageList(out IImageList ppImageList);
    void UpdateAllViews(IDataObject lpDataObject, int data, int hint);
    void MessageBox([MarshalAs(UnmanagedType.LPWStr)] String lpszText, [MarshalAs(UnmanagedType.LPWStr)] String lpszTitle, uint fuStyle, ref int piRetval);
    void QueryConsoleVerb(out IConsoleVerb ppConsoleVerb);
    void SelectScopeItem(int hScopeItem);
    void GetMainWindow(out IntPtr phwnd);
    void NewWindow(int hScopeItem, uint lOptions);
    void Expand(int hItem, int bExpand);
    void IsTaskpadViewPreferred();
    void SetStatusText([MarshalAs(UnmanagedType.LPWStr)]String pszStatusText);
}// IConsole2

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("43136EB7-D36C-11CF-ADBC-00AA00A80033")]
public interface IContextMenuCallback
{
    void AddItem(ref CONTEXTMENUITEM pItem);
}// IContextMenuCallback

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("69FB811E-6C1C-11D0-A2CB-00C04FD909DD")]
public interface IControlbar
{
    void Create(MMC_CONTROL_TYPE nType, IExtendControlbar pExtendControlbar, [MarshalAs(UnmanagedType.Interface)] out Object ppUnknown);
    void Attach(MMC_CONTROL_TYPE nType, [MarshalAs(UnmanagedType.Interface)] Object lpUnknown);
    void Detach([MarshalAs(UnmanagedType.Interface)] Object lpUnknown);
}// IControlbar

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("43136EB9-D36C-11CF-ADBC-00AA00A80033")]
public interface IToolbar
{
    void AddBitmap(int nImages, IntPtr hbmp, int cxSize, int cySize, int crMask);
    void AddButtons(int nButtons, ref MMCBUTTON lpButtons);
    void InsertButton(int nIndex, ref MMCBUTTON lpButton);
    void DeleteButton(int nIndex);
    void GetButtonState(int idCommand, MMC_BUTTON_STATE nState, out int pState);
    void SetButtonState(int idCommand, MMC_BUTTON_STATE nState, int bState);
}// IToolbar   

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("E49F7A60-74AF-11D0-A286-00C04FD8FE93")]
public interface IConsoleVerb 
{
    void GetVerbState(uint eCmdID, uint nState, ref int pState);
    void SetVerbState(uint eCmdID, uint nState, int bState);
    void SetDefaultVerb(uint eCmdID);
    void GetDefaultVerb(ref uint peCmdID);
}// IConsoleVerb


//--------------------------------------------------------------------
// The following interfaces are not MMC specific interfaces and do not 
// need to be implemented, but their details must be known by the snapin;
// thus, we're defining them here. I don't make any guarantees that the
// interfaces are 100% accurate.... I could be missing "ref" or have extra
// "ref" parameters in these. I only know for certain that Write works.
//--------------------------------------------------------------------

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("0000000c-0000-0000-C000-000000000046")]
public interface IStream 
{
    void Read(IntPtr pv, uint cb, out uint pcbRead);
    void Write(IntPtr pv, uint cb, out uint pcbWritten);
    void Seek(long dlibMove, uint dwOrigin, out ulong plibNewPosition);
    void SetSize(ulong libNewSize);
    void CopyTo(IStream pstm, ulong cb, out ulong pcbRead, out ulong pcbWritten);
    void Commit(uint grfCommitFlags);
    void Revert();
    void LockRegion(ulong libOffset, ulong cb, uint dwLockType);
    void UnlockRegion(ulong libOffset, ulong cb, uint dwLockType);
    void Stat(out STATSTG pstatstg, uint grfStatFlag);
    void Clone(out IStream ppstm);
}// IStream

[ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("00000121-0000-0000-C000-000000000046")]
public interface IDropSource
{
    void QueryContinueDrag(int fEscapePressed, uint grfKeyState);
    void GiveFeedback(uint dwEffect);
}// IDropSource



}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\isolatedstorageperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// IsolatedStoragePerm.cs
//
// This implements both a property page and a dialog allowing
// the user the modify a IsolatedStorageFilePermission
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;

//-------------------------------------------------
// CIsoStoragePermDialog
//
// This class is used to generate a read-write dialog
// for an IsolatedStorageFilePermission.
//-------------------------------------------------

internal class CIsoStoragePermDialog: CPermDialog
{
    //-------------------------------------------------
    // CIsoStoragePermDialog - Constructor
    //
    // The constructor takes in a permission that the dialog
    // will use to display default values
    //-------------------------------------------------
    internal CIsoStoragePermDialog(IsolatedStoragePermission perm)
    {
        this.Text = CResourceStore.GetString("Isolatedstorageperm:PermName");
        m_PermControls = new CIsoStoragePermControls(perm, this);
        Init();        
    }// CIsoStoragePermDialog  
}// class CIsoStoragePermDialog

//-------------------------------------------------
// CIsoStoragePermPropPage
//
// This class is used to generate a read-write property-page
// for an IsolatedStorageFilePermission
//-------------------------------------------------
internal class CIsoStoragePermPropPage: CPermPropPage
{
    //-------------------------------------------------
    // CIsoStoragePermPropPage - Constructor
    //
    // Initializes the property page with the permisison set
    // that it will be modifying
    //-------------------------------------------------
    internal CIsoStoragePermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("Isolatedstorageperm:PermName"); 
    }// CIsoStoragePermPropPage

    //-------------------------------------------------
    // CreateControls
    //
    // Pulls the IsolatedStorageFilePermission out of the
    // permission set and creates the controls used to
    // display the permission
    //-------------------------------------------------
    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(IsolatedStorageFilePermission));
        m_PermControls = new CIsoStoragePermControls(perm, this);
    }// CreateControls
   
}// class CIsoStoragePermPropPage

//-------------------------------------------------
// CIsoStoragePermControls
//
// This class is responsible for managing the controls
// that are used to configure an IsolatedStorageFilePermission.
// 
// This class doesn't care where the controls are placed...
// it can be either a form or a property page or ???
//-------------------------------------------------
internal class CIsoStoragePermControls : CPermControls
{
    // Controls on the page
    private ComboBox m_cbUsage;
    private Label m_lblDiskQuota;
    private Label m_lblQuotaDes;
    private Label m_lblBytes;
    private Label m_lblUsageAllowed;
    private TextBox m_txtDiskQuota;
    private Label m_lblUsageDescription;

    // These constants must stay in line with how things are added to the combo box
    private const int ADMINBYUSER       = 0;
    private const int ASSEMBLYISO       = 1;
    private const int ASSEMBLYISOROAM   = 2;
    private const int DOMAINISO         = 3;
    private const int DOMAINISOROAM     = 4;
    private const int NONE              = 5;
    
    //-------------------------------------------------
    // CIsoStoragePermControls - Constructor
    //
    //-------------------------------------------------
    internal CIsoStoragePermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new IsolatedStorageFilePermission(PermissionState.None);
    }// CIsoStoragePermControls

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // Inserts controls into the given control collection
    //-------------------------------------------------

    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CIsoStoragePermControls));
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_cbUsage = new System.Windows.Forms.ComboBox();
        this.m_lblDiskQuota = new System.Windows.Forms.Label();
        this.m_lblQuotaDes = new System.Windows.Forms.Label();
        this.m_lblBytes = new System.Windows.Forms.Label();
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_lblUsageAllowed = new System.Windows.Forms.Label();
        this.m_txtDiskQuota = new System.Windows.Forms.TextBox();
        this.m_lblUsageDescription = new System.Windows.Forms.Label();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_cbUsage.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbUsage.DropDownWidth = 224;
        this.m_cbUsage.Location = ((System.Drawing.Point)(resources.GetObject("m_cbUsage.Location")));
        this.m_cbUsage.Size = ((System.Drawing.Size)(resources.GetObject("m_cbUsage.Size")));
        this.m_cbUsage.TabIndex = ((int)(resources.GetObject("m_cbUsage.TabIndex")));
        m_cbUsage.Name = "Usage";
        this.m_lblDiskQuota.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDiskQuota.Location")));
        this.m_lblDiskQuota.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDiskQuota.Size")));
        this.m_lblDiskQuota.TabIndex = ((int)(resources.GetObject("m_lblDiskQuota.TabIndex")));
        this.m_lblDiskQuota.Text = resources.GetString("m_lblDiskQuota.Text");
        m_lblDiskQuota.Name = "DiskQuotaLabel";
        this.m_lblQuotaDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblQuotaDes.Location")));
        this.m_lblQuotaDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblQuotaDes.Size")));
        this.m_lblQuotaDes.TabIndex = ((int)(resources.GetObject("m_lblQuotaDes.TabIndex")));
        this.m_lblQuotaDes.Text = resources.GetString("m_lblQuotaDes.Text");
        m_lblQuotaDes.Name = "DiskQuotaDescription";
        this.m_lblBytes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblBytes.Location")));
        this.m_lblBytes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblBytes.Size")));
        this.m_lblBytes.TabIndex = ((int)(resources.GetObject("m_lblBytes.TabIndex")));
        this.m_lblBytes.Text = resources.GetString("m_lblBytes.Text");
        m_lblBytes.Name = "BytesLabel";
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_lblUsageAllowed.Location = ((System.Drawing.Point)(resources.GetObject("m_lblUsageAllowed.Location")));
        this.m_lblUsageAllowed.Size = ((System.Drawing.Size)(resources.GetObject("m_lblUsageAllowed.Size")));
        this.m_lblUsageAllowed.TabIndex = ((int)(resources.GetObject("m_lblUsageAllowed.TabIndex")));
        this.m_lblUsageAllowed.Text = resources.GetString("m_lblUsageAllowed.Text");
        m_lblUsageAllowed.Name = "UsageAllowedLabel";
        this.m_txtDiskQuota.Location = ((System.Drawing.Point)(resources.GetObject("m_txtDiskQuota.Location")));
        this.m_txtDiskQuota.Size = ((System.Drawing.Size)(resources.GetObject("m_txtDiskQuota.Size")));
        this.m_txtDiskQuota.TabIndex = ((int)(resources.GetObject("m_txtDiskQuota.TabIndex")));
        this.m_txtDiskQuota.Text = resources.GetString("m_txtDiskQuota.Text");
        m_txtDiskQuota.Name = "DiskQuota";
        this.m_lblUsageDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblUsageDescription.Location")));
        this.m_lblUsageDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblUsageDescription.Size")));
        this.m_lblUsageDescription.TabIndex = ((int)(resources.GetObject("m_lblUsageDescription.TabIndex")));
        m_lblUsageDescription.Name = "UsageDescription";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblUsageAllowed,
                        this.m_cbUsage,
                        this.m_lblQuotaDes,
                        this.m_lblDiskQuota,
                        this.m_txtDiskQuota,
                        this.m_lblUsageDescription,
                        this.m_lblBytes});
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted,
                        });
        // Fill in the data
        PutValuesinPage();

        // Hook up event handlers
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_cbUsage.SelectedIndexChanged += new EventHandler(onChange);
        m_cbUsage.SelectedIndexChanged += new EventHandler(onUsageChange);
        m_txtDiskQuota.TextChanged += new EventHandler(onChange);
        m_txtDiskQuota.KeyPress+= new KeyPressEventHandler(onKeyPress);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);
        

        return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // onUsageChange
    //
    // Event handler that gets fired when the user changes
    // the value of the combobox. It changes the descriptive
    // text for the combobox value
    //-------------------------------------------------
    void onUsageChange(Object o, EventArgs e)
    {
   
        if (m_cbUsage.SelectedIndex == ADMINBYUSER)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:AdministerByUDDes");

        else if (m_cbUsage.SelectedIndex == ASSEMBLYISO)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:AssemIsoByUDDes");

        else if (m_cbUsage.SelectedIndex == ASSEMBLYISOROAM)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:AssemIsoByURoamDes");

        else if (m_cbUsage.SelectedIndex == DOMAINISO)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:DomainIsoByUDDes");

        else if (m_cbUsage.SelectedIndex == DOMAINISOROAM)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:DomainIsoByURoamDes");

        else if (m_cbUsage.SelectedIndex == NONE)
            m_lblUsageDescription.Text = CResourceStore.GetString("Isolatedstorageperm:NoneDes");
        else 
            m_lblUsageDescription.Text = "";
    }// onUsageChange

    //-------------------------------------------------
    // PutValuesinPage
    //
    // Initializes the controls with the provided permission
    //-------------------------------------------------
    protected override void PutValuesinPage()
    {
        // Put stuff in the combo box
        m_cbUsage.Items.Clear();
        // Make sure these get added in this order
        m_cbUsage.Items.Add(CResourceStore.GetString("IsolatedStorageFilePermission:AdministerIsolatedStorageByUser"));
        m_cbUsage.Items.Add(CResourceStore.GetString("IsolatedStorageFilePermission:AssemblyIsolatationByUser"));
        m_cbUsage.Items.Add(CResourceStore.GetString("IsolatedStorageFilePermission:AssemblyIsolatationByUserRoam"));
        m_cbUsage.Items.Add(CResourceStore.GetString("IsolatedStorageFilePermission:DomainIsolatationByUser"));
        m_cbUsage.Items.Add(CResourceStore.GetString("IsolatedStorageFilePermission:DomainIsolatationByUserRoam"));
        m_cbUsage.Items.Add(CResourceStore.GetString("None"));

        IsolatedStoragePermission perm = (IsolatedStoragePermission)m_perm;
   
        if (perm.IsUnrestricted())
        {
            m_radUnrestricted.Checked=true;
            m_ucOptions.Enabled = false;
            m_cbUsage.SelectedIndex = 0;

        }
        else
        {
            m_radGrantFollowingPermission.Checked=true;

            if (perm.UsageAllowed == IsolatedStorageContainment.AdministerIsolatedStorageByUser)
                m_cbUsage.SelectedIndex=ADMINBYUSER;
            else if (perm.UsageAllowed == IsolatedStorageContainment.AssemblyIsolationByUser)
                m_cbUsage.SelectedIndex=ASSEMBLYISO;
            else if (perm.UsageAllowed == IsolatedStorageContainment.AssemblyIsolationByRoamingUser)
                m_cbUsage.SelectedIndex=ASSEMBLYISOROAM;
            else if (perm.UsageAllowed == IsolatedStorageContainment.DomainIsolationByUser)
                m_cbUsage.SelectedIndex=DOMAINISO;
            else if (perm.UsageAllowed == IsolatedStorageContainment.DomainIsolationByRoamingUser)
                m_cbUsage.SelectedIndex=DOMAINISOROAM;
            else if (perm.UsageAllowed == IsolatedStorageContainment.None)
                m_cbUsage.SelectedIndex=NONE;

            
            m_txtDiskQuota.Text = perm.UserQuota.ToString();

        }
        onUsageChange(null, null);
    }// PutValuesinPage

    internal override bool ValidateData()
    {
        if (m_radUnrestricted.Checked != true)
        {
           try
           {
               // Make sure they've entered a valid positive quota
               if (Int64.Parse(m_txtDiskQuota.Text) < 0)
                   throw new Exception();
           }
           catch(Exception)
           {
               MessageBox(CResourceStore.GetString("IsolatedStoragePerm:InvalidQuota"),
                          CResourceStore.GetString("IsolatedStoragePerm:InvalidQuotaTitle"),
                          MB.ICONEXCLAMATION);
               return false;
           }
        }
        return true;
    }// ValidateData


    //-------------------------------------------------
    // GetCurrentPermission
    //
    // This builds a permission based on the values of
    // the controls
    //-------------------------------------------------
    internal override IPermission GetCurrentPermission()
    {
        IsolatedStoragePermission perm;
        if (m_radUnrestricted.Checked == true)
            perm = new IsolatedStorageFilePermission(PermissionState.Unrestricted);
        else
        {
            IsolatedStorageContainment isc;

            switch(m_cbUsage.SelectedIndex)
            {
                case ADMINBYUSER:
                    isc = IsolatedStorageContainment.AdministerIsolatedStorageByUser;
                    break;
                case ASSEMBLYISO:
                    isc = IsolatedStorageContainment.AssemblyIsolationByUser;
                    break;
                case ASSEMBLYISOROAM:
                    isc = IsolatedStorageContainment.AssemblyIsolationByRoamingUser;
                    break;
                case DOMAINISO:
                    isc = IsolatedStorageContainment.DomainIsolationByUser;
                    break;
                case DOMAINISOROAM:
                    isc = IsolatedStorageContainment.DomainIsolationByRoamingUser;
                    break;
                    
                default:
                    isc = IsolatedStorageContainment.None;
                    break;
            }

            perm = new IsolatedStorageFilePermission(PermissionState.None);
            perm.UsageAllowed = isc;
            try
            {
                perm.UserQuota = Int64.Parse(m_txtDiskQuota.Text);
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("IsolatedStoragePerm:InvalidQuota"),
                           CResourceStore.GetString("IsolatedStoragePerm:InvalidQuotaTitle"),
                           MB.ICONEXCLAMATION);
                return null;
            }
        }

        return perm;
    }// GetCurrentPermission

    //-------------------------------------------------
    // onChange
    //
    // Event Handler that turns on the Apply button on 
    // property pages
    //-------------------------------------------------
    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

    //-------------------------------------------------
    // onKeyPress
    //
    // Intercepts key presses in the quota textbox 
    //-------------------------------------------------
    void onKeyPress(Object o, KeyPressEventArgs e)
    {

        // We only care about the numbers that the user enters... If the user enters
        // a number, inform the text box control that we did not handle the event, 
        // and so the text box should take care of it. If the user enters anything else,
        // tell the textbox control that we handled it, so the textbox control will ignore the input.

        if (Char.IsLetter(e.KeyChar) || Char.IsPunctuation(e.KeyChar) || Char.IsSeparator(e.KeyChar))
            e.Handled=true;
    }// onKeyPress
}// class CSecPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\messagequeuepermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// MessageQueuePermission.cs
//
// This implements both a property page and a dialog allowing
// the user the modify a MessageQueuePermission
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Messaging;

//-------------------------------------------------
// CMessageQueuePermDialog
//
// This class is used to generate a read-write dialog
// for an MessageQueuePermission.
//-------------------------------------------------
internal class CMessageQueuePermDialog: CPermDialog
{
    //-------------------------------------------------
    // CMessageQueuePermDialog - Constructor
    //
    // The constructor takes in a permission that the dialog
    // will use to display default values
    //-------------------------------------------------
    internal CMessageQueuePermDialog(MessageQueuePermission perm) : base()
    {
        this.Text = CResourceStore.GetString("MessageQueuePermission:PermName");
        m_PermControls = new CMessageQueuePermControls(perm, this);
        Init();        
    }// CMessageQueuePermDialog 
}// class CMessageQueuePermDialog

//-------------------------------------------------
// CMessageQueuePermPropPage
//
// This class is used to generate a read-write property-page
// for an MessageQueuePermission
//-------------------------------------------------
internal class CMessageQueuePermPropPage: CPermPropPage
{
    //-------------------------------------------------
    // CMessageQueuePermPropPage - Constructor
    //
    // Initializes the property page with the permisison set
    // that it will be modifying
    //-------------------------------------------------
    internal CMessageQueuePermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("MessageQueuePermission:PermName"); 
    }// CMessageQueuePermPropPage

    //-------------------------------------------------
    // CreateControls
    //
    // Pulls the MessageQueuePermission out of the
    // permission set and creates the controls used to
    // display the permission
    //-------------------------------------------------
    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(MessageQueuePermission));
        m_PermControls = new CMessageQueuePermControls(perm, this);
    }// CreateControls

}// class CMessageQueuePermPropPage

//-------------------------------------------------
// CMessageQueuePermControls
//
// This class is responsible for managing the controls
// that are used to configure an MessageQueuePermission.
// 
// This class doesn't care where the controls are placed...
// it can be either a form or a property page or ???
//-------------------------------------------------

internal class CMessageQueuePermControls : CPermControls
{
    // Internal data
    private MyDataGrid m_dgOther;
    private Button m_btnDeletePath;
    private Label m_lblPathDes;
    private MyDataGrid m_dgPath;
    private Button m_btnDeleteOther;
    private Label m_lblOtherDes;

    private DataTable   m_dtPath;
    private DataTable   m_dtOther;
    private DataSet     m_ds;

    //-------------------------------------------------
    // CMessageQueuePermControls - Constructor
    //
    //-------------------------------------------------
    internal CMessageQueuePermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new MessageQueuePermission(PermissionState.None);
    }// CMessageQueuePermControls

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // Inserts controls into the given control collection
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CMessageQueuePermControls));
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_dgOther = new MyDataGrid();
        this.m_btnDeletePath = new System.Windows.Forms.Button();
        this.m_lblPathDes = new System.Windows.Forms.Label();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_dgPath = new MyDataGrid();
        this.m_btnDeleteOther = new System.Windows.Forms.Button();
        this.m_lblOtherDes = new System.Windows.Forms.Label();
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Name = "Unrestricted";
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblPathDes,
                        this.m_dgPath,
                        this.m_btnDeletePath,
                        this.m_lblOtherDes,
                        this.m_dgOther,
                        this.m_btnDeleteOther
                        });
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Name = "Options";
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        this.m_dgOther.DataMember = "";
        this.m_dgOther.Location = ((System.Drawing.Point)(resources.GetObject("m_dgOther.Location")));
        this.m_dgOther.Name = "OtherTable";
        this.m_dgOther.Size = ((System.Drawing.Size)(resources.GetObject("m_dgOther.Size")));
        this.m_dgOther.TabIndex = ((int)(resources.GetObject("m_dgOther.TabIndex")));
        this.m_btnDeletePath.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDeletePath.Location")));
        this.m_btnDeletePath.Name = "DeletePath";
        this.m_btnDeletePath.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDeletePath.Size")));
        this.m_btnDeletePath.TabIndex = ((int)(resources.GetObject("m_btnDeletePath.TabIndex")));
        this.m_btnDeletePath.Text = resources.GetString("m_btnDeletePath.Text");
        this.m_lblPathDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPathDes.Location")));
        this.m_lblPathDes.Name = "PathDescription";
        this.m_lblPathDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPathDes.Size")));
        this.m_lblPathDes.TabIndex = ((int)(resources.GetObject("m_lblPathDes.TabIndex")));
        this.m_lblPathDes.Text = resources.GetString("m_lblPathDes.Text");
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Name = "Restricted";
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        this.m_dgPath.DataMember = "";
        this.m_dgPath.Location = ((System.Drawing.Point)(resources.GetObject("m_dgPath.Location")));
        this.m_dgPath.Name = "PathTable";
        this.m_dgPath.Size = ((System.Drawing.Size)(resources.GetObject("m_dgPath.Size")));
        this.m_dgPath.TabIndex = ((int)(resources.GetObject("m_dgPath.TabIndex")));
        this.m_btnDeleteOther.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDeleteOther.Location")));
        this.m_btnDeleteOther.Name = "DeleteOther";
        this.m_btnDeleteOther.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDeleteOther.Size")));
        this.m_btnDeleteOther.TabIndex = ((int)(resources.GetObject("m_btnDeleteOther.TabIndex")));
        this.m_btnDeleteOther.Text = resources.GetString("m_btnDeleteOther.Text");
        this.m_lblOtherDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblOtherDes.Location")));
        this.m_lblOtherDes.Name = "OtherDescription";
        this.m_lblOtherDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblOtherDes.Size")));
        this.m_lblOtherDes.TabIndex = ((int)(resources.GetObject("m_lblOtherDes.TabIndex")));
        this.m_lblOtherDes.Text = resources.GetString("m_lblOtherDes.Text");
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_ucOptions,
                        this.m_radUnrestricted,
                        this.m_radGrantFollowingPermission});

        m_dtPath = CreatePathDataTable(m_dgPath);
        m_dtOther = CreateOtherDataTable(m_dgOther);

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dtPath);
        m_ds.Tables.Add(m_dtOther);

        m_dgPath.DataSource = m_dtPath;
        m_dgOther.DataSource = m_dtOther;
        
    
        // Set up the GUI-type stuff for the data grid
        m_dgPath.CaptionVisible=false;
        m_dgPath.BackgroundColor = Color.White;

        m_dgOther.CaptionVisible=false;
        m_dgOther.BackgroundColor = Color.White;

        // Fill in the data
        PutValuesinPage();

        // Set up any callbacks
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_dgPath.CurrentCellChanged+=new EventHandler(onChange);        
        m_dgOther.CurrentCellChanged+=new EventHandler(onChange);        
        m_btnDeletePath.Click += new EventHandler(onDeleteEntireRow);
        m_btnDeleteOther.Click += new EventHandler(onDeleteEntireRow);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_dgPath.CurrentCellChanged += new EventHandler(onCellChange);
        m_dgOther.CurrentCellChanged += new EventHandler(onCellChange);

        // Get the delete buttons set up right
        onCellChange(m_dgPath, null);
        onCellChange(m_dgOther, null);
        

        return 1;

    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // CreatePathDataTable
    //
    // Creates the datatable for the Path table
    //-------------------------------------------------
    private DataTable CreatePathDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Path" Column
        DataColumn dcPath = new DataColumn();
        dcPath.ColumnName = "Path";
        dcPath.DataType = typeof(String);
        dt.Columns.Add(dcPath);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);


       
        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcPath = new DataGridTextBoxColumn();

        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle();

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;


        // Set up the column info for the Path column
        dgtbcPath.MappingName = "Path";
        dgtbcPath.HeaderText = CResourceStore.GetString("MessageQueuePermission:Path");
        dgtbcPath.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:PathColumnDataWidth"));
        dgtbcPath.NullText = "";
        dgtbcPath.TextBox.TextChanged +=new EventHandler(onChange);

        dgts.GridColumnStyles.Add(dgtbcPath);

        // Set up the column info for the Access column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("MessageQueuePermission:Access");
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:AccessColumnDataWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("None")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Browse")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Peek")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Send")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Receive")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Administer"))
                                             };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);

        dgts.GridColumnStyles.Add(dgccAccess);

        return dt;
    }// CreateDataTable

    //-------------------------------------------------
    // CreateOtherDataTable
    //
    // Creates the datatable for the Other table
    //-------------------------------------------------
    private DataTable CreateOtherDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Other");

        // Create the "Machine Name" Column
        DataColumn dcMachine = new DataColumn();
        dcMachine.ColumnName = "Machine";
        dcMachine.DataType = typeof(String);
        dt.Columns.Add(dcMachine);

        // Create the "Category" Column
        DataColumn dcCategory = new DataColumn();
        dcCategory.ColumnName = "Category";
        dcCategory.DataType = typeof(String);
        dt.Columns.Add(dcCategory);

        // Create the "Label" Column
        DataColumn dcLabel = new DataColumn();
        dcLabel.ColumnName = "Label";
        dcLabel.DataType = typeof(String);
        dt.Columns.Add(dcLabel);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);


       
        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcMachine = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcCategory = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcLabel = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle(); 

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Other";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Machine column
        dgtbcMachine.MappingName = "Machine";
        dgtbcMachine.HeaderText = CResourceStore.GetString("MessageQueuePermission:MachineName");
        dgtbcMachine.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:MachineColumnWidth"));
        dgtbcMachine.NullText = "";
        dgtbcMachine.TextBox.TextChanged +=new EventHandler(onChange);

        dgts.GridColumnStyles.Add(dgtbcMachine);

        // Set up the column info for the Category column
        dgtbcCategory.MappingName = "Category";
        dgtbcCategory.HeaderText = CResourceStore.GetString("MessageQueuePermission:Category");
        dgtbcCategory.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:CategoryColumnWidth"));
        dgtbcCategory.NullText = "";
        dgtbcCategory.TextBox.TextChanged +=new EventHandler(onChange);
        
        dgts.GridColumnStyles.Add(dgtbcCategory);
        
        // Set up the column info for the Label column
        dgtbcLabel.MappingName = "Label";
        dgtbcLabel.HeaderText = CResourceStore.GetString("MessageQueuePermission:Label");
        dgtbcLabel.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:LabelColumnWidth"));
        dgtbcLabel.NullText = "";
        dgtbcLabel.TextBox.TextChanged +=new EventHandler(onChange);

        dgts.GridColumnStyles.Add(dgtbcLabel);

        // Set up the column info for the Access column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("MessageQueuePermission:Access");
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("MessageQueuePermission:AccessColumnWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("None")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Browse")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Peek")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Send")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Receive")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("MessageQueuePermission:Administer"))
                                             };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);

        dgts.GridColumnStyles.Add(dgccAccess);

        return dt;
    }// CreateOtherDataTable

    //-------------------------------------------------
    // PutValuesinPage
    //
    // Initializes the controls with the provided permission
    //-------------------------------------------------
    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("MessageQueuePermission:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("MessageQueuePermission:GrantFollowing");

        MessageQueuePermission perm = (MessageQueuePermission)m_perm;

        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.PermissionEntries.GetEnumerator();
            while (enumer.MoveNext())
            {
                MessageQueuePermissionEntry mqpp = (MessageQueuePermissionEntry)enumer.Current;
                
                String sAccess = CResourceStore.GetString("None");

                if ((mqpp.PermissionAccess&MessageQueuePermissionAccess.Administer) == MessageQueuePermissionAccess.Administer)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Administer");
                else if ((mqpp.PermissionAccess&MessageQueuePermissionAccess.Receive) == MessageQueuePermissionAccess.Receive)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Receive");
                else if ((mqpp.PermissionAccess&MessageQueuePermissionAccess.Peek) == MessageQueuePermissionAccess.Peek)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Peek");
                else if ((mqpp.PermissionAccess&MessageQueuePermissionAccess.Send) == MessageQueuePermissionAccess.Send)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Send");
                else if ((mqpp.PermissionAccess&MessageQueuePermissionAccess.Browse) == MessageQueuePermissionAccess.Browse)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Browse");


                DataRow newRow;
                // Figure out what type of row we're adding
                if (mqpp.Path!=null && mqpp.Path.Length > 0)
                {
                    newRow = m_dtPath.NewRow();
                    newRow["Path"]=mqpp.Path;
                    newRow["Access"] = new DataGridComboBoxEntry(sAccess);
                    m_dtPath.Rows.Add(newRow);
                }
                else
                {
                    newRow = m_dtOther.NewRow();
                    newRow["Machine"]=mqpp.MachineName;
                    newRow["Category"]=(mqpp.Category!=null)?mqpp.Category:"";
                    newRow["Label"]=(mqpp.Label!=null)?mqpp.Label:"";
                    newRow["Access"] = new DataGridComboBoxEntry(sAccess);
                    m_dtOther.Rows.Add(newRow);
                }
            }
        }

        // We want at least 1 rows so it looks pretty
        while(m_dtPath.Rows.Count < 1)
        {
           AddEmptyPathRow(m_dtPath);
        }

        // We want at least 1 rows so it looks pretty
        while(m_dtOther.Rows.Count < 1)
        {
           AddEmptyOtherRow(m_dtOther);
        }

        
    }// PutValuesinPage

    //-------------------------------------------------
    // AddEmptyPathRow
    //
    // Adds an empty row in the Path table
    //-------------------------------------------------
    private void AddEmptyPathRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Path"]="";
        newRow["Access"]=CResourceStore.GetString("None");
        dt.Rows.Add(newRow);
    }// AddEmptyPathRow

    //-------------------------------------------------
    // AddEmptyOtherRow
    //
    // Adds an empty row in the Other table
    //-------------------------------------------------
    private void AddEmptyOtherRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Machine"]="";
        newRow["Category"]="";
        newRow["Label"]="";
        newRow["Access"]=CResourceStore.GetString("None");
           
        dt.Rows.Add(newRow);
    }// AddEmptyOtherRow

    //-------------------------------------------------
    // ValidateData
    //
    // Makes sure all the data entered was correct
    //-------------------------------------------------
    internal override bool ValidateData()
    {
        return GetCurrentPermission() != null;
    }// ValidateData

    //-------------------------------------------------
    // GetCurrentPermission
    //
    // This builds a permission based on the values of
    // the controls
    //-------------------------------------------------
    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dgPath.CurrentCell = new DataGridCell(0,1);
        m_dgPath.CurrentCell = new DataGridCell(0,0);
    
        m_dgOther.CurrentCell = new DataGridCell(0,1);
        m_dgOther.CurrentCell = new DataGridCell(0,0);

        MessageQueuePermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new MessageQueuePermission(PermissionState.Unrestricted);
        else
        {
            perm = new MessageQueuePermission(PermissionState.None);
            for(int i=0; i<m_dtPath.Rows.Count; i++)
            {
                // Make sure we have a permission to add
                if (m_dgPath[i, 0] != DBNull.Value && ((String)m_dgPath[i, 0]).Length > 0)
                {
                    String sPath = (String)m_dgPath[i, 0];
                    String sAccess = (String)m_dgPath[i,1];
                    try
                    {
                        perm.PermissionEntries.Add(new MessageQueuePermissionEntry(GetAccess(sAccess), sPath));        
                    }
                    catch(Exception)
                    {
                        MessageBox(String.Format(CResourceStore.GetString("MessageQueuePermission:isNotAValidPath"), sPath),
                                CResourceStore.GetString("MessageQueuePermission:isNotAValidPathTitle"),
                                MB.ICONEXCLAMATION);
                                   
                        // Move to the cell that has the bad path
                        m_dgPath.CurrentCell = new DataGridCell(i,0);
                                
                        return null;
                    }
                }
            }

            for(int i=0; i<m_dtOther.Rows.Count; i++)
            {
                // Make sure we have a permission to add
                String sMachine=null;
                String sCategory=null;
                String sLabel=null;
                String sAccess=null;

                if (m_dgOther[i, 0] != DBNull.Value && ((String)m_dgOther[i, 0]).Length>0)
                    sMachine = (String)m_dgOther[i, 0];
                if (m_dgOther[i, 1] != DBNull.Value && ((String)m_dgOther[i, 1]).Length>0)
                    sCategory = (String)m_dgOther[i, 1];
                if (m_dgOther[i, 2] != DBNull.Value && ((String)m_dgOther[i, 2]).Length>0)
                    sLabel = (String)m_dgOther[i, 2];


                if (sMachine != null || sCategory != null || sLabel != null)
                {
                    sAccess = (String)m_dgOther[i,3];

                    perm.PermissionEntries.Add(new MessageQueuePermissionEntry(GetAccess(sAccess), sMachine, sLabel, sCategory));        
                }
            }
        }
        return perm;
    }// GetCurrentPermission

    //-------------------------------------------------
    // GetAccess
    //
    // Translates a string into a MessageQueuePermissionAccess enum 
    //-------------------------------------------------
    private MessageQueuePermissionAccess GetAccess(String sAccess)
    {
        MessageQueuePermissionAccess mqpa = MessageQueuePermissionAccess.None;

        if (sAccess.Equals(CResourceStore.GetString("MessageQueuePermission:Administer")))
            mqpa = MessageQueuePermissionAccess.Administer;
        if (sAccess.Equals(CResourceStore.GetString("MessageQueuePermission:Receive")))
            mqpa = MessageQueuePermissionAccess.Receive;
        if (sAccess.Equals(CResourceStore.GetString("MessageQueuePermission:Peek")))
            mqpa = MessageQueuePermissionAccess.Peek;
        if (sAccess.Equals(CResourceStore.GetString("MessageQueuePermission:Send")))
            mqpa = MessageQueuePermissionAccess.Send;
        if (sAccess.Equals(CResourceStore.GetString("MessageQueuePermission:Browse")))
            mqpa = MessageQueuePermissionAccess.Browse;

        return mqpa;
    }// GetAccess


    private void onChange(Object o, EventArgs e)
    {
        if (o == m_dgPath)
        {
            int iSelRow = m_dgPath.CurrentCell.RowNumber;

            if (m_dgPath[iSelRow, 1] == DBNull.Value)
                m_dgPath[iSelRow, 1] = CResourceStore.GetString("None");

        }
        else
        {
            int iSelRow = m_dgOther.CurrentCell.RowNumber;

            if (m_dgOther[iSelRow, 3] == DBNull.Value)
                m_dgOther[iSelRow, 3] = CResourceStore.GetString("None");

        }
        
        ActivateApply();
      
    }// onChange
    
    void onDeleteEntireRow(Object o, EventArgs e)
    {
        DataGrid dg = ((Button)o == m_btnDeletePath)?m_dgPath:m_dgOther;
        DataTable dt = (dg == m_dgPath)?m_dtPath:m_dtOther;
    
        if (dg.CurrentRowIndex != -1)
        {

            if (dg.CurrentRowIndex >= dt.Rows.Count)
            {
                // Try moving to a different cell to 'submit' this data
                int nOldRow = dg.CurrentRowIndex;
                dg.CurrentCell = new DataGridCell(0, 0);
                // And now move back to the original row                
                dg.CurrentCell = new DataGridCell(nOldRow, 0);
            }
            // They're trying to delete a non-existant row
            if (dg.CurrentRowIndex >= dt.Rows.Count)
                return;
        
            int nRet = MessageBox(CResourceStore.GetString("ConfirmDeleteEntry"), 
                                  CResourceStore.GetString("ConfirmDeleteEntryTitle"),
                                  MB.ICONQUESTION|MB.YESNO);

            if (nRet == MB.IDYES)
            {
                int nRowToDelete = dg.CurrentRowIndex;
                int nRowToMoveTo = 0;
        
                dt.Rows.Remove(dt.Rows[nRowToDelete]);

                // See if we need to add more rows again....
        
                // We want at least 1 rows so it looks pretty
                while(dt.Rows.Count < 1)
                {
                    if (dt == m_dtPath)
                        AddEmptyPathRow(dt);
                    else
                        AddEmptyOtherRow(dt);
                }
                
                if (nRowToDelete >= dt.Rows.Count)
                    nRowToMoveTo = nRowToDelete-1;
                else
                    nRowToMoveTo = nRowToDelete;

                // End up with the cursor on the point right after the delete item    
                dg.CurrentCell = new DataGridCell(nRowToMoveTo,0);
                // Have the delete button figure out if it should be enabled again
                onCellChange(dg, null);

                ActivateApply();
            }
        }
    }// onDeleteEntireRow

    void onCellChange(Object o, EventArgs e)
    {
        DataGrid dg = (o == m_dgPath)?m_dgPath:m_dgOther;
        DataTable dt = (dg == m_dgPath)?m_dtPath:m_dtOther;
    
        bool fEnable = false;
        
        if (dg.CurrentRowIndex != -1)
        {
            // See if we're on a valid row
            if (dg.CurrentRowIndex < dt.Rows.Count)
            {
                if (isThereValidColumns(dg, dg.CurrentRowIndex))
                    fEnable = true;
            }
        }

        Button b = (dg == m_dgPath)?m_btnDeletePath:m_btnDeleteOther;
        b.Enabled = fEnable;
    }// onCellChange

    protected void onKeyPress(Object o, KeyPressEventArgs e)
    {
        ActivateApply();
    }// onKeyPress

    // Constants used to figure out if columns are valid
    
    private const int YES = 0;
    private const int NO = 1;
    private const int MAYBE = 2;


    private bool isValidRow(DataGrid dg, int nRowNum)
    {
        // Figure out how many rows we have
        int nNumColumns = dg.TableStyles[0].GridColumnStyles.Count;
        int nColumn = 0;
        bool fValid = true;
        // If any of these columns are invalid, return false
        while(fValid && nColumn < nNumColumns)
            fValid = isValidColumn(dg, nRowNum, nColumn++)!=NO;
        
        return fValid;
    }// isValidRow
    
    private int isValidColumn(DataGrid dg, int nRowNum, int nColumnNum)
    {
        // We'll only validate DataGridTextBoxColumns
        if (dg.TableStyles[0].GridColumnStyles[nColumnNum] is DataGridTextBoxColumn)
        {
            try
            {
                if ((dg[nRowNum, nColumnNum] is String) && ((String)dg[nRowNum, nColumnNum]).Length > 0)
                    return YES;
            }
            catch(Exception)
            {}
            return NO;            
         }
        else // all other types are ok...
            return MAYBE;            
    }// isValidColumn

    private bool isThereValidColumns(DataGrid dg, int nRowNum)
    {
        // Figure out how many rows we have
        int nNumColumns = dg.TableStyles[0].GridColumnStyles.Count;
        int nColumn = 0;
        bool fValid = false;
        // If any of these columns are valid, return true
        while(!fValid && nColumn < nNumColumns)
            fValid = isValidColumn(dg, nRowNum, nColumn++)==YES;
        
        return fValid;
    }// isThereValidColumns



    
}// class CMessageQueuePermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\litexmlparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Text;
using System.Security;
using System.Runtime.InteropServices;


internal class SecurityXMLStuff
{
    internal static SecurityElement GetSecurityElementFromXMLFile(String sXMLFilename)
    {
        FileStream f;

        try
        {
            f = new FileStream(sXMLFilename, FileMode.Open, FileAccess.Read);
        }
        catch (Exception)
        {
            return null;
        }

        // Do the actual decode.
        
        Encoding[] encodings = new Encoding[] { Encoding.UTF8, Encoding.ASCII, Encoding.Unicode };

        bool success = false;
        Exception exception = null;
        Parser parser = null;

        for (int i = 0; !success && i < encodings.Length; ++i)
        {
            try
            {
                f.Position = 0;

                StreamReader reader = new StreamReader( f, encodings[i], true );
                parser = new Parser( reader );
                success = true;
            }
            catch (Exception e1)
            {
                if (exception == null)
                    exception = e1;
            }
        }

        f.Close();

        if (!success)
        {
            return null;
        }

        return parser.GetTopElement();
    }// GetSecurityElementFromXMLFile

}// class SecurityXMLStuff 


    internal enum SecurityElementType
    {
        Regular = 0,
        Format = 1,
        Comment = 2
    }



sealed internal class Parser
    {
        private SecurityElement   _ecurr = null ;
        private Tokenizer _t     = null ;
    
        public SecurityElement GetTopElement()
        {
            return (SecurityElement)_ecurr.Children[0];
        }

        public Encoding GetEncoding()
        {
            return _t.GetEncoding();
        }
    
        private void ParseContents (SecurityElement e, bool restarted)
        {
            //
            // Iteratively collect stuff up until the next end-tag.
            // We've already seen the open-tag.
            //

            SecurityElementType lastType = SecurityElementType.Regular;

            ParserStack stack = new ParserStack();
            ParserStackFrame firstFrame = new ParserStackFrame();
            firstFrame.element = e;
            firstFrame.intag = false;
            stack.Push( firstFrame );
            
            bool needToBreak = false;
            bool needToPop = false;
            
            int i;

            do
            {
                ParserStackFrame locFrame = stack.Peek();
                
                for (i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
                {
                    switch (i)
                    {
                    case Tokenizer.cstr:
                        {
                            if (locFrame.intag)
                            {
                                if (locFrame.type == SecurityElementType.Comment)
                                {
                                    String appendString;

                                    if (locFrame.sawEquals)
                                    {
                                        appendString = "=\"" + _t.GetStringToken() + "\"";
                                        locFrame.sawEquals = false;
                                    }
                                    else
                                    {
                                        appendString = " " + _t.GetStringToken();
                                    }

                                    // Always set this directly since comments are not subjected
                                    // to the same restraints as other element types.  The strings
                                    // are all escaped so this shouldn't be a problem.

                                    locFrame.element.Tag = locFrame.element.Tag + appendString;
                                }
                                else
                                {
                                    // We're in a regular tag, so we've found an attribute/value pair.
                                
                                    if (locFrame.strValue == null)
                                    {
                                        // Found attribute name, save it for later.
                                    
                                        locFrame.strValue = _t.GetStringToken ();
                                    }
                                    else
                                    {
                                        // Found attribute text, add the pair to the current element.

                                        if (!locFrame.sawEquals)
                                            throw new XmlSyntaxException( _t.LineNo );

                                        locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken() );

                                        locFrame.strValue = null;
                                    }
                                }
                            }
                            else
                            {
                                // We're not in a tag, so we've found text between tags.
                                
                                if (locFrame.element.Text == null)
                                    locFrame.element.Text = "" ;
    
                                StringBuilder sb = new StringBuilder (locFrame.element.Text) ;
    
                                //
                                // Separate tokens with single spaces, collapsing whitespace
                                //
                                if (!locFrame.element.Text.Equals (""))
                                    sb.Append (" ") ;
                            
                                sb.Append (_t.GetStringToken ()) ;
                                locFrame.element.Text = sb.ToString ();
                            }
                        }
                        break ;
        
                    case Tokenizer.bra:
                        locFrame.intag = true;
                        i = _t.NextTokenType () ;
    
                        if (i == Tokenizer.slash)
                        {
                            while (true)
                            {
                                // spin; don't care what's in here
                                i = _t.NextTokenType();
                                if (i == Tokenizer.cstr)
                                    continue;
                                else if (i == -1)
                                    throw new Exception ("");
                                else
                                    break;
                            }
        
                            if (i != Tokenizer.ket)
                            {
                                    throw new Exception ("");
                            }
         
                            locFrame.intag = false;
         
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;

                        }
                        else if (i == Tokenizer.cstr)
                        {
                            // Found a child
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement ( _t.GetStringToken() );
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.bang)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            ParserStackFrame newFrame = new ParserStackFrame();
        
                            newFrame.status = 1;

                            do
                            {
                                i = _t.NextTokenType();

                                if (newFrame.status < 3)
                                {
                                    if (i != Tokenizer.dash)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        newFrame.status++;
                                }
                                else
                                {
                                    if (i != Tokenizer.cstr)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        break;
                                }
                            }
                            while (true);                                    

                            
                            newFrame.element = new SecurityElement ( _t.GetStringToken());

                            newFrame.type = SecurityElementType.Comment;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.quest)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            i = _t.NextTokenType();

                            if (i != Tokenizer.cstr)
                                throw new XmlSyntaxException( _t.LineNo );
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement (_t.GetStringToken());

                            newFrame.type = SecurityElementType.Format;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            newFrame.status = 1;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else   
                        {
                            throw new Exception ("");
                        }
                        break ;
        
                    case Tokenizer.equals:
                        locFrame.sawEquals = true;
                        break;
                        
                    case Tokenizer.ket:
                        if (locFrame.intag)
                        {
                            locFrame.intag = false;
                            continue;
                        }
                        else
                        {
                            throw new Exception ("");
                        }
                        // not reachable
                        
                    case Tokenizer.slash:
                        locFrame.element.Text = null;
                        
                        i = _t.NextTokenType ();
                        
                        if (i == Tokenizer.ket)
                        {
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new Exception ("");
                        }
                        break;
                        
                    case Tokenizer.quest:
                        if (locFrame.intag && locFrame.type == SecurityElementType.Format && locFrame.status == 1)
                        {
                            i = _t.NextTokenType ();

                            if (i == Tokenizer.ket)
                            {
                                lastType = stack.Peek().type;
                                stack.Pop();

                                needToBreak = true;
                            }
                            else
                            {
                                throw new Exception ("");
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    case Tokenizer.dash:
                        if (locFrame.intag && (locFrame.status > 0 && locFrame.status < 5) && locFrame.type == SecurityElementType.Comment)
                        {
                            locFrame.status++;

                            if (locFrame.status == 5)
                            {
                                i = _t.NextTokenType ();

                                if (i == Tokenizer.ket)
                                {
                                    lastType = stack.Peek().type;
                                    stack.Pop();

                                    needToBreak = true;
                                }
                                else
                                {
                                    throw new Exception ("");
                                }
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    default:
                        throw new XmlSyntaxException (_t.LineNo) ;
                    }
                    
                    if (needToBreak)
                    {
                        needToBreak = false;
                        needToPop = false;
                        break;
                    }
                    else
                    {
                        needToPop = true;
                    }
                }
                if (needToPop)
                {
                    lastType = stack.Peek().type;
                    stack.Pop();
                }
                else if (i == -1 && stack.GetCount() != 1)
                {
                    // This means that we still have items on the stack, but the end of our
                    // stream has been reached.

                    throw new Exception("");
                }
            }
            while (stack.GetCount() > 1);

            SecurityElement topElement = this.GetTopElement();

            if (lastType == SecurityElementType.Format)
            {
                if (restarted)
                    throw new XmlSyntaxException( _t.LineNo );

                String format = topElement.Attribute( "encoding" );

                if (format != null)
                {
                    _t.ChangeFormat( System.Text.Encoding.GetEncoding( format ) );
                }

                _ecurr = new SecurityElement( "junk" );
                ParseContents( _ecurr, true );
            }

            
        }
    
        private Parser(Tokenizer t)
        {
            _t = t;
            _ecurr       = new SecurityElement( "junk" );

            ParseContents (_ecurr, false) ;
        }
        
        public Parser (String input)
            : this (new Tokenizer (input))
        {
        }
    
        public Parser (BinaryReader input)
            : this (new Tokenizer (input))
        {
        }
       
        public Parser( byte[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
        public Parser( StreamReader input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( Stream input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( char[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
    }                                              
    
    
    internal class ParserStackFrame
    {
        internal SecurityElement element = null;
        internal bool intag = true;
        internal String strValue = null;
        internal int status = 0;
        internal bool sawEquals = false;
        internal SecurityElementType type = SecurityElementType.Regular;
    }
    
    
    internal class ParserStack
    {
        private ArrayList m_array;
        
        public ParserStack()
        {
            m_array = new ArrayList();
        }
        
        public void Push( ParserStackFrame element )
        {
            m_array.Add( element );
        }
        
        public ParserStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
                m_array.RemoveAt( count-1 );
                return temp;
            }
            else
            {
                throw new Exception("");
            }
        }
        
        public ParserStackFrame Peek()
        {
            if (!IsEmpty())
            {
                return (ParserStackFrame) m_array[m_array.Count-1];
            }
            else
            {
                throw new Exception("");
            }
        }
        
        public bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        public int GetCount()
        {
            return m_array.Count;
        }
        
    }


    internal class Tokenizer 
    {
        private ITokenReader         _input;
        private bool             _fintag;
        private StringBuilder       _cstr;
        private char[]              _sbarray;
        private int                 _sbindex;
        private const int          _sbmaxsize = 128;
    
        // There are five externally knowable token types: bras, kets,
        // slashes, cstrs, and equals.  
    
        internal const int bra     = 0;
        internal const int ket     = 1;
        internal const int slash   = 2;
        internal const int cstr    = 3;
        internal const int equals  = 4;
        internal const int quest   = 5;
        internal const int bang    = 6;
        internal const int dash    = 7;

        internal const int intOpenBracket = (int) '<';
        internal const int intCloseBracket = (int) '>';
        internal const int intSlash = (int) '/';
        internal const int intEquals = (int) '=';
        internal const int intQuote = (int) '\"';
        internal const int intQuest = (int) '?';
        internal const int intBang = (int) '!';
        internal const int intDash = (int) '-';
    
        public int  LineNo;
    
        //================================================================
        // Constructor uses given ICharInputStream
        //

        internal Tokenizer (String input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StringTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        

        internal Tokenizer (BinaryReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new TokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (byte[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new ByteTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (char[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new CharTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        
        
        internal Tokenizer (StreamReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }
    
        internal Tokenizer (Stream input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(new StreamReader( input )) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }


        internal void ChangeFormat( System.Text.Encoding encoding )
        {
            if (encoding == null)
            {
                return;
            }

            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return;
            }

            Stream stream = reader._in.BaseStream;

            String fakeReadString = new String( new char[reader.NumCharEncountered] );

            stream.Position = reader._in.CurrentEncoding.GetByteCount( fakeReadString );

            _input = new StreamTokenReader( new StreamReader( stream, encoding ) );
        }

        internal System.Text.Encoding GetEncoding()
        {
            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return null;
            }
            
            return reader._in.CurrentEncoding;
        }

   
        //================================================================
        // 
        //
        private bool FIsWhite (int j)
        {
            if ((j == 10) && (_input.Peek() != -1))
                LineNo ++ ;
    
            bool retval =  (j == 32) || (j ==  9)  // Space and tab
                        || (j == 13) || (j == 10); // CR and LF
         
            return retval;
                
        }
    
        //================================================================
        // Parser needs to know types of tokens
        //
        private void SBArrayAppend(char c) {
            // this is the common case
            if (_sbindex != _sbmaxsize) {
                _sbarray[_sbindex] = c;
                _sbindex++;
                return;
            } 
            // OK, first check if we have to init the StringBuilder
            if (_cstr == null) {
                _cstr = new StringBuilder();
            }
            // OK, copy from _sbarray to _cstr
            _cstr.Append(_sbarray,0,_sbmaxsize);
            // reset _sbarray pointer
            _sbarray[0] = c;
            _sbindex = 1;
            return;
        }
        
        internal int NextTokenType()
        {
            _cstr = null;
            _sbindex = 0;
            int i;
            
            i = _input.Read();
        BEGINNING_AFTER_READ:            
        
            switch (i)
            {
            case -1:
                return -1;
                
            case intOpenBracket:
                _fintag = true;
                return bra;
                
            case intCloseBracket:
                _fintag = false;
                return ket;
                
            case intEquals:
                return equals;
                
            case intSlash:
                if (_fintag) return slash;
                goto default;

            case intQuest:
                if (_fintag) return quest;
                goto default;

            case intBang:
                if (_fintag) return bang;
                goto default;

            case intDash:
                if (_fintag) return dash;
                goto default;
                
            default:
                // We either have a string or whitespace.
                if (FIsWhite( i ))
                {
                    do
                    {
                        i = _input.Read();
                    } while (FIsWhite( i ));
                    
                    goto BEGINNING_AFTER_READ;
                }
                else
                {
                    // The first and last characters in a string can be quotes.
                    
                    bool inQuotedString = false;

                    if (i == intQuote)
                    {
                        inQuotedString = true;
                        i = _input.Read();

                        if (i == intQuote)
                            return cstr;
                    }

                    do
                    {
                        SBArrayAppend( (char)i );
                        i = _input.Peek();
                        if (!inQuotedString && (FIsWhite( i ) || i == intOpenBracket || (_fintag && (i == intCloseBracket || i == intEquals || i == intSlash))))
                            break;
                        _input.Read();
                        if (i == intQuote && inQuotedString)
                            break;
                        if (i == -1)
                            return -1;
                    } while (true);
                    
                    return cstr;
                }
            }
            
        }
        

        //================================================================
        //
        //
        
        internal String GetStringToken ()
        {
            // OK, easy case first, _cstr == null
            if (_cstr == null) {
                // degenerate case
                if (_sbindex == 0) return("");
                return(new String(_sbarray,0,_sbindex));
            }
            // OK, now we know we have a StringBuilder already, so just append chars
            _cstr.Append(_sbarray,0,_sbindex);
            return(_cstr.ToString());
        }
    
        internal interface ITokenReader
        {
            int Peek();
            int Read();
        }
    
        internal class ByteTokenReader : ITokenReader {
            private byte[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal ByteTokenReader( byte[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }

        internal class StringTokenReader : ITokenReader {
            private String _input;
            private int _currentIndex;
            private int _inputSize;
            
            internal StringTokenReader( String input )
            {
                _input = input;
                _currentIndex = 0;
                _inputSize = input.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex++];
                }
            }
        } 
        
        internal class CharTokenReader : ITokenReader {
            private char[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal CharTokenReader( char[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }        
                
        internal class TokenReader : ITokenReader {
    
            private BinaryReader _in;
    
            internal TokenReader(BinaryReader input) {
                _in = input;
            }
    
            public virtual int Peek() {
                return _in.PeekChar();
            }
    
            public virtual int Read() {
                return _in.Read();
            }
        }
        
        internal class StreamTokenReader : ITokenReader {
            
            internal StreamReader _in;
            internal int _numCharRead;
            
            internal StreamTokenReader(StreamReader input) {
                _in = input;
                _numCharRead = 0;
            }
            
            public virtual int Peek() {
                return _in.Peek();
            }
            
            public virtual int Read() {
                int value = _in.Read();
                if (value != -1)
                    _numCharRead++;
                return value;
            }

            internal int NumCharEncountered
            {
                get
                {
                    return _numCharRead;
                }
            }
        }
    }
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\mmcenumsandstructs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// mmcEnumsAndStructs.cs
//
// Contains enumerations, constants,  and structure definitions used
// by an MMC snapin
//
// NOTE: This is not an all-encompasing list of every enumeration
// and structure defination available to a snapin... just those used
// by this snapin.
//-------------------------------------------------------------

using System;
using System.Runtime.InteropServices;

namespace Microsoft.CLRAdmin
{
//-------------------------------------------\\
//          Enums and Constants              \\
//-------------------------------------------\\

internal class MSIDBOPEN
{
    internal const int READONLY  = 0;  // database open read-only, no 
    internal const int TRANSACT  = 1;  // database read/write in transaction 
    internal const int DIRECT    = 2;  // database direct read/write without 
    internal const int CREATE    = 3;  // create new database, direct mode read/write
}// class MSIDBOPEN


internal class LVIS
{
    internal const int FOCUSED                = 0x0001;
    internal const int SELECTED               = 0x0002;
    internal const int CUT                    = 0x0004;
    internal const int DROPHILITED            = 0x0008;
}// class LVIS

internal class MMC
{
    internal const int MULTI_SELECT_COOKIE    = -2;

    internal const int SINGLESEL	            = 0x1;
	internal const int SHOWSELALWAYS	        = 0x2;
	internal const int NOSORTHEADER	        = 0x4;

}// class MMC

internal class DOBJ
{
    internal const int   NULL              = 0;
    internal const int   CUSTOMOCX         = -1;
    internal const int   CUSTOMWEB         = -2;
}// DOBJ

internal class MMCLV
{
    internal const int AUTO                   = -1;
}// class MMCLV

internal class LVCFMT
{
    internal const int LEFT                   = 0x0000;
    internal const int RIGHT                  = 0x0001;
    internal const int CENTER                 = 0x0002;
    internal const int JUSTIFYMASK            = 0x0003;
    internal const int IMAGE                  = 0x0800;
    internal const int BITMAP_ON_RIGHT        = 0x1000;
    internal const int COL_HAS_IMAGES         = 0x8000;
}// class LVCFMT

internal class TBSTATE
{
    internal const byte CHECKED               = 0x01;
    internal const byte PRESSED               = 0x02;
    internal const byte ENABLED               = 0x04;
    internal const byte HIDDEN                = 0x08;
    internal const byte INDETERMINATE         = 0x10;
    internal const byte WRAP                  = 0x20;
    internal const byte ELLIPSES              = 0x40;
    internal const byte MARKED                = 0x80;
}// class TBSTATE

internal class TBSTYLE
{
    internal const byte BUTTON                = 0x0000;
    internal const byte SEP                   = 0x0001;
    internal const byte CHECK                 = 0x0002;
    internal const byte GROUP                 = 0x0004;
    internal const byte CHECKGROUP            = (GROUP | CHECK);
    internal const byte DROPDOWN              = 0x0008;
    internal const byte AUTOSIZE              = 0x0010;
    internal const byte NOPREFIX              = 0x0020;
}// class TBSTYLE

internal class EN
{
    internal const uint SETFOCUS           = 0x0100;
    internal const uint KILLFOCUS          = 0x0200;
    internal const uint CHANGE             = 0x0300;
    internal const uint UPDATE             = 0x0400;
    internal const uint ERRSPACE           = 0x0500;
    internal const uint MAXTEXT            = 0x0501;
    internal const uint HSCROLL            = 0x0601;
    internal const uint VSCROLL            = 0x0602;
}// EN

internal class PSM
{

    internal const uint SETCURSEL          = (0x0400 + 101);
    internal const uint REMOVEPAGE         = (0x0400 + 102);
    internal const uint ADDPAGE            = (0x0400 + 103);
    internal const uint CHANGED            = (0x0400 + 104);
    internal const uint SETWIZBUTTONS      = (0x0400 + 112);
}// PSM

internal class PSWIZB
{
    internal const uint BACK               = 1;
    internal const uint NEXT               = 2;
    internal const uint FINISH             = 4;
    internal const uint DISABLEDFINISH     = 8;
}// PSWIZB

internal class PSN
{
    internal const uint FIRST              = unchecked((0U-200U));
    internal const uint LAST               = unchecked((0U-299U));
    internal const uint SETACTIVE          = unchecked((FIRST-0));
    internal const uint KILLACTIVE         = unchecked((FIRST-1));
    internal const uint APPLY              = unchecked((FIRST-2));
    internal const uint RESET              = unchecked((FIRST-3));
    internal const uint HELP               = unchecked((FIRST-5));
    internal const uint WIZBACK            = unchecked((FIRST-6));
    internal const uint WIZNEXT            = unchecked((FIRST-7));
    internal const uint WIZFINISH          = unchecked((FIRST-8));
    internal const uint QUERYCANCEL        = unchecked((FIRST-9));
    internal const uint GETOBJECT          = unchecked((FIRST-10));
}// PSN

// Constants for Window Messages
internal class WM
{
    internal const uint INITDIALOG            = 0x0110;
    internal const uint COMMAND               = 0x0111;
    internal const uint DESTROY               = 0x0002;
    internal const uint NOTIFY                = 0x004E;
    internal const uint PAINT                 = 0x000F;
    internal const uint SETFOCUS              = 0x0007;
}// WM

// Constants required for the Property Sheet Page Callback function
internal class PSPCB
{
    internal const uint ADDREF                = 0;
    internal const uint RELEASE               = 1;
    internal const uint CREATE                = 2;
}// PSPCB
    
internal class PSP
{
    internal const uint DEFAULT               = 0x00000000;
    internal const uint DLGINDIRECT           = 0x00000001;
    internal const uint USEHICON              = 0x00000002;
    internal const uint USEICONID             = 0x00000004;
    internal const uint USETITLE              = 0x00000008;
    internal const uint RTLREADING            = 0x00000010;

    internal const uint HASHELP               = 0x00000020;
    internal const uint USEREFPARENT          = 0x00000040;
    internal const uint USECALLBACK           = 0x00000080;
    internal const uint PREMATURE             = 0x00000400;

    internal const uint HIDEHEADER            = 0x00000800;
    internal const uint USEHEADERTITLE        = 0x00001000;
    internal const uint USEHEADERSUBTITLE     = 0x00002000;
}// class PSP

public class MMC_PSO
{
    public const int NOAPPLYNOW     = 0x1;
    public const int HASHELP        = 0x2;
    public const int NEWWIZARDTYPE  = 0x4;
    public const int NO_PROPTITLE   = 0x8;
}// class MMC_PSO

internal class HRESULT
{
    internal const int S_OK                  = 0;
    internal const int S_FALSE               = 1;
    internal const int E_FAIL                = unchecked((int)0x80004005);
    internal const int E_NOTIMPL             = unchecked((int)0x80004001);
    internal const int E_ACCESSDENIED        = unchecked((int)0x80070005);
}// HRESULT

internal class IMAGE
{
    internal const int BITMAP                = 0;
    internal const int CURSOR                = 1;
    internal const int ICON                  = 2;
}// class IMAGE_TYPES        

internal class CCT
{
    internal const uint SCOPE            = 0x8000; // Data object for scope pane context 
    internal const uint RESULT           = 0x8001; // Data object for result pane context 
    internal const uint SNAPIN_MANAGER   = 0x8002; // Data object for Snap-in Manager context 
    internal const uint UNINITIALIZED    = 0xFFFF;  // Data object has an invalid type 
}// class CCT

public class MMC_BUTTON_STATE
{
    internal const uint ENABLED	            = 0x1;
	internal const uint CHECKED	            = 0x2;
	internal const uint HIDDEN	            = 0x4;
	internal const uint INDETERMINATE	        = 0x8;
	internal const uint BUTTONPRESSED	        = 0x10;
}// class MMC_BUTTON_STATE

internal class MMC_VERB                               
{                                                            
    internal const uint NONE            = 0x0000;                       
    internal const uint OPEN            = 0x8000;                       
    internal const uint COPY            = 0x8001;                       
    internal const uint PASTE           = 0x8002;                       
    internal const uint DELETE          = 0x8003;                       
    internal const uint PROPERTIES      = 0x8004;                       
    internal const uint RENAME          = 0x8005;                       
    internal const uint REFRESH         = 0x8006;                       
    internal const uint PRINT           = 0x8007;                       
    internal const uint CUT             = 0x8008;
                                                             
    internal const uint MAX             = 0x8009;                                            
    internal const uint FIRST           = OPEN;                
    internal const uint LAST            = MAX - 1;             
}// class MMC_VERB                            

public enum MMC_CONTROL_TYPE
{
    TOOLBAR	                = 0,
	MENUBUTTON	            = TOOLBAR + 1,
	COMBOBOXBAR	            = MENUBUTTON + 1
}// enum MMC_CONTROL_TYPE

internal class CCM
{	
    internal const uint INSERTIONALLOWED_TOP	= 1;
    internal const uint INSERTIONALLOWED_NEW	= 2;
    internal const uint INSERTIONALLOWED_TASK	= 4;
    internal const uint INSERTIONALLOWED_VIEW	= 8;

    internal const uint INSERTIONPOINTID_PRIMARY_TOP	= 0xa0000000;
	internal const uint INSERTIONPOINTID_PRIMARY_NEW	= 0xa0000001;
	internal const uint INSERTIONPOINTID_PRIMARY_TASK	= 0xa0000002;
	internal const uint INSERTIONPOINTID_PRIMARY_VIEW	= 0xa0000003;
	internal const uint INSERTIONPOINTID_3RDPARTY_NEW	= 0x90000001;
	internal const uint INSERTIONPOINTID_3RDPARTY_TASK = 0x90000002;
	internal const uint INSERTIONPOINTID_ROOT_MENU 	= 0x80000000;
}// class CCM

internal class MF
{
    internal const int SEPARATOR         	= 0x00000800;
    internal const int MENUBARBREAK       = 0x00000020;

    internal const int MENUBREAK          = 0x00000040;

}// class MF


public class MMCN
{
    public const uint ACTIVATE           = 0x8001;                        
    public const uint ADD_IMAGES         = 0x8002;                        
    public const uint BTN_CLICK          = 0x8003;                        
    public const uint CLICK              = 0x8004;   // NOT USED          
    public const uint COLUMN_CLICK       = 0x8005;                        
    public const uint CONTEXTMENU        = 0x8006;   // NOT USED          
    public const uint CUTORMOVE          = 0x8007;                       
    public const uint DBLCLICK           = 0x8008;                       
    public const uint DELETE             = 0x8009;                        
    public const uint DESELECT_ALL       = 0x800A;                        
    public const uint EXPAND             = 0x800B;                        
    public const uint HELP               = 0x800C;   // NOT USED          
    public const uint MENU_BTNCLICK      = 0x800D;                        
    public const uint MINIMIZED          = 0x800E;                        
    public const uint PASTE              = 0x800F;                        
    public const uint PROPERTY_CHANGE    = 0x8010;                        
    public const uint QUERY_PASTE        = 0x8011;                        
    public const uint REFRESH            = 0x8012;                        
    public const uint REMOVE_CHILDREN    = 0x8013;                        
    public const uint RENAME             = 0x8014;                        
    public const uint SELECT             = 0x8015;                        
    public const uint SHOW               = 0x8016;                        
    public const uint VIEW_CHANGE        = 0x8017;                        
    public const uint SNAPINHELP         = 0x8018;                        
    public const uint CONTEXTHELP        = 0x8019;                        
    public const uint INITOCX            = 0x801A;                        
    public const uint FILTER_CHANGE      = 0x801B;                        
    public const uint FILTERBTN_CLICK    = 0x801C;                        
    public const uint RESTORE_VIEW       = 0x801D;                        
    public const uint PRINT              = 0x801E;                        
    public const uint PRELOAD            = 0x801F;                        
    public const uint LISTPAD            = 0x8020;                        
    public const uint EXPANDSYNC         = 0x8021;                        
    public const uint COLUMNS_CHANGED    = 0x8022;
}// class MMCN

internal class SDI
{
    internal const uint STR                = 0x2;
    internal const uint IMAGE              = 0x4;
    internal const uint OPENIMAGE	         = 0x8;
    internal const uint STATE	             = 0x10;
    internal const uint PARAM              = 0x20;
    internal const uint CHILDREN	         = 0x40;
    internal const uint PARENT	         = 0;
    internal const uint PREVIOUS	         = 0x10000000;
    internal const uint NEXT	             = 0x20000000;
    internal const uint FIRST	             = 0x8000000;
}// class SDI

internal class RDI
{
    internal const uint STR                = 0x2;
    internal const uint IMAGE	             = 0x4;
    internal const uint STATE	             = 0x8;
    internal const uint PARAM	             = 0x10;
    internal const uint INDEX	             = 0x20;
    internal const uint INDENT	         = 0x40;
}// class RDI

internal class MMC_TASK_DISPLAY_TYPE
{	internal const int DISPLAY_UNINITIALIZED	= 0;
	internal const int SYMBOL	                = DISPLAY_UNINITIALIZED + 1;
	internal const int VANILLA_GIF	        = SYMBOL + 1;
	internal const int CHOCOLATE_GIF	        = VANILLA_GIF + 1;
	internal const int BITMAP	                = CHOCOLATE_GIF + 1;
}// class MMC_TASK_DISPLAY_TYPE

internal class MMC_ACTION_TYPE
{
    internal const int UNINITIALIZED	= -1;
	internal const int ID	            = UNINITIALIZED + 1;
	internal const int LINK	        = ID + 1;
	internal const int SCRIPT	        = LINK + 1;
}// class MMC_ACTION_TYPE

internal class MMC_VIEW_OPTIONS
{

    internal const uint NONE	                        = 0;
    internal const uint NOLISTVIEWS                   = 0x1;
    internal const uint MULTISELECT                   = 0x2;
    internal const uint OWNERDATALIST                 = 0x4;
    internal const uint FILTERED                      = 0x8;
    internal const uint CREATENEW                     = 0x10;
    internal const uint USEFONTLINKING                = 0x20;
    internal const uint EXCLUDE_SCOPE_ITEMS_FROM_LIST = 0x40;
    internal const uint LEXICAL_SORT                  = 0x80;
}// class MMC_VIEW_OPTIONS

internal class MB
{
    internal const uint OK                 = 0;
    internal const uint OKCANCEL           = 1;
    internal const uint ABORTRETRYIGNORE   = 2;
    internal const uint YESNOCANCEL        = 3;
    internal const uint YESNO              = 4;
    internal const uint RETRYCANCEL        = 5;
    internal const uint ICONHAND           = 0x10;
    internal const uint ICONQUESTION       = 0x20;
    internal const uint ICONEXCLAMATION    = 0x30;
    internal const uint ICONASTERISK       = 0x40;
    internal const uint ICONINFORMATION    = 0x40;
    internal const uint USERICON           = 0x80;

    internal const uint IDOK               = 1;
    internal const uint IDCANCEL           = 2;
    internal const uint IDABORT            = 3;
    internal const uint IDRETRY            = 4;
    internal const uint IDIGNORE           = 5;
    internal const uint IDYES              = 6;
    internal const uint IDNO               = 7;
    internal const uint IDCLOSE            = 8;
    internal const uint IDHELP             = 9;

    internal const uint APPLMODAL          = 0x00000000;
    internal const uint SYSTEMMODAL        = 0x00001000;
    internal const uint TASKMODAL          = 0x00002000;
}// class MB

internal class CF
{
    internal const int TEXT             = 1;
    internal const int UNICODETEXT      = 13;
    internal const int HDROP            = 15;
}// class CF

internal class DVASPECT 
{ 
    internal const int CONTENT          = 1; 
    internal const int THUMBNAIL        = 2; 
    internal const int ICON             = 4; 
    internal const int DOCPRINT         = 8;
}// class DVASPECT 

internal class TYMED
{
    internal const int HGLOBAL	      = 1;
}// class TYMED

internal class SHGFI
{
    internal const uint ICON            = 0x000000100;
    internal const uint SMALLICON       = 0x000000001;
}// SHGFI

internal class PSNRET
{
    internal const uint NOERROR               = 0;
    internal const uint INVALID               = 1;
    internal const uint INVALID_NOCHANGEPAGE  = 2;
}// class PSNRET

internal class DS
{
    internal const uint SETFONT               = 0x40;
    internal const uint FIXEDSYS              = 0x0008;

}// class DS

internal class SWP
{
    internal const uint NOSIZE          = 0x0001;
    internal const uint NOMOVE          = 0x0002;
    internal const uint NOZORDER        = 0x0004;
    internal const uint NOREDRAW        = 0x0008;
    internal const uint NOACTIVATE      = 0x0010;
    internal const uint FRAMECHANGED    = 0x0020;  /* The frame changed: send WM_NCCALCSIZE */
    internal const uint SHOWWINDOW      = 0x0040;
    internal const uint HIDEWINDOW      = 0x0080;
    internal const uint NOCOPYBITS      = 0x0100;
    internal const uint NOOWNERZORDER   = 0x0200; /* Don't do owner Z ordering */
    internal const uint NOSENDCHANGING  = 0x0400;  /* Don't send WM_WINDOWPOSCHANGING */
}


//-------------------------------------------\\
//          Structure Definitions            \\
//-------------------------------------------\\

//----------------------------------------------------------------------
// Notes about structures in general
//
// Each structure has the property
// "[StructLayout(LayoutKind.Sequential)]"
//
// This tells C# to pack the structure in sequential memory so it
// can be sent to unmanaged code correctly.
//
// Also, each string is represented by an int. MMC takes care of
// deallocating all the strings we pass it, and it deallocates them
// using CoTaskMemFree, so we must allocate all the strings with
// CoTaskMemCreate. Marshal.StringToCoTaskMemXXX does this for us.
//----------------------------------------------------------------------


[StructLayout(LayoutKind.Sequential)]
internal struct MMC_TASK_DISPLAY_SYMBOL
{
    internal int szFontFamilyName;
    internal int szURLtoEOT;
    internal int szSymbolString;
}// struct MMC_TASK_DISPLAY_SYMBOL;

[StructLayout(LayoutKind.Sequential)]
struct MMC_TASK_DISPLAY_BITMAP
{
    internal int szMouseOverBitmap;
    internal int szMouseOffBitmap;
}// struct MMC_TASK_DISPLAY_BITMAP;
    

[StructLayout(LayoutKind.Sequential)]
public struct MMC_TASK_DISPLAY_OBJECT
{
    internal MMC_TASK_DISPLAY_TYPE eDisplayType;
    internal int uData;
    /*
        Previous field is a union of these two items
        MMC_TASK_DISPLAY_BITMAP uBitmap;
        MMC_TASK_DISPLAY_SYMBOL uSymbol;
    */

}// struct MMC_TASK_DISPLAY_OBJECT

[StructLayout(LayoutKind.Sequential)]
public struct MMC_TASK
{
    internal MMC_TASK_DISPLAY_OBJECT sDisplayObject;
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String szText;
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String szHelpString;
    internal MMC_ACTION_TYPE eActionType;
    internal int nCommandID;
    /* 
        Previous field is a union of these three items

        LONG_PTR nCommandID;
        LPOLESTR szActionURL;
        LPOLESTR szScript;
    */
}// struct MMC_TASK

[StructLayout(LayoutKind.Sequential)]
public struct MMC_LISTPAD_INFO
{
    internal IntPtr szTitle;
    internal IntPtr szButtonText;
    internal int nCommandID;
}// struct MMC_LISTPAD_INFO

[StructLayout(LayoutKind.Sequential)]
public struct MMCBUTTON
{
    internal int nBitmap;
    internal int idCommand;
    internal byte fsState;
    internal byte fsType;
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String lpButtonText;
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String lpTooltipText;
}// struct MMCBUTTON

[StructLayout(LayoutKind.Sequential)]
public struct CONTEXTMENUITEM
{
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String   strName;
    [MarshalAs(UnmanagedType.LPWStr)]
    internal String   strStatusBarText;
    internal int      lCommandID;
    internal uint     lInsertionPointID;
    internal int      fFlags;
    internal int      fSpecialFlags;
}// CONTEXTMENUITEM

[StructLayout(LayoutKind.Sequential)]
public struct SCOPEDATAITEM
{
    public uint     mask;
    public IntPtr   displayname;
    public int      nImage;
    public int      nOpenImage;
    public uint     nState;
    public int      cChildren;
    public int      lParam;
    public int      relativeID;
    public int      ID;
}// struct SCOPEDATAITEM

[StructLayout(LayoutKind.Sequential)]
public struct RESULTDATAITEM
{
    internal uint     mask;
    internal int      bScopeItem;
    internal int      itemID;
    internal int      nIndex;
    internal int      nCol;
    internal IntPtr   str;
    internal int      nImage;
    internal uint     nState;
    internal int      lParam;
    internal int      iIndent;
}// struct RESULTDATAITEM

[StructLayout(LayoutKind.Sequential)]
internal struct MMC_RESTORE_VIEW
{
    internal uint     dwSize;
    internal int      cookie;
    internal IntPtr   pViewType;
    internal int      lViewOptions;
}// struct MMC_RESTORE_VIEW


//--------------------------------------------------
// These structures are non-MMC specific
//--------------------------------------------------

[StructLayout(LayoutKind.Sequential)]
public struct CLSID
{
    internal uint x;
    internal ushort s1;
    internal ushort s2;
    internal byte[] c;
}// struct CLSID

[StructLayout(LayoutKind.Sequential)]
internal struct SMMCObjectTypes
{
    internal uint count;
    internal CLSID[] guid;
}// struct SMMCObjectTypes

[StructLayout(LayoutKind.Sequential)]
public struct FORMATETC
{
    internal int cfFormat;
    internal int ptd;
    internal uint dwAspect;
    internal int  lindex;
    internal uint tymed;
}// struct FORMATETC

public delegate bool DialogProc(IntPtr hwndDlg, uint uMsg, IntPtr wParam, IntPtr lParam); 
public delegate uint PropSheetPageProc(IntPtr hwnd, uint uMsg, IntPtr lParam);

[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct PROPSHEETPAGE
{  
    internal uint            dwSize; 
    internal uint            dwFlags; 
    internal IntPtr          hInstance; 

    // This is a union of the following Data items
    // String          pszTemplate; 
    internal IntPtr          pResource;

    

    // This is a union of the following Data items
    // IntPtr          hIcon; 
    // String          pszIcon; 

    internal IntPtr          hIcon; 

    internal String          pszTitle; 
    internal DialogProc      pfnDlgProc;
    internal IntPtr          lParam; 

    internal PropSheetPageProc pfnCallback;
    internal int             pcRefParent;
     
    internal String          pszHeaderTitle;
    internal String          pszHeaderSubTitle;
}// struct PROPSHEETPAGE

[StructLayout(LayoutKind.Sequential, Pack=2, CharSet=CharSet.Auto)]
internal struct DLGTEMPLATE
{
    internal uint style; 
    internal uint dwExtendedStyle; 
    internal ushort cdit; 
    internal short x; 
    internal short y; 
    internal short cx; 
    internal short cy;
    internal short wMenuResource;
    internal short wWindowClass;
    internal short wTitleArray;
}// struct DLGTEMPLATE

[StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
internal struct DIBSECTION 
{
    internal BITMAP              dsBm;
    internal BITMAPINFOHEADER    dsBmih;
    internal uint                dsBitfields0;
    internal uint                dsBitfields1;
    internal uint                dsBitfields2;
    internal IntPtr              dshSection;
    internal uint                dsOffset;
}// struct DIBSECTION

[StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
internal struct BITMAP
{
    internal int bmType;
    internal int bmWidth;
    internal int bmHeight;
    internal int bmWidthBytes;
    internal ushort bmPlanes;
    internal ushort bmBitsPixel;
    internal IntPtr bmBits;
}// struct BITMAP

[StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
internal struct BITMAPINFOHEADER
{
    internal int biSize;
    internal int biWidth;
    internal int biHeight;
    internal ushort biPlanes;
    internal ushort biBitCount;
    internal uint biCompression;
    internal uint biSizeImage;
    internal int biXPelsPerMeter;
    internal int biYPelsPerMeter;
    internal uint biClrUsed;
    internal uint biClrImportant;
}// struct BITMAPINFOHEADER

[StructLayout(LayoutKind.Sequential, Pack=1, CharSet=CharSet.Auto)]
internal struct BITMAPINFO 
{
    internal BITMAPINFOHEADER    bmiHeader;
    internal long                bmiColors0;
    internal long                bmiColors1;
    internal long                bmiColors2;
    internal long                bmiColors3;
}// struct BITMAPINFO



//--------------------------------------------------
// This structure is nowhere close to the generalized
// structure used throughout Windows, but it should
// suffice for MMC snapins
//--------------------------------------------------
[StructLayout(LayoutKind.Sequential)]
public struct STGMEDIUM
{
  internal uint tymed;
  internal IntPtr hGlobal;
  internal IntPtr pUnkForRelease;
}// struct STGMEDIUM

//----------------------------------------------------
// These structure is not used by MMC Snapins.... 
// They are included only to be able to accurately
// define certain interfaces
//----------------------------------------------------
[StructLayout(LayoutKind.Sequential)]
public struct STATSTG
{
    internal int pwcsName;
    internal uint type;
    internal ulong cbSize;
    internal FILETIME mtime;
    internal FILETIME ctime;
    internal FILETIME atime;
    internal uint grfMode;
    internal uint grfLocksSupported;
    internal CLSID clsid;
    internal uint grfStateBits;
    internal uint reserved;
}// struct STATSTG

[StructLayout(LayoutKind.Sequential)]
internal struct FILETIME
{
    internal uint dwLowDateTime;
    internal uint dwHighDateTime;
}// struct FILETIME

[StructLayout(LayoutKind.Sequential)]
internal struct userFLAG_STGMEDIUM
{
    internal int ContextFlags;
    internal int fPassOwnership;
    internal STGMEDIUM Stgmed;
}// struct userFLAG_STGMEDIUM

[StructLayout(LayoutKind.Sequential)]
internal struct PSHNOTIFY
{
    internal NMHDR hdr; 
    internal IntPtr lParam; 
}// struct PSHNOTIFY


[StructLayout(LayoutKind.Sequential)]
internal struct NMHDR
{
    internal IntPtr hwndFrom; 
    internal uint idFrom; 
    internal uint code; 
}// struct NMHDR

[StructLayout(LayoutKind.Sequential)]
internal struct SYSTEMTIME
{
    internal short wYear; 
    internal short wMonth; 
    internal short wDayOfWeek; 
    internal short wDay; 
    internal short wHour; 
    internal short wMinute; 
    internal short wSecond; 
    internal short wMilliseconds; 
}// struct NMHDR

[StructLayout(LayoutKind.Sequential)]
internal struct OSVERSIONINFO
{
    internal uint   dwOSVersionInfoSize; 
    internal uint   dwMajorVersion; 
    internal uint   dwMinorVersion; 
    internal uint   dwBuildNumber; 
    internal uint   dwPlatformId; 
    internal String szCSDVersion; 
}// struct OSVERSIONINFO

[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct SHFILEINFO
{
    internal IntPtr   hIcon;
    internal int      iIcon;
    internal uint     dwAttributes;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
    internal String   szDisplayName;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=80)]
    internal String   szTypeName;
}// struct SHFILEINFO

[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct WIN32_FIND_DATA
{
    internal uint dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal uint nFileSizeHigh;
    internal uint nFileSizeLow;
    internal uint dwReserved0;
    internal uint dwReserved1;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
    internal String   cFileName;
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=14)]
    internal String   cAlternateFileName;
}// struct WIN32_FIND_DATA


[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct WINDOWINFO
{
    internal uint cbSize;
    internal RECT rcWindow;
    internal RECT rcClient;
    internal uint dwStyle;
    internal uint dwExStyle;
    internal uint dwWindowStatus;
    internal uint cxWindowBorders;
    internal uint cyWindowBorders;
	internal short atomWindowType;
	internal short wCreatorVersion;
}// struct WINDOWINFO

[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct RECT
{
    internal int left;
    internal int top;
    internal int right;
    internal int bottom;
}// struct RECT

public delegate IntPtr MessageProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam); 

[StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
internal struct WNDCLASS
{
    internal uint        style;
    internal MessageProc lpfnWndProc;
    internal int         cbClsExtra;
    internal int         cbWndExtra;
    internal IntPtr      hInstance;
    internal IntPtr      hIcon;
    internal IntPtr      hCursor;
    internal IntPtr      hbrBackground;
    internal String      lpszMenuName;
    internal String      lpszClassName;
}// WNDCLASS

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\printingpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Drawing.Printing;

internal class CPrintingPermDialog: CPermDialog
{
    internal CPrintingPermDialog(PrintingPermission perm)
    {
        this.Text = CResourceStore.GetString("PrintingPermission:PermName");
        m_PermControls = new CPrintingPermControls(perm, this);
        Init();        
    }// CPrintingPermDialog  
}// class CPrintingPermDialog

internal class CPrintingPermPropPage: CPermPropPage
{
    internal CPrintingPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("PrintingPermission:PermName"); 
    }// CPrintingPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(PrintingPermission));
        m_PermControls = new CPrintingPermControls(perm, this);
    }// CreateControls
    
}// class CPrintingPermPropPage


internal class CPrintingPermControls : CComboBoxPermissionControls
{
    internal CPrintingPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new PrintingPermission(PermissionState.None);
    }// CPrintingPermControls


    protected override String GetTextForIndex(int nIndex)
    {
        switch(nIndex)
        {
            case 0:
                return CResourceStore.GetString("PrintingPermission:NoPrintDes");
            case 1:
                return CResourceStore.GetString("PrintingPermission:SafePrintDes");
            case 2:
                return CResourceStore.GetString("PrintingPermission:DefaultPrintDes");
            case 3:
                return CResourceStore.GetString("PrintingPermission:AllPrintDes");
        }
        return "";
    }// GetTextForIndex


    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("PrintingPermission:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("PrintingPermission:GrantFollowing");
        
        m_cbOptions.Items.Clear();
        m_cbOptions.Items.Add(CResourceStore.GetString("PrintingPermission:NoPrinting"));
        m_cbOptions.Items.Add(CResourceStore.GetString("PrintingPermission:SafePrinting"));
        m_cbOptions.Items.Add(CResourceStore.GetString("PrintingPermission:DefaultPrinting"));
        m_cbOptions.Items.Add(CResourceStore.GetString("PrintingPermission:AllPrinting"));

        PrintingPermission perm = (PrintingPermission)m_perm;

        CheckUnrestricted(perm);
               
        if (!perm.IsUnrestricted())
        {
            if ((perm.Level&PrintingPermissionLevel.AllPrinting) == PrintingPermissionLevel.AllPrinting)
                m_cbOptions.SelectedIndex = 3;
            else if ((perm.Level&PrintingPermissionLevel.DefaultPrinting) == PrintingPermissionLevel.DefaultPrinting)
                m_cbOptions.SelectedIndex = 2;
            else if ((perm.Level&PrintingPermissionLevel.SafePrinting) == PrintingPermissionLevel.SafePrinting)
                m_cbOptions.SelectedIndex = 1;
            else
                m_cbOptions.SelectedIndex = 0;
        }
        else
            m_cbOptions.SelectedIndex = 3;
        
        onOptionChange(null, null);
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        PrintingPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new PrintingPermission(PermissionState.Unrestricted);
        else
        {
            perm = new PrintingPermission(PermissionState.None);
            PrintingPermissionLevel ppl = PrintingPermissionLevel.NoPrinting;
            if (m_cbOptions.SelectedIndex == 1)
                ppl = PrintingPermissionLevel.SafePrinting;
            else if (m_cbOptions.SelectedIndex == 2)
                ppl = PrintingPermissionLevel.DefaultPrinting;
            else if (m_cbOptions.SelectedIndex == 3)
                ppl = PrintingPermissionLevel.AllPrinting;
         
            perm.Level = ppl;
        }
        return perm;
    }// GetCurrentPermission
}// class CPrintingPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\reflectperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;

internal class CReflectPermDialog: CPermDialog
{
    internal CReflectPermDialog(ReflectionPermission perm)
    {
        this.Text = CResourceStore.GetString("Reflectperm:PermName");
        m_PermControls = new CReflectPermControls(perm, this);
        Init();        
    }// CReflectPermDialog(ReflectionPermission)  
}// class CReflectPermDialog

internal class CReflectPermPropPage: CPermPropPage
{
    internal CReflectPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("Reflectperm:PermName"); 
    }// CReflectPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(ReflectionPermission));
        m_PermControls = new CReflectPermControls(perm, this);
    }// CreateControls

    
}// class CReflectPermPropPage

internal class CReflectPermControls : CPermControls
{
    // Controls on the page
    private CheckBox m_chkReflectionEmit;
    private Label m_lblTypeInformationDes;
    private Label m_lblReflectionEmit;
    private CheckBox m_chkMemberAccess;
    private Label m_lblMemberAccessDes;
    private CheckBox m_chkTypeInformation;

    internal CReflectPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new ReflectionPermission(PermissionState.None);
    }// CReflectPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CReflectPermControls));
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_chkReflectionEmit = new System.Windows.Forms.CheckBox();
        this.m_lblTypeInformationDes = new System.Windows.Forms.Label();
        this.m_lblReflectionEmit = new System.Windows.Forms.Label();
        this.m_chkMemberAccess = new System.Windows.Forms.CheckBox();
        this.m_lblMemberAccessDes = new System.Windows.Forms.Label();
        this.m_chkTypeInformation = new System.Windows.Forms.CheckBox();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_chkReflectionEmit.Location = ((System.Drawing.Point)(resources.GetObject("m_chkReflectionEmit.Location")));
        this.m_chkReflectionEmit.Size = ((System.Drawing.Size)(resources.GetObject("m_chkReflectionEmit.Size")));
        this.m_chkReflectionEmit.TabIndex = ((int)(resources.GetObject("m_chkReflectionEmit.TabIndex")));
        this.m_chkReflectionEmit.Text = resources.GetString("m_chkReflectionEmit.Text");
        m_chkReflectionEmit.Name = "ReflectionEmit";
        this.m_lblTypeInformationDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblTypeInformationDes.Location")));
        this.m_lblTypeInformationDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblTypeInformationDes.Size")));
        this.m_lblTypeInformationDes.TabIndex = ((int)(resources.GetObject("m_lblTypeInformationDes.TabIndex")));
        this.m_lblTypeInformationDes.Text = resources.GetString("m_lblTypeInformationDes.Text");
        m_lblTypeInformationDes.Name = "TypeInformationLabel";
        this.m_lblReflectionEmit.Location = ((System.Drawing.Point)(resources.GetObject("m_lblReflectionEmit.Location")));
        this.m_lblReflectionEmit.Size = ((System.Drawing.Size)(resources.GetObject("m_lblReflectionEmit.Size")));
        this.m_lblReflectionEmit.TabIndex = ((int)(resources.GetObject("m_lblReflectionEmit.TabIndex")));
        this.m_lblReflectionEmit.Text = resources.GetString("m_lblReflectionEmit.Text");
        m_lblReflectionEmit.Name = "ReflectionEmitLabel";
        this.m_chkMemberAccess.Location = ((System.Drawing.Point)(resources.GetObject("m_chkMemberAccess.Location")));
        this.m_chkMemberAccess.Size = ((System.Drawing.Size)(resources.GetObject("m_chkMemberAccess.Size")));
        this.m_chkMemberAccess.TabIndex = ((int)(resources.GetObject("m_chkMemberAccess.TabIndex")));
        this.m_chkMemberAccess.Text = resources.GetString("m_chkMemberAccess.Text");
        m_chkMemberAccess.Name = "MemberAccess";
        this.m_lblMemberAccessDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblMemberAccessDes.Location")));
        this.m_lblMemberAccessDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblMemberAccessDes.Size")));
        this.m_lblMemberAccessDes.TabIndex = ((int)(resources.GetObject("m_lblMemberAccessDes.TabIndex")));
        this.m_lblMemberAccessDes.Text = resources.GetString("m_lblMemberAccessDes.Text");
        m_lblMemberAccessDes.Name = "MemberAccessLabel";
        this.m_chkTypeInformation.Location = ((System.Drawing.Point)(resources.GetObject("m_chkTypeInformation.Location")));
        this.m_chkTypeInformation.Size = ((System.Drawing.Size)(resources.GetObject("m_chkTypeInformation.Size")));
        this.m_chkTypeInformation.TabIndex = ((int)(resources.GetObject("m_chkTypeInformation.TabIndex")));
        this.m_chkTypeInformation.Text = resources.GetString("m_chkTypeInformation.Text");
        m_chkTypeInformation.Name = "TypeInformation";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblMemberAccessDes,
                        this.m_chkMemberAccess,
                        this.m_lblTypeInformationDes,
                        this.m_chkTypeInformation,
                        this.m_lblReflectionEmit,
                        this.m_chkReflectionEmit
                        });
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radUnrestricted,
                        this.m_ucOptions,
                        this.m_radGrantFollowingPermission});
     
           // Fill in the data
        PutValuesinPage();

        // Put in event Handlers
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_chkMemberAccess.CheckStateChanged += new EventHandler(onChange);
        m_chkTypeInformation.CheckStateChanged += new EventHandler(onChange);
        m_chkReflectionEmit.CheckStateChanged += new EventHandler(onChange);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);



        return 1;
    }// InsertPropSheetPageControls

   
    protected override void PutValuesinPage()
    {
        ReflectionPermission perm = (ReflectionPermission)m_perm;

    
        if (perm.IsUnrestricted())
        {
            m_radUnrestricted.Checked=true;
            m_ucOptions.Enabled = false;

        }
        else
        {
            m_radGrantFollowingPermission.Checked=true;

            if ((perm.Flags & ReflectionPermissionFlag.MemberAccess) > 0)
                m_chkMemberAccess.Checked=true;
            if ((perm.Flags & ReflectionPermissionFlag.ReflectionEmit) > 0)
                m_chkReflectionEmit.Checked =true;
            if ((perm.Flags & ReflectionPermissionFlag.TypeInformation) > 0)
                m_chkTypeInformation.Checked=true;
        }
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        ReflectionPermission refperm;
        if (m_radUnrestricted.Checked == true)
            refperm = new ReflectionPermission(PermissionState.Unrestricted);
        else
        {
            ReflectionPermissionFlag rpf = ReflectionPermissionFlag.NoFlags;

            if (m_chkMemberAccess.Checked == true)
                rpf |= ReflectionPermissionFlag.MemberAccess;
            if (m_chkReflectionEmit.Checked == true)
                rpf |= ReflectionPermissionFlag.ReflectionEmit;
            if (m_chkTypeInformation.Checked == true)
                rpf |= ReflectionPermissionFlag.TypeInformation;

            refperm = new ReflectionPermission(rpf);
        }

        return refperm;
    }// GetCurrentPermission

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CReflectPermControls



}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\oledbpermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Data.OleDb;

internal class COleDbPermDialog: CPermDialog
{
    internal COleDbPermDialog(OleDbPermission perm)
    {
        this.Text = CResourceStore.GetString("OleDbPermission:PermName");
        m_PermControls = new COleDbPermControls(perm, this);
        Init();        
    }// COleDbPermDialog(OleDbPermission)  
}// class COleDbPermDialog

internal class COleDbPermPropPage: CPermPropPage
{
    internal COleDbPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("OleDbPermission:PermName"); 
    }// COleDbPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(OleDbPermission));
        m_PermControls = new COleDbPermControls(perm, this);
    }// CreateControls
    
}// class COleDbPermPropPage


internal class COleDbPermControls : CTablePermControls
{
    // Winforms control
    private CheckBox m_chkAllowBlank;

    internal COleDbPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new OleDbPermission(PermissionState.None);
    }// COleDbPermControls

    
    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Provider" Column
        DataColumn dcProvider = new DataColumn();
        dcProvider.ColumnName = "Provider";
        dcProvider.DataType = typeof(String);
        dt.Columns.Add(dcProvider);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcProvider = new DataGridTextBoxColumn();
         
        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Path column
        dgtbcProvider.MappingName = "Provider";
        dgtbcProvider.HeaderText = CResourceStore.GetString("Provider");
        dgtbcProvider.Width = ScaleWidth(CResourceStore.GetInt("OleDbPermission:ProviderColumnWidth"));
        dgtbcProvider.NullText = "";
        dgtbcProvider.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcProvider);
   
           return dt;
    }// CreateDataTable
    
    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("OleDbPermission:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("OleDbPermission:GrantFollowing");


        // Adjust some of the UI components on this page (and put in a checkbox)
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(COleDbPermControls));
        this.m_chkAllowBlank = new System.Windows.Forms.CheckBox();
        this.m_btnDeleteRow.Location = ((System.Drawing.Point)(resources.GetObject("m_btn.Location")));
        this.m_chkAllowBlank.Location = ((System.Drawing.Point)(resources.GetObject("m_chkAllowBlank.Location")));
        this.m_chkAllowBlank.Name = "m_chkAllowBlank";
        this.m_chkAllowBlank.Size = ((System.Drawing.Size)(resources.GetObject("m_chkAllowBlank.Size")));
        this.m_chkAllowBlank.TabIndex = ((int)(resources.GetObject("m_chkAllowBlank.TabIndex")));
        this.m_chkAllowBlank.Text = resources.GetString("m_chkAllowBlank.Text");
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_chkAllowBlank.Click += new EventHandler(onChange);


        m_ucOptions.Controls.Add(this.m_chkAllowBlank);

        OleDbPermission perm = (OleDbPermission)m_perm;
                
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            String[] sProviders = perm.Provider.Split(new char[] {';'});
            
            for(int i=0; i<sProviders.Length; i++)
            {
                if (sProviders[i].Length > 0)
                {
                    DataRow newRow = m_dt.NewRow();
                    newRow["Provider"]=sProviders[i];
                    m_dt.Rows.Add(newRow);
                }
            }

            m_chkAllowBlank.Checked = perm.AllowBlankPassword;
            
        }

        // We want at least 1 rows so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Provider"]="";
        dt.Rows.Add(newRow);
    }// AddEmptyRow


    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(1,0);
        m_dg.CurrentCell = new DataGridCell(0,0);

        OleDbPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new OleDbPermission(PermissionState.Unrestricted);
        else
        {
            perm = new OleDbPermission(PermissionState.None);
            String sProviders = "";
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have an file permission to add
                if (m_dg[i, 0] is String && ((String)m_dg[i, 0]).Length > 0)
                {
                    sProviders += (String)m_dg[i, 0] + ";";
                }
            }

            // Strip off the last ';'
            if (sProviders.Length > 0)
                sProviders = sProviders.Substring(0, sProviders.Length-1); 
            

            perm.Provider = sProviders;
            perm.AllowBlankPassword = m_chkAllowBlank.Checked;

        }
        return perm;
    }// GetCurrentPermission
}// class COleDbPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\performancecounterperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;

internal class CPerformanceCounterPermDialog: CPermDialog
{
    internal CPerformanceCounterPermDialog(PerformanceCounterPermission perm)
    {
        this.Text = CResourceStore.GetString("PerformanceCounterPerm:PermName");
        m_PermControls = new CPerformanceCounterPermControls(perm, this);
        Init();        
    }// CPerformanceCounterPermDialog  
}// class CPerformanceCounterPermDialog

internal class CPerformanceCounterPermPropPage: CPermPropPage
{
    internal CPerformanceCounterPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("PerformanceCounterPerm:PermName"); 
    }// CPerformanceCounterPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(PerformanceCounterPermission));
        m_PermControls = new CPerformanceCounterPermControls(perm, this);
    }// CreateControls
   
}// class CPerformanceCounterPermPropPage

internal class CPerformanceCounterPermControls : CTablePermControls
{
    internal CPerformanceCounterPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new PerformanceCounterPermission(PermissionState.None);
    }// CPerformanceCounterPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Machine Name" Column
        DataColumn dcMachine = new DataColumn();
        dcMachine.ColumnName = "Machine";
        dcMachine.DataType = typeof(String);
        dt.Columns.Add(dcMachine);

        // Create the "Catagory" Column
        DataColumn dcCatagory = new DataColumn();
        dcCatagory.ColumnName = "Category";
        dcCatagory.DataType = typeof(String);
        dt.Columns.Add(dcCatagory);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcMachine = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcCatagory = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle();

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Machine column
        dgtbcMachine.MappingName = "Machine";
        dgtbcMachine.HeaderText = CResourceStore.GetString("PerformanceCounterPermission:Machine");
        dgtbcMachine.Width = ScaleWidth(CResourceStore.GetInt("PerformanceCounter:MachineColumnWidth"));
        dgtbcMachine.NullText = "";
        dgtbcMachine.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcMachine);

        // Set up the column info for the Browse column
        dgtbcCatagory.MappingName = "Category";
        dgtbcCatagory.HeaderText = CResourceStore.GetString("PerformanceCounterPermission:Category");
        dgtbcCatagory.NullText = "";
        dgtbcCatagory.Width = ScaleWidth(CResourceStore.GetInt("PerformanceCounter:CategoryColumnWidth"));
        dgtbcCatagory.TextBox.TextChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcCatagory);

        // Set up the column info for the Instrument column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("PerformanceCounterPermission:Access");
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("PerformanceCounter:AccessColumnWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("PerformanceCounterPermission:Browse")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("PerformanceCounterPermission:Instrument")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("None")),
                                                };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);


        dgts.GridColumnStyles.Add(dgccAccess);
        
        return dt;
    }// CreateDataTable

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("PerformanceCounterPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("PerformanceCounterPerm:GrantFollowing");

        PerformanceCounterPermission perm = (PerformanceCounterPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.PermissionEntries.GetEnumerator();
            while (enumer.MoveNext())
            {
                PerformanceCounterPermissionEntry pcpe = (PerformanceCounterPermissionEntry)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();

                newRow["Machine"]=pcpe.MachineName;
                newRow["Category"]=pcpe.CategoryName;

                // Determine the Access String
                String sAccess = null;
                
                if ((pcpe.PermissionAccess&PerformanceCounterPermissionAccess.Administer) == PerformanceCounterPermissionAccess.Administer)
                    sAccess = CResourceStore.GetString("PerformanceCounterPermission:Administer");
                else if ((pcpe.PermissionAccess&PerformanceCounterPermissionAccess.Instrument) == PerformanceCounterPermissionAccess.Instrument)
                    sAccess = CResourceStore.GetString("PerformanceCounterPermission:Instrument");
                else if ((pcpe.PermissionAccess&PerformanceCounterPermissionAccess.Browse) == PerformanceCounterPermissionAccess.Browse)
                    sAccess = CResourceStore.GetString("PerformanceCounterPermission:Browse");
                else 
                    sAccess = CResourceStore.GetString("None");
                    
                newRow["Access"] = new DataGridComboBoxEntry(sAccess);
                m_dt.Rows.Add(newRow);
            }
          
        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Machine"]="";
        newRow["Category"]="";
        newRow["Access"]=CResourceStore.GetString("None");
           
        dt.Rows.Add(newRow);
    }// AddEmptyRow

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
    
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        PerformanceCounterPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new PerformanceCounterPermission(PermissionState.Unrestricted);
        else
        {
            perm = new PerformanceCounterPermission(PermissionState.None);
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a socket permission to add
                if (m_dg[i, 0] != DBNull.Value && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sName = (String)m_dg[i, 0];
                    if (m_dg[i, 1] == DBNull.Value || ((String)m_dg[i, 1]).Length == 0)
                    {
                        MessageBox(CResourceStore.GetString("PerformanceCounter:NeedCategory"),
                                   CResourceStore.GetString("PerformanceCounter:NeedCategoryTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;

                    }
                    
                    String sCategory = (String)m_dg[i, 1];
                    
                    PerformanceCounterPermissionAccess pcpa = PerformanceCounterPermissionAccess.None;
                    
                    if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("PerformanceCounterPermission:Administer")))
                        pcpa = PerformanceCounterPermissionAccess.Administer;

                    else if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("PerformanceCounterPermission:Instrument")))
                        pcpa = PerformanceCounterPermissionAccess.Instrument;

                    else if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("PerformanceCounterPermission:Browse")))
                        pcpa = PerformanceCounterPermissionAccess.Browse;

                    perm.PermissionEntries.Add(new PerformanceCounterPermissionEntry(pcpa, sName, sCategory));        
                }
                else if (m_dg[i, 1] != DBNull.Value && ((String)m_dg[i, 1]).Length > 0)
                {
                    MessageBox(CResourceStore.GetString("PerformanceCounter:NeedMachineName"),
                               CResourceStore.GetString("PerformanceCounter:NeedMachineNameTitle"),
                               MB.ICONEXCLAMATION);
                    return null;

                }
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the combo box
        if (m_dg[iSelRow, 2] == DBNull.Value)
                m_dg[iSelRow, 2] = CResourceStore.GetString("None");

        ActivateApply();
      
    }// onClick
}// class CPerformanceCounterPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\mmcspecificconstsandinterfaces.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// mmcSpecificConstsAndInterfaces.cs
//
// Contains constants and interfaces that are unique to this snapin
//-------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Runtime.CompilerServices;
using System.Reflection;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Runtime.Remoting;
using System.Security.Policy;
using System.Security;
using System.Security.Permissions;


namespace Microsoft.CLRAdmin
{
    internal class COMMANDS
    {
         internal const int ADD_GACASSEMBLY                = 0;
         internal const int ADD_APPLICATION                = 1;
         internal const int NEW_PERMISSIONSET              = 2;
         internal const int NEW_SECURITYPOLICY             = 3;
         internal const int OPEN_SECURITYPOLICY            = 4;
         internal const int EVALUATE_ASSEMBLY              = 5;
         internal const int ADJUST_SECURITYPOLICY          = 6;
         internal const int CREATE_MSI                     = 7;
         internal const int TRUST_ASSEMBLY                 = 8;
         internal const int FIX_APPLICATION                = 9;
         internal const int RESET_POLICY                   = 10;
         
         // Commands that our command history should ignore
         // should start with 1000
         internal const int SHOW_LISTVIEW                  = 1001;
         internal const int SHOW_TASKPAD                   = 1002;
         internal const int SAVE_SECURITYPOLICY            = 1003;
         internal const int DUPLICATE_PERMISSIONSET        = 1004;
         internal const int REMOVE_PERMISSIONSET           = 1005;
         internal const int DUPLICATE_CODEGROUP            = 1006;
         internal const int REMOVE_CODEGROUP               = 1007;
         internal const int REMOVE_ASSEMBLY                = 1008;
         internal const int REMOVE_PERMISSION              = 1009;
         internal const int REMOVE_APPLICATION             = 1010;
         internal const int VIEW_PERMISSION                = 1011;
         internal const int ADD_PERMISSIONS                = 1012;
         internal const int REFRESH_DISPLAY                = 1013;
         internal const int UNDO_SECURITYPOLICY            = 1014;
         internal const int FIND_DEPENDENTASSEMBLIES       = 1015;
         internal const int CREATE_CODEGROUP               = 1016;
         internal const int ADD_ASSEMBLY                   = 1017;

    }// class COMMANDS

    internal class FILEPERMS
    {
        internal const int READ=0;
        internal const int WRITE=1;
        internal const int APPEND=2;
        internal const int PDISC=3;
    }// class FILEPERMS

    internal interface IColumnResultView
    {
        int getNumColumns();
        int getNumRows();
        String getColumnTitles(int iIndex);
        String getValues(int iX, int iY);
        void AddImages(ref IImageList il);
        int GetImageIndex(int i);
        bool DoesItemHavePropPage(Object o);
        CPropPage[] CreateNewPropPages(Object o);
    }// IColumnResultView

    // If another program is going to host this snapin
    // besides MMC, they should implement this interface
    public interface INonMMCHost
    {
    }// INonMMCHost

    internal class NotEvalCodegroup : CodeGroup
    {
        public NotEvalCodegroup(): base(new AllMembershipCondition(), new PolicyStatement(new PermissionSet(PermissionState.None)))
        {}
        public override PolicyStatement Resolve(Evidence e)
        {
            return null;
        }
        public override CodeGroup ResolveMatchingCodeGroups(Evidence e)
        {   
            return null;
        }
        public override CodeGroup Copy()
        {
            return null;
        }
        public override String MergeLogic
        {
            get{return null;}
        }
    }// NotEvalCodegroup
    
        
    internal class BindingRedirInfo
    {
        internal String Name;
        internal String PublicKeyToken;
        internal bool   fHasBindingPolicy;
        internal bool   fHasCodebase;
    }// struct BindingRedirInfo

    internal struct BindingPolicy
    {
        internal StringCollection scBaseVersion;
        internal StringCollection scRedirectVersion;
    }

    internal struct CodebaseLocations
    {
        internal StringCollection scVersion;
        internal StringCollection scCodeBase;
    }

    internal struct AppFiles
    {
        internal string sAppFile;
        internal string sAppConfigFile;
    }// struct AppFiles

    internal class RemotingApplicationInfo
    {
        internal String sURL;
        internal String sName;
        internal StringCollection scActObjectType;
        internal StringCollection scActAssembly;

        internal StringCollection scWellKnownObjectType;
        internal StringCollection scWellKnownAssembly;
        internal StringCollection scWellKnownURL;

        internal RemotingApplicationInfo()
        {
            sURL = "";
            sName = ""; 
            scActObjectType = new StringCollection();
            scActAssembly = new StringCollection();
            scWellKnownObjectType = new StringCollection();
            scWellKnownAssembly = new StringCollection();
            scWellKnownURL = new StringCollection();
        }// RemotingApplicationInfo
    }// class RemotingApplicationInfo

    internal class ExposedTypes
    {
        internal StringCollection scActivatedName;
        internal StringCollection scActivatedType;
        internal StringCollection scActivatedAssem;
        internal StringCollection scActivatedLease;
        internal StringCollection scActivatedRenew;

        internal StringCollection scWellKnownObjectName;
        internal StringCollection scWellKnownMode;
        internal StringCollection scWellKnownType;
        internal StringCollection scWellKnownAssem;
        internal StringCollection scWellKnownUri;

        internal ExposedTypes()
        {
            scActivatedName = new StringCollection();
            scActivatedType = new StringCollection();
            scActivatedAssem = new StringCollection();
            scActivatedLease = new StringCollection();
            scActivatedRenew = new StringCollection();

            scWellKnownObjectName = new StringCollection();
            scWellKnownMode = new StringCollection();
            scWellKnownType = new StringCollection();
            scWellKnownAssem = new StringCollection();
            scWellKnownUri = new StringCollection();
        }// ExposedTypes

    }// class ExposedTypes

    internal class RemotingChannel
    {
        internal StringCollection scAttributeName;
        internal StringCollection scAttributeValue;
        internal ArrayList  alChildren;

        internal String sName;
        
        internal RemotingChannel()
        {
            sName = "channel";
            scAttributeName = new StringCollection();
            scAttributeValue = new StringCollection();
            alChildren = new ArrayList();
        }// RemotingChannel

    }// class RemotingChannel


    internal class MyDataGrid : DataGrid
    {
        internal ScrollBar TheVertScrollBar
        {
            get
            {
                return VertScrollBar;
            }
        }// TheVertScrollBar
    }// class MyDataGrid

    internal class DataGridComboBoxEntry
    {
        private String m_sValue;
        internal DataGridComboBoxEntry(String sValue)
        {
            m_sValue = sValue;
        }
        public String Value
        {
            get{return m_sValue;}
        }
        public override String ToString()
        {
            return m_sValue;
        }
    }// DataGridComboBoxEntry
  
    internal class PathListFunctions
    {
        static internal StringCollection IntersectCollections(ref StringCollection sc1, ref StringCollection sc2)
        {
            StringCollection scOutput = new StringCollection();
            int iLen=sc1.Count;
            for(int i=0; i<iLen; i++)
            {
                // Clean up our String Collection a little bit   
                if (sc1[i].Length == 0)
                {
                    sc1.RemoveAt(i);
                    i--;
                    iLen--;
                }
                else
                {
                    int iIndexInSecond=sc2.IndexOf(sc1[i]);
                    if (iIndexInSecond != -1)
                    {
                        scOutput.Add(sc1[i]);
                        // Pull this string out of the two string collections
                        sc1.RemoveAt(i);
                        sc2.RemoveAt(iIndexInSecond);
                        // Set the counters so we won't be lost
                        i--;
                        iLen--;
    
                    }                
                }
            }
            return scOutput;
        }// IntersectCollections

        static internal StringCollection CondIntersectCollections(ref StringCollection sc1, ref StringCollection sc2, ref StringCollection sc3)
        {
            StringCollection scOutput = new StringCollection();
            int iLen=sc1.Count;
            for(int i=0; i<iLen; i++)
            {
                // Clean up our String Collection a little bit   
                if (sc1[i].Equals(""))
                {
                    sc1.RemoveAt(i);
                    i--;
                    iLen--;
                }
                else
                {
                    int iIndexInSecond=sc2.IndexOf(sc1[i]);
                    if (iIndexInSecond != -1 && !sc3.Contains(sc1[i]))
                    {
                        scOutput.Add(sc1[i]);
                        // Pull this string out of the two string collections
                        sc1.RemoveAt(i);
                        sc2.RemoveAt(iIndexInSecond);
                        // Set the counters so we won't be lost
                        i--;
                        iLen--;
    
                    }                
                }
            }
            return scOutput;
        }// IntersectCollections

        static internal StringCollection IntersectAllCollections(ref StringCollection sc1, ref StringCollection sc2, ref StringCollection sc3)
        {
            StringCollection scEmpty = new StringCollection();
            StringCollection sc1and2Union = IntersectCollections(ref sc1, ref sc2);
            return IntersectCollections(ref sc1and2Union, ref sc3);
        }// IntersectAllCollections
                
        static internal String JoinStringCollection(StringCollection sc)
        {
            int iLen = sc.Count;
            String s = "";
            for(int i=0; i<iLen; i++)
            {
                s+=sc[i];
                // Only add the seperator if it's not the last item
                if (i+1 != iLen)
                    s+=";";
            }
            return s;
        }// JoinStringCollection
 
    }// class PathListFunctions

internal class AssemblyLoader
{
    AppDomain m_ad;

    internal void Finished()
    {
        if (m_ad != null)
            AppDomain.Unload(m_ad);
        m_ad = null;
    }// Finished

    internal AssemblyRef LoadAssemblyInOtherAppDomainFrom(String sLocation)
    {
        if (m_ad != null)
            Finished();
        Assembly ExecAsm = Assembly.GetExecutingAssembly();
        m_ad = AppDomain.CreateDomain("appDomain",ExecAsm.Evidence);
        
        Type t = typeof(AssemblyRef);
        String aname = Assembly.GetExecutingAssembly().FullName;
      
        ObjectHandle oh = m_ad.CreateInstance(aname,                // Assembly file name
                                            t.FullName,           // Type name
                                            false,                // ignore case
                                            BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public, // binding attributes
                                            null,                 // binder
                                            null,                 // args
                                            ExecAsm.GetName().CultureInfo,  // culture info 
                                            null,                 // activation attributes
                                            ExecAsm.Evidence    // security attributes
                                            );
        AssemblyRef ar = (AssemblyRef) oh.Unwrap();
        ar.LoadFrom (sLocation);
        return ar;
    }// LoadAssemblyInOtherAppDomainFrom
}// TimAssemblyStuff
    

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by urtui.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\regperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;

internal class CRegPermDialog: CPermDialog
{
    internal CRegPermDialog(RegistryPermission perm)
    {
        this.Text = CResourceStore.GetString("RegPerm:PermName");
        m_PermControls = new CRegPermControls(perm, this);
        Init();        
    }// CRegPermDialog(RegistryPermission)  
}// class CRegPermDialog

internal class CRegPermPropPage: CPermPropPage
{
    internal CRegPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("RegPerm:PermName"); 
    }// CRegPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(RegistryPermission));
        m_PermControls = new CRegPermControls(perm, this);
    }// CreateControls
   
}// class CRegPermPropPage


internal class CRegPermControls : CTablePermControls
{
    internal CRegPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new RegistryPermission(PermissionState.None);
    }// CRegPermControls

    protected override DataTable CreateDataTable(DataGrid dg)
    {
    
        DataTable dt = new DataTable("Stuff");

        // Create the "Key" Column
        DataColumn dcKey = new DataColumn();
        dcKey.ColumnName = "Key";
        dcKey.DataType = typeof(String);
        dt.Columns.Add(dcKey);

        // Create the "Read" Column
        DataColumn dcRead = new DataColumn();
        dcRead.ColumnName = "Read";
        dcRead.DataType = typeof(bool);
        dt.Columns.Add(dcRead);


        // Create the "Write" Column
        DataColumn dcWrite = new DataColumn();
        dcWrite.ColumnName = "Write";
        dcWrite.DataType = typeof(bool);
        dt.Columns.Add(dcWrite);

        // Create the "Create" Column
        DataColumn dcAppend = new DataColumn();
        dcAppend.ColumnName = "Create";
        dcAppend.DataType = typeof(bool);
        dt.Columns.Add(dcAppend);


        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridBoolColumn dgbcRead = new DataGridBoolColumn();
        DataGridBoolColumn dgbcWrite = new DataGridBoolColumn();
        DataGridBoolColumn dgbcCreate = new DataGridBoolColumn();
        DataGridTextBoxColumn dgtbcKey = new DataGridTextBoxColumn();
         
        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Path column
        dgtbcKey.MappingName = "Key";
        dgtbcKey.HeaderText = CResourceStore.GetString("Key");
        dgtbcKey.Width = ScaleWidth(CResourceStore.GetInt("RegPerm:KeyColumnWidth"));
        dgtbcKey.NullText = "";
        dgtbcKey.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcKey);

        // Set up the column info for the Read column
        dgbcRead.MappingName = "Read";
        dgbcRead.HeaderText = CResourceStore.GetString("RegistryPermission:Read");
        dgbcRead.AllowNull = false;
        dgbcRead.Width = ScaleWidth(CResourceStore.GetInt("RegPerm:ReadColumnWidth"));
        dgbcRead.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcRead);

        // Set up the column info for the Write column
        dgbcWrite.MappingName = "Write";
        dgbcWrite.HeaderText = CResourceStore.GetString("RegistryPermission:Write");
        dgbcWrite.AllowNull = false;
        dgbcWrite.Width = ScaleWidth(CResourceStore.GetInt("RegPerm:WriteColumnWidth"));
        dgbcWrite.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcWrite);

        // Set up the column info for the Append column
        dgbcCreate.MappingName = "Create";
        dgbcCreate.HeaderText = CResourceStore.GetString("RegistryPermission:Create");
        dgbcCreate.AllowNull = false;
        dgbcCreate.Width = ScaleWidth(CResourceStore.GetInt("RegPerm:CreateColumnWidth"));
        dgbcCreate.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcCreate);
      
        return dt;
    }

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("RegPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("RegPerm:GrantFollowing");

        RegistryPermission perm = (RegistryPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            StringCollection scReadKeys = new StringCollection();
            StringCollection scWriteKeys = new StringCollection();
            StringCollection scCreateKeys = new StringCollection();
            StringCollection scRWKeys = new StringCollection();
            StringCollection scRCKeys = new StringCollection();
            StringCollection scWCKeys = new StringCollection();
            StringCollection scRWCKeys = new StringCollection();
    
            // Get the paths the user has access to
            if (perm.GetPathList(RegistryPermissionAccess.Read) != null)
                scReadKeys.AddRange(perm.GetPathList(RegistryPermissionAccess.Read).Split(new char[] {';'}));
            if (perm.GetPathList(RegistryPermissionAccess.Write) != null)
                scWriteKeys.AddRange(perm.GetPathList(RegistryPermissionAccess.Write).Split(new char[] {';'})); 
            if (perm.GetPathList(RegistryPermissionAccess.Create) != null)
                scCreateKeys.AddRange(perm.GetPathList(RegistryPermissionAccess.Create).Split(new char[] {';'}));

            // Careful with the order of these calls... make sure the final IntersectAllCollections
            // is the last function to get called. Also, make sure each of the base
            // string collections (Read, Write, and Append) all are the 1st argument in the
            // IntersectCollections call at least once, to clean up any "" that might be floating around
            scRWKeys = PathListFunctions.CondIntersectCollections(ref scReadKeys, ref scWriteKeys, ref scCreateKeys);
            scRCKeys = PathListFunctions.CondIntersectCollections(ref scCreateKeys, ref scReadKeys,  ref scWriteKeys);
            scWCKeys = PathListFunctions.CondIntersectCollections(ref scWriteKeys, ref scCreateKeys, ref scReadKeys);
            scRWCKeys = PathListFunctions.IntersectAllCollections(ref scReadKeys, ref scWriteKeys, ref scCreateKeys);

            // Now we have 7 different combinations we have to run through
            String[] sFilePaths = new String[] {
                                                PathListFunctions.JoinStringCollection(scReadKeys),
                                                PathListFunctions.JoinStringCollection(scWriteKeys),
                                                PathListFunctions.JoinStringCollection(scCreateKeys),
                                                PathListFunctions.JoinStringCollection(scRWKeys),
                                                PathListFunctions.JoinStringCollection(scRCKeys),
                                                PathListFunctions.JoinStringCollection(scWCKeys),
                                                PathListFunctions.JoinStringCollection(scRWCKeys)
                                                };

            RegistryPermissionAccess[] fipa = new RegistryPermissionAccess[] {
                                                    RegistryPermissionAccess.Read,
                                                    RegistryPermissionAccess.Write,
                                                    RegistryPermissionAccess.Create,
                                                    RegistryPermissionAccess.Read|RegistryPermissionAccess.Write,
                                                    RegistryPermissionAccess.Create|RegistryPermissionAccess.Read,
                                                    RegistryPermissionAccess.Create|RegistryPermissionAccess.Write,
                                                    RegistryPermissionAccess.Read|RegistryPermissionAccess.Write|RegistryPermissionAccess.Create};

            for(int i=0; i<7; i++)
            {
                DataRow newRow;
                // See if we have some info for this one
                if (sFilePaths[i].Length > 0)
                {
                    newRow = m_dt.NewRow();
                    newRow["Key"]=sFilePaths[i];
                    newRow["Read"]=(fipa[i] & RegistryPermissionAccess.Read) > 0;
                    newRow["Write"]=(fipa[i] & RegistryPermissionAccess.Write) > 0;
                    newRow["Create"]=(fipa[i] & RegistryPermissionAccess.Create) > 0;
                    m_dt.Rows.Add(newRow);
                }
            }
        }

        // We want at least 1 rows so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        RegistryPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new RegistryPermission(PermissionState.Unrestricted);
        else
        {
            perm = new RegistryPermission(PermissionState.None);
            StringCollection scRead = new StringCollection();
            StringCollection scWrite = new StringCollection();
            StringCollection scCreate = new StringCollection();
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a registry permission to add
                if (m_dg[i, 0] is String && ((String)m_dg[i, 0]).Length > 0)
                {
                    // Does this path have read permissions
                    if ((bool)m_dg[i, 1])
                        scRead.Add((String)m_dg[i, 0]);
                    // Does this path have write permissions
                    if ((bool)m_dg[i, 2])
                        scWrite.Add((String)m_dg[i, 0]);
                    // Does this have append permissions
                    if ((bool)m_dg[i, 3])
                        scCreate.Add((String)m_dg[i, 0]);
                }
                else
                {
                    // Make sure they didn't check any boxes and not include
                    // an empty path
                    bool fCheckedBox = false;
                    for(int j=1; j<=3 && !fCheckedBox; j++)
                        fCheckedBox = (bool)m_dg[i, j];

                    if (fCheckedBox)
                    {            
                        MessageBox(CResourceStore.GetString("RegPerm:NeedRegName"),
                                   CResourceStore.GetString("RegPerm:NeedRegNameTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;    
                    }
                   }
            }
            String sAdd = PathListFunctions.JoinStringCollection(scRead);
            if (sAdd.Length > 0)
                perm.AddPathList(RegistryPermissionAccess.Read, sAdd);

            String sWrite = PathListFunctions.JoinStringCollection(scWrite);
            if (sWrite.Length > 0)
                perm.AddPathList(RegistryPermissionAccess.Write, sWrite);

            String sCreate = PathListFunctions.JoinStringCollection(scCreate);
            if (sCreate.Length > 0)
                perm.AddPathList(RegistryPermissionAccess.Create, sCreate);

        }
        return perm;
    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        for(int i=1; i<4; i++)
            if (m_dg[iSelRow, i] == DBNull.Value)
                m_dg[iSelRow, i]=false;

        ActivateApply();
    }// onClick

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow;
        newRow = dt.NewRow();
        newRow["Key"]="";
        newRow["Read"]=false;
        newRow["Write"]=false;
        newRow["Create"]=false;
        dt.Rows.Add(newRow);
    }// AddEmptyRow

}// class CRegPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\socketperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Net;
using System.Collections;

internal class CSocketPermDialog: CPermDialog
{
    internal CSocketPermDialog(SocketPermission perm)
    {
        this.Text = CResourceStore.GetString("SocketPerm:PermName");

        if (perm == null)
            perm = new SocketPermission(PermissionState.None);
        
        m_PermControls = new CSocketPermControls(perm, this);
        Init();        
    }// CSocketPermDialog(SocketPermission)  
}// class CSocketPermDialog

internal class CSocketPermPropPage: CPermPropPage
{
    internal CSocketPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("SocketPerm:PermName"); 
    }// CSocketPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(SocketPermission));
        m_PermControls = new CSocketPermControls(perm, this);
    }// CreateControls
}// class CSocketPermPropPage

internal class CSocketPermControls : CTablePermControls
{
    internal CSocketPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new SocketPermission(PermissionState.None);
    }// CSocketPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Host" Column
        DataColumn dcHost = new DataColumn();
        dcHost.ColumnName = "Host";
        dcHost.DataType = typeof(String);
        dt.Columns.Add(dcHost);

        // Create the "Port" Column
        DataColumn dcPort = new DataColumn();
        dcPort.ColumnName = "Port";
        dcPort.DataType = typeof(String);
        dt.Columns.Add(dcPort);

        // Create the "Direction" Column
        DataColumn dcDirection = new DataColumn();
        dcDirection.ColumnName = "Direction";
        dcDirection.DataType = typeof(String);
        dt.Columns.Add(dcDirection);

        // Create the "TCP" Column
        DataColumn dcTCP = new DataColumn();
        dcTCP.ColumnName = "TCP";
        dcTCP.DataType = typeof(bool);
        dt.Columns.Add(dcTCP);
        
        // Create the "UDP" Column
        DataColumn dcUDP = new DataColumn();
        dcUDP.ColumnName = "UDP";
        dcUDP.DataType = typeof(bool);
        dt.Columns.Add(dcUDP);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcHost = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcPort = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccDirection = new DataGridComboBoxColumnStyle();
        DataGridBoolColumn dgbcTCP= new DataGridBoolColumn();
        DataGridBoolColumn dgbcUDP = new DataGridBoolColumn();
         
        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Host column
        dgtbcHost.MappingName = "Host";
        dgtbcHost.HeaderText = CResourceStore.GetString("Host");
        dgtbcHost.Width = ScaleWidth(CResourceStore.GetInt("SocketPerm:HostColumnWidth"));
        dgtbcHost.NullText = "";
        dgtbcHost.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcHost);

        // Set up the column info for the Port column
        dgtbcPort.MappingName = "Port";
        dgtbcPort.HeaderText = CResourceStore.GetString("SocketPermission:Port");
        dgtbcPort.NullText = "";
        dgtbcPort.Width = ScaleWidth(CResourceStore.GetInt("SocketPerm:PortColumnWidth"));
        dgtbcPort.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcPort);

        // Set up the column info for the direction column
        dgccDirection.MappingName = "Direction";
        dgccDirection.HeaderText = CResourceStore.GetString("SocketPermission:Direction");
        dgccDirection.Width = ScaleWidth(CResourceStore.GetInt("SocketPerm:DirectionColumnWidth"));
        dgccDirection.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("SocketPermission:Accept")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("SocketPermission:Connect"))
                                                };
        dgccDirection.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);


        dgts.GridColumnStyles.Add(dgccDirection);

        // Set up the column info for the TCP column
        dgbcTCP.MappingName = "TCP";
        dgbcTCP.HeaderText = CResourceStore.GetString("SocketPermission:TCP");
        dgbcTCP.AllowNull = false;
        dgbcTCP.Width = ScaleWidth(CResourceStore.GetInt("SocketPerm:TCPColumnWidth"));
        dgbcTCP.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcTCP);

        // Set up the column info for the UDP column
        dgbcUDP.MappingName = "UDP";
        dgbcUDP.HeaderText = CResourceStore.GetString("SocketPermission:UDP");
        dgbcUDP.AllowNull = false;
        dgbcUDP.Width = ScaleWidth(CResourceStore.GetInt("SocketPerm:UDPColumnWidth"));
        dgbcUDP.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcUDP);

        return dt;
    }// CreateDataTable

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("SocketPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("SocketPerm:GrantFollowing");

        SocketPermission perm = (SocketPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.AcceptList;
            while (enumer.MoveNext())
            {
                EndpointPermission epp = (EndpointPermission)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();
                newRow["Host"]=epp.Hostname;
                newRow["Port"]=epp.Port.ToString();
                newRow["Direction"]=new DataGridComboBoxEntry(CResourceStore.GetString("SocketPermission:Accept"));
                newRow["TCP"]=((epp.Transport&TransportType.Tcp) == TransportType.Tcp);
                newRow["UDP"]=((epp.Transport&TransportType.Udp) == TransportType.Udp);
                m_dt.Rows.Add(newRow);
            }
            
            // Run through the list of socket permissions we have to connect through

            enumer = perm.ConnectList;
            while (enumer.MoveNext())
            {
                EndpointPermission epp = (EndpointPermission)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();
                newRow["Host"]=epp.Hostname;
                newRow["Port"]=epp.Port.ToString();
                newRow["Direction"]=CResourceStore.GetString("SocketPermission:Connect");
                newRow["TCP"]=((epp.Transport&TransportType.Tcp) == TransportType.Tcp);
                newRow["UDP"]=((epp.Transport&TransportType.Udp) == TransportType.Udp);
                m_dt.Rows.Add(newRow);
            }

        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Host"]="";
        newRow["Port"]="";
        newRow["Direction"]=CResourceStore.GetString("SocketPermission:Accept");
        newRow["TCP"]=false;
        newRow["UDP"]=false;
            
        dt.Rows.Add(newRow);
    }// AddEmptyRow

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
    
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        SocketPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new SocketPermission(PermissionState.Unrestricted);
        else
        {
            perm = new SocketPermission(PermissionState.None);
            
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a socket permission to add
                if (m_dg[i, 0] != DBNull.Value && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sHostname = (String)m_dg[i, 0];
                    int    nPort=0;     
                    if (m_dg[i, 1] != DBNull.Value && ((String)m_dg[i, 1]).Length > 0)
                    {
                        try
                        {
                            nPort = Int32.Parse((String)m_dg[i, 1]);
                            // Verify the port is valid... note, this is the same logic that
                            // SocketPermission uses
                            
                            if ((nPort >= UInt16.MaxValue || nPort < 0) && nPort != SocketPermission.AllPorts)
                                throw new Exception();                

                        }
                        catch(Exception)
                        {
                        
                            MessageBox(String.Format(CResourceStore.GetString("SocketPerm:isbadport"), m_dg[i, 1]),
                                       CResourceStore.GetString("SocketPerm:isbadportTitle"),
                                       MB.ICONEXCLAMATION);
                            return null;                                    
                        }
                    }
                    else
                    {
                        MessageBox(CResourceStore.GetString("SocketPerm:NeedPort"),
                                   CResourceStore.GetString("SocketPerm:NeedPortTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;
                    }

                    TransportType tt = 0;
                    
                    if ((bool)m_dg[i, 3])
                        tt |= TransportType.Tcp;
                    if ((bool)m_dg[i, 4])
                        tt |= TransportType.Udp;
                
                    NetworkAccess na;
                    if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("SocketPermission:Accept")))
                        na = NetworkAccess.Accept;
                    else
                        na = NetworkAccess.Connect;

                    perm.AddPermission(na, tt, sHostname, nPort);        
                }
                else
                {
                    // Check to see if they filled out any other fields without filling out
                    // the site field
                    if ((m_dg[i, 1] != DBNull.Value && ((String)m_dg[i, 1]).Length > 0) ||
                        (bool)m_dg[i, 3] || (bool)m_dg[i, 3])
                    {
                        MessageBox(CResourceStore.GetString("SocketPerm:NeedSite"),
                                   CResourceStore.GetString("SocketPerm:NeedSiteTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;
                    }

                }
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        for(int i=3; i<5; i++)
            if (m_dg[iSelRow, i] == DBNull.Value)
                m_dg[iSelRow, i]=false;

        if (m_dg[iSelRow, 2] == DBNull.Value)
            m_dg[iSelRow, 2] = CResourceStore.GetString("SocketPermission:Accept");
                
        ActivateApply();
      
    }// onClick
}// class CEnvPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\servicecontrollerperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.ComponentModel;
using System.ServiceProcess;

internal class CServiceControllerPermDialog: CPermDialog
{
    internal CServiceControllerPermDialog(ServiceControllerPermission perm)
    {
        this.Text = CResourceStore.GetString("PerformanceCounterPerm:PermName");
        m_PermControls = new CServiceControllerPermControls(perm, this);
        Init();        
    }// CServiceControllerPermDialog(SocketPermission)  
}// class CServiceControllerPermDialog

internal class CServiceControllerPermPropPage: CPermPropPage
{
    internal CServiceControllerPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("PerformanceCounterPerm:PermName"); 
    }// CPerformanceCounterPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(ServiceControllerPermission));
        m_PermControls = new CServiceControllerPermControls(perm, this);
    }// CreateControls

    
}// class CServiceControllerPermPropPage


internal class CServiceControllerPermControls : CTablePermControls
{
    internal CServiceControllerPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new ServiceControllerPermission(PermissionState.None);
    }// CServiceControllerPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Machine Name" Column
        DataColumn dcMachine = new DataColumn();
        dcMachine.ColumnName = "Machine";
        dcMachine.DataType = typeof(String);
        dt.Columns.Add(dcMachine);

        // Create the "Service" Column
        DataColumn dcService = new DataColumn();
        dcService.ColumnName = "Service";
        dcService.DataType = typeof(String);
        dt.Columns.Add(dcService);

        // Create the "Access" Column
        DataColumn dcAccess = new DataColumn();
        dcAccess.ColumnName = "Access";
        dcAccess.DataType = typeof(String);
        dt.Columns.Add(dcAccess);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcMachine = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcService = new DataGridTextBoxColumn();
        DataGridComboBoxColumnStyle dgccAccess = new DataGridComboBoxColumnStyle();

        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Machine column
        dgtbcMachine.MappingName = "Machine";
        dgtbcMachine.HeaderText = CResourceStore.GetString("ServiceControllerPermission:Machine");
        dgtbcMachine.Width = ScaleWidth(CResourceStore.GetInt("ServiceControllerPerm:MachineColumnWidth"));
        dgtbcMachine.NullText = "";
        dgtbcMachine.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcMachine);

        // Set up the column info for the Service column
        dgtbcService.MappingName = "Service";
        dgtbcService.HeaderText = CResourceStore.GetString("ServiceControllerPermission:Service");
        dgtbcService.NullText = "";
        dgtbcService.Width = ScaleWidth(CResourceStore.GetInt("ServiceControllerPerm:ServiceColumnWidth"));
        dgtbcService.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcService);

        // Set up the column info for the Access column
        dgccAccess.MappingName = "Access";
        dgccAccess.HeaderText = CResourceStore.GetString("ServiceControllerPermission:Access");
        dgccAccess.Width = ScaleWidth(CResourceStore.GetInt("ServiceControllerPerm:AccessColumnWidth"));
        dgccAccess.DataSource = new DataGridComboBoxEntry[] {  
                                                new DataGridComboBoxEntry(CResourceStore.GetString("ServiceControllerPermission:Control")), 
                                                new DataGridComboBoxEntry(CResourceStore.GetString("ServiceControllerPermission:Browse")),
                                                new DataGridComboBoxEntry(CResourceStore.GetString("None")),
                                                };
        dgccAccess.ComboBox.SelectedIndexChanged +=new EventHandler(onChange);



        dgts.GridColumnStyles.Add(dgccAccess);
        
        return dt;
    }// CreateDataTable

    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("ServiceControllerPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("ServiceControllerPerm:GrantFollowing");

        ServiceControllerPermission perm = (ServiceControllerPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            IEnumerator enumer = perm.PermissionEntries.GetEnumerator();
            while (enumer.MoveNext())
            {
                ServiceControllerPermissionEntry scpe = (ServiceControllerPermissionEntry)enumer.Current;
                DataRow newRow;
                newRow = m_dt.NewRow();

                newRow["Machine"]=scpe.MachineName;
                newRow["Service"]=scpe.ServiceName;

                // Determine the Access String
                String sAccess;
                if ((scpe.PermissionAccess&ServiceControllerPermissionAccess.Control) == ServiceControllerPermissionAccess.Control)
                    sAccess = CResourceStore.GetString("ServiceControllerPermission:Control");
                else if ((scpe.PermissionAccess&ServiceControllerPermissionAccess.Browse) == ServiceControllerPermissionAccess.Browse)
                    sAccess = CResourceStore.GetString("ServiceControllerPermission:Browse");
                else 
                    sAccess = CResourceStore.GetString("None");
                    
                newRow["Access"] = new DataGridComboBoxEntry(sAccess);
                m_dt.Rows.Add(newRow);
            }
          
        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Machine"]="";
        newRow["Service"]="";
        newRow["Access"]=CResourceStore.GetString("None");
           
        dt.Rows.Add(newRow);
    }// AddEmptyRow

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
    
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        ServiceControllerPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new ServiceControllerPermission(PermissionState.Unrestricted);
        else
        {
            perm = new ServiceControllerPermission(PermissionState.None);
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a socket permission to add
                if (m_dg[i, 0] != DBNull.Value && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sName = (String)m_dg[i, 0];
                    if (m_dg[i, 1] == DBNull.Value || ((String)m_dg[i, 1]).Length == 0)
                    {
                        MessageBox(CResourceStore.GetString("ServiceControllerPerm:NeedService"),
                                   CResourceStore.GetString("ServiceControllerPerm:NeedServiceTitle"),
                                   MB.ICONEXCLAMATION);
                        return null;
                    }


                    String sService = (String)m_dg[i, 1];
                    
                    ServiceControllerPermissionAccess scpa = ServiceControllerPermissionAccess.None;
                    
                    if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("ServiceControllerPermission:Control")))
                        scpa = ServiceControllerPermissionAccess.Control;

                    else if (((String)m_dg[i,2]).Equals(CResourceStore.GetString("ServiceControllerPermission:Browse")))
                        scpa = ServiceControllerPermissionAccess.Browse;

                    perm.PermissionEntries.Add(new ServiceControllerPermissionEntry(scpa, sName, sService));        
                }
                else if (m_dg[i, 1] != DBNull.Value && ((String)m_dg[i, 1]).Length > 0)
                {
                    MessageBox(CResourceStore.GetString("ServiceControllerPerm:NeedMachineName"),
                               CResourceStore.GetString("ServiceControllerPerm:NeedMachineNameTitle"),
                               MB.ICONEXCLAMATION);
                    return null;

                }

               
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
        int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the combo box
        if (m_dg[iSelRow, 2] == DBNull.Value)
                m_dg[iSelRow, 2] = CResourceStore.GetString("None");

        ActivateApply();
    }// onClick
}// class CServiceControllerPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\uiperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;

internal class CUIPermDialog: CPermDialog
{
    internal CUIPermDialog(UIPermission perm)
    {
        this.Text = CResourceStore.GetString("Uiperm:PermName");
        m_PermControls = new CUIPermControls(perm, this);
        Init();        
    }// CUIPermDialog(UIPermission)  

 }// class CUIPermDialog

internal class CUIPermPropPage: CPermPropPage
{
    internal CUIPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("Uiperm:PermName"); 
    }// CUIPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(UIPermission));
        m_PermControls = new CUIPermControls(perm, this);
    }// CreateControls
    
}// class CUIPermPropPage


internal class CUIPermControls : CPermControls
{
    // Controls on the page
    private ComboBox m_cbWindowOptions;
    private Label m_lblWindowOptionDescription;
    private ComboBox m_cbClipboardOptions;
    private Label m_lblClipboard;
    private Label m_lblWindowing;
    private Label m_lblClipboardOptionDescription;

    internal CUIPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new UIPermission(PermissionState.None);
    }// CUIPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CUIPermControls));
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_cbWindowOptions = new System.Windows.Forms.ComboBox();
        this.m_lblWindowOptionDescription = new System.Windows.Forms.Label();
        this.m_cbClipboardOptions = new System.Windows.Forms.ComboBox();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_lblClipboard = new System.Windows.Forms.Label();
        this.m_lblWindowing = new System.Windows.Forms.Label();
        this.m_lblClipboardOptionDescription = new System.Windows.Forms.Label();
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_cbWindowOptions.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbWindowOptions.DropDownWidth = 272;
        this.m_cbWindowOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_cbWindowOptions.Location")));
        this.m_cbWindowOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_cbWindowOptions.Size")));
        this.m_cbWindowOptions.TabIndex = ((int)(resources.GetObject("m_cbWindowOptions.TabIndex")));
        m_cbWindowOptions.Name = "WindowOptions";
        this.m_lblWindowOptionDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblWindowOptionDescription.Location")));
        this.m_lblWindowOptionDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblWindowOptionDescription.Size")));
        this.m_lblWindowOptionDescription.TabIndex = ((int)(resources.GetObject("m_lblWindowOptionDescription.TabIndex")));
        m_lblWindowOptionDescription.Name = "WindowOptionDescription";
        this.m_cbClipboardOptions.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbClipboardOptions.DropDownWidth = 264;
        this.m_cbClipboardOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_cbClipboardOptions.Location")));
        this.m_cbClipboardOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_cbClipboardOptions.Size")));
        this.m_cbClipboardOptions.TabIndex = ((int)(resources.GetObject("m_cbClipboardOptions.TabIndex")));
        m_cbClipboardOptions.Name = "ClipboardOptions";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblWindowing,
                        this.m_cbWindowOptions,
                        this.m_lblWindowOptionDescription,
                        this.m_lblClipboard,
                        this.m_cbClipboardOptions,
                        this.m_lblClipboardOptionDescription
                        });
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        this.m_lblClipboard.Location = ((System.Drawing.Point)(resources.GetObject("m_lblClipboard.Location")));
        this.m_lblClipboard.Size = ((System.Drawing.Size)(resources.GetObject("m_lblClipboard.Size")));
        this.m_lblClipboard.TabIndex = ((int)(resources.GetObject("m_lblClipboard.TabIndex")));
        this.m_lblClipboard.Text = resources.GetString("m_lblClipboard.Text");
        m_lblClipboard.Name = "ClipboardLabel";
        this.m_lblWindowing.Location = ((System.Drawing.Point)(resources.GetObject("m_lblWindowing.Location")));
        this.m_lblWindowing.Size = ((System.Drawing.Size)(resources.GetObject("m_lblWindowing.Size")));
        this.m_lblWindowing.TabIndex = ((int)(resources.GetObject("m_lblWindowing.TabIndex")));
        this.m_lblWindowing.Text = resources.GetString("m_lblWindowing.Text");
        m_lblWindowing.Name = "WindowingLabel";
        this.m_lblClipboardOptionDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblClipboardOptionDescription.Location")));
        this.m_lblClipboardOptionDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblClipboardOptionDescription.Size")));
        this.m_lblClipboardOptionDescription.TabIndex = ((int)(resources.GetObject("m_lblClipboardOptionDescription.TabIndex")));
        m_lblClipboardOptionDescription.Name = "ClipboardOptionDescription";
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted
                        });

        // Fill in the data
        PutValuesinPage();
        
        // Hook up some event handlers
        m_cbWindowOptions.SelectedIndexChanged += new EventHandler(onChangeWindowOption);
        m_cbClipboardOptions.SelectedIndexChanged += new EventHandler(onChangeClipboardOption);
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);


        return 1;
    }// InsertPropSheetPageControls


    void onChangeWindowOption(Object o, EventArgs e)
    {
        if (m_cbWindowOptions.SelectedIndex == 0)
            m_lblWindowOptionDescription.Text = CResourceStore.GetString("Uiperm:AllWinDes");
        else if (m_cbWindowOptions.SelectedIndex == 1)
            m_lblWindowOptionDescription.Text = CResourceStore.GetString("Uiperm:SafeTopDes");
        else if (m_cbWindowOptions.SelectedIndex == 2)
            m_lblWindowOptionDescription.Text = CResourceStore.GetString("Uiperm:SafeSubDes");
        else if (m_cbWindowOptions.SelectedIndex == 3)
            m_lblWindowOptionDescription.Text = CResourceStore.GetString("Uiperm:NoWinDes");
        else 
            m_lblWindowOptionDescription.Text = "";
    
        ActivateApply();

    }// onChangeWindowOption

    void onChangeClipboardOption(Object o, EventArgs e)
    {
        if (m_cbClipboardOptions.SelectedIndex == 0)
            m_lblClipboardOptionDescription.Text = CResourceStore.GetString("Uiperm:AllClipDes");
        else if (m_cbClipboardOptions.SelectedIndex == 1)
            m_lblClipboardOptionDescription.Text = CResourceStore.GetString("Uiperm:PasteSameAppDomainDes");
        else if (m_cbClipboardOptions.SelectedIndex == 2)
            m_lblClipboardOptionDescription.Text = CResourceStore.GetString("Uiperm:NoClipDes");
        else 
            m_lblClipboardOptionDescription.Text = "";
    
        ActivateApply();

    }// onChangeClipboardOption

    protected override void PutValuesinPage()
    {
        m_cbWindowOptions.Items.Clear();
        m_cbWindowOptions.Items.Add(CResourceStore.GetString("UIPermission:Allwindows"));
        m_cbWindowOptions.Items.Add(CResourceStore.GetString("UIPermission:Safetopwindows"));
        m_cbWindowOptions.Items.Add(CResourceStore.GetString("UIPermission:safesubwindows"));
        m_cbWindowOptions.Items.Add(CResourceStore.GetString("UIPermission:Nowindows"));
    
        m_cbClipboardOptions.Items.Clear();
        m_cbClipboardOptions.Items.Add(CResourceStore.GetString("UIPermission:Allclipboard"));
        m_cbClipboardOptions.Items.Add(CResourceStore.GetString("UIPermission:pastingfromsamedomain"));
        m_cbClipboardOptions.Items.Add(CResourceStore.GetString("UIPermission:Noclipboard"));
        
        int nWindowPerm = 3;
        int nClipboardPerm = 2;

        UIPermission perm = (UIPermission)m_perm;

        if (perm.IsUnrestricted())
        {
            m_radUnrestricted.Checked=true;
            m_ucOptions.Enabled = false;
            nWindowPerm=0;
            nClipboardPerm=0;
        }
        else
        {
            m_radGrantFollowingPermission.Checked=true;

            // First get the Windowing Permission
            if (perm.Window == UIPermissionWindow.AllWindows)
                nWindowPerm=0;
            else if (perm.Window == UIPermissionWindow.SafeSubWindows)
                nWindowPerm=1;
            else if (perm.Window == UIPermissionWindow.SafeTopLevelWindows)
                nWindowPerm=2;
            else if (perm.Window == UIPermissionWindow.NoWindows)
                nWindowPerm=3;

            // Now get the Clipboard permission
            if (perm.Clipboard == UIPermissionClipboard.AllClipboard)
                nClipboardPerm=0;
            else if (perm.Clipboard == UIPermissionClipboard.OwnClipboard)
                nClipboardPerm=1;
            else if (perm.Clipboard == UIPermissionClipboard.NoClipboard)
                nClipboardPerm=2;
        }
        m_cbWindowOptions.SelectedIndex = nWindowPerm;
        m_cbClipboardOptions.SelectedIndex = nClipboardPerm;
        onChangeWindowOption(null, null);
        onChangeClipboardOption(null, null);
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        UIPermission uiperm;
        if (m_radUnrestricted.Checked == true)
            uiperm = new UIPermission(PermissionState.Unrestricted);
        else
        {

            UIPermissionWindow uipw;
            if (m_cbWindowOptions.SelectedIndex == 0)
                uipw = UIPermissionWindow.AllWindows;
            else if (m_cbWindowOptions.SelectedIndex == 1)
                uipw = UIPermissionWindow.SafeTopLevelWindows;
            else if (m_cbWindowOptions.SelectedIndex == 2)
                uipw = UIPermissionWindow.SafeSubWindows;
            else 
                uipw = UIPermissionWindow.NoWindows;

            // Now set the Clipboard permission
            UIPermissionClipboard uipc;
            if (m_cbClipboardOptions.SelectedIndex == 0)
                uipc = UIPermissionClipboard.AllClipboard;
            else if (m_cbClipboardOptions.SelectedIndex == 1)
                uipc = UIPermissionClipboard.OwnClipboard;
            else
                uipc = UIPermissionClipboard.NoClipboard;


            uiperm = new UIPermission(uipw, uipc);
        }
        return uiperm;
    }// GetCurrentPermissions
}// class CUIPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\sqlclientperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Net;
using System.Data.SqlClient;

internal class CSQLClientPermDialog: CPermDialog
{
    internal CSQLClientPermDialog(SqlClientPermission perm)
    {
        this.Text = CResourceStore.GetString("SQLClientPerm:PermName");
        m_PermControls = new CSQLClientPermControls(perm, this);
        Init();        
    }// CSQLClientPermDialog(DnsPermission)  
 }// class CSQLClientPermDialog

internal class CSQLClientPermPropPage: CPermPropPage
{
    internal CSQLClientPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("SQLClientPerm:PermName"); 
    }// CSQLClientPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(SqlClientPermission));
        m_PermControls = new CSQLClientPermControls(perm, this);
    }// CreateControls

    
}// class CSQLClientPermPropPage


internal class CSQLClientPermControls : CPermControls
{
    // Controls on the page
    private CheckBox m_chkAllowBlankPasswords;
    private Label m_lblHelp;

    internal CSQLClientPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new SqlClientPermission(PermissionState.None);
    }// CSQLClientPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSQLClientPermControls));
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_chkAllowBlankPasswords = new System.Windows.Forms.CheckBox();
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_chkAllowBlankPasswords});
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_chkAllowBlankPasswords.Location = ((System.Drawing.Point)(resources.GetObject("m_chkAllowBlankPasswords.Location")));
        this.m_chkAllowBlankPasswords.Size = ((System.Drawing.Size)(resources.GetObject("m_chkAllowBlankPasswords.Size")));
        this.m_chkAllowBlankPasswords.TabIndex = ((int)(resources.GetObject("m_chkAllowBlankPasswords.TabIndex")));
        this.m_chkAllowBlankPasswords.Text = resources.GetString("m_chkAllowBlankPasswords.Text");
        m_chkAllowBlankPasswords.Name = "AllowBlankPasswords";
        cc.AddRange(new System.Windows.Forms.Control[] {this.m_lblHelp,
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted
                        });

        // Fill in the data
        PutValuesinPage();

        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_chkAllowBlankPasswords.CheckedChanged += new EventHandler(onChange);

        
        return 1;
    }// InsertPropSheetPageControls


    protected override void PutValuesinPage()
    {
        SqlClientPermission perm = (SqlClientPermission)m_perm;
    
        if (perm.IsUnrestricted())
            m_radUnrestricted.Checked=true;
        else
        {
            m_radGrantFollowingPermission.Checked=true;
            m_chkAllowBlankPasswords.Checked = perm.AllowBlankPassword;
        }
        onChangeUnRestrict(null, null);
    }// PutValuesinPage


    internal override IPermission GetCurrentPermission()
    {
        SqlClientPermission perm;
        if (m_radUnrestricted.Checked == true)
            perm = new SqlClientPermission(PermissionState.Unrestricted);
        else
            perm = new SqlClientPermission(PermissionState.None);

        return perm;
    }// GetCurrentPermissions

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
  
}// class CSQLClientPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\secperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;

internal class CSecPermDialog: CPermDialog
{
    internal CSecPermDialog(SecurityPermission perm)
    {
        this.Text = CResourceStore.GetString("Secperm:PermName");
        m_PermControls = new CSecPermControls(perm, this);
        Init();        
    }// CSecPermDialog  
}// class CSecPermDialog

internal class CSecPermPropPage: CPermPropPage
{
    internal CSecPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("Secperm:PermName"); 
    }// CSecPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(SecurityPermission));
        m_PermControls = new CSecPermControls(perm, this);
    }// CreateControls
   
}// class CSecPermPropPage


internal class CSecPermControls : CPermControls
{
    // Controls on the page
    private CheckBox m_chkPrincipalControl;
    private CheckBox m_chkDomainPolicyControl;
    private CheckBox m_chkEvidenceControl;
    private CheckBox m_chkSkipVerification;
    private CheckBox m_chkUnmanagedCode;
    private CheckBox m_chkCodeExecution;
    private CheckBox m_chkThreadControl;
    private CheckBox m_chkSerializationFormatter;
    private CheckBox m_chkPolicyControl;
    private CheckBox m_chkAssertPermissions;
    private CheckBox m_chkExtendInfra;
    private CheckBox m_chkRemotingConfig;
    private CheckBox m_chkAppDomainControl;
        

    internal CSecPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new SecurityPermission(PermissionState.None);
    }// CSecPermControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CSecPermControls));
        this.m_chkPrincipalControl = new System.Windows.Forms.CheckBox();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_chkDomainPolicyControl = new System.Windows.Forms.CheckBox();
        this.m_chkEvidenceControl = new System.Windows.Forms.CheckBox();
        this.m_chkSkipVerification = new System.Windows.Forms.CheckBox();
        this.m_chkUnmanagedCode = new System.Windows.Forms.CheckBox();
        this.m_chkCodeExecution = new System.Windows.Forms.CheckBox();
        this.m_chkThreadControl = new System.Windows.Forms.CheckBox();
        this.m_chkSerializationFormatter = new System.Windows.Forms.CheckBox();
        this.m_chkPolicyControl = new System.Windows.Forms.CheckBox();
        this.m_chkAssertPermissions = new System.Windows.Forms.CheckBox();
        this.m_chkExtendInfra = new System.Windows.Forms.CheckBox();
        this.m_chkRemotingConfig = new System.Windows.Forms.CheckBox();
        m_chkAppDomainControl = new System.Windows.Forms.CheckBox();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        
        this.m_chkPrincipalControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkPrincipalControl.Location")));
        this.m_chkPrincipalControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkPrincipalControl.Size")));
        this.m_chkPrincipalControl.TabIndex = ((int)(resources.GetObject("m_chkPrincipalControl.TabIndex")));
        this.m_chkPrincipalControl.Text = resources.GetString("m_chkPrincipalControl.Text");
        m_chkPrincipalControl.Name = "PrincipalControl";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        this.m_radGrantFollowingPermission.Text = resources.GetString("m_radGrantPermissions.Text");
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        this.m_radUnrestricted.Text = resources.GetString("m_radUnrestricted.Text");
        m_radUnrestricted.Name = "Unrestricted";
        this.m_chkDomainPolicyControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkDomainPolicyControl.Location")));
        this.m_chkDomainPolicyControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkDomainPolicyControl.Size")));
        this.m_chkDomainPolicyControl.TabIndex = ((int)(resources.GetObject("m_chkDomainPolicyControl.TabIndex")));
        this.m_chkDomainPolicyControl.Text = resources.GetString("m_chkDomainPolicyControl.Text");
        m_chkDomainPolicyControl.Name = "DomainPolicyControl";
        this.m_chkEvidenceControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkEvidenceControl.Location")));
        this.m_chkEvidenceControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkEvidenceControl.Size")));
        this.m_chkEvidenceControl.TabIndex = ((int)(resources.GetObject("m_chkEvidenceControl.TabIndex")));
        this.m_chkEvidenceControl.Text = resources.GetString("m_chkEvidenceControl.Text");
        m_chkEvidenceControl.Name = "EvidenceControl";
        this.m_chkSkipVerification.Location = ((System.Drawing.Point)(resources.GetObject("m_chkSkipVerification.Location")));
        this.m_chkSkipVerification.Size = ((System.Drawing.Size)(resources.GetObject("m_chkSkipVerification.Size")));
        this.m_chkSkipVerification.TabIndex = ((int)(resources.GetObject("m_chkSkipVerification.TabIndex")));
        this.m_chkSkipVerification.Text = resources.GetString("m_chkSkipVerification.Text");
        m_chkSkipVerification.Name = "SkipVerification";
        this.m_chkUnmanagedCode.Location = ((System.Drawing.Point)(resources.GetObject("m_chkUnmanagedCode.Location")));
        this.m_chkUnmanagedCode.Size = ((System.Drawing.Size)(resources.GetObject("m_chkUnmanagedCode.Size")));
        this.m_chkUnmanagedCode.TabIndex = ((int)(resources.GetObject("m_chkUnmanagedCode.TabIndex")));
        this.m_chkUnmanagedCode.Text = resources.GetString("m_chkUnmanagedCode.Text");
        m_chkUnmanagedCode.Name = "UnmanagedCode";
        this.m_chkCodeExecution.Location = ((System.Drawing.Point)(resources.GetObject("m_chkCodeExecution.Location")));
        this.m_chkCodeExecution.Size = ((System.Drawing.Size)(resources.GetObject("m_chkCodeExecution.Size")));
        this.m_chkCodeExecution.TabIndex = ((int)(resources.GetObject("m_chkCodeExecution.TabIndex")));
        this.m_chkCodeExecution.Text = resources.GetString("m_chkCodeExecution.Text");
        m_chkCodeExecution.Name = "CodeExecution";
        this.m_chkThreadControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkThreadControl.Location")));
        this.m_chkThreadControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkThreadControl.Size")));
        this.m_chkThreadControl.TabIndex = ((int)(resources.GetObject("m_chkThreadControl.TabIndex")));
        this.m_chkThreadControl.Text = resources.GetString("m_chkThreadControl.Text");
        m_chkThreadControl.Name = "ThreadControl";
        this.m_chkSerializationFormatter.Location = ((System.Drawing.Point)(resources.GetObject("m_chkSerializationFormatter.Location")));
        this.m_chkSerializationFormatter.Size = ((System.Drawing.Size)(resources.GetObject("m_chkSerializationFormatter.Size")));
        this.m_chkSerializationFormatter.TabIndex = ((int)(resources.GetObject("m_chkSerializationFormatter.TabIndex")));
        this.m_chkSerializationFormatter.Text = resources.GetString("m_chkSerializationFormatter.Text");
        m_chkSerializationFormatter.Name = "SerializationFormatter";
        this.m_chkPolicyControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkPolicyControl.Location")));
        this.m_chkPolicyControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkPolicyControl.Size")));
        this.m_chkPolicyControl.TabIndex = ((int)(resources.GetObject("m_chkPolicyControl.TabIndex")));
        this.m_chkPolicyControl.Text = resources.GetString("m_chkPolicyControl.Text");
        m_chkPolicyControl.Name = "PolicyControl";
        this.m_chkAssertPermissions.Location = ((System.Drawing.Point)(resources.GetObject("m_chkAssertPermissions.Location")));
        this.m_chkAssertPermissions.Size = ((System.Drawing.Size)(resources.GetObject("m_chkAssertPermissions.Size")));
        this.m_chkAssertPermissions.TabIndex = ((int)(resources.GetObject("m_chkAssertPermissions.TabIndex")));
        this.m_chkAssertPermissions.Text = resources.GetString("m_chkAssertPermissions.Text");
        m_chkAssertPermissions.Name = "AssertPermissions";
        // 
        // m_chkExtendInfra
        // 
        this.m_chkExtendInfra.Location = ((System.Drawing.Point)(resources.GetObject("m_chkExtendInfra.Location")));
        this.m_chkExtendInfra.Name = "ExtendInfra";
        this.m_chkExtendInfra.Size = ((System.Drawing.Size)(resources.GetObject("m_chkExtendInfra.Size")));
        this.m_chkExtendInfra.TabIndex = ((int)(resources.GetObject("m_chkExtendInfra.TabIndex")));
        this.m_chkExtendInfra.Text = resources.GetString("m_chkExtendInfra.Text");
        this.m_chkExtendInfra.Visible = ((bool)(resources.GetObject("m_chkExtendInfra.Visible")));
        // 
        // m_chkRemotingConfig
        // 
        this.m_chkRemotingConfig.Location = ((System.Drawing.Point)(resources.GetObject("m_chkRemotingConfig.Location")));
        this.m_chkRemotingConfig.Name = "RemotingConfig";
        this.m_chkRemotingConfig.Size = ((System.Drawing.Size)(resources.GetObject("m_chkRemotingConfig.Size")));
        this.m_chkRemotingConfig.TabIndex = ((int)(resources.GetObject("m_chkRemotingConfig.TabIndex")));
        this.m_chkRemotingConfig.Text = resources.GetString("m_chkRemotingConfig.Text");
        this.m_chkRemotingConfig.Visible = ((bool)(resources.GetObject("m_chkRemotingConfig.Visible")));

        // 
        // m_chkAppDomainControl
        // 
        this.m_chkAppDomainControl.Location = ((System.Drawing.Point)(resources.GetObject("m_chkAppDomainControl.Location")));
        this.m_chkAppDomainControl.Name = "AppDomainControl";
        this.m_chkAppDomainControl.Size = ((System.Drawing.Size)(resources.GetObject("m_chkAppDomainControl.Size")));
        this.m_chkAppDomainControl.Text = resources.GetString("m_chkAppDomainControl.Text");



        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_chkCodeExecution,
                        this.m_chkUnmanagedCode,
                        this.m_chkAssertPermissions,
                        this.m_chkSkipVerification,
                        this.m_chkThreadControl,
                        this.m_chkPolicyControl,
                        this.m_chkDomainPolicyControl,
                        this.m_chkPrincipalControl,
                        m_chkAppDomainControl,
                        this.m_chkSerializationFormatter,
                        this.m_chkEvidenceControl,
                        m_chkExtendInfra,
                        m_chkRemotingConfig
                        });
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabStop = false;
        m_ucOptions.Name = "Options";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted
                        });
    
        // Fill in the data
        PutValuesinPage();

        // Hook up event handlers        

        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_chkCodeExecution.CheckStateChanged += new EventHandler(onChange);
        m_chkUnmanagedCode.CheckStateChanged += new EventHandler(onChange);
        m_chkAssertPermissions.CheckStateChanged += new EventHandler(onChange);
        m_chkSkipVerification.CheckStateChanged += new EventHandler(onChange);
        m_chkThreadControl.CheckStateChanged += new EventHandler(onChange);
        m_chkPolicyControl.CheckStateChanged += new EventHandler(onChange);
        m_chkDomainPolicyControl.CheckStateChanged += new EventHandler(onChange);
        m_chkPrincipalControl.CheckStateChanged += new EventHandler(onChange);
        m_chkSerializationFormatter.CheckStateChanged += new EventHandler(onChange);
        m_chkEvidenceControl.CheckStateChanged += new EventHandler(onChange);
        m_chkExtendInfra.CheckStateChanged += new EventHandler(onChange);
        m_chkRemotingConfig.CheckStateChanged += new EventHandler(onChange);
        m_chkAppDomainControl.CheckStateChanged += new EventHandler(onChange);

        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);

        return 1;
    }// InsertPropSheetPageControls


    protected override void PutValuesinPage()
    {
        SecurityPermission perm = (SecurityPermission)m_perm;
    
        if (perm.IsUnrestricted())
        {
            m_radUnrestricted.Checked=true;
            m_ucOptions.Enabled = false;

        }
        else
        {
            m_radGrantFollowingPermission.Checked=true;

            SecurityPermissionFlag spf = perm.Flags;
    
            if ((spf & SecurityPermissionFlag.Assertion) > 0)
                m_chkAssertPermissions.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlDomainPolicy) > 0)
                m_chkDomainPolicyControl.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlEvidence) > 0)
                m_chkEvidenceControl.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlPolicy) > 0)
                m_chkPolicyControl.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlPrincipal) > 0)
                m_chkPrincipalControl.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlThread) > 0)
                m_chkThreadControl.Checked=true;
            if ((spf & SecurityPermissionFlag.Execution) > 0)
                m_chkCodeExecution.Checked=true;
            if ((spf & SecurityPermissionFlag.SerializationFormatter) > 0)
                m_chkSerializationFormatter.Checked=true;
            if ((spf & SecurityPermissionFlag.SkipVerification) > 0)
                m_chkSkipVerification.Checked=true;
            if ((spf & SecurityPermissionFlag.UnmanagedCode) > 0)
                m_chkUnmanagedCode.Checked=true;
            if ((spf & SecurityPermissionFlag.Infrastructure) > 0)
                m_chkExtendInfra.Checked=true;
            if ((spf & SecurityPermissionFlag.RemotingConfiguration) > 0)
                m_chkRemotingConfig.Checked=true;
            if ((spf & SecurityPermissionFlag.ControlAppDomain ) > 0)
                m_chkAppDomainControl.Checked=true;
                

        }
    }// PutValuesinPage

    internal override IPermission GetCurrentPermission()
    {
        SecurityPermission secperm;
        if (m_radUnrestricted.Checked == true)
            secperm = new SecurityPermission(PermissionState.Unrestricted);
        else
        {
            m_radGrantFollowingPermission.Checked = true;
        
            SecurityPermissionFlag spf = SecurityPermissionFlag.NoFlags;

            if (m_chkAssertPermissions.Checked == true)
                spf|=SecurityPermissionFlag.Assertion;
            if (m_chkDomainPolicyControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlDomainPolicy;
            if (m_chkEvidenceControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlEvidence;
            if (m_chkPolicyControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlPolicy;
            if (m_chkPrincipalControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlPrincipal;
            if (m_chkThreadControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlThread;
            if (m_chkCodeExecution.Checked == true)
                spf|=SecurityPermissionFlag.Execution;
            if (m_chkSerializationFormatter.Checked == true)
                spf|=SecurityPermissionFlag.SerializationFormatter;
            if (m_chkSkipVerification.Checked == true)
                spf|=SecurityPermissionFlag.SkipVerification;
            if (m_chkUnmanagedCode.Checked == true)
                spf|=SecurityPermissionFlag.UnmanagedCode;
            if (m_chkExtendInfra.Checked == true)
                spf|=SecurityPermissionFlag.Infrastructure;
            if (m_chkRemotingConfig.Checked == true)
                spf|=SecurityPermissionFlag.RemotingConfiguration;
            if (m_chkAppDomainControl.Checked == true)
                spf|=SecurityPermissionFlag.ControlAppDomain;
                


            secperm = new SecurityPermission(spf);
        }

        return secperm;
    }// GetCurrentPermission

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CSecPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\securityfunctions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{

using System;
using System.Security;
using System.Security.Permissions;
using System.Security.Policy;
using System.Collections;
using System.Net;
using System.Reflection;
using System.DirectoryServices;
using System.Diagnostics;
using System.Drawing.Printing;
using System.ServiceProcess;
using System.Data.SqlClient;
using System.Data.OleDb;
using System.Messaging;
using System.Runtime.InteropServices;

internal class PermissionSetType
{
    internal const int    NONE        = 0;
    internal const int    INTERNET    = 1;
    internal const int    INTRANET    = 2;
    internal const int    FULLTRUST   = 3;
    internal const int    UNKNOWN     = 4;
}// PermissionSetType   

internal class IndexPolicyException : PolicyException
{
    private int m_nIndex;
    
    internal IndexPolicyException(PolicyException pe) : base(pe.Message, pe)
    {
        m_nIndex = -1;
    }

    internal int Index
    {
        get{return m_nIndex;}
        set{m_nIndex = value;}
    }

}// IndexPolicyException

internal class SuperCodeGroupArrayList : ArrayList
{
    internal SuperCodeGroupArrayList() : base()
    {
    }// CodeGroupArrayList

    public new SuperCodeGroup this[int index]
    {
        get{return (SuperCodeGroup)(base[index]);}
    }

}// SuperCodeGroupArrayList
    

internal class SuperCodeGroup
{
    internal int              nParent;
    internal object           o;
    
    private CSingleCodeGroup  m_scg;
    private CodeGroup         m_cg;  
    private int               m_nChildNum;


    internal SuperCodeGroup(int nParent, Object cg, int nChildNum)
    {
        this.nParent = nParent;
        o = null;
        m_nChildNum = nChildNum;

        m_cg = cg as CodeGroup;
        m_scg = cg as CSingleCodeGroup;

        if (m_cg == null && m_scg == null)
            throw new ArgumentException();
    }// SuperCodegroup

    internal int ChildNum
    {
        get{return m_nChildNum;}
    }// ChildNum

    internal CSingleCodeGroup CodeGroupNode
    {
        get{return m_scg;}
    }// CodeGroupNode

    

    internal CodeGroup cg
    {
        get
        {
            if (m_cg != null)
                return m_cg;
            else
                return m_scg.MyCodeGroup;
        }
    }

    public override bool Equals(Object o)
    {
        if (m_cg != null)
            return m_cg.Equals(o);

        if (o is CSingleCodeGroup)
            return (m_scg == o);

        return base.Equals(o);
    }// Equals

    public override int GetHashCode()
    {
        if (m_cg != null)
            return m_cg.GetHashCode();

        if (m_scg != null)
            return m_scg.GetHashCode();
        return base.GetHashCode();
    }

    internal int NumChildren
    {
        get{
                if (m_scg != null)
                    return m_scg.NumChildren;
                else
                    return m_cg.Children.Count;
           }
    }

    internal Object GetChild(int index)
    {
        if (m_scg != null)
            return (CSingleCodeGroup)CNodeManager.GetNode(m_scg.Child[index]);
        else
            return m_cg.Children[index];
    }// Children

    
}// class SuperCodegroup


internal class Security
{
    private static CGenSecurity m_GenSecNode = null;

    internal static CGenSecurity GenSecurityNode
    {
        get{return m_GenSecNode;}
        set{m_GenSecNode = value;}
    }// GenSecurityNode

    internal static String ConvertPublicKeyToString(byte[] pubKey)
    {
        return ByteArrayToString(pubKey);
    }// ConvertPublicKeyToString

    private static String ByteArrayToString(Byte[] b)
    {
        String s = "";
        String sPart;
        if (b != null)
        {
            for(int i=0; i<b.Length; i++)
            {
                sPart = b[i].ToString("X");
                // If the byte was only one character in length, make sure we add
                // a zero. We want all bytes to be 2 characters long
                if (b[i] < 0x10)
                    sPart = "0" + sPart;
                
                s+=sPart;
            }
        }
        return s;
    }// ByteArrayToString

    internal static String FindAGoodCodeGroupName(PolicyLevel pl, String sBase)
    {
        int nNum = 0;
        SuperCodeGroupArrayList al; 
        ListifyPolicyLevel(pl, null, out al);

        while (DoesThisCodegroupExist(al, sBase + nNum.ToString(), null))
            nNum++;

        return sBase+nNum.ToString();
    }// FindAGoodCodeGroupName

    private static bool DoesThisCodegroupExist(SuperCodeGroupArrayList al, String s, CodeGroup cgExclude)
    {
        if (al == null || s == null || s.Length == 0)
            return false;

        for(int i=0; i<al.Count; i++)
        {
            if (!al[i].Equals(cgExclude) && al[i].cg.Name != null && al[i].cg.Name.Equals(s))
                return true;
        }
        return false;
    }// DoesThisCodegroupExist

    internal static PermissionSet CreatePermissionSetFromAllMachinePolicy(Evidence ev)
    {
        return CreatePermissionSetFromAllPolicy(ev,
                            new PolicyLevel[] {Security.GetMachinePolicyLevelFromLabel("Enterprise"),
                                               Security.GetMachinePolicyLevelFromLabel("Machine"),
                                               Security.GetMachinePolicyLevelFromLabel("User")});

    }

    internal static PermissionSet CreatePermissionSetFromAllLoadedPolicy(Evidence ev)
    {
        // If this never got set, we won't be able to use it.
        if (GenSecurityNode == null)
            return null;

        return CreatePermissionSetFromAllPolicy(ev,
                            new PolicyLevel[] {GenSecurityNode.EnterpriseNode.MyPolicyLevel,
                                               GenSecurityNode.MachineNode.MyPolicyLevel,
                                               GenSecurityNode.UserNode.MyPolicyLevel});

    }

    internal static PermissionSet CreatePermissionSetFromAllPolicy(Evidence ev, PolicyLevel[] polLevels)
    {
    
        PermissionSet permSet;
        int nIndex = 0;
        try
        {
            PolicyStatement polstate = polLevels[nIndex].Resolve(ev); 

            permSet = polstate.PermissionSet;

            for(nIndex=1; nIndex<polLevels.Length; nIndex++) 
            {
                if (permSet != null && (polstate.Attributes & PolicyStatementAttribute.LevelFinal) != PolicyStatementAttribute.LevelFinal)
                {
                    polstate = polLevels[nIndex].Resolve(ev); 
                    permSet = permSet.Intersect(polstate.PermissionSet);
                }
            }

            if (permSet == null)
                permSet = new PermissionSet(PermissionState.None);

            return permSet;
        }
        catch(PolicyException pe)
        {
            IndexPolicyException ipe = new IndexPolicyException(pe);
            ipe.Index = nIndex;
            throw ipe;
        }
    }// CreatePermissionSetFromAllPolicy


    internal static String BuildMCDisplayName(String sName)
    {
        String sOutString = sName;
        byte[] ab = new byte[16];
        StrongNameMembershipCondition snmc = new StrongNameMembershipCondition(
                        new StrongNamePublicKeyBlob(ab),null,null);
                                
        HashMembershipCondition hmc = new HashMembershipCondition( 
                        System.Security.Cryptography.HashAlgorithm.Create(), ab );
        
        String[] args = sName.Split(new char[] {' '});
        String[] argsSN = snmc.ToString().Split(new char[] {' '});
        String[] argsH = hmc.ToString().Split(new char[] {' '});
        if(args[0].Equals(argsSN[0]) || args[0].Equals(argsH[0])) sOutString = args[0];
        else if(args.Length == 3 && args[1].Equals("-")) sOutString = args[0] + ": " + args[2];
        
        return sOutString;

    }// BuildMCDisplayName

    internal static bool isCodeGroupNameUsed(CodeGroup cg, String sName)
    {
        if (sName == null || sName.Length == 0)
            return false;

        SuperCodeGroupArrayList al;
            
        ListifyCodeGroup(cg, null, out al);

        return DoesThisCodegroupExist(al, sName, null);
    }// isCodeGroupNameUsed

    internal static bool isCodeGroupNameUsed(CodeGroup cg, CodeGroup cgExclude)
    {
        if (cgExclude.Name == null || cgExclude.Name.Length == 0)
            return false;

        SuperCodeGroupArrayList al;

        ListifyCodeGroup(cg, null, out al);

        return DoesThisCodegroupExist(al, cgExclude.Name, cgExclude);
    }// isCodeGroupNameUsed

    internal static String FindAGoodPermissionSetName(PolicyLevel pl, String sBase)
    {
        int nNum = 0;

        while (isPermissionSetNameUsed(pl, sBase + nNum.ToString()))
            nNum++;

        return sBase+nNum.ToString();
    }// FindAGoodCodeGroupName


    internal static bool isPermissionSetNameUsed(PolicyLevel pl, String sName)
    {
        // Let's scrounge together a permission set enumerator
        IEnumerator permsetEnumerator = pl.NamedPermissionSets.GetEnumerator();
                  
        while (permsetEnumerator.MoveNext())
        {
            PermissionSet permSet = (PermissionSet)permsetEnumerator.Current;
            if (permSet is NamedPermissionSet)
                if (((NamedPermissionSet)permSet).Name.Equals(sName))
                    return true;
        }    
        // It's not any of these children
        return false;
    }// isCodeGroupNameUsed


    internal static IPermission[] CreatePermissionArray(PermissionSet permSet)
    {
        // Get the permissions
        ArrayList al = new ArrayList();
        
        IEnumerator permEnumerator = permSet.GetEnumerator();
        while (permEnumerator.MoveNext())
            al.Add(permEnumerator.Current);

        IPermission[] perms = new IPermission[al.Count];
        for(int i=0; i<al.Count; i++)
            perms[i] = (IPermission)al[i];

        return perms;
    }// CreatePermissionArray

    internal static String GetDisplayStringForPermission(IPermission perm)
    {
        String sDisplayName = null;

    	if (perm is DirectoryServicesPermission)
            sDisplayName = CResourceStore.GetString("Directory Services");
    
        else if (perm is DnsPermission)
            sDisplayName = CResourceStore.GetString("DNS");

        else if (perm is EventLogPermission)
            sDisplayName = CResourceStore.GetString("Event Log");

        else if (perm is EnvironmentPermission)
            sDisplayName = CResourceStore.GetString("Environment Variables");

        else if (perm is FileIOPermission)
            sDisplayName = CResourceStore.GetString("File & Folder");

        else if (perm is FileDialogPermission)
            sDisplayName = CResourceStore.GetString("File Dialog");

        else if (perm is IsolatedStorageFilePermission)
            sDisplayName = CResourceStore.GetString("Isolated Storage");

        else if (perm is MessageQueuePermission)
            sDisplayName = CResourceStore.GetString("Message Queue");

        else if (perm is SocketPermission)
            sDisplayName = CResourceStore.GetString("Socket Access");

        else if (perm is OleDbPermission)
            sDisplayName = CResourceStore.GetString("OLE DB");

        else if (perm is PerformanceCounterPermission)
            sDisplayName = CResourceStore.GetString("Performance Counter");

        else if (perm is PrintingPermission)
            sDisplayName = CResourceStore.GetString("Printing");

        else if (perm is RegistryPermission)
            sDisplayName = CResourceStore.GetString("Registry");

        else if (perm is ReflectionPermission)
            sDisplayName = CResourceStore.GetString("Reflection");

        else if (perm is SecurityPermission)
            sDisplayName = CResourceStore.GetString("Security");
            
        else if (perm is ServiceControllerPermission)
            sDisplayName = CResourceStore.GetString("Service Controller");
        
        else if (perm is SqlClientPermission)
            sDisplayName = CResourceStore.GetString("SQL Client");

        else if (perm is UIPermission)
            sDisplayName = CResourceStore.GetString("Windowing");

        else if (perm is WebPermission)
            sDisplayName = CResourceStore.GetString("Web Access");

        else
            sDisplayName = CResourceStore.GetString("CReadOnlyPermission:CustomPermission") 
            + " - " + perm.GetType().ToString();
            
        return sDisplayName;
    }// GetDisplayStringFromType

    internal static int FindCurrentPermissionSet(Evidence ev)
    {
        PermissionSet pSet = CreatePermissionSetFromAllLoadedPolicy(ev);
        return FindCurrentPermissionSet(ev, pSet);
    }// FindCurrentPermissionSet

    internal static int FindCurrentPermissionSet(Evidence ev, PolicyLevel[] pLevels)
    {
        PermissionSet pSet = CreatePermissionSetFromAllPolicy(ev, pLevels);
        return FindCurrentPermissionSet(ev, pSet);
    }// FindCurrentPermissionSet

    internal static int FindCurrentPermissionSet(Evidence ev, PermissionSet pSet)
    {
        // Ok, now let's see if the permission set that is currently granted matches
        // either Full Trust, Internet, Intranet, or none.

        if (pSet.IsEmpty())
            return PermissionSetType.NONE;

        if (pSet.IsUnrestricted())
            return PermissionSetType.FULLTRUST;

        // Let's grab the internet and intranet permission sets....
        PolicyLevel pl = GetPolicyLevelFromType(PolicyLevelType.Enterprise);
        PermissionSet psInternet = pl.GetNamedPermissionSet("Internet");
        PermissionSet psIntranet = pl.GetNamedPermissionSet("LocalIntranet");
                
        // In addition, the internet and intranet permission sets get additional
        // permissions that are normally provided by custom codegroups. We'll
        // create those codegroups and get the permissions of of those

        // Mess with the custom codegroups
        FileCodeGroup fcg = new FileCodeGroup(new AllMembershipCondition(), FileIOPermissionAccess.Read|FileIOPermissionAccess.PathDiscovery);
        NetCodeGroup ncg = new NetCodeGroup(new AllMembershipCondition());

        // The intranet permission set gets unioned with each of these...
        PermissionSet psss = fcg.Resolve(ev).PermissionSet;
        psIntranet = psIntranet.Union(psss);
        psIntranet = psIntranet.Union(ncg.Resolve(ev).PermissionSet);
        // The internet permission set just gets the net codegroup
        psInternet = psInternet.Union(ncg.Resolve(ev).PermissionSet);
      
        int nPermissionSet = PermissionSetType.UNKNOWN;

        // These 'IsSubsetOf' will throw exceptions if there are non-identical
        // regular expressions. 

        try
        {
            if (psIntranet != null && pSet.IsSubsetOf(psIntranet) && psIntranet.IsSubsetOf(pSet))
                nPermissionSet = PermissionSetType.INTRANET;
        }
        catch(Exception)
        {
        }

        // See if we should keep looking
        if (nPermissionSet == PermissionSetType.UNKNOWN)
        {

            try
            {
                // See if this is a Internet policy level
                if (psInternet != null && pSet.IsSubsetOf(psInternet) && psInternet.IsSubsetOf(pSet))
                    nPermissionSet = PermissionSetType.INTERNET;
            }
            catch(Exception)
            {
            }
        }
        return nPermissionSet;
    }// FindCurrentPermissionSet


    internal static PolicyLevel GetPolicyLevelFromType(PolicyLevelType plt)
    {
        String sLabel = null;
        switch(plt)
        {
            case PolicyLevelType.Enterprise:
                sLabel = "Enterprise";
                break;
            case PolicyLevelType.Machine:
                sLabel = "Machine";
                break;
            case PolicyLevelType.User:
                sLabel = "User";
                break;
            default:
                throw new Exception("I don't know about this type");
        }

        return GetPolicyLevelFromLabel(sLabel);
    }// GetPolicyLevelFromType

    internal static PolicyLevelType GetPolicyLevelTypeFromLabel(String sLabel)
    {   
        if (sLabel.Equals("Enterprise"))
            return PolicyLevelType.Enterprise;
        if (sLabel.Equals("Machine"))
            return PolicyLevelType.Machine;
        if (sLabel.Equals("User"))
            return PolicyLevelType.User;

        throw new Exception("I don't recognize the security policy label " + sLabel);

    }// GetPolicyLevelTypeFromLabel

    internal static PolicyLevel GetMachinePolicyLevelFromLabel( String label )
    {
        IEnumerator enumerator;

        PolicyLevel pl = null;        
        try
        {
            enumerator = SecurityManager.PolicyHierarchy();
        }
        catch (SecurityException)
        {
            throw new Exception("Insufficient rights to obtain policy level");
        }
                
        while (enumerator.MoveNext())
        {
            PolicyLevel level = (PolicyLevel)enumerator.Current;
            if (level.Label.Equals( label ))
            {
                pl = level;
                break;
            }
        }
                
        return pl;
    }// GetMachinePolicyLevelFromLabel   

    internal static CSingleCodeGroup GetRootCodeGroupNode(PolicyLevel pl)
    {
        return m_GenSecNode.GetSecurityPolicyNode(GetPolicyLevelTypeFromLabel(pl.Label)).GetRootCodeGroupNode();
    }// GetRootCodeGroupNode

    internal static PolicyLevel GetPolicyLevelFromLabel( String label )
    {
        return m_GenSecNode.GetSecurityPolicyNode(GetPolicyLevelTypeFromLabel(label)).MyPolicyLevel;
    }// GetPolicyLevelFromLabel   

    internal static int ListifyCodeGroup(Object cgBase, Object cgStop, out SuperCodeGroupArrayList scalFinal)
    {
        scalFinal = new SuperCodeGroupArrayList();
        SuperCodeGroupArrayList scalTemp = new SuperCodeGroupArrayList();

        if (cgBase == null)
            return -1;
            
        scalTemp.Add(new SuperCodeGroup(-1, cgBase, 0));

        while (scalTemp.Count > 0)
        {
            // Put this guy in the final one....
            int nMyIndex = scalFinal.Add(scalTemp[0]);
            // If this guy is the main codegroup we're interested in, let's stop now
            if (cgStop != null && scalTemp[0].Equals(cgStop))
                return nMyIndex;
                
            // Iterate through this guy's children
            for(int i=0; i< scalTemp[0].NumChildren; i++)
            {
                Object cg = scalTemp[0].GetChild(i);
                scalTemp.Add(new SuperCodeGroup(nMyIndex, cg, i));
            }
            // Now remove this guy from the list
            scalTemp.RemoveAt(0);
        }

        return -1;
    }// ListifyCodeGroup

    internal static int ListifyPolicyLevel(PolicyLevel pl, Object cgStop, out SuperCodeGroupArrayList al)
    {
        
        return ListifyCodeGroup(GetRootCodeGroupNode(pl), cgStop, out al);
    }// ListifyPolicyLevel

    // NOTE: If any changes are made to this function, check UpdateAllCodegroups to see
    // if the change applies there as well.
    internal static void UpdateCodegroup(PolicyLevel pl, CSingleCodeGroup cg)
    {
        // We don't want to do this recursively, so first let's listify this policy level
        SuperCodeGroupArrayList scal;

        int nIndex = ListifyPolicyLevel(pl, cg, out scal);
        
        // We need to find ourselves, remove ourselves from our parent, then add ourselves back in....
        if (nIndex == -1)
        {
            nIndex = 0;
            while (nIndex < scal.Count && !scal[nIndex].Equals(cg))
                nIndex ++;
        }
        
        if (nIndex == scal.Count)
        {
            // Ooops... we didn't find our codegroup
            throw new Exception("Couldn't find codegroup");
        }

        // Now we need to change every codegroup in the entire branch of the tree
        // until we hit the root code group
    
        while (scal[nIndex].nParent != -1)
        {
            RefreshCodeGroup(scal[scal[nIndex].nParent].CodeGroupNode);
            nIndex = scal[nIndex].nParent; 
        }

        // And finally, set the new Root Codegroup
        pl.RootCodeGroup = scal[nIndex].cg;
    }// UpdateCodegroup

    internal static void RemoveChildCodegroup(CSingleCodeGroup scgParent, CSingleCodeGroup scgChildToRemove)
    {
        // Ok, we need to remove all these children, and then add all but this codegroup back
        //
        // Why, because the security manager is lame and can't do a proper 'equals'
        // on codegroups, so we can't call RemoveChildCodegroup
        scgParent.MyCodeGroup.Children = new ArrayList();

        
        for(int i=0; i<scgParent.NumChildren; i++)
        {
            CSingleCodeGroup scg = (CSingleCodeGroup)CNodeManager.GetNode(scgParent.Child[i]);
            if (scg != scgChildToRemove)
                scgParent.MyCodeGroup.AddChild(scg.MyCodeGroup);
        }

    }// RemoveChildCodegroup

    private static void RefreshCodeGroup(CSingleCodeGroup scgParent)
    {
        // In order to keep a proper order to the codegroups, to refresh a certain
        // codegroup, we'll remove all child codegroups and add them all back in the 
        // proper order.

        scgParent.MyCodeGroup.Children = new ArrayList();
        
        for(int i=0; i<scgParent.NumChildren; i++)
        {
            CSingleCodeGroup scg = (CSingleCodeGroup)CNodeManager.GetNode(scgParent.Child[i]);
            scgParent.MyCodeGroup.AddChild(scg.MyCodeGroup);
        }

    }// RemoveChildCodegroup

    private static void RefreshCodeGroup(CodeGroup cgParent, CodeGroup cgChild, int nChildIndex)
    {
        CodeGroup cgParentCopy = cgParent.Copy();
        cgParent.Children = new ArrayList();

        for(int i=0; i<cgParentCopy.Children.Count; i++)
        {
            if (i != nChildIndex)
                cgParent.AddChild((CodeGroup)cgParentCopy.Children[i]);
            else
                cgParent.AddChild(cgChild);
        }
    }// RefreshCodegroup


    internal static bool DoesHitURLCodegroup(Evidence ev)
    {
        return DoesHitURLCodegroup(ev, 
                                    new PolicyLevel[] {GenSecurityNode.EnterpriseNode.MyPolicyLevel,
                                                       GenSecurityNode.MachineNode.MyPolicyLevel,
                                                       GenSecurityNode.UserNode.MyPolicyLevel});

    }// DoesHitURLCodegroup

    internal static bool DoesHitURLCodegroup(Evidence ev, PolicyLevel[] polLevels)
    {
        // We'll rip a lot of code out from the Evaluate Assembly Wizard to do this....
        for (int i=0; i< polLevels.Length; i++)
        {
            CodeGroup cg = polLevels[i].RootCodeGroup.ResolveMatchingCodeGroups(ev);
            if (DoesHitURLCodegroupHelp(cg))
                return true;
                
        }
        return false;
    }// DoesHitURLCodegroup

    private static bool DoesHitURLCodegroupHelp(CodeGroup cg)
    {
        // No codegroup....
        if (cg == null)
            return false;

        SuperCodeGroupArrayList scal;

        ListifyCodeGroup(cg, null, out scal);
        for(int i=0; i<scal.Count; i++)
        {
            // See if this codegroup has the url membership condition
            if (scal[i].cg.MembershipCondition is UrlMembershipCondition)
                return true;
        }
        return false;
    }// DoesCGHaveNetCodegroup

    internal static void PrepCodeGroupTree(CodeGroup root, PolicyLevel plSrc, PolicyLevel plDest)
    {
        SuperCodeGroupArrayList scal;

        ListifyCodeGroup(root, null, out scal);
        for(int i=0; i<scal.Count; i++)
        {
            // make sure this codegroup name is not already used
            int nCounter = 1;
            String sBase = scal[i].cg.Name;
            while(Security.isCodeGroupNameUsed(plDest.RootCodeGroup, scal[i].cg.Name) || 
                  Security.isCodeGroupNameUsed(root, scal[i].cg))
            {
                if (nCounter == 1)
                    scal[i].cg.Name = String.Format(CResourceStore.GetString("CSingleCodeGroup:NewDupCodegroup"), sBase);
                else
                    scal[i].cg.Name = String.Format(CResourceStore.GetString("CSingleCodeGroup:NumNewDupCodegroup"), nCounter.ToString(), sBase);

                nCounter++;
            }
                
            // Now check to see if we have its permission set in the policy
            if (plDest != plSrc)
            {
                bool fAddPermissionSet = false;
                
                if (!Security.isPermissionSetNameUsed(plDest, scal[i].cg.PermissionSetName))
                {
                    // We're copying a codegroup from a different policy level to a new
                    // policy level. This new policy level does not contain the permission
                    // set that our codegroup uses... thus, we must also copy over a new
                    // permission set as well
                    fAddPermissionSet = true;
                }
                else
                {

                
                    // The permission set name is used. Let's see if it's what we want
                    PermissionSet psSrc = plSrc.GetNamedPermissionSet(scal[i].cg.PermissionSetName);
                    PermissionSet psDest = plDest.GetNamedPermissionSet(scal[i].cg.PermissionSetName);
                    // See if these permission sets are equal
                    try
                    {
                        if (!(psSrc.IsSubsetOf(psDest) && psDest.IsSubsetOf(psSrc)))
                        {   
                            // We're copying a codegroup from a different policy level to a new
                            // policy level. This new policy level contains a permission
                            // set with the same name as the permission set the our codegroup uses... 
                            // However, the permission set that the codegroup uses has different permissions
                            // than what the permission set that the new policy level has... therefore, we
                            // must copy over a new permission set.
                            // The copied permission set will have a different name (since we can't have two
                            // permission sets with the exact same name). We'll have to remember
                            // to change the name of the permission set that the codegroup uses.
                            fAddPermissionSet = true;
                        }
                    }
                    catch(Exception)
                    {
                        // When we're doing these IsSubSetOf things, RegEx classes will throw
                        // exceptions if things aren't quite right. If that's the case, then
                        // we want to add the permission set.
                        fAddPermissionSet = true;
                    }
                }

                if (fAddPermissionSet)
                {
                    // See if this codegroup has a policy (i.e. a permission set)
                    if (scal[i].cg.PolicyStatement != null)
                    {
                        // We need to add this permission set from that policy level
                        String sPermissionSetName = AddPermissionSet(plDest, plSrc.GetNamedPermissionSet(scal[i].cg.PermissionSetName)).DisplayName;
                        // It's possible that we added a permission set and the name of our permission
                        // set was already used in the security policy. In that case, the permission set
                        // we tried to add was renamed. We should updated the codegroup to look at the
                        // permission set's new name
                        PermissionSet ps = plDest.GetNamedPermissionSet(sPermissionSetName);
                        PolicyStatement pols = scal[i].cg.PolicyStatement;
                        pols.PermissionSet = ps;
                        scal[i].cg.PolicyStatement = pols;                
                    }
                }
            }

            if (i != 0)
                // Add the modified codegroup back into the tree
                Security.RefreshCodeGroup(scal[scal[i].nParent].cg, scal[i].cg, scal[i].ChildNum);
        }
    }// PrepCodeGroupTree

    internal static CSinglePermissionSet AddPermissionSet(PolicyLevel plDest, NamedPermissionSet pSet)
    {
        return GenSecurityNode.AddPermissionSet(plDest, pSet);        
    }// AddPermissionSet

    internal static void UpdateAllCodegroups(PolicyLevel pl, NamedPermissionSet pSet)
    {
        // We need to update all codegroups that have this permission set.
        
        // This is pretty much just a cut and paste from UpdateCodegroup. We just need to 
        // make a few tweaks. If we make any changes to this, we'll also probably
        // want to make changes to RemoveExclusiveCodeGroups.
        
        // We don't want to do this recursively, so first let's listify this policy level
        SuperCodeGroupArrayList scal;

        ListifyPolicyLevel(pl, null, out scal);
        
        // We need to find ourselves, remove ourselves from our parent, then add ourselves back in....
        for(int i=scal.Count-1; i>=0; i--)
        {
            if (pSet.Name.Equals(scal[i].cg.PermissionSetName))
            {
                // This guy needs to be updated
                PolicyStatement ps = scal[i].cg.PolicyStatement;
                ps.PermissionSet = pSet;
                
                scal[i].cg.PolicyStatement = ps;

                int nIndex = i;
                // Now update this fellow in the tree
                while (scal[nIndex].nParent != -1)
                {
                    RefreshCodeGroup(scal[scal[nIndex].nParent].CodeGroupNode);
                    nIndex = scal[nIndex].nParent; 
                }
            }
        }
        // And finally, set the new Root Codegroup
        pl.RootCodeGroup = scal[0].cg;
        
    }// UpdateAllCodegroups

    internal static void RemoveExclusiveCodeGroups(CodeGroup cg)
    {
        // This function will remove the exclusive flag from any codegroups
        // in the passed in tree.
        
        // This is pretty much just a cut and paste from UpdateAllCodegroups. We just need to 
        // make a few tweaks

        if (cg == null)
            return;
            
        // We don't want to do this recursively, so first let's listify this policy level
        SuperCodeGroupArrayList scal;

        ListifyCodeGroup(cg, null, out scal);
        
        // Let's go looking for exclusive codegroups
        for(int i=scal.Count-1; i>=0; i--)
        {
            PolicyStatement ps = scal[i].cg.PolicyStatement;
            
            if (ps != null && (ps.Attributes & PolicyStatementAttribute.Exclusive)==PolicyStatementAttribute.Exclusive)
            {
                // This guy needs to have the exclusive flag removed
                ps.Attributes = ps.Attributes & ~PolicyStatementAttribute.Exclusive;

                scal[i].cg.PolicyStatement = ps;

                int nIndex = i;
                // Now update this fellow in the tree
                while (scal[nIndex].nParent != -1)
                {
                    RefreshCodeGroup(scal[scal[nIndex].nParent].cg, scal[nIndex].cg, scal[nIndex].ChildNum);
                    nIndex = scal[nIndex].nParent; 
                }
            }
        }
    }// RemoveExclusiveCodeGroups
 
}// class Security
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorcfg.dll"
#define VER_FILEDESCRIPTION_STR "Administrative tool for .NET UI\0"
#define VER_ORIGFILENAME_STR    "mscorcfg.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\webperm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;
using System.Data;
using System.Collections.Specialized;
using System.Net;
using System.Collections;
using System.Text.RegularExpressions;

internal class CWebPermDialog: CPermDialog
{
    internal CWebPermDialog(WebPermission perm)
    {
        this.Text = CResourceStore.GetString("WebPerm:PermName");
        m_PermControls = new CWebPermControls(perm, this);
        Init();        
    }// CWebPermDialog(WebPermission)  
}// class CWebPermDialog

internal class CWebPermPropPage: CPermPropPage
{
    internal CWebPermPropPage(CPSetWrapper nps) : base(nps)
    {
        m_sTitle=CResourceStore.GetString("WebPerm:PermName"); 
    }// CWebPermPropPage

    protected override void CreateControls()
    {
        IPermission perm = m_pSetWrap.PSet.GetPermission(typeof(WebPermission));
        m_PermControls = new CWebPermControls(perm, this);
    }// CreateControls
   
}// class CSocketPermPropPage


internal class CWebPermControls : CTablePermControls
{
    internal CWebPermControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
        // If they don't have a permission for this permission set, we will
        // feed our property page a 'none' permission state.
   
        if (perm == null)
            m_perm = new WebPermission(PermissionState.None);
    }// CWebPermControls


    protected override DataTable CreateDataTable(DataGrid dg)
    {
        DataTable dt = new DataTable("Stuff");

        // Create the "Host" Column
        DataColumn dcHost = new DataColumn();
        dcHost.ColumnName = "Host";
        dcHost.DataType = typeof(String);
        dt.Columns.Add(dcHost);

        // Create the "Accept" Column
        DataColumn dcAccept = new DataColumn();
        dcAccept.ColumnName = "Accept";
        dcAccept.DataType = typeof(bool);
        dt.Columns.Add(dcAccept);
        
        // Create the "Connect" Column
        DataColumn dcConnect = new DataColumn();
        dcConnect.ColumnName = "Connect";
        dcConnect.DataType = typeof(bool);
        dt.Columns.Add(dcConnect);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();

        DataGridTextBoxColumn dgtbcHost = new DataGridTextBoxColumn();
        DataGridBoolColumn dgbcAccept = new DataGridBoolColumn();
        DataGridBoolColumn dgbcConnect = new DataGridBoolColumn();
         
        dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        // Set up the column info for the Host column
        dgtbcHost.MappingName = "Host";
        dgtbcHost.HeaderText = CResourceStore.GetString("Host");
        dgtbcHost.Width = ScaleWidth(CResourceStore.GetInt("WebPerm:HostColumnWidth"));
        dgtbcHost.NullText = "";
        dgtbcHost.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcHost);

        // Set up the column info for the Accept column
        dgbcAccept.MappingName = "Accept";
        dgbcAccept.HeaderText = CResourceStore.GetString("WebPermission:Accept");
        dgbcAccept.AllowNull = false;
        dgbcAccept.Width = ScaleWidth(CResourceStore.GetInt("WebPerm:AcceptColumnWidth"));
        dgbcAccept.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcAccept);

        // Set up the column info for the Connect column
        dgbcConnect.MappingName = "Connect";
        dgbcConnect.HeaderText = CResourceStore.GetString("WebPermission:Connect");
        dgbcConnect.AllowNull = false;
        dgbcConnect.Width = ScaleWidth(CResourceStore.GetInt("WebPerm:ConnectColumnWidth"));
        dgbcConnect.TrueValueChanged += new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgbcConnect);

        return dt;
    }// CreateDataTable
    
    protected override void PutValuesinPage()
    {
        // Put in the text for the radio buttons
        m_radUnrestricted.Text = CResourceStore.GetString("WebPerm:GrantUnrestrict");
        m_radGrantFollowingPermission.Text = CResourceStore.GetString("WebPerm:GrantFollowing");

        WebPermission perm = (WebPermission)m_perm;
        
        CheckUnrestricted(perm);
        
        if (!perm.IsUnrestricted())
        {
            // Run through the list of web permissions we have to accept connections
            IEnumerator enumer = perm.AcceptList;
            while (enumer.MoveNext())
            {
                String sHost;
                
                if (enumer.Current is Regex)
                    sHost = ((Regex)enumer.Current).ToString();
                else
                    sHost = (String)enumer.Current;
                    
                DataRow newRow;
                newRow = m_dt.NewRow();
                newRow["Host"] = sHost;
                newRow["Accept"] = true;
                newRow["Connect"] = false;
                m_dt.Rows.Add(newRow);
            }
            
            // Run through the list of web permissions we have to connect through
            enumer = perm.ConnectList;
            while (enumer.MoveNext())
            {
                String sHost;
                
                if (enumer.Current is Regex)
                    sHost = ((Regex)enumer.Current).ToString();
                else
                    sHost = (String)enumer.Current;

                // Check to see if this already exists in our table
                int i;
                for(i=0; i<m_dt.Rows.Count; i++)
                    if (m_dt.Rows[i]["Host"].Equals(sHost))
                    {
                        m_dt.Rows[i]["Connect"] = true;
                        break;
                    }

                // If we didn't have a match, make a new row
                if (i == m_dt.Rows.Count)
                {
                    DataRow newRow;
                    newRow = m_dt.NewRow();
                    newRow["Host"] = sHost;
                    newRow["Accept"] = false;
                    newRow["Connect"] = true;
                    m_dt.Rows.Add(newRow);
                }
            }

        }

        // We want at least 1 row so it looks pretty
        while(m_dt.Rows.Count < 1)
        {
           AddEmptyRow(m_dt);
        }
    }// PutValuesinPage

    protected override void AddEmptyRow(DataTable dt)
    {
        DataRow newRow = dt.NewRow();
        newRow["Host"]="";
        newRow["Accept"]=false;
        newRow["Connect"]=false;
           
        dt.Rows.Add(newRow);
    }// AddEmptyRow

    internal override bool ValidateData()
    {
        return GetCurrentPermission()!=null;
    }// ValidateData

    internal override IPermission GetCurrentPermission()
    {
        // Change cells so we get data committed to the grid
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        WebPermission perm=null;

        if (m_radUnrestricted.Checked == true)
            perm = new WebPermission(PermissionState.Unrestricted);
        else
        {
            perm = new WebPermission(PermissionState.None);
            
            for(int i=0; i<m_dt.Rows.Count; i++)
            {
                // Make sure we have a web permission to add
                if (m_dg[i, 0] != DBNull.Value && ((String)m_dg[i, 0]).Length > 0)
                {
                    String sHostname = (String)m_dg[i, 0];

                    // See if this hostname has Accept access
                    try
                    {
                        if ((bool)m_dg[i, 1])
                            perm.AddPermission(NetworkAccess.Accept, sHostname);

                        // See if this hostname has Connect access
                        if ((bool)m_dg[i, 2])
                            perm.AddPermission(NetworkAccess.Connect, sHostname);
                    }
                    catch(Exception)
                    {
                        MessageBox(String.Format(CResourceStore.GetString("WebPerm:BadHostName"), sHostname),
                                   CResourceStore.GetString("WebPerm:BadHostNameTitle"),
                                   MB.ICONEXCLAMATION);

                        m_dg.CurrentCell = new DataGridCell(i,0);
                        return null;
                    }
                   
                }
                else
                {
                    // if they checked a box, throw up a error dialog
                    if ((bool)m_dg[i, 1] || (bool)m_dg[i, 2])
                    {
                        MessageBox(CResourceStore.GetString("WebPerm:NeedHostName"),
                                   CResourceStore.GetString("WebPerm:NeedHostNameTitle"),
                                   MB.ICONEXCLAMATION);

                        m_dg.CurrentCell = new DataGridCell(i,0);
                        return null;
                    }
        
                }
            }
         
        }
        return perm;

    }// GetCurrentPermission

    protected override void onChange(Object o, EventArgs e)
    {
         int iSelRow = m_dg.CurrentCell.RowNumber;

        // If they created a new row... don't let there be null
        // values in the checkbox
        for(int i=1; i<3; i++)
            if (m_dg[iSelRow, i] == DBNull.Value)
                m_dg[iSelRow, i]=false;

        ActivateApply();
    }// onClick

}// class CWebPermControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\urtuihelper\urtuihelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define SAMPLEMMCHELPER_API __declspec(dllexport)


#include <windows.h>
#include <mmc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include "fci.h"


SAMPLEMMCHELPER_API HRESULT callMMCPropertyChangeNotify(long* INotifyHandle,  LPARAM param);
SAMPLEMMCHELPER_API HRESULT callMMCFreeNotifyHandle(long* lNotifyHandle);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\urtuihelper\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscortim.dll"
#define VER_FILEDESCRIPTION_STR "Unmanaged code to assist CLR Admin tool\0"
#define VER_ORIGFILENAME_STR    "mscortim.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\urtuihelper\urtuihelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "Urtuihelper.h"

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif

int __cdecl main()
{
	return 0;
}

// The following functions are located in MMC.lib. Since functions located in .lib files are 
// inaccessable to C#, we need to provide wrappers for them
SAMPLEMMCHELPER_API HRESULT callMMCPropertyChangeNotify(long INotifyHandle,  LPARAM param)
{
	return MMCPropertyChangeNotify(INotifyHandle, param);
}// callMMCPropertyChangeNotify

SAMPLEMMCHELPER_API HRESULT callMMCFreeNotifyHandle(long lNotifyHandle)
{
	return MMCFreeNotifyHandle(lNotifyHandle);
}// callMMCFreeNotifyHandle

/*
 * When a CAB file reaches this size, a new CAB will be created
 * automatically.  This is useful for fitting CAB files onto disks.
 *
 * If you want to create just one huge CAB file with everything in
 * it, change this to a very very large number.
 */
#define MEDIA_SIZE			300000

/*
 * When a folder has this much compressed data inside it,
 * automatically flush the folder.
 *
 * Flushing the folder hurts compression a little bit, but
 * helps random access significantly.
 */
#define FOLDER_THRESHOLD	900000


/*
 * Compression type to use
 */

#define COMPRESSION_TYPE    tcompTYPE_MSZIP


/*
 * Our internal state
 *
 * The FCI APIs allow us to pass back a state pointer of our own
 */
typedef struct
{
    long    total_compressed_size;      /* total compressed size so far */
	long	total_uncompressed_size;	/* total uncompressed size so far */
} client_state;


/*
 * Function prototypes 
 */
void    store_cab_name(char *cabname, int iCab);
void    set_cab_parameters(PCCAB cab_parms);
BOOL	test_fci(int num_files, char *file_list[]);
void    strip_path(char *filename, char *stripped_name, DWORD cchName);
int		get_percentage(unsigned long a, unsigned long b);
char    *return_fci_error_string(int err);

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

static HFCI (FAR DIAMONDAPI *pfnFCICreate)(
        PERF                perf,
        PFNFCIFILEPLACED    pfnfiledest,
        PFNFCIALLOC         pfnalloc,
        PFNFCIFREE          pfnfree,
        PFNFCIOPEN          pfnopen,
        PFNFCIREAD          pfnread,
        PFNFCIWRITE         pfnwrite,
        PFNFCICLOSE         pfnclose,
        PFNFCISEEK          pfnseek,
        PFNFCIDELETE        pfndelete,
        PFNFCIGETTEMPFILE   pfntemp,
        PCCAB               pccab,
        void FAR *          pv);
static BOOL (FAR DIAMONDAPI *pfnFCIAddFile)(
        HFCI                hfci,
        char                *pszSourceFile,
        char                *pszFileName,
        BOOL                fExecute,
        PFNFCIGETNEXTCABINET GetNextCab,
        PFNFCISTATUS        pfnProgress,
        PFNFCIGETOPENINFO   pfnOpenInfo,
        TCOMP               typeCompress);
static BOOL (FAR DIAMONDAPI *pfnFCIFlushCabinet)(
        HFCI                hfci,
        BOOL                fGetNextCab,
        PFNFCIGETNEXTCABINET GetNextCab,
        PFNFCISTATUS        pfnProgress);
static BOOL (FAR DIAMONDAPI *pfnFCIFlushFolder)(
        HFCI                hfci,
        PFNFCIGETNEXTCABINET GetNextCab,
        PFNFCISTATUS        pfnProgress);
static BOOL (FAR DIAMONDAPI *pfnFCIDestroy)(
        HFCI                hfci);


/*
 *  FCICreate -- Create an FCI context
 *
 *  See fci.h for entry/exit conditions.
 */

HFCI DIAMONDAPI FCICreate(PERF              perf,
                          PFNFCIFILEPLACED  pfnfiledest,
                          PFNFCIALLOC       pfnalloc,
                          PFNFCIFREE        pfnfree,
                          PFNFCIOPEN        pfnopen,
                          PFNFCIREAD        pfnread,
                          PFNFCIWRITE       pfnwrite,
                          PFNFCICLOSE       pfnclose,
                          PFNFCISEEK        pfnseek,
                          PFNFCIDELETE      pfndelete,
                          PFNFCIGETTEMPFILE pfntemp,
                          PCCAB             pccab,
                          void FAR *        pv)
{
    HFCI hfci;
    hCabinetDll = LoadLibrary("CABINET");
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFCICreate = (HFCI(FAR DIAMONDAPI *)(PERF,PFNFCIFILEPLACED,PFNFCIALLOC,PFNFCIFREE,PFNFCIOPEN,PFNFCIREAD,PFNFCIWRITE,PFNFCICLOSE,PFNFCISEEK,PFNFCIDELETE,PFNFCIGETTEMPFILE,PCCAB,void *))GetProcAddress(hCabinetDll,"FCICreate");
    pfnFCIAddFile = (BOOL(FAR DIAMONDAPI *)(HFCI,char *,char *,BOOL,PFNFCIGETNEXTCABINET,PFNFCISTATUS,PFNFCIGETOPENINFO,TCOMP))GetProcAddress(hCabinetDll,"FCIAddFile");
    pfnFCIFlushCabinet = (BOOL(FAR DIAMONDAPI *)(HFCI,BOOL,PFNFCIGETNEXTCABINET,PFNFCISTATUS))GetProcAddress(hCabinetDll,"FCIFlushCabinet");
    pfnFCIFlushFolder = (BOOL(FAR DIAMONDAPI *)(HFCI,PFNFCIGETNEXTCABINET,PFNFCISTATUS))GetProcAddress(hCabinetDll,"FCIFlushFolder");
    pfnFCIDestroy = (BOOL(FAR DIAMONDAPI *)(HFCI))GetProcAddress(hCabinetDll,"FCIDestroy");

    if ((pfnFCICreate == NULL) ||
        (pfnFCIAddFile == NULL) ||
        (pfnFCIFlushCabinet == NULL) ||
        (pfnFCIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfci = pfnFCICreate(perf,pfnfiledest,pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,pfndelete,pfntemp,
            pccab,pv);
	        
    if (hfci == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfci);
}


/*
 *  FCIAddFile -- Add file to cabinet
 *
 *  See fci.h for entry/exit conditions.
 */

BOOL DIAMONDAPI FCIAddFile(HFCI                  hfci,
                           char                 *pszSourceFile,
                           char                 *pszFileName,
                           BOOL                  fExecute,
                           PFNFCIGETNEXTCABINET  GetNextCab,
                           PFNFCISTATUS          pfnProgress,
                           PFNFCIGETOPENINFO     pfnOpenInfo,
                           TCOMP                 typeCompress)
{
    if (pfnFCIAddFile == NULL)
    {
        return(FALSE);
    }

    return(pfnFCIAddFile(hfci,pszSourceFile,pszFileName,fExecute,GetNextCab,
            pfnProgress,pfnOpenInfo,typeCompress));
}


/*
 *  FCIFlushCabinet -- Complete the current cabinet under construction
 *
 *  See fci.h for entry/exit conditions.
 */

BOOL DIAMONDAPI FCIFlushCabinet(HFCI                  hfci,
                                BOOL                  fGetNextCab,
                                PFNFCIGETNEXTCABINET  GetNextCab,
                                PFNFCISTATUS          pfnProgress)
{
    if (pfnFCIFlushCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFCIFlushCabinet(hfci,fGetNextCab,GetNextCab,pfnProgress));
}


/*
 *  FCIFlushFolder -- Complete the current folder under construction
 *
 *  See fci.h for entry/exit conditions.
 */

BOOL DIAMONDAPI FCIFlushFolder(HFCI                  hfci,
                               PFNFCIGETNEXTCABINET  GetNextCab,
                               PFNFCISTATUS          pfnProgress)
{
    if (pfnFCIFlushFolder == NULL)
    {
        return(FALSE);
    }

    return(pfnFCIFlushFolder(hfci,GetNextCab,pfnProgress));
}


/*
 *  FCIDestroy -- Destroy an FCI context
 *
 *  See fci.h for entry/exit conditions.
 */

BOOL DIAMONDAPI FCIDestroy(HFCI hfci)
{
    BOOL rc;

    if (pfnFCIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFCIDestroy(hfci);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}



/*
 * Memory allocation function
 */
FNFCIALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFCIFREE(mem_free)
{
	free(memory);
}


/*
 * File i/o functions
 */
FNFCIOPEN(fci_open)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIREAD(fci_read)
{
    unsigned int result;

    result = (unsigned int) _read(hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCIWRITE(fci_write)
{
    unsigned int result;

    result = (unsigned int) _write(hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCICLOSE(fci_close)
{
    int result;

    result = _close(hf);

    if (result != 0)
        *err = errno;

    return result;
}

FNFCISEEK(fci_seek)
{
    long result;

    result = _lseek(hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIDELETE(fci_delete)
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
FNFCIFILEPLACED(file_placed)
{
	printf(
		"   placed file '%s' (size %d) on cabinet '%s'\n",
		pszFile, 
		cbFile, 
		pccab->szCab
	);

	if (fContinuation)
		printf("      (Above file is a later segment of a continued file)\n");

	return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
FNFCISTATUS(progress)
{
	return 0;
}

FNFCIGETNEXTCABINET(get_next_cabinet)
{
	return TRUE;
}


FNFCIGETOPENINFO(get_open_info)
{
	BY_HANDLE_FILE_INFORMATION	finfo;
	FILETIME					filetime;
	HANDLE						handle;
    DWORD                       attrs;
    int                         hf;

    /*
     * Need a Win32 type handle to get file date/time
     * using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with
     * _open
     */
	handle = CreateFile(
		pszName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
		NULL
	);
   
	if (handle == INVALID_HANDLE_VALUE)
	{
		return -1;
	}

	if (GetFileInformationByHandle(handle, &finfo) == FALSE)
	{
		CloseHandle(handle);
		return -1;
	}
   
	FileTimeToLocalFileTime(
		&finfo.ftLastWriteTime, 
		&filetime
	);

	FileTimeToDosDateTime(
		&filetime,
		pdate,
		ptime
	);

    attrs = GetFileAttributes(pszName);

    if (attrs == 0xFFFFFFFF)
    {
        /* failure */
        *pattribs = 0;
    }
    else
    {
        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *pattribs = (int) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }

    CloseHandle(handle);


    /*
     * Return handle using _open
     */
	hf = _open( pszName, _O_RDONLY | _O_BINARY );

	if (hf == -1)
		return -1; // abort on error
   
	return hf;
}


void set_cab_parameters(PCCAB cab_parms, char* szCabFilename)
{
	memset(cab_parms, 0, sizeof(CCAB));

	// Make this really big so we won't deal with multiple cab files
	cab_parms->cb = 1000000000;
	cab_parms->cbFolderThresh = 100000000;

	/*
	 * Don't reserve space for any extensions
	 */
	cab_parms->cbReserveCFHeader = 0;
	cab_parms->cbReserveCFFolder = 0;
	cab_parms->cbReserveCFData   = 0;

	/*
	 * We use this to create the cabinet name
	 */
	cab_parms->iCab = 1;

	/*
	 * If you want to use disk names, use this to
	 * count disks
	 */
	cab_parms->iDisk = 0;

	/*
	 * Choose your own number
	 */
	cab_parms->setID = 12345;

	/*
	 * Only important if CABs are spanning multiple
	 * disks, in which case you will want to use a
	 * real disk name.
	 *
	 * Can be left as an empty string.
	 */
	strcpy(cab_parms->szDisk, "");

	// Strip off the path of the filename
	int 	nCount = 0;
	char*	pFileName = szCabFilename;
	
	while(szCabFilename[nCount] != 0)
	{
		if (szCabFilename[nCount] == '\\')
			pFileName = szCabFilename + nCount + 1;
		nCount++;
	}

	/* store name of first CAB file */
       if (strlen(pFileName) < NumItems(cab_parms->szCab))
            strcpy(cab_parms->szCab, pFileName);

	char cTemp = *pFileName;
	(*pFileName) = 0;

	/* where to store the created CAB files */
	if (strlen(szCabFilename) < NumItems(cab_parms->szCabPath))
	    strcpy(cab_parms->szCabPath, szCabFilename);

	(*pFileName) = cTemp;
}


SAMPLEMMCHELPER_API BOOL CreateCab(char* szFileToCompress, char* szCabFilename)
{
	HFCI			hfci;
	ERF				erf;
	CCAB			cab_parameters;
	client_state	cs;


	/*  
	 * Initialise our internal state
	 */
    cs.total_compressed_size = 0;
	cs.total_uncompressed_size = 0;

	set_cab_parameters(&cab_parameters, szCabFilename);
	hfci = FCICreate(
		&erf,
		file_placed,
		mem_alloc,
		mem_free,
        fci_open,
        fci_read,
        fci_write,
        fci_close,
        fci_seek,
        fci_delete,
		get_temp_file,
        &cab_parameters,
        &cs
	);

	if (hfci == NULL)
	{
		return FALSE;
	}

	char	stripped_name[256];

	/*
	 * Don't store the path name in the cabinet file!
	*/
		strip_path(szFileToCompress, stripped_name, NumItems(stripped_name));

	if (FALSE == FCIAddFile(
		hfci,
		szFileToCompress,  /* file to add */
		stripped_name, /* file name in cabinet file */
		FALSE, /* file is not executable */
		get_next_cabinet,
		progress,
		get_open_info,
        COMPRESSION_TYPE))
	{
		(void) FCIDestroy(hfci);
		return FALSE;
	}

	/*
	 * This will automatically flush the folder first
	 */

	if (FALSE == FCIFlushCabinet(
		hfci,
		FALSE,
		get_next_cabinet,
		progress))
	{
        (void) FCIDestroy(hfci);

		return FALSE;
	}

    if (FCIDestroy(hfci) != TRUE)
	{
		return FALSE;
	}

	return TRUE;
}


void strip_path(char *filename, char *stripped_name, DWORD cchName)
{
	char	*p;

	p = strrchr(filename, '\\');

	if (p == NULL)
	{
            if (strlen(filename) < cchName)
		strcpy(stripped_name, filename);
        }
	else
	{
            if (strlen(p+1) < cchName)
                strcpy(stripped_name, p+1);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\verifymdh\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "ADEPENDS.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft CLR Assembly Dependancies Utility\0"
#define VER_ORIGFILENAME_STR    "ADEPENDS.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\resource\html\genresx.cs ===
using System;
using System.IO;
using System.Resources;
using System.Collections;

namespace GenResX
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>

	class GenResX
	{
		static int Main(string[] args)
		{
			ArrayList items = new ArrayList();
			ArrayList names = new ArrayList();

			foreach(string arg in args)
			{
			    String[] HTMLSet = arg.Split(new char[] {','}); 
				names.Add(HTMLSet[0]);

				FileStream htmlfile = new FileStream(HTMLSet[1], FileMode.Open, FileAccess.Read);
				StreamReader r = new StreamReader(htmlfile);
				String htmlstring = r.ReadToEnd();
				items.Add(htmlstring);
			}

            ResXResourceWriter rsxw = new ResXResourceWriter("mscorcfghtml.resx"); 

		    IEnumerator e = items.GetEnumerator();
			foreach(string name in names)
			{
			    e.MoveNext();
				rsxw.AddResource(name, e.Current);
            }				
            rsxw.Close();

			return 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\urtuihelper\fci.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *  FCI.H -- File Compression Interface
 *
 *  All Rights Reserved.
 */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FCI
#pragma pack(4)

//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_TYPES_FCI_FDI

#ifndef INCLUDED_FCI
#define INCLUDED_FCI 1

//** Specify structure packing explicitly for clients of FCI
#pragma pack(4)


/***    FCIERROR - Error codes returned in erf.erfOper field
 *
 */
typedef enum {
FCIERR_NONE,                // No error

FCIERR_OPEN_SRC,            // Failure opening file to be stored in cabinet
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_READ_SRC,            // Failure reading file to be stored in cabinet
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_ALLOC_FAIL,          // Out of memory in FCI

FCIERR_TEMP_FILE,           // Could not create a temporary file
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_BAD_COMPR_TYPE,      // Unknown compression type

FCIERR_CAB_FILE,            // Could not create cabinet file
                            //  erf.erfTyp has C run-time *errno* value

FCIERR_USER_ABORT,          // Client requested abort

FCIERR_MCI_FAIL,            // Failure compressing data

} FCIERROR;


/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFCI - Handle to an FCI Context
 *
 */
typedef void * HFCI;


/***    CCAB - Current Cabinet
 *
 *  This structure is used for passing in the cabinet parameters to FCI,
 *  and is passed back on certain FCI callbacks to provide cabinet
 *  information to the client.
 */
typedef struct {
// longs first
    ULONG  cb;                  // size available for cabinet on this media
    ULONG  cbFolderThresh;      // Thresshold for forcing a new Folder

// then ints
    UINT   cbReserveCFHeader;   // Space to reserve in CFHEADER
    UINT   cbReserveCFFolder;   // Space to reserve in CFFOLDER
    UINT   cbReserveCFData;     // Space to reserve in CFDATA
    int    iCab;                // sequential numbers for cabinets
    int    iDisk;               // Disk number
#ifndef REMOVE_CHICAGO_M6_HACK
    int    fFailOnIncompressible; // TRUE => Fail if a block is incompressible
#endif

//  then shorts
    USHORT setID;               // Cabinet set ID

// then chars
    char   szDisk[CB_MAX_DISK_NAME];    // current disk name
    char   szCab[CB_MAX_CABINET_NAME];  // current cabinet name
    char   szCabPath[CB_MAX_CAB_PATH];  // path for creating cabinet
} CCAB; /* ccab */
typedef CCAB *PCCAB; /* pccab */


/***    FNFCIALLOC - Memory Allocation
 *      FNFCIFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FCI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           FNFCIALLOC and FNFCIFREE calls -- incremental releases of
 *           FCI may have radically different numbers of
 *           FNFCIALLOC calls and allocation sizes!
 */
//** Memory functions for FCI
typedef void HUGE * (FAR DIAMONDAPI *PFNFCIALLOC)(ULONG cb); /* pfna */
#define FNFCIALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFCIFREE)(void HUGE *memory); /* pfnf */
#define FNFCIFREE(fn) void FAR DIAMONDAPI fn(void HUGE *memory)


/***    PFNFCIOPEN  - File I/O callbacks for FCI
 *      PFNFCIREAD
 *      PFNFCIWRITE
 *      PFNFCICLOSE
 *      PFNFCISEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNFCIOPEN oflag
 *  and pmode calls are those defined for _open.  FCI expects error
 *  handling to be identical to these C run-time routines, except that
 *  the value of errno should be returned via *err.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  It is possible
 *           that in a future implementations it may open temporary
 *           files or cabinet files in a different order.
 */
//** File I/O functions for FCI
typedef int  (FAR DIAMONDAPI *PFNFCIOPEN) (char FAR *pszFile, int oflag, int pmode, int FAR *err, void FAR *pv);
typedef UINT (FAR DIAMONDAPI *PFNFCIREAD) (int hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
typedef UINT (FAR DIAMONDAPI *PFNFCIWRITE)(int hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv);
typedef int  (FAR DIAMONDAPI *PFNFCICLOSE)(int hf, int FAR *err, void FAR *pv);
typedef long (FAR DIAMONDAPI *PFNFCISEEK) (int hf, long dist, int seektype, int FAR *err, void FAR *pv);
typedef int  (FAR DIAMONDAPI *PFNFCIDELETE) (char FAR *pszFile, int FAR *err, void FAR *pv);

#define FNFCIOPEN(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode, int FAR *err, void FAR *pv)
#define FNFCIREAD(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv)
#define FNFCIWRITE(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *memory, UINT cb, int FAR *err, void FAR *pv)
#define FNFCICLOSE(fn) int FAR DIAMONDAPI fn(int hf, int FAR *err, void FAR *pv)
#define FNFCISEEK(fn) long FAR DIAMONDAPI fn(int hf, long dist, int seektype, int FAR *err, void FAR *pv)
#define FNFCIDELETE(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int FAR *err, void FAR *pv)


/***    FNFCIGETNEXTCABINET - Callback used to request new cabinet info
 *
 *  Entry:
 *      pccab     - Points to copy of old ccab structure to modify
 *      cbPrevCab - Estimate of size of previous cabinet
 *      pv        - Has the caller's context pointer
 *
 *  Exit-Success:
 *      returns TRUE;
 *
 *  Exit-Failure:
 *      returns FALSE;
 */
typedef BOOL (DIAMONDAPI *PFNFCIGETNEXTCABINET)(PCCAB  pccab,
                                                ULONG  cbPrevCab,
                                                void FAR *pv); /* pfnfcignc */

#define FNFCIGETNEXTCABINET(fn) BOOL DIAMONDAPI fn(PCCAB  pccab,     \
                                                   ULONG  cbPrevCab, \
                                                   void FAR *pv)


/***    FNFCIFILEPLACED - Notify FCI client that file was placed
 *
 *  Entry:
 *      pccab         - cabinet structure to fill in, with copy of previous one
 *      pszFile       - name of file, from cabinet
 *      cbFile        - length of file
 *      fContinuation - true if this is a later segment of a continued file
 *      pv            - the context of the client
 *
 *  Exit-Success:
 *      return value anything but -1
 *
 *  Exit-Failure:
 *      return value -1 means to abort
 */
typedef int (DIAMONDAPI *PFNFCIFILEPLACED)(PCCAB pccab,
                                           char *pszFile,
                                           long  cbFile,
                                           BOOL  fContinuation,
                                           void FAR *pv); /* pfnfcifp */

#define FNFCIFILEPLACED(fn) int DIAMONDAPI fn(PCCAB pccab,         \
                                              char *pszFile,       \
                                              long  cbFile,        \
                                              BOOL  fContinuation, \
                                              void FAR *pv)


/***    FNCDIGETOPENINFO - Open source file, get date/time/attribs
 *
 *  Entry:
 *      pszName  -- complete path to filename
 *      pdate    -- location to return FAT-style date code
 *      ptime    -- location to return FAT-style time code
 *      pattribs -- location to return FAT-style attributes
 *      pv       -- client's context
 *
 *  Exit-Success:
 *      Return value is file handle of open file to read
 *
 *  Exit-Failure:
 *      Return value is -1
 */
typedef int (DIAMONDAPI *PFNFCIGETOPENINFO)(char   *pszName,
                                            USHORT *pdate,
                                            USHORT *ptime,
                                            USHORT *pattribs,
                                            int FAR *err,
                                            void FAR *pv); /* pfnfcigoi */

#define FNFCIGETOPENINFO(fn) int DIAMONDAPI fn(char   *pszName,  \
                                               USHORT *pdate,    \
                                               USHORT *ptime,    \
                                               USHORT *pattribs, \
                                               int FAR *err, \
                                               void FAR *pv)
                            
/***    FNFCISTATUS - Status/Cabinet Size callback
 *
 *  Entry:
 *      typeStatus == statusFile if compressing a block into a folder
 *                      cb1 = Size of compressed block
 *                      cb2 = Size of uncompressed block
 *
 *      typeStatus == statusFolder if adding a folder to a cabinet
 *                      cb1 = Amount of folder copied to cabinet so far
 *                      cb2 = Total size of folder
 *
 *      typeStatus == statusCabinet if writing out a complete cabinet
 *                      cb1 = Estimated cabinet size that was previously
 *                              passed to fnfciGetNextCabinet().
 *                      cb2 = Actual cabinet size
 *                    NOTE: Return value is desired client size for cabinet
 *                          file.  FCI updates the maximum cabinet size
 *                          remaining using this value.  This allows a client
 *                          to generate multiple cabinets per disk, and have
 *                          FCI limit the size correctly -- the client can do
 *                          cluster size rounding on the cabinet size!
 *                          The client should either return cb2, or round cb2
 *                          up to some larger value and return that.
 *  Exit-Success:
 *      Returns anything other than -1;
 *      NOTE: See statusCabinet for special return values!
 *
 *  Exit-Failure:
 *      Returns -1 to signal that FCI should abort;
 */

#define statusFile      0   // Add File to Folder callback
#define statusFolder    1   // Add Folder to Cabinet callback
#define statusCabinet   2   // Write out a completed cabinet callback

typedef long (DIAMONDAPI *PFNFCISTATUS)(UINT   typeStatus,
                                        ULONG  cb1,
                                        ULONG  cb2,
                                        void FAR *pv); /* pfnfcis */

#define FNFCISTATUS(fn) long DIAMONDAPI fn(UINT   typeStatus, \
                                           ULONG  cb1,        \
                                           ULONG  cb2,        \
                                           void FAR *pv)


/***    FNFCIGETTEMPFILE - Callback, requests temporary file name
 *
 *  Entry:
 *      pszTempName - Buffer to receive complete tempfile name
 *      cbTempName  - Size of pszTempName buffer
 *
 *  Exit-Success:
 *      return TRUE
 *
 *  Exit-Failure:
 *      return FALSE; could not create tempfile, or buffer too small
 *
 *  Note:
 *      It is conceivable that this function may return a filename
 *      that will already exist by the time it is opened.  For this
 *      reason, the caller should make several attempts to create
 *      temporary files before giving up.
 */
typedef BOOL (DIAMONDAPI *PFNFCIGETTEMPFILE)(char *pszTempName,
                                             int   cbTempName,
                                             void FAR *pv); /* pfnfcigtf */

#define FNFCIGETTEMPFILE(fn) BOOL DIAMONDAPI fn(char *pszTempName, \
                                                int   cbTempName, \
                                                void FAR *pv)


/***    FCICreate -- create an FCI context (an open CAB, an open FOL)
 *
 *  Entry:
 *      perf      - structure where we return error codes
 *      pfnfcifp  - callback to inform caller of eventual dest of files
 *      pfna      - memory allocation function callback
 *      pfnf      - memory free function callback
 *      pfnfcigtf - temp file name generator callback
 *      pccab     - pointer to cabinet/disk name & size structure
 *
 *  Notes:
 *  (1) The alloc/free callbacks must remain valid throughout
 *      the life of the context, up to and including the call to
 *      FCIDestroy.
 *  (2) The perf pointer is stored in the compression context (HCI),
 *      and any errors from subsequent FCI calls are stored in the
 *      erf that was passed in on *this* call.
 *
 *  Exit-Success:
 *      Returns non-NULL handle to an FCI context.
 *
 *  Exit-Failure:
 *      Returns NULL, perf filled in.
 */
HFCI DIAMONDAPI FCICreate(PERF              perf,
                          PFNFCIFILEPLACED  pfnfcifp,
                          PFNFCIALLOC       pfna,
                          PFNFCIFREE        pfnf,
                          PFNFCIOPEN        pfnopen,
                          PFNFCIREAD        pfnread,
                          PFNFCIWRITE       pfnwrite,
                          PFNFCICLOSE       pfnclose,
                          PFNFCISEEK        pfnseek,
                          PFNFCIDELETE      pfndelete,
                          PFNFCIGETTEMPFILE pfnfcigtf,
                          PCCAB             pccab,
                          void FAR *        pv
                         );


/***   FCIAddFile - Add a disk file to a folder/cabinet
 *
 *  Entry:
 *      hfci          - FCI context handle
 *      pszSourceFile - Name of file to add to folder
 *      pszFileName   - Name to store into folder/cabinet
 *      fExecute      - Flag indicating execute on extract
 *      pfn_progress  - Progress callback
 *      pfnfcignc     - GetNextCabinet callback
 *      pfnfcis       - Status callback
 *      pfnfcigoi     - OpenInfo callback
 *      typeCompress  - Type of compression to use for this file
 *      pv            - pointer to caller's internal context
 *
 *  Exit-Success:
 *      returns TRUE
 *
 *  Exit-Failure:
 *      returns FALSE, error filled in
 *    
 *    This is the main function used to add file(s) to a cabinet
 *    or series of cabinets.  If the current file causes the current
 *    folder/cabinet to overflow the disk image currently being built,
 *    the cabinet will be terminated, and a new cabinet/disk name will
 *    be prompted for via a callback.  The pending folder will be trimmed
 *    of the data which has already been generated in the finished cabinet.
 */
BOOL DIAMONDAPI FCIAddFile(HFCI                  hfci,
                           char                 *pszSourceFile,
                           char                 *pszFileName,
                           BOOL                  fExecute,
                           PFNFCIGETNEXTCABINET  pfnfcignc,
                           PFNFCISTATUS          pfnfcis,
                           PFNFCIGETOPENINFO     pfnfcigoi,
                           TCOMP                 typeCompress
                          );
            

/***   FCIFlushCabinet - Complete the current cabinet under construction
 *
 *  This will cause the current cabinet (assuming it is not empty) to
 *  be gathered together and written to disk.
 *
 *  Entry:
 *      hfci        - FCI context
 *      fGetNextCab - TRUE  => Call GetNextCab to get continuation info;
 *                    FALSE => Don't call GetNextCab unless this cabinet
 *                             overflows.
 *      pfnfcignc   - callback function to get continuation cabinets
 *      pfnfcis     - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIFlushCabinet(HFCI                  hfci,
                                BOOL                  fGetNextCab,
                                PFNFCIGETNEXTCABINET  pfnfcignc,
                                PFNFCISTATUS          pfnfcis
                               );

                                                                  
/***   FCIFlushFolder - Complete the current folder under construction
 *
 *  This will force the termination of the current folder, which may or
 *  may not cause one or more cabinet files to be completed.
 *
 *  Entry:
 *      hfci        - FCI context
 *      GetNextCab  - callback function to get continuation cabinets
 *      pfnProgress - callback function for progress reporting
 *      pv          - caller's internal context for callbacks
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIFlushFolder(HFCI                  hfci,
                               PFNFCIGETNEXTCABINET  pfnfcignc,
                               PFNFCISTATUS          pfnfcis
                              );

                                                                  
/***    FCIDestroy - Destroy a FCI context and delete temp files
 *
 *  Entry:
 *      hfci - FCI context
 *
 *  Exit-Success:
 *      return code TRUE
 *
 *  Exit-Failure:
 *      return code FALSE, error structure filled in
 */
BOOL DIAMONDAPI FCIDestroy (HFCI hfci);

                                                                  
//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_FCI

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\avlnode.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  avlnode.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/  
#ifndef __AVLNODE_HPP__
#define __AVLNODE_HPP__


/***************************************************************************************
 ********************                                               ********************
 ********************                    AVLNode                    ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
AVLNode *AVLNode::GetLeftmostDescendant() const
{    
    const AVLNode *node = this;
    
    
    while ( node->m_pLeftChild != NULL )
        node = node->m_pLeftChild;
        
            
    return const_cast<AVLNode *>( node );
    
} // AVLNode::GetLeftmostDescendant


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
AVLNode *AVLNode::GetRightmostDescendant() const
{    
    const AVLNode *node = this;
    
    
    while ( node->m_pRightChild != NULL )
        node = node->m_pRightChild;
        
         
    return const_cast<AVLNode *>( node );
    
} // AVLNode::GetRightmostDescendant


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC 
/* public */
AVLNode *AVLNode::GetPriorNode() const
{   
	const AVLNode *node = this;
    
    
    if ( node != NULL ) 
    {
        if ( m_pLeftChild != NULL )
            return m_pLeftChild->GetRightmostDescendant();

        else  
        {
	    	while ( node->m_pParent != NULL ) 
            {
	        	if ( node->m_pParent->m_pRightChild == node )
	            	return node->m_pParent;
                    
                    
	        	node = node->m_pParent;
                
	    	} // while
        }
    }
        
      
    return NULL; 
    
} // AVLNode::GetPriorNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC 
/* public */
AVLNode *AVLNode::GetNextNode() const
{   
	const AVLNode *node = this;
    
    
    if ( node != NULL ) 
    {
        if ( m_pRightChild != NULL )
            return m_pRightChild->GetLeftmostDescendant();

        else  
        {
	    	while ( node->m_pParent != NULL ) 
            {
	       	 	if ( node->m_pParent->m_pLeftChild == node )
	            	return node->m_pParent;
                    
                    
	        	node = node->m_pParent;

	    	} // while
        }
    }
        
    
  	return NULL;
    
} // AVLNode::GetNextNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
AVLNode *AVLNode::BalanceAfterLeftInsert( BOOL &higher )
{    
    AVLNode *pNode = this;
    
    
    switch ( m_balance ) 
    {
        case 1:
            m_balance = 0;
            higher = false;
            break;
                
                        
        case 0:
            m_balance = -1;
            break;
            
            
        case -1:
        {
            AVLNode *pNode1 = m_pLeftChild;
            
            
            //
            // single LL rotation
            //
            if ( pNode1->m_balance == -1 ) 
            {                
                SetLeftChild( pNode1->m_pRightChild );
                pNode1->SetRightChild( this );

                m_balance = 0; 
                pNode = pNode1;
            }
            //
            // double LR rotation
            //
            else 
            {                
                AVLNode *pNode2 = pNode1->m_pRightChild;
                
                
                pNode1->SetRightChild( pNode2->m_pLeftChild );
                pNode2->SetLeftChild( pNode1 );
                
                SetLeftChild( pNode2->m_pRightChild );
                pNode2->SetRightChild( this );

                m_balance = ((pNode2->m_balance == -1) ? 1 : 0);
                pNode1->m_balance = ((pNode2->m_balance == 1) ? -1 : 0);
                pNode = pNode2;
            }
            
            pNode->m_balance = 0;
            higher = false;
            break;
        }
        
    } // switch
            
    
    return pNode;            
    
} // AVLNode::BalanceAfterLeftInsert
      
      
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */  
AVLNode *AVLNode::BalanceAfterRightInsert( BOOL &higher )
{
    AVLNode *pNode = this;
    
    
    switch ( m_balance ) 
    {
        case -1:
            m_balance = 0;
            higher = false;
            break;
            
            
        case 0:
            m_balance = 1;
            break;
            
            
        case 1:
        {
            AVLNode *pNode1 = m_pRightChild;
            
            
            //
            // single RR rotation
            //
            if ( pNode1->m_balance == 1 ) 
            {                
                SetRightChild( pNode1->m_pLeftChild );
                pNode1->SetLeftChild( this );

                m_balance = 0; 
                pNode = pNode1;
            }
            //
            // double RL rotation
            //
            else 
            {                
                AVLNode *pNode2 = pNode1->m_pLeftChild;
                
                
                pNode1->SetLeftChild( pNode2->m_pRightChild );
                pNode2->SetRightChild( pNode1 );
                
                SetRightChild( pNode2->m_pLeftChild );
                pNode2->SetLeftChild( this );

                m_balance = ((pNode2->m_balance == 1) ? -1 : 0);
                pNode1->m_balance = ((pNode2->m_balance == -1) ? 1 : 0);
                pNode = pNode2;
            }
            
            pNode->m_balance = 0;
            higher = false;
            break;
        }
    
    } // switch
    
      
    return pNode; 
               
} // AVLNode::BalanceAfterRightInsert


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC  
/* public */
AVLNode *AVLNode::BalanceAfterRightDelete( BOOL &lower )
{    
    AVLNode *pNode = this;
    
    
    switch ( m_balance ) 
    {
        case 1:
            m_balance = 0;
            break;
            
            
        case 0:
            m_balance = -1;
            lower = false;
            break;
            
            
        case -1:
        {
            AVLNode *pNode1 = m_pLeftChild;
            char balance = pNode1->m_balance;
            
            
            //
            // single LL rotation
            //
            if ( balance <= 0 ) 
            {                
                SetLeftChild( pNode1->m_pRightChild );
                pNode1->SetRightChild( this );

                if ( balance == 0 ) 
                {
                    m_balance = -1;
                    pNode1->m_balance = 1;
                    lower = false;
                }
                else 
                {
                    m_balance = 0;
                    pNode1->m_balance = 0;
                }
                
                pNode = pNode1;
            }
            //
            // double LR rotation
            //
            else 
            {                
                AVLNode *pNode2 = pNode1->m_pRightChild;
                char balance = pNode2->m_balance;


                pNode1->SetRightChild( pNode2->m_pLeftChild );
                pNode2->SetLeftChild( pNode1 );
                
                SetLeftChild( pNode2->m_pRightChild );
                pNode2->SetRightChild( this );

                m_balance = ((balance == -1) ? 1 : 0);
                pNode1->m_balance = ((balance == 1) ? -1 : 0);
                
                pNode = pNode2;
                pNode2->m_balance = 0;
            }
            break;
        }
    
    } // switch
   
    
    return pNode;
    
} // AVLNode::BalanceAfterRightDelete


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC 
/* public */
AVLNode *AVLNode::BalanceAfterLeftDelete( BOOL &lower )
{
    AVLNode *pNode = this;
    
    
    switch ( m_balance ) 
    {
        case -1:
            m_balance = 0;
            break;
            
            
        case 0:
            m_balance = 1;
            lower = false;
            break;
            
            
        case 1:
        {
            AVLNode *pNode1 = m_pRightChild;
            char balance = pNode1->m_balance;
            
            
            //
            // single RR rotation
            //
            if ( balance >= 0 ) 
            {                
                SetRightChild( pNode1->m_pLeftChild );
                pNode1->SetLeftChild( this );

                if ( balance == 0 ) 
                {
                    m_balance = 1;
                    pNode1->m_balance = -1;
                    lower = false;
                }
                else 
                {
                    m_balance = 0;
                    pNode1->m_balance = 0;
                }
                
                pNode = pNode1;
            }
            //
            // double RL rotation
            //
            else 
            {                
                AVLNode *pNode2 = pNode1->m_pLeftChild;
                char balance = pNode2->m_balance;


                pNode1->SetLeftChild( pNode2->m_pRightChild );
                pNode2->SetRightChild( pNode1 );
                
                SetRightChild( pNode2->m_pLeftChild );
                pNode2->SetLeftChild( this );

                m_balance = ((balance == 1) ? -1 : 0);
                pNode1->m_balance = ((balance == -1) ? 1 : 0);
                
                pNode = pNode2;
                pNode2->m_balance = 0;
            }
            break;
        }

    } // switch
    
      
    return pNode;
    
} // AVLNode::BalanceAfterLeftDelete

#endif // __AVLNODE_HPP__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\verifymdh\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
	echo This is needed to avoid a syntax error when processing this file. :-(


!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(COOL_TARGET) $(TARGETCOMPLUS)
	copy $(TARGETPATH)\$(TARGETNAME:.exe=.pdb) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\verifymdh\verifymdh.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace VerifyMDH {
    using System;
    using System.IO;
    using System.Collections;
    
    public class VerifyMDH
    {
		static int STRING_POOL = 42;
		static int USERSTRING_POOL = 43;
		static int GUID_POOL = 44;
		static int BLOB_POOL = 45;

        static bool verbose = false;
        public static readonly byte[] header10 = {0x4d, 0x44, 0x48, 0x00, 0x01, 0x00, 0x00, 0x00};
        public static readonly byte[] header20 = {0x4d, 0x44, 0x48, 0x00, 0x02, 0x00, 0x00, 0x00};
        public static byte [] m_mvid = new byte [16];
        
        public static int m_fileversion = 0;

    
        private static void DebugPrint(String str)
        {
            if (verbose)
                Console.Write (str);
        }
        private static void DebugPrint(Char ch)
        {
            if (verbose)
                Console.Write (ch.ToString());
        }
        private static void DebugPrint(Byte ch)
        {
            if (verbose)
                Console.Write (ch.ToString());
        }
    
        private static void DebugPrintLn(String str)
        {
            if (verbose)
                Console.WriteLine (str);
        }
        private static void DebugPrintLn(Char ch)
        {
            if (verbose)
                Console.WriteLine (ch.ToString());
        }
        private static void DebugPrintLn(Byte ch)
        {
            if (verbose)
                Console.WriteLine (ch.ToString());
        }
    
       	private static Int32 GetMaskedSecNum (Int32 secNum)
       	{
       	    return secNum & 0xff;
       	}
   	
        private static void CheckHeader(byte[] hd)
        {
            if (hd[4] == 0x01)
            {
                for (int i = 0; i < header10.Length; i++)
                {
                    if (hd[i] != header10[i])
                    {
                            throw new Exception("MDH Header is invalid");
                    }
                }
                m_fileversion = 1;
            }
            else if (hd[4] == 2)
            {
                for (int i = 0; i < header20.Length; i++)
                {
                    if (hd[i] != header20[i])
                    {
                            throw new Exception("MDH Header is invalid");
                    }
                }
                m_fileversion = 2;
            }
            else
            {
                throw new Exception("MDH Header is invalid");
            }
            DebugPrintLn ("Version " + m_fileversion.ToString());
        }
    
        private static void ReadData10 (BinaryReader br)
        {
            Int32 n;
            Int32 secNum;
            
            
            while ((secNum = br.ReadInt32()) != -1)
            {
                DebugPrintLn ("Sec num :" + secNum);
                DebugPrintLn (" Length  :" + (n = br.ReadInt32()));
                DebugPrintLn (" Data    :");
                Byte [] b = br.ReadBytes(n); 
                
                for (Int32 i=0; i<n; i++)
                {
                    if (secNum == STRING_POOL)
                        DebugPrint (Convert.ToChar(b[i]));
                    else if (secNum == USERSTRING_POOL)
                        DebugPrint (b[i]);
                    else if ((secNum == GUID_POOL) || (secNum == BLOB_POOL))
                    {
                        DebugPrintLn("Blob/Guid here...");
                        break;
                    }
                    else
                    {
                        throw new NotSupportedException ("Unknown Heap Id");
                    }
                }
                DebugPrintLn ("");
            }   
        }
	
	    private static void ReadData20 (BinaryReader br)
	    {
            Int32 n;
            Int32 secNum;
		
            m_mvid = br.ReadBytes(16);
            
            while ((secNum = br.ReadInt32()) != -1)
            {
                secNum = GetMaskedSecNum(secNum);
                DebugPrintLn ("Sec num :" + secNum);
                DebugPrintLn (" Length  :" + (n = br.ReadInt32()));
                DebugPrintLn (" Data    :");
                Byte [] b = br.ReadBytes(n); 
                
                for (Int32 i=0; i<n; i++)
                {
                    if (secNum == STRING_POOL)
                        DebugPrint (Convert.ToChar(b[i]));
                    else if (secNum == USERSTRING_POOL)
                        DebugPrint (b[i]);
                    else if ((secNum == GUID_POOL) || (secNum == BLOB_POOL))
                    {
                        DebugPrintLn("Blob/Guid here...");
                        break;
                    }
                    else
                    {
                        throw new NotSupportedException ("Unknown Heap Id");
                    }
                }
                DebugPrintLn ("");
            }   
        }
	
	    private static int ReadData (String hintFile)
        {
            try {
            
            
                FileStream fs = new FileStream (hintFile, FileMode.Open);
                BinaryReader br = new BinaryReader (fs);
            
                
                // Header
                Byte [] sig = br.ReadBytes(8);
                CheckHeader(sig);
                
                if (m_fileversion == 1)
                {
                    ReadData10(br);
                }
                else if (m_fileversion == 2)
                {
                    ReadData20(br);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine ("MDHFile error: " + e);
                // Error is 1.
                return 1;
            }
            
            Console.WriteLine ("Success.");
            // Success is 2
            return 2;
        }
        
        private static void Usage()
        {
            Console.WriteLine("Usage: VerifyMDH foo.mdh");
        }
            
        public static int Main(String[] args)
        {
            int error_code = 1;
            switch (args.Length)
            {
            case 0:
                Usage();
                break;
            case 1:
                error_code = ReadData (args[0]);
                break;
            default:
                Usage();
                break;
            }
            return error_code;
        }
  
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\avlnode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  avlnode.h
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/  
#ifndef __AVLNODE_H__
#define __AVLNODE_H__

#include "basehdr.h"    


/***************************************************************************************
 ********************                                               ********************
 ********************                    AVLNode                    ********************
 ********************                                               ********************
 ***************************************************************************************/
class DECLSPEC AVLNode 
{
	public:

		// balance operations
  		AVLNode *BalanceAfterLeftDelete( BOOL &lower );
        AVLNode *BalanceAfterRightDelete( BOOL &lower );
	    AVLNode *BalanceAfterLeftInsert( BOOL &higher );        
	    AVLNode *BalanceAfterRightInsert( BOOL &higher );
	   	    

		// getters
		AVLNode *GetParent() const;
		AVLNode *GetNextNode() const;
	    AVLNode *GetPriorNode() const;
	    
	    AVLNode *GetLeftChild() const;
	    AVLNode *GetRightChild() const;
	      
      	AVLNode *GetLeftmostDescendant() const;
    	AVLNode *GetRightmostDescendant() const;
 
           
    	// setters   
        void ClearLeftChild();
	    void ClearRightChild();
        
        void SetBalance( char balance );
        void SetParent( AVLNode *pParent );
    	                                        
    	void SetLeftChild( AVLNode *pChild );
    	void SetRightChild( AVLNode *pChild );             	            	        
    
    
	private:

		char m_balance;

    	AVLNode *m_pParent;
   	 	AVLNode *m_pLeftChild;
    	AVLNode *m_pRightChild;

}; // AVLNode


/***************************************************************************************
 ********************                                               ********************
 ********************               Inline Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/ 
inline
DECLSPEC
/* public */
AVLNode *AVLNode::GetParent() const
{
   
	return m_pParent;
        
} // AVLNode::GetParent


inline
DECLSPEC
/* public */
AVLNode *AVLNode::GetLeftChild() const
{
   
	return m_pLeftChild;
        
} // AVLNode::GetLeftChild


inline
DECLSPEC
/* public */
AVLNode *AVLNode::GetRightChild() const
{
   
   	return m_pRightChild;
    
} // AVLNode::GetRightChild


inline
DECLSPEC
/* public */
void AVLNode::ClearLeftChild()
{
  	m_pLeftChild = NULL;
    
} // AVLNode::ClearLeftChild 


inline
DECLSPEC
/* public */
void AVLNode::ClearRightChild()
{    
    m_pRightChild = NULL;

} // AVLNode::ClearRightChild 


inline
DECLSPEC
/* public */
void AVLNode::SetBalance( char balance )
{    
    m_balance = balance;
    
} // AVLNode::SetBalance 


inline
DECLSPEC
/* public */
void AVLNode::SetParent( AVLNode *pParent )
{
    m_pParent = pParent;
    
} // AVLNode::SetParent 


inline
DECLSPEC
/* public */
void AVLNode::SetLeftChild( AVLNode *pChild )
{    
    m_pLeftChild = pChild;       
    if ( pChild != NULL ) 
     	pChild->m_pParent = this;

} // AVLNode::SetLeftChild 


inline
DECLSPEC
/* public */
void AVLNode::SetRightChild( AVLNode *pChild )
{    
    m_pRightChild = pChild; 
   	if ( pChild != NULL ) 
     	pChild->m_pParent = this;

} // AVLNode::SetRightChild 

#endif // __AVLNODE_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\basehlp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************************
 * File:
 *  basehlp.h
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __BASEHLP_H__
#define __BASEHLP_H__

#include "basehdr.h"


//
// exception macro
//
#define _THROW_EXCEPTION( message ) \
{ \
	BASEHELPER::LaunchDebugger( message, __FILE__, __LINE__ );	\
    throw new BaseException( message );	\
} \


/***************************************************************************************
 ********************                                               ********************
 ********************           BaseException Declaration           ********************
 ********************                                               ********************
 ***************************************************************************************/
class DECLSPEC BaseException
{
    public:
        
        BaseException( const char *reason );
        virtual ~BaseException();
        

        virtual void ReportFailure();


    private:

        char *m_reason;
        
}; // BaseException


/***************************************************************************************
 ********************                                               ********************
 ********************            Synchronize Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/
class DECLSPEC Synchronize 
{
	public:
	
    	Synchronize( CRITICAL_SECTION &criticalSection );
		~Synchronize();
        
        
	private:
	
    	CRITICAL_SECTION &m_block;
        
}; // Synchronize


/***************************************************************************************
 ********************                                               ********************
 ********************          BASEHELPER Declaration               ********************
 ********************                                               ********************
 ***************************************************************************************/
class DECLSPEC BASEHELPER
{   
	public:
    
		//
		// debug dumper
		//
		static void DDebug( char *format, ... );


		//
		// unconditional dumper
		//
		static void Display( char *format, ... );


		//
        // obtain the value of the given environment var
        //
        static DWORD FetchEnvironment( const char *environment );
        
        
		//
		// launch debugger
		//
		static void LaunchDebugger( const char *szMsg, const char *szFile, int iLine );


		//
		// logs to a specified file
		// 
		static void LogToFile( char *format, ... );


		//
		// obtain numeric value of environment value
		//               
		static DWORD GetEnvVarValue( char *value );


		//
		// convert a string to a number
        //
		static int String2Number( char *number );
		

		//
		// return a string for a CorElementValue
		//
		static int ElementType2String( CorElementType elementType, WCHAR *buffer );
        
        
        //
		// print element type
		//
		static PCCOR_SIGNATURE ParseElementType( IMetaDataImport *pMDImport, 
											     PCCOR_SIGNATURE signature, 
											     char *buffer );
                                                 
        //
		// process metadata for a function given its functionID
		//
		static
		HRESULT GetFunctionProperties( ICorProfilerInfo *pPrfInfo,
									   FunctionID functionID,
									   BOOL *isStatic,
									   ULONG *argCount,
									   WCHAR *returnTypeStr, 
									   WCHAR *functionParameters,
									   WCHAR *functionName );
                                                 
        //
        // print indentation 
        //                                        
		static void Indent( DWORD indent );
		

        //
        // retrieve a value from the registry if it exists, return 0 otherwise
        //
		static DWORD GetRegistryKey( char *regKeyName );

        //
        // decodes a type from the signature.
        // the type returned will be, depending on the last parameter, 
        // either the outermost type, (e.g. ARRAY for an array of I4s)
        // or the innermost (I4 in the example above),
        //
		static ULONG GetElementType( PCCOR_SIGNATURE pSignature, 
									CorElementType *pType, 
									BOOL bDeepParse = FALSE );


        //
        // helper function for decoding arrays
        //
		static ULONG ProcessArray( PCCOR_SIGNATURE pSignature, CorElementType *pType );


        //
        // helper function for decoding FNPTRs (NOT IMPL)
        //
		static ULONG ProcessMethodDefRef( PCCOR_SIGNATURE pSignature, CorElementType *pType );


}; // BASEHELPER

#endif __BASEHLP_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\basehdr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  basehdr.h
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __BASEHDR_H__
#define __BASEHDR_H__

#define _WIN32_DCOM


/***************************************************************************************
 ********************                                               ********************
 ********************             common includes                   ********************
 ********************                                               ********************
 ***************************************************************************************/
#include "math.h"
#include "time.h"
#include "stdio.h"
#include "stdlib.h"
#include "stdarg.h"
#include "limits.h"
#include "malloc.h"
#include "string.h"

#ifndef _SAMPLES_
	#include "winwrap.h"  // this includes windows   
#else
	#include "windows.h"
#endif

#include "winreg.h"	 
#include "wincrypt.h"
#include "winbase.h"
#include "objbase.h"

#include "cor.h"
#include "corhdr.h"
#include "corhlpr.h"
#include "corerror.h"

#include "corsym.h"
#include "corpub.h"
#include "corprof.h"
#include "cordebug.h"


/***************************************************************************************
 ********************                                               ********************
 ********************            compiler warnings                  ********************
 ********************                                               ********************
 ***************************************************************************************/
// the compiler complains about the exception not being
// used in the exception handler---it is being rethrown.
// ---turn off warning! 
#pragma warning ( disable: 4101 )

// the compiler complains about not having an implementation for
// a base class where the derived class exports everything and
// the base class is a template---turn off warning! 
#pragma warning ( disable: 4275 )

// the compiler complains about "a unary minus operator applied 
// to unsigned type ...", when importing mscorlib.tlb for the
// debugger service test---turn off warning! 
#pragma warning ( disable: 4146 )


/***************************************************************************************
 ********************                                               ********************
 ********************              basic macros                     ********************
 ********************                                               ********************
 ***************************************************************************************/
//  
// alias' for COM method signatures
//
#define COM_METHOD( TYPE ) TYPE STDMETHODCALLTYPE


//
// max length for arrays
//
#define MAX_LENGTH 256


//
// export functions 
//
#ifdef _USE_DLL_

	#if defined _EXPORT_
		#define DECLSPEC __declspec( dllexport )

	#elif defined _IMPORT_
		#define DECLSPEC __declspec( dllimport ) 
	#endif

#else 
	#define DECLSPEC
#endif // _USE_DLL_


//
// DebugBreak
//
#undef _DbgBreak
#ifdef _X86_
	#define _DbgBreak() __asm { int 3 }

#else
	#define _DbgBreak() DebugBreak()
#endif // _X86_


//
// assert on false
//
#define _ASSERT_( expression ) \
{ \
	if ( !(expression) ) \
     	BASEHELPER::LaunchDebugger( #expression, __FILE__, __LINE__ );	\
} \


//
// useful environment/registry macros
//
#define EE_REGISTRY_ROOT  		 "Software\\Microsoft\\.NETFramework"

#define REG_CORNAME          	 "CorName"
#define REG_VERSION          	 "Version"                        
#define REG_BUILDTYPE        	 "BuildType"
#define REG_BUILDFLAVOR		 	 "BuildFlavor"
#define REG_INSTALLROOT      	 "InstallRoot"

#define DEBUG_ENVIRONMENT        "DBG_PRF"
#define LOG_ENVIRONMENT          "DBG_PRF_LOG"
                        
                        
//                        
// basic I/O macros
//
#define DISPLAY( message ) BASEHELPER::Display message;
#define DEBUG_OUT( message ) BASEHELPER::DDebug message;
#define LOG_TO_FILE( message ) BASEHELPER::LogToFile message;
#define TEXT_OUT( message ) printf( "%s", message );
#define TEXT_OUTLN( message ) printf( "%s\n", message );


//
// char to wchar conversion HEAP
//
#define MAKE_WIDE_PTRHEAP_FROMUTF8( widestr, utf8str ) \
	widestr = new WCHAR[strlen( utf8str ) + 1]; \
    swprintf( widestr, L"%S", utf8str ); \
    

//
// char to wchar conversion ALLOCA
//
#define MAKE_WIDE_PTRSTACK_FROMUTF8( widestr, utf8str ) \
	widestr = (WCHAR *)_alloca( (strlen( utf8str ) + 1) * sizeof ( WCHAR ) ); \
    swprintf( widestr, L"%S", utf8str ); \
      

//
// wchar to char conversion HEAP
//
#define MAKE_UTF8_PTRHEAP_FROMWIDE( utf8str, widestr ) \
    utf8str = new char[wcslen( widestr ) + 1]; \
    sprintf( utf8str, "%S", widestr ); \


//
// wchar to char conversion ALLOCA
//
#define MAKE_UTF8_PTRSTACK_FROMWIDE( utf8str, widestr ) \
    utf8str = (char *)_alloca( (wcslen( widestr ) + 1) * sizeof ( char ) ); \
    sprintf( utf8str, "%S", widestr ); \

#endif // __BASEHDR_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\classfactory.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  classfactory.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __CLASSFACTORY_HPP__
#define __CLASSFACTORY_HPP__


//
// Helpers/Registration
//
HINSTANCE g_hInst;		  // instance handle to this piece of code
const int g_iVersion = 1; // version of coclasses.

static const char *g_szProgIDPrefix   = PROGID_PREFIX;
static const char *g_szThreadingModel = THREADING_MODEL;
static const char *g_szCoclassDesc    = COCLASS_DESCRIPTION;


// create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)( REFIID riid, void **ppInterface );


/***************************************************************************************
 ********************                                               ********************
 ********************         COCLASS_REGISTER Declaration          ********************
 ********************                                               ********************
 ***************************************************************************************/
struct COCLASS_REGISTER
{	
	const GUID *pClsid;				// Class ID of the coclass
    const char *szProgID; 			// Prog ID of the class
   	PFN_CREATE_OBJ pfnCreateObject;	// function to create instance
    
}; // COCLASS_REGISTER


//
// this map contains the list of coclasses which are exported from this module
//
const COCLASS_REGISTER g_CoClasses[] =
{	
	&CLSID_PROFILER,
    PROFILER_GUID,     		
    ProfilerCallback::CreateObject,
	NULL,				
    NULL,				
    NULL
};


/***************************************************************************************
 ********************                                               ********************
 ********************          CClassFactory Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/
class CClassFactory :
	public IClassFactory
{
	private:
    
		CClassFactory();						
        
	
	public:
	
    	CClassFactory( const COCLASS_REGISTER *pCoClass );
		~CClassFactory();
        

	public:
    
		//
		// IUnknown 
		//
      	COM_METHOD( ULONG ) AddRef();	    
	    COM_METHOD( ULONG ) Release();
	    COM_METHOD( HRESULT ) QueryInterface( REFIID riid, void	**ppInterface );	   		
        
		//
		// IClassFactory 
		//
		COM_METHOD( HRESULT ) LockServer( BOOL fLock );
	    COM_METHOD( HRESULT ) CreateInstance( IUnknown *pUnkOuter,
	    									  REFIID riid,
	    									  void **ppInterface );
    
    
	private:
    
		long m_refCount;						
    	const COCLASS_REGISTER *m_pCoClass;		
        
}; // CClassFactory


/***************************************************************************************
 ********************                                               ********************
 ********************          CClassFactory Implementation         ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
 /* private */
CClassFactory::CClassFactory()
{    
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
CClassFactory::CClassFactory( const COCLASS_REGISTER *pCoClass ) :
	m_refCount( 1 ), 
    m_pCoClass( pCoClass )
{    
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
CClassFactory::~CClassFactory()
{
} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG CClassFactory::AddRef()
{
     
  	return InterlockedIncrement( &m_refCount );
    
} // CClassFactory::AddRef 
	    

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */ 	     
ULONG CClassFactory::Release()
{    
	long refCount;


    refCount = InterlockedDecrement( &m_refCount );
    if ( refCount == 0 ) 
	    delete this;

    
	return refCount;
			
} // CClassFactory::Release


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT CClassFactory::QueryInterface( REFIID riid, void **ppInterface )
{    
    if ( riid == IID_IUnknown )
        *ppInterface = static_cast<IUnknown *>( this );	

    else if ( riid == IID_IClassFactory )
        *ppInterface = static_cast<IClassFactory *>( this );

    else
    {
        *ppInterface = NULL;                  
        
        
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown *>( *ppInterface )->AddRef();
      
    
    return S_OK;

} // CClassFactory::QueryInterface


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */ 
HRESULT CClassFactory::CreateInstance( IUnknown	*pUnkOuter,	REFIID riid, void **ppInstance )
{	    
	// aggregation is not supported by these objects
	if ( pUnkOuter != NULL )
		return CLASS_E_NOAGGREGATION;
	
    
	// ask the object to create an instance of itself, and check the iid.
	return (*m_pCoClass->pfnCreateObject)( riid, ppInstance );
       
} // CClassFactory::CreateInstance


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT CClassFactory::LockServer( BOOL fLock )
{    
	//
	// we are not required to hook any logic since this is always
	// and in-process server, we define the method for completeness
	//
	return S_OK;
    
} // CClassFactory::LockServer

#endif // __CLASSFACTORY_HPP__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\basehlp.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  basehlp.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/


/***************************************************************************************
 ********************                                               ********************
 ********************          BaseException Implementation         ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
BaseException::BaseException( const char *reason ) :
    m_reason( NULL )
{
    SIZE_T length = strlen( reason );
    
    
    m_reason = new char[(length + 1)];
    strcpy( m_reason, reason );

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* virtual public */
BaseException::~BaseException() 
{
	if ( m_reason != NULL )
        delete[] m_reason;

} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* virtual public */
void BaseException::ReportFailure()
{
   	TEXT_OUTLN( m_reason );
    
} // BaseException::ReportFailure


/***************************************************************************************
 ********************                                               ********************
 ********************            Synchronize Implementation         ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
Synchronize::Synchronize( CRITICAL_SECTION &criticalSection ) : 
	m_block( criticalSection )
{
	EnterCriticalSection( &m_block );
    
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* public */
Synchronize::~Synchronize()
{
	LeaveCriticalSection( &m_block );

} // dtor


/***************************************************************************************
 ********************                                               ********************
 ********************            BASEHELPER Implementation          ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
DWORD BASEHELPER::FetchEnvironment( const char *environment )
{
	DWORD retVal = -1;
	char buffer[MAX_LENGTH];
    
    
 	if ( GetEnvironmentVariableA( environment, buffer, MAX_LENGTH ) > 0 )
   		retVal = BASEHELPER::GetEnvVarValue( buffer );
                
    
    return retVal;

} // BASEHELPER::FetchEnvironemnt


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
void BASEHELPER::DDebug( char *format, ... )
{
	static DWORD debugShow = BASEHELPER::FetchEnvironment( DEBUG_ENVIRONMENT );
    
    
 	if ( (debugShow == 2) || (debugShow == 3) ) 
    {
    	va_list args;
    	DWORD dwLength;
    	char buffer[MAX_LENGTH];
   

    	va_start( args, format );    
    	dwLength = wvsprintfA( buffer, format, args );

    	printf( "%s\n", buffer );
   	}
   
} // BASEHELPER::DDebug


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
void BASEHELPER::Display( char *format, ... )
{
	va_list args;
	DWORD dwLength;
	char buffer[MAX_LENGTH];


	va_start( args, format );    
	dwLength = wvsprintfA( buffer, format, args );

	printf( "%s\n", buffer );   	
   
} // BASEHELPER::Display


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
void BASEHELPER::LogToFile( char *format, ... )
{
	va_list args;
	static DWORD dwVarValue = BASEHELPER::FetchEnvironment( LOG_ENVIRONMENT );


	va_start( args, format );        
	switch ( dwVarValue )
	{
		case 0x00:
		case 0xFFFFFFFF:
			 vprintf( format, args );
			 break;


		case 0xFF:
			break;


		default:
			{
				static count = 0;
				static CRITICAL_SECTION criticalSection = { 0 };

				
				if ( count++ == 0 )
					InitializeCriticalSection( &criticalSection );
				
                
				{
					FILE *stream;
					Synchronize	guard( criticalSection );
				

					//
					// first time create otherwise append
					//
					stream = ((count == 1) ? fopen( "output.log", "w" ) : fopen( "output.log", "a+" ));
				    if ( stream != NULL )
				    {
					    vfprintf( stream, format, args );
					    fflush( stream );
					    fclose( stream );
					}
					else
					   TEXT_OUTLN( "Unable to open log file" )
				}
			}            
			break;
            
	} // switch

} // BASEHELPER::LogToFile


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
void BASEHELPER::LaunchDebugger( const char *szMsg, const char *szFile, int iLine )
{	
	static DWORD launchDebugger = BASEHELPER::FetchEnvironment( DEBUG_ENVIRONMENT );
    
    
	if ( (launchDebugger >= 1) && (launchDebugger != 0xFFFFFFFF) )
    {    	
    	char title[MAX_LENGTH];
    	char message[MAX_LENGTH];
        
         	
		sprintf( message, 
				 "%s\n\n"     \
                 "File: %s\n" \
                 "Line: %d\n",
				 ((szMsg == NULL) ? "FAILURE" : szMsg), 
                 szFile, 
                 iLine );
             
        sprintf( title, 
        		 "Test Failure (PID: %d/0x%08x, Thread: %d/0x%08x)      ",
                 GetCurrentProcessId(), 
                 GetCurrentProcessId(), 
                 GetCurrentThreadId(), 
                 GetCurrentThreadId() );
                      
		switch ( MessageBoxA( NULL, 
        					  message, 
                              title, 
                              (MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION) ) )
		{
			case IDABORT:
				TerminateProcess( GetCurrentProcess(), 999 /* bad exit code */ );
				break;


			case IDRETRY:
				_DbgBreak();


			case IDIGNORE:
				break;
                                
		} // switch
	}
	
} // BASEHELPER::LaunchDebugger


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
int BASEHELPER::String2Number( char *number )
{
	WCHAR ch;
	int base; 
	int iIndex = 1;
	BOOL errorOccurred = FALSE;


	// check to see if this is a valid number
	// if the first digit is '0', then this is 
    // a hex or octal number
	if ( number[0] == '0' )
	{
    	//
        // hex
        //
		if ( (number[1] == 'x') || (number[1] == 'X') )
		{
			iIndex++;
            
			base = 16;
			while ( (errorOccurred == FALSE) &&
					((ch = number[iIndex++]) != '\0') )
			{	
				if ( ((ch >= '0') && (ch <= '9'))  ||
					 ((ch >= 'a') && (ch <= 'f'))  ||
					 ((ch >= 'A') && (ch <= 'F')) )
				{
					continue;
				}
                
				errorOccurred = TRUE;
			}
		}
        //
        // octal
        //
		else
		{
			base = 8;
			while ( (errorOccurred == FALSE) &&
					((ch = number[iIndex++]) != '\0') )
			{	
				if ( (ch >= '0') && (ch <= '7') )
					continue;
				
                
				errorOccurred = TRUE;
			}
		}
	}
    //
    // decimal
    //
	else
	{
		base = 10;
		while  ( (errorOccurred == FALSE) &&
		 		 ((ch = number[iIndex++]) != '\0') )
		{	
			if ( (ch >= '0') && (ch <= '9')	)
				continue;
			
            
			errorOccurred = TRUE;
		}
	}
	
    
	return ((errorOccurred == TRUE) ? -1 : base);

} // BASEHELPER::String2Number


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */ 
int BASEHELPER::ElementType2String( CorElementType elementType, WCHAR *buffer )
{
	int ret = 0; // success


	switch ( elementType )
	{
		case ELEMENT_TYPE_END:
			 swprintf( buffer, L"ELEMENT_TYPE_END" );
			 break;
		
        
		case ELEMENT_TYPE_VOID:
			 swprintf( buffer, L"ELEMENT_TYPE_VOID" );
			 break;


		case ELEMENT_TYPE_BOOLEAN:
			 swprintf( buffer, L"ELEMENT_TYPE_BOOLEAN" );
			 break;


		case ELEMENT_TYPE_CHAR:
			 swprintf( buffer, L"ELEMENT_TYPE_CHAR" );
			 break;


		case ELEMENT_TYPE_I1:
			 swprintf( buffer, L"ELEMENT_TYPE_I1" );
			 break;


		case ELEMENT_TYPE_U1:
			 swprintf( buffer, L"ELEMENT_TYPE_U1" );
			 break;


		case ELEMENT_TYPE_I2:
			 swprintf( buffer, L"ELEMENT_TYPE_I2" );
			 break;


		case ELEMENT_TYPE_U2:
			 swprintf( buffer, L"ELEMENT_TYPE_U2" );
			 break;


		case ELEMENT_TYPE_I4:
			 swprintf( buffer, L"ELEMENT_TYPE_I4" );
			 break;


		case ELEMENT_TYPE_U4:
			 swprintf( buffer, L"ELEMENT_TYPE_U4" );
			 break;


		case ELEMENT_TYPE_I8:
			 swprintf( buffer, L"ELEMENT_TYPE_I8" );
			 break;


		case ELEMENT_TYPE_U8:
			 swprintf( buffer, L"ELEMENT_TYPE_U8" );
			 break;


		case ELEMENT_TYPE_R4:
			 swprintf( buffer, L"ELEMENT_TYPE_R4" );
			 break;


		case ELEMENT_TYPE_R8:
			 swprintf( buffer, L"ELEMENT_TYPE_R8" );
			 break;


		case ELEMENT_TYPE_STRING:
			 swprintf( buffer, L"ELEMENT_TYPE_STRING" );
			 break;


		case ELEMENT_TYPE_PTR:
			 swprintf( buffer, L"ELEMENT_TYPE_PTR" );
			 break;


		case ELEMENT_TYPE_BYREF:
			 swprintf( buffer, L"ELEMENT_TYPE_BYREF" );
			 break;


		case ELEMENT_TYPE_VALUETYPE:
			 swprintf( buffer, L"ELEMENT_TYPE_VALUETYPE" );
			 break;


		case ELEMENT_TYPE_CLASS:
			 swprintf( buffer, L"ELEMENT_TYPE_CLASS" );
			 break;


		case ELEMENT_TYPE_ARRAY:
			 swprintf( buffer, L"ELEMENT_TYPE_ARRAY" );
			 break;


		case ELEMENT_TYPE_TYPEDBYREF:
			 swprintf( buffer, L"ELEMENT_TYPE_TYPEDBYREF" );
			 break;


		case ELEMENT_TYPE_I:
			 swprintf( buffer, L"ELEMENT_TYPE_I" );
			 break;


		case ELEMENT_TYPE_U:
			 swprintf( buffer, L"ELEMENT_TYPE_U" );
			 break;


		case ELEMENT_TYPE_FNPTR:
			 swprintf( buffer, L"ELEMENT_TYPE_FNPTR" );
			 break;


		case ELEMENT_TYPE_OBJECT:
			 swprintf( buffer, L"ELEMENT_TYPE_OBJECT" );
			 break;


		case ELEMENT_TYPE_SZARRAY:
			 swprintf( buffer, L"ELEMENT_TYPE_SZARRAY" );
			 break;


		case ELEMENT_TYPE_CMOD_REQD:
			 swprintf( buffer, L"ELEMENT_TYPE_CMOD_REQD" );
			 break;


		case ELEMENT_TYPE_CMOD_OPT:
			 swprintf( buffer, L"ELEMENT_TYPE_CMOD_OPT" );
			 break;


		case ELEMENT_TYPE_MAX:
			 swprintf( buffer, L"ELEMENT_TYPE_MAX" );
			 break;


		case ELEMENT_TYPE_MODIFIER:
			 swprintf( buffer, L"ELEMENT_TYPE_MODIFIER" );
			 break;


		case ELEMENT_TYPE_SENTINEL:
			 swprintf( buffer, L"ELEMENT_TYPE_SENTINEL" );
			 break;


		case ELEMENT_TYPE_PINNED:
			 swprintf( buffer, L"ELEMENT_TYPE_PINNED" );
			 break;


		default:
			 ret = -1;
			 swprintf( buffer, L"<UNKNOWN>" );
	}

	
	return ret;

} // BASEHELPER::ElementType2String


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
DWORD BASEHELPER::GetEnvVarValue( char *value )
{	
	DWORD retValue = -1;
	int base = BASEHELPER::String2Number( value );


	if ( base != -1 )
		retValue = (DWORD)strtoul( value, NULL, base );


	return retValue;

} // BASEHELPER::GetEnvVarValue


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
PCCOR_SIGNATURE BASEHELPER::ParseElementType( IMetaDataImport *pMDImport,
											  PCCOR_SIGNATURE signature, 
											  char *buffer )
{	
	switch ( *signature++ ) 
	{	
		case ELEMENT_TYPE_VOID:
        	strcat( buffer, "void" );	
			break;					
		
        
		case ELEMENT_TYPE_BOOLEAN:	
			strcat( buffer, "bool" );	
			break;	
		
        
		case ELEMENT_TYPE_CHAR:
        	strcat( buffer, "wchar" );	
			break;		
					
        
		case ELEMENT_TYPE_I1:
        	strcat( buffer, "int8" );	
			break;		
 		
        
		case ELEMENT_TYPE_U1:
        	strcat( buffer, "unsigned int8" );	
			break;		
		
        
		case ELEMENT_TYPE_I2:
        	strcat( buffer, "int16" );	
			break;		
		
        
		case ELEMENT_TYPE_U2:
        	strcat( buffer, "unsigned int16" );	
			break;			
		
        
		case ELEMENT_TYPE_I4:
        	strcat( buffer, "int32" );	
			break;
            
        
		case ELEMENT_TYPE_U4:
        	strcat( buffer, "unsigned int32" );	
			break;		
		
        
		case ELEMENT_TYPE_I8:
        	strcat( buffer, "int64" );	
			break;		
		
        
		case ELEMENT_TYPE_U8:
        	strcat( buffer, "unsigned int64" );	
			break;		
		
        
		case ELEMENT_TYPE_R4:
        	strcat( buffer, "float32" );	
			break;			
		
        
		case ELEMENT_TYPE_R8:
        	strcat( buffer, "float64" );	
			break;		
		
        
		case ELEMENT_TYPE_U:
        	strcat( buffer, "unsigned int" );	
			break;		 
		
        
		case ELEMENT_TYPE_I:
        	strcat( buffer, "int" );	
			break;			  
		
        
		case ELEMENT_TYPE_OBJECT:
        	strcat( buffer, "Object" );	
			break;		 
		
        
		case ELEMENT_TYPE_STRING:
        	strcat( buffer, "String" );	
			break;		 
		
        
		case ELEMENT_TYPE_TYPEDBYREF:
        	strcat( buffer, "refany" );	
			break;				       

		case ELEMENT_TYPE_CLASS:	
		case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
        	{	
				mdToken	token;	
				char classname[MAX_LENGTH];


				classname[0] = '\0';
			   	signature += CorSigUncompressToken( signature, &token ); 
				if ( TypeFromToken( token ) != mdtTypeRef )
				{
                	HRESULT	hr;
					WCHAR zName[MAX_LENGTH];
					
					
					hr = pMDImport->GetTypeDefProps( token, 
													 zName,
													 MAX_LENGTH,
													 NULL,
													 NULL,
													 NULL );
					if ( SUCCEEDED( hr ) )
						wcstombs( classname, zName, MAX_LENGTH );
                }
                    
				strcat( buffer, classname );		
			}
            break;	
		
        
		case ELEMENT_TYPE_SZARRAY:	 
			signature = BASEHELPER::ParseElementType( pMDImport, signature, buffer ); 
			strcat( buffer, "[]" );
			break;		
		
        
		case ELEMENT_TYPE_ARRAY:	
			{	
				ULONG rank;
                

				signature = BASEHELPER::ParseElementType( pMDImport, signature, buffer );                 
				rank = CorSigUncompressData( signature );													
				if ( rank == 0 ) 
					strcat( buffer, "[?]" );

				else 
				{
					ULONG *lower;	
					ULONG *sizes; 	
                    ULONG numsizes; 
					ULONG arraysize = (sizeof ( ULONG ) * 2 * rank);
                    
                                         
					lower = (ULONG *)_alloca( arraysize );                                                        
					memset( lower, 0, arraysize ); 
                    sizes = &lower[rank];

					numsizes = CorSigUncompressData( signature );	
					if ( numsizes <= rank )
					{
                    	ULONG numlower;
                        
                        
						for ( ULONG i = 0; i < numsizes; i++ )	
							sizes[i] = CorSigUncompressData( signature );	
						
                        
						numlower = CorSigUncompressData( signature );	
						if ( numlower <= rank )
						{
							for ( i = 0; i < numlower; i++)	
								lower[i] = CorSigUncompressData( signature ); 
							
                            
							strcat( buffer, "[" );	
							for ( i = 0; i < rank; i++ )	
							{	
								if ( (sizes[i] != 0) && (lower[i] != 0) )	
								{	
									if ( lower[i] == 0 )	
										sprintf ( buffer, "%d", sizes[i] );	

									else	
									{	
										sprintf( buffer, "%d", lower[i] );	
										strcat( buffer, "..." );	
										
										if ( sizes[i] != 0 )	
											sprintf( buffer, "%d", (lower[i] + sizes[i] + 1) );	
									}	
								}
                                	
								if ( i < (rank - 1) ) 
									strcat( buffer, "," );	
							}	
                            
							strcat( buffer, "]" );  
						}						
					}
				}
			} 
			break;	

		
		case ELEMENT_TYPE_PINNED:
			signature = BASEHELPER::ParseElementType( pMDImport, signature, buffer ); 
			strcat( buffer, "pinned" );	
			break;	
         
        
        case ELEMENT_TYPE_PTR:   
            signature = BASEHELPER::ParseElementType( pMDImport, signature, buffer ); 
			strcat( buffer, "*" );	
			break;   
        
        
        case ELEMENT_TYPE_BYREF:   
            signature = BASEHELPER::ParseElementType( pMDImport, signature, buffer ); 
			strcat( buffer, "&" );	
			break;  		    


		default:	
		case ELEMENT_TYPE_END:	
		case ELEMENT_TYPE_SENTINEL:	
			strcat( buffer, "<UNKNOWN>" );	
			break;				                      				            
                        	
	} // switch	
    
	
	return signature;

} // BASEHELPER::ParseElementType


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
HRESULT BASEHELPER::GetFunctionProperties( ICorProfilerInfo *pPrfInfo,
										   FunctionID functionID,
										   BOOL *isStatic,
										   ULONG *argCount,
										   WCHAR *returnTypeStr, 
										   WCHAR *functionParameters,
										   WCHAR *functionName )
{
    HRESULT hr = E_FAIL; // assume success
	
		
    if ( functionID != NULL )
	{
	    mdToken	token;
		ClassID classID;
		IMetaDataImport *pMDImport = NULL;		
		WCHAR funName[MAX_LENGTH] = L"UNKNOWN";
			    
			    
	    
	    //
		// Get the classID 
		//
	    hr = pPrfInfo->GetFunctionInfo( functionID,
									    &classID,
									    NULL,
                                        NULL );
	    if ( SUCCEEDED( hr ) )
		{
		    //
			// Get the MetadataImport interface and the metadata token 
			//
			hr = pPrfInfo->GetTokenAndMetaDataFromFunction( functionID, 
			           								 		IID_IMetaDataImport, 
															(IUnknown **)&pMDImport,
															&token );
			if ( SUCCEEDED( hr ) )
			{
				hr = pMDImport->GetMethodProps( token,
											    NULL,
											    funName,
											    MAX_LENGTH,
											    0,
											    0,
											    NULL,
											    NULL,
											    NULL, 
											    NULL );
				if ( SUCCEEDED( hr ) )
				{
					mdTypeDef classToken = NULL;
					WCHAR className[MAX_LENGTH] = L"UNKNOWN";


					hr = pPrfInfo->GetClassIDInfo( classID, 
						        				   NULL,  
						                           &classToken );
					
					if SUCCEEDED( hr )
					{
				      	if ( classToken != mdTypeDefNil )
						{
				          	hr = pMDImport->GetTypeDefProps( classToken, 
								                             className, 
								                             MAX_LENGTH,
								                             NULL, 
								                             NULL, 
								                             NULL ); 
						}
						swprintf( functionName, L"%s::%s", className, funName );					


					    DWORD methodAttr = 0;
						PCCOR_SIGNATURE sigBlob = NULL;


					    hr = pMDImport->GetMethodProps( (mdMethodDef) token,
					                                    NULL,
													    NULL,
													    0,
					                                    NULL,
					                                    &methodAttr,
					                                    &sigBlob,
					                                    NULL,
					                                    NULL,
					                                    NULL );
						if ( SUCCEEDED( hr ) )
						{
						    ULONG callConv;


							//
							// Is the method static ?
							//
							(*isStatic) = (BOOL)((methodAttr & mdStatic) != 0);

					     	//
						    // Make sure we have a method signature.
						    //
							char buffer[2 * MAX_LENGTH];
						    
						    
						    sigBlob += CorSigUncompressData( sigBlob, &callConv );
						    if ( callConv != IMAGE_CEE_CS_CALLCONV_FIELD )
							{
								static WCHAR* callConvNames[8] = 
								{	
									L"", 
									L"unmanaged cdecl ", 
									L"unmanaged stdcall ",	
									L"unmanaged thiscall ",	
									L"unmanaged fastcall ",	
									L"vararg ",	 
									L"<error> "	 
									L"<error> "	 
								};	
								buffer[0] = '\0';
								if ( (callConv & 7) != 0 )
									sprintf( buffer, "%s ", callConvNames[callConv & 7]);	
								
								//
								// Grab the argument count
								//
								sigBlob += CorSigUncompressData( sigBlob, argCount );

								//
							    // Get the return type
							    //
								sigBlob = ParseElementType( pMDImport, sigBlob, buffer );

								//
								// if the return typ returned back empty, write void
								//
								if ( buffer[0] == '\0' )
									sprintf( buffer, "void" );

								swprintf( returnTypeStr, L"%S",buffer );
								
								//
								// Get the parameters
								//								
								for ( ULONG i = 0; 
									  (SUCCEEDED( hr ) && (sigBlob != NULL) && (i < (*argCount))); 
									  i++ )
								{
									buffer[0] = '\0';

									sigBlob = ParseElementType( pMDImport, sigBlob, buffer );									
									if ( i == 0 )
										swprintf( functionParameters, L"%S", buffer );

									else if ( sigBlob != NULL )
										swprintf( functionParameters, L"%s+%S", functionParameters, buffer );
									
									else
										hr = E_FAIL;
								}								    								
							}
							else
							{
								//
							    // Get the return type
							    //
								buffer[0] = '\0';
								sigBlob = ParseElementType( pMDImport, sigBlob, buffer );
								swprintf( returnTypeStr, L"%s %S",returnTypeStr, buffer );
							}
						} 
					} 
				} 

				pMDImport->Release();
			} 		
		} 
	}
	//
	// This corresponds to an unmanaged frame
	//
	else
	{
		//
		// Set up return parameters
		//
		hr = S_OK;
		*argCount = 0;
		*isStatic = FALSE;
		returnTypeStr[0] = NULL; 
		functionParameters[0] = NULL;
		swprintf( functionName, L"UNMANAGED FRAME" );	
	}

	
	return hr;

} // BASEHELPER::GetFunctionProperties


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
void BASEHELPER::Indent( DWORD indent )
{
	for ( DWORD i = 0; i < indent; i++ )
		LOG_TO_FILE( ("   ") )

} // BASEHELPER::Indent


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
DWORD BASEHELPER::GetRegistryKey( char *regKeyName )
{
	DWORD type;
    DWORD size;
	DWORD retValue = -1;
    HKEY userKey = NULL;
    HKEY machineKey = NULL;


    //
    // local machine
    //
    size = 4;
    if ( (RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
                      	 EE_REGISTRY_ROOT,
                         0, 
                      	 KEY_READ, 
                         &machineKey ) == ERROR_SUCCESS) &&

	  	  (RegQueryValueExA( machineKey, 
                             regKeyName, 
                             0, 
                             &type, 
                             (LPBYTE)&retValue, 
                             &size ) == ERROR_SUCCESS) &&
          
          (type == REG_DWORD) )
   	{                	                    
		printf( "Registry LM Variable: %s=%d\n", regKeyName, retValue );
	}
    //
    // current user
    //
    else if ( (RegOpenKeyExA( HKEY_CURRENT_USER, 
                              EE_REGISTRY_ROOT, 
                              0, 
                              KEY_READ, 
                              &userKey ) == ERROR_SUCCESS) &&
    		 
    		  (RegQueryValueExA( userKey, 
                                 regKeyName, 
                                 0, 
                                 &type, 
                                 (LPBYTE)&retValue, 
                                 &size ) == ERROR_SUCCESS) &&

              (type == REG_DWORD) )
   	{                	                    
		printf( "Registry CU Variable: %s=%d\n", regKeyName, retValue );
	}

    RegCloseKey( userKey );                
    RegCloseKey( machineKey );
   	
   	
   	return retValue; 

} // BASEHELPER::GetRegistryKey


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
ULONG BASEHELPER::GetElementType( PCCOR_SIGNATURE pSignature, CorElementType *pType, BOOL bDeepParse )
{
    ULONG index = 0;
    mdToken typeRef;
    ULONG elementType;
    ULONG tempType;
    
    
    // picking apart primitive types is easy;  
    // the ones below require a bit more processing
    index += CorSigUncompressData( &pSignature[index], &elementType );                   
    switch ( elementType )
    {
        // SENTINEL, PINNED and BYREF are not types, just modifiers
    	case ELEMENT_TYPE_SENTINEL:
        case ELEMENT_TYPE_BYREF:    
    	case ELEMENT_TYPE_PINNED:
				DEBUG_OUT( ("**** PROCESSING SENTINEL/PINNED/BYREF ****") )
		        index += GetElementType( &pSignature[index], (CorElementType *)&elementType, bDeepParse );
		        break;


        case ELEMENT_TYPE_PTR:
        case ELEMENT_TYPE_SZARRAY:  
				DEBUG_OUT( ("**** PROCESSING PTR/SZARRAY ****") )
				if ( bDeepParse )
	                index += GetElementType( &pSignature[index], (CorElementType *)&elementType );
				else
	                index += GetElementType( &pSignature[index], (CorElementType *)&tempType );

	            break;
                        
                        
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_VALUETYPE:                                             
				DEBUG_OUT( ("**** PROCESSING CLASS/OBJECT/VALUECLASS ****") )
	            index += CorSigUncompressToken( &pSignature[index], &typeRef );
	            break;                   
                    

		case ELEMENT_TYPE_CMOD_OPT:
		case ELEMENT_TYPE_CMOD_REQD:        		                                            
                DEBUG_OUT( ("**** PROCESSING CMOD_OPT/CMOD_REQD ****") )
    			index += CorSigUncompressToken( &pSignature[index], &typeRef ); 
				if ( bDeepParse )
                    index += GetElementType( &pSignature[index], (CorElementType *)&elementType );            	                                                                                                                   
				else
                    index += GetElementType( &pSignature[index], (CorElementType *)&tempType );

                break;                                            


        case ELEMENT_TYPE_ARRAY:	 
				DEBUG_OUT( ("**** PROCESSING ARRAY ****") )
				if ( bDeepParse )
                    index += ProcessArray( &pSignature[index], (CorElementType *)&elementType );            	                                                                                                                   
				else
                    index += ProcessArray( &pSignature[index], (CorElementType *)&tempType );

                break;


        case ELEMENT_TYPE_FNPTR:	 
                DEBUG_OUT( ("**** PROCESSING FNPTR ****") )

                // !!! this will throw exception !!!
				index += ProcessMethodDefRef( &pSignature[index], (CorElementType *)&tempType );            	                                                                                                                   

                break;                                            
                
    } // switch

    *pType = (CorElementType)elementType;
    

    return index;

} // BASEHELPER::GetElementType


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
ULONG BASEHELPER::ProcessArray( PCCOR_SIGNATURE pSignature, CorElementType *pType )
{
    ULONG index = 0;
	ULONG rank;


    index += GetElementType( &pSignature[index], pType );            	                                                                                                                   
	index += CorSigUncompressData( &pSignature[index], &rank );
	if ( rank > 0 )
	{
	    UINT i;
	    ULONG sizes;
	    ULONG lowers;


	    index += CorSigUncompressData( &pSignature[index], &sizes );
	    for ( i = 0; i < sizes; i++ ) 
	    {
	        ULONG dimension;


	        index += CorSigUncompressData( &pSignature[index], &dimension );
	    } // for

	    
	    index += CorSigUncompressData( &pSignature[index], &lowers );
	    for ( i = 0; i < lowers; i++ )
	    {
	        int lowerBound;


	        index += CorSigUncompressSignedInt( &pSignature[index], &lowerBound );
	    } // for
	}


    return index;
    
} // BASEHELPER::ProcessArray


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
DECLSPEC
/* static public */
ULONG BASEHELPER::ProcessMethodDefRef( PCCOR_SIGNATURE pSignature, CorElementType *pType )
{
	_THROW_EXCEPTION( "**** ELEMENT_TYPE_FNPTR not supported by the framework ****" )

    return 0;
    
} // BASEHELPER::ProcessArray

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\container.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 * 	container.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __CONTAINER_HPP__
#define __CONTAINER_HPP__


/***************************************************************************************
 ********************                                               ********************
 ********************              Align Template Declaration       ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T>
inline T align(T x, size_t b)
{
    return T((x+(b-1)) & (~(b-1)));
}


/***************************************************************************************
 ********************                                               ********************
 ********************              AString Declaration		        ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T>
class AString
{
	public:

		AString( T *data );	
		~AString();
        
		
 	public:
	
    	void Dump();
		AString *Clone();		
        

	public:
		
        T *m_data;
        DWORD m_length;
				
}; // AString


/***************************************************************************************
 ********************                                               ********************
 ********************              AString Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T>
AString<T>::AString( T *data ) :
    m_length( 0 ),
    m_data( NULL )
{    	
  	if ( data != NULL )
    {    
		while ( data[m_length++] != NULL )
        	;
            
     	
        m_data = new T[m_length--];
        for ( DWORD i = 0; i < m_length; i++ )
        	m_data[i] = data[i];
            
            
      	m_data[m_length] = NULL;
  	}
        
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T>
AString<T>::~AString()
{    
	if ( m_data != NULL )
    {
	   delete [] m_data;	
       m_data = NULL;
   	}
		    
} // dtor

  
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */    
template<class T>    
void AString<T>::Dump()
{	    
    // are we dealing with a char or WCHAR ?
   	if ( sizeof( T ) == 1 )
    	printf( "%s\n", m_data );
        
   	else
    	printf( "%S\n", m_data );	
    
} // AString<T>::Dump

     
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */    
template<class T>    
AString<T> *AString<T>::Clone()
{	    
    							
	return new AString<T>( m_data );

} // AString<T>::Clone


/***************************************************************************************
 ********************                                               ********************
 ********************                   SListNode                   ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T, class K> class SList;


template<class T, class K>
class SListNode 
{
	friend class SList<T, K>;	
			
	public:

		SListNode( T entry, K Key ); 
		virtual ~SListNode();


	private:

		K m_key;
		T m_pEntry;
		        
		SListNode<T, K> *m_pNext;
			
}; // SListNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SListNode<T, K>::SListNode( T entry, K key ) :
	m_key( key ),
	m_pNext( NULL ),
	m_pEntry( entry )	
{        
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SListNode<T, K>::~SListNode() 
{    
    if ( m_pEntry != NULL )
    {
        delete m_pEntry;
        m_pEntry = NULL;
   	}        

} // dtor


/***************************************************************************************
 ********************                                               ********************
 ********************               SList Declaration               ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T, class K>
class SList 
{		
	public:

    	SList();
    	virtual ~SList(); 
        
		SList<T, K>( const SList<T, K> &source );
		SList<T, K> &operator=( const SList<T, K> &source );
 
    
	public:

		void Dump();		        
           
       	BOOL IsEmpty();     
        T Lookup( K key );        
        void DelEntry( K key );
    	void AddEntry( T entry, K key );    		
       	            
        //
        // getters
        //     	   
        T Head();
      	T Tail();
        T Entry();
        ULONG Count(); 
                        
        //
       	// intrinsic iteration
        // 	
		void Next();
        void Reset();
		BOOL AtEnd();
		BOOL AtStart();
                        
                		
	private:
		    
      	ULONG m_count;  
        
	    SListNode<T, K> *m_pHead;
        SListNode<T, K> *m_pTail;
        SListNode<T, K> *m_pCursor; 
        
        CRITICAL_SECTION m_criticalSection;           	    

}; // SList


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SList<T, K>::SList() :
	m_count( 0 ), 
	m_pHead( NULL ),
    m_pTail( NULL ),
	m_pCursor( NULL )	
{    
    InitializeCriticalSection( &m_criticalSection );
        
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SList<T, K>::~SList()
{     
   	if ( m_pHead != NULL )
    {      
    	///////////////////////////////////////////////////////////////////////////
    	Synchronize guard( m_criticalSection );
    	///////////////////////////////////////////////////////////////////////////  
    	SListNode<T, K> *cursor = m_pHead;
    
     
  		// delete all entries
        m_count = 0;
    	for ( ; ((m_pHead = m_pHead->m_pNext) != NULL); cursor = m_pHead )
        	delete cursor;	
   
   
   		delete cursor;
   	}
    
   	DeleteCriticalSection( &m_criticalSection );
   
} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SList<T, K> &SList<T, K>::operator=( const SList<T, K> &source )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
   	///////////////////////////////////////////////////////////////////////////
        
	memcpy( this, &source, sizeof( SList<T, K> ) );
	    
    
	return *this;
    
} // assignment operator


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
SList<T, K>::SList( const SList<T, K> &source ) 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    /////////////////////////////////////////////////////////////////////////// 
    
   	m_pHead = source.m_pHead;
    m_pTail = source.m_pTail;

} // copy ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void SList<T, K>::Dump() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    SListNode<T, K> *cursor = m_pHead;
    
         
  	// dump all entries
    for ( ; (cursor != NULL); cursor = cursor->m_pNext )
       	cursor->m_pEntry->Dump();
	
} // SList<T, K>::Dump


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
ULONG SList<T, K>::Count()
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    
    
	return m_count;
	
} // SList<T, K>::Count


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void SList<T, K>::AddEntry( T entry, K key )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    SListNode<T, K> *temp;
    
       	
  	++m_count;
    temp = new SListNode<T, K>( entry, key );
    
    // list insertion implies appending to the end of the list    
    if ( m_pHead == NULL )
		m_pHead = temp;

	else	 
	    m_pTail->m_pNext = temp;
    
    
    m_pCursor = m_pTail = temp;
         
} // SList<T, K>::AddEntry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void SList<T, K>::DelEntry( K key )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////      
      
      
    //     
    // Case 0: no entries---nothing to delete
    //
    if ( m_pHead != NULL )
   	{
    	SListNode<T, K> *cursor = m_pHead;
        
        
        //
    	// Case 1: delete head entry
        //
   		if ( m_pHead->m_pEntry->Compare( key ) == TRUE )
        {            	    	  
        	--m_count;                      
            
            // consider case where head == tail
            if ( (m_pHead = m_pHead->m_pNext) == NULL )
            	m_pCursor = m_pTail = m_pHead;
			
			else
               m_pCursor = m_pHead;	      
               
                        
            delete cursor;
            cursor = NULL;            		
        }
        //
        // Case 2: delete inner entry
        //
        else
        {
    		SListNode<T, K> *precursor = cursor;
    
    
    		// scan for match
		    for ( ; ((cursor = cursor->m_pNext) != NULL); precursor = cursor )
            {
            	if ( cursor->m_pEntry->Compare( key ) == TRUE )
                {
                	--m_count;
                	m_pCursor = precursor;
                	precursor->m_pNext = cursor->m_pNext;
                    
                    // consider case where deleted entry is the tail 
                    if ( m_pTail == cursor )
					{
                    	m_pTail = precursor;
						m_pTail->m_pNext = NULL;
					}
                        
                        
                	delete cursor;
                	cursor = NULL;                    
                	break;
				}
                
           	} // for   				                       	        		              	
 		}
   	}   
    
} // SList<T, K>::DelEntry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T SList<T, K>::Lookup( K key )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
    SListNode<T, K> *cursor = m_pHead;
    
    
   	// scan for match
    for ( ; 
    	  ((cursor != NULL) && (cursor->m_pEntry->Compare( key ) == FALSE)); 
          cursor = cursor->m_pNext ) 
     	; // continue
       
    
	return ((cursor != NULL) ? cursor->m_pEntry : NULL);    

} // SList<T, K>::Lookup    
    

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T SList<T, K>::Entry() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////	

    
    return ((m_pCursor != NULL) ? m_pCursor->m_pEntry : NULL);
	
} // SList<T, K>::Entry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T SList<T, K>::Head()
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
          
            
	return ((m_pHead != NULL) ? m_pHead->m_pEntry : NULL);            
	
} // SList<T, K>::Head


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T SList<T, K>::Tail() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
            
	
	return ((m_pTail != NULL) ? m_pTail->m_pEntry : NULL);            
           	
} // SList<T, K>::Tail


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void SList<T, K>::Next()
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////	
    
  	if ( m_pCursor != NULL )
	    m_pCursor = m_pCursor->m_pNext; 
    
} // SList<T, K>::Next()


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void SList<T, K>::Reset() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
            
   	m_pCursor = m_pHead;
	
} // SList<T, K>::Reset


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL SList<T, K>::AtEnd() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
        
 
	return (BOOL)(m_pCursor == NULL);

} // SList<T, K>::AtEnd


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL SList<T, K>::AtStart() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
        
 
	return (BOOL)(m_pCursor == m_pHead);

} // SList<T, K>::AtStart


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL SList<T, K>::IsEmpty() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
            
    
	return (BOOL)(m_pHead == NULL);
	
} // SList<T, K>::IsEmpty


/***************************************************************************************
 ********************                                               ********************
 ********************                   CNode               	    ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class K> class CStack;


template<class K>
class CNode 
{
	friend class CStack<K>;	
			
	public:

		CNode( K item ); 
		virtual ~CNode();


	private:
    
		K m_pEntry;
		CNode<K> *m_pNext;
			
}; // CNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
 /* public */
template<class K>
CNode<K>::CNode( K item ) :
	m_pNext( NULL ),
	m_pEntry( item )
{        
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
CNode<K>::~CNode() 
{  
    if ( m_pEntry != NULL )
    {
        delete m_pEntry;
        m_pEntry = NULL;
   	}
				
} // dtor


/***************************************************************************************
 ********************                                               ********************
 ********************                   CStack		                ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class K>
class CStack
{
	public:
    
		CStack();
		virtual ~CStack();

		CStack<K>( const CStack<K> &source );
		CStack<K> &operator=( const CStack<K> &source );


	public:

		void	Push( K item );
		K		Pop();
		K		Top();
		BOOL	Empty();
		void	Dump();
		ULONG 	Count();
		HRESULT	Clone( CStack<K> **target );
		HRESULT CopyToArray( ULONG *ppTarget );


	private:
    
		int		  m_Count;
		CNode<K> *m_pTop;
        
		CRITICAL_SECTION m_criticalSection;

}; // CStack


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
CStack<K>::CStack() :
	m_Count( 0 ),
	m_pTop( NULL )    
{    
    InitializeCriticalSection( &m_criticalSection ); 
    
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
CStack<K>::~CStack()
{
	if ( m_Count != 0 )
	{
		///////////////////////////////////////////////////////////////////////////
		Synchronize guard( m_criticalSection );
		///////////////////////////////////////////////////////////////////////////  

		while ( m_Count != 0 )
		{
			CNode<K> *np = m_pTop;
			CNode<K> *temp = np->m_pNext;


			m_pTop = temp;
			m_Count--;

			delete np;
		} 
	}    
    
   	DeleteCriticalSection( &m_criticalSection );
   
} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
CStack<K> &CStack<K>::operator=( const CStack<K> &source )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
   	///////////////////////////////////////////////////////////////////////////
    
	memcpy( this, &source, sizeof( CStack<K> ) );
	
									    
	return *this;
    
} // assignment operator


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
CStack<K>::CStack( const CStack<K> &source ) 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    /////////////////////////////////////////////////////////////////////////// 
    
	m_pTop = source.m_pTop;
	m_Count = source.m_Count;
    
} // copy ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
ULONG CStack<K>::Count() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
    
    
	return m_Count;
	
} // CStack<K>::Count


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
void CStack<K>::Dump() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    CNode<K> *cursor = m_pTop;
    
         
  	// dump all entries
    for ( ; (cursor != NULL); cursor = cursor->m_pNext )
       	cursor->m_pEntry->Dump();	
	
} // CStack<K>::Dump


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
void CStack<K>::Push( K item )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
	CNode<K> *np = new CNode<K>( item );


	if ( np != NULL )
	{
		m_Count++;

		np->m_pNext = m_pTop;
		m_pTop = np;
	}
    
} // CStack<K>::Push


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
K CStack<K>::Pop()
{		
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
	K item = NULL;


	if ( m_Count !=0 )
	{
		CNode<K> *np = m_pTop;
        
        
		item = np->m_pEntry->Clone();
		m_pTop = np->m_pNext;

		m_Count--;
		delete np;
	}
    	
		
	return item;
    
} // CStack<K>::Pop


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
K CStack<K>::Top()
{		
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

	if ( m_Count == 0 )
		return NULL;
	
	else
		return m_pTop->m_pEntry;
	
} // CStack<K>::Top


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
BOOL CStack<K>::Empty() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
        
    
	return (BOOL)(m_Count == NULL);
	
} // CStack<K>::Empty


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
HRESULT CStack<K>::Clone( CStack<K> **target ) 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    HRESULT hr = S_OK;
    CNode<K> *cursor = m_pTop;
    
         
  	// access all the entries of the original stack
    for ( ; (cursor != NULL); cursor = cursor->m_pNext )
	{
       	K item = NULL;
       	
       	
       	// create a clone of the entry
		// and push it to the stack
		if ( cursor->m_pEntry != NULL )
		{
			item = cursor->m_pEntry->Clone();
			if ( item != NULL )
				(*target)->Push( item );
		   
			else
			{
				hr = E_FAIL;
				break;
			}
		}
		else
		{
			hr = E_FAIL;
			break;
		}
	}
	
	
	return hr;

} // CStack<K>::Clone


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class K>
HRESULT CStack<K>::CopyToArray( ULONG *ppTarget ) 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    HRESULT hr = S_OK;
    CNode<K> *cursor = m_pTop;
    
         
  	// dump all entries
    for ( ULONG i=0; (cursor != NULL); cursor = cursor->m_pNext, i++ )
       	ppTarget[i] = (ULONG)(cursor->m_pEntry);	
	
	return hr;

} // CStack<K>::CopyToArray


/***************************************************************************************
 ********************                                               ********************
 ********************                   TableNode                   ********************
 ********************                                               ********************
 ***************************************************************************************/
enum Comparison { LESS_THAN, EQUAL_TO, GREATER_THAN };
template<class T, class K> class Table;


template<class T, class K> 
class TableNode : 
	public AVLNode 
{
	friend class Table<T, K>;
    
	private:
    
    	TableNode( T entry, K key ); 
        virtual ~TableNode();
        
        
	public:
    	 
	    TableNode<T, K> *DeleteNode( K key,	
        							 BOOL &lower,
                                     TableNode<T, K> *&deleted,
                                     TableNode<T, K> *&prior ); 
                                       
	    TableNode<T, K> *InsertNode( T entry, 
        							 K key, 
                                     BOOL &higher,  
                                     TableNode<T, K> *&inserted );
                                     

	private:

		TableNode<T, K> *_InsertNewNode( T entry, K key );
	    TableNode<T, K> *_DeleteNode( BOOL &lower, 
        							  TableNode<T, K> *&deleted, 
                                      TableNode<T, K> *&prior );
                     
             
  	public:
    	
        K m_key;
    	T m_pEntry;
        
}; // TableNode
   

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
TableNode<T, K>::TableNode( T entry, K key ) :
	m_key( key ),
    m_pEntry( entry )
{    
    SetBalance( 0 );
    ClearLeftChild();
    SetParent( NULL );
    ClearRightChild();

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
TableNode<T, K>::~TableNode<T, K>()
{    
	if ( m_pEntry != NULL )
    {
    	delete m_pEntry;
        m_pEntry = NULL;
   	}
        	                       
} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
TableNode<T, K> *TableNode<T, K>::InsertNode( T entry, 
											  K key, 
                                              BOOL &higher, 
                                              TableNode<T, K> *&inserted )
{    
	TableNode<T, K> *pNode = this;
    TableNode<T, K> *pChild = NULL;
    
    
    if ( pNode == NULL ) 
    {
        higher = TRUE;
        return (inserted = _InsertNewNode( entry, key ));
    }
	    

    switch ( (pNode->m_pEntry)->CompareEx( key ) )
    {
        case EQUAL_TO:
        			higher = FALSE;	            		            
                break;
                

		case LESS_THAN:
        		{
        			pChild = (TableNode<T, K> *)GetLeftChild();                                      
            		SetLeftChild( pChild->InsertNode( entry, key, higher, inserted ) );
            		if ( higher == TRUE ) 
                    	pNode = (TableNode<T, K> *)BalanceAfterLeftInsert( higher );
	    		}
               	break;
                

		case GREATER_THAN:
				{
                	pChild = (TableNode<T, K> *)GetRightChild();                                      
            		SetRightChild( pChild->InsertNode( entry, key, higher, inserted ) );
            		if ( higher == TRUE ) 
                    	pNode = (TableNode<T, K> *)BalanceAfterRightInsert( higher );            
            	}
	    		break;
                
    } // switch
    
    
    return pNode;
    
} // TableNode<T, K>::InsertNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
TableNode<T, K> *TableNode<T, K>::DeleteNode( K key, 
											  BOOL &lower, 
											  TableNode<T, K> *&deleted, 
                                              TableNode<T, K> *&prior )
{ 
    TableNode<T, K> *pNode = this;
    TableNode<T, K> *pChild = NULL;
    

	if ( pNode != NULL )
	{
	    switch ( (pNode->m_pEntry)->CompareEx( key ) ) 
	    {
			case LESS_THAN:
					{
	                    pChild = (TableNode<T, K> *)GetLeftChild();
	                    SetLeftChild( pChild->DeleteNode( key, lower, deleted, prior ) );
		            	if ( lower == TRUE ) 
	                    	pNode = (TableNode<T, K> *)pNode->BalanceAfterLeftDelete( lower );
	             	}
			    	break;
	                

			case GREATER_THAN:
					{
	                    pChild = (TableNode<T, K> *)GetRightChild();	
		            	SetRightChild( pChild->DeleteNode( key, lower, deleted, prior ) );
		            	if ( lower == TRUE ) 
	                    	pNode = (TableNode<T, K> *)pNode->BalanceAfterRightDelete( lower );
	             	}
			    	break;
	                

	        case EQUAL_TO:
		        {	
	              	TableNode<T, K> *pNode1;     
	                
	                
		            deleted = pNode1 = pNode;
		            if ( pNode->GetRightChild() == NULL ) 
	                {
	                	lower = TRUE;
		                pNode = (TableNode<T, K> *)pNode->GetLeftChild();	                
		            }
		            else if ( pNode->GetLeftChild() == NULL ) 
	                {
	                	lower = TRUE;
		                pNode = (TableNode<T, K> *)pNode->GetRightChild();	                                
		            }        
		            else 
	                {
	                    pChild = (TableNode<T, K> *)pNode1->GetLeftChild();
		                pNode1->SetLeftChild( pChild->_DeleteNode( lower, deleted, prior ) );	                
	                    if ( lower == TRUE ) 
	                    	pNode = (TableNode<T, K> *)pNode->BalanceAfterLeftDelete( lower );
		            }
		            break;
		        }
	            
	    } // switch
  	}
        
    
    return pNode;
    
} // TableNode<T, K>::DeleteNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
template<class T, class K>
TableNode<T, K> *TableNode<T, K>::_InsertNewNode( T entry, K key )
{
      	
    return new TableNode<T, K>( entry, key );
	
} // TableNode<T, K>::_InsertNewNode


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
template<class T, class K>
TableNode<T, K> *TableNode<T, K>::_DeleteNode( BOOL &lower,	
											   TableNode<T, K> *&deleted, 
                                               TableNode<T, K> *&prior )
{        
    TableNode<T, K> *pNode = this;
   	TableNode<T, K> *pChild = NULL;
    

	if ( pNode != NULL )
	{
		pChild = (TableNode<T, K> *)pNode->GetRightChild();
	    if ( pChild != NULL ) 
	    {    	
	        pNode->SetRightChild( pChild->_DeleteNode( lower, deleted, prior ) );
	        if ( lower == TRUE ) 
	        	pNode = (TableNode<T, K> *)pNode->BalanceAfterRightDelete( lower );
	    }
	    else 
	    {
			K key;
			T entry;
			TableNode<T, K> *pNode1;


			lower = true;
			deleted = pNode;
			pNode1 = (TableNode<T, K> *)pNode->GetNextNode();

			// swap contents of node to be deleted with its successor;
	        // the 'deleted' node can then be destroyed safely
			key = pNode1->m_key;
			entry = pNode1->m_pEntry;

			pNode1->m_key = pNode->m_key;
	        pNode1->m_pEntry = pNode->m_pEntry;       
			
			deleted->m_key = key;
	        deleted->m_pEntry = entry;


			// set the prior node and adjust pNode to point 
	        // to the left subtree of the 'deleted' node
	        prior = pNode1;
	        pNode = (TableNode<T, K> *)pNode->GetLeftChild();            
	    }
  	}
        
    
    return pNode;
    
} // TableNode<T, K>::_DeleteNode


/***************************************************************************************
 ********************                                               ********************
 ********************                     Table                     ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T, class K> 
class Table 
{
	public:

	    Table(); 
        virtual ~Table();
        
     
 	public:

		void Dump();
        
		BOOL IsEmpty();
		T Lookup( K key );
        void DelEntry( K key );
	    void AddEntry( T entry, K key );
	    
        //
        // getters
        //  
        T Root();   	   
        T Entry();
        ULONG Count(); 
                        
        //
       	// intrinsic iteration
        // 	
		void Next();
        void Reset();
		BOOL AtEnd();
		BOOL AtStart();

                
	private:
		
        // prevent copying 
    	Table( const Table<T, K> & );
    	Table<T, K> &operator=( const Table<T, K> & );

		void _Dump( TableNode<T, K> *pNode );
		void _Clean( TableNode<T, K> *pNode );
        
    
    private:

		ULONG m_count;
        
    	TableNode<T, K> *m_pRoot;      
        TableNode<T, K> *m_pCursor;
        
        CRITICAL_SECTION m_criticalSection;
    
}; // Table


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
Table<T, K>::Table() :
	m_count( 0 ), 
	m_pRoot( NULL ),
    m_pCursor( NULL ) 
{    
	InitializeCriticalSection( &m_criticalSection );
        
} // ctor
      
      
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>      
Table<T, K>::~Table()
{ 	                 
    if ( m_pRoot != NULL )
    {    
    	///////////////////////////////////////////////////////////////////////////
    	Synchronize guard( m_criticalSection );
    	///////////////////////////////////////////////////////////////////////////	
		
		_Clean( m_pRoot );
		m_pRoot = m_pCursor = NULL;
 	}	
    
   	DeleteCriticalSection( &m_criticalSection );
    
} // dtor
        
        
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K> 
T Table<T, K>::Lookup( K key ) 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    TableNode<T, K> *pNode = m_pRoot;


    while ( pNode != NULL ) 
    {
		switch ( (pNode->m_pEntry)->CompareEx( key ) ) 
	    {
		    case EQUAL_TO:
							return pNode->m_pEntry;


		    case LESS_THAN:
							pNode = (TableNode<T, K> *)pNode->GetLeftChild();
							break;


		    case GREATER_THAN:
							pNode = (TableNode<T, K> *)pNode->GetRightChild();
							break;

		} // switch
    }
        
    
    return NULL;
    
} // Table<T, K>::Lookup


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K> 
void Table<T, K>::AddEntry( T entry, K key )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////        
    BOOL higher = FALSE;    
    TableNode<T, K> *inserted = NULL;
        
   
    m_pRoot = m_pRoot->InsertNode( entry, key, higher, inserted );
    if ( m_pRoot != NULL )
    	m_pRoot->SetParent( NULL );
        
    
    // bump the count if we are adding a unique entry;
    // adjust the cursor to point to the inserted node
    if ( inserted != NULL )
    {
		m_count++;
		m_pCursor = inserted;
	}
    	
} // Table<T, K>::AddEntry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K> 
void Table<T, K>::DelEntry( K key )
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    BOOL lower = FALSE;
	TableNode<T, K> *prior = NULL;
	TableNode<T, K> *deleted = NULL;

         
	m_pRoot = m_pRoot->DeleteNode( key, lower, deleted, prior );
	if ( m_pRoot == NULL ) 
    	m_pRoot->SetParent( NULL );
        
        
    // decrease the count if we are removing a found entry;
    // adjust the cursor to point to the prior node; if
    // there is no prior node then reset the cursor
 	if ( deleted != NULL )
	{
   		m_count--;	
        if ( (m_pCursor = prior) == NULL )
			Reset();


		delete deleted;
		deleted = NULL;
	}

} // Table<T, K>::DelEntry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void Table<T, K>::Dump() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
    
    _Dump( m_pRoot );	
	    
} // Table<T, K>::Dump


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void Table<T, K>::_Dump( TableNode<T, K> *pNode ) 
{
	// inorder dump of the tree
	if ( pNode != NULL )
	{
		_Dump( (TableNode<T, K> *)pNode->GetLeftChild() );
		pNode->m_pEntry->Dump();
		_Dump( (TableNode<T, K> *)pNode->GetRightChild() );
	}	
	    
} // Table<T, K>::_Dump


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void Table<T, K>::_Clean( TableNode<T, K> *pNode ) 
{
	if ( pNode != NULL )
	{
		// postorder cleaning of the tree
		_Clean( (TableNode<T, K> *)pNode->GetLeftChild() );		
		_Clean( (TableNode<T, K> *)pNode->GetRightChild() );

		delete pNode;
		pNode = NULL;
	}	
	    
} // Table<T, K>::_Dump


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void Table<T, K>::Reset() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

	if ( m_pRoot != NULL )
   		m_pCursor = (TableNode<T, K> *)m_pRoot->GetLeftmostDescendant();
    
} // Table<T, K>::Reset


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
void Table<T, K>::Next()
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

	if ( m_pCursor != NULL )
   		m_pCursor = (TableNode<T, K> *)m_pCursor->GetNextNode(); 
            
} // Table<T, K>::Next

   
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T Table<T, K>::Entry() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

    
    return ((m_pCursor != NULL) ? m_pCursor->m_pEntry : NULL);
        
} // Table<T, K>::Entry


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
T Table<T, K>::Root() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

    
	return ((m_pRoot != NULL) ? m_pRoot->m_pEntry : NULL);            
    
} // Table<T, K>::Root


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL Table<T, K>::AtEnd() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////    
    		

	return (BOOL)(m_pCursor == NULL);
    
} // Table<T, K>::AtEnd 
    
    
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL Table<T, K>::AtStart() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////
        
	if ( m_pRoot != NULL )
    	return (BOOL)(m_pCursor == (TableNode<T, K> *)m_pRoot->GetLeftmostDescendant());
        
              
	return FALSE;

} // Table<T, K>::AtStart


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
BOOL Table<T, K>::IsEmpty() 
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

    
	return (BOOL)(m_pRoot == NULL);
    
} // Table<T, K>::IsEmpty
            
            
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
template<class T, class K>
ULONG Table<T, K>::Count()
{
	///////////////////////////////////////////////////////////////////////////
    Synchronize guard( m_criticalSection );
    ///////////////////////////////////////////////////////////////////////////

    
	return m_count;
    
} // Table<T, K>::Count


/***************************************************************************************
 ********************                                               ********************
 ********************                     HashTable                 ********************
 ********************                                               ********************
 ***************************************************************************************/
template<class T, class K> 
class HashTable 
{
	public:

	    HashTable(); 
        virtual ~HashTable();
        
     
 	public:

		T Lookup( K key );
	    void AddEntry( T entry, K key );
	    
	private:
		
        // prevent copying 
    	HashTable( const HashTable<T, K> & );
    	HashTable<T, K> &operator=( const HashTable<T, K> & );

    private:

        struct HashTableEntry
        {
            T   entry;
            HashTableEntry *next;
        };

        DWORD m_bucketCount;
        HashTableEntry **m_bucketTable;

}; // Table

/* public */
template<class T, class K>
HashTable<T, K>::HashTable()
{
    m_bucketCount = 2333;
    m_bucketTable = new HashTableEntry*[m_bucketCount];
    memset(m_bucketTable, 0, sizeof(m_bucketTable[0])*m_bucketCount);
} // ctor

/* public */
template<class T, class K>      
HashTable<T, K>::~HashTable()
{
    delete[] m_bucketTable;
} // dtor
        
        
/* public */
template<class T, class K>      
T HashTable<T, K>::Lookup( K key )
{
    DWORD hashCode = DWORD(key) % m_bucketCount;

//    printf("hashCode = %u\n", hashCode);
    for (HashTableEntry *h = m_bucketTable[hashCode]; h != NULL; h = h->next)
        if (h->entry->Compare(key) == TRUE)
            return h->entry;
    return NULL;
}

/* public */
template<class T, class K>      
void HashTable<T, K>::AddEntry( T entry, K key )
{
    DWORD hashCode = DWORD(key) % m_bucketCount;

    HashTableEntry *h = new HashTableEntry;
    h->entry = entry;
    h->next = m_bucketTable[hashCode];
    m_bucketTable[hashCode] = h;
}

#endif // __CONTAINER_HPP__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\profilercallback.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerCallBack.cpp
 *
 * Description:
 *  
 *
 *
 ***************************************************************************************/ 
#include "ProfilerCallback.h"


ProfilerCallback *g_pCallbackObject;		// global reference to callback object
/***************************************************************************************
 ********************                                               ********************
 ********************   Global Functions Used for Thread Support    ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* static __stdcall */
DWORD _GCThreadStub( void *pObject )
{    
	((ProfilerCallback *)pObject)->_ThreadStubWrapper( GC_HANDLE );   

  	return 0;
   	         	       
} // _GCThreadStub


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* static __stdcall */
DWORD _TriggerThreadStub( void *pObject )
{    
    ((ProfilerCallback *)pObject)->_ThreadStubWrapper( OBJ_HANDLE );   

  	return 0;
   	         	       
} // _TriggerThreadStub


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* static __stdcall */
DWORD _CallstackThreadStub( void *pObject )
{    
    ((ProfilerCallback *)pObject)->_ThreadStubWrapper( CALL_HANDLE );   

  	return 0;
   	         	       
} // _CallstackThreadStub


/***************************************************************************************
 ********************                                               ********************
 ********************   Global Functions Used by Function Hooks     ********************
 ********************                                               ********************
 ***************************************************************************************/

//
// The functions EnterStub, LeaveStub and TailcallStub are wrappers. The use of 
// of the extended attribute "__declspec( naked )" does not allow a direct call
// to a profiler callback (e.g., ProfilerCallback::Enter( functionID )).
//
// The enter/leave function hooks must necessarily use the extended attribute
// "__declspec( naked )". Please read the corprof.idl for more details. 
//

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __stdcall EnterStub( FunctionID functionID )
{
    ProfilerCallback::Enter( functionID );
    
} // EnterStub


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __stdcall LeaveStub( FunctionID functionID )
{
    ProfilerCallback::Leave( functionID );
    
} // LeaveStub


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __stdcall TailcallStub( FunctionID functionID )
{
    ProfilerCallback::Tailcall( functionID );
    
} // TailcallStub


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __declspec( naked ) EnterNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp + 16]
        call EnterStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
    
} // EnterNaked


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __declspec( naked ) LeaveNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp + 16]
        call LeaveStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
    
} // LeaveNaked


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void __declspec( naked ) TailcallNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp + 16]
        call TailcallStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
    
} // TailcallNaked


DWORD _GetTickCount()
{
    LARGE_INTEGER perfFrequency;
    LARGE_INTEGER perfCounter;
    if (QueryPerformanceFrequency(&perfFrequency))
    {
        QueryPerformanceCounter(&perfCounter);
        return (DWORD)(1000*perfCounter.QuadPart/perfFrequency.QuadPart);
    }
    else
    {
        return GetTickCount();
    }
}


int tlsIndex;

/***************************************************************************************
 ********************                                               ********************
 ********************     ProfilerCallBack Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */

ProfilerCallback::ProfilerCallback() :
    PrfInfo(),
	m_path( NULL ),
	m_hPipe( NULL ),
	m_dwMode( 0x3 ),
    m_refCount( 0 ),
	m_stream( NULL ),
    m_firstTickCount( _GetTickCount() ),
    m_lastTickCount( 0 ),
    m_lastClockTick( 0 ),
	m_dwShutdown( 0 ),
	m_totalClasses( 1 ),
	m_totalModules( 0 ),
	m_dwSkipObjects( 0 ),
	m_bShutdown( FALSE ),
	m_totalFunctions( 0 ),
	m_dwProcessId( NULL ),
	m_bDumpGCInfo( FALSE ),
	m_classToMonitor( NULL ),
	m_bDumpCompleted( FALSE ),
	m_bTrackingObjects( FALSE ),
	m_totalObjectsAllocated( 0 ),
	m_dwFramesToPrint( 0xFFFFFFFF ),
	m_bIsTrackingStackTrace( FALSE ),
    m_pGCHost( NULL ),
    m_callStackCount( 0 )
{
	HRESULT hr = E_FAIL;
	FunctionInfo *pFunctionInfo = NULL;

	
    TEXT_OUTLN( "CLR Object Profiler Tool" )
    
    //
	// initializations
	//
    InitializeCriticalSectionAndSpinCount( &m_criticalSection, 10000 );
    InitializeCriticalSectionAndSpinCount( &g_criticalSection, 10000 );
    g_pCallbackObject = this;

	
	//
	// get the processID and connect to the Pipe of the UI
	//
	m_dwProcessId = GetCurrentProcessId();
	sprintf( m_logFileName, "%s", FILENAME );
	_ConnectToUI();


	//
	// define in which mode you will operate
	//
	_ProcessEnvVariables();


	//
	// set the event and callback names
	//
	hr = _InitializeNamesForEventsAndCallbacks();
	
	if ( SUCCEEDED(hr) )
	{
		//
		// open the correct file stream fo dump the logging information
		//
		m_stream = ( m_path	== NULL ) ? fopen(m_logFileName, "w+"): fopen(m_path, "w+");
		hr = ( m_stream == NULL ) ? E_FAIL : S_OK;
		if ( SUCCEEDED( hr ) )
		{
            setvbuf(m_stream, NULL, _IOFBF, 32768);
			//
			// add an entry for the stack trace in case of managed to unamanged transitions
			//
			pFunctionInfo = new FunctionInfo( NULL, m_totalFunctions );		
			hr = ( pFunctionInfo == NULL ) ? E_FAIL : S_OK;
			if ( SUCCEEDED( hr ) )
			{
				wcscpy( pFunctionInfo->m_functionName, L"NATIVE FUNCTION" );
				wcscpy( pFunctionInfo->m_functionSig, L"( UNKNOWN ARGUMENTS )" );

				m_pFunctionTable->AddEntry( pFunctionInfo, NULL );
				LogToAny( "f %d %S %S 0 0\n", 
						  pFunctionInfo->m_internalID, 
						  pFunctionInfo->m_functionName,
						  pFunctionInfo->m_functionSig );

				m_totalFunctions ++;
			}
			else
				TEXT_OUTLN( "Unable To Allocate Memory For FunctionInfo" )
		}
		else
			TEXT_OUTLN( "Unable to open log file - No log will be produced" )
	}

    tlsIndex = TlsAlloc();
    if (tlsIndex < 0)
        hr = E_FAIL;

	if ( FAILED( hr ) )
		m_dwEventMask = COR_PRF_MONITOR_NONE;
		
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ProfilerCallback::~ProfilerCallback()
{
	if ( m_path != NULL )
	{
		delete[] m_path;
		m_path = NULL;
	}
	
	if ( m_classToMonitor != NULL )
	{
		delete[] m_classToMonitor;
		m_classToMonitor = NULL;	
	}

	if ( m_stream != NULL )
	{
		fclose( m_stream );
		m_stream = NULL;
	}

	for ( DWORD i=GC_HANDLE; i<SENTINEL_HANDLE; i++ )
	{
		if ( m_NamedEvents[i] != NULL )
		{
			delete[] m_NamedEvents[i];
			m_NamedEvents[i] = NULL;	
		}	

		if ( m_CallbackNamedEvents[i] != NULL )
		{
			delete[] m_CallbackNamedEvents[i];
			m_CallbackNamedEvents[i] = NULL;	
		}	

	}
	
	DeleteCriticalSection( &m_criticalSection );
	DeleteCriticalSection( &g_criticalSection );
	g_pCallbackObject = NULL;

} // dtor

        
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG ProfilerCallback::AddRef() 
{

    return InterlockedIncrement( &m_refCount );

} // ProfilerCallback::AddRef


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG ProfilerCallback::Release() 
{
    long refCount;


    refCount = InterlockedDecrement( &m_refCount );
    if ( refCount == 0 )
        delete this;
     

    return refCount;

} // ProfilerCallback::Release


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::QueryInterface( REFIID riid, void **ppInterface )
{
    if ( riid == IID_IUnknown )
        *ppInterface = static_cast<IUnknown *>( this ); 

    else if ( riid == IID_ICorProfilerCallback )
        *ppInterface = static_cast<ICorProfilerCallback *>( this );

    else
    {
        *ppInterface = NULL;


        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown *>( *ppInterface )->AddRef();

    return S_OK;

} // ProfilerCallback::QueryInterface 


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public static */
HRESULT ProfilerCallback::CreateObject( REFIID riid, void **ppInterface )
{
    HRESULT hr = E_NOINTERFACE;
    
     
   	*ppInterface = NULL;
    if ( (riid == IID_IUnknown) || (riid == IID_ICorProfilerCallback) )
    {           
        ProfilerCallback *pProfilerCallback;
        
                
        pProfilerCallback = new ProfilerCallback();
        if ( pProfilerCallback != NULL )
        {
        	hr = S_OK;
            
            pProfilerCallback->AddRef();
            *ppInterface = static_cast<ICorProfilerCallback *>( pProfilerCallback );
        }
        else
            hr = E_OUTOFMEMORY;
    }    
    

    return hr;

} // ProfilerCallback::CreateObject


IGCHost *GetGCHost()
{
    ICorRuntimeHost *pCorHost = NULL;

    CoInitialize(NULL);

	HRESULT hr = CoCreateInstance( CLSID_CorRuntimeHost, 
	           					   NULL, 
	    	    				   CLSCTX_INPROC_SERVER, 
	    		    			   IID_ICorRuntimeHost,
	    			    		   (void**)&pCorHost );

    if (SUCCEEDED(hr))
    {
        IGCHost *pGCHost = NULL;

        hr = pCorHost->QueryInterface(IID_IGCHost, (void**)&pGCHost);

        if (SUCCEEDED(hr))
            return pGCHost;
        else
            printf("Could not QueryInterface hr = %x\n", hr);
    }
    else
        printf("Could not CoCreateInstance hr = %x\n", hr);

    return NULL;
}

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */

HRESULT ProfilerCallback::Initialize( IUnknown *pICorProfilerInfoUnk )
{     
    HRESULT hr;

    m_pGCHost = GetGCHost();

    hr = pICorProfilerInfoUnk->QueryInterface( IID_ICorProfilerInfo,
                                               (void **)&m_pProfilerInfo );   
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pProfilerInfo->SetEventMask( m_dwEventMask );

        if ( SUCCEEDED( hr ) )
        {
            hr = m_pProfilerInfo->SetEnterLeaveFunctionHooks ( (FunctionEnter *)&EnterNaked,
                                                               (FunctionLeave *)&LeaveNaked,
                                                               (FunctionTailcall *)&TailcallNaked );        
            if ( SUCCEEDED( hr ) )
			{
				hr = _InitializeThreadsAndEvents();
				if ( FAILED( hr ) )
					Failure( "Unable to initialize the threads and handles, No profiling" );
                Sleep(100); // Give the threads a chance to read any signals that are already set.
			}
			else
                Failure( "ICorProfilerInfo::SetEnterLeaveFunctionHooks() FAILED" );
        }
        else
            Failure( "SetEventMask for Profiler Test FAILED" );           
    }       
    else
        Failure( "Allocation for Profiler Test FAILED" );           
              
              
    return S_OK;

} // ProfilerCallback::Initialize


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::Shutdown()
{
	m_dwShutdown++;

    return S_OK;          

} // ProfilerCallback::Shutdown


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::DllDetachShutdown()
{
    //
    // If no shutdown occurs during DLL_DETACH, release the callback
    // interface pointer. This scenario will more than likely occur
    // with any interop related program (e.g., a program that is 
    // comprised of both managed and unmanaged components).
    //
	m_dwShutdown++;
    if ( (m_dwShutdown == 1) && (g_pCallbackObject != NULL) )
	{
		g_pCallbackObject->Release();	
		g_pCallbackObject = NULL;
	}

    
    return S_OK;          

} // ProfilerCallback::DllDetachShutdown


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters: 
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */

__forceinline ThreadInfo *ProfilerCallback::GetThreadInfo(ThreadID threadID)
{
    ThreadInfo *threadInfo = (ThreadInfo *)TlsGetValue(tlsIndex);
    if (threadInfo != NULL && threadInfo->m_id == threadID)
        return threadInfo;

    threadInfo = g_pCallbackObject->m_pThreadTable->Lookup( threadID );
    TlsSetValue(tlsIndex, threadInfo);

    return threadInfo;
}

__forceinline void ProfilerCallback::Enter( FunctionID functionID )
{
#if 0
    ///////////////////////////////////////////////////////////////////////////
	Synchronize guard( g_pCallbackObject->m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

    try
    {
    	g_pCallbackObject->UpdateCallStack( functionID, PUSH );

        //
		// log tracing info if requested
		//
		if ( g_pCallbackObject->m_dwMode & (DWORD)TRACE )
			g_pCallbackObject->_LogCallTrace( functionID );

   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        g_pCallbackObject->Failure();       	    
    }
#else
	ThreadID threadID;

    HRESULT hr = g_pCallbackObject->m_pProfilerInfo->GetCurrentThreadID(&threadID);
	if ( SUCCEEDED(hr) )
	{
		ThreadInfo *pThreadInfo = GetThreadInfo(threadID);

		if (pThreadInfo != NULL)
			pThreadInfo->m_pThreadCallStack->Push( (ULONG)functionID );

        //
		// log tracing info if requested
		//
		if ( g_pCallbackObject->m_dwMode & (DWORD)TRACE )
			g_pCallbackObject->_LogCallTrace( functionID );
	}
#endif
} // ProfilerCallback::Enter


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters: 
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
__forceinline void ProfilerCallback::Leave( FunctionID functionID )
{
#if 0
    ///////////////////////////////////////////////////////////////////////////
	Synchronize guard( g_pCallbackObject->m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

    try
    {
    	g_pCallbackObject->UpdateCallStack( functionID, POP );
   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        g_pCallbackObject->Failure();       	    
    }
#else
    ThreadID threadID;

    HRESULT hr = g_pCallbackObject->m_pProfilerInfo->GetCurrentThreadID(&threadID);
	if ( SUCCEEDED(hr) )
	{
		ThreadInfo *pThreadInfo = GetThreadInfo(threadID);

		if (pThreadInfo != NULL)
			pThreadInfo->m_pThreadCallStack->Pop();
	}
#endif
} // ProfilerCallback::Leave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::Tailcall( FunctionID functionID )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( g_pCallbackObject->m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

    try
    {
    	g_pCallbackObject->UpdateCallStack( functionID, POP );
   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        g_pCallbackObject->Failure();       	    
    }

} // ProfilerCallback::Tailcall


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleLoadFinished( ModuleID moduleID,
											  HRESULT hrStatus )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  
    try
    {      		
		ModuleInfo *pModuleInfo = NULL;


   		AddModule( moduleID, m_totalModules );       
		pModuleInfo = m_pModuleTable->Lookup( moduleID );												

		_ASSERT_( pModuleInfo != NULL );

        DWORD stackTraceId = _StackTraceId();

		LogToAny( "m %d %S 0x%08x %d\n", 
				  pModuleInfo->m_internalID, 
				  pModuleInfo->m_moduleName,
				  pModuleInfo->m_loadAddress,
                  stackTraceId);
		
	    InterlockedIncrement( &m_totalModules );
   	}
    catch ( BaseException *exception )
    {
    	exception->ReportFailure();
        delete exception;
       
      	Failure();    
    }

    return S_OK;

} // ProfilerCallback::ModuleLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCompilationStarted( FunctionID functionID,
                                                 BOOL fIsSafeToBlock )
{
    try
    {      		
   		AddFunction( functionID, m_totalFunctions );       
	    InterlockedIncrement( &m_totalFunctions );
   	}
    catch ( BaseException *exception )
    {
    	exception->ReportFailure();
        delete exception;
       
      	Failure();    
    }


    return S_OK;
    
} // ProfilerCallback::JITCompilationStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCachedFunctionSearchStarted( FunctionID functionID,
														  BOOL *pbUseCachedFunction )
{
    // use the pre-jitted function
    *pbUseCachedFunction = TRUE;

    try
    {      		
   		AddFunction( functionID, m_totalFunctions );       
	    InterlockedIncrement( &m_totalFunctions );
   	}
    catch ( BaseException *exception )
    {
    	exception->ReportFailure();
        delete exception;
       
      	Failure();    
    }


    return S_OK;
       
} // ProfilerCallback::JITCachedFunctionSearchStarted


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters: 
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCompilationFinished( FunctionID functionID,
                                                  HRESULT hrStatus,
                                                  BOOL fIsSafeToBlock )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  


	HRESULT hr;
	ULONG size;
	LPCBYTE address;
	FunctionInfo *pFunctionInfo = NULL;


	pFunctionInfo = m_pFunctionTable->Lookup( functionID );												

	_ASSERT_( pFunctionInfo != NULL );
	hr = m_pProfilerInfo->GetCodeInfo( functionID, &address, &size );
	if ( SUCCEEDED( hr ) )
	{ 
		ModuleID moduleID;


    	hr = m_pProfilerInfo->GetFunctionInfo( functionID, NULL, &moduleID, NULL );
		if ( SUCCEEDED( hr ) )
		{
			ModuleInfo *pModuleInfo = NULL;


			pModuleInfo = m_pModuleTable->Lookup( moduleID );
			if ( pModuleInfo != 0 )
			{
                DWORD stackTraceId = _StackTraceId();
		
                LogToAny( "f %d %S %S 0x%08x %d %d %d\n", 
						  pFunctionInfo->m_internalID, 
						  pFunctionInfo->m_functionName,
						  pFunctionInfo->m_functionSig,
						  address,
						  size,
						  pModuleInfo->m_internalID,
                          stackTraceId);
			}
			else
				Failure( "Module Does Not Exist In The Table" );
		}
	}
	else
    	Failure( "ICorProfilerInfo::GetCodeInfo() FAILED" );
		

    return S_OK;
    
} // ProfilerCallback::JITCompilationFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCachedFunctionSearchFinished( FunctionID functionID,
														   COR_PRF_JIT_CACHE result )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  


	if ( result == COR_PRF_CACHED_FUNCTION_FOUND )
	{
		HRESULT hr;
		ULONG size;
		LPCBYTE address;
		FunctionInfo *pFunctionInfo = NULL;


		pFunctionInfo = m_pFunctionTable->Lookup( functionID );												

		_ASSERT_( pFunctionInfo != NULL );
		hr = m_pProfilerInfo->GetCodeInfo( functionID, &address, &size );
		if ( SUCCEEDED( hr ) )
		{ 
			ModuleID moduleID;


	    	hr = m_pProfilerInfo->GetFunctionInfo( functionID, NULL, &moduleID, NULL );
			if ( SUCCEEDED( hr ) )
			{
				ModuleInfo *pModuleInfo = NULL;


				pModuleInfo = m_pModuleTable->Lookup( moduleID );
				if ( pModuleInfo != 0 )
				{
                    DWORD stackTraceId = _StackTraceId();
			
                    LogToAny( "f %d %S %S 0x%08x %d %d %d\n", 
							  pFunctionInfo->m_internalID, 
							  pFunctionInfo->m_functionName,
							  pFunctionInfo->m_functionSig,
							  address,
							  size,
							  pModuleInfo->m_internalID,
                              stackTraceId);
				}
				else
					Failure( "Module Does Not Exist In The Table" );
			}
		}
		else
	    	Failure( "ICorProfilerInfo::GetCodeInfo() FAILED" );
	}


    return S_OK;
      
} // ProfilerCallback::JITCachedFunctionSearchFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFunctionEnter( FunctionID functionID )
{
	if ( functionID != NULL )
	{
	    try
	    {
			UpdateUnwindStack( &functionID, PUSH );
	   	}
	    catch ( BaseException *exception )
	    {    	
	    	exception->ReportFailure();
	        delete exception;
	        
	        Failure();       	    
	    }
	}
	else
    	Failure( "ProfilerCallback::ExceptionUnwindFunctionEnter returned NULL functionID FAILED" );


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFunctionEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFunctionLeave( )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

	FunctionID poppedFunctionID = NULL;


    try
    {
		UpdateUnwindStack( &poppedFunctionID, POP );
		UpdateCallStack( poppedFunctionID, POP );
   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        Failure();       	    
    }


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFunctionLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */ 
HRESULT ProfilerCallback::ThreadCreated( ThreadID threadID )
{
    try
    {
    	AddThread( threadID ); 
   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        Failure();       	    
    }


    return S_OK; 
    
} // ProfilerCallback::ThreadCreated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ThreadDestroyed( ThreadID threadID )
{
    try
    {
    	RemoveThread( threadID ); 
   	}
    catch ( BaseException *exception )
    {    	
    	exception->ReportFailure();
        delete exception;
        
        Failure();       	    
    }
	    

    return S_OK;
    
} // ProfilerCallback::ThreadDestroyed


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ThreadAssignedToOSThread( ThreadID managedThreadID,
                                                    DWORD osThreadID ) 
{
   	if ( managedThreadID != NULL )
	{
		if ( osThreadID != NULL )
		{
		    try
		    {
		    	UpdateOSThreadID( managedThreadID, osThreadID ); 
		   	}
		    catch ( BaseException *exception )
		    {    	
		    	exception->ReportFailure();
		        delete exception;
		        
		        Failure();       	    
		    }
		}
		else
			Failure( "ProfilerCallback::ThreadAssignedToOSThread() returned NULL OS ThreadID" );
	}
	else
		Failure( "ProfilerCallback::ThreadAssignedToOSThread() returned NULL managed ThreadID" );


    return S_OK;
    
} // ProfilerCallback::ThreadAssignedToOSThread


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::UnmanagedToManagedTransition( FunctionID functionID,
                                                        COR_PRF_TRANSITION_REASON reason )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  
	if ( reason == COR_PRF_TRANSITION_RETURN )
	{
	    try
	    {
			// you need to pop the pseudo function Id from the stack
			UpdateCallStack( functionID, POP );
	   	}
	    catch ( BaseException *exception )
	    {    	
	    	exception->ReportFailure();
	        delete exception;
	        
	        Failure();       	    
	    }
	}


    return S_OK;

} // ProfilerCallback::UnmanagedToManagedTransition


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ManagedToUnmanagedTransition( FunctionID functionID,
                                                        COR_PRF_TRANSITION_REASON reason )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  
	if ( reason == COR_PRF_TRANSITION_CALL )
	{
	    try
	    {
			// record the start of an unmanaged chain
			UpdateCallStack( NULL, PUSH );
			//
			// log tracing info if requested
			//
			if ( m_dwMode & (DWORD)TRACE )
				_LogCallTrace( NULL );
			
	   	}
	    catch ( BaseException *exception )
	    {    	
	    	exception->ReportFailure();
	        delete exception;
	        
	        Failure();       	    
	    }
	}

    return S_OK;

} // ProfilerCallback::ManagedToUnmanagedTransition


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */

static char *puthex(char *p, unsigned val)
{
    static unsigned limit[] = { 0xf, 0xff, 0xfff, 0xffff, 0xfffff, 0xffffff, 0xfffffff, 0xffffffff };
    static char hexDig[]  = "0123456789abcdef";

    *p++ = ' ';
    *p++ = '0';
    *p++ = 'x';

    int digCount = 1;
    while (val > limit[digCount-1])
        digCount++;

    p += digCount;
    int i = 0;
    do
    {
        p[--i] = hexDig[val % 16];
        val /= 16;
    }
    while (val != 0);

    return p;
}

static char *putdec(char *p, unsigned val)
{
    static unsigned limit[] = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, 0xffffffff };

    *p++ = ' ';

    int digCount = 1;
    while (val > limit[digCount-1])
        digCount++;

    p += digCount;
    int i = 0;
    do
    {
        unsigned newval = val / 10;
        p[--i] = val - newval*10 + '0';
        val = newval;
    }
    while (val != 0);

    return p;
}


static DWORD ClockTick()
{
    _asm rdtsc
}

// every CLOCK_TICK_INC machine clocks will we go to the more expensive (and more correct!)QueryPerformanceCounter()

#define CLOCK_TICK_INC    (500*1000)

void ProfilerCallback::_LogTickCount()
{
    DWORD tickCount = _GetTickCount();
    if (tickCount != m_lastTickCount)
    {
        m_lastTickCount = tickCount;
        LogToAny("i %u\n", tickCount - m_firstTickCount);
    }
    m_lastClockTick = ClockTick();
}


HRESULT ProfilerCallback::ObjectAllocated( ObjectID objectID,
                                           ClassID classID )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  
	HRESULT hr = S_OK;
	
	try
	{
		ULONG mySize = 0;
		
		hr = m_pProfilerInfo->GetObjectSize( objectID, &mySize );
		if ( SUCCEEDED( hr ) )
		{
            if (ClockTick() - m_lastClockTick >= CLOCK_TICK_INC)
                _LogTickCount();

            DWORD stackTraceId = _StackTraceId(classID, mySize);
#if 1
            char buffer[128];
            char *p = buffer;
            *p++ = 'a';
            p = puthex(p, objectID);
            p = putdec(p, stackTraceId);
            *p++ = '\n';
            fwrite(buffer, p - buffer, 1, m_stream);
#else
            LogToAny( "a 0x%x %d\n", objectID, stackTraceId );
#endif
 		}
		else
			Failure( "ERROR: ICorProfilerInfo::GetObjectSize() FAILED" );

		m_totalObjectsAllocated++;
	}
	catch ( BaseException *exception )
	{
	    exception->ReportFailure();
	    delete exception;
	   
	    Failure();    
	}    

    return S_OK;

} // ProfilerCallback::ObjectAllocated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ObjectReferences( ObjectID objectID,
                                            ClassID classID,
                                            ULONG objectRefs,
                                            ObjectID objectRefIDs[] )
{
	//
	// dump only in the following cases:
	//		case 1: if the user requested through a ForceGC or
	//		case 2: if you operate in stand-alone mode dump at all times
	//
	if (   (m_bDumpGCInfo == TRUE) 
		|| ( ( (m_dwMode & DYNOBJECT) == 0 ) && ( (m_dwMode & OBJECT) == 1) ) )
	{
		HRESULT hr = S_OK;
		ClassInfo *pClassInfo = NULL;
		
		
		// mark the fact that the callback was received
		m_bDumpCompleted = TRUE;
		
		// dump all the information properly
		hr = _InsertGCClass( &pClassInfo, classID );
		if ( SUCCEEDED( hr ) )
		{
			//
			// remember the stack trace only if you requested the class
			//
			if ( wcsstr( pClassInfo->m_className, m_classToMonitor ) != NULL )
			{
				ULONG size = 0;


				hr =  m_pProfilerInfo->GetObjectSize( objectID, &size );
				if ( SUCCEEDED( hr ) )
				{
					char refs[MAX_LENGTH];

					
					LogToAny( "o 0x%08x %d %d ", objectID, pClassInfo->m_internalID, size );
					refs[0] = NULL;
					for( ULONG i=0, index=0; i < objectRefs; i++, index++ )
					{
						char objToString[16];

						
						sprintf( objToString, "0x%08x ", objectRefIDs[i] );
						strcat( refs, objToString );
						//
						// buffer overrun control for next iteration
						// every loop adds 11 chars to the array
						//
						if ( ((index+1)*16) >= (MAX_LENGTH-1) )
						{
							LogToAny( "%s ", refs );
							refs[0] = NULL;
							index = 0;			
						}
					}
					LogToAny( "%s\n",refs );
				}
				else
					Failure( "ERROR: ICorProfilerInfo::GetObjectSize() FAILED" );
			}
		}
		else
			Failure( "ERROR: _InsertGCClass FAILED" );
	}
    else
    {
        // to stop runtime from enumerating
        return E_FAIL;
    }

    return S_OK;

} // ProfilerCallback::ObjectReferences


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RootReferences( ULONG rootRefs,
                                          ObjectID rootRefIDs[] )
{
	//
	// dump only in the following cases:
	//		case 1: if the user requested through a ForceGC or
	//		case 2: if you operate in stand-alone mode dump at all times
	//
	if (   (m_bDumpGCInfo == TRUE) 
		|| ( ( (m_dwMode & DYNOBJECT) == 0 ) && ( (m_dwMode & OBJECT) == 1) ) )
	{
		char rootsToString[MAX_LENGTH];


		// mark the fact that the callback was received
		m_bDumpCompleted = TRUE;
		
		// dump all the information properly
		LogToAny( "r " );
		rootsToString[0] = NULL;
		for( ULONG i=0, index=0; i < rootRefs; i++,index++ )
		{
			char objToString[16];

			
			sprintf( objToString, "0x%08x ", rootRefIDs[i] );
			strcat( rootsToString, objToString );
			//
			// buffer overrun control for next iteration
			// every loop adds 16 chars to the array
			//
			if ( ((index+1)*16) >= (MAX_LENGTH-1) )
			{
				LogToAny( "%s ", rootsToString );
				rootsToString[0] = NULL;			
				index = 0;
			}
		}
		LogToAny( "%s\n",rootsToString );
	}
    else
    {
        // to stop runtime from enumerating
        return E_FAIL;
    }


    return S_OK;

} // ProfilerCallback::RootReferences


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeSuspendStarted( COR_PRF_SUSPEND_REASON suspendReason )
{
	// if we are shutting down , terminate all the threads
    if ( suspendReason == COR_PRF_SUSPEND_FOR_SHUTDOWN )
	{
		//
		// cleanup the events and threads
		//
		_ShutdownAllThreads();

	}
    
    m_SuspendForGC = suspendReason == COR_PRF_SUSPEND_FOR_GC;
    if (m_SuspendForGC)
    {
    	///////////////////////////////////////////////////////////////////////////
	    Synchronize guard( m_criticalSection );
	    ///////////////////////////////////////////////////////////////////////////  

        if (ClockTick() - m_lastClockTick >= CLOCK_TICK_INC)
            _LogTickCount();
    }
    return S_OK;
    
} // ProfilerCallback::RuntimeSuspendStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeResumeFinished()
{
	//
	// identify if this is the first Object allocated callback
	// after dumping the objects as a result of a Gc and revert the state
	//
	if ( m_bDumpGCInfo == TRUE && m_bDumpCompleted == TRUE )
	{
		// reset
		m_bDumpGCInfo = FALSE;
		m_bDumpCompleted = FALSE;

        // flush the log file so the dump is complete there, too
        fflush(m_stream);

		// give a callback to the user that the GC has been completed
		SetEvent( m_hArrayCallbacks[GC_HANDLE] );
	}

    if (m_SuspendForGC)
    {
        if (m_pGCHost != NULL)
        {
            COR_GC_STATS stats;

            stats.Flags = COR_GC_COUNTS;
            HRESULT hr = m_pGCHost->GetStats(&stats);
            if (SUCCEEDED(hr))
            {
        		LogToAny( "g %d %d %d\n", stats.GenCollectionsTaken[0], stats.GenCollectionsTaken[1], stats.GenCollectionsTaken[2] );
            }
        }
        else
    		LogToAny( "g\n" );
    }

    return S_OK;
    
} // ProfilerCallback::RuntimeResumeFinished


/***************************************************************************************
 ********************                                               ********************
 ********************     Callbacks With Default Implementation     ********************
 ********************                                               ********************
 ***************************************************************************************/


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainCreationStarted( AppDomainID appDomainID )
{
    
    return S_OK;

} // ProfilerCallback::AppDomainCreationStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainCreationFinished( AppDomainID appDomainID,
													 HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::AppDomainCreationFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainShutdownStarted( AppDomainID appDomainID )
{

    return S_OK;

} // ProfilerCallback::AppDomainShutdownStarted

	  

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainShutdownFinished( AppDomainID appDomainID,
													 HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::AppDomainShutdownFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyLoadStarted( AssemblyID assemblyID )
{

    return S_OK;

} // ProfilerCallback::AssemblyLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyLoadFinished( AssemblyID assemblyID,
												HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::AssemblyLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyUnloadStarted( AssemblyID assemblyID )
{

    return S_OK;

} // ProfilerCallback::AssemblyUnLoadStarted

	  
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyUnloadFinished( AssemblyID assemblyID,
												  HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::AssemblyUnLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleLoadStarted( ModuleID moduleID )
{

    return S_OK;

} // ProfilerCallback::ModuleLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleUnloadStarted( ModuleID moduleID )
{

    return S_OK;

} // ProfilerCallback::ModuleUnloadStarted
	  

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleUnloadFinished( ModuleID moduleID,
												HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::ModuleUnloadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleAttachedToAssembly( ModuleID moduleID,
													AssemblyID assemblyID )
{

    return S_OK;

} // ProfilerCallback::ModuleAttachedToAssembly


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassLoadStarted( ClassID classID )
{

    return S_OK;

} // ProfilerCallback::ClassLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassLoadFinished( ClassID classID, 
											 HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::ClassLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassUnloadStarted( ClassID classID )
{

    return S_OK;

} // ProfilerCallback::ClassUnloadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassUnloadFinished( ClassID classID, 
											   HRESULT hrStatus )
{

    return S_OK;

} // ProfilerCallback::ClassUnloadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::FunctionUnloadStarted( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::FunctionUnloadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITFunctionPitched( FunctionID functionID )
{
    
    return S_OK;
    
} // ProfilerCallback::JITFunctionPitched


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITInlining( FunctionID callerID,
                                       FunctionID calleeID,
                                       BOOL *pfShouldInline )
{

    return S_OK;

} // ProfilerCallback::JITInlining


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientInvocationStarted()
{

    return S_OK;
    
} // ProfilerCallback::RemotingClientInvocationStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientSendingMessage( GUID *pCookie,
    													BOOL fIsAsync )
{

    return S_OK;
    
} // ProfilerCallback::RemotingClientSendingMessage


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientReceivingReply(	GUID *pCookie,
	    												BOOL fIsAsync )
{

    return S_OK;
    
} // ProfilerCallback::RemotingClientReceivingReply


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientInvocationFinished()
{

   return S_OK;
    
} // ProfilerCallback::RemotingClientInvocationFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerReceivingMessage( GUID *pCookie,
    													  BOOL fIsAsync )
{

    return S_OK;
    
} // ProfilerCallback::RemotingServerReceivingMessage


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerInvocationStarted()
{

    return S_OK;
    
} // ProfilerCallback::RemotingServerInvocationStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerInvocationReturned()
{

    return S_OK;
    
} // ProfilerCallback::RemotingServerInvocationReturned


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerSendingReply( GUID *pCookie,
    												  BOOL fIsAsync )
{

    return S_OK;

} // ProfilerCallback::RemotingServerSendingReply


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeSuspendFinished()
{

    return S_OK;
    
} // ProfilerCallback::RuntimeSuspendFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeSuspendAborted()
{

    return S_OK;
    
} // ProfilerCallback::RuntimeSuspendAborted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeResumeStarted()
{

    return S_OK;
    
} // ProfilerCallback::RuntimeResumeStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeThreadSuspended( ThreadID threadID )
{

    return S_OK;
    
} // ProfilerCallback::RuntimeThreadSuspended


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RuntimeThreadResumed( ThreadID threadID )
{

    return S_OK;
    
} // ProfilerCallback::RuntimeThreadResumed


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::MovedReferences( ULONG cmovedObjectIDRanges,
                                           ObjectID oldObjectIDRangeStart[],
                                           ObjectID newObjectIDRangeStart[],
                                           ULONG cObjectIDRangeLength[] )
{
	///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

    for (ULONG i = 0; i < cmovedObjectIDRanges; i++)
    {
        LogToAny("u 0x%08x 0x%08x %u\n", oldObjectIDRangeStart[i], newObjectIDRangeStart[i], cObjectIDRangeLength[i]);
    }

    return S_OK;

} // ProfilerCallback::MovedReferences


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ObjectsAllocatedByClass( ULONG classCount,
                                                   ClassID classIDs[],
                                                   ULONG objects[] )
{

    return S_OK;

} // ProfilerCallback::ObjectsAllocatedByClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionThrown( ObjectID thrownObjectID )
{

    return S_OK;

} // ProfilerCallback::ExceptionThrown 


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFunctionEnter( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionSearchFunctionEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFunctionLeave()
{

    return S_OK;

} // ProfilerCallback::ExceptionSearchFunctionLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFilterEnter( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionSearchFilterEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFilterLeave()
{

    return S_OK;

} // ProfilerCallback::ExceptionSearchFilterLeave 


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchCatcherFound( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionSearchCatcherFound


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCLRCatcherFound()
{
    return S_OK;
}

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCLRCatcherExecute()
{
    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionOSHandlerEnter( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionOSHandlerEnter

    
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionOSHandlerLeave( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionOSHandlerLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFinallyEnter( FunctionID functionID )
{

    return S_OK;

} // ProfilerCallback::ExceptionUnwindFinallyEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFinallyLeave()
{

    return S_OK;

} // ProfilerCallback::ExceptionUnwindFinallyLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCatcherEnter( FunctionID functionID,
    											 ObjectID objectID )
{

    return S_OK;

} // ProfilerCallback::ExceptionCatcherEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCatcherLeave()
{

    return S_OK;

} // ProfilerCallback::ExceptionCatcherLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::COMClassicVTableCreated( ClassID wrappedClassID,
                                                   REFGUID implementedIID,
                                                   void *pVTable,
                                                   ULONG cSlots )
{

    return S_OK;

} // ProfilerCallback::COMClassicWrapperCreated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::COMClassicVTableDestroyed( ClassID wrappedClassID,
                                                     REFGUID implementedIID,
                                                     void *pVTable )
{

    return S_OK;

} // ProfilerCallback::COMClassicWrapperDestroyed


/***************************************************************************************
 ********************                                               ********************
 ********************              Private Functions	            ********************
 ********************                                               ********************
 ***************************************************************************************/ 

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::_ProcessEnvVariables()
{
    DWORD mask1;
	DWORD mask2;
	char buffer[4*MAX_LENGTH];
    

	//
	// mask for everything
	//
	m_dwEventMask =  (DWORD) COR_PRF_MONITOR_GC
				   | (DWORD) COR_PRF_MONITOR_THREADS
				   | (DWORD) COR_PRF_MONITOR_SUSPENDS
				   | (DWORD) COR_PRF_MONITOR_ENTERLEAVE
				   | (DWORD) COR_PRF_MONITOR_EXCEPTIONS
				   | (DWORD) COR_PRF_MONITOR_MODULE_LOADS
			       | (DWORD) COR_PRF_MONITOR_CACHE_SEARCHES
				   | (DWORD) COR_PRF_ENABLE_OBJECT_ALLOCATED 
				   | (DWORD) COR_PRF_MONITOR_JIT_COMPILATION
				   | (DWORD) COR_PRF_MONITOR_OBJECT_ALLOCATED
				   | (DWORD) COR_PRF_MONITOR_CODE_TRANSITIONS;

	//
	// read the mode under which the tool is going to operate
	//
 	buffer[0] = '\0';
 	if ( GetEnvironmentVariableA( OMV_USAGE, buffer, MAX_LENGTH ) > 0 )
   	{
		if ( _stricmp( "objects", buffer ) == 0 )
		{
			m_bTrackingObjects = TRUE;
			m_dwMode = (DWORD)OBJECT;	
		}
		else if ( _stricmp( "trace", buffer ) == 0 )
		{
			//
			// mask for call graph, remove GC and OBJECT ALLOCATIONS
			//
			m_dwEventMask = m_dwEventMask ^(DWORD) ( COR_PRF_MONITOR_GC 
												   | COR_PRF_MONITOR_OBJECT_ALLOCATED
												   | COR_PRF_ENABLE_OBJECT_ALLOCATED );
			m_dwMode = (DWORD)TRACE;
		}
		else if ( _stricmp( "both", buffer ) == 0 )
		{
			m_bTrackingObjects = TRUE;
			m_dwMode = (DWORD)BOTH;	
		}
		else
		{
			printf( "**** No Profiling Will Take place **** \n" );
			m_dwEventMask = (DWORD) COR_PRF_MONITOR_NONE;			
		}
	}


	//
	// look if the user specified another path to save the output file
	//
 	buffer[0] = '\0';
 	if ( GetEnvironmentVariableA( OMV_PATH, buffer, MAX_LENGTH ) > 0 )
   	{
		m_path = new char[ARRAYSIZE(buffer)+ARRAYSIZE(m_logFileName)+1];
		if ( m_path != NULL )
			sprintf( m_path, "%s\\%s", buffer, m_logFileName );	
	}
	
    if ( m_dwMode & (DWORD)TRACE)
		m_bIsTrackingStackTrace = TRUE;

    //
	// look further for env settings if operating under OBJECT mode
	//
	if ( m_dwMode & (DWORD)OBJECT )
	{
		//
		// check if the user is going to dynamically enable
		// object tracking
		//
	 	buffer[0] = '\0';
	 	if ( GetEnvironmentVariableA( OMV_DYNAMIC, buffer, MAX_LENGTH ) > 0 )
	   	{
			//
			// do not track object when you start up, activate the thread that
			// is going to listen for the event
			//
			m_dwEventMask = m_dwEventMask ^ (DWORD) COR_PRF_MONITOR_OBJECT_ALLOCATED;
			m_bTrackingObjects = FALSE;
			m_dwMode = m_dwMode | (DWORD)DYNOBJECT;
		}		
		

		//
		// check to see if the user requires stack trace
		//
		DWORD value1 = BASEHELPER::FetchEnvironment( OMV_STACK );

		if ( (value1 != 0x0) && (value1 != 0xFFFFFFFF) )
		{
			m_bIsTrackingStackTrace = TRUE;
			m_dwEventMask = m_dwEventMask
		 					| (DWORD) COR_PRF_MONITOR_ENTERLEAVE
		 					| (DWORD) COR_PRF_MONITOR_EXCEPTIONS
							| (DWORD) COR_PRF_MONITOR_CODE_TRANSITIONS;
		
			//
			// decide how many frames to print
			//
			m_dwFramesToPrint = BASEHELPER::FetchEnvironment( OMV_FRAMENUMBER );

		}

	 	//
		// how many objects you wish to skip
		//
	 	DWORD dwTemp = BASEHELPER::FetchEnvironment( OMV_SKIP );
	 	m_dwSkipObjects = ( dwTemp != 0xFFFFFFFF ) ? dwTemp : 0;


	 	//
		// in which class you are interested in
		//
	 	buffer[0] = '\0';
	 	GetEnvironmentVariableA( OMV_CLASS, buffer, MAX_LENGTH );

		//
		// if the env variable does not exist copy to it the null
		// string otherwise copy its value
		//
		m_classToMonitor = new WCHAR[ARRAYSIZE(buffer) + 1];
		if ( m_classToMonitor != NULL )
		{
			swprintf( m_classToMonitor, L"%S", buffer );
		}
		else
		{
			//
			// some error has happened, do not monitor anything
			//
			printf( "Memory Allocation Error in ProfilerCallback .ctor\n" );
			printf( "**** No Profiling Will Take place **** \n" );
			m_dwEventMask = (DWORD) COR_PRF_MONITOR_NONE;			
		}
	}	

} // ProfilerCallback::_ProcessEnvVariables


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::_InitializeThreadsAndEvents()
{
	HRESULT hr = S_OK;


	//
	// GC and Dynamic Object triggering 
	//	Step 1. set up the IPC event
	//  Step 2. set up the IPC callback event
	//	Step 3. set up the thread
	//
	for ( DWORD i=GC_HANDLE; i<SENTINEL_HANDLE; i++ )
	{
		
		// Step 1
		m_hArray[i] = OpenEventA( EVENT_ALL_ACCESS,	 // access
								  FALSE,			 // do not inherit
								  m_NamedEvents[i] ); // event name
		if ( m_hArray[i] == NULL )
		{
			TEXT_OUTLN( "WARNING: OpenEvent() FAILED Will Attempt CreateEvent()" )
			m_hArray[i] = CreateEventA( NULL,   // Not inherited
									    TRUE,   // manual reset type
									    FALSE,  // initial signaling state
									    m_NamedEvents[i] ); // event name
			if ( m_hArray[i] == NULL )
			{
				TEXT_OUTLN( "CreateEvent() Attempt FAILED" )
				hr = E_FAIL;
				break;
			}
		}
		
		// Step 2
		m_hArrayCallbacks[i] = OpenEventA( EVENT_ALL_ACCESS,	// access
										   FALSE,				// do not inherit
										   m_CallbackNamedEvents[i] ); // event name
		if ( m_hArrayCallbacks[i] == NULL )
		{
			TEXT_OUTLN( "WARNING: OpenEvent() FAILED Will Attempt CreateEvent()" )
			m_hArrayCallbacks[i] = CreateEventA( NULL,   				   // Not inherited
									    		 TRUE,   				   // manual reset type
									    		 FALSE,  				   // initial signaling state
									    		 m_CallbackNamedEvents[i] ); // event name
			if ( m_hArrayCallbacks[i] == NULL )
			{
				TEXT_OUTLN( "CreateEvent() Attempt FAILED" )
				hr = E_FAIL;
				break;
			}
		}
			
		// Step 3
	    m_hThreads[i] = ::CreateThread( NULL,  				  						 // security descriptor, NULL is not inherited 
	    							    0,	 				  						 // stack size	 
	    							    (LPTHREAD_START_ROUTINE) ThreadStubArray[i], // start function pointer 
	    							    (void *) this, 								 // parameters for the function
	    							    THREAD_PRIORITY_NORMAL, 					 // priority 
	    							    &m_dwWin32ThreadIDs[i] );					 // Win32threadID
		if ( m_hThreads[i] == NULL )
		{
			hr = E_FAIL;
			TEXT_OUTLN( "ERROR: CreateThread() FAILED" )
			break;
		}

	}	

	return hr;

} // ProfilerCallback::_InitializeThreadsAndEvents


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::_InitializeNamesForEventsAndCallbacks()
{
	HRESULT hr = S_OK;


	for ( DWORD i=GC_HANDLE; ( (i<SENTINEL_HANDLE) && SUCCEEDED(hr) ); i++ )
	{
		//
		// initialize
		//
		m_NamedEvents[i] = NULL;
		m_CallbackNamedEvents[i] = NULL;


		//
		// allocate space
		//
#ifdef _MULTIPLE_PROCESSES
		m_NamedEvents[i] = new char[strlen(NamedEvents[i]) + 1 + 9];
		m_CallbackNamedEvents[i] = new char[strlen(CallbackNamedEvents[i])+1+9];
#else
		m_NamedEvents[i] = new char[strlen(NamedEvents[i]) + 1];
		m_CallbackNamedEvents[i] = new char[strlen(CallbackNamedEvents[i])+1];
#endif

		if ( (m_NamedEvents[i] != NULL) && (m_CallbackNamedEvents[i] != NULL) )
		{
#ifdef _MULTIPLE_PROCESSES
	
			sprintf( m_NamedEvents[i], "%s_%08x%", NamedEvents[i], m_dwProcessId );
			sprintf( m_CallbackNamedEvents[i], "%s_%08x%", CallbackNamedEvents[i], m_dwProcessId );
#else
	
			sprintf( m_NamedEvents[i], "%s", NamedEvents[i] );
			sprintf( m_CallbackNamedEvents[i], "%s", CallbackNamedEvents[i] );
#endif
		}
		else
			hr = E_FAIL;
	}

	//
	//	report the allocation error
	//
	if ( FAILED( hr ) )
		Failure( "ERROR: Allocation Failure" );


	return hr;

} // ProfilerCallback::_InitializeNamesForEventsAndCallbacks


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::_ShutdownAllThreads()
{
	//
	// mark that we are shutting down
	//
	m_bShutdown = TRUE;

	//
	// look for the named events and reset them if they are set
	// notify the GUI and signal to the threads to shutdown
	//
	for ( DWORD i=GC_HANDLE; i<SENTINEL_HANDLE; i++ )
	{
		SetEvent( m_hArray[i] );		
	}
	
	//
	// wait until you receive the autoreset event from the threads
	// that they have shutdown successfully
	//
	DWORD waitResult = WaitForMultipleObjectsEx( (DWORD)SENTINEL_HANDLE, // number of handles in array
											     m_hThreads,    		 // object-handle array
											  	 TRUE,            		 // wait for all
											  	 INFINITE,     			 // wait for ever
											  	 FALSE );       		 // alertable option
	if ( waitResult == WAIT_FAILED )
		LogToAny( "Error While Shutting Down Helper Threads: 0x%08x\n", GetLastError() );		
	

	//
	// loop through and close all the handles, we are done !
	//	
	for ( DWORD i=GC_HANDLE; i<SENTINEL_HANDLE; i++ )
	{
		if ( CloseHandle( m_hArray[i] ) == FALSE )
			LogToAny( "Error While Executing CloseHandle: 0x%08x\n", GetLastError() );		
		m_hArray[i] = NULL;

		
		if ( CloseHandle( m_hArrayCallbacks[i] ) == FALSE )
			LogToAny( "Error While Executing CloseHandle: 0x%08x\n", GetLastError() );		
		m_hArrayCallbacks[i] = NULL;
		

		if ( CloseHandle( m_hThreads[i] ) == FALSE )
			LogToAny( "Error While Executing CloseHandle: 0x%08x\n", GetLastError() );		
		m_hThreads[i] = NULL;

	}

} // ProfilerCallback::_ShutdownAllThreads
  

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::_InsertGCClass( ClassInfo **ppClassInfo, ClassID classID )
{
	HRESULT hr = S_OK;


	*ppClassInfo = m_pClassTable->Lookup( classID );
	if ( *ppClassInfo == NULL )
	{
		*ppClassInfo = new ClassInfo( classID );
		if ( *ppClassInfo != NULL )
		{
			//
			// we have 2 cases
			// case 1: class is an array
			// case 2: class is a real class
			//
			ULONG rank = 0;
	   		CorElementType elementType;
			ClassID realClassID = NULL;
			WCHAR ranks[MAX_LENGTH];


			// case 1 
			hr = m_pProfilerInfo->IsArrayClass( classID, &elementType, &realClassID, &rank );
			if ( hr == S_OK )
			{
				ClassID prevClassID;


				_ASSERT_( realClassID != NULL );
				ranks[0] = '\0';
				do
				{
					prevClassID = realClassID;
					swprintf( ranks, L"%s[]", ranks, rank );
					hr = m_pProfilerInfo->IsArrayClass( prevClassID, &elementType, &realClassID, &rank );
					if ( (hr == S_FALSE) || (FAILED(hr)) || (realClassID == NULL) )
					{
						//
						// before you break set the realClassID to the value that it was before the 
						// last unsuccessful call
						//
						if ( realClassID != NULL )
							realClassID = prevClassID;
						
						break;
					}
				}
				while ( TRUE );
				
				if ( SUCCEEDED( hr ) )
				{
					WCHAR className[10 * MAX_LENGTH];
					
					
					className[0] = '\0';
					if ( realClassID != NULL )
						hr = GetNameFromClassID( realClassID, className );
					else
						hr = _HackBogusClassName( elementType, className );
					
		            
					if ( SUCCEEDED( hr ) )
					{
		 				swprintf( (*ppClassInfo)->m_className, L"%s %s",className, ranks  );
						(*ppClassInfo)->m_objectsAllocated++;
						(*ppClassInfo)->m_internalID = m_totalClasses;
						m_pClassTable->AddEntry( *ppClassInfo, classID );
						LogToAny( "t %d %S\n",(*ppClassInfo)->m_internalID,(*ppClassInfo)->m_className );
					}
					else
						Failure( "ERROR: PrfHelper::GetNameFromClassID() FAILED" );
				}
				else
					Failure( "ERROR: Looping for Locating the ClassID FAILED" );
			}
			// case 2
			else if ( hr == S_FALSE )
			{
				hr = GetNameFromClassID( classID, (*ppClassInfo)->m_className );
				if ( SUCCEEDED( hr ) )
				{
					(*ppClassInfo)->m_objectsAllocated++;
					(*ppClassInfo)->m_internalID = m_totalClasses;
					m_pClassTable->AddEntry( *ppClassInfo, classID );
					LogToAny( "t %d %S\n",(*ppClassInfo)->m_internalID,(*ppClassInfo)->m_className );
				}				
				else
					Failure( "ERROR: PrfHelper::GetNameFromClassID() FAILED" );
			}
			else
				Failure( "ERROR: ICorProfilerInfo::IsArrayClass() FAILED" );
		}
		else
			Failure( "ERROR: Allocation for ClassInfo FAILED" );	

		InterlockedIncrement( &m_totalClasses );
	}
	else
		(*ppClassInfo)->m_objectsAllocated++;
		
	
	return hr;

} // ProfilerCallback::_InsertGCClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
HRESULT ProfilerCallback::_AddGCObject( BOOL bForce )
{
	HRESULT hr = E_FAIL;
	ThreadID threadID = NULL;

	//
	// if you are not monitoring stack trace, do not even bother
	//
	if ( (m_bIsTrackingStackTrace == FALSE) && (bForce == FALSE) )
		return S_OK;


	hr = m_pProfilerInfo->GetCurrentThreadID( &threadID );
	if ( SUCCEEDED(hr  ) )
	{
		ThreadInfo *pThreadInfo = GetThreadInfo( threadID );


		if ( pThreadInfo != NULL )
		{
			ULONG count = 0;
			
			
			count = (pThreadInfo->m_pThreadCallStack)->Count();
			if 	( count != 0 )
			{
				//
				// dump the stack when the object was allocated
				//
				ULONG threshold = count;


				//
				// calculate the theshold above which you log the stack trace
				//
				if ( m_dwFramesToPrint == 0xFFFFFFFF )
					threshold = 0;
				
				else if ( count<m_dwFramesToPrint )
					threshold = 0;
				
				else
					threshold = count - m_dwFramesToPrint;

	  			for ( DWORD frame = (DWORD)threshold; frame < (DWORD)count; frame++ )
				{
					ULONG stackElement = 0;
					FunctionInfo *pFunctionInfo = NULL;
					
					
					stackElement = (pThreadInfo->m_pThreadCallStack)->m_Array[frame];
					pFunctionInfo = m_pFunctionTable->Lookup( stackElement );
					if ( pFunctionInfo != NULL )
						LogToAny( "%d ", pFunctionInfo->m_internalID );
					else
						Failure( "ERROR: Function Not Found In Function Table" );

				} // end while loop
			}
			else
            {
                LogToAny( "-1 "); /*empty stack is marked as -1*/	
            }
		}
		else 				
			Failure( "ERROR: Thread Structure was not found in the thread list" );
	}
	else
		Failure( "ERROR: ICorProfilerInfo::GetCurrentThreadID() FAILED" );

  	
	return hr;

} // ProfilerCallback::_AddGCObject


DWORD ProfilerCallback::_StackTraceId(int typeId, int typeSize)
{
	ThreadID threadID = NULL;

	//
	// if you are not monitoring stack trace, do not even bother
	//
	if (m_bIsTrackingStackTrace == FALSE)
		return 0;

	HRESULT hr = m_pProfilerInfo->GetCurrentThreadID( &threadID );
	if ( SUCCEEDED(hr  ) )
	{
		ThreadInfo *pThreadInfo = GetThreadInfo( threadID );


		if ( pThreadInfo != NULL )
		{
			DWORD count = pThreadInfo->m_pThreadCallStack->Count();
            StackTrace stackTrace(count, pThreadInfo->m_pThreadCallStack->m_Array, typeId, typeSize);
            StackTraceInfo *stackTraceInfo = pThreadInfo->m_pLatestStackTraceInfo;
            if (stackTraceInfo != NULL && stackTraceInfo->Compare(stackTrace) == TRUE)
                return stackTraceInfo->m_internalId;

            stackTraceInfo = m_pStackTraceTable->Lookup(stackTrace);
            if (stackTraceInfo != NULL)
            {
                pThreadInfo->m_pLatestStackTraceInfo = stackTraceInfo;
                return stackTraceInfo->m_internalId;
            }

            stackTraceInfo = new StackTraceInfo(++m_callStackCount, count, pThreadInfo->m_pThreadCallStack->m_Array, typeId, typeSize);
            pThreadInfo->m_pLatestStackTraceInfo = stackTraceInfo;
            m_pStackTraceTable->AddEntry(stackTraceInfo, stackTrace);

            ClassInfo *pClassInfo = NULL;
            if (typeId != 0 && typeSize != 0)
            {
                hr = _InsertGCClass( &pClassInfo, typeId );
	            if ( !SUCCEEDED( hr ) )
            	    Failure( "ERROR: _InsertGCClass() FAILED" );
            }

            LogToAny("s %d", m_callStackCount);

            if (typeId != 0 && typeSize != 0)
            {
                LogToAny(" %d %d", pClassInfo->m_internalID, typeSize);
            }

	  		for (DWORD frame = 0; frame < count; frame++ )
			{				
				ULONG stackElement = (pThreadInfo->m_pThreadCallStack)->m_Array[frame];
				FunctionInfo *pFunctionInfo = m_pFunctionTable->Lookup( stackElement );
				if ( pFunctionInfo != NULL )
					LogToAny( " %d", pFunctionInfo->m_internalID );
				else
					Failure( "ERROR: Function Not Found In Function Table" );
			} // end for loop
            LogToAny("\n");

            return stackTraceInfo->m_internalId;
		}
		else 				
			Failure( "ERROR: Thread Structure was not found in the thread list" );
	}
	else
		Failure( "ERROR: ICorProfilerInfo::GetCurrentThreadID() FAILED" );

  	
	return 0;

} // ProfilerCallback::_StackTraceId


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
HRESULT ProfilerCallback::_LogCallTrace( FunctionID functionID )
{
    ///////////////////////////////////////////////////////////////////////////
	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

    HRESULT hr = E_FAIL;
	ThreadID threadID = NULL;


	hr = m_pProfilerInfo->GetCurrentThreadID( &threadID );
	if ( SUCCEEDED( hr ) )
	{
		ThreadInfo *pThreadInfo = GetThreadInfo( threadID );


		if ( pThreadInfo != NULL )
		{
            DWORD stackTraceId = _StackTraceId();
#if 1
            char buffer[128];
            char *p = buffer;
            *p++ = 'c';
            p = putdec(p, pThreadInfo->m_win32ThreadID);
            p = putdec(p, stackTraceId);
            *p++ = '\n';
            fwrite(buffer, p - buffer, 1, m_stream);
#else
			LogToAny( "c %d %d\n", pThreadInfo->m_win32ThreadID, stackTraceId );
#endif
		}
		else 				
			Failure( "ERROR: Thread Structure was not found in the thread list" );
	}
	else
		Failure( "ERROR: ICorProfilerInfo::GetCurrentThreadID() FAILED" );

  	
	return hr;

} // ProfilerCallback::_LogCallTrace


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
HRESULT ProfilerCallback::_HackBogusClassName( CorElementType elementType, WCHAR *buffer )
{
	HRESULT hr = S_OK;

	switch ( elementType )
	{
		case ELEMENT_TYPE_BOOLEAN:
			 swprintf( buffer, L"System.Boolean" );
			 break;


		case ELEMENT_TYPE_CHAR:
			 swprintf( buffer, L"System.Char" );
			 break;


		case ELEMENT_TYPE_I1:
			 swprintf( buffer, L"System.SByte" );
			 break;


		case ELEMENT_TYPE_U1:
			 swprintf( buffer, L"System.Byte" );
			 break;


		case ELEMENT_TYPE_I2:
			 swprintf( buffer, L"System.Int16" );
			 break;


		case ELEMENT_TYPE_U2:
			 swprintf( buffer, L"System.UInt16" );
			 break;


		case ELEMENT_TYPE_I4:
			 swprintf( buffer, L"System.Int32" );
			 break;


		case ELEMENT_TYPE_U4:
			 swprintf( buffer, L"System.UInt32" );
			 break;


		case ELEMENT_TYPE_I8:
			 swprintf( buffer, L"System.Int64" );
			 break;


		case ELEMENT_TYPE_U8:
			 swprintf( buffer, L"System.UInt64" );
			 break;


		case ELEMENT_TYPE_R4:
			 swprintf( buffer, L"System.Single" );
			 break;


		case ELEMENT_TYPE_R8:
			 swprintf( buffer, L"System.Double" );
			 break;


		case ELEMENT_TYPE_STRING:
			 swprintf( buffer, L"System.String" );
			 break;


		case ELEMENT_TYPE_PTR:
			 swprintf( buffer, L"System.IntPtr" );
			 break;


		case ELEMENT_TYPE_VALUETYPE:
			 swprintf( buffer, L"System.Hashtable.Bucket" );
			 break;


		case ELEMENT_TYPE_CLASS:
			 swprintf( buffer, L"class" );
			 break;


		case ELEMENT_TYPE_ARRAY:
			 swprintf( buffer, L"System.Array" );
			 break;


		case ELEMENT_TYPE_I:
			 swprintf( buffer, L"int" );
			 break;


		case ELEMENT_TYPE_U:
			 swprintf( buffer, L"uint" );
			 break;


		case ELEMENT_TYPE_OBJECT:
			 swprintf( buffer, L"System.Object" );
			 break;


		case ELEMENT_TYPE_SZARRAY:
			 swprintf( buffer, L"System.Array" );
			 break;


		case ELEMENT_TYPE_MAX:
		case ELEMENT_TYPE_END:
		case ELEMENT_TYPE_VOID:
		case ELEMENT_TYPE_FNPTR:
		case ELEMENT_TYPE_BYREF:
		case ELEMENT_TYPE_PINNED:
		case ELEMENT_TYPE_SENTINEL:
		case ELEMENT_TYPE_CMOD_OPT:
		case ELEMENT_TYPE_MODIFIER:
		case ELEMENT_TYPE_CMOD_REQD:
		case ELEMENT_TYPE_TYPEDBYREF:
		default:
			 swprintf( buffer, L"<UNKNOWN>" );
	}


	return hr;

} // ProfilerCallback::_HackBogusClassName


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::LogToAny( char *format, ... )
{
	///////////////////////////////////////////////////////////////////////////
//	Synchronize guard( m_criticalSection );
	///////////////////////////////////////////////////////////////////////////  

	va_list args;
	va_start( args, format );        
    vfprintf( m_stream, format, args );

} // ProfilerCallback::LogToAny


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::_ThreadStubWrapper( ObjHandles type )
{
  	//
	// loop and listen for a ForceGC event
	//
  	while( TRUE )
	{
		DWORD dwResult;
		
		
		//
		// wait until someone signals an event from the GUI or the profiler
		//
		dwResult = WaitForSingleObject( m_hArray[type], INFINITE );
		if ( dwResult == WAIT_OBJECT_0 )
		{
			///////////////////////////////////////////////////////////////////////////
			Synchronize guard( g_criticalSection );
			///////////////////////////////////////////////////////////////////////////  

			//
			// reset the event
			//
			ResetEvent( m_hArray[type] );

			//
			// FALSE: indicates a ForceGC event arriving from the GUI
			// TRUE: indicates that the thread has to terminate
			// in both cases you need to send to the GUI an event to let it know
			// what the deal is
			//
			if ( m_bShutdown == FALSE )
			{
				//
				// what type do you have ?
				//
				switch( type )
				{
					case GC_HANDLE:
						//
						// force the GC and do not worry about the result
						//
						if ( m_pProfilerInfo != NULL )
						{
							// dump the GC info on the next GC
							m_bDumpGCInfo = TRUE;
							m_pProfilerInfo->ForceGC();
						}
						break;
					
					case OBJ_HANDLE:
						//
						// you need to update the set event mask, given the previous state
						//
						if ( m_pProfilerInfo != NULL )
						{
							if ( m_bTrackingObjects == FALSE )
							{
								// Turning object stuff on
								m_dwEventMask = m_dwEventMask | (DWORD) COR_PRF_MONITOR_OBJECT_ALLOCATED;
							}
							else
							{
								// Turning object stuff off
								m_dwEventMask = m_dwEventMask ^ (DWORD) COR_PRF_MONITOR_OBJECT_ALLOCATED;
							}
							
							//
							// revert the bool flag and set the bit
							//
							m_bTrackingObjects = !m_bTrackingObjects;
							m_pProfilerInfo->SetEventMask( m_dwEventMask );
			                
			                // flush the log file
			                fflush(m_stream);

						}						
						break;
					
					case CALL_HANDLE:
						{
							// turn off or on the logging by reversing the previous option
							if ( m_dwMode & (DWORD)TRACE )
							{
								// turn off
								m_dwMode = m_dwMode ^(DWORD)TRACE;
							}
							else
							{
								// turn on
								m_dwMode = m_dwMode | (DWORD)TRACE;
							} 

			                // flush the log file
			                fflush(m_stream);
						}
						break;
					
					
					default:
						_ASSERT_( !"Valid Option" );
				}

				// notify the GUI, if the request was for GC notify later
				if ( type != GC_HANDLE )
					SetEvent( m_hArrayCallbacks[type] );
			}
			else
			{
				//
				// Terminate
				//
				
				// notify the GUI
				SetEvent( m_hArrayCallbacks[type] );
				break;
			}

		}
		else
		{
			Failure( " WaitForSingleObject TimedOut " );
			break;
		} 
	}

} // ProfilerCallback::_ThreadStubWrapper


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::_ConnectToUI()
{
    HRESULT hr = S_OK;
 

	// Try to open a named pipe; wait for it, if necessary. 
	while (1) 
	{ 
		m_hPipe = CreateFileA( OMV_PIPE_NAME,   				// pipe name 
	    					  GENERIC_READ |  GENERIC_WRITE,	// read and write access 
					          0,              					// no sharing 
					          NULL,           					// no security attributes
	     					  OPEN_EXISTING,  					// opens existing pipe 
					          0,              					// default attributes 
					          NULL );          					// no template file 

		// Break if the pipe handle is valid. 
		if ( m_hPipe != INVALID_HANDLE_VALUE ) 
			break; 

	  	// Exit if an error other than ERROR_PIPE_BUSY occurs. 
	  	if ( GetLastError() == ERROR_PIPE_BUSY )
	  	{
		  	// All pipe instances are busy, so wait 3 minutes and then bail out
		  	if ( !WaitNamedPipeA( OMV_PIPE_NAME, 180000 ) )
		    	hr = E_FAIL;
		}
	  	else
	    	hr = E_FAIL;

		if ( FAILED( hr ) )
		{
	    	TEXT_OUTLN( "Warning: Could Not Open Pipe" )
			break;
		}
	} 
 
	if ( SUCCEEDED( hr ) )
	{
		DWORD dwMode; 
		BOOL fSuccess; 


		// The pipe connected; change to message-read mode. 
		dwMode = PIPE_READMODE_MESSAGE; 
		fSuccess = SetNamedPipeHandleState( m_hPipe,   // pipe handle 
      										&dwMode,   // new pipe mode 
									      	NULL,      // don't set maximum bytes 
									      	NULL);     // don't set maximum time 
		if ( fSuccess == TRUE )
		{
			DWORD cbWritten;
			LPVOID lpvMessage; 
			char processIDString[BYTESIZE+1];


		    // Send a message to the pipe server. 
		    sprintf( processIDString, "%08x", m_dwProcessId );
		    lpvMessage = processIDString; 
		    fSuccess = WriteFile( m_hPipe,	 			  		 // pipe handle 
		      					  lpvMessage, 			  		 // message 
		      					  strlen((char*)lpvMessage) + 1, // message length 
		      					  &cbWritten,             		 // bytes written 
		      					  NULL );                 		 // not overlapped 
		    if ( fSuccess == TRUE )
		    {
				DWORD cbRead; 
				 
				
				//
				// Read from the pipe the server's reply
				//
				do 
				{ 
					// Read from the pipe. 
					fSuccess = ReadFile( m_hPipe,   		// pipe handle 
										 m_logFileName,    	// buffer to receive reply 
										 MAX_LENGTH,      	// size of buffer 
										 &cbRead,  			// number of bytes read 
										 NULL );    		// not overlapped 
					
					if ( (!fSuccess) && (GetLastError() != ERROR_MORE_DATA) ) 
						break; 

					// Make sure that the UI received some information 
					if ( (cbRead == 0) || m_logFileName[0] == NULL )
					{
						//
						// there is an error here ...
						//
				    	TEXT_OUTLN( "WARNING: FileName Was Not properly Read By The UI Will Use Default" )
#ifdef _MULTIPLE_PROCESSES
						sprintf( m_logFileName, "pipe_%08x.log", m_dwProcessId );
#endif
						break;
					}
                    printf("Log file name transmitted from UI is: %s\n", m_logFileName);
				}
				while ( !fSuccess );  // repeat loop if ERROR_MORE_DATA 
							
		    }
		    else
		    	TEXT_OUTLN( "Win32 WriteFile() FAILED" ); 
		}
		else 
			TEXT_OUTLN( "Win32 SetNamedPipeHandleState() FAILED" ) 
	}
		

	if ( m_hPipe != NULL )
   		CloseHandle( m_hPipe ); 


} // ProfilerCallback::_ConnectToUI


/***************************************************************************************
 ********************                                               ********************
 ********************              DllMain/ClassFactory             ********************
 ********************                                               ********************
 ***************************************************************************************/ 
#include "dllmain.hpp"

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\profilerinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerInfo.h
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __PROFILER_INFO_H__
#define __PROFILER_INFO_H__

#define ARRAYSIZE(a) (sizeof a / sizeof a[0] )

#define FILENAME "Pipe.log"
#define BYTESIZE 8

//
// env variables
//
#define OMV_PATH "OMV_PATH"
#define OMV_SKIP  "OMV_SKIP"
#define OMV_CLASS "OMV_CLASS"
#define OMV_STACK "OMV_STACK"
#define OMV_USAGE  "OMV_USAGE"
#define OMV_FRAMENUMBER "OMV_FRAMES"
#define OMV_DYNAMIC "OMV_DynamicObjectTracking"

/***************************************************************************************
 ********************                                               ********************
 ********************              Enum Definitions                 ********************
 ********************                                               ********************
 ***************************************************************************************/
//
// enums
//
enum Operation
{ 
	OBJECT	= 0x1,
	TRACE	= 0x2, 
	BOTH	= 0x3,
	DYNOBJECT = 0x4,
};


enum StackAction
{ 
	PUSH, 
	POP, 
};


enum ObjHandles
{ 
	GC_HANDLE = 0, 
	OBJ_HANDLE = 1,
	CALL_HANDLE = 2,
	SENTINEL_HANDLE = 3, 
};

/***************************************************************************************
 ********************                                               ********************
 ********************                   LightStack	                ********************
 ********************                                               ********************
 ***************************************************************************************/

//
// This stack is lightweight, uses an array to store simple ULONGS and it does not have
// critical section locking. It is supposed to be used from areas of code that we are thread safe
// already.  
//
class LStack
{
	public:
    
		LStack( ULONG size );
		virtual ~LStack();

		LStack( const LStack &source );


	public:

		void	Push( ULONG item );
		DWORD	Pop();
		DWORD	Top();
		BOOL	Empty();
		ULONG 	Count();


	private:
    
		ULONG	m_Count;
		ULONG	m_Size;
		
	public:
		
		ULONG	*m_Array;

}; // LStack


/***************************************************************************************
 ********************                                               ********************
 ********************             BaseInfo Declaration              ********************
 ********************                                               ********************
 ***************************************************************************************/
class BaseInfo
{
	public:
    
    	BaseInfo( ULONG id, ULONG internal = 0 );         
        virtual ~BaseInfo();
                
        
	public:
            
    	virtual void Dump();
        BOOL Compare( ULONG key );
		Comparison CompareEx( ULONG key );
        
        
 	public:
    
    	ULONG m_id;
		ULONG m_internalID;
    
}; // BaseInfo


/***************************************************************************************
 ********************                                               ********************
 ********************              StackTrace Declaration           ********************
 ********************                                               ********************
 ***************************************************************************************/
struct StackTrace
{
    DWORD m_count;
    DWORD *m_stack;
    DWORD m_key;
    DWORD m_typeId;
    DWORD m_typeSize;

    StackTrace(DWORD count, DWORD *stack, DWORD typeId=0, DWORD typeSize=0)
    {
        m_count = count;
        m_stack = stack;
        m_typeId = typeId;
        m_typeSize = typeSize;

        DWORD key = (count*137 + typeId)*137 + typeSize;
        for (DWORD i = 0; i < count; i++)
            key = key*137 + stack[i];
        m_key = key;
    }

    operator DWORD()
    {
        return m_key;
    }
}; // StackTrace


/***************************************************************************************
 ********************                                               ********************
 ********************              StackTraceInfo Declaration       ********************
 ********************                                               ********************
 ***************************************************************************************/

class StackTraceInfo
{
    DWORD m_count;
    DWORD *m_stack;
    DWORD m_key;
    DWORD m_typeId;
    DWORD m_typeSize;

public:
    DWORD m_internalId;

    StackTraceInfo(DWORD internalId, DWORD count, DWORD *stack, DWORD typeId=0, DWORD typeSize=0)
    {
        m_internalId = internalId;
        m_count = count;
        m_stack = new DWORD[count];
        m_typeId = typeId;
        m_typeSize = typeSize;

        DWORD key = (count*137 + typeId)*137 + typeSize;
        for (DWORD i = 0; i < count; i++)
        {
            key = key*137 + stack[i];
            m_stack[i] = stack[i];
        }
        m_key = key;
    }

    BOOL Compare( const StackTrace &stackTrace )
    {
        if (m_key != stackTrace.m_key || m_count != stackTrace.m_count || m_typeId != stackTrace.m_typeId || m_typeSize != stackTrace.m_typeSize)
        {
            return FALSE;
        }
        for (int i = m_count; --i >= 0; )
        {
            if (m_stack[i] != stackTrace.m_stack[i])
            {
                return FALSE;
            }
        }
        return TRUE;
    }
};

/***************************************************************************************
 ********************                                               ********************
 ********************            ThreadInfo Declaration             ********************
 ********************                                               ********************
 ***************************************************************************************/
class ThreadInfo :
	public BaseInfo
{
	public:

		ThreadInfo( ThreadID threadID, ULONG internal = 0 );         
		virtual ~ThreadInfo();
        

	public:
    
    	virtual void Dump();
                
        
	public:	
  	  		
        DWORD  m_win32ThreadID;
		LStack *m_pThreadCallStack;
		LStack *m_pLatestUnwoundFunction;

        StackTraceInfo *m_pLatestStackTraceInfo;

}; // ThreadInfo


/***************************************************************************************
 ********************                                               ********************
 ********************          FunctionInfo Declaration             ********************
 ********************                                               ********************
 ***************************************************************************************/
class FunctionInfo :
	public BaseInfo
{
	public:

		FunctionInfo( FunctionID functionID, ULONG internal = 0 );
   		virtual ~FunctionInfo();
      

	public:
    
    	void Dump();     
        
        
	public:	
  	  	                        	
        WCHAR    m_functionName[MAX_LENGTH];
		WCHAR	 m_functionSig[4*MAX_LENGTH];
        
}; // FunctionInfo


/***************************************************************************************
 ********************                                               ********************
 ********************             ClassInfo Declaration             ********************
 ********************                                               ********************
 ***************************************************************************************/
class ClassInfo :
	public BaseInfo
{
	public:

		ClassInfo( ClassID classID, ULONG internal = 0 );
   		virtual ~ClassInfo();
      

	public:
    
    	void Dump();        
        
        
	public:	
  	  	       
		ULONG	  m_objectsAllocated;
	    WCHAR     m_className[4*MAX_LENGTH];

}; // ClassInfo


/***************************************************************************************
 ********************                                               ********************
 ********************          ModuleInfo Declaration               ********************
 ********************                                               ********************
 ***************************************************************************************/
class ModuleInfo :
	public BaseInfo
{
	public:

		ModuleInfo( ModuleID moduleID, ULONG internal = 0 );
   		virtual ~ModuleInfo();
      

	public:
    
    	void Dump();     
        
        
	public:	
  	  	                        	
        WCHAR    m_moduleName[MAX_LENGTH];
		LPCBYTE  m_loadAddress;
        
}; // ModuleInfo


/***************************************************************************************
 ********************                                               ********************
 ********************              PrfInfo Declaration              ********************
 ********************                                               ********************
 ***************************************************************************************/
class PrfInfo
{	         
    public:
    
        PrfInfo();                     
        virtual ~PrfInfo();                      
                      
                   
   	public:
                    
    	void AddThread( ThreadID threadID );                        
    	void RemoveThread( ThreadID threadID );                        

        void AddFunction( FunctionID functionID, ULONG internalID = 0 ); 
        void RemoveFunction( FunctionID functionID ); 

        void AddModule( ModuleID moduleID, ULONG internalID = 0 ); 
        void RemoveModule( ModuleID moduleID ); 

		void UpdateCallStack( FunctionID functionID, StackAction action );
   		void UpdateOSThreadID( ThreadID managedThreadID, DWORD osThreadID );
		void UpdateUnwindStack( FunctionID *functionID, StackAction action );
		HRESULT GetNameFromClassID( ClassID classID, WCHAR className[] );


		void Failure( char *message = NULL );


  	private:
    
    	// helpers				
		void _GetFunctionSig(FunctionInfo **ppFunctionInfo );
    

    protected:    
                  
        DWORD m_dwEventMask;
        ICorProfilerInfo *m_pProfilerInfo;        
        
        // tables		 
        SList<ThreadInfo *, ThreadID> *m_pThreadTable;
   		HashTable<ClassInfo *, ClassID> *m_pClassTable;
   		Table<ModuleInfo *, ModuleID> *m_pModuleTable;
        Table<FunctionInfo *, FunctionID> *m_pFunctionTable;
        HashTable<StackTraceInfo *, StackTrace> *m_pStackTraceTable;

}; // PrfInfo


#endif // __PROFILER_INFO_H___

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\profilercallback.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerCallback.h
 *
 * Description:
 *  
 *
 *
 ***************************************************************************************/
#ifndef __PROFILER_CALLBACK_H__
#define __PROFILER_CALLBACK_H__

#include "mscoree.h"
#include "ProfilerInfo.h"

//
// event names
//
#define OMV_PIPE_NAME "\\\\.\\pipe\\OMV_Pipe"


/////////////////////////////////////////////////////////////////////////////////////////
// Each test should provide the following blob (with a new GUID)
//
	// {8C29BC4E-1F57-461a-9B51-1200C32E6F1F}

	extern const GUID __declspec( selectany ) CLSID_PROFILER = 
	{ 0x8c29bc4e, 0x1f57, 0x461a, { 0x9b, 0x51, 0x12, 0x0, 0xc3, 0x2e, 0x6f, 0x1f } };

	#define THREADING_MODEL "Both"
	#define PROGID_PREFIX "Objects Profiler"
	#define COCLASS_DESCRIPTION "Microsoft CLR Profiler Test"
	#define PROFILER_GUID "{8C29BC4E-1F57-461a-9B51-1200C32E6F1F}"
//
/////////////////////////////////////////////////////////////////////////////////////////

#define _MULTIPLE_PROCESSES

//
// arrays with the names of the various events and the IPC related stuff
//
static
char *NamedEvents[] = { "Global\\OMV_ForceGC",                                                             
 		    			"Global\\OMV_TriggerObjects",
						"Global\\OMV_Callgraph",
 		    		  };

static
char *CallbackNamedEvents[] = { "Global\\OMV_ForceGC_Completed",                                                             
 		    					"Global\\OMV_TriggerObjects_Completed",
								"Global\\OMV_Callgraph_Completed",
 		    		  		  };

//
// thread routines
//
DWORD __stdcall _GCThreadStub( void *pObject );
DWORD __stdcall _TriggerThreadStub( void *pObject );
DWORD __stdcall _CallstackThreadStub( void *pObject );


static
void *ThreadStubArray[] = { (void *) _GCThreadStub,                                                             
 		    				(void *) _TriggerThreadStub,
							(void *) _CallstackThreadStub,
 		    		  	  };


/***************************************************************************************
 ********************                                               ********************
 ********************       ProfilerCallback Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/

class ProfilerCallback : 
	public PrfInfo,
	public ICorProfilerCallback 
{
    public:
    
        ProfilerCallback();
        ~ProfilerCallback();


    public:

        //
        // IUnknown 
        //
        COM_METHOD( ULONG ) AddRef(); 
        COM_METHOD( ULONG ) Release();
        COM_METHOD( HRESULT ) QueryInterface( REFIID riid, void **ppInterface );


        //
        // STARTUP/SHUTDOWN EVENTS
        //
        virtual COM_METHOD( HRESULT ) Initialize( IUnknown *pICorProfilerInfoUnk );
               
		HRESULT DllDetachShutdown();                           
        COM_METHOD( HRESULT ) Shutdown();
                                         

		//
	 	// APPLICATION DOMAIN EVENTS
		//
	   	COM_METHOD( HRESULT ) AppDomainCreationStarted( AppDomainID appDomainID );
        
    	COM_METHOD( HRESULT ) AppDomainCreationFinished( AppDomainID appDomainID,
													     HRESULT hrStatus );
    
        COM_METHOD( HRESULT ) AppDomainShutdownStarted( AppDomainID appDomainID );

		COM_METHOD( HRESULT ) AppDomainShutdownFinished( AppDomainID appDomainID, 
        												 HRESULT hrStatus );


		//
	 	// ASSEMBLY EVENTS
		//
	   	COM_METHOD( HRESULT ) AssemblyLoadStarted( AssemblyID assemblyID );
        
    	COM_METHOD( HRESULT ) AssemblyLoadFinished( AssemblyID assemblyID,
                                                    HRESULT hrStatus );
    
        COM_METHOD( HRESULT ) AssemblyUnloadStarted( AssemblyID assemblyID );

		COM_METHOD( HRESULT ) AssemblyUnloadFinished( AssemblyID assemblyID, 
        											  HRESULT hrStatus );
		
		
		//
	 	// MODULE EVENTS
		//
	   	COM_METHOD( HRESULT ) ModuleLoadStarted( ModuleID moduleID );
        
    	COM_METHOD( HRESULT ) ModuleLoadFinished( ModuleID moduleID,
                                                  HRESULT hrStatus );
    
        COM_METHOD( HRESULT ) ModuleUnloadStarted( ModuleID moduleID );

		COM_METHOD( HRESULT ) ModuleUnloadFinished( ModuleID moduleID, 
        											HRESULT hrStatus );

		COM_METHOD( HRESULT ) ModuleAttachedToAssembly( ModuleID moduleID,
														AssemblyID assemblyID );
                
        
        //
        // CLASS EVENTS
        //
        COM_METHOD( HRESULT ) ClassLoadStarted( ClassID classID );
        
        COM_METHOD( HRESULT ) ClassLoadFinished( ClassID classID,
                                                 HRESULT hrStatus );
    
     	COM_METHOD( HRESULT ) ClassUnloadStarted( ClassID classID );

		COM_METHOD( HRESULT ) ClassUnloadFinished( ClassID classID, 
        										   HRESULT hrStatus );

		COM_METHOD( HRESULT ) FunctionUnloadStarted( FunctionID functionID );
        
        
        //
        // JIT EVENTS
        //              
        COM_METHOD( HRESULT ) JITCompilationStarted( FunctionID functionID,
                                                     BOOL fIsSafeToBlock );
                                        
        COM_METHOD( HRESULT ) JITCompilationFinished( FunctionID functionID,
        											  HRESULT hrStatus,
                                                      BOOL fIsSafeToBlock );
    
        COM_METHOD( HRESULT ) JITCachedFunctionSearchStarted( FunctionID functionID,
															  BOOL *pbUseCachedFunction );
        
		COM_METHOD( HRESULT ) JITCachedFunctionSearchFinished( FunctionID functionID,
															   COR_PRF_JIT_CACHE result );
                                                                     
        COM_METHOD( HRESULT ) JITFunctionPitched( FunctionID functionID );
        
        COM_METHOD( HRESULT ) JITInlining( FunctionID callerID,
                                           FunctionID calleeID,
                                           BOOL *pfShouldInline );

        
        //
        // THREAD EVENTS
        //
        COM_METHOD( HRESULT ) ThreadCreated( ThreadID threadID );
    
        COM_METHOD( HRESULT ) ThreadDestroyed( ThreadID threadID );

        COM_METHOD( HRESULT ) ThreadAssignedToOSThread( ThreadID managedThreadID,
                                                        DWORD osThreadID );
    

       	//
        // REMOTING EVENTS
        //                                                      

        //
        // Client-side events
        //
        COM_METHOD( HRESULT ) RemotingClientInvocationStarted();

        COM_METHOD( HRESULT ) RemotingClientSendingMessage( GUID *pCookie,
															BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingClientReceivingReply( GUID *pCookie,
															BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingClientInvocationFinished();

        //
        // Server-side events
        //
        COM_METHOD( HRESULT ) RemotingServerReceivingMessage( GUID *pCookie,
															  BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingServerInvocationStarted();

        COM_METHOD( HRESULT ) RemotingServerInvocationReturned();

        COM_METHOD( HRESULT ) RemotingServerSendingReply( GUID *pCookie,
														  BOOL fIsAsync );


       	//
        // CONTEXT EVENTS
        //                                                      
    	COM_METHOD( HRESULT ) UnmanagedToManagedTransition( FunctionID functionID,
                                                            COR_PRF_TRANSITION_REASON reason );
    
        COM_METHOD( HRESULT ) ManagedToUnmanagedTransition( FunctionID functionID,
                                                            COR_PRF_TRANSITION_REASON reason );
                                                                  
                                                                        
       	//
        // SUSPENSION EVENTS
        //    
        COM_METHOD( HRESULT ) RuntimeSuspendStarted( COR_PRF_SUSPEND_REASON suspendReason );

        COM_METHOD( HRESULT ) RuntimeSuspendFinished();

        COM_METHOD( HRESULT ) RuntimeSuspendAborted();

        COM_METHOD( HRESULT ) RuntimeResumeStarted();

        COM_METHOD( HRESULT ) RuntimeResumeFinished();

        COM_METHOD( HRESULT ) RuntimeThreadSuspended( ThreadID threadid );

        COM_METHOD( HRESULT ) RuntimeThreadResumed( ThreadID threadid );


       	//
        // GC EVENTS
        //    
        COM_METHOD( HRESULT ) MovedReferences( ULONG cmovedObjectIDRanges,
                                               ObjectID oldObjectIDRangeStart[],
                                               ObjectID newObjectIDRangeStart[],
                                               ULONG cObjectIDRangeLength[] );
    
        COM_METHOD( HRESULT ) ObjectAllocated( ObjectID objectID,
                                               ClassID classID );
    
        COM_METHOD( HRESULT ) ObjectsAllocatedByClass( ULONG classCount,
                                                       ClassID classIDs[],
                                                       ULONG objects[] );
    
        COM_METHOD( HRESULT ) ObjectReferences( ObjectID objectID,
                                                ClassID classID,
                                                ULONG cObjectRefs,
                                                ObjectID objectRefIDs[] );
    
        COM_METHOD( HRESULT ) RootReferences( ULONG cRootRefs,
                                              ObjectID rootRefIDs[] );
    
        
      	//
        // EXCEPTION EVENTS
        //                                                         

        // Exception creation
        COM_METHOD( HRESULT ) ExceptionThrown( ObjectID thrownObjectID );

        // Search phase
        COM_METHOD( HRESULT ) ExceptionSearchFunctionEnter( FunctionID functionID );
    
        COM_METHOD( HRESULT ) ExceptionSearchFunctionLeave();
    
        COM_METHOD( HRESULT ) ExceptionSearchFilterEnter( FunctionID functionID );
    
        COM_METHOD( HRESULT ) ExceptionSearchFilterLeave();
    
        COM_METHOD( HRESULT ) ExceptionSearchCatcherFound( FunctionID functionID );
        
        COM_METHOD( HRESULT ) ExceptionCLRCatcherFound();

        COM_METHOD( HRESULT ) ExceptionCLRCatcherExecute();

        COM_METHOD( HRESULT ) ExceptionOSHandlerEnter( FunctionID functionID );
            
        COM_METHOD( HRESULT ) ExceptionOSHandlerLeave( FunctionID functionID );
    
        // Unwind phase
        COM_METHOD( HRESULT ) ExceptionUnwindFunctionEnter( FunctionID functionID );
    
        COM_METHOD( HRESULT ) ExceptionUnwindFunctionLeave();
        
        COM_METHOD( HRESULT ) ExceptionUnwindFinallyEnter( FunctionID functionID );
    
        COM_METHOD( HRESULT ) ExceptionUnwindFinallyLeave();
        
        COM_METHOD( HRESULT ) ExceptionCatcherEnter( FunctionID functionID,
            										 ObjectID objectID );
    
        COM_METHOD( HRESULT ) ExceptionCatcherLeave();

        
        //
		// COM CLASSIC WRAPPER
		//
        COM_METHOD( HRESULT )  COMClassicVTableCreated( ClassID wrappedClassID,
                                                        REFGUID implementedIID,
                                                        void *pVTable,
                                                        ULONG cSlots );

        COM_METHOD( HRESULT )  COMClassicVTableDestroyed( ClassID wrappedClassID,
                                                          REFGUID implementedIID,
                                                          void *pVTable );
    
    
        //
        // instantiate an instance of the callback interface
        //
        static COM_METHOD( HRESULT) CreateObject( REFIID riid, void **ppInterface );            
        
                                                                                                     
    	// used by function hooks, they have to be static
    	static void  Enter( FunctionID functionID );
		static void  Leave( FunctionID functionID );
		static void  Tailcall( FunctionID functionID );
		static ThreadInfo *GetThreadInfo(ThreadID threadID);
		//
		// wrapper for the threads
		//
		void _ThreadStubWrapper( ObjHandles type );

    private:

		HRESULT _AddGCObject( BOOL bForce = FALSE );
        DWORD _StackTraceId(int typeId=0, int typeSize=0);
        void _LogTickCount();
		void _ShutdownAllThreads();
		void _ProcessEnvVariables();
		void LogToAny( char *format, ... );

		HRESULT _InitializeThreadsAndEvents();
		HRESULT _LogCallTrace( FunctionID functionID );
		HRESULT _InitializeNamesForEventsAndCallbacks();
		HRESULT _InsertGCClass( ClassInfo **ppClassInfo, ClassID classID );
		HRESULT _HackBogusClassName( CorElementType elementType, WCHAR *buffer );
		
		//
		// pipe operations with the GUI
		//
		void _ConnectToUI();

	
    private:

        // various counters
        long m_refCount;                        
		DWORD m_dwShutdown;
        DWORD m_callStackCount;

		// counters
		LONG m_totalClasses;
		LONG m_totalModules;
		LONG m_totalFunctions;
		ULONG m_totalObjectsAllocated;
		
		// operation indicators
		char *m_path;
		HANDLE m_hPipe;
		DWORD m_dwMode;
		BOOL m_bShutdown;
		BOOL m_bDumpGCInfo;
		DWORD m_dwProcessId;
		BOOL m_bDumpCompleted;
		DWORD m_dwSkipObjects;
		BOOL m_bMonitorParents;
		DWORD m_dwFramesToPrint;
		WCHAR *m_classToMonitor;
		BOOL m_bTrackingObjects;
		BOOL m_bIsTrackingStackTrace;
		CRITICAL_SECTION m_criticalSection;

		
		// file stuff
		FILE *m_stream;
        DWORD m_firstTickCount;
        DWORD m_lastTickCount;
        DWORD m_lastClockTick;

		// event and thread handles need to be accessed by the threads
		HANDLE m_hArray[(DWORD)SENTINEL_HANDLE];
		HANDLE m_hArrayCallbacks[(DWORD)SENTINEL_HANDLE];
		HANDLE m_hThreads[(DWORD)SENTINEL_HANDLE];
		DWORD m_dwWin32ThreadIDs[(DWORD)SENTINEL_HANDLE];


		// names for the events and the callbacks
		char m_logFileName[MAX_LENGTH+1];
		char *m_NamedEvents[SENTINEL_HANDLE];
		char *m_CallbackNamedEvents[SENTINEL_HANDLE];

        // IGCHost callback
        IGCHost *m_pGCHost;
        bool m_SuspendForGC;
				
}; // ProfilerCallback

extern ProfilerCallback *g_pCallbackObject;		// global reference to callback object
CRITICAL_SECTION g_criticalSection;

#endif //  __PROFILER_CALLBACK_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\dllmain.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  dllmain.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __DLLMAIN_HPP__
#define __DLLMAIN_HPP__

#include "regutil.hpp"
#include "classfactory.hpp"


// forward declarations
HINSTANCE GetModuleInst();
STDAPI DllRegisterServer();
STDAPI DllUnregisterServer();
STDAPI DllGetClassObject( REFCLSID rclsid, /* class desired */
						  REFIID riid,	   /* interface desired	*/
						  LPVOID FAR *ppv  /* return interface pointer */ );


/***************************************************************************************
 ********************                                               ********************
 ********************            DllMain Implementation             ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{    
	// save off the instance handle for later use
	switch ( dwReason )
	{
		case DLL_PROCESS_ATTACH:
			g_hInst = hInstance;
			DisableThreadLibraryCalls( hInstance );
			break;
		
        
		case DLL_PROCESS_DETACH:
			// lpReserved == NULL means that we called FreeLibrary()
			// in that case do nothing
			if ( (lpReserved != NULL) && (g_pCallbackObject != NULL) )
				g_pCallbackObject->DllDetachShutdown();

			break;	
		
		default:
			break;		
	}
   
        
	return TRUE;

} // DllMain


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllRegisterServer()
{    
	HRESULT hr = S_OK;
	char  rcModule[_MAX_PATH];	
    const COCLASS_REGISTER *pCoClass;	

	
	DllUnregisterServer();
	GetModuleFileNameA( GetModuleInst(), rcModule, NumItems( rcModule ) );

	// for each item in the coclass list, register it
	for ( pCoClass = g_CoClasses; (SUCCEEDED( hr ) && (pCoClass->pClsid != NULL)); pCoClass++ )
	{
		// register the class with default values
       	hr = REGUTIL::RegisterCOMClass( *pCoClass->pClsid, 
									    g_szCoclassDesc, 
										g_szProgIDPrefix,
										g_iVersion, 
										pCoClass->szProgID, 
										g_szThreadingModel, 
										rcModule );      	        
	} // for


	if ( FAILED( hr ) )
		DllUnregisterServer();
    
       
	return hr;
    
} // DllRegisterServer


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllUnregisterServer()
{    
	const COCLASS_REGISTER *pCoClass;	
    	

	// for each item in the coclass list, unregister it
	for ( pCoClass = g_CoClasses; pCoClass->pClsid != NULL; pCoClass++ )
	{
		REGUTIL::UnregisterCOMClass( *pCoClass->pClsid, 
        							 g_szProgIDPrefix,
									 g_iVersion, 
                                     pCoClass->szProgID );
	} // for
        
        
	return S_OK;
    
} // DllUnregisterServer


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv )				   
{    
	CClassFactory *pClassFactory;		
	const COCLASS_REGISTER *pCoClass;	
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;


	// scan for the right one
	for ( pCoClass = g_CoClasses; pCoClass->pClsid != NULL; pCoClass++ )
	{
		if ( *pCoClass->pClsid == rclsid )
		{
			pClassFactory = new CClassFactory( pCoClass );
			if ( pClassFactory != NULL )
			{	
				hr = pClassFactory->QueryInterface( riid, ppv );
                
				pClassFactory->Release();
				break;
			}
            else
            {
            	hr = E_OUTOFMEMORY;
            	break;    
           	}
      	}
	} // for
    
     
	return hr;
    
} // DllGetClassObject


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI_(char *) GetGUIDAsString()
{
       
    return PROFILER_GUID;
    
} // GetGUIDAsString


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
HINSTANCE GetModuleInst()
{    

    return g_hInst;
    
} // GetModuleInst

#endif // __DLLMAIN_HPP__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\profilerinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerInfo.cpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#include "ProfilerInfo.h"


/***************************************************************************************
 ********************                                               ********************
 ********************             LStack Implementation             ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
LStack::LStack( ULONG size ) :
	m_Count( 0 ),
	m_Size( size ),
	m_Array( NULL )    
{    
	m_Array = new ULONG[size];

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
LStack::~LStack()
{
	if ( m_Array != NULL )
	{
		delete[] m_Array;
		m_Array = NULL;	
	}

} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
LStack::LStack( const LStack &source ) 
{
	m_Size = source.m_Size;
	m_Count = source.m_Count;
	m_Array = source.m_Array;
    
} // copy ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG LStack::Count() 
{
	return m_Count;
	
} // LStack::Count


ULONG *GrowStack(ULONG newSize, ULONG currentSize, ULONG *stack)
{
	ULONG *newStack = new ULONG[newSize];

	if ( newStack != NULL )
	{
		//
		// copy all the elements
		//
		for (ULONG i =0; i < currentSize; i++ )
		{
			newStack[i] = stack[i];		
		}

		delete[] stack;
		
        return newStack;
	}
	else
    	_THROW_EXCEPTION( "Allocation for m_Array FAILED" )	
}
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void LStack::Push( ULONG item )
{
	if ( m_Count == m_Size )
        m_Array = GrowStack(2*m_Count, m_Count, m_Array);
	
	m_Array[m_Count] = item;
	m_Count++;
} // LStack::Push


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
DWORD LStack::Pop()
{		
	DWORD item = -1;


	if ( m_Count !=0 )
	{
		m_Count--;
		item = (DWORD)m_Array[m_Count];
	}
    	
		
	return item;
    
} // LStack::Pop


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
DWORD LStack::Top()
{		

	if ( m_Count == 0 )
		return -1;
	
	else
		return m_Array[m_Count-1];
	
} // LStack::Top


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
BOOL LStack::Empty() 
{
	return (BOOL)(m_Count == NULL);
	
} // LStack::Empty


/***************************************************************************************
 ********************                                               ********************
 ********************             BaseInfo Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
BaseInfo::BaseInfo( ULONG id, ULONG internal ) : 
	m_id( id ),
	m_internalID( internal )
{   
} // ctor         		


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
BaseInfo::~BaseInfo()
{   	
} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
BOOL BaseInfo::Compare( ULONG key )
{

    return (BOOL)(m_id == key);
    
} // BaseInfo::Compare


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
Comparison BaseInfo::CompareEx( ULONG key )
{
	Comparison res = EQUAL_TO;


	if ( key > m_id )
		res =  GREATER_THAN;
	
	else if ( key < m_id )
		res = LESS_THAN;


	return res;

} // BaseInfo::CompareEx


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void BaseInfo::Dump( )
{} // BaseInfo::Dump


/***************************************************************************************
 ********************                                               ********************
 ********************            ThreadInfo Implementation          ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ThreadInfo::ThreadInfo( ThreadID threadID, ULONG internal ) : 
	BaseInfo( threadID, internal ),		
	m_win32ThreadID( 0 )
{
	m_pThreadCallStack = new LStack( MAX_LENGTH );
	m_pLatestUnwoundFunction = new LStack( MAX_LENGTH );
    m_pLatestStackTraceInfo = NULL;
} // ctor         		


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
ThreadInfo::~ThreadInfo()
{
    if ( m_pThreadCallStack != NULL )
   	{   	   	
  		delete m_pThreadCallStack;
		m_pThreadCallStack = NULL;
	}
	
	if ( m_pLatestUnwoundFunction != NULL )
	{
    	delete m_pLatestUnwoundFunction; 
		m_pLatestUnwoundFunction = NULL;
	}

} // dtor
        

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ThreadInfo::Dump()
{} // ThreadInfo::Dump


/***************************************************************************************
 ********************                                               ********************
 ********************          FunctionInfo Implementation          ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
FunctionInfo::FunctionInfo( FunctionID functionID, ULONG internal ) : 
    BaseInfo( functionID, internal )    	
{
   	wcscpy( m_functionName, L"UNKNOWN" );
	wcscpy( m_functionSig, L"" );
   	 	
    
} // ctor         		


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
FunctionInfo::~FunctionInfo()
{  
} // dtor
        

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void FunctionInfo::Dump()
{} // FunctionInfo::Dump


/***************************************************************************************
 ********************                                               ********************
 ********************          ModuleInfo Implementation            ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ModuleInfo::ModuleInfo( ModuleID moduleID, ULONG internal ) : 
    BaseInfo( moduleID, internal ),
    m_loadAddress( 0 )    	
{
   	wcscpy( m_moduleName, L"UNKNOWN" );
    
} // ctor         		


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
ModuleInfo::~ModuleInfo()
{  
} // dtor
        

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ModuleInfo::Dump()
{} // ModuleInfo::Dump


/***************************************************************************************
 ********************                                               ********************
 ********************            ClassInfo Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ClassInfo::ClassInfo( ClassID classID, ULONG internal ) : 
    BaseInfo( classID, internal ),
	m_objectsAllocated( 0 )
{
   	wcscpy( m_className, L"UNKNOWN" ); 	

} // ctor         		


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
ClassInfo::~ClassInfo()
{} // dtor
        

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void ClassInfo::Dump()
{} // ClassInfo::Dump


/***************************************************************************************
 ********************                                               ********************
 ********************              PrfInfo Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
PrfInfo::PrfInfo() :         
    m_pProfilerInfo( NULL ),
	m_dwEventMask( 0 ),
    m_pClassTable( NULL ),
    m_pThreadTable( NULL ),
    m_pFunctionTable( NULL ),
    m_pStackTraceTable( NULL )
{
    // initialize tables
    m_pClassTable = new HashTable<ClassInfo *, ClassID>();
    m_pThreadTable = new SList<ThreadInfo *, ThreadID>();
    m_pModuleTable = new Table<ModuleInfo *, ModuleID>();
    m_pFunctionTable = new Table<FunctionInfo *, FunctionID>();
    m_pStackTraceTable = new HashTable<StackTraceInfo *, StackTrace>();
	
} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* virtual public */
PrfInfo::~PrfInfo()
{
    if ( m_pProfilerInfo != NULL )
    	m_pProfilerInfo->Release();        
       
       
   	// clean up tables   	   	
    if ( m_pClassTable != NULL )
    {    
    	delete m_pClassTable;
		m_pClassTable = NULL;
	}
    

    if ( m_pThreadTable != NULL )
    {    
    	delete m_pThreadTable;
		m_pThreadTable = NULL;
	}
    

    if ( m_pFunctionTable != NULL )
    {    
    	delete m_pFunctionTable;
		m_pFunctionTable = NULL;
	}


    if ( m_pModuleTable != NULL )
    {    
    	delete m_pModuleTable;
		m_pModuleTable = NULL;
	}

} // dtor 				 


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::AddThread( ThreadID threadID )
{    
	HRESULT hr;
	ThreadID myThreadID;


	hr = m_pProfilerInfo->GetCurrentThreadID( &myThreadID );	
	if ( SUCCEEDED( hr ) )
	{		
		if ( threadID == myThreadID )
		{
			ThreadInfo *pThreadInfo;
		    
            
		    pThreadInfo = new ThreadInfo( threadID );
			if ( pThreadInfo != NULL )
		  	{
		    	hr = m_pProfilerInfo->GetThreadInfo( pThreadInfo->m_id, &(pThreadInfo->m_win32ThreadID) );
		    	if ( SUCCEEDED( hr ) )
		        	m_pThreadTable->AddEntry( pThreadInfo, threadID );

				else
					_THROW_EXCEPTION( "ICorProfilerInfo::GetThreadInfo() FAILED" )
		    }
		    else
		    	_THROW_EXCEPTION( "Allocation for ThreadInfo Object FAILED" )
		}
		else
			_THROW_EXCEPTION( "Thread ID's do not match FAILED" )
	}
	else
    	_THROW_EXCEPTION( "ICorProfilerInfo::GetCurrentThreadID() FAILED" )
		            
} // PrfInfo::AddThread


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::RemoveThread( ThreadID threadID )
{    
	if ( threadID != NULL )
  	{
    	ThreadInfo *pThreadInfo;

    	
		pThreadInfo = m_pThreadTable->Lookup( threadID );
		if ( pThreadInfo != NULL )
	    	m_pThreadTable->DelEntry( threadID );

		else
	    	_THROW_EXCEPTION( "Thread was not found in the Thread Table" )
	}
	else
    	_THROW_EXCEPTION( "ThreadID is NULL" )
		            
} // PrfInfo::RemoveThread


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::AddFunction( FunctionID functionID, ULONG internalID )
{    
	if ( functionID != NULL )
	{
	    FunctionInfo *pFunctionInfo;
	    

		pFunctionInfo = m_pFunctionTable->Lookup( functionID );
		if ( pFunctionInfo == NULL )
		{
		    pFunctionInfo = new FunctionInfo( functionID, internalID );
			if ( pFunctionInfo != NULL )
		  	{
		    	try
		        {
					_GetFunctionSig( &pFunctionInfo );
		            m_pFunctionTable->AddEntry( pFunctionInfo, functionID );
		      	}
		        catch ( BaseException *exception )    
		        {
		        	delete pFunctionInfo;
					throw;            		
		      	}
			}        
		    else
		    	_THROW_EXCEPTION( "Allocation for FunctionInfo Object FAILED" )
		}	     
	}
	else
    	_THROW_EXCEPTION( "FunctionID is NULL" )
          
} // PrfInfo::AddFunction


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::RemoveFunction( FunctionID functionID )
{    
    if ( functionID != NULL )
	{
	    FunctionInfo *pFunctionInfo;
	    

		pFunctionInfo = m_pFunctionTable->Lookup( functionID );
		if ( pFunctionInfo != NULL )
	    	m_pFunctionTable->DelEntry( functionID );
	  
		else
	    	_THROW_EXCEPTION( "Function was not found in the Function Table" )
	}
	else
    	_THROW_EXCEPTION( "FunctionID is NULL" )
		    
} // PrfInfo::RemoveFunction


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::AddModule( ModuleID moduleID, ULONG internalID )
{    
	if ( moduleID != NULL )
	{
	    ModuleInfo *pModuleInfo;
	    

		pModuleInfo = m_pModuleTable->Lookup( moduleID );
		if ( pModuleInfo == NULL )
		{
		    pModuleInfo = new ModuleInfo( moduleID, internalID );
			if ( pModuleInfo != NULL )
		  	{
				HRESULT hr;
				ULONG dummy;
				
					            
	            hr = m_pProfilerInfo->GetModuleInfo( moduleID,
                									 &(pModuleInfo->m_loadAddress),
                									 MAX_LENGTH,
                									 &dummy, 
                									 pModuleInfo->m_moduleName,
													 NULL );
				if ( SUCCEEDED( hr ) )
				{
	            	m_pModuleTable->AddEntry( pModuleInfo, moduleID );
				}
				else
			    	_THROW_EXCEPTION( "ICorProfilerInfo::GetModuleInfo() FAILED" )
			}        
		    else
		    	_THROW_EXCEPTION( "Allocation for ModuleInfo Object FAILED" )
		}	     
	}
	else
    	_THROW_EXCEPTION( "ModuleID is NULL" )
          
} // PrfInfo::AddModule


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
/* throws BaseException */
void PrfInfo::RemoveModule( ModuleID moduleID )
{    
    if ( moduleID != NULL )
	{
	    ModuleInfo *pModuleInfo;
	    

		pModuleInfo = m_pModuleTable->Lookup( moduleID );
		if ( pModuleInfo != NULL )
	    	m_pModuleTable->DelEntry( moduleID );
	  
		else
	    	_THROW_EXCEPTION( "Module was not found in the Module Table" )
	}
	else
    	_THROW_EXCEPTION( "ModuleID is NULL" )
		    
} // PrfInfo::RemoveModule


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void PrfInfo::UpdateOSThreadID( ThreadID managedThreadID, DWORD osThreadID )
{
  	ThreadInfo *pThreadInfo;


	pThreadInfo = m_pThreadTable->Lookup( managedThreadID );
	if ( pThreadInfo != NULL )
		pThreadInfo->m_win32ThreadID = osThreadID;
   
	else
		_THROW_EXCEPTION( "Thread does not exist in the thread table" )
                              
} // PrfInfo::UpdateOSThreadID

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void PrfInfo::UpdateUnwindStack( FunctionID *functionID, StackAction action )
{
	HRESULT hr;
	ThreadID threadID;


	hr = m_pProfilerInfo->GetCurrentThreadID( &threadID );
	if ( SUCCEEDED(hr) )
	{
		ThreadInfo *pThreadInfo = m_pThreadTable->Lookup( threadID );


		if ( pThreadInfo != NULL )
		{
			switch ( action )
			{
				case PUSH:
					(pThreadInfo->m_pLatestUnwoundFunction)->Push( (ULONG)functionID );
					break;

				case POP:
					*functionID = (ULONG)(pThreadInfo->m_pLatestUnwoundFunction)->Pop();
					break;
			}
		}
		else 				
			_THROW_EXCEPTION( "Thread Structure was not found in the thread list" )
	}
	else
		_THROW_EXCEPTION( "ICorProfilerInfo::GetCurrentThreadID() FAILED" )
          
} // PrfInfo::UpdateUnwindStack


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
void PrfInfo::UpdateCallStack( FunctionID functionID, StackAction action )
{
	HRESULT hr = S_OK;
	ThreadID threadID;


	hr = m_pProfilerInfo->GetCurrentThreadID(&threadID);
	if ( SUCCEEDED(hr) )
	{
		ThreadInfo *pThreadInfo = m_pThreadTable->Lookup( threadID );


		if ( pThreadInfo != NULL )
		{

			switch ( action )
			{
				case PUSH:
					(pThreadInfo->m_pThreadCallStack)->Push( (ULONG)functionID );
					break;

				case POP:
					(pThreadInfo->m_pThreadCallStack)->Pop();
					break;
			}
		}
		else 				
			_THROW_EXCEPTION( "Thread Structure was not found in the thread list" )
	}
	else
		_THROW_EXCEPTION( "ICorProfilerInfo::GetCurrentThreadID() FAILED" )


} // PrfInfo::UpdateCallStack


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT PrfInfo::GetNameFromClassID( ClassID classID, WCHAR className[] )
{
    HRESULT hr = E_FAIL;
    
    
    if ( m_pProfilerInfo != NULL )
    {
        ModuleID moduleID;
		mdTypeDef classToken;

        
		hr = m_pProfilerInfo->GetClassIDInfo( classID, 
			        						  &moduleID,  
			                                  &classToken );                                                                                                                                              
		if ( SUCCEEDED( hr ) )
	   	{             	
    		IMetaDataImport *pMDImport = NULL;
	            
	        
			hr = m_pProfilerInfo->GetModuleMetaData( moduleID, 
			           						         (ofRead | ofWrite),
											         IID_IMetaDataImport, 
			                                         (IUnknown **)&pMDImport );
			if ( SUCCEEDED( hr ) )
			{
	          	if ( classToken != mdTypeDefNil )
				{
		          	hr = pMDImport->GetTypeDefProps( classToken, 
						                             className, 
						                             MAX_LENGTH,
						                             NULL, 
						                             NULL, 
						                             NULL ); 
			        if ( FAILED( hr ) )
			           	Failure( "IMetaDataImport::GetTypeDefProps() FAILED" );
				}
				else
					DEBUG_OUT( ("The class token is mdTypeDefNil, class does NOT have MetaData info") );


				pMDImport->Release ();
			}
			else
				Failure( "IProfilerInfo::GetModuleMetaData() => IMetaDataImport FAILED" );
	    }
	    else    
	        Failure( "ICorProfilerInfo::GetClassIDInfo() FAILED" );
   	}
    else
		Failure( "ICorProfilerInfo Interface has NOT been Initialized" );


	return hr;

} // PrfHelper::GetNameFromClassID


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* private */
/* throws BaseException */
void PrfInfo::_GetFunctionSig( FunctionInfo **ppFunctionInfo )
{
	HRESULT hr;
    
    
	BOOL isStatic;
	ULONG argCount;
   	WCHAR returnType[MAX_LENGTH];
   	WCHAR functionName[MAX_LENGTH];
	WCHAR functionParameters[10 * MAX_LENGTH];


	//
	// init strings
	//
	returnType[0] = '\0';
	functionName[0] = '\0';
	functionParameters[0] = '\0';
	(*ppFunctionInfo)->m_functionSig[0] = '\0';

	// get the sig of the function and
	// use utilcode to get the parameters you want
	BASEHELPER::GetFunctionProperties( m_pProfilerInfo,
									   (*ppFunctionInfo)->m_id,
									   &isStatic,
									   &argCount,
									   returnType, 
									   functionParameters,
									   functionName );
	// attach the keyword static of method is static
	if ( isStatic )
	{
	   swprintf( (*ppFunctionInfo)->m_functionSig, 
	   			 L"static %s (%s)",
	    		 returnType,
	    		 functionParameters );
	}
    else
	{
	    swprintf( (*ppFunctionInfo)->m_functionSig,
	    		  L"%s (%s)",
	    		  returnType,
	    		  functionParameters );
	}

	WCHAR *index = (*ppFunctionInfo)->m_functionSig;

	while ( *index != '\0' )
	{
		if ( *index == '+' )
		   *index = ' ';	
		index++;
	}

	//
	// update the function name if it is not yet set
	//
	if ( wcsstr( (*ppFunctionInfo)->m_functionName, L"UNKNOWN" ) != NULL )
		swprintf( (*ppFunctionInfo)->m_functionName, L"%s", functionName );

	
} // PrfInfo::_GetFunctionSig


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void PrfInfo::Failure( char *message )
{
	if ( message == NULL )     	
	 	message = "**** SEVERE FAILURE: TURNING OFF APPLICABLE PROFILING EVENTS ****";  
	
	
	//
	// Display the error message and discontinue monitoring CLR events, except the 
	// IMMUTABLE ones. Turning off the IMMUTABLE events can cause crashes. The only
	// place that we can safely enable or disable immutable events is the Initialize
	// callback.
	//		      	
	TEXT_OUTLN( message )
	m_pProfilerInfo->SetEventMask( (m_dwEventMask & (DWORD)COR_PRF_MONITOR_IMMUTABLE) );    
               	         
} // PrfInfo::Failure


// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\chkcor\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\profilerobj.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  profilerGCP.cpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#undef _WIN32_WINNT
#define _WIN32_WINNT    0x0403

#pragma optimize( "t", on )

#include "avlnode.h"
#include "basehlp.h"
#include "container.hpp"
#include "avlnode.hpp"
#include "basehlp.hpp"

#include "ProfilerInfo.cpp"
#include "ProfilerCallback.cpp"

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\regutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************************
 * File:
 *  basehlp.h
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __REGUTIL_H__
#define __REGUTIL_H__


/***************************************************************************************
 ********************                                               ********************
 ********************           BaseException Declaration           ********************
 ********************                                               ********************
 ***************************************************************************************/
#define NumItems( s ) (sizeof( s ) / sizeof( s[0] ))


class REGUTIL
{
	public:

		static BOOL SetKeyAndValue( const char *szKey,     
		    						const char *szSubkey,  
		    						const char *szValue ); 

		static BOOL DeleteKey( const char *szKey,		
		    				   const char *szSubkey );  

		static BOOL SetRegValue( const char *szKeyName,	
		    					 const char *szKeyword, 
		    					 const char *szValue ); 

		static HRESULT RegisterCOMClass( REFCLSID rclsid,  				
								         const char *szDesc,    		
								         const char *szProgIDPrefix,
								         int iVersion,  
								         const char *szClassProgID, 	
								         const char *szThreadingModel, 
								         const char *szModule );       

		static HRESULT UnregisterCOMClass( REFCLSID rclsid,            
									       const char *szProgIDPrefix, 
									       int iVersion,               
									       const char *szClassProgID );

		static HRESULT FakeCoCreateInstance( REFCLSID rclsid, 
											 REFIID riid, 
											 void** ppv );
		

	private:

		static HRESULT _RegisterClassBase( REFCLSID rclsid,          
								           const char *szDesc,       
								           const char *szProgID,     
								           const char *szIndepProgID,
								           char *szOutCLSID );       

		static HRESULT _UnregisterClassBase( REFCLSID rclsid,            
						 			         const char *szProgID,       
									         const char *szIndepProgID,  
									         char *szOutCLSID );          

}; // REGUTIL

#endif // __REGUTIL_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\regutil.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  regutil.hpp
 *
 * Description:
 *	
 *
 *
 ***************************************************************************************/
#ifndef __REGUTIL_HPP__
#define __REGUTIL_HPP__

#include "regutil.h"


typedef HRESULT __stdcall DLLGETCLASSOBJECT(REFCLSID rclsid,
                                            REFIID   riid,
                                            void   **ppv);

IID IID_ICF = {0x00000001, 0x0000, 0x0000, {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}};

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *		Set an entry in the registry of the form:
 *			HKEY_CLASSES_ROOT\szKey\szSubkey = szValue
 *
 *		If szSubkey or szValue are NULL, omit them from the above expression.
 *
 ***************************************************************************************/
/* static public */
BOOL REGUTIL::SetKeyAndValue( const char *szKey,
							  const char *szSubkey,
							  const char *szValue )
{
	HKEY hKey;	 	 		// handle to the new reg key.
	char rcKey[MAX_LENGTH]; // buffer for the full key name.


	// init the key with the base key name.
	strcpy( rcKey, szKey );

	// append the subkey name (if there is one).
	if ( szSubkey != NULL )
	{
		strcat( rcKey, "\\" );
		strcat( rcKey, szSubkey );
	}

	// create the registration key.
	if ( RegCreateKeyExA( HKEY_CLASSES_ROOT, 
					      rcKey, 
						  0, 
						  NULL,
						  REG_OPTION_NON_VOLATILE, 
						  KEY_ALL_ACCESS, 
						  NULL,
						  &hKey, 
						  NULL ) == ERROR_SUCCESS )
	{
		// set the value (if there is one).
		if ( szValue != NULL )
		{
			RegSetValueExA( hKey, 
							NULL, 
							0, 
							REG_SZ, 
							(BYTE *)szValue,
							((strlen( szValue ) + 1) * sizeof ( char )) );
		}
		
		RegCloseKey( hKey );
	
		
		return TRUE;
	}	


	return FALSE;	

} // REGUTIL::SetKeyAndValue


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *		Delete an entry in the registry of the form:
 *			HKEY_CLASSES_ROOT\szKey\szSubkey = szValue
 *
 ***************************************************************************************/
/* static public */
BOOL REGUTIL::DeleteKey( const char *szKey,
					 	 const char *szSubkey )
{
	char rcKey[MAX_LENGTH]; // buffer for the full key name.


	// init the key with the base key name.
	strcpy( rcKey, szKey );

	// append the subkey name (if there is one).
	if ( szSubkey != NULL )
	{
		strcat( rcKey, "\\" );
		strcat( rcKey, szSubkey );
	}

	// delete the registration key.
	RegDeleteKeyA( HKEY_CLASSES_ROOT, rcKey );
	
	
	return TRUE;

} // REGUTIL::DeleteKey


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *		Open the key, create a new keyword and value pair under it.
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static public */
BOOL REGUTIL::SetRegValue( const char *szKeyName,
						   const char *szKeyword,
						   const char *szValue )
{
	HKEY hKey; // handle to the new reg key.


	// create the registration key.
	if ( RegCreateKeyExA( HKEY_CLASSES_ROOT, 
						  szKeyName, 
						  0, 
						  NULL,
						  REG_OPTION_NON_VOLATILE, 
						  KEY_ALL_ACCESS, 
						  NULL,
						  &hKey, 
						  NULL) == ERROR_SUCCESS )
	{
		// set the value (if there is one).
		if ( szValue != NULL )
		{
			RegSetValueExA( hKey, 
							szKeyword, 
							0, 
							REG_SZ, 
							(BYTE *)szValue, 
							((strlen( szValue ) + 1) * sizeof ( char )) );
		}

		RegCloseKey( hKey );

		
		return TRUE;
	}

	
	return FALSE;

} // REGUTIL::SetRegValue


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *		Does standard registration of a CoClass with a progid.
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static public */
HRESULT REGUTIL::RegisterCOMClass( REFCLSID	rclsid,
								   const char *szDesc,					
								   const char *szProgIDPrefix,	
								   int	iVersion,				
								   const char *szClassProgID,	
								   const char *szThreadingModel,
								   const char *szModule ) 
{
	HRESULT	hr;
	char rcCLSID[MAX_LENGTH];			// CLSID\\szID.
	char rcProgID[MAX_LENGTH];			// szProgIDPrefix.szClassProgID
	char rcIndProgID[MAX_LENGTH];		// rcProgID.iVersion
	char rcInproc[MAX_LENGTH + 2]; 		// CLSID\\InprocServer32


	// format the prog ID values.
	sprintf( rcIndProgID, "%s.%s", szProgIDPrefix, szClassProgID ) ;
	sprintf( rcProgID, "%s.%d", rcIndProgID, iVersion );

	// do the initial portion.
	hr =  REGUTIL::_RegisterClassBase( rclsid, 
									   szDesc, 
						     		   rcProgID, 
							 	       rcIndProgID, 
							 	       rcCLSID );
	if ( SUCCEEDED( hr ) )
	{
		// set the server path.
	    SetKeyAndValue( rcCLSID, "InprocServer32", szModule );

		// add the threading model information.
		sprintf( rcInproc, "%s\\%s", rcCLSID, "InprocServer32" );
		SetRegValue( rcInproc, "ThreadingModel", szThreadingModel );
	}	
	

	return hr;

} // REGUTIL::RegisterCOMClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *		Unregister the basic information in the system registry for a given object class
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static public */
HRESULT REGUTIL::UnregisterCOMClass( REFCLSID rclsid,		   
									 const char *szProgIDPrefix,
									 int iVersion,			  
									 const char *szClassProgID )
{
	char szID[64];		   // the class ID to unregister.
	char rcCLSID[64];	   // CLSID\\szID.
	OLECHAR	szWID[64];	   // helper for the class ID to unregister.
	char rcProgID[128];	   // szProgIDPrefix.szClassProgID
	char rcIndProgID[128]; // rcProgID.iVersion


	// format the prog ID values.
	sprintf( rcProgID, "%s.%s", szProgIDPrefix, szClassProgID );
	sprintf( rcIndProgID, "%s.%d", rcProgID, iVersion );

	REGUTIL::_UnregisterClassBase( rclsid, rcProgID, rcIndProgID, rcCLSID );
	DeleteKey( rcCLSID, "InprocServer32" );

    StringFromGUID2(rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP, 
						 0, 
						 szWID, 
						 -1, 
						 szID, 
						 sizeof( szID ), 
						 NULL, 
						 NULL );

	DeleteKey( "CLSID", rcCLSID );
	
	
	return S_OK;

} // REGUTIL::UnregisterCOMClass



/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 * A private function to do the equavilent of a CoCreateInstance in
 * cases where we can't make the real call. Use this when, for
 * instance, you need to create a symbol reader in the Runtime but
 * we're not CoInitialized. Obviously, this is only good for COM
 * objects for which CoCreateInstance is just a glorified
 * find-and-load-me operation.
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static public */
HRESULT REGUTIL::FakeCoCreateInstance( REFCLSID rclsid,
		                               REFIID riid,
		                               void **ppv )
{
    HKEY key;
    DWORD len;
	LONG result;
    HRESULT hr = S_OK;
    OLECHAR guidString[64];
	char szID[64]; 	   			// the class ID to register.
    char keyString[1024];
    char dllName[MAX_PATH];


    StringFromGUID2( rclsid, guidString, NumItems( guidString ) );
	WideCharToMultiByte( CP_ACP, 
						 0, 
						 guidString, 
						 -1, 
						 szID, 
						 sizeof( szID ), 
						 NULL, 
						 NULL );

	sprintf( keyString, "CLSID\\%s\\InprocServer32", szID );
    // Lets grab the DLL name now.
    result = RegOpenKeyExA( HKEY_CLASSES_ROOT, 
                      	    keyString,
                            0, 
                      	    KEY_READ, 
                            &key );
    if ( result == ERROR_SUCCESS )
    {
        DWORD type;
            

        result = RegQueryValueExA( key, NULL, NULL, &type, NULL, &len );
        if ((result == ERROR_SUCCESS) && ((type == REG_SZ) ||
                                          (type == REG_EXPAND_SZ)))
        {
            result = RegQueryValueExA( key, NULL, NULL, &type, (BYTE*) dllName, &len );
            if (result == ERROR_SUCCESS)
			{
			    // We've got the name of the DLL to load, so load it.
			    HINSTANCE dll;
			    
			    
			    dll = LoadLibraryExA( dllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
			    if ( dll != NULL )
			    {
			        // We've loaded the DLL, so find the DllGetClassObject function.
			        FARPROC func;
			        
			        
			        func = GetProcAddress( dll, "DllGetClassObject" );
			        if ( func != NULL )
			        {
			            // Cool, lets call the function to get a class factory for
			            // the rclsid passed in.
			            IClassFactory *classFactory;
			            DLLGETCLASSOBJECT *dllGetClassObject = (DLLGETCLASSOBJECT*)func;


			            hr = dllGetClassObject( rclsid, IID_ICF, (void**)&classFactory );
			            if ( SUCCEEDED( hr ) )
			            {
			                //
			                // Ask the class factory to create an instance of the
			                // necessary object.
							//
			                hr = classFactory->CreateInstance( NULL, riid, ppv );

			                // Release that class factory!
			                classFactory->Release();
			            }
			        }
			        else
			            hr = HRESULT_FROM_WIN32( GetLastError() );
			    }
			    else
			        hr = HRESULT_FROM_WIN32( GetLastError() );
			}
			else
                hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
            hr = HRESULT_FROM_WIN32( GetLastError() );
    
       
        RegCloseKey( key );
    }
    else
        hr = HRESULT_FROM_WIN32( GetLastError() );
        

    return hr;

} // REGUTIL::FakeCoCreateInstance


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *		Register the basics for a in proc server.
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static private */
HRESULT REGUTIL::_RegisterClassBase( REFCLSID rclsid,
								     const char *szDesc,					
									 const char *szProgID,				
									 const char *szIndepProgID,			
									 char *szOutCLSID )				
{
	char szID[64]; 	   // the class ID to register.
	OLECHAR	szWID[64]; // helper for the class ID to register.


    StringFromGUID2( rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP, 
						 0, 
						 szWID, 
						 -1, 
						 szID, 
						 sizeof( szID ), 
						 NULL, 
						 NULL );

    strcpy( szOutCLSID, "CLSID\\" );
    strcat( szOutCLSID, szID );

    // create ProgID keys.
    SetKeyAndValue( szProgID, NULL, szDesc );
    SetKeyAndValue( szProgID, "CLSID", szID );

    // create VersionIndependentProgID keys.
    SetKeyAndValue( szIndepProgID, NULL, szDesc );
    SetKeyAndValue( szIndepProgID, "CurVer", szProgID );
    SetKeyAndValue( szIndepProgID, "CLSID", szID );

    // create entries under CLSID.
    SetKeyAndValue( szOutCLSID, NULL, szDesc );
    SetKeyAndValue( szOutCLSID, "ProgID", szProgID );
    SetKeyAndValue( szOutCLSID, "VersionIndependentProgID", szIndepProgID );
    SetKeyAndValue( szOutCLSID, "NotInsertable", NULL );
	
	
	return S_OK;

} // REGUTIL::_RegisterClassBase


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *		Delete the basic settings for an inproc server.
 *
 *	Parameters: 
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *				   
 *
 ***************************************************************************************/
/* static private */
HRESULT REGUTIL::_UnregisterClassBase( REFCLSID rclsid,
									   const char *szProgID,
									   const char *szIndepProgID,
									   char *szOutCLSID )
{
	char szID[64]; 	   // the class ID to register.
	OLECHAR	szWID[64]; // helper for the class ID to register.


    StringFromGUID2( rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP, 
						 0, 
						 szWID, 
						 -1, 
						 szID, 
						 sizeof( szID ), 
						 NULL, 
						 NULL );

	strcpy( szOutCLSID, "CLSID\\" );
	strcat( szOutCLSID, szID );

	// delete the version independant prog ID settings.
	DeleteKey( szIndepProgID, "CurVer" );
	DeleteKey( szIndepProgID, "CLSID" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szIndepProgID );

	// delete the prog ID settings.
	DeleteKey( szProgID, "CLSID" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szProgID );

	// delete the class ID settings.
	DeleteKey( szOutCLSID, "ProgID" );
	DeleteKey( szOutCLSID, "VersionIndependentProgID" );
	DeleteKey( szOutCLSID, "NotInsertable" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szOutCLSID );
	
	
	return S_OK;

} // REGUTIL::_UnregisterClassBase

#endif // __REGUTIL_HPP__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\chkcor\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <limits.h>
#include <windef.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\allocationsprofiler\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ProfilerOBJ.dll"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime Profiler\0"
#define VER_ORIGFILENAME_STR    "ProfilerOBJ.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\chkcor\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "chkcor.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Signature Viewer\0"
#define VER_ORIGFILENAME_STR    "chkcor.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cordmpmerge\heapmerge.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
	HEAPMERGE.CPP
	
	Owner: MRuhlen
 
	Takes a heap file and a minidump file and merges them producing a new
	minidump file with the heap merged in.  We'll leave a hole where the
	old memory list was, but that's ok.
****************************************************************************/

#include "windows.h"
#include "stddef.h"
#include "stdio.h"
#include "msostd.h"
#include "msouser.h"
#include "msoalloc.h"
#include "msoassert.h"
#include "msostr.h"
#include "minidump.h"

#ifdef DEBUG
#define DBG(x) x
#else
#define DBG(x)
#endif

#define PrintOOFExit() FailExit("OOF", ERROR_NOT_ENOUGH_MEMORY)

#define FOVERLAP(x, dx, y, dy) ((x <= y) && (y < x + dx) || (y < x) && (x < y + dy))

#define FMMDOVERLAP(x,y) FOVERLAP((x).StartOfMemoryRange, (x).Memory.DataSize, \
	(y).StartOfMemoryRange, (y).Memory.DataSize)

#define FMemModOVERLAP(x,y) FOVERLAP((x).StartOfMemoryRange, (x).Memory.DataSize, \
	(y).BaseOfImage, (y).SizeOfImage)

MSOAPI_(BOOL) FInitMsoThread (void);

MSOAPI_(BOOL) FInitMso (int);

// shamelessly stolen from DW
typedef struct _FileMapHandles
{
	HANDLE hFile;
	HANDLE hFileMap;
	void *pvMap;
	DWORD dwSize;
#ifdef DEBUG	
	BOOL fInitialized;
#endif
} FileMapHandles;	


void InitFileMapHandles(FileMapHandles *pfmh)
{
	Assert(pfmh != NULL);
	
	pfmh->pvMap = NULL;
	pfmh->hFileMap = NULL;
	pfmh->hFile = INVALID_HANDLE_VALUE;
#ifdef DEBUG	
	pfmh->fInitialized = TRUE;
#endif
}


/*----------------------------------------------------------------------------
	FMapFileHandle

	Helper function for FMapFile and FMapFileW
----------------------------------------------------------------- MRuhlen --*/
BOOL FMapFileHandle(FileMapHandles *pfmh)
{
	DBG(DWORD dw);
	
	if (pfmh->hFile == INVALID_HANDLE_VALUE)
		return FALSE;
		
	pfmh->dwSize = GetFileSize(pfmh->hFile, NULL);
	
	if (pfmh->dwSize == 0xFFFFFFFF || pfmh->dwSize == 0)
		{
		AssertSz(pfmh->dwSize == 0, "Bogus File Size:  FMapFile");
		
		CloseHandle(pfmh->hFile);
		pfmh->hFile = INVALID_HANDLE_VALUE;
		
		return FALSE;
		}
		
	pfmh->hFileMap = CreateFileMapping(pfmh->hFile, NULL, PAGE_WRITECOPY,
					  0, pfmh->dwSize, NULL);
					  
	if (pfmh->hFileMap == NULL)
		{
		DBG(dw = GetLastError());
		AssertSz(FALSE, "Failed to CreateFileMapping:  FMapFile");
		
		CloseHandle(pfmh->hFile);
		pfmh->hFile = INVALID_HANDLE_VALUE;
		
		return FALSE;
		}
		
	pfmh->pvMap = MapViewOfFile(pfmh->hFileMap, FILE_MAP_COPY, 0, 0, 0);

	if (pfmh->pvMap == NULL)
		{
		DBG(dw = GetLastError());
		Assert(FALSE);
		
		CloseHandle(pfmh->hFileMap);
		pfmh->hFileMap = NULL;
		CloseHandle(pfmh->hFile);
		pfmh->hFile = INVALID_HANDLE_VALUE;
		
		return FALSE;
		}

	return TRUE;
}

/*----------------------------------------------------------------------------
	FMapFile

	Performs memory mapping operations on a given FileMapHandles structure,
	returning TRUE if the file is sucessfully mapped.
----------------------------------------------------------------- MRuhlen --*/
BOOL FMapFile(char *szFileName, FileMapHandles *pfmh)
{
	int cRetries = 0;
	DWORD dw;
	
	Assert(pfmh != NULL);
	Assert(szFileName != NULL);

	// init structure
	InitFileMapHandles(pfmh);

	while (cRetries < 5)
		{
		pfmh->hFile = CreateFileA(szFileName,
								  GENERIC_READ,
								  0,    // no sharing allowed
								  NULL, // no security descriptor
								  OPEN_EXISTING,
								  FILE_READ_ONLY,
								  NULL); // required NULL on Win95

		if (pfmh->hFile == INVALID_HANDLE_VALUE)
			{
			dw = GetLastError();
			if (dw != ERROR_SHARING_VIOLATION && dw != ERROR_LOCK_VIOLATION &&
				dw != ERROR_NETWORK_BUSY)
				break;
				
			cRetries++;
			if (cRetries < 5)
				Sleep(250);
			}
		else
			break; // out of while loop!
		}
		
	return FMapFileHandle(pfmh);
}	


/*----------------------------------------------------------------------------
	UnmapFile

	Performs memory mapping operations on a given FileMapHandles structure,
	returning TRUE if the file is sucessfully mapped.
----------------------------------------------------------------- MRuhlen --*/
void UnmapFile(FileMapHandles *pfmh)
{
	AssertSz(pfmh->fInitialized, "Call UnmapFile on uninitialized handles");
	
	if (pfmh->pvMap != NULL)
		{
		UnmapViewOfFile(pfmh->pvMap);
		pfmh->pvMap = NULL;
		}
	if (pfmh->hFileMap != NULL)
		{
		CloseHandle(pfmh->hFileMap);
		pfmh->hFileMap = NULL;
		}
	if (pfmh->hFile != INVALID_HANDLE_VALUE)
		{
		CloseHandle(pfmh->hFile);
		pfmh->hFile = INVALID_HANDLE_VALUE;
		}
}


/*----------------------------------------------------------------------------
	ShowUsageExit

	Prints usage and then exits.
----------------------------------------------------------------- MRuhlen --*/
void ShowUsageExit(void)
{
	printf("heapmerge <old minidump file> <heap file> <new minidump file>\r\n");
	exit(ERROR_NOT_READY);
}


/*----------------------------------------------------------------------------
	FailExit

	Prints a failure message w/ param and exits
----------------------------------------------------------------- MRuhlen --*/
void FailExit(char *sz, DWORD dwFailCode)
{
	printf((sz) ? "Failure:  %s!!!\r\n" : "Failure!!!\r\n", sz);
	exit(dwFailCode);
}
	

/*----------------------------------------------------------------------------
	main

	duh...
----------------------------------------------------------------- MRuhlen --*/
void main(int argc, char **argv)
{
	FileMapHandles fmhOldMD = {0};
	FileMapHandles fmhHeap = {0};
	FileMapHandles fmhNewMD = {0};
	MSOTPX<MINIDUMP_MEMORY_DESCRIPTOR> *ppxmmdHeap = NULL;
	MSOTPX<MINIDUMP_MEMORY_DESCRIPTOR> *ppxmmdNewMD = NULL;
	MINIDUMP_MEMORY_LIST *pmmlOldMD = NULL;
	MINIDUMP_MEMORY_LIST mmlNew;
	MINIDUMP_MEMORY_DESCRIPTOR *pmmd;
	MINIDUMP_MEMORY_DESCRIPTOR *pmmdOld;
	MINIDUMP_HEADER *pmdh;
	MINIDUMP_DIRECTORY *pmdd;
	ULONG32 cHeapSections = 0;
	RVA rvaNewMemoryList;
	RVA rvaMemoryRangesStart;
	RVA rva;
	MINIDUMP_MODULE_LIST *pmmodlist = NULL;
	BOOL fSkip;
	DWORD TotalSkipped;
	DWORD cSkipped;
	MINIDUMP_MODULE *pmmod;
	int i, j, cAdded;
	BYTE *pb;
	BYTE *pbSource;
	DWORD offset;
	ULONG64 MemEnd;
	ULONG64 End;

	// FUTURE jeffmit: make this a command line parameter
	// the reason this is here is so that it is easy to get rid of overlaps if necessary
	BOOL fOverlapMemMod = 1; // switch that determines whether heap memory regions should
	                         // be allowed to overlap with normal minidump module regions

	// FUTURE jeffmit: make this a command line parameter
	// the reason this is here is so that it is easy to get rid of overlaps if necessary
	BOOL fOverlapMemMem = 0; // switch that determines whether heap memory regions should
	                         // be allowed to overlap with the normal minidump memory regions

	if (argc != 4)
		ShowUsageExit();

	if (!FMapFile(argv[1], &fmhOldMD) || ! FMapFile(argv[2], &fmhHeap))
		ShowUsageExit();
		
	DBG(fmhNewMD.fInitialized = TRUE);

	if (!FInitMso(0) || !FInitMsoThread())
		FailExit("Mso Static Lib init failed", ERROR_DLL_INIT_FAILED);

	fmhNewMD.hFile = CreateFileA(argv[3], GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
								 0, NULL);

	if (fmhNewMD.hFile == INVALID_HANDLE_VALUE)
		ShowUsageExit();

	// ok, we're ready to roll...
	ppxmmdHeap = new MSOTPX<MINIDUMP_MEMORY_DESCRIPTOR>;
	ppxmmdNewMD = new MSOTPX<MINIDUMP_MEMORY_DESCRIPTOR>;
	
	if (ppxmmdHeap == NULL || ppxmmdNewMD == NULL)
		PrintOOFExit();

	// load data

	if (!MiniDumpReadDumpStream(fmhOldMD.pvMap, MemoryListStream, NULL,
								(void **) &pmmlOldMD, NULL))
		FailExit("Reading Old Dump Memory Stream", ERROR_BAD_FORMAT);

	if (!fOverlapMemMod)
		{
		if (!MiniDumpReadDumpStream(fmhOldMD.pvMap, ModuleListStream, NULL,
									(void **) &pmmodlist, NULL))
			FailExit("Reading Old Dump Module Stream", ERROR_BAD_FORMAT);
		}

	cHeapSections = *((ULONG32*) fmhHeap.pvMap);
	if (!cHeapSections)
		FailExit("No heap sections found in Heap file!", ERROR_BAD_FORMAT);

	if (!ppxmmdHeap->FInit(cHeapSections, cHeapSections, msodgMisc) ||
		!ppxmmdNewMD->FInit(cHeapSections, cHeapSections, msodgMisc))
		PrintOOFExit();

	// figure out RVA for the new memory ranges
	// where the new memory list will start
	rvaNewMemoryList = fmhOldMD.dwSize;
    
	// align
	rvaNewMemoryList += 8 - (rvaNewMemoryList % 8);
	
	// all the rva's will be short by mmlNew.NumberOfMemoryRanges * sizeof(MINIDUMP_MEMORY_DESCRIPTOR)
	rvaMemoryRangesStart = 
		rvaNewMemoryList + offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]); 

	// lay out the new memory :)
	cAdded = 0;
	cSkipped = 0;
	TotalSkipped = 0;
	rva = rvaMemoryRangesStart;
	pmmd = (MINIDUMP_MEMORY_DESCRIPTOR *) 
	        ((BYTE*) fmhHeap.pvMap + sizeof(ULONG32));
	for (i = 0; i < cHeapSections; i++)
		{

		// make sure that the memory range does not overlap with a module
		fSkip = FALSE;
		if (!fOverlapMemMod)
			{
			for (j = 0; j < pmmodlist->NumberOfModules; j++)
				{
				pmmod = &pmmodlist->Modules[j];

				// make sure there is no overlap
				if (!FMemModOVERLAP(*pmmd, *pmmod))
					{
					// no overlap, try next module
					continue;
					}

				// partial memory range before the module
				if (pmmd->StartOfMemoryRange < pmmod->BaseOfImage)
					{
					pmmd->Memory.DataSize = pmmod->BaseOfImage - pmmd->StartOfMemoryRange;
					printf("Warning: partial region before module at %08I64x with size of %08x to be added.\n", 
							 pmmd->StartOfMemoryRange, pmmd->Memory.DataSize);
					continue; // keep looking for conflicts with remaining memory region 
					}

				MemEnd = pmmd->StartOfMemoryRange + pmmd->Memory.DataSize;
				End = pmmod->BaseOfImage + pmmod->SizeOfImage;

				// partial memory range after the module
				if (MemEnd > End)
					{
					pmmd->StartOfMemoryRange = End;
					pmmd->Memory.DataSize = MemEnd - End;
					printf("Warning: partial region after module at %08I64x with size of %08x to be added.\n", 
							 pmmd->StartOfMemoryRange, pmmd->Memory.DataSize);
					continue; // keep looking for conflicts with remaining memory region 
					}

				// memory range contained completely in this module, skip it
				cSkipped++;
				TotalSkipped += pmmd->Memory.DataSize;
				fSkip = TRUE;
				break;
				}
			}

		if (!fOverlapMemMem)
			{
			for (j = 0; j < pmmlOldMD->NumberOfMemoryRanges; j++)
				{
				pmmdOld = &pmmlOldMD->MemoryRanges[j];

				// make sure there is no overlap
				if (!FMMDOVERLAP(*pmmd, *pmmdOld))
					{
					// no overlap, try next module
					continue;
					}

				// partial memory range before the module
				if (pmmd->StartOfMemoryRange < pmmdOld->StartOfMemoryRange)
					{
					pmmd->Memory.DataSize = pmmdOld->StartOfMemoryRange - pmmd->StartOfMemoryRange;
					printf("Warning: partial region before region at %08I64x with size of %08x to be added.\n", 
							 pmmd->StartOfMemoryRange, pmmd->Memory.DataSize);
					continue; // keep looking for conflicts with remaining memory region 
					}

				MemEnd = pmmd->StartOfMemoryRange + pmmd->Memory.DataSize;
				End = pmmdOld->StartOfMemoryRange + pmmdOld->Memory.DataSize;

				// partial memory range after the module
				if (MemEnd > End)
					{
					pmmd->StartOfMemoryRange = End;
					pmmd->Memory.DataSize = MemEnd - End;
					printf("Warning: partial region after region at %08I64x with size of %08x to be added.\n", 
							 pmmd->StartOfMemoryRange, pmmd->Memory.DataSize);
					continue; // keep looking for conflicts with remaining memory region 
					}

				// memory range contained completely in this module, skip it
				cSkipped++;
				TotalSkipped += pmmd->Memory.DataSize;
				fSkip = TRUE;
				break;
				}
			}

		if (!fSkip)
			{
			ppxmmdHeap->FAppend(pmmd);
			ppxmmdNewMD->FAppend(pmmd);
			(*ppxmmdNewMD)[cAdded].Memory.Rva = rva;
			rva += pmmd->Memory.DataSize;
			Assert(ppxmmdNewMD->iMac == cAdded + 1 && ppxmmdHeap->iMac == cAdded + 1);
			Assert((*ppxmmdNewMD)[cAdded].StartOfMemoryRange == pmmd->StartOfMemoryRange);
			cAdded++;
			}
		else
			{
			printf("Warning: Skipping memory at: %08I64x with size of %08x\n", pmmd->StartOfMemoryRange, pmmd->Memory.DataSize);
			}
		pmmd++;
		}
		
	Assert(cSkipped + cAdded == cHeapSections);

	if (fOverlapMemMod && fOverlapMemMem)
		{
		Assert(cSkipped == 0);
		Assert(TotalSkipped == 0);
		}
	else
		{
		printf("RESULTS: Skipped %u regions, total size = %u bytes\n", cSkipped, 
				 TotalSkipped);
		}

	// now we know how many memory ranges were added
	mmlNew.NumberOfMemoryRanges = cAdded + pmmlOldMD->NumberOfMemoryRanges;

	// add the offset for the memory range descriptors
	offset = mmlNew.NumberOfMemoryRanges * sizeof(MINIDUMP_MEMORY_DESCRIPTOR);

	fmhNewMD.dwSize = rva + offset;
	
	rvaMemoryRangesStart += offset;

	// ready to map and copy :)
	fmhNewMD.hFileMap = CreateFileMapping(fmhNewMD.hFile, NULL, PAGE_READWRITE,
										  0, fmhNewMD.dwSize, NULL);
	if (fmhNewMD.hFileMap == NULL)
		FailExit("CreateFileMapping failed", ERROR_NOT_ENOUGH_MEMORY);
		
	fmhNewMD.pvMap = MapViewOfFile(fmhNewMD.hFileMap, FILE_MAP_WRITE, 0, 0, 0);
	if (fmhNewMD.pvMap == NULL)
		FailExit("MapViewOfFile failed", ERROR_NOT_ENOUGH_MEMORY);

	// we're ready to go!
	// first we blast over the old Minidump
	memcpy(fmhNewMD.pvMap, fmhOldMD.pvMap, fmhOldMD.dwSize);
	
	// now write out the new memory list
	pb = ((BYTE *) fmhNewMD.pvMap) + rvaNewMemoryList;
	
	// on the off chance they change this from a ULONG32 this should still work
	memcpy(pb, &mmlNew, offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]));
	
	// copy the OLD memory list to the front
	pb += offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]);
	pmmd = &(pmmlOldMD->MemoryRanges[0]);
	for (i = 0; i < pmmlOldMD->NumberOfMemoryRanges; i++)
		{
		memcpy(pb, pmmd, sizeof(*pmmd));
		pb += sizeof(*pmmd);
		pmmd++;
		}
		
	Assert(sizeof(*pmmd) == ppxmmdNewMD->cbItem);
	// now we copy the NEW memory list
	for (i = 0; i < ppxmmdNewMD->iMac; i++)
		{
		// adjust the rva's for the new memory list
		(*ppxmmdNewMD)[i].Memory.Rva += offset;

		memcpy(pb, &((*ppxmmdNewMD)[i]), sizeof(*pmmd));
		pb += sizeof(*pmmd);
		}
		
	Assert(((RVA) (pb - (BYTE *) fmhNewMD.pvMap)) == rvaMemoryRangesStart);
	
	for (i = 0; i < ppxmmdHeap->iMac; i++)
		{
		pbSource = (*ppxmmdHeap)[i].Memory.Rva + (BYTE *) fmhHeap.pvMap;
		memcpy(pb, pbSource, (*ppxmmdHeap)[i].Memory.DataSize);
		pb += (*ppxmmdHeap)[i].Memory.DataSize;
		}

	Assert(((RVA) (pb - (BYTE *) fmhNewMD.pvMap)) == fmhNewMD.dwSize);
	
	// now we just need to change the directory entry to point at the new
	// memory list :)
	
	pmdh = (MINIDUMP_HEADER *) fmhNewMD.pvMap;
	pmdd = (MINIDUMP_DIRECTORY *) ((BYTE *) pmdh + pmdh->StreamDirectoryRva);

	for (i = 0; i < pmdh->NumberOfStreams; i++)
		{
		if (pmdd->StreamType == MemoryListStream)
			{
			pmdd->Location.Rva = rvaNewMemoryList;
			pmdd->Location.DataSize = rvaMemoryRangesStart - rvaNewMemoryList;
			break;
			}
		pmdd++;
		}	

	// we're DONE!
	printf("Merge successful!\r\n");

	UnmapFile(&fmhNewMD);
	UnmapFile(&fmhHeap);
	UnmapFile(&fmhOldMD);
	delete ppxmmdHeap;
	delete ppxmmdNewMD;

	exit(ERROR_SUCCESS);
}

// end of file, heapmerge.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cordmpmerge\cordmpmerge.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
    HEAPMERGE.CPP

    Owner: MRuhlen
    Takes a heap file and a minidump file and merges them producing a new
    minidump file with the heap merged in.  We'll leave a hole where the
    old memory list was, but that's ok.
****************************************************************************/

#include "windows.h"
#include "stddef.h"
#include "stdio.h"
#include "assert.h"
#include "stdlib.h"
#include "dbghelp.h"

#ifdef DBG
    #undef DBG
#endif

#ifdef _DEBUG
    #define DBG(x) x
#else
    #define DBG(x)
#endif

#define Assert(x) assert(x)
#define AssertSz(x,y) assert(x)

#define PrintOOFExit() FailExit("OOF")

// shamelessly stolen from DW
typedef struct _FileMapHandles
{
    HANDLE hFile;
    HANDLE hFileMap;
    void *pvMap;
    DWORD dwSize;
#ifdef _DEBUG	
    BOOL fInitialized;
#endif
} FileMapHandles;   


void InitFileMapHandles(FileMapHandles *pfmh)
{
    Assert(pfmh != NULL);

    pfmh->pvMap = NULL;
    pfmh->hFileMap = NULL;
    pfmh->hFile = INVALID_HANDLE_VALUE;
#ifdef _DEBUG	
    pfmh->fInitialized = TRUE;
#endif
}


/*----------------------------------------------------------------------------
    FMapFileHandle

    Helper function for FMapFile and FMapFileW
----------------------------------------------------------------- MRuhlen --*/
BOOL FMapFileHandle(FileMapHandles *pfmh)
{
    DBG(DWORD dw);

    if (pfmh->hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    pfmh->dwSize = GetFileSize(pfmh->hFile, NULL);

    if (pfmh->dwSize == 0xFFFFFFFF || pfmh->dwSize == 0)
    {
        AssertSz(pfmh->dwSize == 0, "Bogus File Size:  FMapFile");

        CloseHandle(pfmh->hFile);
        pfmh->hFile = INVALID_HANDLE_VALUE;

        return FALSE;
    }

    pfmh->hFileMap = CreateFileMapping(pfmh->hFile, NULL, PAGE_WRITECOPY,
                                       0, pfmh->dwSize, NULL);

    if (pfmh->hFileMap == NULL)
    {
        DBG(dw = GetLastError());
        AssertSz(FALSE, "Failed to CreateFileMapping:  FMapFile");

        CloseHandle(pfmh->hFile);
        pfmh->hFile = INVALID_HANDLE_VALUE;

        return FALSE;
    }

    pfmh->pvMap = MapViewOfFile(pfmh->hFileMap, FILE_MAP_COPY, 0, 0, 0);

    if (pfmh->pvMap == NULL)
    {
        DBG(dw = GetLastError());
        Assert(FALSE);

        CloseHandle(pfmh->hFileMap);
        pfmh->hFileMap = NULL;
        CloseHandle(pfmh->hFile);
        pfmh->hFile = INVALID_HANDLE_VALUE;

        return FALSE;
    }

    return TRUE;
}

/*----------------------------------------------------------------------------
    FMapFile

    Performs memory mapping operations on a given FileMapHandles structure,
    returning TRUE if the file is sucessfully mapped.
----------------------------------------------------------------- MRuhlen --*/
BOOL FMapFile(char *szFileName, FileMapHandles *pfmh)
{
    int cRetries = 0;
    DWORD dw;

    Assert(pfmh != NULL);
    Assert(szFileName != NULL);

    // init structure
    InitFileMapHandles(pfmh);

    while (cRetries < 5)
    {
        pfmh->hFile = CreateFileA(szFileName,
                                  GENERIC_READ,
                                  0,    // no sharing allowed
                                  NULL, // no security descriptor
                                  OPEN_EXISTING,
                                  FILE_READ_ONLY,
                                  NULL); // required NULL on Win95

        if (pfmh->hFile == INVALID_HANDLE_VALUE)
        {
            dw = GetLastError();
            if (dw != ERROR_SHARING_VIOLATION && dw != ERROR_LOCK_VIOLATION &&
                dw != ERROR_NETWORK_BUSY)
                break;

            cRetries++;
            if (cRetries < 5)
                Sleep(250);
        } else
            break; // out of while loop!
    }

    return FMapFileHandle(pfmh);
}   


/*----------------------------------------------------------------------------
    UnmapFile

    Performs memory mapping operations on a given FileMapHandles structure,
    returning TRUE if the file is sucessfully mapped.
----------------------------------------------------------------- MRuhlen --*/
void UnmapFile(FileMapHandles *pfmh)
{
    AssertSz(pfmh->fInitialized, "Call UnmapFile on uninitialized handles");

    if (pfmh->pvMap != NULL)
    {
        UnmapViewOfFile(pfmh->pvMap);
        pfmh->pvMap = NULL;
    }
    if (pfmh->hFileMap != NULL)
    {
        CloseHandle(pfmh->hFileMap);
        pfmh->hFileMap = NULL;
    }
    if (pfmh->hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(pfmh->hFile);
        pfmh->hFile = INVALID_HANDLE_VALUE;
    }
}


/*----------------------------------------------------------------------------
    ShowUsageExit

    Prints usage and then exits.
----------------------------------------------------------------- MRuhlen --*/
void ShowUsageExit(void)
{
    printf("heapmerge <old minidump file> <heap file> <new minidump file>\r\n");
    exit(1);
}


/*----------------------------------------------------------------------------
    FailExit

    Prints a failure message w/ param and exits
----------------------------------------------------------------- MRuhlen --*/
void FailExit(char *sz)
{
    printf((sz) ? "Failure:  %s!!!\r\n" : "Failure!!!\r\n", sz);
    exit(1);
}

// Returns true if there is any overlap of pMem1 and pMem2
bool IsOverlapping(
    MINIDUMP_MEMORY_DESCRIPTOR *pMem1,
    MINIDUMP_MEMORY_DESCRIPTOR *pMem2)
{
    Assert(pMem1->Memory.DataSize > 0 && pMem2->Memory.DataSize > 0);

    if (pMem1->StartOfMemoryRange < pMem2->StartOfMemoryRange)
    {
        if ((pMem1->StartOfMemoryRange + pMem1->Memory.DataSize) > pMem2->StartOfMemoryRange)
            return (true);
    }

    else if (pMem2->StartOfMemoryRange < pMem1->StartOfMemoryRange)
    {
        if ((pMem2->StartOfMemoryRange + pMem2->Memory.DataSize) > pMem1->StartOfMemoryRange)
            return (true);
    }

    // Same starting point means overlap
    else
    {
        return (true);
    }

    return (false);
}

// Returns true if pMem1 contains pMem2
bool IsContaining(
    MINIDUMP_MEMORY_DESCRIPTOR *pMem1,
    MINIDUMP_MEMORY_DESCRIPTOR *pMem2)
{
    // If the start of 1 is before or equal to 2 the first condition is satisfied
    if (pMem1->StartOfMemoryRange <= pMem2->StartOfMemoryRange)
    {
        // If the end of 2 is before or equal to 1 the second condition is satisfied
        if ((pMem2->StartOfMemoryRange + pMem2->Memory.DataSize) <= (pMem1->StartOfMemoryRange + pMem1->Memory.DataSize))
        {
            return (true);
        }
    }

    // pMem1 does not contain pMem2
    return (false);
}

int __cdecl MDMemDescriptorCompare(const void *pvArg1, const void *pvArg2)
{
    MINIDUMP_MEMORY_DESCRIPTOR *pArg1 = (MINIDUMP_MEMORY_DESCRIPTOR *)pvArg1;
    MINIDUMP_MEMORY_DESCRIPTOR *pArg2 = (MINIDUMP_MEMORY_DESCRIPTOR *)pvArg2;

    if (pArg1->StartOfMemoryRange < pArg2->StartOfMemoryRange)
        return (-1);
    else if (pArg2->StartOfMemoryRange < pArg1->StartOfMemoryRange)
        return (1);
    else
        return (0);
}

/*----------------------------------------------------------------------------
    CheckForRealloc
    
    Will reallocate the array if necessary
----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
    EliminateMemoryOverlaps
    
    This will eliminate overlaps of the real MiniDump file and the managed
    heap dump, giving priority to the contents of the minidump.

    The ppNewMemoryRanges will contained a modified version of pHeapList's
    MemoryRanges member with all RVAs corresponding to the same heap as
    pHeapList came from.  This list could be longer, shorter or the same size
    as pHeapList - this is indicated by the OUT value of pc
---------------------------------------------------------------- SimonHal --*/

#define ENDADDR(descriptor) ((descriptor)->StartOfMemoryRange + (descriptor)->Memory.DataSize)

bool EliminateMemoryOverlaps(
    MINIDUMP_MEMORY_LIST        *pMdList,
    MINIDUMP_MEMORY_LIST        *pHeapList,
    ULONG32                     *pcNewMemoryRanges,
    MINIDUMP_MEMORY_DESCRIPTOR **ppNewNumberOfMemoryRanges)
{
    bool fSuccess = false;

    // First assume we'll end up with about the same number of ranges - will grow to suit
    ULONG32 cTotalRanges = pHeapList->NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR *pRanges = new MINIDUMP_MEMORY_DESCRIPTOR[cTotalRanges];

    if (pRanges == NULL)
        goto ErrExit;

    // First, we need to copy the MiniDump list and sort it so that the below loop functions properly
    MINIDUMP_MEMORY_DESCRIPTOR *pMdMemSort = new MINIDUMP_MEMORY_DESCRIPTOR[pMdList->NumberOfMemoryRanges];

    if (pMdMemSort == NULL)
        goto ErrExit;

    // Copy the contents
    memcpy((void *)pMdMemSort, (const void *)pMdList->MemoryRanges,
           sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * pMdList->NumberOfMemoryRanges);

    // Sort the contents
    qsort((void *)pMdMemSort, pMdList->NumberOfMemoryRanges, sizeof(MINIDUMP_MEMORY_DESCRIPTOR), MDMemDescriptorCompare);

    // Iterate over heap dump one by one
    ULONG32 iCurHeapMem = 0;
    ULONG32 iCurNewMem = 0;
    while (iCurHeapMem < pHeapList->NumberOfMemoryRanges)
    {
        // Re-alloc pRanges if iCurNewMem == cTotalRanges - 1;
        if (iCurNewMem >= cTotalRanges - 1)
        {
            ULONG32 cNewTotalRanges = cTotalRanges * 2;
            MINIDUMP_MEMORY_DESCRIPTOR *pNewRanges = new MINIDUMP_MEMORY_DESCRIPTOR[cNewTotalRanges];

            if (pNewRanges == NULL)
                goto ErrExit;

            memcpy((void *)pNewRanges, (const void *)pRanges, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * iCurNewMem);

            // Now switch to the new array
            delete [] pRanges;
            cTotalRanges = cNewTotalRanges;
            pRanges = pNewRanges;
        }

        // Copy the current heap entry into the new heap entry
        pRanges[iCurNewMem] = pHeapList->MemoryRanges[iCurHeapMem++];

        // Now iterate over the minidump memory ranges looking for overlap, splitting the newly added
        // range as appropriate to compensate
        ULONG32 iCurMdMem = 0;
        while (iCurMdMem < pMdList->NumberOfMemoryRanges)
        {
            MINIDUMP_MEMORY_DESCRIPTOR *pCurMdMem = &pMdMemSort[iCurMdMem];
            MINIDUMP_MEMORY_DESCRIPTOR *pCurNewMem = &pRanges[iCurNewMem];

            if (IsOverlapping(pCurMdMem, pCurNewMem))
            {
                if (pCurNewMem->StartOfMemoryRange < pCurMdMem->StartOfMemoryRange)
                {
                    // Hold on to the original values of the descriptor
                    MINIDUMP_MEMORY_DESCRIPTOR oldMem = *pCurNewMem;

                    // Shrink the current dump entry to end at the start of the minidump entry
                    ULONG32 cbNewDataSize = (ULONG32) (pCurMdMem->StartOfMemoryRange - oldMem.StartOfMemoryRange);
                    pCurNewMem->Memory.DataSize = cbNewDataSize;

                    Assert(cbNewDataSize > 0);
                    pCurNewMem = &pRanges[++iCurNewMem];

                    // Now set up the remainder of the memory block to be disjoint from the new one above
                    pCurNewMem->StartOfMemoryRange = oldMem.StartOfMemoryRange + cbNewDataSize;
                    pCurNewMem->Memory.DataSize = oldMem.Memory.DataSize - cbNewDataSize;
                    pCurNewMem->Memory.Rva = oldMem.Memory.Rva + cbNewDataSize;
                }

                // The above if statement should guarantee this is true
                Assert(pCurMdMem->StartOfMemoryRange <= pCurNewMem->StartOfMemoryRange);

                // If the current block extends beyond the minidump block then push the 
                if (ENDADDR(pCurMdMem) < ENDADDR(pCurNewMem))
                {
                    // Hold on to the original values of the descriptor
                    MINIDUMP_MEMORY_DESCRIPTOR oldMem = *pCurNewMem;

                    // Shrink the current dump entry to begin at the end of the minidump entry
                    ULONG32 cbNewDataRemoved = (ULONG32) (ENDADDR(pCurMdMem) - oldMem.StartOfMemoryRange);
                    ULONG32 cbNewDataSize = (ULONG32) (ENDADDR(&oldMem) - ENDADDR(pCurMdMem));

                    Assert(cbNewDataSize > 0);

                    pCurNewMem->StartOfMemoryRange = ENDADDR(pCurMdMem);
                    pCurNewMem->Memory.DataSize = cbNewDataSize;
                    pCurNewMem->Memory.Rva = oldMem.Memory.Rva + cbNewDataRemoved;
                }

                // If there was no trailing data, then we can move on to the next heap item
                else
                    break;
            }

            iCurMdMem++;
        }

        // If the current memory block made it to the end then there's no overlap then it gets added
        if (iCurMdMem == pMdList->NumberOfMemoryRanges)
            iCurNewMem++;
    }

    fSuccess = true;

ErrExit:
    if (pMdMemSort != NULL)
        delete [] pMdMemSort;

    if (!fSuccess && pRanges != NULL)
    {
        delete [] pRanges;
        pRanges = NULL;
    }

    *pcNewMemoryRanges = iCurNewMem;
    *ppNewNumberOfMemoryRanges = pRanges;

    return (fSuccess);
}

void PrintManagedDump(char *dumpFile)
{
    FileMapHandles fmhDump = {0};

    if (!FMapFile(dumpFile, &fmhDump))
    {
        printf("couldn't open dump file %s\n", dumpFile);
        return;
    }

    MINIDUMP_MEMORY_LIST *pMemList;
    ULONG32 cMemRanges;
    MINIDUMP_MEMORY_DESCRIPTOR *pRanges;
    DWORD dumpSig = 0x00141F2B; // 100000th prime number ;-)

    if (MiniDumpReadDumpStream(fmhDump.pvMap, MemoryListStream, NULL, (void **) &pMemList, NULL))
    {
        cMemRanges = pMemList->NumberOfMemoryRanges;
        pRanges = &pMemList->MemoryRanges[0];
    }
    else if (*((DWORD*)((BYTE *)fmhDump.pvMap + fmhDump.dwSize - sizeof(DWORD))) == dumpSig)
    {
        cMemRanges = *((ULONG32 *)fmhDump.pvMap);
        pRanges = (MINIDUMP_MEMORY_DESCRIPTOR *)
            ((BYTE *)fmhDump.pvMap + offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]));
    }
    else
    {
        printf("invalid dump file %s\n", dumpFile);
        return;
    }

    MINIDUMP_MEMORY_DESCRIPTOR *pRangesSrt = new MINIDUMP_MEMORY_DESCRIPTOR[cMemRanges];

    // Copy the contents
    memcpy((void *)pRangesSrt, (const void *)pRanges, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cMemRanges);

    // Sort the contents
    qsort((void *)pRangesSrt, cMemRanges, sizeof(MINIDUMP_MEMORY_DESCRIPTOR), MDMemDescriptorCompare);

    printf("  %d memory ranges\n", cMemRanges);
    printf("  range#    Address      Size\n");

    MINIDUMP_MEMORY_DESCRIPTOR *pCurRange = pRangesSrt;
    MINIDUMP_MEMORY_DESCRIPTOR *pEndRange = pRangesSrt + cMemRanges;
    HANDLE hConsoleBuffer = GetStdHandle(STD_OUTPUT_HANDLE);

    for (ULONG32 i = 0; pCurRange != pEndRange; i++)
    {
        printf("  %6d    %08x    %08x", i, (DWORD)(pCurRange->StartOfMemoryRange), (DWORD)(pCurRange->Memory.DataSize));

        printf("    ");

        if (i > 0 && ENDADDR(pCurRange-1) > pCurRange->StartOfMemoryRange)
            printf("(detected overlap)  ");

        ULONG32 cBytesToDump = 50;
        if (hConsoleBuffer != INVALID_HANDLE_VALUE)
        {
            CONSOLE_SCREEN_BUFFER_INFO info;
            if (GetConsoleScreenBufferInfo(hConsoleBuffer, &info) && (info.dwSize.X > info.dwCursorPosition.X))
                cBytesToDump = (ULONG32) (info.dwSize.X - info.dwCursorPosition.X - 1);
        }

        BYTE *pStartByte = (BYTE*)fmhDump.pvMap + pCurRange->Memory.Rva;
        BYTE *pCurByte = pStartByte;
        BYTE *pEndByte = pCurByte + pCurRange->Memory.DataSize;
        ULONG32 cBytesDumped = 0;
        while (pCurByte != pEndByte && cBytesDumped < cBytesToDump)
        {
            if (isprint((int)(*pCurByte)))
            {
                printf("%c", (int)(*pCurByte));
                cBytesDumped++;
            }

            // The condition is to make ascii-unicode strings look better.
            else if (!(pCurByte != pStartByte && isprint((int)*(pCurByte-1)) && *pCurByte == 0))
            {
                printf(".");
                cBytesDumped++;
            }

            pCurByte++;
        }

        printf("\n");

        pCurRange++;
    }

    CloseHandle(hConsoleBuffer);
    delete [] pRangesSrt;
    UnmapFile(&fmhDump);
}


/*----------------------------------------------------------------------------
    main

    duh...
----------------------------------------------------------------- MRuhlen --*/
extern "C" void _cdecl main(int argc, char **argv)
{
    FileMapHandles fmhOldMD = {0};
    FileMapHandles fmhHeap = {0};
    FileMapHandles fmhNewMD = {0};
    MINIDUMP_MEMORY_DESCRIPTOR *ppxmmdHeap = NULL;
    MINIDUMP_MEMORY_DESCRIPTOR *ppxmmdNewMD = NULL;
    MINIDUMP_MEMORY_LIST *pmmlOldMD = NULL;
    MINIDUMP_MEMORY_LIST mmlNew;
    MINIDUMP_MEMORY_DESCRIPTOR *pmmd;
    MINIDUMP_HEADER *pmdh;
    MINIDUMP_DIRECTORY *pmdd;
    ULONG32 cHeapSections = 0;
    RVA rvaNewMemoryList;
    RVA rvaMemoryRangesStart;
    RVA rva;
    DWORD i;
    BYTE *pb;
    BYTE *pbSource;

    if (argc == 2)
    {
        PrintManagedDump(argv[1]);
        return;
    }

    if (argc != 4)
        ShowUsageExit();

    if (!FMapFile(argv[1], &fmhOldMD) || ! FMapFile(argv[2], &fmhHeap))
        ShowUsageExit();

    DBG(fmhNewMD.fInitialized = TRUE);

    fmhNewMD.hFile = CreateFileA(argv[3], GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                                 0, NULL);

    if (fmhNewMD.hFile == INVALID_HANDLE_VALUE)
        ShowUsageExit();

    // load data

    if (!MiniDumpReadDumpStream(fmhOldMD.pvMap, MemoryListStream, NULL, (void **) &pmmlOldMD, NULL))
        FailExit("Reading Old Dump Memory Stream");

    MINIDUMP_MEMORY_DESCRIPTOR *pNewHeapSections;
    EliminateMemoryOverlaps(pmmlOldMD, (MINIDUMP_MEMORY_LIST *)fmhHeap.pvMap, &cHeapSections, &pNewHeapSections);

    // ok, we're ready to roll...
    ppxmmdHeap = new MINIDUMP_MEMORY_DESCRIPTOR[cHeapSections];
    ppxmmdNewMD = new MINIDUMP_MEMORY_DESCRIPTOR[cHeapSections];

    if (ppxmmdHeap == NULL || ppxmmdNewMD == NULL)
        PrintOOFExit();

    // figure out RVA for the new memory ranges
    // where the new memory list will start
    rvaNewMemoryList = fmhOldMD.dwSize;

    // align
    rvaNewMemoryList += 8 - (rvaNewMemoryList % 8);

    // acount for new memory list
    mmlNew.NumberOfMemoryRanges = cHeapSections + pmmlOldMD->NumberOfMemoryRanges;

    rvaMemoryRangesStart = rvaNewMemoryList + offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]) + 
        mmlNew.NumberOfMemoryRanges * sizeof(MINIDUMP_MEMORY_DESCRIPTOR); 

    // lay out the new memory :)
    rva = rvaMemoryRangesStart;
    pmmd = pNewHeapSections;
    for (i = 0; i < cHeapSections; i++)
    {
        memcpy (&ppxmmdHeap[i], pmmd, sizeof(MINIDUMP_MEMORY_DESCRIPTOR));
        memcpy (&ppxmmdNewMD[i],pmmd, sizeof(MINIDUMP_MEMORY_DESCRIPTOR));
        ppxmmdNewMD[i].Memory.Rva = rva;
        rva += pmmd->Memory.DataSize;
        Assert(ppxmmdNewMD[i].StartOfMemoryRange == pmmd->StartOfMemoryRange);
        pmmd++;
    }

    fmhNewMD.dwSize = rva;

    // ready to map and copy :)
    fmhNewMD.hFileMap = CreateFileMapping(fmhNewMD.hFile, NULL, PAGE_READWRITE, 0, fmhNewMD.dwSize, NULL);
    if (fmhNewMD.hFileMap == NULL)
        FailExit("CreateFileMapping failed");

    fmhNewMD.pvMap = MapViewOfFile(fmhNewMD.hFileMap, FILE_MAP_WRITE, 0, 0, 0);
    if (fmhNewMD.pvMap == NULL)
        FailExit("MapViewOfFile failed");

    // we're ready to go!
    // first we blast over the old Minidump
    memcpy(fmhNewMD.pvMap, fmhOldMD.pvMap, fmhOldMD.dwSize);

    // now write out the new memory list
    pb = ((BYTE *) fmhNewMD.pvMap) + rvaNewMemoryList;

    // on the off chance they change this from a ULONG32 this should still work
    memcpy(pb, &mmlNew, offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]));

    // copy the OLD memory list to the front
    pb += offsetof(MINIDUMP_MEMORY_LIST, MemoryRanges[0]);
    pmmd = &(pmmlOldMD->MemoryRanges[0]);
    for (i = 0; i < pmmlOldMD->NumberOfMemoryRanges; i++)
    {
        memcpy(pb, pmmd, sizeof(*pmmd));
        pb += sizeof(*pmmd);
        pmmd++;
    }

    // now we copy the NEW memory list
    pmmd = ppxmmdNewMD;
    for (i = 0; i < cHeapSections; i++)
    {
        memcpy(pb, pmmd, sizeof(*pmmd));
        pb += sizeof(*pmmd);
        pmmd++;
    }

    Assert(((RVA) (pb - (BYTE *) fmhNewMD.pvMap)) == rvaMemoryRangesStart);

    for (i = 0; i < cHeapSections; i++)
    {
        pbSource = ppxmmdHeap[i].Memory.Rva + (BYTE *) fmhHeap.pvMap;
        memcpy(pb, pbSource, ppxmmdHeap[i].Memory.DataSize);
        pb += ppxmmdHeap[i].Memory.DataSize;
    }

    Assert(((RVA) (pb - (BYTE *) fmhNewMD.pvMap)) == fmhNewMD.dwSize);

    // now we just need to change the directory entry to point at the new
    // memory list :)

    pmdh = (MINIDUMP_HEADER *) fmhNewMD.pvMap;
    pmdd = (MINIDUMP_DIRECTORY *) ((BYTE *) pmdh + pmdh->StreamDirectoryRva);

    for (i = 0; i < pmdh->NumberOfStreams; i++)
    {
        if (pmdd->StreamType == MemoryListStream)
        {
            pmdd->Location.Rva = rvaNewMemoryList;
            pmdd->Location.DataSize = rvaMemoryRangesStart - rvaNewMemoryList;
            break;
        }
        pmdd++;
    }   

    // we're DONE!
    printf("Merge successful!\r\n");

    UnmapFile(&fmhNewMD);
    UnmapFile(&fmhHeap);
    UnmapFile(&fmhOldMD);
    delete ppxmmdHeap;
    delete ppxmmdNewMD;
}

// end of file, heapmerge.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cordmpmerge\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_APP
#define VER_INTERNALNAME_STR	"PEVERIFY.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework PE, Metadata and IL Verification Tool\0"
#define VER_ORIGFILENAME_STR    "peverify.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\chkcor\trust.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* Headers
 **********/

#include "stdpch.h"
#pragma hdrstop

#include <stdio.h>
#include <wintrust.h>
#include <softpub.h>
#include <urlmon.h>
#include "CorPolicy.h"
#include "CorPermE.h"
#include "CorPerm.h"
#include "CorPermP.h"
#include "Cor.h"
#include "utilcode.h"
#include "posterror.h"
#include "__file__.ver"
#include "__file__.h"

BOOL fGrantedPermissions = FALSE;
BOOL fRequestedPermissions = FALSE;
BOOL fQuiet = FALSE;
LPSTR psFileName  = NULL;
LPSTR psSignature = NULL;

static HRESULT SaveData(LPCSTR pszFile, PBYTE pbData, DWORD cbData, BOOL fAppend = FALSE);
static BOOL WriteErrorMessage(HRESULT hr);

const LPCSTR FileNameError = "\nA filename must be supplied with option";

void Usage()
{
    printf(VER_FILEDESCRIPTION_STR);
    printf(" ");
    printf(VER_FILEVERSION_STR );
    printf("\nCopyright (c) Microsoft Corp. 1998-1999. All rights reserved.\n");
    printf("\n");
    // Undocumented options [/D] [/S filename]
    //printf("CHKCOR [/G] [/D] [/O filename] [/S filename] [/Q] signed_file\n");
    printf("CHKCOR [/G] [/O filename] [/Q] signed_file\n");
    printf("\n");
    printf("  signed_file - Name of the signed file.\n");
    printf("\n");
    printf("  /G                Display granted permissions.\n");
    // Undocumented option /D
    //printf("  /D              Display requested permissions.\n");
    printf("  /O filename       Output file for permissions.\n");
    // Undocumented option [/S filename]
    //printf("  /S filename       Output file for signature.\n");
    printf("  /Q                Do not display dialog.\n");
    exit(0);
}

// Parse arguements
void 
ParseSwitch (CHAR chSwitch,
             unsigned *pArgc,
             char **pArgv[])
{

   switch (toupper (chSwitch)) {
   case '?':
       Usage();
       break;
   case 'G':
       fGrantedPermissions = TRUE;
       break;
   case 'D':
       fRequestedPermissions = TRUE;
       break;
   case 'O':
      if (!--(*pArgc))
      {
          printf(FileNameError);
          printf(" -O\n\n");
          Usage ();
      }
      (*pArgv)++;
      if(**pArgv == NULL) 
      {
          printf(FileNameError);
          printf(" -O\n\n");
          Usage();
      }
      psFileName = **pArgv;
      break;
   case 'S':
      // Undocumented option.
      if (!--(*pArgc))
      {
          printf(FileNameError);
          printf(" -S\n\n");
          Usage ();
      }
      (*pArgv)++;
      if(**pArgv == NULL) 
      {
          printf(FileNameError);
          printf(" -S\n\n");
          Usage();
      }
      psSignature = **pArgv;
      break;
   case 'Q':
       fQuiet = TRUE;
       break;
   default:
       Usage ();
       break;

   }
}

void _cdecl main(unsigned argc, char **argv)
{
    PCOR_TRUST pData = NULL;
    WCHAR   wpath [_MAX_PATH];
    char*   pProgram = NULL;
    char*   pchChar;
    DWORD   dwExpectedError = 0;
    HRESULT hr = S_OK;

    if (argc <= 1) Usage();
    
    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            ParseSwitch (*++pchChar, &argc, &argv);
        } 
        else {
            pProgram = pchChar;
            MultiByteToWideChar(CP_ACP, 0, pchChar, -1, wpath, _MAX_PATH);
            }
    }
    
    if (!pProgram) {
        Usage();
    }
    // Init unicode wrappers.
    OnUnicodeSystem();

    // Init Security debugging
    InitSecurityDebug();

    // Set thread in STA mode
    HRESULT hrCOM = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if(FAILED(hrCOM)) {
        SECLOG(("Unable to initialize COM"), S_CRITICAL);
        exit (1);
    }

    // If we are not testing the shutdown bug then open the VM
    // so it is refcounted correctly.

    BOOL fEEStarted = FALSE;
    CORTRY {

        DWORD      dwData;
        DWORD      dwFlags = 0;

        hr = CoInitializeEE(COINITEE_DEFAULT);
        if(FAILED(hr)) CORTHROWMSG(hr, "Failed to startup the EE");
        fEEStarted = TRUE;

        if(fGrantedPermissions)
            dwFlags |= COR_DISPLAYGRANTED;
        if(fQuiet)
            dwFlags |= COR_NOUI;

        hr = GetPublisher(wpath,
                          NULL,
                          dwFlags,
                          &pData,
                          &dwData);
        if(hr == TRUST_E_SUBJECT_NOT_TRUSTED)
            hr = S_OK;
        if(hr == CERT_E_UNTRUSTEDTESTROOT) {
            printf("Warning: The certificate chain validating this signature terminates\n");
            printf("in the test root, which is not currently trusted.\n");
            hr = S_OK;
        }
        if (hr == TRUST_E_NOSIGNATURE) {
            printf("No signature present in the file\n");
            hr = S_OK;
        }

        if(FAILED(hr)) CORTHROWMSG(hr, "Unable to get signature information");
        
        if(psFileName || fRequestedPermissions) {
            BYTE   *pbMinimal;
            DWORD   cbMinimal;
            BYTE   *pbOptional;
            DWORD   cbOptional;
            BYTE   *pbRefused;
            DWORD   cbRefused;
            if (SUCCEEDED(GetPermissionRequests(wpath,
                                                &pbMinimal,
                                                &cbMinimal,
                                                &pbOptional,
                                                &cbOptional,
                                                &pbRefused,
                                                &cbRefused))) {
                PBYTE pbData = NULL;
                DWORD cbData = 0;

                hr = ConvertPermissionSet(L"BINARY",
                                          pbMinimal,
                                          cbMinimal,
                                          L"XMLASCII",
                                          &pbData,
                                          &cbData);
                if(FAILED(hr)) CORTHROWMSG(hr, "Unable to create XML version of minimal permissions");

                if (fRequestedPermissions) {
                    printf("Minimal permission set:\n%s",pbData);
                }
                if (psFileName) {
                    hr = SaveData(psFileName, 
                                  pbData, 
                                  cbData);
                    if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                }

                if (pbOptional) {

                    hr = ConvertPermissionSet(L"BINARY",
                                              pbOptional,
                                              cbOptional,
                                              L"XMLASCII",
                                              &pbData,
                                              &cbData);
                    if(FAILED(hr)) CORTHROWMSG(hr, "Unable to create XML version of minimal permissions");

                    if (fRequestedPermissions) {
                        printf("Optional permission set:\n%s",pbData);
                    }
                    if (psFileName) {
                        hr = SaveData(psFileName, 
                                      pbData, 
                                      cbData,
                                      TRUE);
                        if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                    }

                } else {
                    if (fRequestedPermissions) {
                        printf("Optional permission set:\n  Not specified\n");
                    }
                    if (psFileName) {
                        BYTE pbData[] = "<PermissionSet></PermissionSet>\n";
                        hr = SaveData(psFileName, 
                                      pbData, 
                                      sizeof(pbData) - 1,
                                      TRUE);
                        if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                    }

                }

                if (pbRefused) {

                    hr = ConvertPermissionSet(L"BINARY",
                                              pbRefused,
                                              cbRefused,
                                              L"XMLASCII",
                                              &pbData,
                                              &cbData);
                    if(FAILED(hr)) CORTHROWMSG(hr, "Unable to create XML version of minimal permissions");

                    if (fRequestedPermissions) {
                        printf("Refused permission set:\n%s",pbData);
                    }
                    if (psFileName) {
                        hr = SaveData(psFileName, 
                                      pbData, 
                                      cbData,
                                      TRUE);
                        if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                    }

                } else {
                    if (fRequestedPermissions) {
                        printf("Refused permission set:\n  Not specified\n");
                    }
                    if (psFileName) {
                        BYTE pbData[] = "<PermissionSet></PermissionSet>\n";
                        hr = SaveData(psFileName, 
                                      pbData, 
                                      sizeof(pbData) - 1,
                                      TRUE);
                        if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                    }

                }

             } else if(pData && pData->pbCorPermissions) {
                PBYTE pbData = NULL;
                DWORD cbData = 0;
                hr = ConvertPermissionSet(L"BINARY",
                                          pData->pbCorPermissions,
                                          pData->cbCorPermissions,
                                          L"XMLASCII",
                                          &pbData,
                                          &cbData);
                if(FAILED(hr)) CORTHROWMSG(hr, "Unable to create XML version of the permissions");

                if (fRequestedPermissions && !(FAILED(hr)) ) {
                    printf("Requested permission set:\n%s",pbData);
                }
                if (psFileName && !(FAILED(hr))) {
                    hr = SaveData(psFileName, 
                                  pbData, 
                                  cbData);
                    if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the permissions to the specified file.\n");
                }
            }
            else {
                printf("No permissions were retrieved from the file.\n");
            }
        }
        if(psSignature) {
            if(pData && pData->pbSigner) {
                hr = SaveData(psSignature, 
                              pData->pbSigner, 
                              pData->cbSigner);
                if(FAILED(hr)) CORTHROWMSG(hr, "Unable to write the signature to the specified file.\n");
            }
            else {
                printf("No signature was retrieved from the file.\n");
            }
        }
            
        
    }
    CORCATCH(err) {
        SECLOG(("%s\n", err.corMsg), S_CRITICAL);
    } COREND;

    if(pData) FreeM(pData);

    BOOL fWritten = FALSE;
    if(FAILED(hr)) {
        fWritten = WriteErrorMessage(hr);
    }   
    if(fWritten == FALSE)
        printf("Chkcor return code: %0x\n", hr);

    if(fEEStarted)
        CoUninitializeEE(TRUE);
    
    CoUninitialize();

    exit ( hr == 0 ? 0 : 1 );
}


#define DBUFFER_SIZE 1024
HRESULT SaveData(LPCSTR pszFile, PBYTE pbData, DWORD cbData, BOOL fAppend)
{
    HRESULT hr = S_OK;
#ifndef UNDER_CE
    HANDLE  hFile = NULL;

    CORTRY {
        
        if ((hFile = CreateFileA(pszFile,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,                   // lpsa
                                 fAppend ? OPEN_EXISTING : CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) == INVALID_HANDLE_VALUE)
            CORTHROW(Win32Error());

        if (fAppend)
            SetFilePointer(hFile, 0, NULL, FILE_END);

        // Read the encoding message
        DWORD dwBytesWritten;
        if(!WriteFile(hFile, 
                      pbData,
                      cbData,
                      &dwBytesWritten,
                      NULL) ||
           dwBytesWritten != cbData)
            CORTHROW(Win32Error());
    }
    CORCATCH(err) {
        hr = err.corError;
    } COREND;
    
    if(hFile) CloseHandle(hFile);
#endif
    return hr;

}

BOOL WriteErrorMessage(HRESULT hr)
{
#ifndef UNDER_CE
    CHAR lpMsgBuf[DBUFFER_SIZE];
    if( FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,    
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                       &(lpMsgBuf[0]),    
                       DBUFFER_SIZE,    
                       NULL ) ) {
        printf(lpMsgBuf);
        return TRUE;
    }
    else
#endif
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cordump\cordump.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File: CORDUMP.CPP
//	All Rights Reserved.
//
//  Notes: Used the COR importer APIs to dump meta data definitions
//		   of a COR object
//---------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <crtdbg.h>

#define INIT_GUID
#include <initguid.h>

#include "cor.h"
#include "__file__.ver"
#include "corver.h"


#define NumItems(s) (sizeof(s) / sizeof(s[0]))

///////////////////////////////////////////////////////////////////////////
// Function prototypes
void DumpFile(IMetaDataImport* pImport, char* szFile);
void RawDump(mdScope sc, IMetaDataImport *pImport, char *szFile);
void Summarize(mdScope sc, IMetaDataImport *pImport, char *szFile);
void Iterate(mdScope sc, IMetaDataImport *pImport, char *szFile);
void ClassVue(mdScope sc, IMetaDataImport *pImport, char *szFile);
void ClassVue98(mdScope tkScope, IMetaDataImport *pImport, char *szFile);
void DisplayGetInterfaceImpl98(IMetaDataImport *pImport, mdScope tkScope, mdInterfaceImpl tkImpl, ULONG ulDispFlags);
void DisplayEnumTypeRefs98(IMetaDataImport *pImport, mdScope tkScope, ULONG ulDispFlags);
void DisplayEnumInterfaceImpl98(IMetaDataImport *pImport, mdScope tkScope, mdTypeDef tkTypeDef, ULONG ulDispFlags);
void DisplayGetTypeRefProps98(IMetaDataImport *pImport, mdScope tkScope, mdTypeRef tkTypeRef, ULONG ulDispFlags);
void TestGetTypeRefProps98(IMetaDataImport *pImport, mdScope tkScope, mdTypeRef tkTypeRef, ULONG ulDispFlags);
void DisplayGetNamespaceProps98(IMetaDataImport *pImport, mdScope tkScope, mdNamespace tkNamespace, ULONG ulDispFlags);
HRESULT GetTypeRefOrDefProps(
	IMetaDataImport *pImport, 
	mdScope		tkScope, 
	mdToken		tk, 
	LPWSTR		szTypeRef, 
	ULONG		cchTypeRef, 
	ULONG		*pcchTypeRef);

// dump all properties of a class
HRESULT DumpProperties(mdScope scope, mdTypeDef td);

// dump all events of a class
HRESULT DumpEvents(mdScope scope, mdTypeDef td);


/////////////////////////////////////////////////////////////////////////
//
// Table for mapping element type to text
//
////////////////////////////////////////////////////////////////////////
char *g_szMapElementType[ELEMENT_TYPE_MAX] = 
{
	"End",
	"Void",
	"Boolean",
	"Char", 
	"I1",
	"UI1",
	"I2",
	"UI2",
	"I4",
	"UI4",
	"I8",
	"UI8",
	"R4",
	"R8",
	"System.String",
	"Ptr",
	"ByRef",
	"Composite",
	"Class",
	"SDArray",
	"MDArray",
	"GENArray"
};

char *g_szMapUndecorateType[ELEMENT_TYPE_MAX] = 
{
	"",
	"void",
	"boolean",
	"Char", 
	"byte",
	"unsigned byte",
	"short",
	"unsigned short",
	"int",
	"unsigned int",
	"long",
	"unsigned long",
	"float",
	"double",
	"System.String",
	"*",
	"ByRef",
	"",
	"",
	"",
	"",
	""
};


char *g_strCalling[IMAGE_CEE_CS_CALLCONV_MAX] = 
{	
	"IMAGE_CEE_CS_CALLCONV_DEFAULT",
	"IMAGE_CEE_CS_CALLCONV_C",
	"IMAGE_CEE_CS_CALLCONV_STDCALL",
	"IMAGE_CEE_CS_CALLCONV_THISCALL",
	"IMAGE_CEE_CS_CALLCONV_FASTCALL",
	"IMAGE_CEE_CS_CALLCONV_VARARG",
	"IMAGE_CEE_CS_CALLCONV_FIELD"
};

IMetaDataImport *g_pImport= NULL ;


//@todo: void TableDump(mdScope sc, IMetaDataImport *pImport, char *szFile);
HRESULT UndecorateOneElementType(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb);
HRESULT	DumpSignature(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob);
HRESULT	DumpException(mdScope tkScope, mdMethodDef md);

inline char *Shorten(char *szName)
{
	char *pRslt = szName;
	for (char *p=szName; *p; ++p)
		if ((*p=='/' || *p=='.') && *(p+1))	pRslt=p+1;
	return (pRslt);
}

///////////////////////////////////////////////////////////////////////////
// Global variables.
int	bSummarize=false;					// Summarizer style output.
int bQuiet=false;						// Quite dumping (why? timing.)
int bClassVue=false;					// ClassVue type output!
int bClassVue98=false;					// ClassVue98 type output!
int bFile;								// Is current thing a file?

HRESULT	_FillVariant(
	BYTE		bCPlusTypeFlag, 
	void		*pValue,
	VARIANT		*pvar) 
{
	HRESULT		hr = NOERROR;
	switch (bCPlusTypeFlag)
	{
	case ELEMENT_TYPE_BOOLEAN:
		pvar->vt = VT_BOOL;
		pvar->boolVal = *((VARIANT_BOOL *)pValue);
		break;
    case ELEMENT_TYPE_I1:
		pvar->vt = VT_I1;
		pvar->cVal = *((CHAR*)pValue);
		break;	
    case ELEMENT_TYPE_U1:
		pvar->vt = VT_UI1;
		pvar->bVal = *((BYTE*)pValue);
		break;	
    case ELEMENT_TYPE_I2:
		pvar->vt = VT_I2;
		pvar->iVal = *((SHORT*)pValue);
		break;	
    case ELEMENT_TYPE_U2:
		pvar->vt = VT_UI2;
		pvar->uiVal = *((USHORT*)pValue);
		break; 
    case ELEMENT_TYPE_CHAR:
        pvar->vt = VT_UI2;  //Chars are U2's in Variants.
        pvar->uiVal = *((USHORT*)pValue);
        break;	
    case ELEMENT_TYPE_I4:
		pvar->vt = VT_I4;
		pvar->lVal = *((LONG*)pValue);
		break;	
    case ELEMENT_TYPE_U4:
		pvar->vt = VT_UI4;
		pvar->ulVal = *((ULONG*)pValue);
		break;	
    case ELEMENT_TYPE_R4:
		pvar->vt = VT_R4;
		pvar->fltVal = *((FLOAT*)pValue);
		break;	
    case ELEMENT_TYPE_R8:
		pvar->vt = VT_R8;
		pvar->dblVal = *((DOUBLE*)pValue);
		break;	
    case ELEMENT_TYPE_STRING:
		pvar->vt = VT_BSTR;

		// allocated bstr here
		pvar->bstrVal = ::SysAllocString((LPWSTR)pValue);
		if (pvar->bstrVal == NULL)
			hr = E_OUTOFMEMORY;
		break;	
    case ELEMENT_TYPE_CLASS:
		pvar->punkVal = NULL;
		pvar->vt = VT_UNKNOWN;
		_ASSERTE( *((IUnknown **)pValue) = NULL );
		break;	
	case ELEMENT_TYPE_I8:
		pvar->vt = VT_I8;
		pvar->cyVal.int64 = *((LONGLONG*)pValue);
		break;
	case ELEMENT_TYPE_VOID:
		pvar->vt = VT_EMPTY;
		break;
	default:
		_ASSERTE(!"bad constant value type!");
	}

	return hr;
}



///////////////////////////////////////////////////////////////////////////
// Error() function -- prints an error and returns
void Error(char* szError)
{
	printf("\n%s\n", szError);
	CoUninitialize();
	exit(1);
}

/////////////////////////////////////////////////////////////////////////
// main() function
//
//
int _cdecl main(int argc, char** argv)
{
	// Perform memory leak checking.
#if !defined( NO_CRT ) && defined( _DEBUG )
	int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
	_CrtSetDbgFlag( tmpFlag );
	long l = 253;
	//_CrtSetBreakAlloc(l);
#endif

	CoInitialize(0);
	CoInitializeCor(COINITCOR_DEFAULT);

	/////////////////////////////////////////////////////////////////////////
	// Print copyright message
	if (!bQuiet)
	{
	    printf("\nMicrosoft (R) COM+ Runtime Dump.  Version %s", VER_FILEVERSION_STR);
	    printf("\n%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);
	}

	/////////////////////////////////////////////////////////////////////////
	// Validate incoming arguments
	if ((argc <2) || (lstrcmpi(argv[1], "/?") == 0) || (lstrcmpi(argv[1], "-?") == 0))
	    Error("Usage -- CORDUMP <filename or file patten>");

	/////////////////////////////////////////////////////////////////////////
	// Load the COR object
	HRESULT hr = CoGetCor(IID_IMetaDataImport, (void**) &g_pImport) ;
	if(FAILED(hr)) Error("Failed to load component object runtime");

	////////////////////////////////////////////////////////////////////////
	// Loop through all files in the file pattern passed
	WIN32_FIND_DATA fdFiles;
	HANDLE hFind ;
	char szSpec[_MAX_PATH];
	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR];

	// Iterate over command line arguments.
	for (int iArg=1; iArg<argc; ++iArg)
	{
		char *pArg = argv[iArg];
		if (*pArg == '-')
		{
			++pArg;
			switch (toupper(*pArg++))
			{
			case 'Q':
				bQuiet = ! (*pArg=='-');
				break;
			case 'S':
				bSummarize = ! (*pArg=='-');
				break;
			case '9':
				bClassVue98 =! (*pArg=='-');
				break;
			case 'C':
				bClassVue =! (*pArg=='-');
				break;
			default:
				break;
			}
		}
		else
		{
			hFind = FindFirstFile(pArg, &fdFiles);

			if(hFind == INVALID_HANDLE_VALUE)
			{
				/////////////////////////////////////////////////////////////////
				// Dump the meta data of whatever it is.
				bFile = false;
				DumpFile(g_pImport, pArg);
			}
			else
			{
				bFile = true;
				// Convert relative paths to full paths.
				_fullpath(szSpec, pArg, sizeof(szSpec));
				_splitpath(szSpec, szDrive, szDir, NULL, NULL);
				do
				{
					_makepath(szSpec, szDrive, szDir, fdFiles.cFileName, NULL);

					/////////////////////////////////////////////////////////////
					// Dump the meta data of the file
					DumpFile(g_pImport, szSpec);

				} while(FindNextFile(hFind, &fdFiles)) ;
				// Done with this argument.
				FindClose(hFind);
			}
		}
	}
	g_pImport->Release();
	CoUninitializeCor();
	CoUninitialize();
	return 0;
}



/////////////////////////////////////////////////////////////////////////
// DumpFile() function
//
// Opens the meta data content of a .CLB, .CLASS, or .DLL file, and
//  calls RawDump(), Summarize(), or TableDump().
//
void DumpFile(IMetaDataImport* pImport, char* szFile)
{
	HRESULT hr=S_OK;

	/////////////////////////////////////////////////////////////////////////
	// Open the emit scope
	WCHAR szScope[255];
	WCHAR *pFile;
	if (bFile)
		pFile = wcscpy(szScope, L"file:") + 5;
	else
		pFile = szScope;
	mbstowcs(pFile, szFile, sizeof(szScope)-1-(pFile-szScope));

	mdScope sc;
	if (FAILED(pImport->OpenScope(szScope, 0, &sc)))
		Error("Failed to import file");

	if (bSummarize)
		Summarize(sc, pImport, szFile);
	else
	{
		if (bClassVue98)
			ClassVue98(sc, pImport, szFile);
		else {
			if (bClassVue)
				ClassVue(sc, pImport, szFile);
			else {
				if (bQuiet)
					Iterate(sc, pImport, szFile);
				else
					RawDump(sc, pImport, szFile);
			}
		}
	}


	/////////////////////////////////////////////////////////////////////////
	// Close import scope
	pImport->Close(sc);
}

/////////////////////////////////////////////////////////////////////////
//	ClassVue Type Output
//	Uses:
//		CloseEnum
//			+	CountEnum
//		EnumAttributes
//		EnumTypeDefs
//		*	EnumTypeRefs
//		EnumInterfaceImpls
//		*	EnumMemberRefs
//		*	EnumMembers
//			+	EnumMemberWithName
//			+	EnumParams
//		FindAttribute
//			+	FindClass
//			+	FindMember
//		GetAttributeProps
//		GetClassProps
//		GetClassRefProps
//		GetInterfaceImplProps
//			+	GetMemberConstantValue
//		*	GetMemberProps
//		*	GetMemberRefProps
//		GetNamespaceProps
//			+	GetParamProps
//			+	GetScopeProps
//		GetTokenFromIndex
//		GetTokenValue
//			+	ResetEnum
//			+	ResolveClassRef
//			
void ClassVue(mdScope sc, IMetaDataImport *pImport, char *szFile)
{
	HCORENUM hClasses = 0;
	mdTypeRef rgcr[10];
	ULONG cClasses;
	HCORENUM hAttrs = 0;
	mdCustomValue rgat[10];
	ULONG cAttrs;
	HCORENUM hMembers = 0;
	mdMemberRef rgmr[10];
	ULONG cMembers;
	HCORENUM hIfaceImpls = 0;
	mdInterfaceImpl rgii[10];
	ULONG cIfaceImpls;
    char rcFname[_MAX_FNAME], rcExt[_MAX_EXT];

	HRESULT		hr;
	_splitpath(szFile, 0, 0, rcFname, rcExt);
	printf("\nFile: %s%s\n", rcFname, rcExt);
	printf("===========================================================\n");

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all classes (and interfaces)
	hClasses = 0;
	while (SUCCEEDED(hr = pImport->EnumTypeDefs(sc,&hClasses,rgcr,NumItems(rgcr),&cClasses))&&cClasses>0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			WCHAR szClassName[MAX_CLASS_NAME];
			CLSID clsid;
			GUID cvid;
			CLASSVERSION ver;
			WCHAR szGuid[100];
			char szClassAttr[255];
			DWORD dwClassAttr;
			DWORD dwSuperAttr;
			WCHAR szNamespace[MAX_PACKAGE_NAME];
			WCHAR szSuperName[MAX_CLASS_NAME];
			mdTypeRef crSuper;

			szNamespace[0] = 0;
			pImport->GetTypeDefProps(sc, rgcr[i], szNamespace, NumItems(szNamespace)-1, 0,
									szClassName, NumItems(szClassName)-1, 0,
									&clsid, &ver, &dwClassAttr, &crSuper, &dwSuperAttr);

			if (szNamespace[0] != 0)
			{
				printf("Namespace:          %ls\n",szNamespace) ;
			}
			StringFromGUID2(clsid, szGuid, sizeof(szGuid));
		    printf("GUID:               %ls\n", szGuid);
			StringFromGUID2(cvid, szGuid, sizeof(szGuid));
		    printf("CVID:               %ls\n", szGuid);
		    printf("Version:            %d:%d:%d:%d\n", ((WORD *) &ver)[0], ((WORD *) &ver)[1],
										((WORD *) &ver)[2], ((WORD *) &ver)[3]);
			if(dwClassAttr & tdInterface)
				printf("Interface Name:     (%8.8x) %ls\n",rgcr[i], szClassName) ;
			else
				printf("Class Name:         (%8.8x) %ls\n",rgcr[i], szClassName) ;
			if (crSuper!=mdTypeRefNil)
			{
				hr = GetTypeRefOrDefProps(pImport, sc, crSuper, szSuperName, NumItems(szSuperName)-1, 0);
				printf("Super Class Name:   (%8.8x) %ls\n",crSuper,szSuperName);
			}
			else
				printf("No Super Class\n");
			szClassAttr[0] = 0 ;
			if(dwClassAttr & tdPublic) strcat(szClassAttr,"public ") ;
			if(dwClassAttr & tdFinal) strcat(szClassAttr,"final ") ;
			if(dwClassAttr & tdAbstract) strcat(szClassAttr,"abstract ") ;
			if(dwClassAttr & 0x0020) strcat(szClassAttr,"super ") ;

			printf("Access Flags:       (%08x) %s\n",dwClassAttr,szClassAttr);
			printf("Super's Relation:   (%08x) \n",dwSuperAttr);

			////////////////////////////////////////////////////////////////////
			// Iterate over all interface impls.
			hIfaceImpls = 0;
			while (SUCCEEDED(hr = pImport->EnumInterfaceImpls(sc, &hIfaceImpls, rgcr[i], rgii,
									NumItems(rgii), &cIfaceImpls)) &&
					cIfaceImpls > 0)
			{
				for (unsigned int j=0; j<cIfaceImpls; ++j)
				{
					mdTypeDef cl;
					mdTypeRef cr;
					DWORD flags;
					hr = pImport->GetInterfaceImplProps(sc, rgii[j], &cl, &cr, &flags);
					if (FAILED(hr))
					{
						printf("GetInterfaceImplProps--Failure: %08x\n", hr);
					}
					WCHAR szSuperClass[255];
					hr = GetTypeRefOrDefProps(pImport, sc, cr, szSuperClass, NumItems(szSuperClass)-1, 0);
					printf("Interface(s):       %ls\n",szSuperClass);
				}
			}
			pImport->CloseEnum(sc, hIfaceImpls);

			////////////////////////////////////////////////////////////////////
			//	Iterate over all Class Attributes
			hAttrs = 0;
			while (SUCCEEDED(hr = pImport->EnumCustomValues(sc,&hAttrs,rgcr[i],rgat,NumItems(rgat),&cAttrs))
						&& cAttrs>0)
			{
				for (unsigned int j=0; j<cAttrs; ++j)
				{
					WCHAR	szAttrName[255];
					BYTE	*pBlob;
					ULONG	cbBlob;
					ULONG	chAttr;
					hr = pImport->GetCustomValueProps(sc,rgat[j],szAttrName,NumItems(szAttrName),&chAttr,0);
					if (SUCCEEDED(hr))
						hr = pImport->GetCustomValueAsBlob(sc, rgat[j], (const void**)&pBlob,&cbBlob);
					if (SUCCEEDED(hr)) {
						printf("Attribute(s):       %ls [%d byte(s)]\n",szAttrName,cbBlob);
					}
				}
			}
			pImport->CloseEnum(sc, hAttrs);

			hr = DumpEvents(sc, rgcr[i]);
			if (FAILED(hr))
				goto ErrExit;
			hr = DumpProperties(sc, rgcr[i]);
			if (FAILED(hr))
				goto ErrExit;


			VARIANT	vtValue;
			mdCustomValue atAttr;
			WCHAR	szAttrName[255];
			BYTE	*pBlob;
			ULONG	cbBlob;
			USHORT	idx;
			ULONG	chAttr;
			mdCPToken cpConPool;

			hr = pImport->FindCustomValue(sc, rgcr[i], L"SourceFile", &atAttr,0);
			if (SUCCEEDED(hr)&&(TypeFromToken(atAttr)==mdtCustomValue)) {
				hr = pImport->GetCustomValueProps(sc,atAttr,szAttrName,NumItems(szAttrName),&chAttr,0);
				if (SUCCEEDED(hr))
					hr = pImport->GetCustomValueAsBlob(sc, atAttr, (const void**)&pBlob,&cbBlob);
				if (SUCCEEDED(hr)) {
					idx = pBlob[0]<<8|pBlob[1];
					hr = pImport->GetTokenFromIndex(sc,idx,&cpConPool);
					if (SUCCEEDED(hr)&&(TypeFromToken(cpConPool)==mdtCPToken)) {
						hr = pImport->GetTokenValue(sc,cpConPool,&vtValue);
						if (SUCCEEDED(hr)) {
							printf("Source Filename:    %ls\n",vtValue.bstrVal);
						}
					}
				}
			}
			////////////////////////////////////////////////////////////////////
			// Iterate over all members (fields and methods
			hMembers = 0;
            while (SUCCEEDED(hr = pImport->EnumMembers(sc, &hMembers, rgcr[i], rgmr, NumItems(rgmr), &cMembers)) && cMembers > 0)
			{
				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR	szMember[255];
					PCCOR_SIGNATURE pbSigBlob;
					ULONG	ulSigBlob;
					DWORD	access;
					char	szAccFlags[255];

					pImport->GetMemberProps(sc, rgmr[j], NULL, szMember, NumItems(szMember)-1, 0, &access, &pbSigBlob, &ulSigBlob, 0, 0, 0, 0, 0);
					printf("\n\tMember Type:         %s\n", (TypeFromToken(rgmr[j]) == mdtMethodDef) ? "Method" : "Field");
					printf("\tMember Name:         (%8.8x) %ls\n", rgmr[j], szMember);
					szAccFlags[0] = 0 ;
					if(access & mdPublic) strcat(szAccFlags,"public ");
					if(access & mdPrivate) strcat(szAccFlags,"private ");
					if(access & mdProtected) strcat(szAccFlags,"protected ");
					if(access & mdStatic) strcat(szAccFlags,"static ");
					if(access & mdFinal) strcat(szAccFlags,"final ");
					if(access & mdSynchronized) strcat(szAccFlags,"synchronized ");
					if(access & mdVirtual) strcat(szAccFlags,"virtual ");
					if(access & mdNative) strcat(szAccFlags,"native ");
					if(access & mdAbstract) strcat(szAccFlags,"abstract ");
					//if(access & mdPropAcc) strcat(szAccFlags,"PROPACC ");
					//if(access & mdDefault) strcat(szAccFlags,"DEFAULT ");
					printf("\tMember Access Flags: (%08x) %s\n",access,szAccFlags);
					DumpSignature(sc, pbSigBlob, ulSigBlob);
					DumpException(sc, rgmr[j]);
					// printf("\tMember Signature:    %ls\n", szSig);

					{
						HCORENUM		hSemantics;
						mdToken			tkEvProp;
						ULONG			iEvProp;
						hSemantics = 0;

						while (SUCCEEDED(pImport->EnumMethodSemantics(	// S_OK, S_FALSE, or error.
							sc,							// [IN] The scope.
							&hSemantics,                // [IN|OUT] Pointer to the enum.
							rgmr[j],                    // [IN] MethodDef to scope the enumeration.
							&tkEvProp,					// [OUT] Put Event/Property here.
							1,							// [IN] Max properties to put.
							&iEvProp)) &&					// [OUT] Put # put here.
							iEvProp == 1)
						{
							DWORD		dwFlags;
							pImport->GetMethodSemantics(sc,rgmr[j], tkEvProp, &dwFlags);
							if (TypeFromToken(tkEvProp) == mdtEvent)
							{
								if (dwFlags & msAddOn)
									printf("\t AddOn Event\n");
								else if (dwFlags & msRemoveOn)
									printf("\t RemoveOn Event\n");
								else if (dwFlags & msFire)
									printf("\t Fire Event\n");
								else 
								{
									_ASSERTE(dwFlags & msOther);
									printf("\t Other Event\n");
								}
							}
							else
							{
								_ASSERTE(TypeFromToken(tkEvProp) == mdtProperty);
								if (dwFlags & msSetter)
									printf("\t Setter property\n");
								else if (dwFlags & msGetter)
									printf("\t Getter property\n");
								else if (dwFlags & msReset)
									printf("\t ReSet property\n");
								else if (dwFlags & msTestDefault)
									printf("\t TestDefault property\n");
								else 
								{
									_ASSERTE(dwFlags & msOther);
									printf("\t Other property\n");
								}
							}
						}
					}
				
				}
			}
			pImport->CloseEnum(sc, hMembers);


//		}
//	}
//	pImport->CloseEnum(sc, hClasses);
//
//	/////////////////////////////////////////////////////////////////////////
//	// Iterate over all class refs
//	hClasses = 0;
//	while (!FAILED(hr = pImport->EnumTypeRefs(sc, &hClasses, rgcr,	NumItems(rgcr), &cClasses)) && cClasses > 0)
//	{
//		for (unsigned int i=0; i < cClasses; ++i)
//		{
//			WCHAR szClass[255];
//			// Get the imported class/interface name.
//			pImport->GetClassRefProps(sc, rgcr[i], szClass, NumItems(szClass)-1, 0);
//			printf("\nClass/Interface Reference: %ls\n", szClass);
//			hMembers = 0;
//			for(;;)
//			{
//				hr = pImport->EnumMemberRefs(sc, &hMembers, rgcr[i], rgmr, NumItems(rgmr), &cMembers);
//				if (FAILED(hr) || cMembers == 0)
//					break;
//				for (unsigned int j=0; j < cMembers; ++j)
//				{
//					WCHAR szMember[255];
//					WCHAR szSig[512];
//					pImport->GetMemberRefProps(sc, rgmr[j], NULL, szMember,	NumItems(szMember)-1, 0, szSig, NumItems(szSig)-1, 0);
//					printf("\tMember: %ls: %ls\n", szMember, szSig);
//				}
//			}
//			pImport->CloseEnum(sc, hMembers);
		printf("-----------------------------------------------------------\n");
		}
	}
	pImport->CloseEnum(sc, hClasses);
ErrExit:
	return;
}	//	ClassVue End



/********************************************************************************\
*   Tests for CompLib '98                                                        *
*                                                                                *
*   Start *98 Block                                                              *
\********************************************************************************/

void ClassVue98(mdScope tkScope, IMetaDataImport *pImport, char *szFile) {
	//	ulDispFlags
	//	0		No Extra Output
	//	2		Token/Flag in Hex displayed
	//	3		Display params after API calls
	//	4		Display params upon entering each test method

	ULONG			ulDispFlags	=	2;
//	ulDispFlags = (ULONG) (tdPublic|tdFinal|tdInterface|tdAbstract|tdImport|tdRecord|tdEnum);
	//	Used in EnumTypeDefs
	HCORENUM		hEnumTypeDefs = 0;
	mdTypeRef		rgtkTypeDef[10];
	ULONG			cTypeDefs;

	char rcFname[_MAX_FNAME], rcExt[_MAX_EXT];

	HRESULT			hr;

	DWORD			dwKnownTypeDefFlags;
	dwKnownTypeDefFlags = (DWORD) (tdPublic|tdFinal|tdInterface|tdAbstract|tdImport|tdRecord|tdEnum);
	_splitpath(szFile, 0, 0, rcFname, rcExt);
	printf("\nFile: %s%s\n", rcFname, rcExt);
	printf("===========================================================\n");

	WCHAR		szScopeName[MAX_CLASS_NAME];
	ULONG		lenScopeName;
	GUID		guidScope;
	WCHAR		szOutputBuffer[100];

	hr = pImport->GetScopeProps(tkScope,szScopeName,NumItems(szScopeName),&lenScopeName,&guidScope,0,0);
	printf("Scope:               %ls\n",szScopeName);
	StringFromGUID2(guidScope, szOutputBuffer, sizeof(szOutputBuffer));
	printf("GUID:                %ls\n", szOutputBuffer);
	DisplayEnumTypeRefs98(pImport,tkScope,ulDispFlags);
	printf("-----------------------------------------------------------\n");

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all TypeDefs
	hEnumTypeDefs = 0;
	while (SUCCEEDED(hr = pImport->EnumTypeDefs(tkScope,&hEnumTypeDefs,rgtkTypeDef,
								NumItems(rgtkTypeDef),&cTypeDefs))&&cTypeDefs>0) {
		for (unsigned int iTD=0; iTD < cTypeDefs; ++iTD) {
			//	Used in GetTypeDefProps
			WCHAR			szTypeDefName[MAX_CLASS_NAME];
			ULONG			lenTypeDefName;
			CLSID			clsidTypeDef;
			GUID			mvidTypeDef;
			CLASSVERSION	verTypeDef;
			DWORD			dwTypeDefFlags;
			WCHAR			szOutputGuid[100];
			char			szOutputFlags[255];

			if (rgtkTypeDef[iTD]!=mdTypeDefNil) {
				pImport->GetTypeDefProps(tkScope, rgtkTypeDef[iTD], NULL,0,NULL, szTypeDefName,
									NumItems(szTypeDefName)-1, &lenTypeDefName, &clsidTypeDef,
									&verTypeDef, &dwTypeDefFlags, NULL, NULL);
//				if (tkNamespace != mdNamespaceNil)
//					DisplayGetNamespaceProps98(pImport,tkScope,tkNamespace,ulDispFlags);
				StringFromGUID2(clsidTypeDef, szOutputGuid, sizeof(szOutputGuid));
				printf("GUID:                %ls\n", szOutputGuid);
				StringFromGUID2(mvidTypeDef, szOutputGuid, sizeof(szOutputGuid));
				printf("MVID:                %ls\n", szOutputGuid);
				printf("Version:             %d:%d:%d:%d\n", ((WORD *) &verTypeDef)[0], ((WORD *) &verTypeDef)[1],
										((WORD *) &verTypeDef)[2], ((WORD *) &verTypeDef)[3]);
				printf("TypeDef Name:        %ls\n",szTypeDefName);
//				printf("Extended Name\n");
//				if (tkTypeRefExtended!=mdTypeRefNil)
//					DisplayGetTypeRefProps98(pImport,tkScope,tkTypeRefExtended,ulDispFlags);
//				else
//					printf("    TypeRef:         None\n");
				szOutputFlags[0] = 0 ;
				if(dwTypeDefFlags & tdPublic) strcat(szOutputFlags,"public ") ;
				if(dwTypeDefFlags & tdFinal) strcat(szOutputFlags,"final ") ;
				if(dwTypeDefFlags & tdInterface) strcat(szOutputFlags,"interface ") ;
				if(dwTypeDefFlags & tdAbstract) strcat(szOutputFlags,"abstract ") ;
				if(dwTypeDefFlags & tdImport) strcat(szOutputFlags,"imported ") ;
				if(dwTypeDefFlags & tdRecord) strcat(szOutputFlags,"record ") ;
				if(dwTypeDefFlags & tdEnum) strcat(szOutputFlags,"enum ") ;
				DWORD dwTemp = dwTypeDefFlags & dwKnownTypeDefFlags;
				if (dwTemp!=0) sprintf(szOutputFlags,"%sAND UNKNOWN FLAGS (%08x)",szOutputFlags,dwTemp);

				printf("TypeDef Flags:       (%08x) %s\n",dwTypeDefFlags,szOutputFlags);
//				printf("TypeRefExtendedFlags:(%08x) \n",dwTypeRefExtendedFlags);

				DisplayEnumInterfaceImpl98(pImport,tkScope,rgtkTypeDef[iTD],ulDispFlags);
			}
			printf("-----------------------------------------------------------\n");
		}
	}
	ULONG	cTokens2;
	hr = pImport->CountEnum(tkScope,hEnumTypeDefs,&cTokens2);
	if (FAILED(hr)) {
		printf("CountEnum--Failure: (%08x)\n", hr);
	}
	printf("Num of TypeDef(s):   (%08x)\n",cTokens2);
	pImport->CloseEnum(tkScope, hEnumTypeDefs);
}	//	ClassVue98 End

/*****************************************************************************\
*    EnumInterfaceImpls                                                       *
*                                                                             *
\*****************************************************************************/
void DisplayEnumInterfaceImpl98(IMetaDataImport *pImport, mdScope tkScope, mdTypeDef tkTypeDef, ULONG ulDispFlags) {
	//	Used in EnumInterfaceImpls
	HCORENUM		hEnumImpls = 0;
	mdInterfaceImpl	rgtkImpl[10];
	ULONG			cImpls;
	
	HRESULT			hr;
	if (ulDispFlags>=4) {
		printf("DisplayInterfaceImpl98(pImport,       /* [in]                */\n");;
		printf("                       tkScope,       /* (%08x) [in]     */\n",tkScope);
		printf("                       tkTypeDef,     /* (%08x) [in]     */\n",tkTypeDef);
		printf("                       ulDispFlags);  /* (%08x) [in]     */\n",ulDispFlags);
	}
	hEnumImpls = 0;
	while (SUCCEEDED(hr = pImport->EnumInterfaceImpls(tkScope, &hEnumImpls,
					tkTypeDef, rgtkImpl,NumItems(rgtkImpl), &cImpls)) &&
				cImpls > 0) {
		if (ulDispFlags>=3) {
			printf("EnumInterfaceImpls(tkScope,           /* (%08x) [in]     */\n",tkScope);
			printf("                   hEnumImpls,        /* (%08x) [in,out] */\n",hEnumImpls);
			printf("                   tkTypeDef,         /* (%08x) [in]     */\n",tkTypeDef);
			printf("                   rgtkImpl,          /* Tokens     [in,out] */\n");
			printf("                   NumItems(rgtkImpl),/* (%08x) [in]     */\n",NumItems(rgtkImpl));
			printf("                   cImpls);           /* (%08x) [out]    */\n",cImpls);
		}
		for (unsigned int iII=0; iII<cImpls; ++iII) {
			if (rgtkImpl[iII]!=mdInterfaceImplNil) {
				DisplayGetInterfaceImpl98(pImport,tkScope,rgtkImpl[iII],ulDispFlags);
			}
		}
	}
	pImport->CloseEnum(tkScope, hEnumImpls);
}

/*****************************************************************************\
*    GetInterfaceImplProps                                                    *
*                                                                             *
\*****************************************************************************/
void DisplayGetInterfaceImpl98(IMetaDataImport *pImport, mdScope tkScope, mdInterfaceImpl tkImpl, ULONG ulDispFlags) {
	
	HRESULT			hr;
	if (ulDispFlags>=4) {
		printf("DisplayGetInterfaceImpl98(pImport,    /* [in]                */\n");;
		printf("                          tkScope,    /* (%08x) [in]     */\n",tkScope);
		printf("                          tkImpl,     /* (%08x) [in]     */\n",tkImpl);
		printf("                          ulDispFlags);/*(%08x) [in]     */\n",ulDispFlags);
	}
	//	Local Variables for GetInterfaceImplProps to use.
	mdTypeDef	tkImplTypeDef;
	mdTypeRef	tkImplTypeRef;
	DWORD		dwImplFlags;
	hr = pImport->GetInterfaceImplProps(tkScope,tkImpl,&tkImplTypeDef,&tkImplTypeRef,&dwImplFlags);
	if (FAILED(hr)) {
		printf("GetInterfaceImplProps--Failure: %08x\n", hr);
	}
	else if (tkImplTypeRef!=mdTypeRefNil) {
		if (ulDispFlags>=3) {
			printf("GetInterfaceImplProps(tkScope,        /* (%08x) [in]     */\n",tkScope);
			printf("                      tkImpl,         /* (%08x) [in]     */\n",tkImpl);
			printf("                      tkImplTypeDef,  /* (%08x) [in,out] */\n",tkImplTypeDef);
			printf("                      tkImplTypeRef,  /* (%08x) [in,out] */\n",tkImplTypeRef);
			printf("                      dwImplFlags);   /* (%08x) [in,out] */\n",dwImplFlags);
		}
		printf("Implements\n");
		DisplayGetTypeRefProps98(pImport,tkScope,tkImplTypeRef,ulDispFlags);
	}
}

/*****************************************************************************\
*    GetTypeRefProps                                                          *
*                                                                             *
\*****************************************************************************/
void DisplayGetTypeRefProps98(IMetaDataImport *pImport, mdScope tkScope, mdTypeRef tkTypeRef, ULONG ulDispFlags) {
	WCHAR		szTypeRefName[MAX_CLASS_NAME];
	ULONG		lenTypeRefName;

//	pImport->GetClassRefProps(tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,&lenTypeRefName);
	GetTypeRefOrDefProps(pImport, tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,&lenTypeRefName);
	if (ulDispFlags>=3) {
		printf("GetTypeRefProps(tkScope,              /* (%08x) [in]     */\n",tkScope);
		printf("                tkTypeRef,            /* (%08x) [in]     */\n",tkTypeRef);
		printf("                szTypeRefName,        /*            [in,out] */\n");
		printf("           NumItems(szTypeRefName)-1, /* (%08x) [in]     */\n",(NumItems(szTypeRefName)-1));
		printf("                lenTypeRefName);      /* (%08x) [out]    */\n",lenTypeRefName);
	}
	printf("    TypeRef:         %ls\n",szTypeRefName);
}

///*****************************************************************************\
//*    GetNamespaceProps                                                        *
//*                                                                             *
//\*****************************************************************************/
//void DisplayGetNamespaceProps98(IMetaDataImport *pImport, mdScope tkScope, mdNamespace tkNamespace, ULONG ulDispFlags) {
//	WCHAR		szNamespace[MAX_CLASS_NAME];
//	ULONG		lenNamespace;
//
//	pImport->GetNamespaceProps(tkScope,tkNamespace,szNamespace,NumItems(szNamespace)-1,&lenNamespace);
//	if (ulDispFlags>=3) {
//		printf("GetNamespaceProps(tkScope,            /* (%08x) [in]     */\n",tkScope);
//		printf("                  tkNamespace,        /* (%08x) [in]     */\n",tkNamespace);
//		printf("                  szNamespace,        /*            [in,out] */\n");
//		printf("             NumItems(szNamespace)-1, /* (%08x) [in]     */\n",(NumItems(szNamespace)-1));
//		printf("                  lenNamespace);      /* (%08x) [in,out] */\n",lenNamespace);
//	}
//	printf("Namespace:           %ls\n",szNamespace) ;
//}

/*****************************************************************************\
*    GetTypeRefProps                                                          *
*        Test                                                                 *
\*****************************************************************************/
void TestGetTypeRefProps98(IMetaDataImport *pImport, mdScope tkScope, mdTypeRef tkTypeRef, ULONG ulDispFlags) {
	ULONG		ulDefault = 0x99;
	//	Used in GetTypeRefProps
	WCHAR		szTypeRefName[MAX_CLASS_NAME];
	ULONG		lenTypeRefName;

//	pImport->GetClassRefProps(tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,&lenTypeRefName);
	GetTypeRefOrDefProps(pImport, tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,&lenTypeRefName);
	if (ulDispFlags>=3) {
		printf("GetTypeRefProps(tkScope,              /* (%08x) [in]     */\n",tkScope);
		printf("                tkTypeRef,            /* (%08x) [in]     */\n",tkTypeRef);
		printf("                szTypeRefName,        /*            [in,out] */\n");
		printf("           NumItems(szTypeRefName)-1, /* (%08x) [in]     */\n",(NumItems(szTypeRefName)-1));
		printf("                lenTypeRefName);      /* (%08x) [in,out] */\n",lenTypeRefName);
	}
//	pImport->GetClassRefProps(tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,NULL);
	GetTypeRefOrDefProps(pImport, tkScope,tkTypeRef,szTypeRefName,NumItems(szTypeRefName)-1,NULL);
	if (ulDispFlags>=3) {
		printf("GetTypeRefProps(tkScope,              /* (%08x) [in]     */\n",tkScope);
		printf("                tkTypeRef,            /* (%08x) [in]     */\n",tkTypeRef);
		printf("                szTypeRefName,        /*            [in,out] */\n");
		printf("           NumItems(szTypeRefName)-1, /* (%08x) [in]     */\n",(NumItems(szTypeRefName)-1));
		printf("                NULL);                /*            [in,out] */\n");
	}
	lenTypeRefName = ulDefault;
//	pImport->GetClassRefProps(tkScope,tkTypeRef,NULL,0,&lenTypeRefName);
	GetTypeRefOrDefProps(pImport, tkScope,tkTypeRef,NULL,0,&lenTypeRefName);
	if (ulDispFlags>=3) {
		printf("GetTypeRefProps(tkScope,              /* (%08x) [in]     */\n",tkScope);
		printf("                tkTypeRef,            /* (%08x) [in]     */\n",tkTypeRef);
		printf("                NULL,                 /*            [in,out] */\n");
		printf("                0,                    /*            [in]     */\n");
		printf("                lenTypeRefName);      /* (%08x) [in,out] */\n",lenTypeRefName);
	}
}

/*****************************************************************************\
*    EnumTypeRefs                                                             *
*                                                                             *
\*****************************************************************************/
void DisplayEnumTypeRefs98(IMetaDataImport *pImport, mdScope tkScope, ULONG ulDispFlags) {
	//	Used in EnumTypeRefs
	HCORENUM		hEnumTypeRefs = 0;
	mdTypeRef		rgtkTypeRef[10];
	ULONG			cTypeRefs;
	
	HRESULT			hr;
	if (ulDispFlags>=4) {
		printf("DisplayEnumTypeRefs98(IMetaDataImport *pImport,\n");;
		printf("                      mdScope         tkScope,   /* (%08x) */\n",tkScope);
		printf("                      ULONG           ulDispFlags);\n");
	}
	hEnumTypeRefs = 0;

	while (!FAILED(hr = pImport->EnumTypeRefs(tkScope, &hEnumTypeRefs, rgtkTypeRef,
//	while (!FAILED(hr = pImport->EnumTypeRefs(tkScope, &hEnumTypeRefs, rgtkTypeRef,
								NumItems(rgtkTypeRef), &cTypeRefs)) && cTypeRefs > 0) {
		for (unsigned int iTR=0; iTR < cTypeRefs; ++iTR) {
			DisplayGetTypeRefProps98(pImport,tkScope,rgtkTypeRef[iTR],ulDispFlags);
		}
	}
	ULONG	cTokens;
	hr = pImport->CountEnum(tkScope,hEnumTypeRefs,&cTokens);
	if (FAILED(hr)) {
		printf("CountEnum--Failure: (%08x)\n", hr);
	}
	printf("Num of TypeRef(s):   (%08x)\n",cTokens);
	hr = pImport->ResetEnum(tkScope,hEnumTypeRefs,0);
	if (FAILED(hr)) {
		printf("ResetEnum--Failure: (%08x)\n", hr);
	}
	while (!FAILED(hr = pImport->EnumTypeRefs(tkScope, &hEnumTypeRefs, rgtkTypeRef,
//	while (!FAILED(hr = pImport->EnumTypeRefs(tkScope, &hEnumTypeRefs, rgtkTypeRef,
								NumItems(rgtkTypeRef), &cTypeRefs)) && cTypeRefs > 0) {
		for (unsigned int iTR=0; iTR < cTypeRefs; ++iTR) {
			TestGetTypeRefProps98(pImport,tkScope,rgtkTypeRef[iTR],ulDispFlags);
		}
	}
	pImport->CloseEnum(tkScope, hEnumTypeRefs);
}
/********************************************************************************\
*   Tests for CompLib '98                                                        *
*                                                                                *
*   End *98 Block                                                                *
\********************************************************************************/



/////////////////////////////////////////////////////////////////////////
// RawDump() function
//
// Dumps the meta data content of a .CLB, .CLASS, or .DLL file
//
void RawDump(mdScope sc, IMetaDataImport *pImport, char *szFile)
{
	HCORENUM hClasses = 0;
	mdTypeRef rgcr[10];
	ULONG cClasses;
	HCORENUM hMembers = 0;
	mdMemberRef rgmr[10];
	ULONG cMembers;
	HCORENUM hIfaceImpls = 0;
	mdInterfaceImpl rgii[10];
	ULONG cIfaceImpls;
    char rcFname[_MAX_FNAME], rcExt[_MAX_EXT];



	HRESULT		hr;
	_splitpath(szFile, 0, 0, rcFname, rcExt);
	printf("\nFile: %s%s\n", rcFname, rcExt);

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all classes (and interfaces)
	hClasses = 0;
	while (SUCCEEDED(hr = pImport->EnumTypeDefs(sc, &hClasses, rgcr,
							NumItems(rgcr), &cClasses)) &&
			cClasses > 0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			char szTypeName[20];
			WCHAR szNamespace[255];
			WCHAR szClass[255];
			CLSID clsid;
			GUID cvid;
			CLASSVERSION ver;
			WCHAR szGuid[100];
			char szAttr[255];
			DWORD attr;
			DWORD attr2;
			mdTypeRef crExtends;


			pImport->GetTypeDefProps(sc, rgcr[i], szNamespace, NumItems(szNamespace)-1, 0,
									szClass, NumItems(szClass)-1, 0,
									&clsid, &ver, &attr, &crExtends, &attr2);

			if(attr & tdInterface)
				strcpy(szTypeName,"Interface") ;
			else
				strcpy(szTypeName,"Class");

			if (szNamespace[0] != 0)
			{
				wcscat(szNamespace, L" :: ");
			}

			printf("\n%ls%ls Name: (%8.8x) %ls\n", szNamespace, szTypeName, rgcr[i], szClass);
			if (crExtends!=mdTypeRefNil)
			{
				WCHAR szSuper[255];
				GetTypeRefOrDefProps(pImport, sc, crExtends, szSuper, NumItems(szSuper)-1, 0);
				printf("Super Class Name:   (%8.8x) %ls\n", crExtends, szSuper);
			}
			else
				printf("No Super Class\n");
			StringFromGUID2(clsid, szGuid, sizeof(szGuid));
			printf("GUID: %ls\n", szGuid);
			StringFromGUID2(cvid, szGuid, sizeof(szGuid));
			printf("CVID: %ls\n", szGuid);
			printf("Version: %d:%d:%d:%d\n", ((WORD *) &ver)[0], ((WORD *) &ver)[1],
										((WORD *) &ver)[2], ((WORD *) &ver)[3]);

			szAttr[0] = 0 ;
			if(attr & tdPublic) strcat(szAttr,"public ") ;
			if(attr & tdFinal) strcat(szAttr,"final ") ;
			if(attr & tdAbstract) strcat(szAttr,"abstract ") ;
			if(attr & 0x0020) strcat(szAttr,"super ") ;

			printf("%s Attributes: %s\n", szTypeName, szAttr);

			////////////////////////////////////////////////////////////////////
			// Iterate over all members (fields and methods
			hMembers = 0;
            while (SUCCEEDED(hr = pImport->EnumMembers(sc, &hMembers, rgcr[i], rgmr,
                                    NumItems(rgmr), &cMembers)) &&
                    cMembers > 0)
			{
				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR	szMember[255];
					PCCOR_SIGNATURE pbSigBlob;
					ULONG	ulSigBlob;
					DWORD	attr;
					char	szAttr[255];

					pImport->GetMemberProps(sc, rgmr[j], NULL, szMember,
                                NumItems(szMember)-1, 0, &attr, &pbSigBlob, &ulSigBlob, 0, 0, 0, 0, 0);

					printf("\n\tMember Type: %s\n", (TypeFromToken(rgmr[j]) == mdtMethodDef) ? "Method" : "Field");
					printf("\tMember Name: %ls\n", szMember);

					szAttr[0] = 0 ;
					if(attr & mdPublic) strcat(szAttr,"public ") ;
					if(attr & mdPrivate) strcat(szAttr,"private ") ;
					if(attr & mdProtected) strcat(szAttr,"protected ") ;
					if(attr & mdStatic) strcat(szAttr,"static ") ;
					if(attr & mdFinal) strcat(szAttr,"final ") ;
					if(attr & mdSynchronized) strcat(szAttr,"synchronized ") ;
					if(attr & mdVirtual) strcat(szAttr,"virtual ") ;
					if(attr & mdAgile) strcat(szAttr,"agile ") ;
					if(attr & mdNative) strcat(szAttr,"native ") ;
					if(attr & mdNotRemotable) strcat(szAttr,"notRemotable ") ;
					if(attr & mdAbstract) strcat(szAttr,"abstract ") ;
					if(attr & mdCtor) strcat(szAttr,"constructor ") ;
					printf("\tMember Attributes: %s\n", szAttr) ;
					DumpSignature(sc, pbSigBlob, ulSigBlob);
					// printf("\tMember Signature: %ls\n", szSig);
					if (TypeFromToken(rgmr[j]) == mdtMethodDef)
						DumpException(sc, rgmr[j]);
				}
			}
			pImport->CloseEnum(sc, hMembers);

			////////////////////////////////////////////////////////////////////
			// Iterate over all interface impls.
			hIfaceImpls = 0;
			while (SUCCEEDED(hr = pImport->EnumInterfaceImpls(sc, &hIfaceImpls, rgcr[i], rgii,
									NumItems(rgii), &cIfaceImpls)) &&
					cIfaceImpls > 0)
			{
				for (unsigned int j=0; j<cIfaceImpls; ++j)
				{
					mdTypeDef cl;
					mdTypeRef cr;
					DWORD flags;
					hr = pImport->GetInterfaceImplProps(sc, rgii[j], &cl, &cr, &flags);
					if (FAILED(hr))
					{
						printf("GetInterfaceImplProps--Failure: %08x\n", hr);
					}
					WCHAR szClass2[255];
					WCHAR szClass3[255];
					CLSID clsid2;
					CLASSVERSION ver2;
					DWORD attr2;

					pImport->GetTypeDefProps(sc, cl, NULL,0,NULL, szClass2, NumItems(szClass2)-1, 0,
											&clsid2, &ver2, &attr2, NULL, NULL);

					GetTypeRefOrDefProps(pImport, sc, cr, szClass3, NumItems(szClass3)-1, 0);
					printf("Class (%8.8x) %ls implements Interface (%8.8x) %ls\n",cl,szClass2,cr,szClass3);
				}
			}
			pImport->CloseEnum(sc, hIfaceImpls);
		}
	}
	pImport->CloseEnum(sc, hClasses);

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all class refs
	hClasses = 0;
	while (!FAILED(hr = pImport->EnumTypeRefs(sc, &hClasses, rgcr,
									NumItems(rgcr), &cClasses)) &&
			cClasses > 0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			WCHAR szClass[255];

			// Get the imported class/interface name.
			GetTypeRefOrDefProps(pImport, sc, rgcr[i], szClass, NumItems(szClass)-1, 0);
			printf("\nClass/Interface Reference: (%8.8x) %ls\n", rgcr[i], szClass);

			hMembers = 0;
			for(;;)
			{
				hr = pImport->EnumMemberRefs(sc, &hMembers, rgcr[i], rgmr,
									NumItems(rgmr), &cMembers);
				if (FAILED(hr) || cMembers == 0)
					break;

				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR szMember[255];
					PCCOR_SIGNATURE pbSigBlob;
					ULONG ulSigBlob;
					ULONG iSigBlob;

					pImport->GetMemberRefProps(sc, rgmr[j], NULL, szMember,
								NumItems(szMember)-1, 0, &pbSigBlob, &ulSigBlob);
					printf("\tMember: (%8.8x) %ls: ", rgmr[j], szMember);

					// dumping signature in hex format
					for (iSigBlob = 0; iSigBlob < ulSigBlob; iSigBlob++)
						printf("%2x ", pbSigBlob[iSigBlob]);
					printf("\n");

				}
			}
			pImport->CloseEnum(sc, hMembers);
		}
	}
	pImport->CloseEnum(sc, hClasses);

}

/////////////////////////////////////////////////////////////////////////
// Summarize() function
//
// Dumps the meta data in a "Summarize" format.
//
void Summarize(mdScope sc, IMetaDataImport *pImport, char *szFile)
{
	HCORENUM hClasses = 0;
	mdTypeRef rgcr[10];
	ULONG cClasses;
	HCORENUM hMembers = 0;
	mdMemberRef rgmr[10];
	ULONG cMembers;
	HCORENUM hIfaceImpls = 0;
	mdInterfaceImpl rgii[10];
	ULONG cIfaceImpls;
	HRESULT		hr;

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all classes (and interfaces)
	hClasses = 0;
	while (SUCCEEDED(hr = pImport->EnumTypeDefs(sc, &hClasses, rgcr,
							NumItems(rgcr), &cClasses)) &&
			cClasses > 0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			char szTypeName[20];
			WCHAR szClass[255];
			CLSID clsid;
			CLASSVERSION ver;
			WCHAR *pClass;
			WCHAR *pPackage;
			char szAttr[255];
			int	 bInterface=false;
			DWORD clAttr;
			mdTypeDef clExtends;
			WCHAR szExtends[255];
			pImport->GetTypeDefProps(sc, rgcr[i], NULL,0,NULL, szClass, NumItems(szClass)-1, 0,
									&clsid, &ver, &clAttr,
									&clExtends, NULL);
#if 0 // test FindClass
			{
			mdTypeDef cl;
			hr = pImport->FindClass(sc, szClass, &cl);
			printf("FindClass(%ls): cl:%x, hr:%x\n", szClass, cl, hr);
			hr = pImport->FindClass(sc, L"Blah", &cl);
			printf("FindClass(Blah): cl:%x, hr:%x\n", cl, hr);
			}
#endif
			pPackage = 0;
			pClass = szClass;
			for (WCHAR *p=pClass; *p; ++p)
			{
				if ((*p == L'/' || *p == L'.') && *(p+1))
				{
					pClass = p+1;
					pPackage = p;
					*p = L'.';
				}
			}
			if (pPackage)
			{
				*pPackage = 0;
				pPackage = szClass;
			}

			if (pPackage)
				printf("package %ls;\n", pPackage);

			// What is it?
			if(clAttr & tdInterface)
				strcpy(szTypeName,"interface"), bInterface = true ;
			else
				strcpy(szTypeName,"class");

			// Attributes.
			szAttr[0] = 0 ;
			if(clAttr & tdPublic) strcat(szAttr,"public ") ;
			if(clAttr & tdFinal) strcat(szAttr,"final ") ;
			if(clAttr & tdAbstract) strcat(szAttr,"abstract ") ;

			printf("%s%s %ls ", szAttr, szTypeName, pClass);
			//@todo: extends.
			if (clExtends != mdTypeRefNil)
			{
				hr = GetTypeRefOrDefProps(pImport, sc, clExtends, szExtends, NumItems(szExtends), 0);
				printf("extends %ls ", szExtends);
			}

			hIfaceImpls = 0;
			while (SUCCEEDED(hr = pImport->EnumInterfaceImpls(sc, &hIfaceImpls, rgcr[i], rgii,
									NumItems(rgii), &cIfaceImpls)) &&
					cIfaceImpls > 0)
			{
				for (unsigned int j=0; j<cIfaceImpls; ++j)
				{
					mdTypeDef cl;
					mdTypeRef cr;
					DWORD flags;
					hr = pImport->GetInterfaceImplProps(sc, rgii[j], &cl, &cr, &flags);

					// Get the imported class/interface name.
					hr = GetTypeRefOrDefProps(pImport, sc, cr, szClass, NumItems(szClass)-1, 0);
					if (j == 0)
						printf("\n\timplements ");
					else
						printf(",\n\t");
					printf("%ls", szClass);
				}
			}
			pImport->CloseEnum(sc, hIfaceImpls);
			printf(" {\n");
			////////////////////////////////////////////////////////////////////
			// Iterate over all members (fields and methods
			hMembers = 0;
			while (SUCCEEDED(hr = pImport->EnumMembers(sc, &hMembers, rgcr[i], rgmr,
									NumItems(rgmr), &cMembers)) &&
					cMembers > 0)
			{
				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR	szMember[255];
					PCCOR_SIGNATURE pbSigBlob;
					ULONG	ulSigBlob;
					ULONG	ulCalling;
					ULONG	ulArgs;
					ULONG	cb;
					ULONG	ulSigCur;
					DWORD	attr;

					pImport->GetMemberProps(sc, rgmr[j], NULL, szMember, NumItems(szMember)-1, 0,
                                &attr, &pbSigBlob, &ulSigBlob, 0, 0, 0, 0, 0);

					// Skip class initializer.
					if (wcscmp(szMember, L"<clinit>") == 0)
						continue;

					printf("    ");

					// pop off the calling convention
					ulSigCur = CorSigUncompressData(pbSigBlob, &ulCalling);

					if (TypeFromToken(rgmr[j]) == mdtMethodDef)
					{	
						// Method.

						// get the argument count
						ulSigCur += CorSigUncompressData(&pbSigBlob[ulSigCur], &ulArgs);
						if (attr & mdPublic && !bInterface)	printf("public ");
						if (attr & mdProtected)		printf("protected ");
						if (attr & mdPrivate)		printf("private ");
						if (attr & mdStatic)		printf("static ");
						if (attr & mdFinal && !(clAttr & tdFinal))	printf("final ");
						if (attr & mdSynchronized)	printf("synchronized ");
						if (attr & mdNative)		printf("native ");

						if (wcscmp(szMember, L"<init>") == 0)
							printf("%ls", pClass);
						else
						{
							// print out the return type of method
							hr = UndecorateOneElementType(sc, &pbSigBlob[ulSigCur], ulSigBlob - ulSigCur, &cb);
							if (FAILED(hr))
								goto ErrExit;
							ulSigCur += cb;

							// print out the name of the method
							printf(" %ls", szMember);
						}
						printf("(");
						while (ulArgs > 0)
						{
							// print out the return type of method
							hr = UndecorateOneElementType(sc, &pbSigBlob[ulSigCur], ulSigBlob - ulSigCur, &cb);
							if (FAILED(hr))
								goto ErrExit;
							ulSigCur += cb;
							if (ulArgs > 1)
								printf(",");
							ulArgs--;
						}
						printf(")\n");
						DumpException(sc, rgmr[j]);
#if 1 // Test FindMemberAttribute for code.
						{
							mdCustomValue atCode;
							BYTE *pCode;
							ULONG cbAttr;
							ULONG  cbCode;
							hr = pImport->FindCustomValue(sc, rgmr[j], L"Code", &atCode, 0);
							if (hr != S_OK)
								printf("FindMemberAttribute(...\"Code\"...) returned %x\n", hr);
							else
							{
								hr = pImport->GetCustomValueAsBlob(sc, atCode, (const void**) &pCode, &cbAttr);
								if (FAILED(hr))
									printf("GetAttributeProps(...\"Code\"...) returned %x\n", hr);
								else
								{
									printf("\nCodeAttr: (%d)", cbAttr);
									for (unsigned i=0; i<128 && i<cbAttr; ++i)
									{
										if ((i & 0xf) == 0) printf("\n");
										printf("%02x ", pCode[i]);
									}
									printf("\n");
								}
							}
							hr = pImport->GetMethodCode(sc, rgmr[j], (void**)&pCode, &cbCode);
							if (hr != S_OK)
								printf("GetMemberCode() returned %x\n", hr);
							else
							{
								printf("CodeByte: (%d)", cbCode);
								for (unsigned int i=0; i<128 && i<cbCode; ++i)
								{
									if ((i & 0xf) == 0) printf("\n");
									printf("%02x ", pCode[i]);
								}
								printf("\n");
							}
						}
#endif
					}
					else
					{	// Field.
						VARIANT vtValue;
						DWORD	dwCPlusTypeFlag;
						void const *pValue;
#if 0
						WCHAR	szAttr[255];
						mdCustomValue at;
						BYTE *pBlob;
						USHORT cbBlob;
						USHORT ix;
						mdCPToken cp;
#endif // 0

						if (attr & mdPublic && !bInterface)	printf("public ");
						if (attr & mdProtected)				printf("protected ");
						if (attr & mdPrivate)				printf("private ");
						if (attr & mdStatic && !bInterface) printf("static ");
						if (attr & mdFinal  && !bInterface)	printf("final ");
						//if (attr & mdVolatile)				printf("volatile ");
						//if (attr & mdTransient)				printf("transient ");

						// print out the type of the field
						hr = UndecorateOneElementType(sc, &pbSigBlob[ulSigCur], ulSigBlob - ulSigCur, &cb);
						if (FAILED(hr))
							goto ErrExit;
						ulSigCur += cb;

						// print out the name of the field
						printf(" %ls", szMember);

						::VariantInit(&vtValue);
						// Get any constant value
#if 1	// directly
						hr = pImport->GetMemberProps(sc, rgmr[j],0,0,0,0,0,0,0,0,0,0,&dwCPlusTypeFlag, &pValue);
						hr = _FillVariant((BYTE)dwCPlusTypeFlag, (void *)pValue, &vtValue);
#else	// through the ConstantValue attribute index into the constant pool
						hr = pImport->FindMemberAttribute(sc, rgmr[j], L"ConstantValue", &at);
						if (SUCCEEDED(hr))
						    hr = pImport->GetAttributeProps(sc, at, szAttr, NumItems(szAttr), (void**)&pBlob, &cbBlob);
						ix = pBlob[0]<<8 | pBlob[1];
						if (SUCCEEDED(hr))
							hr = pImport->GetTokenFromIndex(sc, ix, &cp);
						if (SUCCEEDED(hr))
							hr = pImport->GetTokenValue(sc, cp, &vtValue);
#endif
						if (SUCCEEDED(hr))
						{
							switch (vtValue.vt)
							{
							case VT_R4:
								printf(" = %g", vtValue.fltVal);
								break;
							case VT_R8:
								printf(" = %f", vtValue.dblVal);
								break;
							case VT_I4:
								printf(" = %d", vtValue.lVal);
								break;
							case VT_I8:
								printf(" = %I64d", vtValue.cyVal.int64);
								break;
							case VT_BSTR:
								printf(" = \"%ls\"", vtValue.bstrVal);
								::VariantClear(&vtValue);
								break;
							default:
								printf(" = (vt=%x)", vtValue.vt);
								break;
							}
						}
					}
					printf(";\n");
				}
			}

			pImport->CloseEnum(sc, hMembers);
			printf("}\n");
		}
	}
	pImport->CloseEnum(sc, hClasses);
	return;

ErrExit:
	pImport->CloseEnum(sc, hMembers);
	pImport->CloseEnum(sc, hClasses);
	return;
}



/////////////////////////////////////////////////////////////////////////
// HRESULT DumpOneElementType(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
//
// Dump COM+ signature element type 
/////////////////////////////////////////////////////////////////////////
HRESULT DumpOneElementType(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
{
	ULONG		cbCur = 0;
	ULONG		cb;
	ULONG		ulData;
	ULONG		ulTemp;
	int			iTemp;
	WCHAR		wzTypeRef[512];
	mdToken		tk;

	cb = CorSigUncompressData(pbSigBlob, &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	if (ulData >= ELEMENT_TYPE_MAX) 
	{
		_ASSERTE(!"Bad signature blob value!");
		return E_FAIL;
	}
	while (ulData == ELEMENT_TYPE_PTR || ulData == ELEMENT_TYPE_BYREF)
	{
		printf(" %s", g_szMapElementType[ulData]);
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
		cbCur += cb;
		ulSigBlob -= cb;
	}
	printf(" %s", g_szMapElementType[ulData]);
	if (CorIsPrimitiveType((CorElementType)ulData))
	{
		// If this is a primitive type, we are done
		goto ErrExit;
	}
	if (ulData == ELEMENT_TYPE_VALUECLASS || ulData == ELEMENT_TYPE_CLASS)
	{
		cb = CorSigUncompressToken(&pbSigBlob[cbCur], &tk);
		cbCur += cb;
		ulSigBlob -= cb;	

		// get the name of type ref. Don't care if truncated
		if (FAILED( GetTypeRefOrDefProps(
			g_pImport,
			tkScope, 
			tk, 
			wzTypeRef,
			512, 
			NULL) ))
			goto ErrExit;
		printf(" %ls", wzTypeRef);
		goto ErrExit;
	}
	if (ulData == ELEMENT_TYPE_SDARRAY)
	{
		// dump the base type of SDARRAY
		if (FAILED(DumpOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
			goto ErrExit;
		cbCur += cb;
		ulSigBlob -= cb;

		// dump the size of SDARRAY
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
		cbCur += cb;
		ulSigBlob -= cb;
		printf(" %d", ulData);
		goto ErrExit;
	}

	_ASSERTE(ulData == ELEMENT_TYPE_ARRAY || ulData == ELEMENT_TYPE_GENARRAY);

	// dump the base type of SDARRAY
	if (FAILED(DumpOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
		goto ErrExit;
	cbCur += cb;
	ulSigBlob -= cb;

	// dump the rank of MDARRAY
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	printf(" %d", ulData);
	if (ulData == 0)
		// we are done if no rank specified
		goto ErrExit;

	// how many dimensions have size specified?
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	printf(" %d", ulData);
	while (ulData)
	{

		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulTemp);
		printf(" %d", ulTemp);
		cbCur += cb;
		ulSigBlob -= cb;
		ulData--;
	}
	// how many dimensions have lower bounds specified?
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	printf(" %d", ulData);
	while (ulData)
	{

		cb = CorSigUncompressSignedInt(&pbSigBlob[cbCur], &iTemp);
		printf(" %d", iTemp);
		cbCur += cb;
		ulSigBlob -= cb;
		ulData--;
	}
	
ErrExit:
	*pcb = cbCur;
	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
// HRESULT	DumpSignature(mdScope tkScope, BYTE *pbSigBlob, ULONG ulSigBlob);
//
// Dump COM+ signature
/////////////////////////////////////////////////////////////////////////
HRESULT	DumpSignature(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob)
{
	ULONG		cbCur = 0;
	ULONG		cb;
	ULONG		ulData;
	ULONG		ulArgs;
	ULONG		i;
	HRESULT		hr = NOERROR;

	cb = CorSigUncompressData(pbSigBlob, &ulData);

	printf("\tCalling Convention: %s", g_strCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]);
	if (ulData & IMAGE_CEE_CS_CALLCONV_RETPARAM)
		printf(" returnsValueClass ");
	if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
		printf(" instanceMethod ");
	printf("\n");
	cbCur += cb;
	ulSigBlob -= cb;
	if (isCallConv(ulData, IMAGE_CEE_CS_CALLCONV_FIELD))
	{
		// dump field type
		printf("\tField type: ");
		if (FAILED(hr = DumpOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
			goto ErrExit;
		printf("\n");
		ulSigBlob -= cb;
	}
	else 
	{
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulArgs);
		cbCur += cb;
		ulSigBlob -= cb;

		// dump return type
		printf("\tReturn type: ");
		if (FAILED(DumpOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
			goto ErrExit;
		printf("\n");
		cbCur += cb;
		ulSigBlob -= cb;

		// dump count of argument
		// dump arguments
		if (ulArgs)
			printf("\tNumber of arguments: %d\n", ulArgs);
		else
			printf("\tNo arguments.\n");
		for (i = 0; i < ulArgs; i++)
		{
			printf("\tArgument %3d:", i + 1);
			if (FAILED(DumpOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
				goto ErrExit;
			printf("\n");
			cbCur += cb;
			ulSigBlob -= cb;
		}
	}
	// We should have consumed all signature blob
	_ASSERTE(ulSigBlob == 0);
ErrExit:
	if (FAILED(hr))
		printf("ERROR!! Bad signature blob value!\n");
	return hr;
}



#define		MAX_ARRAY			8
/////////////////////////////////////////////////////////////////////////
// HRESULT UndecorateOneElementType(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
//
// print out an element type 
//
// Dump COM+ signature element type 
/////////////////////////////////////////////////////////////////////////
HRESULT UndecorateOneElementType(mdScope tkScope, PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
{
	ULONG		cbCur = 0;
	ULONG		cb;
	ULONG		ulData;
	ULONG		ulRank;
	ULONG		i;
	WCHAR		wzTypeRef[512];
	int 		ulLowerBound[MAX_ARRAY];
	ULONG		ulSize[MAX_ARRAY];
	ULONG		*pulSize = ulSize;
	int			*pulLowerBound = ulLowerBound;
	ULONG		ulMaxRank = MAX_ARRAY;
	mdToken		tk;
	HRESULT		hr = NOERROR;
	bool		isMDArray = false;

	cb = CorSigUncompressData(pbSigBlob, &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	if (ulData >= ELEMENT_TYPE_MAX) 
	{
		_ASSERTE(!"Bad signature blob value!");
		return E_FAIL;
	}

	// @todo: what sequence should we print out??
	while (ulData == ELEMENT_TYPE_PTR || ulData == ELEMENT_TYPE_BYREF)
	{
		printf(" %s", g_szMapUndecorateType[ulData]);
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
		cbCur += cb;
		ulSigBlob -= cb;
	}
	if (g_szMapUndecorateType[ulData][0] != '\0')
		printf(" %s", g_szMapUndecorateType[ulData]);
	if (CorIsPrimitiveType((CorElementType)ulData))
	{
		// If this is a primitive type, we are done.
		goto ErrExit;
	}
	if (ulData == ELEMENT_TYPE_VALUECLASS || ulData == ELEMENT_TYPE_CLASS)
	{
		cb = CorSigUncompressToken(&pbSigBlob[cbCur], &tk);
		cbCur += cb;
		ulSigBlob -= cb;	

		// get the name of type ref. Don't care if truncated
		if (FAILED(hr = GetTypeRefOrDefProps(
			g_pImport,
			tkScope, 
			tk, 
			wzTypeRef,
			512, 
			NULL) ))
			goto ErrExit;
		printf(" %ls", wzTypeRef);

		// we are done.
		goto ErrExit;
	}
	if (ulData == ELEMENT_TYPE_SDARRAY)
	{
		// dump the base type of SDARRAY
		if (FAILED(hr = UndecorateOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
			goto ErrExit;
		cbCur += cb;
		ulSigBlob -= cb;

		// dump the size of SDARRAY
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
		if (ulData)
			printf("[%d]", ulData);
		else
			printf("[]");

		// we are done.
		goto ErrExit;
	}

	_ASSERTE(ulData == ELEMENT_TYPE_ARRAY || ulData == ELEMENT_TYPE_GENARRAY);

	if (ulData == ELEMENT_TYPE_ARRAY)
		isMDArray = true;

	// dump the base type of MDARRAY or GENARRAY
	if (FAILED(hr = UndecorateOneElementType(tkScope, &pbSigBlob[cbCur], ulSigBlob, &cb)))
		goto ErrExit;
	cbCur += cb;
	ulSigBlob -= cb;

	// dump the rank of MDARRAY
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	if (ulData > ulMaxRank)
	{
		if (pulSize != ulSize)
		{
			free(pulSize);
			free(pulLowerBound);
		}

		// allocate enough buffer to hold dimension size and lower bound
		pulSize = (ULONG *)malloc(sizeof(ULONG) * ulData);
		if (pulSize == NULL)
			goto ErrExit;
		pulLowerBound = (int *)malloc(sizeof(int) * ulData);
		if (pulLowerBound == NULL)
			goto ErrExit;
	}
	ulRank = ulData;
	for (i=0; i < ulRank; i++)
	{
		// clear everything
		pulSize[i] = pulLowerBound[i] = 0;
	}
	if (ulRank == 0)
		// we are done if no rank specified
		goto ErrExit;

	// how many dimensions have size specified?
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	for (i=0; i < ulData; i++)
	{
		cb = CorSigUncompressData(&pbSigBlob[cbCur], &pulSize[i]);
		cbCur += cb;
		ulSigBlob -= cb;
	}
	// how many dimensions have lower bounds specified?
	cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
	cbCur += cb;
	ulSigBlob -= cb;
	for (i=0; i < ulData; i++)
	{
		cb = CorSigUncompressSignedInt(&pbSigBlob[cbCur], &pulLowerBound[i]);
		cbCur += cb;
		ulSigBlob -= cb;
	}
	if (isMDArray)
		printf("[");
	else
		printf("{");
	for (i=0; i<ulRank; i++)
	{
		if (pulSize[i])
		{
			printf("%d..%d",pulLowerBound[i], pulLowerBound[i] + pulSize[i] - 1);
		}
		else
		{
			if (pulLowerBound[i])
			{
				printf("%d..-", pulLowerBound[i]);
			}
		}
		if (i+1 < ulRank)
			printf(",");
	}
	if (isMDArray)
		printf("]");
	else
		printf("}");
	
ErrExit:
	if (pulSize != ulSize)
	{
		free(pulSize);
		free(pulLowerBound);
	}
	*pcb = cbCur;
	return hr;
}


/////////////////////////////////////////////////////////////////////////
// DumpException(mdScope tkScope, mdMemberDef md)
//
// Dumping the exception classes that can be raised by a method
//
/////////////////////////////////////////////////////////////////////////
HRESULT	DumpException(mdScope tkScope, mdMethodDef md)
{
	HRESULT		hr;
	HCORENUM    hEnum = 0;
	mdException	ex;
	ULONG		cExceptions;
	mdToken		tk;
	WCHAR		wzTypeRef[512];
	bool		fFirstClass = true;
	ULONG		iCount = 0;

	while (true)
	{
		cExceptions = 0;
		iCount ++;
		hr = g_pImport->EnumExceptions(					// S_OK, S_FALSE, or error.
			tkScope,                  // [IN] The scope.
			&hEnum,                // [IN|OUT] Pointer to the enum.
			md,                     // [IN] MemberDef to scope the enumeration.
			&ex,			// [OUT] Put ParamDefs here.
			1,                   // [IN] Max ParamDefs to put.
			&cExceptions);		    // [OUT] Put # put here.
		if (FAILED(hr) || hr == S_FALSE || cExceptions == 0)
			break;
		hr = g_pImport->GetExceptionProps(
			tkScope,
			ex,
			NULL,
			&tk);
		if (FAILED(hr))
			goto ErrExit;
		hr = GetTypeRefOrDefProps(
			g_pImport, 
			tkScope, 
			tk, 
			wzTypeRef, 
			512,
			NULL);
		if (FAILED(hr))
			goto ErrExit;

		if (fFirstClass)
		{
			fFirstClass = false;
			printf("	Throws exception: ");
		}
		printf("%ls, ", wzTypeRef);
	}
	if (fFirstClass == false)
		printf("\n");
ErrExit:
	return hr;

}


/////////////////////////////////////////////////////////////////////////
// Iterate() function
//
// Iterates the meta data content of a .CLB, .CLASS, or .DLL file
//
void Iterate(mdScope sc, IMetaDataImport *pImport, char *szFile)
{
	HCORENUM hClasses = 0;
	mdTypeRef rgcr[10];
	ULONG cClasses;
	HCORENUM hMembers = 0;
	mdMemberRef rgmr[10];
	ULONG cMembers;
	HCORENUM hIfaceImpls = 0;
	mdInterfaceImpl rgii[10];
	ULONG cIfaceImpls;



	HRESULT		hr;

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all classes (and interfaces)
	hClasses = 0;
	while (SUCCEEDED(hr = pImport->EnumTypeDefs(sc, &hClasses, rgcr,
							NumItems(rgcr), &cClasses)) &&
			cClasses > 0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			WCHAR szClass[255];
			CLSID clsid;
			CLASSVERSION ver;
			DWORD attr;

			pImport->GetTypeDefProps(sc, rgcr[i], NULL,0,NULL, szClass, NumItems(szClass)-1, 0,
									&clsid, &ver, &attr, NULL, NULL);

			////////////////////////////////////////////////////////////////////
			// Iterate over all members (fields and methods
			hMembers = 0;
			while (SUCCEEDED(hr = pImport->EnumMembers(sc, &hMembers, rgcr[i], rgmr,
									NumItems(rgmr), &cMembers)) &&
					cMembers > 0)
			{
				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR szMember[255];
					PCCOR_SIGNATURE pvSigBlob;
					ULONG	cbSigBlob;
					DWORD attr;

					pImport->GetMemberProps(sc, rgmr[j], NULL, szMember,
                                NumItems(szMember)-1, 0, &attr, &pvSigBlob, &cbSigBlob, 0, 0, 0, 0, 0);

				}
			}
			pImport->CloseEnum(sc, hMembers);

			////////////////////////////////////////////////////////////////////
			// Iterate over all interface impls.
			hIfaceImpls = 0;
			while (SUCCEEDED(hr = pImport->EnumInterfaceImpls(sc, &hIfaceImpls, rgcr[i], rgii,
									NumItems(rgii), &cIfaceImpls)) &&
					cIfaceImpls > 0)
			{
				for (unsigned int j=0; j<cIfaceImpls; ++j)
				{
					mdTypeDef cl;
					mdTypeRef cr;
					DWORD flags;
					hr = pImport->GetInterfaceImplProps(sc, rgii[j], &cl, &cr, &flags);
					if (FAILED(hr))
					{
						printf("Failure: %08x\n", hr);
					}
				}
			}
			pImport->CloseEnum(sc, hIfaceImpls);
		}
	}
	pImport->CloseEnum(sc, hClasses);

	/////////////////////////////////////////////////////////////////////////
	// Iterate over all class refs
	hClasses = 0;
	while (!FAILED(hr = pImport->EnumTypeRefs(sc, &hClasses, rgcr,
									NumItems(rgcr), &cClasses)) &&
			cClasses > 0)
	{
		for (unsigned int i=0; i < cClasses; ++i)
		{
			WCHAR szClass[255];

			// Get the imported class/interface name.
			GetTypeRefOrDefProps(pImport, sc, rgcr[i], szClass, NumItems(szClass)-1, 0);

#if 0
			hMembers = 0;
			for(;;)
			{
				hr = pImport->EnumMemberRefs(sc, &hMembers, rgcr[i], rgmr,
									NumItems(rgmr), &cMembers);
				if (FAILED(hr) || cMembers == 0)
					break;

				for (unsigned int j=0; j < cMembers; ++j)
				{
					WCHAR szMember[255];
					WCHAR szSig[512];

					pImport->GetMemberRefProps(sc, rgmr[j], NULL, szMember,
								NumItems(szMember)-1, (PCOR_SIGNATURE) szSig, NumItems(szSig)-1);
				}
			}
			pImport->CloseEnum(sc, hMembers);
#endif
		}
	}
	pImport->CloseEnum(sc, hClasses);
}


/////////////////////////////////////////////////////////////////////////
// Iterate() function
//
// Iterates the meta data content of a .CLB, .CLASS, or .DLL file
//
/////////////////////////////////////////////////////////////////////////
HRESULT GetTypeRefOrDefProps(
	IMetaDataImport *pImport, 
	mdScope		tkScope, 
	mdToken		tk, 
	LPWSTR		szTypeRef, 
	ULONG		cchTypeRef,
	ULONG		*pcchTypeRef)
{
	WCHAR		wzNamespace[512]; 			// The typedef namespace.
	ULONG		cchNamespace;
	ULONG		cchNamespaceMax = 512;
	WCHAR		wzTypeName[512]; 			// The typedef name.
	ULONG		cchName;
	ULONG		cchNameMax = 512;
	ULONG		cchCur = 0;
	HRESULT		hr = NOERROR;

	if (TypeFromToken(tk) == mdtTypeRef)
	{
		hr = pImport->GetTypeRefProps(tkScope, tk, szTypeRef, cchTypeRef, pcchTypeRef, 0,0);
	}
	else
	{
		hr = pImport->GetTypeDefProps(
			tkScope,                // [IN] The import scope.
			tk,                     // [IN] TypeDef token for inquiry.
			wzNamespace,            // [OUT] Put namespace here.
			cchNamespaceMax,        // [IN] size of Namespace buffer in wide chars.
			&cchNamespace,			// [OUT] put size of Namespace (wide chars) here.
			wzTypeName,             // [OUT] Put name here.
			cchNameMax,             // [IN] size of name buffer in wide chars.
			&cchName,				// [OUT] put size of name (wide chars) here.
			NULL,					// [OUT] Put clsid here.
			NULL,					// [OUT] Put version here.
			NULL,					// [OUT] Put flags here.
			NULL,					// [OUT] Put base class TypeDef/TypeRef here.
			NULL);					// [OUT] Put extends flags here.
		if (FAILED(hr))
			goto ErrExit;

		if (cchNamespace)
		{	// Assume the worst.
			hr = E_FAIL;

			// Copy in the namespace part.
			wcsncpy(szTypeRef, wzNamespace, cchTypeRef);
			if ((cchNamespace+1) >= cchTypeRef)
				goto ErrExit;
			cchTypeRef -= cchNamespace;

			// Copy the delim.
			szTypeRef[cchNamespace] = L'.';

			// The classname part.
			wcsncpy(szTypeRef+cchNamespace+1, wzTypeName, cchTypeRef - cchNamespace - 1);

			// Return the required buffer.
			if (pcchTypeRef)
				*pcchTypeRef = cchNamespace + 1 + cchName + 1;

			// Actually worked.
			hr = S_OK;
		}
		else
		{
			memcpy(szTypeRef, wzTypeName, cchName > cchTypeRef ? cchTypeRef : cchName * sizeof(WCHAR));
			if (pcchTypeRef)
				*pcchTypeRef = cchName;
			
		}
	}

	// fall through

ErrExit:
	return hr;
}


#define		MAX_METHOD_ARRAY		20


// print out a classdef or classref name
HRESULT DumpClassName(IMetaDataImport *pImport, mdScope scope, mdToken tk)
{
	HRESULT hr;
	WCHAR	wzName[128];

	if (TypeFromToken(tk) == mdtTypeDef) 
	{
		hr = pImport->GetTypeDefProps(
			scope, 
			tk, 
			NULL, 0, NULL,
			wzName,
			NumItems(wzName)-1, 
			NULL,
			NULL,
			NULL,
			NULL, 
			NULL, 
			NULL);
		if (FAILED(hr))
			goto ErrExit;
	}
	else
	{
		_ASSERTE(TypeFromToken(tk) == mdtTypeRef);
		hr = pImport->GetTypeRefProps(
			scope, 
			tk, 
			wzName, 
			NumItems(wzName)-1, 
			NULL, 
			0,
			0);
		if (FAILED(hr))
			goto ErrExit;

	}
	printf("%ls", wzName);

ErrExit:
	return hr;

}

// print out method name
HRESULT DumpMethodName(IMetaDataImport *pImport, mdScope scope, mdMethodDef md)
{
	HRESULT hr;
	WCHAR	wzName[128];
	
	hr = pImport->GetMemberProps(
		scope, 
		md, 
		NULL, 
		wzName, 
		NumItems(wzName)-1, 
		0, 
		NULL, 
		NULL, 
		NULL, 
		NULL, 
		NULL, 
		NULL,
		NULL,
		NULL);
	if (FAILED(hr))
		goto ErrExit;

	printf("%ls", wzName);

ErrExit:
	return hr;

}

// print out event name
HRESULT DumpEventName(IMetaDataImport *pImport, mdScope scope, mdEvent ev)
{
	HRESULT hr;
	WCHAR	wzName[128];

	hr = pImport->GetEventProps(	// S_OK, S_FALSE, or error.
		scope,						// [IN] The scope.
		ev,							// [IN] event token
		NULL,						// [OUT] typedef containing the event declarion.
		wzName,						// [OUT] Event name
		128,						// [IN] the count of wchar of szEvent
		NULL,						// [OUT] actual count of wchar for event's name
		NULL,						// [OUT] Event flags.
		NULL,						// [OUT] EventType class
		NULL,						// [OUT] AddOn method of the event
		NULL,						// [OUT] RemoveOn method of the event
		NULL,						// [OUT] Fire method of the event
		NULL,						// [OUT] other method of the event
		0,						    // [IN] size of rmdOtherMethod
		NULL);					// [OUT] total number of other method of this event
	if (FAILED(hr))
		goto ErrExit;

	printf("%ls", wzName);

ErrExit:
	return hr;
}


//  print out properties of a class
HRESULT DumpProperties(mdScope scope, mdTypeDef td)
{
	HRESULT		hr = NOERROR;
	mdProperty	property;
	mdMethodDef	mdOther[MAX_METHOD_ARRAY];
	ULONG		cOtherMethod;
	PCCOR_SIGNATURE pvSig;
	ULONG		cbSig;
	ULONG		cProperty;
	DWORD		dwPropFlags;
	WCHAR		wzProperty[128];
	ULONG		k;
	mdTypeDef	classdef;
	mdEvent		evNotifyChanging;
	mdEvent		evNotifyChanged;
	mdFieldDef	mdBackingField;
	HCORENUM	henum = 0;
	DWORD		dwCPlusTypeFlag;
	void const	*pValue;

	while (true)
	{
		hr = g_pImport->EnumProperties(
			scope, 
			&henum, 
			td, 
			&property, 
			1, 
			&cProperty);
		if (FAILED(hr))
			goto ErrExit;

		if (cProperty == 0)
			break;		
		hr = g_pImport->GetPropertyProps(// S_OK, S_FALSE, or error.
			scope,						// [IN] The scope.
			property,	                // [IN] property token
			&classdef,					// [OUT] typedef containing the event declarion.
			wzProperty,					// [OUT] Event name
			128,						// [IN] the count of wchar of szEvent
			NULL,						// [OUT] actual count of wchar for event's name
			&dwPropFlags,				// [OUT] Event flags.
			&pvSig,		                // [OUT] signature blob
			&cbSig,						// [OUT] size of signature blob
			&dwCPlusTypeFlag,			// [OUT] default value type
			&pValue,					// [OUT] default value blob
			&mdOther[0],				// [OUT] setter method of the property
			&mdOther[1],				// [OUT] getter method of the property
			&mdOther[2],				// [OUT] reset method of the property
			&mdOther[3],				// [OUT] tets default method
			&mdOther[4],				// [OUT] other method of the property
			NumItems(mdOther) - 4,      // [IN] size of rmdOtherMethod
			&cOtherMethod,				// [OUT] total number of other method of this property
			&evNotifyChanging,			// [OUT] notify changing EventDef or EventRef
			&evNotifyChanged,			// [OUT] notify changed EventDef or EventRef
			&mdBackingField);			// [OUT] backing field
		if (FAILED(hr))
			goto ErrExit;

		_ASSERTE(classdef == td);

		// print out property name
		printf("\tPROPERTY %ls\n", wzProperty);
		
		// print out property flags
		printf("\t\tPROPERTY FLAG - ");
		if (dwPropFlags & prDefaultProperty)			
			printf("DefaultProperty, ");
		if (dwPropFlags & prBindable)			
			printf("Bindable, ");
		if (dwPropFlags & prDisplayBind)			
			printf("DisplayBind, ");
		if (dwPropFlags & prImmediateBind)			
			printf("ImmediateBind, ");
		if (dwPropFlags & prBrowsable)			
			printf("Browsable, ");
		if (dwPropFlags & prOnRequestEdit)			
			printf("OnRequestEdit, ");
		printf("\n");

		for (k = 0 ; k < cOtherMethod + 4; k ++)
		{
			if (mdOther[k] != mdMethodDefNil)
			{					
				if (k == 0)
					printf("\t\tSetter Method : ");
				else if (k == 1)
					printf("\t\tGetter Method : ");
				else if (k == 2)
					printf("\t\tReset Method : ");
				else if (k == 2)
					printf("\t\tTestDefault Method : ");
				else 
					printf("\t\tOther Method : ");
				DumpMethodName(g_pImport, scope, mdOther[k]);
				printf("\n");
			}
		}
		if (evNotifyChanged != mdEventNil)
		{
			printf("\t\tNotify Changing Event is : ");
			DumpEventName(g_pImport, scope, evNotifyChanging);
			printf("\n");
		}

		if (evNotifyChanged != mdEventNil)
		{
			printf("\t\tNotify Changed Event is : ");
			DumpEventName(g_pImport, scope, evNotifyChanged);
			printf("\n");
		}
		if (mdBackingField != mdFieldDefNil)
		{
			printf("\t\tBacking Field is : ");
			DumpMethodName(g_pImport, scope, mdBackingField);
			printf("\n");
		}
	}

	// fall through
ErrExit:
	if (henum)
		g_pImport->CloseEnum(scope, henum);
	return hr;
}

// print out events of a class
HRESULT DumpEvents(mdScope scope, mdTypeDef td)
{
	HRESULT		hr = NOERROR;
	ULONG		cEvent;
	mdEvent		event;
	WCHAR		wzEvent[128];
	ULONG		cbEvent;
	DWORD		dwEventFlags;
	mdToken		tkEventType;
	mdMethodDef	mdOther[MAX_METHOD_ARRAY];
	ULONG		cOtherMethod;
	HCORENUM	henum = 0;
	ULONG		k;
	mdTypeDef	classdef;

	while (true)
	{
		hr = g_pImport->EnumEvents(
			scope, 
			&henum, 
			td, 
			&event, 
			1, 
			&cEvent);
		if (FAILED(hr))
			goto ErrExit;

		if (cEvent == 0)
			break;
		hr = g_pImport->GetEventProps(	// S_OK, S_FALSE, or error.
			scope,						// [IN] The scope.
			event,		                // [IN] event token
			&classdef,					// [OUT] typedef containing the event declarion.
			wzEvent,					// [OUT] Event name
			128,						// [IN] the count of wchar of szEvent
			&cbEvent,					// [OUT] actual count of wchar for event's name
			&dwEventFlags,				// [OUT] Event flags.
			&tkEventType,				// [OUT] EventType class
			&mdOther[0],				// [OUT] AddOn method of the event
			&mdOther[1],				// [OUT] RemoveOn method of the event
			&mdOther[2],				// [OUT] Fire method of the event
			&mdOther[3],				// [OUT] other method of the event
			NumItems(mdOther) - 3,	    // [IN] size of rmdOtherMethod
			&cOtherMethod);				// [OUT] total number of other method of this event
		if (FAILED(hr))
			goto ErrExit;

		_ASSERTE(classdef == td);
		printf("\tEVENT %ls \n", wzEvent);
		printf("\t\tEVENT FLAG - ");
		if (dwEventFlags & evPublic)
			printf("Public, ");
		if (dwEventFlags & evPrivate)
			printf("Private, ");
		if (dwEventFlags & evProtected)
			printf("Protected, ");
		printf("\n");

		// print out event type
		if (tkEventType != mdTokenNil)
		{
			printf("\t\tEVENTTYPE : ");
			DumpClassName(g_pImport, scope, tkEventType);
			printf("\n");
		}

		for (k = 0 ; k < cOtherMethod + 3; k ++)
		{
			if (mdOther[k] != mdMethodDefNil)
			{					
				if (k == 0)
					printf("\t\tAddOn method is : ");
				else if (k == 1)
					printf("\t\tRemoveOn method is : ");
				else if (k == 2)
					printf("\t\tFire method is : ");
				else 
					printf("\t\tOther method is : ");					
				DumpMethodName(g_pImport, scope, mdOther[k]);
				printf("\n");
			}
		}
	}


	// fall through
ErrExit:
	if (henum)
		g_pImport->CloseEnum(scope, henum);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cordump\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "CORDUMP.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM dumper\0"
#define VER_ORIGFILENAME_STR    "cordump.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cormerge\cormerge.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File: CORMERGE.CPP
//	All Rights Reserved.
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////
// Simple implementation of IMemory.
///////////////////////
#include <stdio.h>
#include <windows.h>
#include <objbase.h>

#include "CorError.h" // for errors
#include "__file__.ver"
#include "corver.h"

#define _META_DATA_NO_SCOPE_
#define INIT_GUID
#include <initguid.h>
#include "cor.h"
#ifndef _IMD_DEFINED
#if !defined(COMPLUS98)
IMetaDataEmit *g_pEmit = NULL ;
IMetaDataImport *g_pImport = NULL;
#else	/* COMPLUS98 */
IMetaDataRegEmit *g_pEmit = NULL ;
IMetaDataRegImport *g_pImport = NULL;
#endif	/* COMPLUS98 */
#define _IMD_DEFINED
#endif	/* _IMD_DEFINED */
IMetaDataDispenser *g_pDisp = NULL;

// Forward declaration.
void Error(HRESULT hr, char* szError, bool printHR = true);

///////////////////////////////////////////////////////////////////////////
// Simple implementation of a stream.
///////////////////////////////////////////////////////////////////////////
class CStream : public IStream
{
public:
	CStream() :
		m_fh(INVALID_HANDLE_VALUE)
	{
	}

	STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppv)
	{
		if (riid == IID_IStream || riid == IID_IUnknown)
			*ppv = this;
		else
			return (E_NOINTERFACE);
		((IUnknown *) *ppv)->AddRef();
		return (S_OK);
	}
	STDMETHOD_(ULONG,AddRef)()
	{
		return (1);
	}
	STDMETHOD_(ULONG,Release)()
	{
		return (1);
	}


	HRESULT InitWithHandle(HANDLE fh)
	{
		m_fh = fh;
		return S_OK;
	}

// IStream

	STDMETHOD(Write)(
		const void	*pv,
		ULONG		cb,
		ULONG		*pcbWritten)
	{
//		_ASSERTE(m_fh != INVALID_HANDLE_VALUE);

		if (!WriteFile(m_fh, pv, cb, pcbWritten, NULL))
			return (E_FAIL);
		return (S_OK);
	}

	// We actually only use this to find the current stream offset, not to move
	// the pointer around.  LARGE_INTEGER is overkill here, but what the heck.
	STDMETHOD(Seek)(
		LARGE_INTEGER dlibMove,
		DWORD		dwOrigin,
		ULARGE_INTEGER *plibNewPosition)
	{
//		_ASSERTE(m_fh != INVALID_HANDLE_VALUE);

		plibNewPosition->HighPart = dlibMove.HighPart;
		plibNewPosition->LowPart = SetFilePointer(m_fh, dlibMove.LowPart,
										(PLONG) &plibNewPosition->HighPart, dwOrigin);

		if (plibNewPosition->LowPart == 0xffffffff &&
			GetLastError() != NO_ERROR)
			return (E_FAIL);
		return (S_OK);
	}


// Unimplemented IStream functions...

	STDMETHOD(Read)(
		void		*pv,
		ULONG		cb,
		ULONG		*pcbRead)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(SetSize)(
		ULARGE_INTEGER libNewSize)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(CopyTo)(
		IStream		*pstm,
		ULARGE_INTEGER cb,
		ULARGE_INTEGER *pcbRead,
		ULARGE_INTEGER *pcbWritten)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(Commit)(
		DWORD		grfCommitFlags)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(Revert)()
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(LockRegion)(
		ULARGE_INTEGER libOffset,
		ULARGE_INTEGER cb,
		DWORD		dwLockType)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(UnlockRegion)(
		ULARGE_INTEGER libOffset,
		ULARGE_INTEGER cb,
		DWORD		dwLockType)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(Stat)(
		STATSTG		*pstatstg,
		DWORD		grfStatFlag)
	{
		return (E_NOTIMPL);
	}

	STDMETHOD(Clone)(
		IStream		**ppstm)
	{
		return (E_NOTIMPL);
	}

private:
	HANDLE m_fh;
};


///////////////////////////////////////////////////////////////////////////
// Simple implementation of a stream.
///////////////////////////////////////////////////////////////////////////
class CMapToken : public IMapToken
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv)
	{
		if (riid == IID_IMapToken || riid == IID_IUnknown)
			*ppv = this;
		else
			return (E_NOINTERFACE);
		((IUnknown *) *ppv)->AddRef();
		return (S_OK);
	}
	STDMETHODIMP_(ULONG) AddRef()
	{
		return (1);
	}
	STDMETHODIMP_(ULONG) Release()
	{
		return (1);
	}

	STDMETHODIMP Map(mdToken tkImp, mdToken tkEmit)
	{
		return (S_OK);
	}
};


#define CaseErrorPrintName(ERRNAME) \
{ case ERRNAME: { printf(#ERRNAME"\n"); break; } }


///////////////////////////////////////////////////////////////////////////
// Simple implementation of an error handler.
///////////////////////////////////////////////////////////////////////////
class CMetaDataError : public IMetaDataError
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv)
	{
		*ppv = 0;
		if (riid == IID_IMetaDataError || riid == IID_IUnknown)
			*ppv = this;
		else
			return (E_NOINTERFACE);
		((IUnknown *) *ppv)->AddRef();
		return (S_OK);
	}
	STDMETHODIMP_(ULONG) AddRef()
	{
		return (1);
	}
	STDMETHODIMP_(ULONG) Release()
	{
		return (1);
	}

	STDMETHODIMP OnError(HRESULT hr, mdToken inToken)
	{
		printf("Merge: error 0x%8.8X occurred: ", hr);
		switch(hr)
		{
			// these errors all return a nil token
			CaseErrorPrintName(META_E_DUPLICATE)
			CaseErrorPrintName(META_E_GUID_REQUIRED)
			CaseErrorPrintName(META_E_TYPEDEF_MISMATCH)
			CaseErrorPrintName(META_E_MERGE_COLLISION)
			CaseErrorPrintName(META_E_MD_INCONSISTENCY)
			CaseErrorPrintName(META_E_CLASS_LAYOUT_INCONSISTENT)
			CaseErrorPrintName(META_E_METHODSEM_NOT_FOUND)

			// these errors all return a token
			CaseErrorPrintName(META_E_METHD_NOT_FOUND)
			CaseErrorPrintName(META_E_FIELD_NOT_FOUND)
			CaseErrorPrintName(META_S_PARAM_MISMATCH)
			CaseErrorPrintName(META_E_INTFCEIMPL_NOT_FOUND)
			CaseErrorPrintName(META_E_FIELD_MARSHAL_NOT_FOUND)
			CaseErrorPrintName(META_E_EVENT_NOT_FOUND)
			CaseErrorPrintName(META_E_PROP_NOT_FOUND)
		}
		if (inToken)
			printf("\t -- while processing token (0x%8.8X)\n",inToken);

		// S_OK tells Merge() to keep going -- error is continuable
		return (S_OK);
	}
};


///////////////////////////////////////////////////////////////////////////////
// Extract extended error information if there is any.
//
void DumpCOMErrors(
	HRESULT		hrErr)					// The error code recieved.
{
	IErrorInfo	*pIErr = NULL;			// Error interface.
	BSTR		bstrDesc = NULL;		// Description text.

	// Try to get an error info object and display the message.
	if (GetErrorInfo(0, &pIErr) == S_OK &&
		pIErr->GetDescription(&bstrDesc) == S_OK)
	{
		printf("COM Error: %S\n", bstrDesc);
		SysFreeString(bstrDesc);
	}

	// Free the error interface.
	if (pIErr)
		pIErr->Release();
}

///////////////////////////////////////////////////////////////////////////
// Error() function -- prints an error and returns
void Error(HRESULT hr, char* szError, bool printHR)
{
	if (printHR)
	{
		printf("\n%s (hr = 0x%08x)\n", szError, hr);
		DumpCOMErrors(hr);
	}
	else
		printf("\n%s\n", szError);
	if (g_pEmit)
		g_pEmit->Release();
	if (g_pDisp)
		g_pDisp->Release();
	CoUninitializeCor();
	exit(1);
}


/////////////////////////////////////////////////////////////////////////
// main() function
//
//
int _cdecl main(int argc, char** argv)
{
	int         arg;
	CMapToken   sMap;
    DWORD       dwSaveSize;

#if defined(COMPLUS98)
	printf("*** CORMERGE Compiled For COM+ '98 ***\n");
#endif
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr)) {
        printf("Error: %s when initializing COM runtime.\n", hr);
        exit(-1);
    }
	CoInitializeCor(0);

	/////////////////////////////////////////////////////////////////////////
	// Print copyright message
	printf("\nMicrosoft (R) Common Language Runtime MetaData Merge Utility. Version %s", VER_FILEVERSION_STR);
	printf("\n%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);

	/////////////////////////////////////////////////////////////////////////
	// Validate incoming arguments
	if ((argc <2) || (lstrcmpi(argv[1], "/?") == 0) || (lstrcmpi(argv[1], "-?") == 0))
	    Error(E_INVALIDARG, "Usage -- CORMERGE <filename or file patten>", false);


	/////////////////////////////////////////////////////////////////////////
	// Load the COR object
	hr = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, 
			      IID_IMetaDataDispenser, (void **) &g_pDisp);
	if (FAILED(hr)) Error(hr, "Failed to get dispenser object");

	hr = g_pDisp->DefineScope(CLSID_CorMetaDataRuntime, 
				0, IID_IMetaDataEmit,
				(IUnknown **) &g_pEmit);
	if (FAILED(hr)) Error(hr, "Failed to define a scope");

	CMetaDataError mergeErrHandler;
	g_pEmit->SetHandler((IUnknown *)&mergeErrHandler);

	for (arg=1; arg < argc; ++arg)
	{
		// Loop through all files in the file pattern passed
		WIN32_FIND_DATA fdFiles;
		HANDLE hFind ;
		char szSpec[_MAX_PATH];
		WCHAR wszSpec[_MAX_PATH];
		char szDrive[_MAX_DRIVE];
		char szDir[_MAX_DIR];
		hFind = FindFirstFile(argv[arg], &fdFiles);
		if(hFind == INVALID_HANDLE_VALUE)
		{
			FindClose(hFind);
			Error(E_FAIL, "Failed to find requested files");
		}
		// Map views of all of the files.
		_fullpath(szSpec, argv[arg], sizeof(szSpec));
		_splitpath(szSpec, szDrive, szDir, NULL, NULL);
		do
		{
			_makepath(szSpec, szDrive, szDir, fdFiles.cFileName, NULL);

			// Open the file to be merged.
			MultiByteToWideChar(CP_ACP, 0, szSpec, -1, wszSpec, _MAX_PATH);
			hr = g_pDisp->OpenScope(wszSpec, cssAccurate, IID_IMetaDataImport,
					      (IUnknown**) &g_pImport);
			if (FAILED(hr)) Error(hr, "Failed to open scope");

			// Merge the meta-data.
			hr = g_pEmit->Merge(g_pImport, &sMap, &mergeErrHandler);
			if (FAILED(hr)) Error(hr, "Merge failed");

			// Done with this import.
			g_pImport->Release();
			g_pImport = 0;

		} while(FindNextFile(hFind,&fdFiles)) ;

        hr = g_pEmit->MergeEnd();
    	if (FAILED(hr)) Error(hr, "MergeEndEx failed");
		FindClose(hFind);
	}

	// Save the stream.
	hr = g_pEmit->GetSaveSize(cssAccurate, &dwSaveSize);
	if (FAILED(hr)) Error(hr, "Failed to GetSaveSize");

    hr = g_pEmit->Save(L"merge.clb", 0);
    if (FAILED(hr)) Error(hr, "Failed to save merged meta-data");

	// Release the scope.
	g_pEmit->Release();
	g_pDisp->Release();

	// All done.
	CoUninitializeCor();
	CoUninitialize();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\cormerge\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "COMREG.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM+ registration tool\0"
#define VER_ORIGFILENAME_STR    "comreg.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\pchcpp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\corattr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  File:       CorAttr.h
//
//
//----------------------------------------------------------------------------

#ifndef _COR_ATTR_DLL_H
#define _COR_ATTR_DLL_H



#ifdef __cplusplus
extern "C" {
#endif

//+-----------------------------------------------------------------------
//  
//  InitAttr:
//
//      This function should be called as the first call to the dll.
//
//      The dll has to use the input memory allocation and free routine
//      to allocate and free all memories, including internal use.
//      It has to handle when pInitString==NULL.
//
//------------------------------------------------------------------------

HRESULT WINAPI  
InitAttr(LPWSTR         pInitString); //IN: the init string
    
 //+-----------------------------------------------------------------------
//  
//  GetAttrs:
//
//
//      Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttr(PCRYPT_ATTRIBUTES  *ppsAuthenticated,       // OUT: Authenticated attributes added to signature
        PCRYPT_ATTRIBUTES  *ppsUnauthenticated);    // OUT: Uunauthenticated attributes added to signature
    

//+-----------------------------------------------------------------------
//  
//  ReleaseAttrs:
//
//
//      Release authenticated and unauthenticated attributes
//      returned from GetAttr(). 
//
//      psAuthenticated and psUnauthenticated should never be NULL.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
ReleaseAttr(PCRYPT_ATTRIBUTES  psAuthenticated,     // OUT: Authenticated attributes to be released
            PCRYPT_ATTRIBUTES  psUnauthenticated);  // OUT: Uunauthenticated attributes to be released
    

//+-----------------------------------------------------------------------
//  
//  ExitAttr:
//
//      This function should be called as the last call to the dll
//------------------------------------------------------------------------
HRESULT WINAPI
ExitAttr( );    


#ifdef __cplusplus
}
#endif

#endif  //#define _COR_ATTR_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\correg\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "CORREG.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM registration utility\0"
#define VER_ORIGFILENAME_STR    "correg.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\correg\correg.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File: CORREG.CPP
//	All Rights Reserved. 
//
//  Notes: Command line utility used for registration of COR classes
//---------------------------------------------------------------------------
#include <stdio.h>
#include <windows.h>
#include <objbase.h>

#define INIT_GUID
#include <initguid.h>

#include "cor.h"

///////////////////////////////////////////////////////////////////////////
// Function prototypes

///////////////////////////////////////////////////////////////////////////
// Global variables.
ICorRegistration *g_pReg= NULL ;

///////////////////////////////////////////////////////////////////////////
// Error() function -- prints an error and returns
void Error(char* szError)
{
	if(g_pReg)
		g_pReg->Release();

	printf("\n%s\n", szError);
	exit(1);
}

/////////////////////////////////////////////////////////////////////////
// Supported commands
enum Commands
{
	HELP, INSTALL, UNINSTALL, MODULEDUMP, CLASSDUMPCLSID, CLASSDUMPCVID, 
	CLASSDUMP,	FINDCLASS};

typedef struct
{
	char cCommand;
	int nMinArgs;
	Commands nCommand;

} CommandInfo;

CommandInfo g_commands[] = 
{
	{ 'i', 3, INSTALL }, { 'u', 3, UNINSTALL } , { 'm', 2, MODULEDUMP },
	{ 'c', 2, CLASSDUMPCLSID } , { 'v', 2, CLASSDUMPCVID }, 
	{ 'd', 2, CLASSDUMP}, { 'f', 3, FINDCLASS }};

#define NUM_COMMANDS (sizeof(g_commands) / sizeof(g_commands[0]))

/////////////////////////////////////////////////////////////////////////
// ParseCommand() -- Parses the command line 
int ParseCommand(int argc, char* argv[])
{
	int i;
	if(argc <2) 
		return HELP;

	if(argv[1][0] != '-' && argv[1][0] != '/')
		return HELP;

	for(i=0; i<NUM_COMMANDS; i++)
	{
		if(argv[1][1]==g_commands[i].cCommand)
		{
			if(argc < g_commands[i].nMinArgs)
				return HELP;

			return g_commands[i].nCommand;
		}
	}
	return HELP;
}

/////////////////////////////////////////////////////////////////////////
// PrintGUID
void PrintGUID(GUID guid)
{
	WCHAR szGuid[42];
	StringFromGUID2(guid, szGuid, 42);
	wprintf(L"%s", szGuid);
}

/////////////////////////////////////////////////////////////////////////
// main() function
// 
//
int _cdecl main(int argc, char** argv)
{
	int cmd ;
	
	/////////////////////////////////////////////////////////////////////////
	// Print copyright message
   printf("Microsoft (R) Component Object Runtime Registration Version 0.5\n"
		"Copyright (C) Microsoft Corp 1992-1997. All rights reserved.\n");
	
	/////////////////////////////////////////////////////////////////////////
	// Load the COR object 
	HRESULT hr = CoGetCor(IID_ICorRegistration, (void**) &g_pReg) ;
	if(FAILED(hr)) Error("Failed to load component object runtime");

	/////////////////////////////////////////////////////////////////////////
	// Validate incoming arguments
	cmd = ParseCommand(argc, argv);

	switch(cmd)
	{
		//////////////////////////////////////////////////////////////////////////
		// Show help message
		case	HELP:
				Error("CORREG -i <files> [<no copy>]   --   Install module\n"\
					  "CORREG -u <mid>                 --   Uninstall module\n"\
					  "CORREG -m                       --   List modules\n"\
					  "CORREG -d [<namespace>]         --   Dump class information\n"\
					  "CORREG -c [<namespace>]         --   Dump class id information\n"\
					  "CORREG -v [<namespace>]         --   Dump class version information\n"\
					  "CORREG -f <url>                 --   Find class by URL\n");


		//////////////////////////////////////////////////////////////////////////
		// Install COR package
		case	INSTALL:
			{
				////////////////////////////////////////////////////////////////////////
				// Loop through all files in the file pattern passed 
				WIN32_FIND_DATA fdFiles;
				HANDLE hFind ;
				char szSpec[_MAX_PATH];
				char szDrive[_MAX_DRIVE];
				char szDir[_MAX_DIR];
				int fNoCopy=0 ;

				if(argc == 4)	// We have a copy flag
				{
					fNoCopy = atoi(argv[3]);
				}

				hFind = FindFirstFile(argv[2],&fdFiles);
				if(hFind == INVALID_HANDLE_VALUE)
					Error("Failed to find requested files");

				_fullpath(szSpec, argv[2], sizeof(szSpec));
				_splitpath(szSpec, szDrive, szDir, NULL, NULL);
				do
				{
					_makepath(szSpec, szDrive, szDir, fdFiles.cFileName, NULL);

					/////////////////////////////////////////////////////////////////
					// Register the file
					MID mid ;
					WCHAR szSpecW[MAX_PATH];
					mbstowcs(szSpecW,szSpec,MAX_PATH);
					hr = g_pReg->Install(szSpecW, (fNoCopy) ? regNoCopy : 0);

					if(FAILED(hr)) Error("Failed to register package");
					printf("\nSuccessfully registered %s\n", argv[2]);

				} while(FindNextFile(hFind,&fdFiles)) ;
				FindClose(hFind);
			}
			break;

		//////////////////////////////////////////////////////////////////////////
		// Remove cor package
		case	UNINSTALL:
			{
				MID mid = atoi(argv[2]);
				hr = g_pReg->Uninstall(mid);
				if(FAILED(hr)) Error("Failed to uninstall package");
				printf("\nSuccessfully removed package\n");
			}
			break;
		//////////////////////////////////////////////////////////////////////////
		// Dump cor package
		case	MODULEDUMP:
			{
				RegModuleEnumInfo rgMod[10];
				HCORENUM hModules= NULL;
				unsigned int cModules= sizeof(rgMod) / sizeof(rgMod[0]) ;
				unsigned int i ;

				// Enumerate all package
				wprintf(L"\nID   Name                 Module\n");
				wprintf(L"==============================================================\n");
				while (SUCCEEDED(hr = g_pReg->EnumModules(&hModules, rgMod,
						sizeof(rgMod)/sizeof(rgMod[0]), &cModules)) && cModules> 0)
				{

					///////////////////////////////////////////////////////////////////
					// Print package information
					for (i=0; i < cModules; ++i)
					{
						wprintf(L"%-4d %-20s %-30s\n", rgMod[i].mid, rgMod[i].Name, rgMod[i].Module);
					}

					if(cModules < sizeof(rgMod)/sizeof(rgMod[0]))
						break;
				}
				//@todo: We need an error message.
				g_pReg->CloseRegEnum(hModules);
			}
			break;
		//////////////////////////////////////////////////////////////////////////
		// Dump cor classes
		case	CLASSDUMP:
		case	CLASSDUMPCVID:
		case	CLASSDUMPCLSID:
			{
				RegClassEnumInfo rgClass[10];
				WCHAR szNamespace[MAX_PATH];
				WCHAR szFullClassName[MAX_PATH+MAX_CLASS_NAME];
				WCHAR szModule[MAX_PATH];
				HCORENUM hClasses = NULL;
				unsigned int cClasses= sizeof(rgClass) / sizeof(rgClass[0]) ;
				unsigned int i ;
				LPWSTR pszNamespace=NULL;
				CVStruct *pver;

				if(argc > 2)
				{
					mbstowcs(szNamespace, argv[2], 255);
					pszNamespace = szNamespace;
				}

				/////////////////////////////////////////////////////////////////////////////////
				// Print class information
				if(cmd== CLASSDUMP)
					wprintf(L"\nName                 Version\tModule\n");
				else if(cmd==CLASSDUMPCLSID)
					wprintf(L"\nName                 Version\tCLSID\n");
				else
					wprintf(L"\nName                 Version\tCVID\n");

				wprintf(L"======================================================================\n");
				// Enumerate all package
				while (SUCCEEDED(hr = g_pReg->EnumClasses(pszNamespace, 0, &hClasses, rgClass,
						sizeof(rgClass)/sizeof(rgClass[0]), &cClasses)) && cClasses> 0)
				{

					for (i=0; i < cClasses; ++i)
					{
						szNamespace[0] = '\0';
						g_pReg->GetNamespaceInfo(rgClass[i].Namespace, szNamespace,sizeof(szNamespace));
						g_pReg->GetModuleInfo(rgClass[i].Module, szModule, sizeof(szModule));
						if(*szNamespace)
							swprintf(szFullClassName, L"%s.%s", szNamespace, rgClass[i].Name);
						else
							wcscpy(szFullClassName,rgClass[i].Name);
						
						pver = (CVStruct*) &rgClass[i].Version;

						wprintf(L"%-20s %d.%d.%d.%d\t", szFullClassName, 
								pver->Major,pver->Minor, pver->Sub, pver->Build);

						if(cmd==CLASSDUMP)
							wprintf(L"%20s", szModule);
						else if(cmd == CLASSDUMPCLSID)
						{
							PrintGUID(rgClass[i].Clsid);
						}
						else
						{
							PrintGUID(rgClass[i].Cvid);
						}
						wprintf(L"\n");
					}

					if(cClasses < sizeof(rgClass)/sizeof(rgClass[0]))
						break;
				}
				//@todo: We need an error message.
				g_pReg->CloseRegEnum(hClasses);
			}
			break;

		case	FINDCLASS:
			{
				WCHAR szUrl[MAX_PATH];
				WCHAR szModule[MAX_PATH];
				STGMEDIUM	sStgModule;
				HRESULT		hr;

				sStgModule.tymed = TYMED_FILE;
				sStgModule.lpszFileName = szModule;
				sStgModule.pUnkForRelease = 0;

				mbstowcs(szUrl, argv[2], MAX_PATH);

				hr = g_pReg->GetModule(szUrl, &sStgModule, MAX_PATH);
				if (sStgModule.tymed == TYMED_ISTREAM)
					sStgModule.pstm->Release();
				if(FAILED(hr))
				{
					Error("Class not found");
				}
				else
				{
					wprintf(L"\nClass found at: %s\n", szModule);
				}

			}
			break;

	}

	g_pReg->Release();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\corsign.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"

#include <stdio.h>
#include <regstr.h>
#include <wintrust.h>

#include "corattr.h"
#include "CorPermE.h"
#include "cor.h"

#define FILE_NAME_BUFSIZ  _MAX_PATH

CRITICAL_SECTION    g_crsNameLock;
BOOL                g_fLockAcquired = FALSE;
LPWSTR              g_wszFileName   = NULL;
WCHAR               g_wszFileNameBuf[FILE_NAME_BUFSIZ];

CRYPT_ATTRIBUTES    g_cryptDummyAttribs;

//
// Entry point for interpretting command arguments and
// preparation for decoding.
//
HRESULT WINAPI InitAttr(LPWSTR pInitString) 
{
    
    // Save the argument string for use in GetAttr.
    if(pInitString != NULL)
    {
        EnterCriticalSection(&g_crsNameLock);
        
        // Set the length of the name
        int iFileNameSize = wcslen(pInitString);
        int iSize = (iFileNameSize + 1) * sizeof(WCHAR);
        
        if (iSize > sizeof(g_wszFileNameBuf))
        {
            g_wszFileName = (LPWSTR) MallocM(iSize);
            if(g_wszFileName == NULL)
            {
                LeaveCriticalSection(&g_crsNameLock);
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            g_wszFileName = g_wszFileNameBuf;
        }
        
        // Copy it into our space.
        memcpy(g_wszFileName, pInitString, iSize);
        
        g_fLockAcquired = TRUE;
    }
    
    return S_OK;
}


//
// Entry point for retrieving the attributes given
// the parameters specified in the call to InitAttr.
//
HRESULT WINAPI GetAttr(PCRYPT_ATTRIBUTES  *ppsAuthenticated,        
                       PCRYPT_ATTRIBUTES  *ppsUnauthenticated)
{
    
    HRESULT             hr = S_OK;
    BYTE                *pbEncoded = NULL;
    DWORD               cbEncoded = 0;
    PCRYPT_ATTRIBUTES   pAttribs = NULL;
    DWORD               dwAttribute = 0;
    DWORD               cAttributes = 0;
    PCRYPT_ATTRIBUTE    pAttr = NULL;
    DWORD               dwEncodingType = CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING;
            
             
    
    // Set the return values 
    *ppsAuthenticated = NULL;
    *ppsUnauthenticated = NULL;
    
    if(g_wszFileName == NULL)
        return E_UNEXPECTED;

    CORTRY {
        // Call into the EE to get the pb/cb for the ASN
        // encoding of the permission set defined in the
        // ini file.
        hr = EncodePermissionSetFromFile(g_wszFileName,
                                         L"XMLASCII",
                                         &pbEncoded,
                                         &cbEncoded);
        
        if (FAILED(hr))
            CORTHROW(hr);
        
        // If we got an encoding, see how big the
        // attribute needs to be to store the encoding.
        if (cbEncoded > 0)
        {
            _ASSERTE(pbEncoded != NULL);
            
            // Call to get required size of attribute structure.
            CryptDecodeObject(dwEncodingType,
                              PKCS_ATTRIBUTE,
                              pbEncoded,
                              cbEncoded,
                              0,
                              pAttr,
                              &dwAttribute);
            
            if(dwAttribute == 0)
                CORTHROW(Win32Error());
        }
            
        // Allocate a fixed block of mem large enough to hold a single
        // CRYPT_ATTRIBUTES entry, and the required size of the CRYPT_ATTRIBUTE.
        // (If there's no encoding, then dwAttribute == 0, so we just allocate
        // space for the CRYPT_ATTRIBUTES structure.
        pAttribs = (PCRYPT_ATTRIBUTES) MallocM(dwAttribute + sizeof(CRYPT_ATTRIBUTES));
        if(pAttribs == NULL)
            CORTHROW(E_OUTOFMEMORY);
        
        // If we got an encoding, decode it into the attribute structure.
        if (cbEncoded > 0)
        {
            cAttributes = 1;
            pAttr = (PCRYPT_ATTRIBUTE) (((BYTE*)pAttribs) + sizeof(CRYPT_ATTRIBUTES));
        
            // Decode attribute structure.
            if(!CryptDecodeObject(dwEncodingType,
                                  PKCS_ATTRIBUTE,
                                  pbEncoded,
                                  cbEncoded,
                                  0,
                                  pAttr,
                                  &dwAttribute))
                CORTHROW(Win32Error());
        }
        
        // Set up the authenticated attributes structure.
        pAttribs->cAttr = cAttributes;
        pAttribs->rgAttr = pAttr;
        
        // Set up the dummy unauth structure.
        g_cryptDummyAttribs.cAttr = 0;
        g_cryptDummyAttribs.rgAttr = NULL;
        
        // Set the return value.
        *ppsAuthenticated = pAttribs;
        *ppsUnauthenticated = &g_cryptDummyAttribs;
            
    } CORCATCH(err) {
        hr = err.corError;
        if (pAttribs != NULL)
            FreeM(pAttribs);
    } COREND;

    if (pbEncoded != NULL)
        FreeM(pbEncoded);

    return hr; 
}


//
// Entry point to release memory created in the
// call to GetAttr.
//
HRESULT  WINAPI
ReleaseAttr(PCRYPT_ATTRIBUTES  psAuthenticated,     
            PCRYPT_ATTRIBUTES  psUnauthenticated)
{
    // Free attribute buffer.
    if(psAuthenticated != NULL)
        FreeM(psAuthenticated);
    
    _ASSERTE(psUnauthenticated == NULL ||
             psUnauthenticated == &g_cryptDummyAttribs);
    
    return S_OK;
}



//
// Entry point to release memory created by
// the initialization in InitAttr.
//
HRESULT WINAPI ExitAttr( )
{
    if(g_fLockAcquired)
    {
        if(g_wszFileName != g_wszFileNameBuf && g_wszFileName != NULL)
            FreeM(g_wszFileName);
        
        g_fLockAcquired = FALSE;
        LeaveCriticalSection(&g_crsNameLock);
    }
    
    return S_OK;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\dllmain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"

#include <stdio.h>
#include <regstr.h>
#include <wintrust.h>

extern CRITICAL_SECTION g_crsNameLock;

STDAPI DllRegisterServer ( void )
{
    HRESULT hr = S_OK;
   
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer ( void )
{
    return S_OK;
}

STDAPI DllCanUnloadNow(void)
{
    return S_OK;
}


BOOL WINAPI DllMain(HMODULE hInstDLL,
                    DWORD   dwReason,
                    LPVOID  lpvReserved)
{

    HRESULT hr = S_OK;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstDLL);
        InitializeCriticalSection(&g_crsNameLock);
        break;
    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&g_crsNameLock);
        break;
    default:
        break;
    }
    return (hr == S_OK ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "CORSIGN.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Security module\0"
#define VER_ORIGFILENAME_STR    "corsign.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>

#include <crtdbg.h>                     // _ASSERTE macros.
#include <malloc.h>                     // _alloca
#include "CorPermP.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corver\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\binstr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* a binary string (blob) class */

#ifndef BINSTR_H
#define BINSTR_H

#include <string.h>			// for memmove, memcpy ... 

class BinStr {
public:
	BinStr()  { 
		len = 0L; max = 8L; ptr_ = buff; 
		}
	~BinStr() { 
		if (ptr_ != buff) delete [] ptr_; 
		}

	void insertInt8(int val) { if (len >= max) realloc(); memmove(ptr_+1, ptr_, len); *ptr_ = val; len++; }
	void appendInt8(int val) { if (len >= max) realloc(); ptr_[len++] = val; }
	void appendInt16(int val) { if (len + 2 > max) realloc(); *((short*) &ptr_[len]) = val; len += 2; }
	void appendInt32(int val) { if (len + 4 > max) realloc(); *((int*) &ptr_[len]) = val; len += 4; }
	void appendInt64(__int64 *pval) { if (len + 8 > max) realloc(); memcpy(&ptr_[len],pval,8); len += 8; }
	unsigned __int8* getBuff(unsigned size) { 
		if (len + size > max) realloc(size); 
		_ASSERTE(len + size <= max);
		unsigned __int8* ret = &ptr_[len]; 
		len += size; 
		return(ret);
		}
    void append(BinStr* str) {
       memcpy(getBuff(str->length()), str->ptr(), str->length());
       }
	void appendStr(char* str) {
		if(str && *str) memcpy(getBuff(strlen(str)),str,strlen(str));
	}

	void remove(unsigned size) { _ASSERTE(len >= size); len -= size; }
	
	unsigned __int8* ptr() 		{ return(ptr_); }
	unsigned length() 	{ return(len); }
	
private:
	void realloc(unsigned atLeast = 4) {
		max = max * 2;
		if (max < atLeast + len)
			max = atLeast + len;
		_ASSERTE(max >= len + atLeast);
		unsigned __int8* newPtr = new unsigned __int8[max];
		memcpy(newPtr, ptr_, len);
		if (ptr_ != buff) delete [] ptr_; 
		ptr_ = newPtr;
		}
	
private:
	unsigned  len;
	unsigned  max;
	unsigned __int8 *ptr_;
	unsigned __int8 buff[8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corsign\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// 
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\dparse.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* hParse is basically a wrapper around a YACC grammar H to COM+ IL converter  */

#ifndef hparse_h
#define hparse_h

#include "cor.h"        // for CorMethodAttr ...
#include <crtdbg.h>     // For _ASSERTE
#include <corsym.h>

#include <stdio.h>      // for FILE
#include <stdlib.h>
#include <assert.h>
#include "UtilCode.h"
#include "DebugMacros.h"
#include "corpriv.h"
#include <sighelper.h>
//#include "asmparse.h"
#include "binstr.h"

#define MAX_FILENAME_LENGTH         512     //256

/**************************************************************************/
/* an abstraction of a stream of input characters */
class ReadStream {
public:
        // read at most 'buffLen' bytes into 'buff', Return the
        // number of characters read.  On EOF return 0
    virtual unsigned read(char* buff, unsigned buffLen) = 0;
        
        // Return the name of the stream, (for error reporting).  
    virtual const char* name() = 0;
        //return ptr to buffer containing specified source line
    virtual char* getLine(int lineNum) = 0;
};

/**************************************************************************/
class FileReadStream : public ReadStream {
public:
    FileReadStream(char* aFileName) 
    {
        fileName = aFileName;
        file = fopen(fileName, "rb"); 
    }

    unsigned read(char* buff, unsigned buffLen) 
    {
        _ASSERTE(file != NULL);
        return(fread(buff, 1, buffLen, file));
    }

    const char* name() 
    { 
        return(fileName); 
    }

    BOOL IsValid()
    {
        return(file != NULL); 
    }
    
    char* getLine(int lineNum)
    {
        char* buf = new char[65535];
        FILE* F;
        F = fopen(fileName,"rt");
        for(int i=0; i<lineNum; i++) fgets(buf,65535,F);
        fclose(F);
        return buf;
    }

private:
    const char* fileName;       // FileName (for error reporting)
    FILE* file;                 // File we are reading from
};

/************************************************************************/
/* represents an object that knows how to report errors back to the user */

class ErrorReporter 
{
public:
    virtual void error(char* fmt, ...) = 0; 
    virtual void warn(char* fmt, ...) = 0; 
};
/*****************************************************************************/
/* LIFO (stack) and FIFO (queue) templates (must precede #include "method.h")*/
template <class T>
class LIST_EL
{
public:
    T*  m_Ptr;
    LIST_EL <T> *m_Next;
    LIST_EL(T *item) {m_Next = NULL; m_Ptr = item; };
};
    
template <class T>
class LIFO
{
public:
    inline LIFO() { m_pHead = NULL; };
    inline ~LIFO() {T *val; while(val = POP()) delete val; };
    void PUSH(T *item) 
    {
        m_pTemp = new LIST_EL <T>(item); 
        m_pTemp->m_Next = m_pHead; 
        m_pHead = m_pTemp;
    };
    T* POP() 
    {
        T* ret = NULL;
        if(m_pTemp = m_pHead)
        {
            m_pHead = m_pHead->m_Next;
            ret = m_pTemp->m_Ptr;
            delete m_pTemp;
        }
        return ret;
    };
private:
    LIST_EL <T> *m_pHead;
    LIST_EL <T> *m_pTemp;
};
template <class T>
class FIFO
{
public:
    FIFO() { m_Arr = NULL; m_ulArrLen = 0; m_ulCount = 0; m_ulOffset = 0; };
    ~FIFO() {
        if(m_Arr) {
            for(ULONG i=0; i < m_ulCount; i++) {
                if(m_Arr[i+m_ulOffset]) delete m_Arr[i+m_ulOffset];
            }
            delete m_Arr;
        }
    };
    void PUSH(T *item) 
    {
        if(m_ulCount+m_ulOffset >= m_ulArrLen)
        {
            if(m_ulOffset)
            {
                memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                m_ulOffset = 0;
            }
            else
            {
                m_ulArrLen += 1024;
                T** tmp = new T*[m_ulArrLen];
                if(m_Arr)
                {
                    memcpy(tmp,m_Arr,m_ulCount*sizeof(T*));
                    delete m_Arr;
                }
                m_Arr = tmp;
            }
        }
        m_Arr[m_ulOffset+m_ulCount] = item;
        m_ulCount++;
    };
    ULONG COUNT() { return m_ulCount; };
    T* POP() 
    {
        T* ret = NULL;
        if(m_ulCount)
        {
            ret = m_Arr[m_ulOffset++];
            m_ulCount--;
            if(m_ulOffset >= 1024)
            {
                memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                m_ulOffset = 0;
            }
        }
        return ret;
    };
    T* PEEK(ULONG idx)
    {
        T* ret = NULL;
        if(idx < m_ulCount) ret = m_Arr[m_ulOffset+idx];
        return ret;
    };
private:
    T** m_Arr;
    ULONG       m_ulCount;
    ULONG       m_ulOffset;
    ULONG       m_ulArrLen;
};


#define VAR_TYPE_INT    0
#define VAR_TYPE_FLOAT  1
#define VAR_TYPE_CHAR   2
#define VAR_TYPE_WCHAR  3

struct VarDescr
{
    char  szName[MAX_CLASSNAME_LENGTH];
    int   iType;
    int   iValue;
};
typedef FIFO<VarDescr> VarDescrQueue;

struct ClassDescr
{
    char        szNamespace[512];
    char        szName[MAX_CLASSNAME_LENGTH];
    BinStr      bsBody;
};
typedef FIFO<ClassDescr> ClassDescrQueue;

/**************************************************************************/
/* HParse does all the parsing.  It also builds up simple data structures,  
   (like signatures), but does not do the any 'heavy lifting' like define
   methods or classes.  Instead it calls to the Assembler object to do that */

class DParse : public ErrorReporter 
{
public:
    DParse(BinStr* pIn, char* szGlobalNS, bool bByName);
    ~DParse();

        // The parser knows how to put line numbers on things and report the error 
    virtual void error(char* fmt, ...);
    virtual void warn(char* fmt, ...);
    bool Success() {return success; };
    bool Parse();
    void EmitConstants();
    void EmitIntConstant(char* szName, int iValue);
    void EmitFloatConstant(char* szName, float fValue);
    void EmitCharConstant(char* szName, BinStr* pbsValue);
    void EmitWcharConstant(char* szName, BinStr* pbsValue);
    VarDescr* FindVar(char* szName);
    int  ResolveVar(char* szName);
    void AddVar(char* szName, int iVal, int iType);
    ClassDescrQueue ClassQ;
    ClassDescr* FindCreateClass(char* szFullName);
    char    m_szGlobalNS[512];
    char    m_szCurrentNS[512];
    BinStr* m_pIn;             // how we fill up our buffer

private:
    char            m_szIndent[1024];
    VarDescrQueue*  m_pVDescr;

private:
    friend void yyerror(char* str);
    friend int yyparse();
    friend int yylex();

        // Error reporting support
    char* curTok;               // The token we are in the process of processing (for error reporting)
    unsigned curLine;           // Line number (for error reporting)
    bool success;               // overall success of the compilation
    bool m_bByName;

        // Input buffer logic
    enum { 
        IN_READ_SIZE = 8192,    // How much we like to read at one time
        IN_OVERLAP   = 255,     // Extra space in buffer for overlapping one read with the next
                                // This limits the size of the largest individual token (except quoted strings)
    };
    char* buff;                 // the current block of input being read
    char* curPos;               // current place in input buffer
    char* limit;                // curPos should not go past this without fetching another block
    char* endPos;               // points just past the end of valid data in the buffer

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\d_kywd.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//
// COM+ H->IL converter keywords, symbols and values
//
// This is the master table used in HtoIL (hparse.y)
// symbols and values are defined in hparse.y 
//

#ifndef __D_KYWD_H_
#define __D_KYWD_H_

	KYWD( "#define",		DEFINE_,			NO_VALUE )
	KYWD( "TEXT",			TEXT_,				NO_VALUE )

#if(0)
	KYWD( "void",			VOID_,				NO_VALUE )
	KYWD( "bool",			BOOL_,				NO_VALUE )
	KYWD( "char",			CHAR_,				NO_VALUE )
	KYWD( "int",			INT_,				NO_VALUE )
	KYWD( "__int8",			INT8_,				NO_VALUE )
	KYWD( "__int16",		INT16_,				NO_VALUE )
	KYWD( "__int32",		INT32_,				NO_VALUE )
	KYWD( "__int64",		INT64_,				NO_VALUE )
	KYWD( "long",			LONG_,				NO_VALUE )
	KYWD( "short", 			SHORT_,				NO_VALUE )
	KYWD( "unsigned",		UNSIGNED_,			NO_VALUE )
	KYWD( "signed",			SIGNED_,			NO_VALUE )
	KYWD( "float",			FLOAT_,				NO_VALUE )
	KYWD( "double",			DOUBLE_,			NO_VALUE )
	KYWD( "const",			CONST_,				NO_VALUE )
	KYWD( "extern",			EXTERN_,			NO_VALUE )
#endif
	KYWD( "^THE_END^",		0,					NO_VALUE )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\corver\corver.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//=============================================================
//
//	CorVer.cpp
//
//	All Rights Reserved. 
//
//	Created: May 11, 98
//
//	Questions to: jasonand@microsoft.com
//				 
//
//	Notes: CorVer is a little Util to give the version of the DLL's
//	and a few other files that we care about for COM+.
//
//	CorVer will look for files the same way the system does. It will -
//	like the system - report the first occurence that it finds.
//
//	To add a new file -- look in main -- It's pretty simple.
//
//
//	WARNING: I hard coded the arrays to handle as many as 256 files 
//	if you want more then that - feel free to change the array size
//	or - if you feel really bored - make it dynamic.
//
//=============================================================
//
//  Modified: November 12, 1998
//
//  Questions to: manishg@microsoft.com
//
//  Notes: Added support to customize the search of files and registry keys
//  CorVer now reads from a file. The file can specify the files and registry
//  keys to be searched for.
//
//
//
//  WARNING: The above warning still holds
//
// ============================================================
// ============================================================
// ============================================================

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <iostream.h>
#include <stdlib.h>
#include <stdio.h>
#include <shlwapi.h>

BOOL checkVersions( char *File, char *Ext );
VOID getOutput( );
VOID registerOutput( char *File, char *Version );
VOID getHelp( );
BOOL checkRegistry( HKEY rootkey, char *mkey_name, char *mpast_keys, char *mpast_descriptions);
BOOL parseFile(FILE *fptr);
char *readFile(FILE *fptr, char delimiter);
BOOL checkFile(char *FileName);
HKEY getConstHKey(char *key);

char Files[ 256 ][ 256 ];
char Versions[ 256 ][ 256 ];
char Keys[ 256 ][ 256 ];
char Descriptions [ 256 ][ 256 ];
char Version[256];

int iReg = 0;
int iMaxLength = 0;
BOOL bMiddle = FALSE;
BOOL bBare = FALSE, bHelp = FALSE, bCustom = FALSE;

#define NUMKEYS 6		//Number of DWORD registry keys to be queried


// ============================================================
// ============================================================
// ============================================================


int main( int argc, char *argv[ ] )
{
	char iFile[256] = "File.Ver";

	for( int J = 0; J < argc; J++ )
	{
		if( ( _stricmp( argv[ J ], "-b" ) == 0 ) || ( _stricmp( argv[ J ], "/b" ) == 0 ) )
			bBare = TRUE;

		if( ( _stricmp( argv[ J ], "-c" ) == 0 ) || ( _stricmp( argv[ J ], "/c" ) == 0 ) )
			bCustom = TRUE;

		if( ( _stricmp( argv[ J ], "-m" ) == 0 ) || ( _stricmp( argv[ J ], "/m" ) == 0 ) )
			bMiddle = TRUE;

		if( ( _stricmp( argv[ J ], "-?" ) == 0 ) || ( _stricmp( argv[ J ], "/?" ) == 0 ) )
			bHelp = TRUE;

		if ( (_stricmp( argv [ J ], "-f") == 0 ) || ( _stricmp( argv[ J ], "/f" ) == 0 ) ){
				if (J + 1 < argc) 
					strcpy(iFile, argv[J + 1]);
				bCustom = TRUE;
		}
		if ( (_stricmp( argv [ J ], "-v") == 0 ) || ( _stricmp( argv[ J ], "/v" ) == 0 ) ){
				if (J + 1 < argc) 
					strcpy(Version, argv[J + 1]);

		}
	}

	cout << endl;
	
	if ( !bBare )
	{
		cout << "Microsoft (R) Version Utility for the Common Language Runtime" << endl;
		cout << "Copyright (C) Microsoft Corporation 1998. All rights reserved." << endl;
		cout << endl;
		cout << endl;
	}

	if( bHelp )	getHelp( );
	else if (!bCustom)
	{
		checkVersions( "mscoree", ".dll" );
		checkVersions( "mscorrc", ".dll" );
//		checkVersions( "mscorodb", ".dll" );
		checkVersions( "mscorlib", ".dll" );
		checkVersions( "mscorsec", ".dll" );
		checkVersions( "mscorjit", ".dll" );
//		checkVersions( "mscordb", ".dll" );
		checkVersions( " ", " " );					// Blank will insert a blank line in the output list
//		checkVersions( "cordump", ".exe" );
		checkVersions( "cormerge", ".exe" );
		checkVersions( "ceegen", ".exe" );
		checkVersions( "metainfo", ".exe" );
		checkVersions( "ilasm", ".exe" );
		checkVersions( "ildasm", ".exe" );
		checkVersions( "cview", ".exe" );
		checkVersions( "comreg", ".exe" );
		checkVersions( " ", " " );
//		checkVersions( "jps", ".dll" );
		checkVersions( "smc", ".exe" );
//		checkVersions( "msjvc", ".dll");
		checkVersions( "regsvr32", ".exe" );
//		checkVersions( "sgen", ".exe" );
		checkVersions( " ", " " );
		checkVersions( "msvcp60d", ".dll" );
//		checkVersions( "msds110d", ".dll" );
		checkVersions( "msvcrtd", ".dll" );
		checkVersions( "msvcrt", ".dll" );

//		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "DebuggerEnable", "Debugger" );
//		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "EnableDebugGC", "DebugGC" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "JITEnable", "JIT" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "JITRequired", "JIT Required" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "JITnoSched", "JIT no Sched" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "LogEnable", "Log Enabled" );
//		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "SecurityFlag", "Security Tracing" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "HeapVerify", "Heap Verification" );
		checkRegistry( HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", "GCStress", "GCStress" );
		cout << endl;
		getOutput( );
	} 
	else
	{	
		char Search[ _MAX_PATH ];
		DWORD Result = SearchPath( NULL, iFile, ".ver", _MAX_PATH, Search, NULL );
		if (Result == 0) cout << "File " << iFile << " not found" << endl; // TODO: Make the Name Dynamic here
		else 
		{
			FILE *fPtr = fopen(Search, "r");
			if (!parseFile(fPtr)){
				cout << "\n\nSome Failure(s) were encountered,\n (*) indicates the file versions do not match" << endl;
				return 1;
			}
			else 
				return 0;
		}
	}
	cout << endl;
	return 0;
}

// ============================================================
// ============================================================
// ============================================================


VOID registerOutput( char *File, char *Version )
{
	if( strcmp( File, " " ) != 0 )
	{
		strcpy( Files[ iReg ], File );
		strcat( Files[ iReg ], ":" );
		
		int CLen = strlen( Files[ iReg ] );
		if( CLen > iMaxLength ) iMaxLength = CLen;
			
		strcpy(Versions[ iReg ], Version );
	}
	else
	{
		strcpy( Files[ iReg ], " " );
		strcpy(Versions[ iReg ], " " );
	}


	iReg += 1;

}

// ============================================================
// ============================================================
// ============================================================


VOID getOutput( )
{

//	cout << "Max Length is: " << iMaxLength << endl;
	
	for( int J = 0; J < iReg; J++ )
	{
		if( strcmp( Files[ J ], " " ) != 0 )
		{
			int Dif = 0;
			int CLen = strlen( Files[ J ] );
			if( CLen != iMaxLength ) 
			{
				Dif = iMaxLength - CLen;
				if( bMiddle )
				{
					char Temp[ 256 ];
					strcpy( Temp, Files[ J ] );

					for( int A = 0; A < Dif; A++ ) 
					{
							if( A == 0 ) strcpy( Files[ J ], " " );
							else strcat( Files[ J ], " " );
					}

					strcat( Files[ J ], Temp );
				}
				else
				{
					for( int A = 0; A < Dif; A++ )  strcat( Files[ J ], " " );
				}
				
			}
		}
		cout << " " << Files[ J ] << "  " << Versions[ J ] << endl;
	}
}


// ============================================================
// ============================================================
// ============================================================


BOOL checkVersions( char *File, char *Ext )
{
	BOOL retVal = TRUE;
	char Search[ _MAX_PATH ];
	DWORD Result = SearchPath( NULL, File, Ext, _MAX_PATH, Search, NULL );
	
	if( strcmp( File, " " ) == 0 )
	{
		
		registerOutput( " ", " " );
		return retVal;
	}
	else
	{
		if( Result == 0 ) 
		{
			char cError[ 50 ];
			char File_Ext[ 256 ];

			DWORD dwError = GetLastError( );
			if( dwError == 2 ) {
				strcpy( cError, "File not found" );
				retVal = FALSE;
			}
			else 
			{
				char buffer[ 5 ];
				strcpy( cError, "Unknown error: " );
				_itoa( dwError, buffer, 10 );
				strcat( cError, buffer );
				retVal = FALSE;
			}
			strcpy( File_Ext, File );
			strcat(  File_Ext, Ext );
			registerOutput( File_Ext, cError );

		}
		else 
		{
			DWORD Handle;
			int Size = 0;
			LPDWORD NullData = 0;
			char VersionBuffer[1000];


			char V2[ 512 ];
		
			Size = GetFileVersionInfoSize( Search, &Handle );
			if( Size != 0 )
			{
				NullData = new DWORD[ Size ];
				BOOL Result = GetFileVersionInfo( Search, Handle, Size, ( LPVOID )NullData ); 
				UINT BufferSize = sizeof( VersionBuffer );
				VerQueryValue( NullData, "\\", ( LPVOID* )VersionBuffer, &BufferSize );
				VS_FIXEDFILEINFO* VerStruct = *( VS_FIXEDFILEINFO** )VersionBuffer;
		
				if ( ( VerStruct->dwFileVersionMS >> 16 ) == 0 )
				{
					strcpy( V2, "Unable to get version for this file" );
				}
				else 
				{
					
					char buffer[ 32 ];

					_itoa( VerStruct->dwFileVersionMS >> 16, buffer, 10 );
					strcpy( V2, buffer );
					strcat( V2, "." );
					
					_itoa( VerStruct->dwFileVersionMS & 0xFFff, buffer, 10 );
					strcat( V2, buffer );
					strcat( V2, "." );

					_itoa( VerStruct->dwFileVersionLS >> 16, buffer, 10 );
					strcat( V2, buffer );
					strcat( V2, "." );

					_itoa( VerStruct->dwFileVersionLS & 0xFFff, buffer, 10 );
					strcat( V2, buffer );
				}
				if (stricmp(Version, V2) != 0) {
					retVal = false;
					if (bCustom) strcat(V2, "*");
				}
			}
			else strcpy( V2, "No version information" );
			
			registerOutput( Search , V2 );
		}
		return retVal;
	}	
}


// ============================================================
// ============================================================
// ============================================================	


VOID getHelp( )
{
	cout << "CorVer - Outputs the versions of DLLs and tools used by the Common Language Runtime" << endl;
	cout << endl;
	cout << "Syntax: CorVer [options]" << endl;
	cout << endl;
	cout << "Options:" << endl;
	cout << "   /b          Bare output - no label" << endl;
	cout << "   /c          Custom - Displays versions of files in \"File.ver\"" << endl;
	cout << "   /m          Output printed to the middle of the screen" << endl;
	cout << "   /v  <ver>	Specifies the File Versions to be checked against" << endl;
	cout << "   /f  <file>	Specifies the Input file" << endl;
	cout << "   /?          Print this help message" << endl;
	cout << "Note: a \'*\' after a filename means the versions do not match" << endl;
}


// ============================================================
// ============================================================
// ============================================================

BOOL checkRegistry( HKEY rootKey, char *mkey_name, char *mpast_key, char *mpast_description){
	HKEY__ *mpHK_HKey = new HKEY__;
	unsigned long *mpul_type = new unsigned long;

	char data[256] = "";

	unsigned long *mpul_sizeofInt = new unsigned long;
	*mpul_sizeofInt = sizeof(int);

	if(RegOpenKeyEx(rootKey, mkey_name, //"Software\\Microsoft\\.NETFramework",
		0, KEY_READ, &mpHK_HKey) != ERROR_SUCCESS){
		cout << "Cannot open " << mkey_name << " registry entry" << endl;
		return FALSE;
	}

		if(RegQueryValueEx(mpHK_HKey, mpast_key, 0,
			mpul_type, (unsigned char *)data, mpul_sizeofInt) != ERROR_SUCCESS){
				cout << "Value " << mpast_key << " not found" << endl;
				return FALSE;
		}
		else{
			cout << mpast_description << " = ";

			switch (*mpul_type){
			case REG_BINARY:
							cout << data;
							break;

			case REG_DWORD:
							cout << *(unsigned long *)data;
							break;

			case REG_DWORD_BIG_ENDIAN:
							cout << *(unsigned long *)data;
							break;

			case REG_SZ:
							cout << data;
							break;

			default:
							break;
			}
			cout << endl;
		}
	RegCloseKey(mpHK_HKey);
	return TRUE;
}

// ============================================================
// ============================================================
// ============================================================

BOOL parseFile(FILE *fptr){
		char *nextLine;
		char rootName[256] = "";
		char keyName[256] = "";
		char keyVal[256] = "";
		BOOL isFile = TRUE;
		BOOL retVal = TRUE;

		strcpy(Version, "");

		do{
			nextLine = readFile(fptr, ';');
			if (nextLine != NULL ){
				if (stricmp(nextLine, "[key]") == 0){
					isFile = FALSE;
					strcpy(rootName, readFile(fptr, '\\'));
					strcpy(keyName, readFile(fptr, NULL));
					strcpy(keyVal, readFile(fptr, ';'));
					nextLine = readFile(fptr, NULL);
				}
				else 
					if (stricmp(nextLine, "[file]") == 0){
						isFile=TRUE;
						strcpy(Version, readFile(fptr, NULL));
						nextLine = readFile(fptr, NULL);
					}
					else if (!isFile && strcmp(nextLine, "") != 0){
						strcpy(keyVal, nextLine);
						nextLine = readFile(fptr, NULL);
					}
			}
			if (nextLine != NULL && strcmp(nextLine, "") != 0){
				if (isFile){
					if (!checkFile(nextLine)) 
						retVal = false;
				}
				else {
						if (!checkRegistry(getConstHKey(rootName), keyName, keyVal, nextLine)) 
							retVal = false;
					}
			}
		}while (nextLine != NULL);
		cout << endl;

		getOutput();
		return retVal;
}

// ============================================================
// ============================================================
// ============================================================

char *readFile(FILE *fptr, char delimiter){
	char nextChar[2] = "";
	char nextLine[256] = "";
	int result;

	do{
		strcat(nextLine, nextChar);
		result = fscanf(fptr, "%c", &nextChar[0]);
	}while( stricmp(nextLine, "[key]") != 0 && stricmp(nextLine, "[file]") != 0 &&
			nextChar[0] != delimiter && nextChar[0] != '\n' && result != EOF);

	if (result == EOF && strlen(nextLine) == 0) 
		return NULL;
	else {
		char *retLine = new char[256];
		strcpy(retLine, nextLine);
		return retLine;
	}
}

// ============================================================
// ============================================================
// ============================================================

BOOL checkFile(char *FileName){
	int ch = '.';
	char *periodPos = strchr(FileName, ch);
	char File[ _MAX_PATH ] = "", Ext[ _MAX_PATH ] = "";

	int result = periodPos - FileName + 1;
				 
	strncpy(File, FileName, result - 1);
	File[result] = 0;
				 
	strncpy(Ext, FileName + result - 1 , strlen(FileName) - result + 1);
	Ext[strlen(FileName) - result + 1] = 0;

	return checkVersions( File, Ext );
}

// ============================================================
// ============================================================
// ============================================================

HKEY getConstHKey(char *key){
	
	if (key == NULL) return NULL;
	if (strcmp(key, "HKEY_CLASSES_ROOT") == 0)		return HKEY_CLASSES_ROOT;
	if (strcmp(key, "HKEY_CURRENT_USER") == 0)		return HKEY_CURRENT_USER;
	if (strcmp(key, "HKEY_CURRENT_CONFIG") == 0)	return HKEY_CURRENT_CONFIG;
	if (strcmp(key, "HKEY_LOCAL_MACHINE") == 0)		return HKEY_LOCAL_MACHINE;
	if (strcmp(key, "HKEY_USERS") == 0)				return HKEY_USERS;
	return NULL;

	
}

// ========================EOF=================================
// ============================================================
// ============================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\nvpair.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/* Name value pair (both strings) which can be linked into a list of pairs */

#ifndef NVPAIR_H
#define NVPAIR_H

class NVPair
{
public:

    NVPair(char *name, char *value)
    {
        m_Name = new char [strlen(name) + 1];
        m_Value = new char [strlen(value) + 1];
        strcpy(m_Name, name);
        strcpy(m_Value, value);
        m_Tail = NULL;
    }

    ~NVPair()
    {
        delete [] m_Name;
        delete [] m_Value;
        delete m_Tail;
    }

    NVPair *Concat(NVPair *list)
    {
        m_Tail = list;
        return this;
    }

    char *Name() { return m_Name; }
    char *Value() { return m_Value; }
    NVPair *Next() { return m_Tail; }

private:
    char   *m_Name;
    char   *m_Value;
    NVPair *m_Tail;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\makefile.inc ===
OBJECTS = $(OBJECTS) $O\DParse.obj 

$O\DParse.obj: DParse.h $O\DParse.c dparse.grammar


$O\DParse.c: dparse.y dparse.h ..\..\inc\openum.h 
	-del/f /q $O\dparse.c 
    yacc_ms -o $O\dparse -i dparse.y

dparse.grammar: dparse.y
	perl extractGrammar.pl dparse.y > dparse.grammar
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "dparse.h"
#include "__file__.ver"
#include "corver.h"

char* g_szFileName[4096];

BOOL ExtractConstants(char* szInputFilename,char* szGlobalNS, bool bByName, DParse* pParser)
{
	FILE	*pInF;
	static char	buf[2048];
	BinStr	*pRes = pParser->m_pIn;
	BOOL	continued = FALSE;
	unsigned L;
	char	*pc;

	fprintf(stderr,"//Converting '%s' \n\n", szInputFilename);
	if(pInF = fopen(szInputFilename,"rt"))
	{
		while(fgets(buf,sizeof(buf),pInF))
		{
			for(pc = &buf[strlen(buf)-1];(pc >= buf)&&((*pc == '\n')||(*pc == '\r')); pc--) *pc = 0;
			pc = &buf[0];
			if(continued)	continued = FALSE;
			else
			{
				for(; (*pc == ' ')||(*pc == '\t'); pc++);
				if(strstr(pc,"#include") == pc)
				{
					char *pcend, *szNewName;
					pc+= 8; // skip #include
					for(; *pc &&((*pc == ' ')||(*pc == '\t')); pc++);
					pc++; // skip " or <
					for(pcend = pc; *pcend && (*pcend != '"') && (*pcend != '>'); pcend++);
					*pcend = 0;
					szNewName = new char[pcend-pc+1];
					strcpy(szNewName,pc);
					for(L = 0; L < 4096; L++)
					{
						if(g_szFileName[L])
						{
							if(!strcmp(g_szFileName[L],szNewName)) break;
						}
					}
					if(L >= 4096)
					{
						for(L = 0; (L < 4096)&&(g_szFileName[L]); L++);
						g_szFileName[L] = szNewName;
						ExtractConstants(szNewName,szGlobalNS,bByName,pParser);
					}
					else delete szNewName;
					continue;
				}
				if(strstr(pc,"#define") != pc) continue;
			}

			if(L = strlen(pc))
			{
				L--;
				if(pc[L] == '\\')
				{
					continued = TRUE;
					pc[L] = 0;
				}
				pRes->appendStr(pc);
			}
			if(!continued)
			{
				pRes->appendInt8(0);
				pc = (char*)(pRes->ptr());
				if(!pParser->Parse()) printf("// in: %s\n\n",pc);
				L = pRes->length();
				pRes->remove(L);
			}
		}
		fclose(pInF);
		fprintf(stderr,"\n//Done with '%s' \n\n", szInputFilename);
		return TRUE;
	}
	else
		printf("Error : could not open input file %s\n",szInputFilename);
	return FALSE;
}

void __cdecl main(int argc, char **argv)
{
    char        szInputFilename[MAX_FILENAME_LENGTH];
    char        szDefFilename[MAX_FILENAME_LENGTH];
    char        szGlobalNS[MAX_FILENAME_LENGTH];
    int         i;
    BOOL	    OnErrGo = false;
	_TCHAR		szOpt[128];
	bool		bByName = false;
	int			exitval=1;
	BinStr		*pRes = new BinStr();
	DParse*		pParser;

    printf("\n//Microsoft (R) Converter H to CIL Assembler (constants).  Version " VER_FILEVERSION_STR);
    printf("\n//%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);

	memset(szInputFilename,0,sizeof(szInputFilename));
	
    if (argc < 2 || ! strcmp(argv[1], "/?") || ! strcmp(argv[1],"-?"))
    { 
    ErrorExit:
      printf("\n\nUsage: DefToIL [Options] <sourcefile> [Options]");
      printf("\n\n");
      printf("\nOptions:");
      printf("\n/BYNAME				emit the constants by name (Const.A, Const.B, etc.)");
      printf("\n/GNS=<namespace>	set global namespace for constants");
      printf("\n\nKey may be '-' or '/'\nOptions are recognized by first 3 characters\nDefault source file extension is .H\n\n");
      exit(1);
    }

	//-------------------------------------------------
	szDefFilename[0] = 0;
	szGlobalNS[0] = 0;
	for (i = 1; i < argc; i++)
	{
		if((argv[i][0] == '/') || (argv[i][0] == '-'))
		{
			lstrcpyn(szOpt, &argv[i][1],10);
			szOpt[3] = 0;
			if (!lstrcmpi(szOpt, _T("GNS")))
			{
				char *pStr = strchr(argv[i],'=');
				if(pStr == NULL) goto ErrorExit;
				for(pStr++; *pStr == ' '; pStr++); //skip the blanks
				if(strlen(pStr)==0) goto ErrorExit; //if no file name
				lstrcpyn(szGlobalNS,pStr,MAX_FILENAME_LENGTH-1);
			}
			else
			if (!lstrcmpi(szOpt, _T("BYN")))
			{
				bByName = true;;
			}
			else
			{
				printf("Error : Invalid Option: %s", argv[i]);
				goto ErrorExit;
			}
		}
		else
		{
			if(szInputFilename[0]) goto ErrorExit;
			//Attention! Not Unicode piece:
			lstrcpyn(szInputFilename,argv[i],MAX_FILENAME_LENGTH-1);
			int j = strlen(szInputFilename)-1;
			for(; j >= 0; j--)
			{
				if(szInputFilename[j] == '.') break;
				if((szInputFilename[j] == '\\')||(j == 0))
				{
					strcat(szInputFilename,".H");
					break;
				}
			}
		}
	}
				
	if(szInputFilename[0] == 0) goto ErrorExit;
	//======================================================================
	//======================================================================
	if(pParser = new DParse(pRes,szGlobalNS,bByName))
	{
		memset(g_szFileName,0,4096*sizeof(char*));
		g_szFileName[0] = szInputFilename;
		if(ExtractConstants(szInputFilename,szGlobalNS,bByName,pParser)) exitval = 0;
		pParser->EmitConstants();
		delete pParser;
	}
	else
		printf("Error : could not create parser\n");
	//======================================================================
	exit(exitval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\fastfc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "FASTFC.EXE"
#define VER_FILEDESCRIPTION_STR "Fast file compare\0"
#define VER_ORIGFILENAME_STR    "fastfc.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\deftoil\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "DEFTOIL.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft converter H to CIL (constant defines)\0"
#define VER_ORIGFILENAME_STR    "DefToIL.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\binstr.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* a binary string (blob) class */

#ifndef BINSTR_H
#define BINSTR_H

#include <string.h>			// for memmove, memcpy ... 

class BinStr {
public:
	BinStr()  { 
		len = 0L; max = 8L; ptr_ = buff; 
		}
	~BinStr() { 
		if (ptr_ != buff) delete [] ptr_; 
		}

	void insertInt8(int val) { if (len >= max) realloc(); memmove(ptr_+1, ptr_, len); *ptr_ = val; len++; }
	void appendInt8(int val) { if (len >= max) realloc(); ptr_[len++] = val; }
	void appendInt16(int val) { if (len + 2 > max) realloc(); *((short*) &ptr_[len]) = val; len += 2; }
	void appendInt32(int val) { if (len + 4 > max) realloc(); *((int*) &ptr_[len]) = val; len += 4; }
	void appendInt64(__int64 *pval) { if (len + 8 > max) realloc(); memcpy(&ptr_[len],pval,8); len += 8; }
	unsigned __int8* getBuff(unsigned size) { 
		if (len + size > max) realloc(size); 
		_ASSERTE(len + size <= max);
		unsigned __int8* ret = &ptr_[len]; 
		len += size; 
		return(ret);
		}
    void append(BinStr* str) {
       memcpy(getBuff(str->length()), str->ptr(), str->length());
       }
	void appendStr(char* str) {
		if(str && *str) memcpy(getBuff(strlen(str)),str,strlen(str));
	}

	void remove(unsigned size) { _ASSERTE(len >= size); len -= size; }
	
	unsigned __int8* ptr() 		{ return(ptr_); }
	unsigned length() 	{ return(len); }
	
private:
	void realloc(unsigned atLeast = 4) {
		max = max * 2;
		if (max < atLeast + len)
			max = atLeast + len;
		_ASSERTE(max >= len + atLeast);
		unsigned __int8* newPtr = new unsigned __int8[max];
		memcpy(newPtr, ptr_, len);
		if (ptr_ != buff) delete [] ptr_; 
		ptr_ = newPtr;
		}
	
private:
	unsigned  len;
	unsigned  max;
	unsigned __int8 *ptr_;
	unsigned __int8 buff[8];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\fastfc\fastfc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// This is a quick and dirty file compare utility which only tells you if a
// file is different or not.  There is nothing in here smarter than that.  It
// came in very handy for the VSS merge builder.
//*****************************************************************************
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

//
// 0 == same
// 1 == different
//
int __cdecl main(int argc, char *argv[])
{
    int         irtn = 0;
    FILE        *f1 = 0;
    FILE        *f2 = 0;
    unsigned char rgbuff1[64*1024];
    unsigned char rgbuff2[64*1024];

    printf("fastfc:  file1   file2\n");
    if (argc < 3)
        return (-1);

    f1 = fopen(argv[1], "rb");
    if (!f1)
    {
        printf("Failed to open file %s\n", argv[1]);
        goto ErrExit;
    }


    f2 = fopen(argv[2], "rb");
    if (!f2)
    {
        printf("Failed to open file %s\n", argv[2]);
        goto ErrExit;
    }

    while (true)
    {
        size_t cb1 = fread(rgbuff1, 1, sizeof(rgbuff1), f1);
        size_t cb2 = fread(rgbuff2, 1, sizeof(rgbuff2), f2);
        
        // If both files are now empty, we're done and they match.
        if (cb1 == 0 && cb2 == 0 && feof(f1) && feof(f2))
            break;
        
        // If buffer sizes differ, or buffer contents differ, then different
        // so just quit right now.
        if (cb1 != cb2 || memcmp(rgbuff1, rgbuff2, cb1) != 0)
        {
            printf("Files are different.\n");
            irtn = 1;
            goto ErrExit;
        }
    }

    irtn = 0;
    printf("Files are the same.\n");

ErrExit:
    if (f1)
        fclose(f1);
    if (f2)
        fclose(f2);
    return (irtn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\gac\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "cachemgr.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly Cache Utility\0"
#define VER_ORIGFILENAME_STR    "cachemgr.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\gac\gac.cpp ===
#include <winwrap.h>
#include <stdio.h>
#include <windows.h>
#include <assert.h>
#include <cor.h>
#include <corerror.h>
#include <corver.h>
#include <utilcode.h>
#include <mscoree.h>
#include <__file__.ver>

#include "initguid.h"
#include "fusion.h"
#include "shlwapi.h"

#define INSTALL_REF_UNINSTALL_SCHEME      L"UNINSTALL_KEY"
#define INSTALL_REF_FILEPATH_SCHEME       L"FILEPATH" 
#define INSTALL_REF_OPAQUE_STRING_SCHEME  L"OPAQUE"
#define INSTALL_REF_MSI_SCHEME            L"WINDOWS_INSTALLER"
#define INSTALL_REF_OSINSTALL_SCHEME      L"OSINSTALL"  

//
// Function pointers late bound calls to Fusion.  Fusion is delay loaded for side by side
//
typedef HRESULT (__stdcall *CreateAsmCache)(IAssemblyCache **ppAsmCache, DWORD dwReserved);
typedef HRESULT (__stdcall *CreateAsmNameObj)(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *CreateAsmEnum)(IAssemblyEnum **pEnum, IUnknown *pAppCtx, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);
typedef HRESULT (__stdcall *NukeDlCache)();
typedef HRESULT (__stdcall *CreateInstallRefEnum)(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);

CreateAsmCache g_pfnCreateAssemblyCache = NULL;
CreateAsmNameObj g_pfnCreateAssemblyNameObject = NULL;
CreateAsmEnum g_pfnCreateAssemblyEnum = NULL;
NukeDlCache g_pfnNukeDownloadCache = NULL;
CreateInstallRefEnum g_pfnCreateInstallReferenceEnum = NULL;

HMODULE                     g_FusionDll         = NULL;

bool                        g_bdisplayLogo      = true;
bool                        g_bSilent           = false;

// commands
INT                         g_bInstall          = 0;        //  -i
INT                         g_bInstallList      = 0;        //  -il
INT                         g_bUninstall        = 0;        //  -u
INT                         g_bUninstallAllRefs = 0;        //  -uf 
INT                         g_bUninstallNgen    = 0;        //  -ugen
INT                         g_bUninstallList    = 0;        //  -ul
INT                         g_bListAsm          = 0;        //  -l
INT                         g_bListAsmRefs      = 0;        //  -lr
INT                         g_bListDLCache      = 0;        //  -ldl
INT                         g_bNukeDLCache      = 0;        //  -cdl
INT                         g_bPrintHelp        = 0;        //  -?

// arguments/options
bool                        g_bForceInstall     = false;    // -f
FUSION_INSTALL_REFERENCE   *g_pInstallReference = NULL;     // -r
LPCWSTR                     g_pAsmListFileName  = NULL;     
LPCWSTR                     g_pAsmFileName      = NULL;
LPCWSTR                     g_pAsmDisplayName   = NULL;

#define BSILENT_PRINTF0ARG(str) if(!g_bSilent) printf(str)
#define BSILENT_PRINTF1ARG(str, arg1) if(!g_bSilent) printf(str, arg1)
#define BSILENT_PRINTF2ARG(str, arg1, arg2) if(!g_bSilent) printf(str, arg1, arg2)

#define MAX_COUNT MAX_PATH

bool FusionInit(void)
{
    // 
    // Load the version of Fusion from the directory the EE is in
    //
    HRESULT hr = LoadLibraryShim(L"fusion.dll", 0, 0, &g_FusionDll);

    //
    // Save pointers to call through later
    //
    if (SUCCEEDED(hr))
    {
        if ((g_pfnCreateAssemblyCache      = (CreateAsmCache)GetProcAddress(g_FusionDll, "CreateAssemblyCache")) == NULL) return false;
        if ((g_pfnCreateAssemblyNameObject = (CreateAsmNameObj)GetProcAddress(g_FusionDll, "CreateAssemblyNameObject")) == NULL) return false;
        if ((g_pfnCreateAssemblyEnum       = (CreateAsmEnum)GetProcAddress(g_FusionDll, "CreateAssemblyEnum")) == NULL) return false;
        if ((g_pfnNukeDownloadCache        = (NukeDlCache)GetProcAddress(g_FusionDll, "NukeDownloadedCache")) == NULL) return false;
        if ((g_pfnCreateInstallReferenceEnum       = (CreateInstallRefEnum)GetProcAddress(g_FusionDll, "CreateInstallReferenceEnum")) == NULL) return false;
    }
    else
    {
        return false;
    }

    return true;
}

void Title()
{
    if (g_bSilent) return;

    printf("\nMicrosoft (R) .NET Global Assembly Cache Utility.  Version " VER_FILEVERSION_STR);
    wprintf(L"\n" VER_LEGALCOPYRIGHT_DOS_STR);
    printf("\n\n");
}

void ShortUsage()
{
    if (g_bSilent) return;

    printf("Usage: Gacutil <command> [ <options> ]\n");
    printf("Commands:\n");
    printf("  /i <assembly_path> [ /r <...> ] [ /f ]\n");
    printf("    Installs an assembly to the global assembly cache.\n");
    printf("\n");
    
    printf("  /il <assembly_path_list_file> [ /r <...> ] [ /f ]\n");
    printf("    Installs one or more assemblies to the global assembly cache.\n");
    printf("\n");
    
    printf("  /u <assembly_display_name> [ /r <...> ]\n");
    printf("    Uninstalls an assembly from the global assembly cache.\n");
    printf("\n");

    printf("  /ul <assembly_display_name_list_file> [ /r <...> ]\n");
    printf("    Uninstalls one or more assemblies from the global assembly cache.\n");
    printf("\n");

    printf("  /ungen <assembly_name>\n");
    printf("    Uninstalls a native image installed via the NGEN utility.\n");
    printf("\n");

    printf("  /l [ <assembly_name> ]\n");
    printf("    List the global assembly cache filtered by <assembly_name>\n");
    printf("\n");

    printf("  /lr [ <assembly_name> ]\n");
    printf("    List the global assembly cache with all traced references.\n");
    printf("\n");

    printf("  /cdl\n");
    printf("    Deletes the contents of the download cache\n");
    printf("\n");
    
    printf("  /ldl\n");
    printf("    Lists the contents of the download cache\n");
    printf("\n");

    printf("  /? \n");
    printf("    Displays a detailed help screen\n");
    printf("\n");

    printf("Options:\n");
    printf("  /r <reference_scheme> <reference_id> <description>\n");
    printf("    Specifies a traced reference to install (/i, /il) or uninstall (/u, /ul).\n");
    printf("\n");

    printf("  /f \n");
    printf("    Forces reinstall of an assembly.\n");
    printf("\n");
    
    printf("  /nologo\n");
    printf("    Suppresses display of the logo banner\n");
    printf("\n");
    
    printf("  /silent\n");
    printf("    Suppresses display of all output\n");
    printf("\n");
}
void LongUsage()
{
    if (g_bSilent) return;

    printf("Usage: Gacutil <command> [ <options> ]\n");
    printf("Commands:\n");
    printf("  /i <assembly_path> [ /r <...> ] [ /f ]\n");
    printf("    Installs an assembly to the global assembly cache. <assembly_path> is the\n");
    printf("    name of the file that contains the assembly manifest.\n");
    printf("    Example: /i myDll.dll /r FILEPATH c:\\projects\\myapp.exe \"My App\"\n");
    printf("\n");
    
    printf("  /il <assembly_list_file> [ /r <...> ] [ /f ]\n");
    printf("    Installs one or more assemblies to the global assembly cache.  \n");
    printf("    <assembly_list_file> is the path to a text file that contains a list of \n");
    printf("    assembly manifest file paths. Individual paths in the text file must be \n");
    printf("    separated by CR/LF.\n");
    printf("    Example: /il MyAssemblyList.txt /r FILEPATH c:\\projects\\myapp.exe \"My App\"\n");
    printf("      myAssemblyList.txt content:\n");
    printf("      myAsm1.dll\n");
    printf("      myAsm2.dll\n");
    printf("\n");
    
    printf("  /u <assembly_name> [ /r <...> ]\n");
    printf("    Uninstalls an assembly. <assembly_name> is the name of the assembly\n");
    printf("    (partial or fully qualified) to remove from the Global Assembly Cache.\n");
    printf("    If a partial name is specified all matching assemblies will be uninstalled.\n");
    printf("    Example:\n");
    printf("      /u myDll,Version=1.1.0.0,Culture=en,PublicKeyToken=874e23ab874e23ab \n");
    printf("      /r FILEPATH c:\\projects\\myapp.exe \"My App\"\n");
    printf("\n");

    printf("  /uf <assembly_name>\n");
    printf("    Forces uninstall of an assembly by removing all traced references.\n");
    printf("    <assembly_name> is the full name of the assembly to remove. Assembly will\n");
    printf("    be removed unless referenced by Windows Installer.\n");
    printf("    ! Warning: use the /uf command with care as applications may fail to run !\n");
    printf("    Example: /uf myDll,Version=1.1.0.0,Culture=en,PublicKeyToken=874e23ab874e23ab\n");
    printf("\n");
       
    printf("  /ul <assembly_list_file> [ /r <...> ]\n");
    printf("    Uninstalls one or more assemblies from the global assembly cache.  \n");
    printf("    <assembly_list_file> is the path to a text file that contains a list of \n");
    printf("    assembly names. Individual names in the text file must be \n");
    printf("    separated by CR/LF.\n");
    printf("    Example: /ul myAssemblyList.txt /r FILEPATH c:\\projects\\myapp.exe \"My App\"\n");
    printf("      myAssemblyList.txt content:\n");
    printf("      myDll,Version=1.1.0.0,Culture=en,PublicKeyToken=874e23ab874e23ab\n");
    printf("      myDll2,Version=1.1.0.0,Culture=en,PublicKeyToken=874e23ab874e23ab\n");
    printf("\n");
    
    printf("  /ungen <assembly_name>\n");
    printf("    Uninstalls a native image installed via the NGEN utility. <assembly_name>\n");
    printf("    is the name of the assembly for which native images are to be uninstalled.\n");
    printf("    The assembly itself will remain in the global assembly cache.\n");
    printf("    Example: /ungen myDll\n");
    printf("\n");
    
    printf("  /l [ <assembly_name> ]\n");
    printf("    Lists the contents of the global assembly cache. When the optional \n");
    printf("    <assembly_name> parameter is specified only matching assemblies are listed.\n");
    printf("\n");
    
    printf("  /lr [ <assembly_name> ]\n");
    printf("    Lists the contents of the global assembly cache including traced reference \n");
    printf("    information. When the optional <assembly_name> parameter is specified only \n");
    printf("    matching assemblies are listed.\n");
    printf("\n");
    
    printf("  /cdl\n");
    printf("    Deletes the contents of the download cache\n");
    printf("\n");
    
    printf("  /ldl\n");
    printf("    Lists the contents of the download cache\n");
    printf("\n");
    
    printf("  /? \n");
    printf("    Displays a detailed help screen\n");
    printf("\n");

    printf("Old command syntax:\n");
    printf("  /if <assembly_path>\n");
    printf("    equivalent to /i <assembly_path> /f\n");
    printf("\n");
    
    printf("  /ir <assembly_path> <reference_scheme> <reference_id> <description>\n");
    printf("    equivalent to /i <assembly_path> /r <...>\n");
    printf("\n");

    printf("  /ur <assembly_name> <reference_scheme> <reference_id> <description>\n");
    printf("    equivalent to /u <assembly_path> /r <...>\n");
    printf("\n");
            
    printf("Options:\n");
    printf("  /r <reference_scheme> <reference_id> <description>\n");
    printf("    Specifies a traced reference to install (/i, /il) or uninstall (/u, /ul).\n");
    printf("      <reference_scheme> is the type of the reference being added \n");
    printf("        (UNINSTALL_KEY, FILEPATH or OPAQUE). \n");
    printf("      <reference_id> is the identifier of the referencing application, \n");
    printf("        depending on the <reference_scheme>\n");
    printf("      <description> is a friendly description of the referencing application.\n");
    printf("    Example: /r FILEPATH c:\\projects\\myapp.exe \"My App\"\n");
    printf("\n");
    
    printf("  /f \n");
    printf("    Forces reinstall of an assembly regardless of any existing assembly with \n");
    printf("    the same assembly name.\n");
    printf("\n");
    
    printf("  /nologo\n");
    printf("    Suppresses display of the logo banner\n");
    printf("\n");
    
    printf("  /silent\n");
    printf("    Suppresses display of all output\n");
    printf("\n");
}

void ReportError(HRESULT hr)
{
    //
    // First, check to see if this is one of the Fusion HRESULTS
    //
    // TODO: Put these strings in the rc file so they can be localized...
    if (hr == FUSION_E_PRIVATE_ASM_DISALLOWED)
    {
        BSILENT_PRINTF0ARG("Attempt to install an assembly without a strong name\n");
    }
    else if (hr == FUSION_E_SIGNATURE_CHECK_FAILED)
    {
        BSILENT_PRINTF0ARG("Strong name signature could not be verified.  Was the assembly built delay-signed?\n");     
    }
    else if (hr == FUSION_E_ASM_MODULE_MISSING)
    {
        BSILENT_PRINTF0ARG("One or more modules specified in the manifest not found.\n");
    }
    else if (hr == FUSION_E_UNEXPECTED_MODULE_FOUND)
    {
        BSILENT_PRINTF0ARG("One or more modules were streamed in which did not match those specified by the manifest.  Invalid file hash in the manifest?\n");
    }
    else if (hr == FUSION_E_DATABASE_ERROR)
    {
        BSILENT_PRINTF0ARG("An unexpected error was encountered in the assembly cache.\n");
    }
    else if (hr == FUSION_E_INVALID_NAME)
    {
        BSILENT_PRINTF0ARG("Invalid file or assembly name.  The name of the file must be the name of the assembly plus .dll or .exe .\n");
    }
    else if (hr == FUSION_E_UNINSTALL_DISALLOWED)
    {
        BSILENT_PRINTF0ARG("Assembly cannot be uninstalled because it is required by the operating system.\n");
    }
    else
    {
        //
        // Try the system messages
        //
        LPVOID lpMsgBuf;
        DWORD bOk = WszFormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL); 

        if (bOk)
        {
            BSILENT_PRINTF1ARG("\t%ws\n", (LPTSTR)((LPTSTR)lpMsgBuf));
            LocalFree( lpMsgBuf );
        }
        else
        {
            BSILENT_PRINTF0ARG("Unknown Error\n");
        }
    }

}

bool GetGUIDFromInput(LPCWSTR pszInput, GUID *pGuidScheme)
{

    if (!_wcsicmp(INSTALL_REF_UNINSTALL_SCHEME, pszInput) ) 
    {
        *pGuidScheme=FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
    } else if (!_wcsicmp(INSTALL_REF_FILEPATH_SCHEME, pszInput) ) 
    {
        *pGuidScheme=FUSION_REFCOUNT_FILEPATH_GUID;
    } else if (!_wcsicmp(INSTALL_REF_OPAQUE_STRING_SCHEME, pszInput) ) 
    {
        *pGuidScheme=FUSION_REFCOUNT_OPAQUE_STRING_GUID;
    } else if (!_wcsicmp(INSTALL_REF_OSINSTALL_SCHEME, pszInput) )
    {
        *pGuidScheme=FUSION_REFCOUNT_OSINSTALL_GUID;
    }
    else 
    {
        return false; 
    }

    return true;
}

bool GetInputFromGUID(GUID *pGuidScheme, LPWSTR &pszScheme)
{
    if(*pGuidScheme==FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID)
    {
        pszScheme = INSTALL_REF_UNINSTALL_SCHEME;
    }
    else if(*pGuidScheme==FUSION_REFCOUNT_FILEPATH_GUID)
    {
        pszScheme = INSTALL_REF_FILEPATH_SCHEME;
    }
    else if(*pGuidScheme==FUSION_REFCOUNT_OPAQUE_STRING_GUID)
    {
        pszScheme = INSTALL_REF_OPAQUE_STRING_SCHEME;
    }
    else if(*pGuidScheme==FUSION_REFCOUNT_MSI_GUID)
    {
        pszScheme = INSTALL_REF_MSI_SCHEME;
    }
    else if (*pGuidScheme==FUSION_REFCOUNT_OSINSTALL_GUID)
    {
        pszScheme = INSTALL_REF_OSINSTALL_SCHEME;
    }
    else
    {
        return false; 
    }

    return true;
}


bool GetInstallReferenceFromInput(int currentArg, LPCWSTR argv[], LPFUSION_INSTALL_REFERENCE *ppInstallReference)
{
    bool bRet = true;
    LPFUSION_INSTALL_REFERENCE      pInstallReference       = NULL;

    if (!ppInstallReference || !argv) 
    {
        bRet = false;
        goto exit;
    }

    pInstallReference = new (FUSION_INSTALL_REFERENCE);

    if (!pInstallReference ) 
    {
        // _ftprintf(stderr, _T("OutOfMemory.  Could not create instance of FUSION_INSTALL_REFERENCE\n"));  
        bRet = false;
        goto exit;
    }

    pInstallReference->cbSize= sizeof(FUSION_INSTALL_REFERENCE);
    pInstallReference->dwFlags=0;

    if(!GetGUIDFromInput(argv[currentArg], &(pInstallReference->guidScheme)))
    {
        BSILENT_PRINTF0ARG( "Install Reference has to be one of:\n"
                            "  FILEPATH      <filepath> <data>\n"
                            "  UNINSTALL_KEY <registry key> <data>\n"
                            "  OPAQUE        <identifier> <data>\n"
                          );

        bRet = false;
        goto exit;
    }

    pInstallReference->szIdentifier=argv[currentArg+1];

    pInstallReference->szNonCannonicalData=argv[currentArg+2];

    *ppInstallReference = pInstallReference;

exit:

    if(!bRet && pInstallReference )
        delete pInstallReference;

    return bRet;
}


bool PrintInstallReference(LPFUSION_INSTALL_REFERENCE pInstallReference)
{
    bool bRet = true;
    LPWSTR pszScheme = NULL;

    if (!pInstallReference ) 
    {
        bRet = false;
        goto exit;
    }

    if(!GetInputFromGUID(&pInstallReference->guidScheme, pszScheme))
    {
        bRet = false;
        goto exit;
    }

    if(pszScheme)
    {
        MAKE_ANSIPTR_FROMWIDE_BESTFIT(pszA, pszScheme);
        BSILENT_PRINTF1ARG("              SCHEME: <%s> ", pszA);

    }
    else // it is a fatal error if this is NULL ??
    {
        bRet = false;
        goto exit;
    }

    if(pInstallReference->szIdentifier)
    {
        MAKE_ANSIPTR_FROMWIDE_BESTFIT(pszA, pInstallReference->szIdentifier);
        BSILENT_PRINTF1ARG(" ID: <%s> ", pszA);
    }
    else // it is a fatal error if this is NULL ??
    {
        bRet = false;
        goto exit;
    }

    // this can be null, so an if.
    if(pInstallReference->szNonCannonicalData)
    {
        MAKE_ANSIPTR_FROMWIDE_BESTFIT(pszA, pInstallReference->szNonCannonicalData);
        BSILENT_PRINTF1ARG(" DESCRIPTION : <%s> ", pszA);
    }

    BSILENT_PRINTF0ARG(" \n");

exit:

    if(!bRet && pInstallReference)
        delete pInstallReference;

    return bRet;
}

bool InstallAssembly(LPCWSTR pszManifestFile, LPFUSION_INSTALL_REFERENCE pInstallReference, DWORD dwFlag)
{

    IAssemblyCache*     pCache      = NULL;
    HRESULT             hr          = S_OK;
    
    hr = (*g_pfnCreateAssemblyCache)(&pCache, 0);
    if (FAILED(hr))
    {
        BSILENT_PRINTF0ARG("Failure adding assembly to the cache: ");
        ReportError(hr);
        if (pCache) pCache->Release();
        return false;
    }

    PrintInstallReference(pInstallReference);
    hr = pCache->InstallAssembly(dwFlag, pszManifestFile, pInstallReference);
    if (hr==S_FALSE)
    {
        BSILENT_PRINTF0ARG("Assembly already exists in cache. Use /f option to force overwrite\n");
        pCache->Release();
        return true;
    }
    else
    if (SUCCEEDED(hr))
    {
        BSILENT_PRINTF0ARG("Assembly successfully added to the cache\n");
        pCache->Release();
        return true;
    }
    else
    {
        BSILENT_PRINTF0ARG("Failure adding assembly to the cache: ");
        ReportError(hr);
        pCache->Release();
        return false;
    }

}

bool InstallListOfAssemblies(LPCWSTR pwzAssembliesListFile, LPFUSION_INSTALL_REFERENCE pInstallReference, DWORD dwFlag)
{
    IAssemblyCache*     pCache      = NULL;
    HRESULT             hr          = S_OK;
    HANDLE              hFile       = INVALID_HANDLE_VALUE;
    DWORD               dwTotal     = 0;
    DWORD               dwFailed    = 0;
    DWORD               dwSize      = MAX_PATH;
    WCHAR               wzAsmFullPath[MAX_PATH];
    LPWSTR              wzFileName  = NULL;
    WCHAR               wzPath[MAX_PATH];
    WCHAR               wzAsmName[MAX_PATH];
    CHAR                szAsmName[MAX_PATH];
    CHAR               *tmp;
    DWORD               dwBytesRead = 0;
    BOOL                bRes;
    BOOL                done = FALSE;
    bool                bSucceeded = false;

    DWORD               dwPathLength = 0;
    // get the path of pwzAssembliesListFile
    dwPathLength = WszGetFullPathName(pwzAssembliesListFile, MAX_PATH, wzPath, &wzFileName);
    if (!dwPathLength)
    {
        BSILENT_PRINTF1ARG("Invalid path: %ws \n", pwzAssembliesListFile);
        ReportError(HRESULT_FROM_WIN32(GetLastError()));
        return false;
    }
    else if (dwPathLength > MAX_PATH)
    {
        BSILENT_PRINTF1ARG("File path is too long: %ws \n", pwzAssembliesListFile);
        return false;
    }
    // we only need the path
    *wzFileName = L'\0';

    hFile = WszCreateFile(pwzAssembliesListFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        BSILENT_PRINTF1ARG("Failed to open assemblies list file %ws.", pwzAssembliesListFile);
        return false;
    }

    hr = g_pfnCreateAssemblyCache(&pCache, 0);
    if (FAILED(hr))
    {
        BSILENT_PRINTF0ARG("Failed to add assemblies to the cache: ");
        ReportError(hr);
        goto Exit;
    }
    
    // Installing
    while(!done)
    {
        // get the file name
        tmp = szAsmName;
        *tmp = '\0';
        while(1)
        {
            if (tmp >= szAsmName + MAX_PATH)
            {
                BSILENT_PRINTF0ARG("Invalid assembly filename in input file.\n");
                goto Exit;
            }
            
            bRes = ReadFile( hFile, tmp, 1, &dwBytesRead, NULL);
            if (!bRes)
            {
                BSILENT_PRINTF1ARG("Error reading file %ws.", pwzAssembliesListFile);
                goto Exit;
            }
           
            // end of file
            if (!dwBytesRead) 
            {
                done = TRUE;
                *tmp=0;
                break;
            }
            
            if (*tmp == '\n') 
            {
                *tmp = 0;
                break;
            }
            else if ( *tmp != '\r' && !((*tmp == ' ' || *tmp == '\t')&&( tmp == szAsmName)) ) 
            {
                tmp++;
            }
        }
        
        if (lstrlenA(szAsmName))
        {
            if (!MultiByteToWideChar(CP_ACP, 0, szAsmName, -1, wzAsmName, dwSize))
            {
                //unicode convert failed?
                BSILENT_PRINTF0ARG("Failed to add assemblies to the cache: ");
                ReportError(HRESULT_FROM_WIN32(GetLastError()));
                goto Exit;           
            }

            if (lstrlenW(wzPath) + lstrlenW(wzAsmName) + 1 > MAX_PATH)
            {
                // path too long
                BSILENT_PRINTF0ARG("Invalid assembly filename in input file.\n");
                goto Exit;
            }
             
            if (!PathCombine(wzAsmFullPath, wzPath, wzAsmName))
            {
                BSILENT_PRINTF1ARG("Failed to process assembly %ws.", wzAsmName);
                goto Exit;
            }
            
            // Now install
            dwTotal++;
            PrintInstallReference(pInstallReference);
            hr = pCache->InstallAssembly(dwFlag, wzAsmFullPath, pInstallReference);
            if (hr==S_FALSE)
            {
                BSILENT_PRINTF1ARG("Assembly %ws already exists in cache. Use /f option to force overwrite\n", wzAsmFullPath);
            }
            else
            if (SUCCEEDED(hr))
            {
                BSILENT_PRINTF1ARG("Assembly %ws successfully added to the cache\n", wzAsmFullPath);
            }
            else
            {
                BSILENT_PRINTF1ARG("Failed to add assembly %ws to the cache: ", wzAsmFullPath);
                ReportError(hr);
                dwFailed++;
            }
        }
    }

    if (dwFailed == 0)
        bSucceeded = true;
    
Exit:
    if (pCache)
        pCache->Release();
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    BSILENT_PRINTF0ARG("\n");
    BSILENT_PRINTF1ARG("Number of assemblies processed = %d\n", dwTotal);
    BSILENT_PRINTF1ARG("Number of assemblies installed = %d\n", dwTotal-dwFailed);
    BSILENT_PRINTF1ARG("Number of failures = %d\n", dwFailed);   

    return bSucceeded;
   
}

HRESULT EnumerateActiveInstallRefsToAssembly(IAssemblyName *pName)
{
    HRESULT hr = S_OK;
    IInstallReferenceEnum *pInstallRefEnum = NULL;
    IInstallReferenceItem *pRefItem = NULL;
    LPFUSION_INSTALL_REFERENCE pRefData = NULL;


    hr = (*g_pfnCreateInstallReferenceEnum)(&pInstallRefEnum, pName, 0, NULL);

    while(hr == S_OK)
    {
  

        hr = pInstallRefEnum->GetNextInstallReferenceItem( &pRefItem, 0, NULL);

        if(hr != S_OK)
            break;

        hr = pRefItem->GetReference( &pRefData, 0, NULL);

        if(hr != S_OK)
            break;

        PrintInstallReference(pRefData);
        if (pRefItem)
        {
            pRefItem->Release();
            pRefItem = NULL;
        }
    }

    if (pInstallRefEnum)
    {
        pInstallRefEnum->Release();
        pInstallRefEnum = NULL;
    }

    if (pRefItem)
    {
        pRefItem->Release();
        pRefItem = NULL;
    }

    return hr;
}

HRESULT CopyInstallRef(LPFUSION_INSTALL_REFERENCE pRefDest, LPCFUSION_INSTALL_REFERENCE pRefSrc)
{
    HRESULT hr = S_OK;

    
    if (!pRefDest || !pRefSrc)
        return E_INVALIDARG;

    if (pRefSrc->szIdentifier)
    {
        pRefDest->szIdentifier = new WCHAR[wcslen(pRefSrc->szIdentifier)+1];
        if (!pRefDest->szIdentifier) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        wcscpy((WCHAR*)pRefDest->szIdentifier, pRefSrc->szIdentifier);
    }

    if (pRefSrc->szNonCannonicalData)
    {
        pRefDest->szNonCannonicalData = new WCHAR[wcslen(pRefSrc->szNonCannonicalData)+1];
        if (!pRefDest->szNonCannonicalData) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        wcscpy((WCHAR*)pRefDest->szNonCannonicalData, pRefSrc->szNonCannonicalData);
    }

    pRefDest->cbSize        = sizeof(FUSION_INSTALL_REFERENCE);
    pRefDest->dwFlags       = pRefSrc->dwFlags;
    pRefDest->guidScheme    = pRefSrc->guidScheme;


exit:

    if (FAILED(hr)) {
        if (pRefDest->szIdentifier)
            delete [] pRefDest->szIdentifier;
        if (pRefDest->szNonCannonicalData)
            delete [] pRefDest->szNonCannonicalData;
    }

    return hr;
}


HRESULT DeleteInstallRef(LPFUSION_INSTALL_REFERENCE pInstallRef)
{
    if (!pInstallRef)
        return S_OK;
    
    if (pInstallRef->szIdentifier)
    {
        delete [] pInstallRef->szIdentifier;
        pInstallRef->szIdentifier = NULL;
    }
    
    if (pInstallRef->szNonCannonicalData)
    {
        delete [] pInstallRef->szNonCannonicalData;
        pInstallRef->szNonCannonicalData = NULL;
    }

    delete pInstallRef;
    pInstallRef = NULL;

    return S_OK;
}

HRESULT RemoveInstallRefsToAssembly(IAssemblyCache* pCache, LPCWSTR pszAssemblyName)
{
    HRESULT                     hrTemp              = S_OK;
    HRESULT                     hr                  = S_OK;
    IInstallReferenceEnum       *pInstallRefEnum    = NULL;
    IInstallReferenceItem       *pRefItem           = NULL;
    LPFUSION_INSTALL_REFERENCE  pRefList[MAX_COUNT];
    LPFUSION_INSTALL_REFERENCE  pRefData            = NULL;
    IAssemblyName               *pAsmName           = NULL;
    ULONG                       ulDisp              = 0;
    int                         iNumRefs            = 0;
    bool                        bUsedByMSI          = false;
    bool                        bUsedByOS           = false;
    int                         i                   = 0;

    for (i=0; i<MAX_COUNT; i++)
        pRefList[i] = NULL;

    hr = (*g_pfnCreateAssemblyNameObject)(&pAsmName, pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, NULL);
    if (FAILED(hr))
        return hr;

    hr = (*g_pfnCreateInstallReferenceEnum)(&pInstallRefEnum, pAsmName, 0, NULL);

    //First create list of references

    while(hr == S_OK)
    {
        hr = pInstallRefEnum->GetNextInstallReferenceItem( &pRefItem, 0, NULL);

        if(hr != S_OK)
            break;

        hr = pRefItem->GetReference( &pRefData, 0, NULL);

        if(hr != S_OK)
            break;

        if (pRefData->guidScheme == FUSION_REFCOUNT_MSI_GUID)
        {
            bUsedByMSI = true;
            pRefItem->Release();
            continue;
        }

        if (pRefData->guidScheme == FUSION_REFCOUNT_OSINSTALL_GUID)
        {
            bUsedByOS = true;
            pRefItem->Release();
            continue;
        }

        pRefList[iNumRefs] = new (FUSION_INSTALL_REFERENCE);
        if (!pRefList[iNumRefs]) {
            pRefItem->Release();
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        CopyInstallRef(pRefList[iNumRefs], pRefData);
        
        iNumRefs++;

        if (pRefItem)
        {
            pRefItem->Release();
            pRefItem = NULL;
        }
    }

    if (pRefItem)
    {
        pRefItem->Release();
        pRefItem = NULL;
    }

    if (pInstallRefEnum)
    {
        pInstallRefEnum->Release();
        pInstallRefEnum = NULL;
    }

    //reset hr back to S_OK before start uninstalling
    hr = S_OK;

    if (iNumRefs)
    {
        BSILENT_PRINTF0ARG("Removing references:\n");
    
        for (i=0; i<iNumRefs; i++)
        {
            PrintInstallReference(pRefList[i]);
        
            hrTemp = pCache->UninstallAssembly(0, pszAssemblyName, pRefList[i], &ulDisp);
            if (FAILED(hrTemp))
                hr = hrTemp;
        }
    }

    if (bUsedByMSI)
    {
        //Cannot be uninstalled since referenced by MSI
        BSILENT_PRINTF0ARG("Assembly could not be uninstalled because it is required by Windows Installer\n");
        goto exit;
    }

    if (bUsedByOS)
    {
        BSILENT_PRINTF0ARG("Assembly could not be uninstalled because it is required by the operating system\n");
        goto exit;
    }

    if (SUCCEEDED(hr) && (ulDisp == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES))
    {
        BSILENT_PRINTF0ARG("Unable to remove all install references\n");
        goto exit;
    }

exit:

    if (pAsmName)
    {
        pAsmName->Release();
        pAsmName = NULL;
    }

    for (i=0; i<iNumRefs; i++)
        DeleteInstallRef(pRefList[i]);

    return hr;
}

bool UninstallListOfAssemblies(IAssemblyCache* pCache,
                                         LPWSTR arrpszDispName[],
                                         DWORD dwDispNameCount,
                                         bool bzapCache, 
                                         LPCFUSION_INSTALL_REFERENCE pInstallReference,
                                         bool bRemoveAllRefs,
                                         DWORD *pdwFailures,
                                         DWORD *pdwOmitFromCount)
{
    HRESULT         hr              = S_OK;
    DWORD           dwCount         = 0;
    DWORD           dwFailures      = 0;
    DWORD           dwOmitFromCount = 0;
    bool            bOmit           = false;
    ULONG           ulDisp          = 0;
    IAssemblyName*  pAsmName        = NULL;

    while( dwDispNameCount > dwCount)
    {
        LPWSTR szDisplayName = arrpszDispName[dwCount];
        
        BSILENT_PRINTF1ARG("\nAssembly: %ws\n", szDisplayName);
        
        if (bRemoveAllRefs)
        {
            hr = RemoveInstallRefsToAssembly(pCache, szDisplayName);
            if (FAILED(hr))
            {
                dwFailures++;
                BSILENT_PRINTF1ARG("\nUninstall Failed for: %ws\n", szDisplayName);
                ReportError(hr);
                hr = S_OK;
            }
            else if (hr!=S_OK)
            {
                bOmit = true;
            }
        }
        //Call uninstall with full display name (will always uninstall only 1 assembly)
        hr = pCache->UninstallAssembly(0, szDisplayName, pInstallReference, &ulDisp);
        if (SUCCEEDED(hr) && 
            ((ulDisp == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND) ||
            (ulDisp == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES)))
        {
            if (pInstallReference)
            {    
                if (ulDisp == IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND)
                {
                    BSILENT_PRINTF0ARG("Reference not found:\n");
                    PrintInstallReference((LPFUSION_INSTALL_REFERENCE)pInstallReference);
                }
                else
                {
                    BSILENT_PRINTF0ARG("Removed reference:\n");
                    PrintInstallReference((LPFUSION_INSTALL_REFERENCE)pInstallReference);
                }
            }
            else
            {
                BSILENT_PRINTF0ARG("Unable to uninstall: assembly is required by one or more applications\n");
            }

            BSILENT_PRINTF0ARG("Pending references:\n");
            if (SUCCEEDED(hr = (*g_pfnCreateAssemblyNameObject)(&pAsmName, szDisplayName, CANOF_PARSE_DISPLAY_NAME, NULL)))
            {
                hr = EnumerateActiveInstallRefsToAssembly(pAsmName);
                pAsmName->Release();
                pAsmName = NULL;
            }

            bOmit = true;
        }
        else if (SUCCEEDED(hr))
        {   
            MAKE_ANSIPTR_FROMWIDE_BESTFIT(pszA, szDisplayName);
            BSILENT_PRINTF1ARG("Uninstalled: %s\n", pszA);
        }
        else
        {
            dwFailures++;
            BSILENT_PRINTF1ARG("\nUninstall Failed for: %ws\n", szDisplayName);
            ReportError(hr);
            hr = S_OK;
        }
        dwCount++;
        if (bOmit)
        {
            dwOmitFromCount++;
            bOmit = false;
        }

    }

    *pdwFailures = dwFailures;
    *pdwOmitFromCount = dwOmitFromCount;

    return true;
}

bool UninstallAssembly(LPCWSTR pszAssemblyName, bool bzapCache, LPCFUSION_INSTALL_REFERENCE pInstallReference, bool bRemoveAllRefs)
{
    IAssemblyCache* pCache          = NULL;
    IAssemblyName*  pEnumName       = NULL;
    IAssemblyName*  pAsmName        = NULL;
    IAssemblyEnum*  pEnum           = NULL;
    HRESULT         hr              = S_OK;
    DWORD           dwCount         = 0;
    DWORD           dwFailures      = 0;
    DWORD           dwOmitFromCount = 0;
    LPWSTR          szDisplayName = NULL;
    DWORD           dwLen       = 0;
    DWORD           dwDisplayFlags = ASM_DISPLAYF_VERSION 
                        | ASM_DISPLAYF_CULTURE
                        | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                        | ASM_DISPLAYF_CUSTOM;

    LPWSTR arrpszDispName[MAX_COUNT+1];
    DWORD dwDispNameCount=0;

    memset( (LPBYTE) arrpszDispName, 0, sizeof(arrpszDispName));

    hr = (*g_pfnCreateAssemblyCache)(&pCache, 0);
    if (FAILED(hr))
    {
        BSILENT_PRINTF0ARG("Failure removing assembly from cache: ");
        ReportError(hr);
        return false;
    }
    
    //Name passed in may be partial, therefore enumerate matching assemblies
    //and uninstall each one. Uninstall API should be called with full name ref.

    //Create AssemblyName for enum
    if (hr = (*g_pfnCreateAssemblyNameObject)(&pEnumName, pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, NULL))
    {
        BSILENT_PRINTF0ARG("Failure removing assembly from cache: ");
        ReportError(hr);
        if (pCache) pCache->Release();
        return false;
    }
    

    //
    // For zaps, null out the custom string
    if (bzapCache)
    {
            DWORD dwSize = 0;
            //Check if Custom string has been set
    hr = pEnumName->GetProperty(ASM_NAME_CUSTOM, NULL, &dwSize);

            if (!dwSize)
            {
            //Custom String not set - set to NULL to unset property so lookup is partial
                    pEnumName->SetProperty(ASM_NAME_CUSTOM, NULL, 0);
            }
    }

    hr = (*g_pfnCreateAssemblyEnum)(&pEnum, 
                            NULL, 
                            pEnumName,
                            bzapCache ? ASM_CACHE_ZAP : ASM_CACHE_GAC, 
                            NULL);
    if (hr != S_OK)
    {
        BSILENT_PRINTF1ARG("No assemblies found that match: %ws\n", pszAssemblyName);
    }

    if (pEnumName) pEnumName->Release();

    //Loop through assemblies and uninstall each one
    while (hr == S_OK)
    {
        hr = pEnum->GetNextAssembly(NULL, &pAsmName, 0);
        if (hr == S_OK)
        {
            dwLen = 0;
            hr = pAsmName->GetDisplayName(NULL, &dwLen, dwDisplayFlags);
            if (dwLen)
            {
                szDisplayName = new WCHAR[dwLen+1];
                hr = pAsmName->GetDisplayName(szDisplayName, &dwLen, dwDisplayFlags);
                if (SUCCEEDED(hr))
                {
                    arrpszDispName[dwDispNameCount++] = szDisplayName;
                    szDisplayName = NULL;
                }
                else
                {
                    BSILENT_PRINTF1ARG("Error in IAssemblyName::GetDisplayName (HRESULT=%X)\n",hr);
                }
            }

            if (pAsmName)
            {
                pAsmName->Release();
                pAsmName = NULL;
            }
        }
    }

    if(dwDispNameCount)
    {
        BOOL fRet = UninstallListOfAssemblies(pCache, 
                                         arrpszDispName,
                                         dwDispNameCount, bzapCache,
                                         pInstallReference,
                                         bRemoveAllRefs,
                                         &dwFailures,
                                         &dwOmitFromCount);

    }

    dwCount = 0;
    while(dwDispNameCount > dwCount)
    {
        delete [] arrpszDispName[dwCount];
        arrpszDispName[dwCount] = NULL;
        dwCount++;
    }

    dwCount = dwDispNameCount - dwFailures - dwOmitFromCount;

    if (pEnum) pEnum->Release();

    BSILENT_PRINTF1ARG("\nNumber of items uninstalled = %d\n",dwCount);

    BSILENT_PRINTF1ARG("Number of failures = %d\n\n",dwFailures);

    
    // if everything failed return a 1 return code....
    if ((dwFailures != 0) && (dwCount == 0))
        return false;
    else
        return true;

}

int EnumerateAssemblies(DWORD dwWhichCache, LPCWSTR pszAssemblyName, bool bPrintInstallRefs)
{
    HRESULT                 hr              = S_OK;
    IAssemblyEnum*          pEnum           = NULL;
    IAssemblyName*          pAsmName        = NULL;
    IAssemblyName*           pEnumName       = NULL;
    DWORD                   dwCount         = 0;
    WCHAR*                  szDisplayName   = NULL;
    DWORD                   dwLen           = 0;
    DWORD                   dwDisplayFlags  = ASM_DISPLAYF_VERSION 
                                    | ASM_DISPLAYF_CULTURE 
                                    | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                                    | ASM_DISPLAYF_CUSTOM; 

    if (pszAssemblyName)
    {
            if (FAILED(hr = (*g_pfnCreateAssemblyNameObject)(&pEnumName, pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, NULL)))
            {
                BSILENT_PRINTF0ARG("Failure enumerating assemblies: ");
                ReportError(hr);            
                return false;
            }
    }
    
    hr = (*g_pfnCreateAssemblyEnum)(&pEnum, 
                                    NULL, 
                                    pEnumName,
                                    dwWhichCache, 
                                    NULL);
    while (hr == S_OK)
    {
        hr = pEnum->GetNextAssembly(NULL, &pAsmName, 0);
        if (hr == S_OK)
        {
            dwCount++;
            dwLen = 0;
            hr = pAsmName->GetDisplayName(NULL, &dwLen, dwDisplayFlags);
            if (dwLen)
            {
                szDisplayName = new WCHAR[dwLen+1];
                if (!szDisplayName) {
                    pEnum->Release();
                    pAsmName->Release();
                    BSILENT_PRINTF0ARG("Failure enumerating assemblies. Out of memory.");
                    return 0;
                }

                hr = pAsmName->GetDisplayName(szDisplayName, &dwLen, dwDisplayFlags);
                if (SUCCEEDED(hr))
                {
                    MAKE_ANSIPTR_FROMWIDE_BESTFIT(pszA, szDisplayName);
                    BSILENT_PRINTF1ARG("\t%s\n", pszA);
                }
                else
                {
                    BSILENT_PRINTF1ARG("Error displaying assembly name. HRESULT= %x : ", hr);
                }
                delete [] szDisplayName;
                szDisplayName = NULL;
            }

            if (pAsmName)
            {
                if( (dwWhichCache & ASM_CACHE_GAC) && bPrintInstallRefs)
                {
                    EnumerateActiveInstallRefsToAssembly(pAsmName);
                }

                pAsmName->Release();
                pAsmName = NULL;
            }
        }
    }
    
    if (pEnum)
    {
        pEnum->Release();
        pEnum = NULL;
    }

    if (pEnumName)
    {
        pEnumName->Release();
        pEnumName = NULL;
    }

    return dwCount;
}

bool UninstallListOfAssemblies(LPCWSTR pwzAssembliesListFile, LPFUSION_INSTALL_REFERENCE pInstallReference)
{
    IAssemblyCache     *pCache      = NULL; 
    HRESULT             hr          = S_OK;
    HANDLE              hFile       = INVALID_HANDLE_VALUE;
    DWORD               dwTotal     = 0;
    DWORD               dwSubFail   = 0;
    DWORD               dwFailed    = 0;
    DWORD               dwSize      = MAX_PATH;
    DWORD               dwDisp      = 0;
    WCHAR               wzAsmName[MAX_PATH];
    CHAR                szAsmName[MAX_PATH];
    CHAR               *tmp;
    DWORD               dwBytesRead = 0;
    BOOL                bRes;
    BOOL                done = FALSE;
    bool                bSucceeded = false;

    hFile = WszCreateFile(pwzAssembliesListFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        BSILENT_PRINTF1ARG("Fail to open assemblies list file %ws.", pwzAssembliesListFile);
        return false;
    }

    hr = (*g_pfnCreateAssemblyCache)(&pCache, 0);
    if (FAILED(hr))
    {
        BSILENT_PRINTF0ARG("Failure removing assembly from cache: ");
        ReportError(hr);
        goto Exit;
    }

    // uninstalling
    while(!done)
    {
        // get the assembly display name
        tmp = szAsmName;
        *tmp = '\0';
        while(1)
        {
            if (tmp == szAsmName + MAX_PATH)
            {
                BSILENT_PRINTF0ARG("Invalid assembly display name in input file.\n");
                goto Exit;
            }
            
            bRes = ReadFile( hFile, tmp, 1, &dwBytesRead, NULL);
            if (!bRes)
            {
                BSILENT_PRINTF1ARG("Error reading file %ws.", pwzAssembliesListFile);
                goto Exit;
            }
           
            // end of file
            if (!dwBytesRead) {
                done = TRUE;
                *tmp=0;
                break;
            }

            if (*tmp == '\n') 
            {
                *tmp = 0;
                break;
            }
            else if ( *tmp != '\r' && !((*tmp == ' ' || *tmp == '\t')&&( tmp == szAsmName)) ) 
            {
                tmp++;
            }
        }
        
        if (lstrlenA(szAsmName))
        {
            if (!MultiByteToWideChar(CP_ACP, 0, szAsmName, -1, wzAsmName, dwSize))
            {
                //unicode convert failed?
                BSILENT_PRINTF0ARG("Fail to add assemblies to the cache: ");
                ReportError(HRESULT_FROM_WIN32(GetLastError()));
                goto Exit;           
            }

            BSILENT_PRINTF1ARG("\nAssembly: %ws\n", wzAsmName);

            dwTotal++;
            hr = pCache->UninstallAssembly(0, wzAsmName, pInstallReference, &dwDisp);
            if (FAILED(hr))
            {
                dwFailed++;
                BSILENT_PRINTF1ARG("\nUninstall Failed for: %ws\n", wzAsmName);
                ReportError(hr);
            }
            else if (hr == S_FALSE)
            {
                switch (dwDisp)
                {
                    case IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND:
                        BSILENT_PRINTF0ARG("Reference not found:\n");
                        PrintInstallReference((LPFUSION_INSTALL_REFERENCE)pInstallReference);
                        dwFailed++;
                        break;
                    case IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES:
                        if (pInstallReference)
                        {
                            BSILENT_PRINTF0ARG("Removed reference:\n");
                            PrintInstallReference((LPFUSION_INSTALL_REFERENCE)pInstallReference);
                        }
                        else
                        {
                            BSILENT_PRINTF0ARG("Unable to uninstall: assembly is required by one or more applications\n");
                            dwFailed++;
                        }
                        break;
                    case IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED:
                        BSILENT_PRINTF1ARG("No assemblies found matching: %ws\n", wzAsmName);
                        dwFailed++;
                        break;
                    default:
                        break;
                }
            }
            else 
            {
                BSILENT_PRINTF1ARG("Uninstalled: %ws\n", wzAsmName);
            }
        }              
    }

    if (dwFailed == 0)
        bSucceeded = true;

Exit:
    if (pCache != NULL)
        pCache->Release();
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    
    BSILENT_PRINTF0ARG("\n");
    BSILENT_PRINTF1ARG("Number of assemblies processed = %d \n", dwTotal);
    BSILENT_PRINTF1ARG("Number of assemblies uninstalled = %d \n", dwTotal - dwFailed);
    BSILENT_PRINTF1ARG("Number of failures = %d \n", dwFailed);

    return bSucceeded;
}

bool ClearDownloadCache()
{

    HRESULT hr = (*g_pfnNukeDownloadCache)();

    if (FAILED(hr))
    {
        BSILENT_PRINTF0ARG("Error deleting contents of the download cache: ");
        ReportError(hr);
        return false;
    }
    else
    {
        BSILENT_PRINTF0ARG("Download cache deleted successfully\n");
    }

        return true;
}


//
// Command line parsing code...
//

#define CURRENT_ARG_STRING &(argv[currentArg][1])

bool ValidSwitchSyntax(int currentArg, LPCWSTR argv[])
{
    if ((argv[currentArg][0] == L'-') || (argv[currentArg][0] == L'/')) 
    {
        return true;
    }
    else
    {
        return false;
    }
}

void SetDisplayOptions(int argc, LPCWSTR argv[])
{
        for(int currentArg = 1; currentArg < argc; currentArg++)
        {
                // only check switches
                if ((argv[currentArg][0] == L'-') || (argv[currentArg][0] == L'/'))  
                {
                        if (_wcsicmp(CURRENT_ARG_STRING, L"nologo") == 0) g_bdisplayLogo = false;
                        if (_wcsicmp(CURRENT_ARG_STRING, L"silent") == 0) g_bSilent = true;
                }
        }

}

bool CheckArgs(int currentArg, int argsRequired, int argCount, LPCWSTR argv[], bool bShowError)
{
    assert(argCount >= 2); // if we got this far, we've got at least 2 args.

    if (argCount <= currentArg + argsRequired)
    {
        if (bShowError)
        {
            if (argsRequired == 1)
            {
                BSILENT_PRINTF1ARG("Option %ws takes 1 argument\n", argv[currentArg]);
            }
            else
            {
                BSILENT_PRINTF2ARG("Option %ws takes %i arguments\n", argv[currentArg], argsRequired);
            }
        }
        return false;
    }

    for (int i = 1; i <= argsRequired; i++)
    {
        // What? Switch found when argument expected.
        if (ValidSwitchSyntax(currentArg+i, argv))
        {
            if (bShowError)
            {
                if (argsRequired == 1)
                {
                    BSILENT_PRINTF1ARG("Option %ws takes 1 argument\n", argv[currentArg]);
                }
                else
                {
                    BSILENT_PRINTF2ARG("Option %ws takes %i arguments\n", argv[currentArg], argsRequired);
                }
            }
            return false;
        }
    }

    return true;
}

bool CheckArgs(int currentArg, int argsRequired, int argCount, LPCWSTR argv[])
{
    return CheckArgs(currentArg, argsRequired, argCount, argv, true);
}

bool ParseArguments(int argc, LPCWSTR argv[])
{
    int currentArg = 1;         // skip the name of the program

    while ((currentArg < argc))
    {
        if (!ValidSwitchSyntax(currentArg, argv))
        {
            BSILENT_PRINTF1ARG("Unknown option: %ws\n", argv[currentArg]);
            return false;
        }

        if (_wcsicmp(CURRENT_ARG_STRING, L"i") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
                return false;
          
            if (g_bInstall)
            {
                BSILENT_PRINTF1ARG("Duplicate command %ws.\n", argv[currentArg]);
                return false;
            }
            g_bInstall = 1;
            g_pAsmFileName = argv[currentArg+1];
            currentArg += 2;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"f") == 0)
        {
            g_bForceInstall = 1;
            currentArg++; 
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"r") == 0)
        {
            if (!CheckArgs(currentArg, 3 , argc, argv)) 
               return false;

            if (g_pInstallReference)
            {
                BSILENT_PRINTF0ARG("Duplicate option /r.\n");
                return false;
            }

            if(!GetInstallReferenceFromInput(currentArg+1, argv, &g_pInstallReference))
                return false;

            currentArg+= 4; 
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"il") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
                return false;
            
            if (g_bInstallList)
            {
                BSILENT_PRINTF0ARG("Duplicate command /il.\n");
                return false;
            }          
            g_bInstallList = 1;
            g_pAsmListFileName = argv[currentArg+1];
            
            currentArg += 2;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"u") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
                return false;
            
            if (g_bUninstall)
            {
                BSILENT_PRINTF0ARG("Duplicate command /u.\n");
                return false;
            }   

            g_bUninstall = 1;
            g_pAsmDisplayName = argv[currentArg + 1];
            currentArg += 2;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"uf") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
               return false;

            if (g_bUninstallAllRefs)
            {
                BSILENT_PRINTF0ARG("Duplicate command /uf.\n");
                return false;
            }
            
            g_bUninstallAllRefs = 1;
            g_pAsmDisplayName = argv[currentArg + 1];
            currentArg += 2;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"ungen") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
               return false;
            
            if (g_bUninstallNgen)
            {
                BSILENT_PRINTF0ARG("Duplicate command /ungen.\n");
                return false;
            }           

            g_bUninstallNgen = 1;
            g_pAsmDisplayName = argv[currentArg + 1];
            currentArg += 2; 
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"ul") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
                return false;
            
            if (g_bUninstallList)
            {
                BSILENT_PRINTF0ARG("Duplicate command /ul.\n");
                return false;
            }               
            g_bUninstallList = 1;
            g_pAsmListFileName = argv[currentArg + 1];
            currentArg += 2;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"l") == 0) 
        {
            bool bNameSpecified = false;
            
            if (CheckArgs(currentArg, 1, argc, argv, false))
                bNameSpecified = true;

            if (g_bListAsm)
            {
                BSILENT_PRINTF0ARG("Duplicate command /l.\n");
                return false;
            }
            
            g_bListAsm = 1;
            if (bNameSpecified)
            {
                g_pAsmDisplayName = argv[currentArg + 1];
                currentArg += 2;
            }
            else
                currentArg++;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"lr") == 0) 
        {
            bool bNameSpecified = false;
            
            if (CheckArgs(currentArg, 1, argc, argv, false))
                bNameSpecified = true;

            if (g_bListAsmRefs)
            {
                BSILENT_PRINTF0ARG("Duplicate command /lr.\n");
                return false;
            }

            g_bListAsmRefs = 1;
            if (bNameSpecified)
            {
                g_pAsmDisplayName = argv[currentArg + 1];
                currentArg += 2;
            }
            else
                currentArg++;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"ldl") == 0)
        {
            if (g_bListDLCache)
            {
                BSILENT_PRINTF0ARG("Duplicate command /ldl.\n");
                return false;
            }
            g_bListDLCache = 1;
            currentArg++;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"cdl") == 0)
        {
            if (g_bNukeDLCache)
            {
                BSILENT_PRINTF0ARG("Duplicate command /cdl.\n");
                return false;
            }
            g_bNukeDLCache = 1;
            currentArg++;
        }
        else if ((_wcsicmp(CURRENT_ARG_STRING, L"nologo") == 0) || (_wcsicmp(CURRENT_ARG_STRING, L"silent") == 0))
        {
            // just skip it.
            currentArg++;
        }
        else if ((_wcsicmp(CURRENT_ARG_STRING, L"?") == 0) || (_wcsicmp(CURRENT_ARG_STRING, L"h") ==0))
        {
            g_bPrintHelp = true;
            return true;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"upre") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
               return false;
            
            if (g_bUninstallNgen)
            {
                BSILENT_PRINTF0ARG("Duplicate command /upre.\n");
                return false;
            }
           
            g_bUninstallNgen = 1;
            g_pAsmDisplayName = argv[currentArg + 1];
            currentArg += 2; 
        }   
        else if (_wcsicmp(CURRENT_ARG_STRING, L"ur") == 0)
        {
            if (!CheckArgs(currentArg, 4, argc, argv))
                return false;

            if (g_bUninstall)
            {
                BSILENT_PRINTF0ARG("Duplicate command /u.");
                return false;
            }

            if(!GetInstallReferenceFromInput(currentArg+2, argv, &g_pInstallReference))
                return false;

            g_bUninstall = 1;
            g_pAsmDisplayName = argv[currentArg + 1];
            currentArg += 5;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"ir") == 0)
        {
            if (!CheckArgs(currentArg, 4, argc, argv))
                return false;

            if (g_bInstall)
            {
                BSILENT_PRINTF0ARG("Duplicate command /i.");
                return false;
            }

            if(!GetInstallReferenceFromInput(currentArg+2, argv, &g_pInstallReference))
                return false;

            g_bInstall = 1;
            g_pAsmFileName = argv[currentArg + 1];
            currentArg += 5;
        }
        else if (_wcsicmp(CURRENT_ARG_STRING, L"if") == 0)
        {
            if (!CheckArgs(currentArg, 1, argc, argv))
                return false;

            if (g_bInstall)
            {
                BSILENT_PRINTF0ARG("Duplicate command /i.");
                return false;
            }

            g_bInstall = 1;
            g_bForceInstall = true;
            g_pAsmFileName = argv[currentArg + 1];
            currentArg += 2;
        }
        else
        {
            BSILENT_PRINTF1ARG("Unknown option: %ws\n", argv[currentArg]);
            return false;
        }
    }

    return true;
}

bool Run()
{
    if (g_bPrintHelp)
    {
        LongUsage();
        return true;
    }

    INT totalCommands = g_bInstall + g_bInstallList + g_bUninstall 
                + g_bUninstallNgen + g_bUninstallList + g_bListAsm 
                + g_bListAsmRefs + g_bListDLCache + g_bNukeDLCache
                + g_bUninstallAllRefs;

    if (totalCommands == 0)
    {
        // nothing to do
        return true;
    }

    if (totalCommands > 1)
    {
        BSILENT_PRINTF0ARG("Error: multiple commands encountered. Only one command can be specified\n");
        return false;
    }

    DWORD dwFlag = IASSEMBLYCACHE_INSTALL_FLAG_REFRESH;

    if (g_bForceInstall)
        dwFlag = IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH;   

    if (g_bInstall)
    {
        return InstallAssembly(g_pAsmFileName, g_pInstallReference, dwFlag);
    }

    if (g_bInstallList)
    {
        return InstallListOfAssemblies(g_pAsmListFileName, g_pInstallReference, dwFlag);
    }

    if (g_bUninstall)
    {
        return UninstallAssembly(g_pAsmDisplayName, false, g_pInstallReference, false);
    }

    if (g_bUninstallNgen)
    {
        return UninstallAssembly(g_pAsmDisplayName, true, NULL, false);
    }

    if (g_bUninstallAllRefs)
    {
        return UninstallAssembly(g_pAsmDisplayName, false, NULL, true);
    }

    if (g_bUninstallList)
    {
        return UninstallListOfAssemblies(g_pAsmListFileName, g_pInstallReference);
    }

    if (g_bListAsm || g_bListAsmRefs)
    {
        bool bPrintRefs = g_bListAsmRefs?true:false;
        BSILENT_PRINTF0ARG("The Global Assembly Cache contains the following assemblies:\n");
        int gacCount = 0;
        gacCount = EnumerateAssemblies(ASM_CACHE_GAC, g_pAsmDisplayName, bPrintRefs);

        BSILENT_PRINTF0ARG("\nThe cache of ngen files contains the following entries:\n");
        int zapCount = 0;
        zapCount = EnumerateAssemblies(ASM_CACHE_ZAP, g_pAsmDisplayName, false);

        BSILENT_PRINTF0ARG("\n");
        BSILENT_PRINTF1ARG("Number of items = %d\n",gacCount+zapCount);
        return true;
    }

    if (g_bListDLCache)
    {
        BSILENT_PRINTF0ARG("\nThe cache of downloaded files contains the following entries:\n");
        int dlCount = 0;
        dlCount = EnumerateAssemblies(ASM_CACHE_DOWNLOAD, NULL, false);

        BSILENT_PRINTF0ARG("\n");
        BSILENT_PRINTF1ARG("Number of items = %d\n",dlCount);
        return true;
    }

    if (g_bNukeDLCache)
    {
        return ClearDownloadCache();
    }

    return true;
}

int __cdecl wmain(int argc, LPCWSTR argv[])
{
    // Initialize Wsz wrappers.
    OnUnicodeSystem();
    
    // Initialize Fusion
    if (!FusionInit())
    {
        printf("Falure initializing gacutil\n");
        return 1;
        }

    bool bResult = true;

    if ((argc < 2) || (!ValidSwitchSyntax(1, argv))) 
    {
        Title();
        ShortUsage();
        return 1;
    }

    SetDisplayOptions(argc, argv); // sets g_bdisplayLogo and g_bSilent
    if (g_bdisplayLogo)
    {
       Title();
    }
    
    bResult = ParseArguments(argc, argv);

    if (bResult)
    {
        bResult = Run();
    }

    if (g_pInstallReference)
        delete g_pInstallReference;

    return bResult ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\holler\holler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <sql.h>
#include <sqlext.h>
#include <stdio.h>
#include <stdlib.h>
#include "maillib.h"

RETCODE DoWork(HSTMT hstmt, bool bSummary);
RETCODE PrintODBCErrors(HDBC hdbc, HSTMT hstmt);

int usage()
{
    printf("holler.exe [options]\n");
    printf("  -confirm                  Send confirm email to verify its working.\n");
    printf("\n");
    return -1;
}

int __cdecl main(int argc, char *argv[])
{
    int         iRtn = 0;

    HENV        henv = 0;
    HDBC        hdbc = 0;
    HSTMT       hstmt = 0;
    int         FromTime = 6;
    int         ToTime = 20;
    RETCODE     rc = 0;
    bool        bSendConfirmMail = false;
    bool        bWeekends = false;
    bool        bSummary = false;

    for (int i=1;  i<argc;  i++)
    {
        char * str = argv[i];
        if (*str == '-' || *str == '/')
        {
            if (_stricmp(str + 1, "confirm") == 0)
                bSendConfirmMail = true;
            else if (_stricmp(str + 1, "from:") == 0)
            {
                int ft = atoi(str + 6);
                if (ft < 1 || ft > 23)
                    printf("Invalid from time: %d\n", ft);
                else
                    FromTime = ft;
            }
            else if (_stricmp(str + 1, "to:") == 0)
            {
                int tt = atoi(str + 4);
                if (tt < 1 || tt > 23)
                    printf("Invalid to time: %d\n", tt);
                else
                    ToTime = tt;
            }
            else if (_stricmp(str + 1, "summary") == 0)
                bSummary = true;
            else if (_stricmp(str + 1, "weekends") == 0)
                bWeekends = true;
        }
    }
    
    // Don't run on Saturday & Sunday
	SYSTEMTIME st;
    GetLocalTime(&st);
    if (bWeekends == false && (st.wDayOfWeek == 0 || st.wDayOfWeek == 6))
    {
        printf("Its the %d day of the week, no howler on Sat or Sun.\n", st.wDayOfWeek);
        return 0;
    }

    if (FromTime >= ToTime)
    {
        printf("Invalid time range.\n");
        return usage();
    }
    
    rc = SQLAllocEnv(&henv);
    if (rc != 0)
        printf("SQLAllocEnv failed %d\n");

    rc = SQLAllocConnect(henv, &hdbc);
    if (rc != 0)
        printf("SQLAllocConnect failed %d\n");
    
    rc = SQLConnect(hdbc, (unsigned char *) "Apps Server/Univ RunTime:Raid4", -3,
                (unsigned char *) "AppsS_ro", -3, (unsigned char *) "RuihqAFY", -3);
    if (rc != 0 && rc != 1)
    {
        // @Todo: print errors:
        printf("SQLConnect failed:  %d\n", rc);
        PrintODBCErrors(hdbc, 0);
        goto ErrExit;
    }
    rc = SQLAllocStmt(hdbc, &hstmt);

    rc = DoWork(hstmt, bSummary);

ErrExit:
    if (hstmt)
        SQLFreeStmt(hstmt, SQL_DROP);

    if (hdbc)
    {
        SQLDisconnect(hdbc);
        SQLFreeConnect(hdbc);
    }
    SQLFreeEnv(henv);
    return iRtn;
}

RETCODE DoWork(HSTMT hstmt, bool bSummary)
{
    int         bugs = 0;
    long        cb;
    RETCODE     rc;
    ULONG       ulRet;
	SYSTEMTIME st;
	
    printf("Commencing database loop\n");
    GetLocalTime(&st);

    enum
    {
        COL_BUGID = 1,
        COL_ASSIGNEDTO,
        COL_TITLE,
        COL_CHANGEDDATE,
        COL_CHANGEDBY,
        COL_DESCRIPTION
    };

    struct BUGDATA
    {
        unsigned BugId;
        char    rcAssignedTo[64];
        char    rcTitle[255];
        char    rcDescription[64*1024];
    } bug;

    char        rcSubject[512];
    char        rcMsg[68*1024];
    char        *rcBigBuffer = (char *) malloc(128 * 1024);
    char        *szBuffer = rcBigBuffer;

    static const char *szQuery = "select " \
        "bugid, assignedto, title, changeddate, changedby, description " \
        "from bugs "\
        "where (substatus = 'HotFix' or Milestone = 'Now') " \
        "      and status = 'Active' order by assignedto";
/*        "      and status = 'Active' and project = 'COM+ Runtime' order by assignedto"; */

    rc = SQLExecDirect(hstmt, (unsigned char *) szQuery, -3);
    if (rc != 0)
    {
        printf("SQLExecDirect failed: %d\n", rc);
        PrintODBCErrors(0, hstmt);
    }

    while (0 == (rc = SQLFetch(hstmt)))
    {
        ++bugs;
        rc = SQLGetData(hstmt, COL_BUGID, SQL_C_ULONG, &bug.BugId, sizeof(int), &cb);
        rc = SQLGetData(hstmt, COL_ASSIGNEDTO, SQL_C_CHAR, bug.rcAssignedTo, 64, &cb);
        rc = SQLGetData(hstmt, COL_TITLE, SQL_C_CHAR, bug.rcTitle, 255, &cb);
        rc = SQLGetData(hstmt, COL_DESCRIPTION, SQL_C_CHAR, bug.rcDescription, 64*1024, &cb);

        printf("\n");
		wsprintf(rcMsg, "%d: %s, %s\n", bug.BugId, bug.rcAssignedTo, bug.rcTitle);
        strcpy(szBuffer, rcMsg);
        szBuffer += strlen(szBuffer);
        printf(rcMsg);

        if (_stricmp(bug.rcAssignedTo, "VCExtern") == 0 ||
            _stricmp(bug.rcAssignedTo, "VBExtern") == 0 ||
            _stricmp(bug.rcAssignedTo, "CoolExtern") == 0 ||
            _stricmp(bug.rcAssignedTo, "DNAExtrn") == 0 ||
            _stricmp(bug.rcAssignedTo, "VSExternal") == 0 ||
            _stricmp(bug.rcAssignedTo, "FusionExtern") == 0 ||
            _stricmp(bug.rcAssignedTo, "#BugPortApp") == 0 ||
            _stricmp(bug.rcAssignedTo, "OSExtern") == 0)
        {
            printf("bug skipped, not assigned to a human.\n");
            continue;
        }

        wsprintf(rcSubject, "Hot fix! %d, %s,  %s", 
						bug.BugId, bug.rcAssignedTo, bug.rcTitle);
        wsprintf(rcMsg, "This is an automated bug auditing message.  " \
                        "Bug %d is active and assigned to %s.  Hot fix bugs " \
                        "must be fixed in a 24-hour period.  Please resolve asap." \
                        "\n\nDescription:\n%s", bug.BugId, bug.rcAssignedTo, bug.rcDescription);


        char rcTo[128];
        char *szUser = bug.rcAssignedTo;
        if (_stricmp(bug.rcAssignedTo, "active") == 0)
            szUser = "korys";
        wsprintf(rcTo, "SMTP:%s@microsoft.com", szUser);
        rcTo[strlen(rcTo) + 1] = 0;

        printf("Sending mail to:  %s...", rcTo);
        if (!bSummary)
            ulRet = MailTo(szUser, rcTo, "", "", rcSubject, rcMsg, 0, MAIL_VERBOSE);
        printf("  (return code: %08x)\n", ulRet);
    }

    wsprintf(rcSubject, "%d hot fix bugs as of %02d:%02d %s", 
                bugs,
                (st.wHour) > 12 ? st.wHour - 12 : st.wHour, st.wMinute,
                (st.wHour > 12) ? "PM" : "AM");
    ulRet = MailTo("jasonz", "jasonz", "", "", rcSubject, rcBigBuffer, 0, MAIL_VERBOSE);

    rc = SQLFreeStmt(hstmt, SQL_CLOSE);
    return rc;
}


RETCODE PrintODBCErrors(HDBC hdbc, HSTMT hstmt)
{
    char        rcState[32];
    SQLINTEGER  NativeError;
    char        rcMsg[1024];
    SQLSMALLINT cbTextLength;
    RETCODE     rc;

    printf("ODBC Errors:\n");

    if (hdbc)
    {
        printf("  Connection errors:\n");
        while ((rc = SQLError(0, hdbc, 0, (unsigned char *) rcState, &NativeError, 
                              (unsigned char *) rcMsg, sizeof(rcMsg), &cbTextLength)) == 0)
        {
            printf("     ODBC Error [%s]: %s\n", rcState, rcMsg);
        }
    }

    if (hstmt)
    {
        printf("  Statement errors:\n");
        while ((rc = SQLError(0, 0, hstmt, (unsigned char *) rcState, &NativeError, 
                              (unsigned char *) rcMsg, sizeof(rcMsg), &cbTextLength)) == 0)
        {
            printf("     ODBC Error [%s]: %s\n", rcState, rcMsg);
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\holler\maillib.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// maillib.cpp
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// MailTo - Command line mailer and MAPI helper using exchange.
//
// MailTo provides a simple solution for programmatic and command
//	line mail needs. I've written one function (MailTo) that takes
//	all required input needed for mailing text and/or attachments.
//	I use the MAPI functions, MAPILogon, MAPISendMail, and MAPILogoff
//	to handle the task. MailTo calls the function GetUserProfile that
//	gets the user's exchange ID out of the registry. There may be a
//	simpler way to do this, but this way works for both NT and Win95.
//	Notes: To use this the user must have exchange installed and all
//	mail is sent from the default profile on the user's account. All
//	recipient strings and file name strings are to have each field
//	delimited by a null character and the string terminated with a
//	double null character. I did this to be consistent with the common
//	file dialogs.
//	Much of what is in this program was lifted from two other programs.
//	Execmail by someone unknown and modified by JasonS was used primarily
//	for the ArgIndex function and the Usage function which were lifted
//	with minimal changes. I also borrowed and modified the string parsing
//	code. This project originally started as a modification to Sndmail
//	by DanHoe.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <mapi.h>
#include <time.h>
#include "maillib.h"


///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// GetUserProfile - gets the User ID from the registry
//	This is not really related to the MAPI stuff,
//	but the programmer will need to know how to get
//	the user ID in order to ship mail.
//
//	Input:	szUid - Character buffer with enough space allocated for the user ID
//	Output:	szUid - Character buffer filled with user ID
//	Returns:TRUE for success, FALSE for failure
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

BOOL GetUserProfile(char *szUid)
{
	HKEY	hRegKey;
	DWORD	cchUid = MAX_LENGTH;
	BOOL	bRet = FALSE;

	// Try to open the Win 95 registry entry
	if (ERROR_SUCCESS != RegOpenKeyEx(	HKEY_CURRENT_USER,
										WIN95_REG_KEY,
										0,
										KEY_READ,
										&hRegKey)) {
		// Try to open the NT registry entry
		if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
										WINNT_REG_KEY,
										0,
										KEY_READ,
										&hRegKey)) {
			printf("Could not open user profile in registry.\n");
			goto Ret;
		}
	}
	if (ERROR_SUCCESS != RegQueryValueEx(hRegKey,
										"DefaultProfile",
										NULL,
										NULL,
										(unsigned char *) szUid,
										&cchUid)) {
		printf("Could not retrieve user profile from registry.\n");
		goto Ret;
	}

	bRet = TRUE;
Ret:
	RegCloseKey(hRegKey);
	return bRet;
}

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// MailTo - Logs into MAPI, sends mail, and logs out
//	This is the meat of the beast. MailTo handles
//	everything you need to do to send mail.
//
//	The function performs everything in 11 easy steps:
//		1)	Load the MAPI DLL and function pointers - Do
//			 this first, because if the library doesn't
//			 load or the functions can't be found then
//			 there's no point in continuing.
//		2)	Load User Name - This calls GetUserProfile
//			 which loads the "DefaultProfile" value out
//			 of the "Windows Messaging Subsystem" key in
//			 the registry.
//		3)	Load the recipient data - This part handles
//			 parsing the szRecip parameter and loading
//			 the rgmRecip array. The two parts of this
//			 structure of concern are ulRecipClass which
//			 should be set to MAPI_TO and lpszName which
//			 should be loaded with each name. There is a
//			 trick to loading this data. The mMessage struct
//			 contains a pointer to the rgmRecip array and a
//			 count of all recipients. This includes the CC
//			 and BCC recipients so make sure	you don't reset
//			 the count.
//		4)	Load the carbon copy data - This is nearly
//			 identical to part 4. The only difference is that
//			 you must set ulRecipClass to MAPI_CC and load the
//			 names from szCC.
//		5)	Load the blind carbon copy data - This is nearly
//			 identical to part 4. The only difference is that
//			 you must set ulRecipClass to MAPI_BCC and load the
//			 names from szBCC.
//		6)	Load the attachment data - This is also nearly
//			 identical to part 4. Here we're dealing with a
//			 different array (rgmFileDesc). The only part of
//			 this structure that is of any real interest is
//			 lpszPathName. This should contain the path to the
//			 file and the file name. If the path and filename
//			 were separated for some reason you could load this
//			 with just the path and lpszFileName with just the
//			 filename.
//		7)	Load recipients into message - The message contains
//			 a pointer to all recipients (including CC and BCC)
//			 and I attach that to mMessage here. Don't forget to
//			 make sure nRecipCount is equal to the number of all
//			 normal recipients, CC recipients, and BCC recipients.
//		8)	Load filenames into message -  The message contains
//			 a pointer to all file attachements and I attach that
//			 to mMessage here. Don't forget to make sure nFileCount
//			 is equal to the number of all attached files.
//		9)	Log in - This is time consuming. If you need to send
//			 a lot of mail do this once at the beginning instead.
//		10)	Send the mail - Yea!!!
//		11)	Log off - Only log off once per log in
//
//	Inputs:	szRecip	- Character buffer containing names of all recipients
//			szCC - Character buffer containing names of all CC'd recipients
//			szBCC - Character buffer containing names of all BCC'd recipients
//			szSubject - Character buffer containing subject line
//			szMessage - Character buffer containing message text
//			szFileName - Character buffer containing names of all file attachments
//		Note: szRecip is required to have at least one receiver name. szRecip, szCC,
//			and szBCC may have more than one name. Each name must be separated by
//			a null character and the last name must have a null character (other
//			than the normal end of string null character) after it. For example:
//			"User One\0User Two\0User Last\0". The file attachments must also be
//			separated with a null character. If no CC's, BCC's, or Files need to
//			be sent then the string may be empty.
//	Output:	-
//	Returns:TRUE for success, FALSE for failure
//
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////



ULONG MailTo(
            char *szDisplayName,    // NULL delimited display name
            char *szRecip,			// NULL delimited recipient list (one or more)
			char *szCC,				// NULL delimited CC list (zero or more)
			char *szBCC,			// NULL delimited BCC list (zero or more)
			char *szSubject,		// subject (may be empty string)
			char *szMessage,		// message text (may be empty string)
			char *szFileName,		// NULL delimited file attachment names (zero or more)
			unsigned int dwOptions)	// Options - currently ignored
{
	HINSTANCE		hLib;
	typedef HANDLE FAR PASCAL FUNCMAPILOGON(ULONG			ulUIParam,
											LPTSTR			lpszProfileName,
											LPTSTR			lpszPassword,
											FLAGS			flFlags,
											ULONG			ulReserved,
											LPLHANDLE		lplhSession);
	FUNCMAPILOGON	*pfnMAPILogon;
	typedef HANDLE FAR PASCAL FUNCMAPISENDMAIL(LHANDLE		lhSession,
											ULONG			ulUIParam,
											lpMapiMessage	lpMessage,
											FLAGS			flFlags,
											ULONG			ulReserved);
	FUNCMAPISENDMAIL	*pfnMAPISendMail;
	typedef HANDLE FAR PASCAL FUNCMAPILOGOFF(LHANDLE		lhSession,
											ULONG			ulUIParam,
											FLAGS			flFlags,
											ULONG			ulReserved);
	FUNCMAPILOGOFF	*pfnMAPILogoff;
	//FARPROC			fnMAPISendMail;
	//FARPROC			fnMAPILogon;
	//FARPROC			fnMAPILogoff;
	MapiRecipDesc	rgmRecip[30];			// recipient array
	MapiFileDesc	rgmFileDesc[30];		// file array
	BOOL			bFiles = FALSE;			// are there any file attachments
	MapiMessage		mMessage = {0L,			// Reserved
								szSubject,	// Subject line
								szMessage,	// Message text
								NULL,		// Message type (NULL is normal)
								NULL,		// Date received (not appropriate for sending)
								NULL,		// Conversation ID (I don't use this)
								0L,			// Flags (see MapiMessage for a description)
								NULL,		// Recipient descriptor (NULL is normal)
								0L,			// Recipient count (initialized to zero)
								NULL,		// Pointer to recipient array (assigned in step 8)
								0L,			// File count (initialized to zero)
								NULL};		// Pointer to file array (assigned in step 9)
	char			szMailName[MAX_LENGTH];
	LHANDLE			hSession;
	LONG			errSendMail;
	char			szBuf[MEGA_LENGTH];		// I cheated - you might want to dynamically
											//				allocate this

	ULONG			ulRet = SUCCESS_SUCCESS;

//1	////////////////////
	// Load the MAPI DLL and function pointers
	hLib = LoadLibrary("mapi32.dll");
	if(hLib == NULL) {
		ulRet |= MAPI_E_FAILURE;
		if(dwOptions |= MAIL_VERBOSE) {
			printf("Could not find mapi32.dll.\nBe sure it is in your path.\n");
		}
		goto Ret;
	}

	pfnMAPILogon = (FUNCMAPILOGON *) GetProcAddress(hLib, "MAPILogon");
	pfnMAPISendMail = (FUNCMAPISENDMAIL *) GetProcAddress(hLib, "MAPISendMail");
	pfnMAPILogoff = (FUNCMAPILOGOFF *) GetProcAddress(hLib, "MAPILogoff");

//2	/////////////////
	// Load User Name
	if (!GetUserProfile(szMailName)) {
		ulRet |= MAPI_E_FAILURE;
		if(dwOptions |= MAIL_VERBOSE) {
			printf("Could not get User Name. Be sure you have installed Exchange.\n");
		}
		goto Ret;
	}

//3	//////////////////////////
	// Load the Recipient data
	if(szRecip == NULL) {
		ulRet |= MAPI_E_UNKNOWN_RECIPIENT;
		if(dwOptions |= MAIL_VERBOSE) {
			printf("You must specify a recipient.\n");
		}
		goto Ret;
	}
	while (szRecip[0] != '\0' && mMessage.nRecipCount < 30) {
		// Load the recipient array element
		rgmRecip[mMessage.nRecipCount].ulReserved = 0;
		rgmRecip[mMessage.nRecipCount].ulRecipClass = MAPI_TO;
		rgmRecip[mMessage.nRecipCount].lpszName = szDisplayName;
        rgmRecip[mMessage.nRecipCount].lpszAddress = 0;
        if (strchr(szRecip, '@') != 0)
		    rgmRecip[mMessage.nRecipCount].lpszAddress = szRecip;
		rgmRecip[mMessage.nRecipCount].ulEIDSize = 0;
		rgmRecip[mMessage.nRecipCount].lpEntryID = NULL;

		// Increment recipient count
		mMessage.nRecipCount++;
		// Move to next name in list
		do {
			szRecip++;
		} while (szRecip[0] != '\0');
		szRecip++;
	}

//4	////////////////////////////
	// Load the Carbon Copy data
	if(szCC != NULL) {
		while (szCC[0] != '\0' && mMessage.nRecipCount < 30) {
			// Load the recipient array element
			rgmRecip[mMessage.nRecipCount].ulReserved = 0;
			rgmRecip[mMessage.nRecipCount].ulRecipClass = MAPI_CC;
			rgmRecip[mMessage.nRecipCount].lpszName = szCC;
			rgmRecip[mMessage.nRecipCount].lpszAddress = NULL;
			rgmRecip[mMessage.nRecipCount].ulEIDSize = 0;
			rgmRecip[mMessage.nRecipCount].lpEntryID = NULL;

			// Increment recipient count
			mMessage.nRecipCount++;
			// Move to next name in list
			do {
				szCC++;
			} while (szCC[0] != '\0');
			szCC++;
		}
	}

//5	//////////////////////////////////
	// Load the Blind Carbon Copy data
	if(szBCC != NULL) {
		while (szBCC[0] != '\0' && mMessage.nRecipCount < 30) {
			// Load the recipient array element
			rgmRecip[mMessage.nRecipCount].ulReserved = 0;
			rgmRecip[mMessage.nRecipCount].ulRecipClass = MAPI_BCC;
			rgmRecip[mMessage.nRecipCount].lpszName = szBCC;
			rgmRecip[mMessage.nRecipCount].lpszAddress = NULL;
			rgmRecip[mMessage.nRecipCount].ulEIDSize = 0;
			rgmRecip[mMessage.nRecipCount].lpEntryID = NULL;

			// Increment recipient count
			mMessage.nRecipCount++;
			// Move to next name in list
			do {
				szBCC++;
			} while (szCC[0] != '\0');
			szBCC++;
		}
	}

//6	///////////////////////////
	// Load the Attachment data
	// Add a blank line in front of the message if there are files to attach
	if(szFileName != NULL) {
		if(szFileName[0] != '\0') {
			sprintf(szBuf, "                              \n%s", mMessage.lpszNoteText);
			mMessage.lpszNoteText = szBuf;
			bFiles = TRUE;
		}
		while (szFileName[0] != '\0' && mMessage.nFileCount < 30) {
			// Load the file array element
			rgmFileDesc[mMessage.nFileCount].ulReserved = 0;
			rgmFileDesc[mMessage.nFileCount].flFlags = 0;
			rgmFileDesc[mMessage.nFileCount].nPosition = mMessage.nFileCount;
			rgmFileDesc[mMessage.nFileCount].lpszPathName = szFileName;
			rgmFileDesc[mMessage.nFileCount].lpszFileName = NULL;
			rgmFileDesc[mMessage.nFileCount].lpFileType = NULL;

			// Increment file count
			mMessage.nFileCount++;
			// Move to the next file in the list
			do {
				szFileName++;
			} while (szFileName[0] != '\0');
			szFileName++;
		}
	}

//7	///////////////////////////////
	// load recipients into message
	mMessage.lpRecips = rgmRecip;

//8	//////////////////////////////
	// load filenames into message
	if(bFiles) {
		mMessage.lpFiles = rgmFileDesc;
	}

//9	/////////
	// Log in
	if(SUCCESS_SUCCESS != pfnMAPILogon(0L, szMailName, NULL, MAPI_NEW_SESSION, 0L, &hSession)) {
		ulRet |= MAPI_E_LOGON_FAILURE;
		if(dwOptions |= MAIL_VERBOSE) {
			printf("Could not log into mail for %s. Be sure you have installed Exchange.\n", szMailName);
		}
		goto Ret;
	}

//10////////////////
	// Send the mail
	errSendMail = (LONG) pfnMAPISendMail(hSession, 0L, &mMessage, 0L, 0L);
	if(errSendMail != SUCCESS_SUCCESS) {
		ulRet |= errSendMail;
		if(dwOptions |= MAIL_VERBOSE) {
			switch(errSendMail) {
			case MAPI_E_AMBIGUOUS_RECIPIENT:
				printf("Recipient is ambiguous. Please respecify.\n");
				break;
			case MAPI_E_UNKNOWN_RECIPIENT:
				printf("Recipient is unknown. Please respecify.\n");
				break;
			default:
				printf("Could not send message.\n");
				printf("Error number %d\n", errSendMail);
				printf("See mapi.h for error descriptions\n");
				break;
			}
		}
	}
	else {
		if(dwOptions |= MAIL_VERBOSE) {
			if(mMessage.nFileCount) {
				printf("Message sent with %d file attachments.\n", mMessage.nFileCount);
			}
			else {
				printf("Message sent.\n");
			}
		}
	}

Ret:

//11//////////
	// Log off
	pfnMAPILogoff(hSession, 0L, 0L, 0L);
	FreeLibrary(hLib);
	return ulRet;
}
#if 0
ULONG MailIt(char* szRecip, char* szCC, char* szBCC, char* szSubject, char* szMessage, char* szFileName, unsigned int dwOptions)
{
	return MailTo(szRecip, szCC, szBCC, szSubject, szMessage, szFileName, dwOptions);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\fixpdbpath\fixpdbpath.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Scan all images (.exe and .dll) in a directory sub-tree and remove any
// extraneous PDB directory information from the debug section. Also, image
// checksums are updated. 
//


#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <tchar.h>


// The level of verbosity.
DWORD g_dwVerbosity = ~0;


// Private routine prototypes.
DWORD ScanFile(LPTSTR pszFile);
DWORD ScanDirectory(LPTSTR pszDir);


// Macro to print based on verbosity.
#define VPRINT(_lvl) if ((_lvl) <= g_dwVerbosity) _tprintf


// Program entry point.
int __cdecl _tmain (int argc, LPTSTR argv[])
{
    int     iArgs = argc - 1;
    LPTSTR *rArgs = &argv[1];
    TCHAR   szFileOrDir[MAX_PATH + 1];
    bool    bIsFile;
    DWORD   dwAttr;
    DWORD   dwErrors;

    // Read all options (they must preceed the other args and start with a '-'
    // or '/').
    while (iArgs) {
        if ((rArgs[0][0] == '-') || (rArgs[0][0] == '/')) {
            switch (rArgs[0][1]) {
            case '?':
            case 'h':
                _tprintf(_T("usage: FixPdbPath [-?] [-v<level>] [<dir>|<file>]\n"));
                _tprintf(_T("where:\n"));
                _tprintf(_T("  -?             Shows this help.\n"));
                _tprintf(_T("  -v<level>      Sets the output level, where <verbosity> is one of:\n"));
                _tprintf(_T("                   0 -- display errors\n"));
                _tprintf(_T("                   1 -- display files updated\n"));
                _tprintf(_T("                   2 -- display files scanned\n"));
                _tprintf(_T("                 The default level is 0.\n"));
                _tprintf(_T("  <dir>          Directory to recursively scan. Default is current directory.\n"));
                _tprintf(_T("  <file>         A single file to examine instead of a directory to scan.\n"));
                _tprintf(_T("                 Verbosity default is set to 2 in this case.\n"));
                return 0;
            case 'v':
                switch (rArgs[0][2]) {
                case '0':
                    g_dwVerbosity = 0;
                    break;
                case '1':
                    g_dwVerbosity = 1;
                    break;
                case '2':
                    g_dwVerbosity = 2;
                    break;
                default:
                    _tprintf(_T("Invalid verbosity level, %s\n"), rArgs[0]);
                    return 1;
                }
                break;
            default:
                _tprintf(_T("Unknown option %s, use -? for usage\n"), rArgs[0]);
                return 1;
            }
            iArgs--;
            rArgs = &rArgs[1];
        } else
            break;
    }

    // Get file or start directory (default to current directory). Ensure that
    // path doesn't end with '\' (we'll add that later).
    if (iArgs > 0) {
        _tcscpy(szFileOrDir, rArgs[0]);
        dwAttr = ::GetFileAttributes(szFileOrDir);
        if ((dwAttr == ~0) || (dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
            bIsFile = false;
            if (szFileOrDir[_tcslen(szFileOrDir) - 1] == _T('\\'))
                szFileOrDir[_tcslen(szFileOrDir) - 1] = _T('\0');
        } else {
            bIsFile = true;
            if (g_dwVerbosity == ~0)
                g_dwVerbosity = 2;
        }
    } else {
        bIsFile = false;
        _tcscpy(szFileOrDir, _T("."));
    }

    if (g_dwVerbosity == ~0)
        g_dwVerbosity = 0;

    // Recursively scan for files from the given directory or, if a file
    // was given as input, just process that file.
    if (bIsFile)
        dwErrors = ScanFile(szFileOrDir) == NO_ERROR ? 0 : 1;
    else
        dwErrors = ScanDirectory(szFileOrDir);

    return dwErrors;
}


// Recursively scan for files from the given directory. The directory name
// must be given in a writeable buffer at least MAX_PATH + 1 characters long
// (though the buffer will appear to be unchanged on return from this routine).
// Directory names should be given without a trailing '\'.
// Returns count of errors (number of files we attempted to scan but failed to
// update or determine that no update was necessary).
DWORD ScanDirectory(LPTSTR pszDir)
{
    HANDLE          hSearch;
    WIN32_FIND_DATA sFileInfo;
    DWORD           cchOldPath;
    DWORD           dwErrors = 0;
    LPTSTR          pszExt;

    // Remember where the input directory currently ends (since we only ever add
    // to the directory name, we can use this information to restore the buffer
    // on exit from this routine).
    cchOldPath = _tcslen(pszDir);

    // Add the necessary wildcard filename necessary to make FindFirstFile
    // return every file and subdir within the directory.
    _tcscat(pszDir, _T("\\*.*"));

    // Start scanning for files.
    hSearch = ::FindFirstFile(pszDir, &sFileInfo);
    if (hSearch == INVALID_HANDLE_VALUE) {
        pszDir[cchOldPath] = _T('\0');
        VPRINT(0)(_T("Failed to open directory %s, error %u\n"), pszDir, GetLastError());
        return dwErrors + 1;
    }

    // While we haven't reached the end of the file list...
    while (hSearch != INVALID_HANDLE_VALUE) {

        if (sFileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            // If we've found a sub directory and it's not one of the special
            // cases ('.' or '..'), recursively descend into it.
            if (_tcscmp (_T("."), sFileInfo.cFileName) &&
                _tcscmp (_T(".."), sFileInfo.cFileName)) {
                _tcscpy(&pszDir[cchOldPath + 1], sFileInfo.cFileName);
                dwErrors += ScanDirectory(pszDir);
            }
        } else {
            // We've found a regular file. Check whether it has an interesting
            // file extension. If so, prepend directory and process the result.
            if ((pszExt = _tcsrchr(sFileInfo.cFileName, _T('.'))) &&
                (_tcsicmp(pszExt, _T(".exe")) == 0 || _tcsicmp(pszExt, _T(".dll")) == 0)) {
                _tcscpy(&pszDir[cchOldPath + 1], sFileInfo.cFileName);
                dwErrors += ScanFile(pszDir) == NO_ERROR ? 0 : 1;
            }
        }

        // Move to the next file.
        if (!::FindNextFile(hSearch, &sFileInfo))
            break;
    }

    // Finished with the enumerator.
    ::FindClose(hSearch);

    // Restore the directory path to the state it was in when we entered the
    // routine.
    pszDir[cchOldPath] = '\0';

    return dwErrors;
}


// Fix PDB path and checksum information for a single file.
DWORD ScanFile(LPTSTR pszFile)
{
    DWORD                       dwStatus = NO_ERROR;
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    HANDLE                      hMap = NULL;
    BYTE                       *pbBase  = NULL;
    IMAGE_NT_HEADERS           *pNtHeaders;
    IMAGE_DEBUG_DIRECTORY      *pDbgDir;
    LPSTR                       pszDbgType;
    LPSTR                       pszPdbPath;
    LPSTR                       pszDir;
    DWORD                       dwOldCheckSum;
    DWORD                       dwCheckSum;
    DWORD                       dwLength;
    DWORD                       dwDbgDataLength;
    DWORD                       dwChanged = 0;

    // Open the file.
    hFile = CreateFile(pszFile,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       0);
    if (hFile == INVALID_HANDLE_VALUE) {
        dwStatus = GetLastError();
        VPRINT(0)(_T("Failed to open %s\n"), pszFile);
        goto Cleanup;
    }

    // Create a file mapping.
    hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
    if (hMap == NULL) {
        dwStatus = GetLastError();
        VPRINT(0)(_T("Failed to create file map for %s\n"), pszFile);
        goto Cleanup;
    }

    // Map the file into memory.
    pbBase = (BYTE*)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
    if (pbBase == NULL) {
        dwStatus = GetLastError();
        VPRINT(0)(_T("Failed to map %s\n"), pszFile);
        goto Cleanup;
    }

    // Locate the standard file headers.
    pNtHeaders = ImageNtHeader(pbBase);
    if (pNtHeaders == NULL) {
        dwStatus = ERROR_BAD_FORMAT;
        VPRINT(0)(_T("Failed to find NT file headers in %s\n"), pszFile);
        goto Cleanup;
    }

    // Can't cope with files that haven't had their symbols stripped.
    if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        if (!(((IMAGE_NT_HEADERS32*)pNtHeaders)->FileHeader.Characteristics & IMAGE_FILE_LOCAL_SYMS_STRIPPED)) {
            dwStatus = ERROR_BAD_FORMAT;
            VPRINT(0)(_T("Image %s does not have its symbols stripped\n"), pszFile);
            goto Cleanup;
        }
    } else if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        if (!(((IMAGE_NT_HEADERS64*)pNtHeaders)->FileHeader.Characteristics & IMAGE_FILE_LOCAL_SYMS_STRIPPED)) {
            dwStatus = ERROR_BAD_FORMAT;
            VPRINT(0)(_T("Image %s does not have its symbols stripped\n"), pszFile);
            goto Cleanup;
        }
    } else {
        dwStatus = ERROR_BAD_FORMAT;
        VPRINT(0)(_T("Unrecognized file header format in %s\n"), pszFile);
        goto Cleanup;
    }

    // See if we can find a debug directory.
    pDbgDir = (IMAGE_DEBUG_DIRECTORY*)ImageRvaToVa(pNtHeaders,
                                                   pbBase,
                                                   pNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress,
                                                   NULL);
    if (pDbgDir == NULL) {
        VPRINT(2)(_T("No debug data in %s\n"), pszFile);
        goto Cleanup;
    }

    // Locate start of debug type information.
    if (pDbgDir->PointerToRawData == NULL) {
        VPRINT(2)(_T("No debug data in %s\n"), pszFile);
        goto Cleanup;
    }

    // Check for a format we understand.
    if (pDbgDir->SizeOfData < 4) {
        dwStatus = ERROR_BAD_FORMAT;
        VPRINT(0)(_T("Can't parse debug data in %s\n"), pszFile);
        goto Cleanup;
    }

    pszDbgType = (LPSTR)(pbBase + pDbgDir->PointerToRawData);

    if (strncmp(pszDbgType, "RSDS", 4) == 0) {
        pszPdbPath = pszDbgType + 24;
    } else if (strncmp(pszDbgType, "NB10", 4) == 0) {
        pszPdbPath = pszDbgType + 16;
    } else {
        dwStatus = ERROR_BAD_FORMAT;
        VPRINT(0)(_T("Can't parse debug data in %s\n"), pszFile);
        goto Cleanup;
    }

    // Look for directory separator in PDB filename.
    pszDir = strrchr(pszPdbPath, '\\');
    if (pszDir != NULL) {
        // Pull the filename portion forward, overwriting the start of the PDB path.
        strcpy(pszPdbPath, pszDir + 1);
        dwChanged |= 0x00000001;
    }

    // Update the size of the debug data (even if we didn't alter it, just to be
    // on the safe side).
    dwDbgDataLength = (pszPdbPath + strlen(pszPdbPath) + 1) - pszDbgType;
    if (pDbgDir->SizeOfData != dwDbgDataLength) {
        pDbgDir->SizeOfData = dwDbgDataLength;
        dwChanged |= 0x00000002;
    }

    // Determine file length used in checksum below.
    dwLength = GetFileSize(hFile, NULL);

    // Recalculate image checksum taking in account changes above.
    if (CheckSumMappedFile(pbBase,
                           dwLength,
                           &dwOldCheckSum,
                           &dwCheckSum) == NULL) {
        dwStatus = GetLastError();
        VPRINT(0)(_T("Failed to update checksum in %s\n"), pszFile);
        goto Cleanup;
    }

    if (dwOldCheckSum != dwCheckSum) {

        // Write the new checksum back into the image.
        if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            ((IMAGE_NT_HEADERS32*)pNtHeaders)->OptionalHeader.CheckSum = dwCheckSum;
        else
            ((IMAGE_NT_HEADERS64*)pNtHeaders)->OptionalHeader.CheckSum = dwCheckSum;

        // Flush the image updates.
        if (!FlushViewOfFile(pbBase, 0)) {
            dwStatus = GetLastError();
            VPRINT(0)(_T("Failed flush updates for %s\n"), pszFile);
            goto Cleanup;
        }

        dwChanged |= 0x00000004;
    }

    if (dwChanged) {
        VPRINT(1)(_T("The following were updated in %s: "), pszFile);
        if (dwChanged & 0x00000001)
            VPRINT(1)(_T("[PDB Path] "));
        if (dwChanged & 0x00000002)
            VPRINT(1)(_T("[Debug Dir Size] "));
        if (dwChanged & 0x00000004)
            VPRINT(1)(_T("[Image Checksum] "));
        VPRINT(1)(_T("\n"));
    } else
        VPRINT(2)(_T("%s required no updates\n"), pszFile);

 Cleanup:
    // Cleanup all resources we used.
    if (pbBase)
        UnmapViewOfFile(pbBase);
    if (hMap)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\nvpair.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/* Name value pair (both strings) which can be linked into a list of pairs */

#ifndef NVPAIR_H
#define NVPAIR_H

class NVPair
{
public:

    NVPair(char *name, char *value)
    {
        m_Name = new char [strlen(name) + 1];
        m_Value = new char [strlen(value) + 1];
        strcpy(m_Name, name);
        strcpy(m_Value, value);
        m_Tail = NULL;
    }

    ~NVPair()
    {
        delete [] m_Name;
        delete [] m_Value;
        delete m_Tail;
    }

    NVPair *Concat(NVPair *list)
    {
        m_Tail = list;
        return this;
    }

    char *Name() { return m_Name; }
    char *Value() { return m_Value; }
    NVPair *Next() { return m_Tail; }

private:
    char   *m_Name;
    char   *m_Value;
    NVPair *m_Tail;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\hparse.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************/
/* hParse is basically a wrapper around a YACC grammar H to COM+ IL converter  */

#ifndef hparse_h
#define hparse_h

#include "cor.h"        // for CorMethodAttr ...
#include <crtdbg.h>     // For _ASSERTE
#include <corsym.h>

#include <stdio.h>      // for FILE
#include <stdlib.h>
#include <assert.h>
#include "UtilCode.h"
#include "DebugMacros.h"
#include "corpriv.h"
#include <sighelper.h>
//#include "asmparse.h"
#include "binstr.h"

#define MAX_FILENAME_LENGTH         512     //256

/**************************************************************************/
/* an abstraction of a stream of input characters */
class ReadStream {
public:
        // read at most 'buffLen' bytes into 'buff', Return the
        // number of characters read.  On EOF return 0
    virtual unsigned read(char* buff, unsigned buffLen) = 0;
        
        // Return the name of the stream, (for error reporting).  
    virtual const char* name() = 0;
        //return ptr to buffer containing specified source line
    virtual char* getLine(int lineNum) = 0;
};

/**************************************************************************/
class FileReadStream : public ReadStream {
public:
    FileReadStream(char* aFileName) 
    {
        fileName = aFileName;
        file = fopen(fileName, "rb"); 
    }

    unsigned read(char* buff, unsigned buffLen) 
    {
        _ASSERTE(file != NULL);
        return(fread(buff, 1, buffLen, file));
    }

    const char* name() 
    { 
        return(fileName); 
    }

    BOOL IsValid()
    {
        return(file != NULL); 
    }
    
    char* getLine(int lineNum)
    {
        char* buf = new char[65535];
        FILE* F;
        F = fopen(fileName,"rt");
        for(int i=0; i<lineNum; i++) fgets(buf,65535,F);
        fclose(F);
        return buf;
    }

private:
    const char* fileName;       // FileName (for error reporting)
    FILE* file;                 // File we are reading from
};

/************************************************************************/
/* represents an object that knows how to report errors back to the user */

class ErrorReporter 
{
public:
    virtual void error(char* fmt, ...) = 0; 
    virtual void warn(char* fmt, ...) = 0; 
};
/*****************************************************************************/
/* LIFO (stack) and FIFO (queue) templates (must precede #include "method.h")*/
template <class T>
class LIST_EL
{
public:
    T*  m_Ptr;
    LIST_EL <T> *m_Next;
    LIST_EL(T *item) {m_Next = NULL; m_Ptr = item; };
};
    
template <class T>
class LIFO
{
public:
    inline LIFO() { m_pHead = NULL; };
    inline ~LIFO() {T *val; while(val = POP()) delete val; };
    void PUSH(T *item) 
    {
        m_pTemp = new LIST_EL <T>(item); 
        m_pTemp->m_Next = m_pHead; 
        m_pHead = m_pTemp;
    };
    T* POP() 
    {
        T* ret = NULL;
        if(m_pTemp = m_pHead)
        {
            m_pHead = m_pHead->m_Next;
            ret = m_pTemp->m_Ptr;
            delete m_pTemp;
        }
        return ret;
    };
private:
    LIST_EL <T> *m_pHead;
    LIST_EL <T> *m_pTemp;
};
template <class T>
class FIFO
{
public:
    FIFO() { m_Arr = NULL; m_ulArrLen = 0; m_ulCount = 0; m_ulOffset = 0; };
    ~FIFO() {
        if(m_Arr) {
            for(ULONG i=0; i < m_ulCount; i++) {
                if(m_Arr[i+m_ulOffset]) delete m_Arr[i+m_ulOffset];
            }
            delete m_Arr;
        }
    };
    void PUSH(T *item) 
    {
        if(m_ulCount+m_ulOffset >= m_ulArrLen)
        {
            if(m_ulOffset)
            {
                memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                m_ulOffset = 0;
            }
            else
            {
                m_ulArrLen += 1024;
                T** tmp = new T*[m_ulArrLen];
                if(m_Arr)
                {
                    memcpy(tmp,m_Arr,m_ulCount*sizeof(T*));
                    delete m_Arr;
                }
                m_Arr = tmp;
            }
        }
        m_Arr[m_ulOffset+m_ulCount] = item;
        m_ulCount++;
    };
    ULONG COUNT() { return m_ulCount; };
    T* POP() 
    {
        T* ret = NULL;
        if(m_ulCount)
        {
            ret = m_Arr[m_ulOffset++];
            m_ulCount--;
            if(m_ulOffset >= 1024)
            {
                memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                m_ulOffset = 0;
            }
        }
        return ret;
    };
    T* PEEK(ULONG idx)
    {
        T* ret = NULL;
        if(idx < m_ulCount) ret = m_Arr[m_ulOffset+idx];
        return ret;
    };
private:
    T** m_Arr;
    ULONG       m_ulCount;
    ULONG       m_ulOffset;
    ULONG       m_ulArrLen;
};

struct ILType
{
    char  szString[2048];
    char  szMarshal[2048];
    int   iSize;
    BOOL  bExplicit;
    BOOL  bConst;
};
typedef LIFO<ILType> ILTypeStack;
struct Typedef
{
    char  szName[MAX_CLASSNAME_LENGTH];
    char  szDefinition[2048];
    char  szMarshal[2048];
    int   iSize;
};
typedef FIFO<Typedef> TypedefQueue;
struct VarDescr
{
    char  szName[MAX_CLASSNAME_LENGTH];
    int   iValue;
};
typedef FIFO<VarDescr> VarDescrQueue;

struct ClassDescr
{
    char        szNamespace[MAX_CLASSNAME_LENGTH];
    char        szName[MAX_CLASSNAME_LENGTH];
    BinStr      bsBody;
};
typedef FIFO<ClassDescr> ClassDescrQueue;

struct AppDescr
{
    char        szApp[256];
    char        szDLL[256];
    ClassDescr* pClass;
};
typedef FIFO<AppDescr> AppDescrQueue;

/**************************************************************************/
/* HParse does all the parsing.  It also builds up simple data structures,  
   (like signatures), but does not do the any 'heavy lifting' like define
   methods or classes.  Instead it calls to the Assembler object to do that */

class HParse : public ErrorReporter 
{
public:
    HParse(ReadStream* stream, char* szDefFileName, char* szGlobalNS, bool bShowTypedefs);
    ~HParse();

        // The parser knows how to put line numbers on things and report the error 
    virtual void error(char* fmt, ...);
    virtual void warn(char* fmt, ...);
    char *getLine(int lineNum) { return in->getLine(lineNum); };
    bool Success() {return success; };
    void PopPack() { if(m_uPackStackIx) m_uCurrentPack = m_PackStack[m_uPackStackIx--]; };
    void PushPack(){ m_PackStack[++m_uPackStackIx] = m_uCurrentPack; };
    void SetPack(unsigned uPack) { m_uCurrentPack = uPack; };
    void PopFieldIx() { if(m_uFieldIxIx) m_uCurrentFieldIx = m_FieldIxStack[m_uFieldIxIx--]; };
    void PushFieldIx(){ m_FieldIxStack[++m_uFieldIxIx] = m_uCurrentFieldIx; };
    void EmitTypes(BinStr* pbsTypeNames, BOOL isTypeDef); // uses m_pCurrILType
    void ResolveTypeRef(char* szTypeName); // sets m_pCurrILType when typedef'ed type is used
    ILType*         m_pCurrILType;
    ILTypeStack     m_ILTypeStack;
    void StartStruct(char* szName);
    void StartUnion(char* szName);
    void StartEnum(char* szName);
    void CloseClass();
    void EmitField(char* szName);
    void EmitEnumField(char* szName, int iVal);
    int             m_iEnumValue;
    void EmitFunction(BinStr* pbsType, char* szCallConv, BinStr* pbsName, BinStr* pbsArguments);
    //void StartFunction(char* szCallConv, char* szName);
    //void EmitFunction(BinStr* pbsArguments);
    void FuncPtrType(BinStr* pbsType, char* szCallConv, BinStr* pbsSig);
    int  ResolveVar(char* szName);
    void AddVar(char* szName, int iVal);
    BinStr* FuncPtrDecl(BinStr* pbsType, BinStr* pbsCallNameSig);
    ClassDescrQueue ClassQ;
    AppDescrQueue   AppQ;
    ClassDescr* FindCreateClass(char* szFullName);
    AppDescr*   GetAppProps(char* szAppName);
    char    m_szGlobalNS[512];
    char    m_szCurrentNS[512];

private:
    unsigned        m_PackStack[1024];
    unsigned        m_uPackStackIx;
    unsigned        m_uCurrentPack;
    unsigned        m_FieldIxStack[1024];
    unsigned        m_uFieldIxIx;
    unsigned        m_uCurrentFieldIx;
    TypedefQueue    m_Typedef;
    unsigned        m_uAnonNumber;
    char            m_szIndent[1024];
    unsigned        m_uInClass;
    VarDescrQueue*  m_pVDescr;
    int             m_nBitFieldCount;
    bool            m_bShowTypedefs;

    char* fillBuff(char* curPos);   // refill the input buffer 

private:
    friend void yyerror(char* str);
    friend int yyparse();
    friend int yylex();

        // Error reporting support
    char* curTok;               // The token we are in the process of processing (for error reporting)
    unsigned curLine;           // Line number (for error reporting)
    bool success;               // overall success of the compilation

        // Input buffer logic
    enum { 
        IN_READ_SIZE = 8192,    // How much we like to read at one time
        IN_OVERLAP   = 255,     // Extra space in buffer for overlapping one read with the next
                                // This limits the size of the largest individual token (except quoted strings)
    };
    char* buff;                 // the current block of input being read
    char* curPos;               // current place in input buffer
    char* limit;                // curPos should not go past this without fetching another block
    char* endPos;               // points just past the end of valid data in the buffer

    ReadStream* in;             // how we fill up our buffer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\holler\maillib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// maillib.h

// Required symbols
#define MAX_LENGTH 256
#define MEGA_LENGTH 65535
#define WIN95_REG_KEY "Software\\Microsoft\\Windows Messaging Subsystem\\Profiles"
#define WINNT_REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles"

// Options
#define		MAIL_QUIET		0x00000001	// Quiet - no output
#define		MAIL_VERBOSE	0x00000002	// Verbose - status sent to standard out

ULONG MailIt(char* szRecip, char* szCC, char *szBCC, char* szSubject, char* szMessage, char* szFilName, unsigned int dwOptions);

// Signature
ULONG MailTo(
            char *szDisplayName,    // NULL delimited display name
            char *szRecip,			// NULL delimited recipient list (one or more)
			char *szCC,				// NULL delimited CC list (zero or more)
			char *szBCC,			// NULL delimited BCC list (zero or more)
			char *szSubject,		// subject (may be empty string)
			char *szMessage,		// message text (may be empty string)
			char *szFileName,		// NULL delimited file attachment names (zero or more)
			unsigned int dwOptions);// Options

// szRecip		-	Recipient list
//						This should be a null terminated list of recipient names.
//						Each name should be separated with a null character and
//						the string should be terminated with two null characters.
//						This is consistent with the common open file dialog.

// szCC			-	Carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						Obviously this is the list of names to be cc'd on the mail.

// szBCC		-	Blind carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						The names on this list will also get the mail but the regular
//						recipients and carbon copy recipients will not know.

// szSubject	-	Subject text of message
//						This should be a null terminated string that will go in the
//						subject field.

// szMessage	-	Body text of message
//						This should be a null terminated string that will be the
//						body text of the message.

// szFileName	-	List of file attachments
//						This should be a null terminated list of file names to attach.
//						The files will go on the first line before the body text.

// dwOptions	-	See Options above

// Note: You are limited to thirty total recipients and thirty total files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\h_kywd.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
//
// COM+ H->IL converter keywords, symbols and values
//
// This is the master table used in HtoIL (hparse.y)
// symbols and values are defined in hparse.y 
//

#ifndef __H_KYWD_H_
#define __H_KYWD_H_

	KYWD( "#pragma",		PRAGMA_,			NO_VALUE )
	KYWD( "pack",			PACK_,				NO_VALUE )
	KYWD( "pop",			POP_,				NO_VALUE )
	KYWD( "push",			PUSH_,				NO_VALUE )
	KYWD( "once",			ONCE_,				NO_VALUE )
	KYWD( "warning",		WARNING_,			NO_VALUE )
	KYWD( "disable",		DISABLE_,			NO_VALUE )
	KYWD( "default",		DEFAULT_,			NO_VALUE )
	KYWD( "function",		FUNCTION_,			NO_VALUE )
	KYWD( "_enable",		_ENABLE_,			NO_VALUE )
	KYWD( "_disable",		_DISABLE_,			NO_VALUE )
	KYWD( "comment",		COMMENT_,			NO_VALUE )
	KYWD( "lib",			LIB_,				NO_VALUE )

	KYWD( "void",			VOID_,				NO_VALUE )
	KYWD( "bool",			BOOL_,				NO_VALUE )
	KYWD( "char",			CHAR_,				NO_VALUE )
	KYWD( "int",			INT_,				NO_VALUE )
	KYWD( "__int8",			INT8_,				NO_VALUE )
	KYWD( "__int16",		INT16_,				NO_VALUE )
	KYWD( "__int32",		INT32_,				NO_VALUE )
	KYWD( "__int64",		INT64_,				NO_VALUE )
	KYWD( "long",			LONG_,				NO_VALUE )
	KYWD( "short", 			SHORT_,				NO_VALUE )
	KYWD( "unsigned",		UNSIGNED_,			NO_VALUE )
	KYWD( "signed",			SIGNED_,			NO_VALUE )
	KYWD( "float",			FLOAT_,				NO_VALUE )
	KYWD( "double",			DOUBLE_,			NO_VALUE )
	KYWD( "typedef", 		TYPEDEF_,			NO_VALUE )
	KYWD( "__cdecl", 		_CDECL_,			NO_VALUE )
	KYWD( "_cdecl", 		CDECL_,				NO_VALUE )
	KYWD( "__stdcall", 		STDCALL_,			NO_VALUE )
	KYWD( "struct",			STRUCT_,			NO_VALUE )
	KYWD( "union",			UNION_,				NO_VALUE )
	KYWD( "enum",			ENUM_,				NO_VALUE )
	KYWD( "const",			CONST_,				NO_VALUE )
	KYWD( "extern",			EXTERN_,			NO_VALUE )
	KYWD( "__declspec",		_DECLSPEC_,			NO_VALUE )
	KYWD( "dllimport",		DLLIMPORT_,			NO_VALUE )
	KYWD( "noreturn",		NORETURN_,			NO_VALUE )
	KYWD( "__inline",		__INLINE_,			NO_VALUE )
	KYWD( "_inline",		_INLINE_,			NO_VALUE )
	KYWD( "inline",			INLINE_,			NO_VALUE )
	KYWD( "forceinline",	FORCEINLINE_,		NO_VALUE )
	KYWD( "wchar_t",		WCHAR_,				NO_VALUE )

	KYWD( "^THE_END^",		0,					NO_VALUE )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\installhook\versioneddll\mscorrc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Mscorrc.cpp
//
// This just provides a load point for the .dll.
//
//*****************************************************************************
#include <windows.h>


//*****************************************************************************
// This function is called when the DLL is loaded/unloaded.  A code is passed
// giving a reason for being called.
//*****************************************************************************
BOOL APIENTRY DllMain( // TRUE = success, FALSE = failure.
    HINSTANCE	hModule,				// DLL's instance handle.
	DWORD		ul_reason_for_call,		// Cause of this call.
	LPVOID		lpReserved)
{
    if (ul_reason_for_call == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls((HINSTANCE)hModule);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "hparse.h"
#include "__file__.ver"
#include "corver.h"

BOOL g_fReduceNames = TRUE;

void __cdecl main(int argc, char **argv)
{
    char        szInputFilename[MAX_FILENAME_LENGTH];
    char        szDefName[MAX_FILENAME_LENGTH];
    char        szGlobalNS[MAX_FILENAME_LENGTH];
    int         i;
    BOOL	    OnErrGo = false;
	_TCHAR		szOpt[128];
	FileReadStream *pIn;
	HParse		*pParser;
	int			exitval=1;
	bool		bShowTypedef=false;

    printf("\n//Microsoft (R) Converter H to CIL Assembler.  Version " VER_FILEVERSION_STR);
    printf("\n//%s\n\n", VER_LEGALCOPYRIGHT_DOS_STR);

	memset(szInputFilename,0,sizeof(szInputFilename));
	
    if (argc < 2 || ! strcmp(argv[1], "/?") || ! strcmp(argv[1],"-?"))
    { 
    ErrorExit:
      printf("\n\nUsage: HtoIL [Options] <sourcefile> [Options]");
      printf("\n\n");
      printf("\nOptions:");
	  printf("\n/DEF=<definition file>	set the API definition file (MANDATORY)");
	  printf("\n/GNS=<namespace>		set the global namespace");
	  printf("\n/TYPEDEF				show typedefs as comments");
	  printf("\n/NORED					suppress typedef name reduction (removing leading underscores and 'tag')");
      printf("\n\nKey may be '-' or '/'\nOptions are recognized by first 3 characters\nDefault source file extension is .H\n\n");
      exit(1);
    }

	//-------------------------------------------------
	szDefName[0] = 0;
	szGlobalNS[0] = 0;
	for (i = 1; i < argc; i++)
	{
		if((argv[i][0] == '/') || (argv[i][0] == '-'))
		{
			lstrcpyn(szOpt, &argv[i][1],10);
			szOpt[3] = 0;
			if (!lstrcmpi(szOpt, _T("DEF")))
			{
				char *pStr = strchr(argv[i],'=');
				if(pStr == NULL) goto ErrorExit;
				for(pStr++; *pStr == ' '; pStr++); //skip the blanks
				if(strlen(pStr)==0) goto ErrorExit; //if no file name
				lstrcpyn(szDefName,pStr,MAX_FILENAME_LENGTH-1);
			}
			else
			if (!lstrcmpi(szOpt, _T("TYP")))
			{
				bShowTypedef = true;
			}
			else
			if (!lstrcmpi(szOpt, _T("NOR")))
			{
				g_fReduceNames = FALSE;
			}
			else
			if (!lstrcmpi(szOpt, _T("GNS")))
			{
				char *pStr = strchr(argv[i],'=');
				if(pStr == NULL) goto ErrorExit;
				for(pStr++; *pStr == ' '; pStr++); //skip the blanks
				if(strlen(pStr)==0) goto ErrorExit; //if no file name
				lstrcpyn(szGlobalNS,pStr,MAX_FILENAME_LENGTH-1);
			}
			else
			{
				printf("Error : Invalid Option: %s", argv[i]);
				goto ErrorExit;
			}
		}
		else
		{
			if(szInputFilename[0]) goto ErrorExit;
			//Attention! Not Unicode piece:
			lstrcpyn(szInputFilename,argv[i],MAX_FILENAME_LENGTH-1);
			int j = strlen(szInputFilename)-1;
			for(; j >= 0; j--)
			{
				if(szInputFilename[j] == '.') break;
				if((szInputFilename[j] == '\\')||(j == 0))
				{
					strcat(szInputFilename,".H");
					break;
				}
			}
		}
	}
				
	if(szInputFilename[0] == 0) goto ErrorExit;
	if(szDefName[0] == 0) goto ErrorExit;
	//======================================================================
	printf("//Converting '%s' \n\n", szInputFilename);
	//======================================================================
	pIn = new FileReadStream(szInputFilename);
	if ((!pIn) || !(pIn->IsValid())) 
        printf("Could not open %s\n", szInputFilename);
	else
	{
		if(pParser = new HParse(pIn,szDefName, szGlobalNS, bShowTypedef))
		{
			if(pParser->Success()) exitval = 0;
			delete pParser;
		}
		else printf("Could not create parser\n");
		delete pIn;
	}

    if (exitval == 0)
        printf("\n//Operation completed successfully\n");
    else
        printf("\n***** FAILURE ***** \n");
    exit(exitval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\makefile.inc ===
OBJECTS = $(OBJECTS) $O\HParse.obj 

$O\HParse.obj: HParse.h $O\HParse.c hparse.grammar


$O\HParse.c: hparse.y hparse.h ..\..\inc\openum.h 
	-del/f /q $O\hparse.c 
    yacc_ms -o $O\hparse -i hparse.y

hparse.grammar: hparse.y
	perl extractGrammar.pl hparse.y > hparse.grammar
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\installhook\hkffile\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

keyfile: _NETFXSBS10.hkf
	AddRuntimeVersion.pl _NETFXSBS10.hkf $(URTTARGET)\NETFXSBS10.hkf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\installhook\netfxsbs\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "netfxsbs10.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Installation Hook\0"
#define VER_ORIGFILENAME_STR    "netfxsbs10.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\installhook\netfxsbs\installhook.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <Shlwapi.h>

#define HOOK_OPTION_INSTALL         1
#define HOOK_OPTION_UNINSTALL    2
#define HOOK_OPTION_UNKNOWN      3

#define HOOK_REGFILE                                "NETFXSBS10.hkf"
#define INSTALL_UNINSTALL_SEPERATOR      "*------*"

#define HOOK_SYSTEMDIR_TOKEN            "%systemdir%"
#define HOOK_RTMDIR_TOKEN                 "%rtmdir%"
#define HOOK_INSTALLDIR_TOKEN           "%installdir%"

// All Token retrievers must have this pattern
class RegistryKeyParser;
typedef BOOL (RegistryKeyParser::*PTokenRetriever)(char* pszSystemDir, DWORD nSize);

#define PARSER_NOERROR                                          0
#define PARSER_ERROR_UNSUPPORTED_FORMAT      1
#define PARSER_ERROR_FILE_NOT_FOUND                2
#define REGISTRY_ACCESS_FAILED                           3
#define PARSER_ERROR_TOKENS                                 4

#define BUFFER_SIZE     1000

FILE*   g_fLogFile = NULL;

struct RegEntry
{
    HKEY        hKey;
    LPCSTR    pszSubKey;
    LPCSTR    pszValueName;
    DWORD   dwDataType;
    BYTE*      pData;
    DWORD    cbData;
    BOOL        fDelete;
    struct RegEntry*    next;
};// struct RegEntry



class RegistryKeyParser
{
public:

    //-------------------------------------------------
    // RegistryKeyParser - Constructor
    //-------------------------------------------------
    RegistryKeyParser()
    {
        m_pHead = NULL;
    }// RegistryKeyParser

    //-------------------------------------------------
    // RegistryKeyParser - Destructor
    //-------------------------------------------------
    ~RegistryKeyParser()
    {
        struct RegEntry* temp = m_pHead;

        while(temp != NULL)
        {
            struct RegEntry* nextEntry = temp->next;

            // If this has a Value, then we shouldn't delete the subkey name
            if (temp->pszValueName != NULL)
            {
                delete[] temp->pszValueName;
                delete[] temp->pData;
            }
            else
                delete[] temp->pszSubKey;

            delete temp;

            temp = nextEntry;
        
        }
    }// ~RegistryKeyParser

    //-------------------------------------------------
    // LoadAndParseRegFile
    //
    // This takes in the registry file to parse
    //
    // It returns one of the error codes defined at the top of this
    // file
    //-------------------------------------------------

    DWORD LoadAndParseRegFile(char* pszRegFile, BOOL fInstall)
    {
        FILE            *fin = NULL;
        char            szBuffer[BUFFER_SIZE];
        DWORD       nRetValue = PARSER_NOERROR;

        fin = fopen(pszRegFile, "rt");
        if (fin == NULL)
        {
            fprintf(g_fLogFile, "Unable to open %s\n", pszRegFile);
            return PARSER_ERROR_FILE_NOT_FOUND;
        }
        if (!fInstall)
            ChugToUnInstallPoint(fin);

        // Keep chugging along until we run out of things to look at
        while (NULL != fgets(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), fin))
        {
            // Check if this is a comment line
            if (*szBuffer == '#')
                continue;
        
            if (!ReplaceTokens(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0])))
            {
                fprintf(g_fLogFile, "Error replacing tokens\n");
                nRetValue = PARSER_ERROR_TOKENS;
                goto ErrExit;
            }
        
            char *pData = szBuffer;


            // See if we've hit the terminator for this section
            if (!strncmp(szBuffer, 
                              INSTALL_UNINSTALL_SEPERATOR, 
                              sizeof(INSTALL_UNINSTALL_SEPERATOR)/sizeof(INSTALL_UNINSTALL_SEPERATOR[0])-1))
                break;


            // Run through any whitespace
            pData = RunThroughWhitespace(pData);

            // If we hit the end of the line, there's no parsing here to do
            if (*pData)
            {
                // We should be at a key defination right now.
                struct RegEntry* re = ParseKey(pData);
                if (re == NULL)
                {
                    nRetValue = PARSER_ERROR_UNSUPPORTED_FORMAT;
                    fprintf(g_fLogFile, "Syntax error in file");
                    goto ErrExit;    
                }

                // Else, all is good. Let's add this top level key to our list
                AddToList(re);

                DWORD nRet = ParseValues(re, fin);
                if (nRet != PARSER_NOERROR)
                {
                    nRetValue = nRet;
                    fprintf(g_fLogFile, "Syntax error in file");
                    goto ErrExit;
                }
              }
        }
        ErrExit:
            if (fin != NULL)
                fclose(fin);

            return nRetValue;

    }

    //-------------------------------------------------
    // DumpKeys
    //
    // Called for debug purposes only
    //-------------------------------------------------
    void DumpKeys()
    {
        struct RegEntry* temp = m_pHead;

        while(temp != NULL)
        {
            char *pszhKey = "unknown";
            if (temp->hKey == HKEY_LOCAL_MACHINE)
                pszhKey = "HKEY_LOCAL_MACHINE";
            else if (temp->hKey == HKEY_CLASSES_ROOT)
                pszhKey = "HKEY_CLASSES_ROOT";
            else if (temp->hKey == HKEY_CURRENT_USER)
                pszhKey = "HKEY_CURRENT_USER";

            fprintf(g_fLogFile, "Key is %s\n", pszhKey);
            fprintf(g_fLogFile,"SubKey is %s\n", temp->pszSubKey);
            fprintf(g_fLogFile, "I am %sdeleting this item\n", temp->fDelete?"":"not ");
            fprintf(g_fLogFile, "Datatype is %d\n", temp->dwDataType);

            if (temp->pszValueName != NULL)
            {
                fprintf(g_fLogFile, "Valuename is %s\n", temp->pszValueName);
                fprintf(g_fLogFile, "Data is: '");

                if (temp->dwDataType == REG_DWORD)
                    fprintf(g_fLogFile, "%d", *(DWORD*)(temp->pData));
                else
                {
                    for(DWORD i=0; i<temp->cbData; i++)
                        fprintf(g_fLogFile, "%c", temp->pData[i]);
                }
                fprintf(g_fLogFile, "'\n");
            }    

            fprintf(g_fLogFile, "----------------------\n\n");

            temp = temp->next;
        }
    

    }// DumpKeys

    //-------------------------------------------------
    // ApplyRegistrySettings
    //
    // This will run through the registry settings we've parsed and
    // commit the changes to the registry
    //-------------------------------------------------
    DWORD ApplyRegistrySettings()
    {
        struct RegEntry* temp = m_pHead;
        HKEY hOpenedKey = NULL;

        while(temp != NULL)
        {

            // See if we're deleting this key
            if (temp->pszValueName == NULL && temp->fDelete)
            {
                DWORD dwRes =  SHDeleteKeyA(temp->hKey,
                                                                  temp->pszSubKey);

                // It's not an error if they tried to delete something that wasn't there
                if (dwRes != ERROR_SUCCESS && dwRes != ERROR_FILE_NOT_FOUND)
                {
                    fprintf(g_fLogFile, "Error deleting key %d %s", temp->hKey, temp->pszSubKey);
                    goto ErrExit;
                }                                                                                    
            }
            else
            {
                DWORD dwDisp = 0;
                
                if (ERROR_SUCCESS != RegCreateKeyExA(temp->hKey,
                                                                                temp->pszSubKey,
                                                                                0,
                                                                                NULL,
                                                                                REG_OPTION_NON_VOLATILE,
                                                                                KEY_ALL_ACCESS,
                                                                                NULL,
                                                                                &hOpenedKey,
                                                                                &dwDisp
                                                                                ))
                {
                    fprintf(g_fLogFile, "Error creating key %d %s", temp->hKey, temp->pszSubKey);
                    goto ErrExit;
                }
                // Keep chugging away if we have a value.
                if (temp->pszValueName != NULL)
                {
                    // See if we should delete this one
                    if (temp->fDelete)
                    {
                        DWORD dwReturn = RegDeleteValueA(hOpenedKey, temp->pszValueName);
                        // It's not an error if they tried to delete something that wasn't there
                        if (dwReturn != ERROR_SUCCESS && dwReturn != ERROR_FILE_NOT_FOUND)
                        {
                            fprintf(g_fLogFile, "Error deleting value %d %s %s", temp->hKey, temp->pszSubKey, temp->pszValueName);
                            goto ErrExit;
                        }
                    }
                    else
                    {  
                        if (ERROR_SUCCESS != RegSetValueExA(hOpenedKey, 
                                                                                     temp->pszValueName,
                                                                                     0,
                                                                                     temp->dwDataType,
                                                                                     temp->pData,
                                                                                     temp->cbData))
                        {
                            fprintf(g_fLogFile, "Error setting value %d %s %s", temp->hKey, temp->pszSubKey, temp->pszValueName);
                            goto ErrExit;                                                                                            
                        }
                    }

                }

            }

            if (hOpenedKey != NULL && RegCloseKey(hOpenedKey) != ERROR_SUCCESS)
            {
                fprintf(g_fLogFile, "Unable to close a registry key! %d %s", temp->hKey, temp->pszSubKey);
                // We probably shouldn't fail for this... keep chugging along
            }
            hOpenedKey = NULL;
            temp = temp->next;
        }

        return PARSER_NOERROR;
        

    ErrExit:
        if (hOpenedKey != NULL)
            RegCloseKey(hOpenedKey);

        return REGISTRY_ACCESS_FAILED;


    }// ApplyRegistrySettings

private:

    //-------------------------------------------------
    // ChugToUnInstallPoint
    //
    // This function will position the file pointer to the first line in
    // the file past the 'seperator' string.
    //
    // On return, the file pointer will be pointing to the first line of
    // the uninstall section
    //-------------------------------------------------
    void ChugToUnInstallPoint(FILE* fin)
    {
        char szBuffer[BUFFER_SIZE];
        while (NULL != fgets(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), fin))
        {
            // See if we hit the seperator

            // We do the -1 for the length of the string because we don't want to count the null
            if (!strncmp(szBuffer, 
                              INSTALL_UNINSTALL_SEPERATOR, 
                              sizeof(INSTALL_UNINSTALL_SEPERATOR)/sizeof(INSTALL_UNINSTALL_SEPERATOR[0])-1))
                return;
        }        
        return;
    }// ChugToUnInstallPoint

    //-------------------------------------------------
    // ReplaceTokens
    //
    // This function will replace all the token values sitting in the
    // supplied buffer.
    //
    // It returns TRUE if successful, FALSE if an error occured
    //-------------------------------------------------
    BOOL ReplaceTokens(char* lpszBuffer, DWORD dwBufferLen)
    {
        // Check the simple case
        if (lpszBuffer == NULL || *lpszBuffer == 0)
            return TRUE;
            
        // There's three tokens we need to look for
        
        // Make sure these Tokens/Token Retrievers stay matched up
        char *lppszTokenValues[3] = {HOOK_SYSTEMDIR_TOKEN, HOOK_RTMDIR_TOKEN, HOOK_INSTALLDIR_TOKEN};
        PTokenRetriever pfn[3] = {GetSystemDirectory, GetRTMDirectory, GetInstallDirectory};
        char *lpszToken = NULL;
        char szReplacementValue[MAX_PATH+1];
        
        for(int i=0; i<sizeof(lppszTokenValues)/sizeof(*lppszTokenValues); i++)
        {
            *szReplacementValue = 0;

            while(lpszToken = strstr(lpszBuffer, lppszTokenValues[i]))
            {
                if (!*szReplacementValue)
                    if (!(*this.*pfn[i])(szReplacementValue,  sizeof(szReplacementValue)/sizeof(szReplacementValue[0])))
                    {
                        return FALSE;
                    }
                if (!ReplaceToken(lpszToken, 
                                           dwBufferLen - (lpszToken - lpszBuffer), // Remaining space in the buffer
                                           lppszTokenValues[i],
                                           szReplacementValue))
                {
                    fprintf(g_fLogFile, "Unable to de-tokenize %s\n", lppszTokenValues[i]);
                    return FALSE;
                }
            }
        }
        return TRUE;
    }// ReplaceTokens

    //-------------------------------------------------
    // ReplaceToken
    //
    // This function will replace a single token value with the
    // supplied value
    //
    // It returns TRUE if successful, FALSE if an error occured
    //-------------------------------------------------
    BOOL ReplaceToken(char *lpszBuffer, DWORD nSize, char *pszTokenToReplace, char* lpszTokenReplacementValue)
    {
        int nShift = strlen(lpszTokenReplacementValue) - strlen(pszTokenToReplace);

        int nLen = strlen(lpszBuffer);

        if ((nLen + nShift) > (int)nSize)
        {
            fprintf(g_fLogFile, "Our buffer isn't big enough to do the replacement\n");
            return FALSE;
        }
        
        // Start clearing room in the buffer for this substring
        char* lpszCurrent = NULL;
        char* lpszEnd = NULL;
        int     nChange = 0;
        // We need to make the buffer bigger
        if (nShift > 0)
        {
            lpszCurrent = lpszBuffer + nLen;
            lpszEnd = lpszBuffer + strlen(pszTokenToReplace)-1;
            nChange = -1;
        }
        // We need to make the buffer smaller
        else
        {
            lpszCurrent = lpszBuffer + strlen(pszTokenToReplace);
            lpszEnd = lpszBuffer + nLen+1;
            nChange = 1;
        }

        // Shift the buffer to make room for the replacement token
        while(lpszCurrent != lpszEnd)
        {
            *(lpszCurrent + nShift) = *lpszCurrent;
            lpszCurrent+=nChange;
        }

        // Now put in the token replacement
        while (*lpszTokenReplacementValue)
        {
            *lpszBuffer = *lpszTokenReplacementValue;
            lpszBuffer++;
            lpszTokenReplacementValue++;
        }

        return TRUE;
    }// ReplaceToken

    //-------------------------------------------------
    // GetSystemDirectory
    //
    // Retrieves the system directory
    //
    // It returns TRUE if successful, FALSE if an error occured
    //-------------------------------------------------

    BOOL GetSystemDirectory(char* pszSystemDir, DWORD nSize)
    {
            UINT nRet = GetSystemDirectoryA(pszSystemDir, nSize);

            if (nRet == 0 || nRet > nSize)
            {
                fprintf(g_fLogFile, "GetSystemDirectoryA failed\n");
                return FALSE;
            }
            else
                return TRUE;
    }// GetSystemDirectory

    //-------------------------------------------------
    // GetRTMDirectory
    //
    // Retrieves the directory where RTM lives
    //
    // It returns TRUE if successful, FALSE if an error occured
    //-------------------------------------------------
    BOOL GetRTMDirectory(char* pszRTMDirectory, DWORD nSize)
    {
        DWORD nNumChars = CopyWindowsDirectory(pszRTMDirectory, nSize);

        if (nNumChars == 0)
            return FALSE;

        if ((strlen("\\Microsoft.NET\\Framework\\v1.0.3705") + nNumChars) > nSize)
        {
            fprintf(g_fLogFile, "Buffer not large enough to create RTM directory\n");
            return FALSE;
        }               

        // Do the appending
        strcat(pszRTMDirectory, "\\Microsoft.NET\\Framework\\v1.0.3705");

        return TRUE;
    }// GetRTMDirectory

    //-------------------------------------------------
    // GetInstallDirectory
    //
    // Retrieves the root directory where runtimes get installed
    //
    // It returns TRUE if successful, FALSE if an error occured
    //-------------------------------------------------
    BOOL GetInstallDirectory(char* pszInstallDirectory, DWORD nSize)
    {
        DWORD nNumChars = CopyWindowsDirectory(pszInstallDirectory, nSize);

        if (nNumChars == 0)
            return FALSE;

        if ((strlen("\\Microsoft.NET\\Framework") + nNumChars) > nSize)
        {
            fprintf(g_fLogFile, "Buffer not large enough to create root Install directory\n");
            return FALSE;
        }               

        // Do the appending
        strcat(pszInstallDirectory, "\\Microsoft.NET\\Framework");

        return TRUE;
    }// GetInstallDirectory

    //-------------------------------------------------
    // CopyWindowsDirectory
    //
    // Retrieves the Windows directory
    //
    // It returns number of characters copied.
    //-------------------------------------------------
    DWORD CopyWindowsDirectory(char* pszWindowsDirectory, DWORD nSize)
    {
        DWORD nNumChars = GetWindowsDirectoryA(pszWindowsDirectory, nSize);

        if (nNumChars == 0 || nNumChars > nSize)
        {
            fprintf(g_fLogFile, "GetWindowsDirectoryA failed\n");
            return 0;
        }
        return nNumChars;
    }// CopyWindowsDirectory

    //-------------------------------------------------
    // ParseValues
    //
    // This will pull Registry values out of the file and populate the
    // regentry structure.
    //
    // It returns one of the error codes defined above.
    //-------------------------------------------------
    DWORD   ParseValues(struct RegEntry* reParent, FILE *fin)
    {   
        // The value strings should all look like this
        //
        //  "NameString" = "#1 Team Sites"

        char    buff[BUFFER_SIZE];
        char    *pszData = NULL;
        char    *pszEndOfValueName = NULL;
        char    *pszValueName = NULL;
        struct RegEntry* reValue = NULL;
        DWORD   nRet = PARSER_NOERROR;

        
        while (fgets(buff, sizeof(buff)/sizeof(buff[0]), fin))
        {
            // Chew up whitespace
            pszData = RunThroughWhitespace(buff);

            if (*buff == '#')
                continue;

            // See if we hit a key
            // It will look like either 
            //
            // ~[
            // or
            // [
            if (*pszData == '[' || (*pszData == '~' && *(pszData+1) == '['))
            {
                // Let's rewind and go back to parse the key
                // Move the file pointer 1 character prior to the start
                // of this string
                fseek(fin, (strlen(buff)+1)*-1, SEEK_CUR);
                return PARSER_NOERROR;
            }


            ReplaceTokens(buff, sizeof(buff)/sizeof(buff[0]));
            pszData = buff;

            // Chew up whitespace
            pszData = RunThroughWhitespace(pszData);
            
            // If we hit the end of the buffer, bail from the function
            if (!*pszData)
                return PARSER_NOERROR;

            BOOL fDelete = FALSE;

            // If the next character is a ~, then we want to delete this entry
            if (*pszData == '~')
            {
                fDelete = TRUE;
                pszData++;
            }

            // Check to see if the next character is a '@'
            if (*pszData == '@')
            {
                pszValueName = "";
                pszEndOfValueName = pszData;
            }
            else
            {
                // This next character better be a "
                if (*pszData != '\"')
                {
                    fprintf(g_fLogFile, "Was expecting a \", got %s\n", pszData);
                    return PARSER_ERROR_UNSUPPORTED_FORMAT;
                }
                pszData++;
                pszEndOfValueName = pszData;

                char *pszFoundQuote = strchr(pszEndOfValueName, '\"');
            
                // If this isn't a quote, bail
                if (pszFoundQuote == NULL)
                {
                    fprintf(g_fLogFile, "Was expecting a \", got %s\n", pszEndOfValueName);
                    return PARSER_ERROR_UNSUPPORTED_FORMAT;
                }

                pszEndOfValueName = pszFoundQuote;
                // Extract the value name
                *pszEndOfValueName = 0;
                pszValueName = pszData;
            }

            reValue = new struct RegEntry;
            reValue->pszValueName = strClone(pszValueName);

            // Now, go after the data
            // Make sure we have a '='

            // Chew through whitespace
            pszData = pszEndOfValueName;
            pszData++;
            pszData = RunThroughWhitespace(pszData);

            // This better be an '='

            if (*pszData != '=')
            {
                fprintf(g_fLogFile, "Was expecting a =, got %s\n", pszData);
                nRet = PARSER_ERROR_UNSUPPORTED_FORMAT;
                goto ErrExit;
            }
            pszData++;
            // Chew through more whitespace
            pszData = RunThroughWhitespace(pszData);

            // Make sure we still have data
            if (!*pszData)
            {
                fprintf(g_fLogFile, "Unexpected end of value\n");
                nRet = PARSER_ERROR_UNSUPPORTED_FORMAT;
                goto ErrExit;
            }

            nRet = ParseData(pszData, reValue);
            if (nRet != PARSER_NOERROR)
            {
                fprintf(g_fLogFile, "Unable to parse data\n");
                goto ErrExit;
            }              
            reValue->fDelete = fDelete;
            
            // Copy over the stuff from the parent
            reValue->hKey = reParent->hKey;
            reValue->pszSubKey = reParent->pszSubKey;

            // Place this in the linked list
            AddToList(reValue);
        }

        return PARSER_NOERROR;

        ErrExit:
        if (reValue != NULL)
            delete reValue;

        return nRet;
    }// ParseValues
        
    //-------------------------------------------------
    // ParseData
    //
    // This will parse the data associated with a registry value
    //
    // It returns one of the error codes defined above.
    //-------------------------------------------------
    DWORD ParseData(char*pszData, struct RegEntry* reValue)
    {
        // Ok, so if the next character is a ", then we have a string value. If not, then we have a DWORD value.
        // We won't support anything like binary blobs and such unless needed

        if (*pszData == '\"')
        {
            reValue->dwDataType = REG_SZ;

            pszData++;
            // Get to the end of the string
            char* pszEndOfValue = pszData;

            char *pszFoundQuote = strchr(pszEndOfValue, '\"');

            // If this is null, we got a problem
            if (pszFoundQuote ==  NULL)
            {
                fprintf(g_fLogFile, "Expecting a \", got %s\n", pszEndOfValue);
                return PARSER_ERROR_UNSUPPORTED_FORMAT;
            }
            pszEndOfValue = pszFoundQuote;
            *pszEndOfValue = 0;
            reValue->pData = (BYTE*)strClone(pszData);
            reValue->cbData = strlen(pszData);
        }
        else
        {
            // Ok, this is an integer value
            reValue->dwDataType = REG_DWORD;

            char *pszEndOfValue = pszData;
            // Go to the end of the integer value
            while(*pszEndOfValue && *pszEndOfValue != '\n') pszEndOfValue++;

            // Stomp down a null
            *pszEndOfValue = 0;
            DWORD *pdwValue = new DWORD[1];
            *pdwValue = atoi(pszData);
            reValue->pData = (BYTE*)pdwValue;
            reValue->cbData = sizeof(DWORD);
        }
        return PARSER_NOERROR;
    }// ParseData
        
    //-------------------------------------------------
    // ParseKey
    //
    // This will parse a registry key from the supplied buffer
    //-------------------------------------------------
    struct RegEntry* ParseKey(char *pszBuffer)
    {
        struct RegEntry *reNewKey = NULL;
        BOOL   fDelete = FALSE;

        // See if we want to delete this key
        if (*pszBuffer == '~')
        {
            fDelete = TRUE;
            pszBuffer++;
        }

        // Ok, the key should look like this
        //
        // 
        // [HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\Snapins\{94B9D51F-C874-4DA0-BC13-FDA94CBF72DE}]

        // Verify first character is the '['
        if (*pszBuffer != '[')
        {
            fprintf(g_fLogFile, "Expecting [, got %s\n", pszBuffer);
            return NULL;
        }
        pszBuffer++;

        // Figure out which key to use
        char* pszEndOfKey = pszBuffer;
        char *pszFoundSlash = strchr(pszEndOfKey, '\\');

        // Make sure we hit the '\'
        if (pszFoundSlash == NULL)
        {
            fprintf(g_fLogFile, "Expecting \\, got %s\n", pszEndOfKey);
            return NULL;
        }
        pszEndOfKey = pszFoundSlash;
        // Ok, figure out what this is.
        *pszEndOfKey = 0;

        reNewKey = new struct RegEntry;

        reNewKey->fDelete = fDelete;

    
        if (!strcmp("HKEY_LOCAL_MACHINE", pszBuffer))
            reNewKey->hKey = HKEY_LOCAL_MACHINE;
        else if (!strcmp("HKEY_CLASSES_ROOT", pszBuffer))
            reNewKey->hKey = HKEY_CLASSES_ROOT;
        else if (!strcmp("HKEY_CURRENT_USER", pszBuffer))
            reNewKey->hKey = HKEY_CURRENT_USER;
        else
        {
            // We don't support this key
            fprintf(g_fLogFile, "Don't support the key %s\n", pszBuffer);
            goto ErrExit;
        }

        // Cool so far. Let's grab the subkey now
        pszEndOfKey++;
        char* pszStartOfKey = pszEndOfKey;
        char *pszFoundBracket = strchr(pszEndOfKey, ']');

        if (pszFoundBracket == NULL)
        {
            fprintf(g_fLogFile, "Expected ], got %s\n", pszEndOfKey);
            goto ErrExit;
        }
        pszEndOfKey = pszFoundBracket;
        *pszEndOfKey = 0;
        
        reNewKey->pszSubKey = strClone(pszStartOfKey);

        // We're not setting any values here
        reNewKey->pszValueName = NULL;

        return reNewKey;
                    
        ErrExit:
            if (reNewKey != NULL)
                delete reNewKey;

            return NULL;
    }// ParseKey


    //-------------------------------------------------
    // strClone
    //
    // Clones a string
    //-------------------------------------------------
    char* strClone(char* s)
    {
        int nLen = strlen(s);
        char *newBuf = new char[nLen+1];
        if (newBuf != NULL)
            strcpy(newBuf, s);
        return newBuf;
    }// strClone

    //-------------------------------------------------
    // AddToList
    //
    // This adds a registry entry structure to the end of our linked
    // list
    //-------------------------------------------------
    void AddToList(struct RegEntry* pNew)
    {
        if (m_pHead == NULL)
        {
            pNew->next = NULL;
            m_pHead = pNew;
        }
        else
        {
            struct RegEntry* pLast = m_pHead;

            while (pLast->next != NULL)
                pLast = pLast->next;

            pLast->next = pNew;
            pNew->next = NULL;
        }

    }// AddToList

    //-------------------------------------------------
    // RunThroughWhitespace
    //
    // This will advance a pointer through any whitespace
    //-------------------------------------------------
    char* RunThroughWhitespace(char* psw)
    {
        // Run through any whitespace
        while (*psw == ' ' || *psw == '\t' || *psw == '\n' || *psw == '\r') psw++;

        return psw;
    }// RunThroughWhitespace

    struct RegEntry*    m_pHead;
};// class RegistryKeyParser


// We accept one of two command line arguments
//
// Either NETFXSBS10.EXE /install
//
// or 
//
// NETFXSBS10.EXE /uninstall
void PrintUsage(char* pszExeFilename)
{
    printf("Usage is as follows: \n");
    printf("%s [-install] [-uninstall]\n", pszExeFilename);
}// PrintUsage

//-------------------------------------------
// ParseArgs
// 
//
// This parses the command line
//-------------------------------------------
int ParseArgs(int argc, char** argv)
{
    // We only care about the second argument right now
    // We'll accept either
    // -install or -uninstall
    // /install or /uninstall
    // install or uninstall

    char *pInstallOption = argv[1];

    if (*pInstallOption == '-') pInstallOption++;
    if (*pInstallOption == '/') pInstallOption++;

    if (!strcmp(pInstallOption, "install"))
        return HOOK_OPTION_INSTALL;

    if (!strcmp(pInstallOption, "uninstall"))
        return HOOK_OPTION_UNINSTALL;

    // We don't know this option
    return HOOK_OPTION_UNKNOWN;
}// ParseArgs

//-------------------------------------------
// HandleRegistryEntries
// 
//
// Takes care of the Registry stuff
//-------------------------------------------

BOOL HandleRegistryEntries(char *pszRegFile, BOOL fInstall)
{
    RegistryKeyParser rkp;

    DWORD nRet = rkp.LoadAndParseRegFile(pszRegFile, fInstall);

    if (nRet  == PARSER_NOERROR)
    {
        // Enable for debugging purposes only
        rkp.DumpKeys();
    }
    else
    {
        if (nRet == PARSER_ERROR_FILE_NOT_FOUND)
            printf("Could not open the file %s\n", pszRegFile);

        else if (nRet == PARSER_ERROR_UNSUPPORTED_FORMAT)
            printf("The file format is unsupported (errors in the file perhaps?)\n");

        else
            printf("An unknown error occured.\n");

        return FALSE;    
    }

    nRet = rkp.ApplyRegistrySettings();
    if (nRet != PARSER_NOERROR)
    {
        printf("There was an error writing stuff to the registry\n");
        return FALSE;
    }
    // Everything went ok
    return TRUE;
}// HandleRegistryEntries

//-------------------------------------------
// HandleSecurityPolicy
// 
//
// Takes care of security stuff
//-------------------------------------------
BOOL HandleSecurityPolicy(BOOL fInstall)
{
    // Migrate the policy if we're installing
    if (fInstall)
    {

        STARTUPINFOA si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        memset(&pi, 0, sizeof(pi));
    
        BOOL fResult = CreateProcessA("migpolwin.exe",
                                                       "migpolwin.exe -migrate 1.0.3705",
                                                       NULL,
                                                       NULL,
                                                       FALSE,
                                                       0,
                                                       NULL,
                                                       NULL,
                                                       &si,
                                                       &pi);

        if (fResult)
        {
            // Wait until child process exits.
            WaitForSingleObject( pi.hProcess, INFINITE );

            // Close process and thread handles. 
            CloseHandle( pi.hProcess );
            CloseHandle( pi.hThread );
        }
        else
        {
            fprintf(g_fLogFile, "Error migrating security policy\n");
            return FALSE;
        }
    }
    return TRUE;
}// HandleSecurityPolicy

//-------------------------------------------
// Main
// 
//-------------------------------------------
int __cdecl main(int argc, char** argv)
{

    char    szTempFilename[MAX_PATH+1];    

    DWORD nNumChars = GetTempPathA(sizeof(szTempFilename)/sizeof(szTempFilename[0]), szTempFilename);

    if (nNumChars == 0 || (nNumChars + strlen("NETFXSBS10.log")) > sizeof(szTempFilename)/sizeof(szTempFilename[0]))
        g_fLogFile = stdout;

    else
    {
        strcat(szTempFilename, "NETFXSBS10.log");           
        g_fLogFile = fopen(szTempFilename, "wt");
        if (g_fLogFile == NULL)
            g_fLogFile = stdout;
    }


    if (argc != 2)
    {
        PrintUsage(argv[0]);
        return -1;
    }

    int nOption = ParseArgs(argc, argv);

    if (nOption == HOOK_OPTION_UNKNOWN)
    {
        PrintUsage(argv[0]);
        return -1;
    }

    char* pszRegFile = HOOK_REGFILE;
    BOOL fInstall = TRUE;
    
    if (nOption == HOOK_OPTION_UNINSTALL)
        fInstall = FALSE;
        
    if (!HandleRegistryEntries(pszRegFile, fInstall))
        return -1;

    // Make sure this is done last. It involves managed code, so we need to make sure the environment is
    // set up correctly so it can run
    if (!HandleSecurityPolicy(fInstall))
        return -1;

    return 0;
}// main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\htoil\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "HTOIL.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft converter H to CIL\0"
#define VER_ORIGFILENAME_STR    "HtoIL.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\installhook\versioneddll\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "sbscmp10.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework v1.0 compatibility\0"
#define VER_ORIGFILENAME_STR    "sbscmp10.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\internalresgen\internalresgen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <stdio.h>
#include <iostream.h>
#include <string.h>
#include <process.h>
#include <malloc.h>
#include <__file__.ver>         //file version info - variable, but same for all files
#include <assert.h>

/**
 * Common Language Runtime Resource file Generator
 * 
 * This program will read in text files of name-value pairs and produces
 * a CLR .resources file.  The file must have name=value, and
 * comments are allowed ('#' at the beginning of the line).  
 *
 * Compare to ResGen.cs in the FX source base.  This is an unmanaged solution,
 * required for both the CLR & FX build processes to succeed.
 * 
 * @author Rajesh Chandrashekaran, Brian Grunkemeyer
 * @version 0.99 (to be in sync with the managed resgen)
 */

// For debugging info in our .resources file.
//#define RESOURCE_FILE_FORMAT_DEBUG (1)

// Increase size to decrease collisions
#define HASHTABLESIZE 1027

// Resource header information
// Keep these in sync with System.Resources.ResourceManager
#define MAGICNUMBER 	     0xBEEFCACE
#define RESMGRHEADERVERSION  0x1
// Keep this in sync with System.Resources.RuntimeResourceSet
#define VERSION			     0x1
#define READERTYPENAME       (L"System.Resources.ResourceReader, mscorlib")
#define SETTYPENAME          (L"System.Resources.RuntimeResourceSet, mscorlib")

// Failure exit code
#define FAILEDCODE		0xbaadbaad

// Each hashtable entry is a sorted singly linked list

#define MAX_NAME_LENGTH 255
#define MAX_VALUE_LENGTH 2048
#define MAX_LINE_LENGTH (MAX_NAME_LENGTH+MAX_VALUE_LENGTH + 4)

// Singly linked list implementation
class ListNode
{
	public:
		ListNode *next;
		wchar_t name[MAX_NAME_LENGTH+1]; // Static sizing to minimize calls to new, else we will need 3 calls to new v/s 1
		wchar_t value[MAX_VALUE_LENGTH+1];
};

class List
{
	private:
		ListNode *CreateListNode(const wchar_t * const name, const wchar_t * const value);
	
	public:
		ListNode *head;
		List(); 
		~List();
		bool FindOrInsertSorted(wchar_t* name, wchar_t *value); // Returns true if element already exists
		wchar_t* Lookup(wchar_t* name);
};


ListNode* List::CreateListNode(const wchar_t* const name, const wchar_t* const value)
{
	ListNode *p = new ListNode;
	if (p == NULL)
	{
		printf("Fatal Error!! Out of Memory.....Exiting\n");
		exit(FAILEDCODE);
	}

	wcscpy(p->name, name);
	wcscpy(p->value, value);

	int nLen = wcslen(value);

	p->next = NULL;

	return p;
}

List::List()
{
	head = NULL;
}

List::~List()
{
	while (head != NULL)
	{
		ListNode *temp = head;		
		head = head->next;
		delete temp;
	}
}

// If element is not found then insert at the end
bool List::FindOrInsertSorted(wchar_t * name, wchar_t * value)
{
	bool done = false;
	ListNode *element = CreateListNode(name,value);

	if (head == NULL)
		head = element; // Create a new List
	else
	{
		ListNode *temp = head;
		ListNode *previous = NULL;

		while((temp != NULL) && (!done))
		{
			if (_wcsicmp(name, temp->name) == 0) /* Element found */
			{
				delete element;
				return true;
			}

			// Incoming string comes lexicographically after this
			if (_wcsicmp(name, temp->name) < 0)
			{
				previous = temp;
				temp = temp->next;
			}
			else
			{
				// Insert at the beginning
				if (previous == NULL)
				{
					element->next = temp;
					head = element;
				}
				else
				{ // Insert at the end
	
					element->next = previous->next;
					previous->next = element;
				}
	
				done = true;

			}
		
		}

		if (!done) // Insert at the end
			previous->next = element;

	}
	return false;

}

wchar_t* List::Lookup(wchar_t * name)
{
	ListNode *temp = head;

	while(temp != NULL)
	{
		if (_wcsicmp(name, temp->name) == 0) /* Element found */
		{
			return temp->value;
		}

		temp = temp->next;
	}
	return NULL;
}


// NEVER CHANGE THIS HASH FUNCTION!
int GetResourceHashCode(wchar_t* string)
{
    // WE MUST NEVER CHANGE THIS HASH FUNCTION!
    // This hash function is persisted into our .resources files and must
    // be standardized so other people can read & write our .resources files.
    // This is used to eliminate string comparisons, but NOT to add resource
    // names to a hash table.
    assert(string != NULL);
    unsigned int hash = 5381;
    while(*string != '\0') {
        hash = ((hash << 5) + hash) ^ (*string);
        string++;
    }
    return (int) hash;
}

void QuickSortHelper(int * array, wchar_t** secondArray, int left, int right);

void ParallelArraySort(int* array, wchar_t** secondArray, int count)
{
    QuickSortHelper(array, secondArray, 0, count-1);
}

// Copied from Array's QuickSort implementation.
void QuickSortHelper(int * array, wchar_t** secondArray, int left, int right) {
    do {
        int i = left;
        int j = right;
        int pivot = array[(i + j) >> 1];
        do {
            while(array[i] < pivot) i++;
            while(pivot < array[j]) j--;
            assert(j>=left && j<=right);
			assert(i>=left && i<=right);
            if (i > j) break;
            if (i < j) {
                int tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
                if (secondArray != NULL) {
                    wchar_t* tmpString = secondArray[i];
                    secondArray[i] = secondArray[j];
                    secondArray[j] = tmpString;
                }
            }
            i++;
            j--;
        } while (i <= j);
        if (j - left < right - i) {
            if (left < j) {
                QuickSortHelper(array, secondArray, left, j);
            }
            left = i;
        }
        else {
            if (i < right) QuickSortHelper(array, secondArray, i, right);
            right = j;
        }
    } while (left < right);
}


// Basic hashtable implementation

// We hash the strings into one of HASHTABLESIZE buckets. Each bucket maintains a linked list of entries that hashes into this bucket.
// We then do a linear search through the list to check for name collisions. This hashtable also has an inbuilt enumerator.
class Hashtable
{	
	private:
	List *Hash[HASHTABLESIZE];
	int count;
	ListNode* currentnode;
	int nextindex;

    // Case-insensitive string hash function.  
    inline ULONG HashiString(wchar_t* szStrUnknownCase)
    {
        // Everywhere where we use len, we needed to add 1 for terminating
        // \0, so we'll just add 1 to len itself.
        unsigned int len = wcslen(szStrUnknownCase) + 1;
        wchar_t* szStr = (wchar_t*) alloca(len*sizeof(wchar_t));
        // CultureInfo.InvariantCulture's LCID is 0.
		// Include terminating \0 in both lengths.
        int r= LCMapStringW(0, LCMAP_UPPERCASE, szStrUnknownCase, len, szStr, len);
        assert(r && "Failure in LCMapStringW!");
        ULONG   hash = 5381;
        while (*szStr != 0) {
            hash = ((hash << 5) + hash) ^ *szStr;
            szStr++;
        }
        return hash % HASHTABLESIZE;
    }

	public:
	Hashtable()
	{
		for (int i=0;i<HASHTABLESIZE;i++)
			Hash[i] = NULL;
		count = 0;
		currentnode = NULL;
	}

	~Hashtable()
	{
		for (int i=0;i<HASHTABLESIZE;i++)
			if(Hash[i] != NULL)
			{
				delete Hash[i];
				Hash[i] = NULL;
			}

	}

	int GetCount()
	{
		return count;
	}

	bool FindOrAdd(wchar_t * szName, wchar_t * szValue)
	{
		int index = HashiString(szName);
		if (Hash[index] == NULL)
			Hash[index] = new List;

		bool duplicate = Hash[index]->FindOrInsertSorted(szName, szValue); /* True if duplicate entry, else its a normal insertion operation */
		if (!duplicate)
			count++; /* One more element successfully added */
		return duplicate;
	}

	wchar_t* Lookup(wchar_t * szName)
	{
		int index = HashiString(szName);
		if (Hash[index] == NULL)
			return NULL;
		
		wchar_t* value = Hash[index]->Lookup(szName);
		return value;
	}

	
	void ResetEnumerator()
	{
		currentnode = NULL;
		nextindex = 0;
	}

	
	bool MoveNext() // False if end of enumeration 
	{
		bool retval = false;

		if (currentnode != NULL)
		{
			currentnode = currentnode->next;
			if (currentnode)
				return true;
		}
		

		if (currentnode == NULL) // Find next item 
		{
			for (int i=nextindex;i<HASHTABLESIZE;i++)
			{
				if (Hash[i] == NULL)
					continue;
				else
				{
					retval = true;
					currentnode = Hash[i]->head;
					nextindex = i + 1;
					break;
				}
			}
		}
		return retval;
	}

	wchar_t *CurrentItemName()
	{
		return currentnode->name;
	}

	wchar_t *CurrentItemValue()
	{
		return currentnode->value;
	}
};


enum EncodingType
{
    UTF8,
    Unicode,
    LittleEndianUnicode,
    UnknownEncoding,
};

class StreamReader
{
private:
    wchar_t* chars;
    unsigned int len;
    unsigned int readPos;
	unsigned int lineNumber;

public:
    StreamReader(const char * const fileName) {
        len = 0;
        readPos = 0;
		lineNumber = 1;
        chars = NULL;
        unsigned int hi = 0;
        HANDLE handle = CreateFileA(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
		if (handle==INVALID_HANDLE_VALUE) {
            HRESULT hr = GetLastError();
            WCHAR error[1000];
            error[0] = L'0';
            int result = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                0, hr, 0, error, sizeof(error), 0);
			printf("InternalResGen: Looks like we couldn't open %s.  Reason: %ls\n", fileName, error);
			exit(-1);
		}
        unsigned int lo = GetFileSize(handle, (LPDWORD) &hi);
        assert((int)lo != -1);
        if (hi != 0) {
            assert(!"Your input file is too big!");
            printf("Your input file is way too big.  Try something less than 2 GB in size.\n");
            exit(1);
        }
        EncodingType enc = DetectEncoding(handle);
        int r = 0;
        unsigned int numBytesRead = 0;
        switch(enc) {
        case LittleEndianUnicode:
            chars = new wchar_t[lo/2];
            r = ReadFile(handle, chars, lo, (LPDWORD)&numBytesRead, NULL);
            assert(r);
            len = numBytesRead / 2;
            break;
            
        case Unicode:
            chars = new wchar_t[lo/2];
            r = ReadFile(handle, chars, lo, (LPDWORD)&numBytesRead, NULL);
            assert(r);
            len = numBytesRead / 2;
            // Now swap every byte.
            for(unsigned int i=0; i<len; i++) {
                unsigned short ch = chars[i];
                chars[i] = (ch >> 8) | (ch << 8);
            }
            break;
          
        case UTF8:
        case UnknownEncoding: 
            {
                char* bytes = new char[lo];
                r = ReadFile(handle, bytes, lo, (LPDWORD)&numBytesRead, NULL);
                assert(r);
                r = MultiByteToWideChar(CP_UTF8, 0, bytes, numBytesRead, NULL, 0);
                chars = new wchar_t[r];
				assert(chars != NULL);
                assert(r > 0 || numBytesRead == 0);
                len = r;
                r = MultiByteToWideChar(CP_UTF8, 0, bytes, numBytesRead, chars, len);
                assert(r > 0 || numBytesRead == 0);
                delete [] bytes;
                break;
            }

        default:
            assert(!"Unrecognized EncodingType!");
            exit(-1);
        }
        CloseHandle(handle);
    }

    ~StreamReader()
    {
        Close();
    }

    void Close() {
        if (chars != NULL) {
            delete [] chars;
            chars = NULL;
        }        
    }

    EncodingType DetectEncoding(HANDLE handle)
    {
        char bytes[3];
        int bytesRead = 0;
        int r = ReadFile(handle, bytes, 3, (LPDWORD) &bytesRead, NULL);
        assert(r);
        if (bytesRead < 2) {
            SetFilePointer(handle, 0, NULL, FILE_BEGIN);
            return UnknownEncoding;
        }
        if (bytes[0] == (char)0xfe && bytes[1] == (char)0xff) {
            SetFilePointer(handle, -1, NULL, FILE_CURRENT);
            return Unicode;
        }
        if (bytes[0] == (char)0xff && bytes[1] == (char)0xfe) {
            SetFilePointer(handle, -1, NULL, FILE_CURRENT);
            return LittleEndianUnicode;
        }
        if (bytesRead==3 && bytes[0] == (char)0xEF && bytes[1] == (char)0xBB && bytes[2] == (char)0xBF)
            return UTF8;
        SetFilePointer(handle, 0, NULL, FILE_BEGIN);
        return UnknownEncoding;
    }


    bool ReadLine(wchar_t line[], int& numChars)
    {
        unsigned int index = readPos;
        do {
            wchar_t ch = chars[index];
            if (ch == L'\r' || ch == L'\n' || index-1==len) {
                // Check for a possible buffer overflow...
                if (index - readPos > MAX_LINE_LENGTH) {
                    wchar_t* output = new wchar_t[index-readPos+1];
                    memcpy(output, chars+readPos, (index-readPos)*sizeof(wchar_t));
                    output[index-readPos] = L'\0';
                    printf("Ack!  Line was too long - fix InternalResGen for longer lines?  (email BCL team - fwbcl)  Length: %d  line: %ls\n", index - readPos, output);
                    delete[] output;
                    exit(-1);
                }
                numChars = index - readPos;
                if (numChars == 0)
                    return true;
                memcpy(line, chars+readPos, numChars*sizeof(wchar_t));
                line[numChars] = L'\0';
                if (ch == L'\r' && index < len && chars[index+1] == L'\n')
                    index++;
                readPos = index+1;
                lineNumber++;
                return true;
            }
			index++;
        } while (index < len);
		numChars = index - readPos;
        if (numChars == 0)
		    return true;
		memcpy(line, chars+readPos, numChars*sizeof(wchar_t));
        line[numChars] = L'\0';
		readPos = len;
        lineNumber++;
        return true;
    }

    int ReadChar()
    {
        if (readPos == len)
            return -1;
        wchar_t ch = chars[readPos++];
        if (ch == '\n')
            lineNumber++;
        return ch;
    }

    int GetLineNumber()
    {
        return lineNumber;
    }
};

// Resources class does the resource reading and writing and has built-in support 
// for Writing UTF-8 Strings

class Resources
{
	private:
	FILE *fp;
	wchar_t name[MAX_NAME_LENGTH+1];
	wchar_t value[MAX_VALUE_LENGTH+1];

    long GetPosition()
    {
        return ftell(fp);
    }
	
	int WriteUTF8(wchar_t * lpszName)
	{
        return WriteUTF8(lpszName, true);
	}

	int WriteUTF8(const wchar_t * const lpszName, bool write)
	{        
		// Write the len and the UTF8 encoded String without the terminating null
		int nLen = wcslen(lpszName);
		int delta = 1;
		
        // get byte length
        // Convert string to UTF-8 & write.
        int byteLen = WideCharToMultiByte(CP_UTF8, 0, lpszName, nLen, NULL, 0, NULL, NULL);
        assert(byteLen > 0 || nLen == 0);
        assert(byteLen >= nLen);

        unsigned int value = byteLen;
		// Strings with length > 0x7F have their length encoded in multi-bytes
		while (value >= 0x80) 
		{
			if (write)
				fprintf(fp,"%c", (value & 0x7f) | 0x80);
			value >>= 7;
			delta++;
	    }

		if (write)
		{
            char* bytes = new char[byteLen+1];
            int r = WideCharToMultiByte(CP_UTF8, 0, lpszName, nLen, bytes, byteLen+1, NULL, NULL);
            assert(r > 0 || nLen == 0);
            bytes[r] = '\0';
			fprintf(fp, "%c", value);
            fprintf(fp, "%s", bytes);
            delete[] bytes;
		}

		return byteLen + delta;
	}

	int WriteUTF16(wchar_t * lpszName)
	{
        return WriteUTF16(lpszName, true);
	}

    // Writes a string out in unicode, depending on the write boolean.  Does 
    // return the number of bytes it would have written.
	int WriteUTF16(const wchar_t * const lpszName, bool write)
	{        
		// Write the len and the UTF8 encoded String without the terminating null
		int nLen = wcslen(lpszName);
		int delta = 1;
		
        // get byte length
        int byteLen = nLen * 2;

        unsigned int value = byteLen;
		// Strings with length > 0x7F have their length encoded in multi-bytes
		while (value >= 0x80) 
		{
			if (write)
				fprintf(fp,"%c", (value & 0x7f) | 0x80);
			value >>= 7;
			delta++;
	    }

		if (write)
		{
			fprintf(fp, "%c", value);
            fwprintf(fp, L"%s", lpszName);
		}

		return byteLen + delta;
	}

    void WriteByte(unsigned char value)
    {
        fprintf(fp, "%c", value);
    }

	void WriteInt32(unsigned long value)
	{
		char *buf = (char *)&value;
		for (int i = 0 ;i < 4; i++)
			fprintf(fp,"%c",buf[i]);
	}

	void Write7BitEncodedInt32(unsigned long value)
	{
        while (value >= 0x80) {
            fprintf(fp,"%c", (char) (value | 0x80));
            value >>= 7;
        }
        fprintf(fp, "%c", value);
	}

	
	

	public:
	Hashtable resources;
	
	Resources()
	{
	}


	// Borrowed from the managed implementation. See ResourceWriter.cs
    // (Note - this comment is out of date, but somewhat approximately right.)
	/*
	 * Resource File Format
	 *
	 * There are three sections to the this file format.  The first
	 * is the Resource Manager header, which consists of a magic number
	 * that identifies this as a Resource file, and a ResourceSet class name.
	 * System.Resources.ResourceReader
	 *
	 * The second section in the system default file format is the 
	 * RuntimeResourceSet specific header.  This contains a version number for
	 * the .resources file, the number of resources in this file, the name and 
	 * virtual offset of each resource, the number of different classes 
	 * contained in the file, and a list of fully qualified class names.  This class
	 * table allows us to read multiple different classes from the same file, 
	 * including user-defined types, in a more efficient way than using 
	 * Serialization, at least when your .resources file contains a reasonable 
	 * proportion of base data types such as Strings or ints.  We use Serialization for
	 * all the non-instrinsic types. We only have "System.String" in the classtable
	 * for this specific case since we only deal with Strings.
	 * 
	 * <p>The third section in the file is the data section, which consists
	 * of a type and a blob of bytes for each item in the file.  The type is 
	 * an integer index into the class table.  The data is specific to that type,
	 * but may be a number written in binary format, a String, or a serialized 
	 * Object.
	 * 
	 * <p>The system default file format is as follows:
	 * 
	 * <table id=FileFormat lang=en-US align=center border=1 cellpadding=3 summary="default Resource File Format">
	 * <caption><em>System Default Resource File Format</em></caption>
	 * <tr><th>What <th>Type of Data
	 * <tr><td colspan=2><em><center>Resource Manager header</center></em>
	 * <tr><td>Magic Number (0xBEEFCACE) <td>Int32
	 * <tr><td>Class name of ResourceSet to parse this file <td>String
	 * <tr><td colspan=2><em><center>RuntimeResourceReader header</center></em>
	 * <tr><td>Version number <td>Int32
	 * <tr><td>Number of resources in the file <td>Int32
	 * <tr><td>Name &amp; virtual offset of each resource <td>Set of (String, Int32) pairs
	 * <tr><td>Number of classes in the class table <td>Int32
	 * <tr><td>Name of each class <td>Set of Strings
	 * <tr><td colspan=2><em><center>RuntimeResourceReader Data Section</center></em>
	 * <tr><td>Type and Value of each resource <td>Set of (Int32, blob of bytes) pairs
	 * </table>
	 */

	bool WriteResources(char* szOutFile)
	{
		fp = fopen(szOutFile,"wb");
		if (fp == NULL)
		{
			printf("ResGen: Error: Couldn't write output file \"%s\"",szOutFile);
			return false;
		}

		printf("Writing resource file \"%s\"...  \n",szOutFile);

		// Write out the ResourceManager header
		// Write out magic number
		WriteInt32(MAGICNUMBER);

        // Write out ResourceManager header version
        WriteInt32(RESMGRHEADERVERSION);

        // Write out number of bytes to skip to get past ResourceManager header.
        int numBytesToSkip = wcslen(READERTYPENAME) + 1 + wcslen(SETTYPENAME) + 1;
        WriteInt32(numBytesToSkip);

		// Write out type name of ResourceReader capable of handling this file
		WriteUTF8(READERTYPENAME);

        // Write out type name for ResourceSet we want handling this file.
		WriteUTF8(SETTYPENAME);
        // End ResourceManager header

				
		// Write out the RuntimeResourceSet header
		// Version number
		WriteInt32(VERSION);
			
		// number of resources
		WriteInt32(resources.GetCount());

		// Reset enumerator. Hashtable has an enumerator to walk the entries
		resources.ResetEnumerator();

		unsigned long virtualoffset = 0;

		// Write the total count of types in this .resources file. We have only "System.String"
		WriteInt32(0x1);

		// Write the name of each class in this case we only have String class
		WriteUTF8(L"System.String, mscorlib");

        // Write the sorted hash values for each resource name.
		resources.ResetEnumerator();
        int numResources = resources.GetCount();
        int* nameHashes = new int[numResources];
        wchar_t** names = new wchar_t*[numResources];
        int i=0;
		for(i=0; i<numResources; i++) {
			nameHashes[i] = 0xdeadbeef;
			names[i] = (wchar_t*) 0xdeadbeef;
		}
		i=0;
        while (resources.MoveNext()) {
            names[i] = resources.CurrentItemName();
            nameHashes[i] = GetResourceHashCode(names[i]);
			//wprintf(L"Resource name: \"%s\"  name hash: %x\n", names[i], nameHashes[i]);
            i++;
        }

        ParallelArraySort(nameHashes, names, numResources);

        // The array of name hashes must be aligned on an 8 byte boundary!
        int alignBytes = GetPosition() & 7;
        if (alignBytes > 0) {
            for(i=0; i<8 - alignBytes; i++)
                WriteByte("PAD"[i % 3]);
        }

        for(i=0; i<numResources; i++)
            WriteInt32(nameHashes[i]);

        // Write location within the name section for each resource name
        virtualoffset = 0;
#if RESOURCE_FILE_FORMAT_DEBUG
		virtualoffset += 5;  // Make room to write "NAMES" at start of name section.
#endif
        for(i = 0; i<numResources; i++) {
			//printf("For %S, nameSectionOffset is %x\n", names[i], virtualoffset);
			WriteInt32(virtualoffset);
			
			// Don't actually write just compute the size
			//wprintf(L"Computing size for name: \"%s\"  name hash: %x\n", names[i], nameHashes[i]);
			virtualoffset += WriteUTF16(names[i], false) + 4;  // Add 4 for data section offset
#if RESOURCE_FILE_FORMAT_DEBUG
			virtualoffset++;  // Add one for the '*' trailing each name/offset pair.
#endif
        }

        // Write out the start of the data section.  This requires knowing the 
        // length of the name section.
        int dataSectionOffset = virtualoffset + 4 + GetPosition();
        WriteInt32(dataSectionOffset);
        //printf("nameSectionOffset: %x\n", GetPosition());
        //printf("dataSectionOffset: %x\n", dataSectionOffset);

        // Write out the names section in UTF-16 (little endian unicode, prefixed
        // by the string length)
		int dataVA = 0;
#if RESOURCE_FILE_FORMAT_DEBUG
		dataVA += 4;  // Skip over "DATA" in the data section.
		fprintf(fp, "%c%c%c%c%c", 'N', 'A', 'M', 'E', 'S');
#endif
		// Need to write out the data items in the corresponding order for the names.
		// Do NOT use the resources enumerator here.
		for(i=0; i<numResources; i++) {
			// Write the name and the current location in the data section for the value
			WriteUTF16(names[i]);
			WriteInt32(dataVA);
			wchar_t* value = resources.Lookup(names[i]);
			if (value == NULL) {
				printf("We're doomed, expected to find value for key %S\n", names[i]);
			}
			assert(value != NULL);
			//printf("For name[%d] (\"%S\"), writing out value \"%S\"\n", i, names[i], value);
			dataVA += WriteUTF8(value, false) + 1;  // Plus 1 for the type code
#if RESOURCE_FILE_FORMAT_DEBUG
			fprintf(fp, "*");
#endif
		}

		// Write data section. index and value pairs
#if RESOURCE_FILE_FORMAT_DEBUG
		fprintf(fp, "%c%c%c%c", 'D', 'A', 'T', 'A');
#endif
		// MUST write out data in the same order as the names are written out.
		for(i=0; i<numResources; i++) {
			wchar_t* value = resources.Lookup(names[i]);
			if (value == NULL) {
				printf("We're doomed, expected to find value for key %S\n", names[i]);
			}
			Write7BitEncodedInt32(0);	// We only have "System.String" types
			WriteUTF8(value);
		}

		fclose(fp);
        delete[] nameHashes;
        delete[] names;
		printf("Done.\n");
		return true;
	}


	bool ReadResources(char* szInFile)
	{
        StreamReader sr(szInFile);
        wchar_t line[MAX_LINE_LENGTH+1];

		while(true) 
		{
			int i = 0;
			// Read in name
			int ch = sr.ReadChar();
            int numChars = 0;
            bool r;
			if (ch == -1)
				break;
			if (ch == L'\n' || ch == L'\r')
				continue;
			// Skip over commented lines or ones starting with whitespace.
			if (ch == L'#' || ch == L'\t' || ch == L' ' || ch == L';') 
			{
				// comment char (or blank line) - skip line.
                r = sr.ReadLine(line, numChars);
                assert(r && "ReadLine failed!");
				continue;
			}

            // We talked about having a [strings] section in a text file for a 
            // while.  Skip over it here.
            if (ch == L'[') {
                r = sr.ReadLine(line, numChars);
                assert(r);
                if (0!=wcscmp(line, L"strings]"))
				{
                    printf("Unexpected INF file bracket syntax on line %d - expected \"[strings]\", but got: \"[%ls\"\n", sr.GetLineNumber(), line);
					return false;
				}
                continue;
            }
			
			int offset = 0;
			while(ch != L'=') 
			{
                if (ch == L'\r' || ch == L'\n') {
                    name[offset] = L'\0';
                    printf("Found a resource that had a new line in it, but couldn't find the equal sign in it!  line #: %d  name: \"%ls\"\n", sr.GetLineNumber(), name);
                    exit(-1);
                }
				name[offset++] = ch;
				if (offset >= MAX_NAME_LENGTH)
				{
                    name[offset] = L'\0';
					printf("Resource string names should be shorter than %d characters, but you had one of length %d around line %d.  Name: \"%ls\"   Email BCL team if you have a problem with this.\n", MAX_NAME_LENGTH, sr.GetLineNumber(), offset, name);
					return false;
				}
				ch = sr.ReadChar();
				if (ch == -1)
					break;
			}
		
			// For the INF file, we must allow a space on both sides of the equals
            // sign.  Deal with it.
			if (offset && name[offset-1] == L' ')
				offset--;

			name[offset] = L'\0'; 

			// Skip over space if it exists
			ch = sr.ReadChar();
			if (ch == L' ') {
				r = sr.ReadLine(value, numChars);
                assert(r);
            }
			else
			{
				value[0] = ch;
				r = sr.ReadLine(value+1, numChars);
				numChars++;  // Include 'ch' in our character count.
                assert(r);
			}

            // Translate '\' and 't' to '\t', etc.
            for(int i=0; i<numChars; i++) {
                if (value[i] == '\\') {
                    switch(value[i+1]) {
                    case '\\':
                        value[i] = '\\';
                        memmove(&value[i+1], &value[i+2], (numChars - i - 1)*sizeof(wchar_t));
                        break;

                    case 'n':
                        value[i] = '\n';
                        memmove(&value[i+1], &value[i+2], (numChars - i - 1)*sizeof(wchar_t));
                        break;

                    case 'r':
                        value[i] = '\r';
                        memmove(&value[i+1], &value[i+2], (numChars - i - 1)*sizeof(wchar_t));
                        break;

                    case 't':
                        value[i] = '\t';
                        memmove(&value[i+1], &value[i+2], (numChars - i - 1)*sizeof(wchar_t));
                        break;

                    case '"':
                        value[i] = '\"';
                        memmove(&value[i+1], &value[i+2], (numChars - i - 1)*sizeof(wchar_t));
                        break;
                        
                    default:
                        printf("Unsupported escape character in value!  Line #: %d  name was: %ls  char value: 0x%x\n", sr.GetLineNumber(), name, value[i+1]);
                        exit(FAILEDCODE);
                    }
                    numChars--;
                }
            }
            value[numChars] = L'\0';

			if (value[0] == L'\0')
			{
				printf("Invalid file format - need name = value  Couldn't find value.  Line #: %d  name was \"%ls\"\n", sr.GetLineNumber(), name);
				return false;
			}

			// Use a Hashtable to check for duplicates			
			if (resources.FindOrAdd(name, value))
			{
				printf("Duplicate resource key or key differed only by case!  Name was: \"%ls\"  Second occurrence was on line #: %d\n", name, sr.GetLineNumber());
				return false;
			}
            /*
            else
                printf("Added resource named %ls\n", name);
            */
		}
		sr.Close();
		printf("Read in %d resources from %s\n", resources.GetCount(), szInFile);
		return true;
	}
};



void Usage()
{
    printf("Microsoft (R) .NET Framework Resource Generator %s\n",VER_FILEVERSION_STR);
    printf("Copyright (c) Microsoft Corp 1998-2000.  All rights reserved.\n\n");
    printf("Internal ResGen filename.txt [output File]\n\n");
    printf("Converts a text file to a binary .resources file.  Text file must look like:");
    printf("# Use # at the beginning of a line for a comment character.\n");
    printf("name=value\n");
    printf("more elaborate name=value 2\n");
}


int __cdecl main(int argc,char *argv[])
{

	if (argc < 2 || strcmp(argv[1],"-h") == 0  || strcmp(argv[1],"-?") == 0 ||
            strcmp(argv[1],"/h") == 0 || strcmp(argv[1],"/?") == 0)
	{
		Usage();
		return FAILEDCODE;
	}

	char inFile[255];
	strcpy(inFile, argv[1]);
	int length = strlen(inFile);

	if ( (length>4) && (strcmp(inFile + length - 4,".txt") != 0))
		strcat(inFile, ".txt");

	Resources resources;
	if (!resources.ReadResources(inFile))
		return FAILEDCODE; // Read operation failed. Error messages should be generated by the function
	
	char outFile[255];
	if (argc > 2)
	{
		strcpy(outFile,argv[2]);
	}
	else 
	{
        // Note that the naming scheme is basename.en-us.resources
        char * end = strrchr(inFile, '.');
        strncpy(outFile, inFile, end - inFile);
        outFile[end-inFile] = '\0';
		strcat(outFile,".resources");
	}
		
	if (!resources.WriteResources(outFile))
		return FAILEDCODE; // Write operation failed. Error messages should be generated by the function
	
	// Tell build we succeeded.
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\internalresgen\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "OpCodeGen.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework resource generator\0"
#define VER_ORIGFILENAME_STR    "OpCodeGen.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ismgd\ceeload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "..\..\ildasm\ceeload.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ismgd\ismgd.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define INITGUID

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>
#include <utilcode.h>
#include <malloc.h>
#include <string.h>
#include "DebugMacros.h"
#include "corpriv.h"
#include "ceeload.h"

#include "__file__.ver"
#include "corver.h"

PELoader *              g_pPELoader = NULL;
IMAGE_COR20_HEADER *    g_CORHeader;

int _cdecl main (int argc, char **argv)
{
 	char		*szFilenameANSI;
	int			exitcode=5;
//_ASSERTE(0);
	if(argc >= 2)
	{
		exitcode--;
		szFilenameANSI = argv[1];
		CoInitialize(NULL);
		CoInitializeCor(COINITCOR_DEFAULT);
		CoInitializeEE(COINITEE_DEFAULT);
		g_pPELoader = new PELoader();
		if (g_pPELoader)
		{
			exitcode--;
			if (g_pPELoader->open(szFilenameANSI))
			{
				exitcode--;
				if (g_pPELoader->getCOMHeader(&g_CORHeader))
				{
					exitcode--;
					if (g_CORHeader->MajorRuntimeVersion != 1 && g_CORHeader->MajorRuntimeVersion <= COR_VERSION_MAJOR) exitcode--;
				}
			}
			g_pPELoader->close();
			delete(g_pPELoader);
		}
		CoUninitializeEE(COUNINITEE_DEFAULT);
		CoUninitializeCor();
		CoUninitialize();
	}
	exit(exitcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ismgd\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ISMGD.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Managed File Identifier\0"
#define VER_ORIGFILENAME_STR    "ismgd.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ismgd\makefile.inc ===
!if "$(LINKONLY)" == "1"

SetExeConsole: 
	editbin /subsystem:console $(TARGETCORBIN)\i386\$(DDKBUILDENV)\ildasm.exe
	editbin /subsystem:console $(TARGETCOMPLUSSDK)\bin\ildasm.exe

!else

SetExeConsole: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jit\jit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>

#include "utilcode.h"
#include "corhlpr.cpp"
#include "corjit.h"
#include "corcompile.h"
#include "iceefilegen.h"

#include "zapper.h"

#include "corver.h"
#include "__file__.ver"

#define EXECUTABLE_CODE 0

/* --------------------------------------------------------------------------- *
 * Options class
 * --------------------------------------------------------------------------- */

class JitOptions : public ZapperOptions
{
  public:
    LPCWSTR     *m_inputs;
    SIZE_T      m_inputCount;
    SIZE_T      m_inputAlloc;

    JitOptions();
    ~JitOptions();
    HRESULT ReadCommandLine(int argc, LPCWSTR argv[]);
    void PrintUsage();
};

JitOptions::JitOptions()
  : ZapperOptions(), 
    m_inputs(NULL),
    m_inputCount(0),
    m_inputAlloc(0)
{
}

JitOptions::~JitOptions()
{
    delete [] m_inputs;
}

HRESULT JitOptions::ReadCommandLine(int argc, LPCWSTR argv[])
{
    HRESULT hr = S_OK;

    m_preload        = false;
    m_JITcode        = true;
    m_assumeInit     = false;
    m_logLevel       = 4;
    m_compilerFlags &= ~CORJIT_FLG_RELOC;


    // Turn off the JIT in the EE (thus the JIT will only be used to jit the methods we pass it)
    WszSetEnvironmentVariable(L"COMPLUS_JitEnable", L"0");
    while (argc-- > 0)
    {
        const WCHAR *arg = *argv++;

        if (*arg == '-' || *arg == '/')
        {
            arg++;
            switch (tolower(*arg++))
            {
            case 'n':
                m_preload = false;
                break;

            case 's':
                if (_wcsicmp(&arg[-1], L"stats") == 0)
                {
                    m_stats = true;
                    continue;
                }
                goto option_error;
                    
            case 'i':
                if (tolower(*arg) == 'l') 
                {
                    arg++;
                    m_jit = false;
                    break;
                }
                if (_wcsnicmp(&arg[-1], L"inc=", 3) == 0)
                {
                    m_onlyMethods = new MethodNamesList(const_cast<WCHAR*>(&arg[3]));
                    continue;
                }
                goto option_error;

            case 'e':
                if (_wcsnicmp(&arg[-1], L"exc=", 3) == 0)
                {
                    m_excludeMethods = new MethodNamesList(const_cast<WCHAR*>(&arg[3]));
                    continue;
                }
                goto option_error;

            case 'v':
                m_verbose = true;
                break;

            case 'o':
                switch (tolower(*arg))
                {
                case 's':
                    m_compilerFlags |= CORJIT_FLG_SIZE_OPT;
                    arg++;
                    break;

                case 't':
                    m_compilerFlags |= CORJIT_FLG_SPEED_OPT;
                    arg++;
                    break;

                default:
                    goto option_error;
                }
                break;

            case 'g':
                switch (tolower(*arg))
                {
                case 'b':
                    m_compilerFlags &= ~(CORJIT_FLG_TARGET_PENTIUM | CORJIT_FLG_TARGET_PPRO | CORJIT_FLG_TARGET_P4);
                    arg++;
                    break;

                case '5':
                    m_compilerFlags |= CORJIT_FLG_TARGET_PENTIUM;
                    arg++;
                    break;

                case '6':
                    m_compilerFlags |= CORJIT_FLG_TARGET_PPRO;
                    arg++;
                    break;

                case '7':
                    m_compilerFlags |= CORJIT_FLG_TARGET_P4;
                    arg++;
                    break;

                default:
                    goto option_error;
                }
                break;

            case 'z':
                switch (tolower(*arg))
                {
                case 'e':
                    m_compilerFlags |=   CORJIT_FLG_DEBUG_EnC
                                       | CORJIT_FLG_DEBUG_OPT 
                                       | CORJIT_FLG_DEBUG_INFO;
                    arg++;
                    break;

                case 'i':
                    if (_wcsicmp(arg, L"int") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitFullyInt", L"1");
                        continue;
                    }

                    m_compilerFlags |=   CORJIT_FLG_DEBUG_OPT 
                                       | CORJIT_FLG_DEBUG_INFO;
                    arg++;
                    break;

                case 'o':
                    m_compilerFlags &= ~CORJIT_FLG_DEBUG_OPT;
                    arg++;
                    break;

                case 's':
                    m_shared = true;
                    arg++;
                    break;

                default:
                    if (_wcsnicmp(arg, L"loglevel=", 9) == 0)
                    {
                        m_logLevel = _wtoi(&arg[9]);
                        continue;
                    }
                    if (_wcsicmp(arg, L"framed") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitFramed", L"1");
                        continue;
                    }
                    if (_wcsicmp(arg, L"cctor") == 0)
                    {
                        m_assumeInit = true;
                        continue;
                    }
                    if (_wcsicmp(arg, L"prejit") == 0)
                    {
                        m_compilerFlags |= CORJIT_FLG_RELOC;
                        m_JITcode = false;
                        m_preload = true;       // /Zjit => /n
                        m_assumeInit = false;   // /Zjit => /Zcctor
                        continue;
                    }
                    if (_wcsicmp(arg, L"dump") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitDump", L"*");
                        continue;
                    }
                    if (_wcsicmp(arg, L"dasm") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitDisasm", L"*");
                        continue;
                    }
                    if (_wcsicmp(arg, L"ldasm") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitLateDisasm", L"*");
                        continue;
                    }
                    if (_wcsicmp(arg, L"gc") == 0)
                    {
                        WszSetEnvironmentVariable(L"COMPLUS_JitGCDump", L"*");
                        continue;
                    }
                    goto option_error;
                }

            case 'r':
                m_recurse = true;
                break;

            case '?':
                PrintUsage();
                return S_FALSE;

            default:
                goto option_error;
            }
                
            if (*arg != 0)
            {
            option_error:
                printf("Unrecognized option %S\n", argv[-1]);
                hr = E_FAIL;
            }
        }
        else
        {
            if (m_inputCount == m_inputAlloc)
            {
                if (m_inputCount == 0)
                    m_inputAlloc = 5;
                else
                    m_inputAlloc *= 2;

                WCHAR **newInputs = new WCHAR * [m_inputAlloc];
                memcpy(newInputs, m_inputs, 
                       m_inputCount * sizeof(WCHAR *));

                delete [] m_inputs;                 
                m_inputs = (const WCHAR **) newInputs;
            }
            m_inputs[m_inputCount++] = arg;
        }
    }

    if (m_inputCount == 0)
        hr = E_FAIL;

    if (m_assumeInit && !m_JITcode)
    {
        printf("Cannot use /Zcctor with /Zprejit\n");
        hr = E_FAIL;
    }
    return hr;
}

void JitOptions::PrintUsage()
{
    printf("\nMicrosoft (R) COM+ IL Install-O-JIT.  Version " VER_FILEVERSION_STR);
    printf("\nUsage: jit [options] input-files\n"
           "\n"
           "    /n       don't preload classes\n"
           "    /il      don't jit code\n"
           "    /r       recursively compile dependent files (doesn't work)\n"
           "    /v       verbose\n"
           "    /os      optimize for space\n"
           "    /ot      optimize for speed\n"
           "    /gb      basic (386) code gen\n"
           "    /g5      pentium code gen\n"
           "    /g6      pentium pro code gen\n"
           "    /g7      pentium 4 code gen\n"
           "    /stats   print out compilation statistics at the end\n"
           "\n"
           "    /ze      edit and continue debugging enabled\n"
           "    /zi      normal debugging enabled\n"
           "    /zo      don't disable optimization when debugging\n"
           "    /zs      load assembly as domain shareable\n"
           "    /zprejit generate prejit code (runnable)\n"
           "    /zcctor  assume all class constructors have been run\n"
           "    /zframed generate code with stack frame register\n"
           "    /zint    generate fully interruptible code\n"
           "    /zoldrp  use the JIT's old register predictor\n"
           "    /zdump   print a compilation dump\n"
           "    /zdasm   print a machine code disassembly\n"
           "    /zldasm  print a late machine code disassembly\n"
           "    /zgc     print gc tracking information\n"
           "    /zloglevel=<num> print out compiler log messages (10 most verbose)\n"
           "\n"
           "    /inc=<methods>  only compile specified list of methods\n"
           "    /exc=<methods>  exclude specified list of methods\n"
           "             method names space separated (quote the whole qualifier)\n"
           "             Ilasm syntax for methods.\n"
           "                System.String::Tostring()\n"
           "                ::main                global function main\n"
           "                *::main               all methods named main\n"
           "                main(,)               all methods named main with 2 args\n"
           "                System.Foo::*         all methods of class System.Foo\n"
           );
}

/* --------------------------------------------------------------------------- *
 * main routine
 * --------------------------------------------------------------------------- */

int _cdecl wmain(int argc, LPCWSTR argv[])
{
    HRESULT hr;

    OnUnicodeSystem();

    JitOptions opt;
    hr = opt.ReadCommandLine(argc-1, argv+1);
    if (hr != S_OK)
    {
        if (FAILED(hr))
            opt.PrintUsage();
        exit(0);
    }

    //
    // Initialize COM & the EE
    //

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // 
    // Init unicode wrappers
    // 

    OnUnicodeSystem();

    //
    // Now, create the zapper
    //

    Zapper zapper(&opt);

    for (unsigned i = 0; i < opt.m_inputCount; i++)
    {
        zapper.Compile(opt.m_inputs[i]);
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitman\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"JITMAN.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime JIT Compiler Manager\0"
#define VER_ORIGFILENAME_STR    "jitman.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitmanager\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define ID_FILE_EXIT                    103
#define JITMGR_ICON                     104
#define HEAPVER_OFF                     108
#define HEAPVER_ON                      109
#define HEAPVER_ON_2                    110
#define GC_DBG_ON                       111
#define GC_DBG_OFF                      112
#define GC_STRESS_OFF                   113
#define GC_STRESS_ON                    114
#define GC_STRESS_ON_1                  115
#define GC_STRESS_ON_2                  116
#define GC_STRESS_ON_3                  117
#define LOG_ON                          118
#define LOG_OFF                         119
#define ZAP_ON                          120
#define ZAP_OFF                         121
#define ZAP_GENERATE                    122

#define VERIFIER_ON                     130
#define VERIFIER_OFF                    131

#define MARSHALER_ON                    136
#define MARSHALER_OFF                   137
#define EXCEPTION_ON                    138
#define EXCEPTION_OFF                   139

#define JIT_REQD                        140
#define JIT_ON                          141
#define JIT_OFF                         142

#define FLAVOR_WORKSTATION				143
#define FLAVOR_SERVER					144
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitman\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by jitman.rc
//
#define IDD_JITMANDLG_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDI_JITMAN                      131
#define IDR_MENU                        132
#define IDC_ECONOJIT                    1000
#define IDC_OP4SIZE                     1002
#define IDC_MAXPITCH                    1003
#define IDC_MAXCACHE                    1004
#define IDC_LBLPITCH                    1005
#define IDC_LBLCACHE                    1006
#define IDC_CONCURGC                    1007
#define IDC_LIMITCACHE                  1008
#define ID_CLOSE                        32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitmanager\jitmanager.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <stdio.h>
#include <shellapi.h>
#include <assert.h>
#include "resource.h"
#include "CorPerm.h"
#include "CorPermE.h"
#include <log.h>


void SetJitFullyInt(BOOL val);

#define MYWM_NOTIFYJIT        (WM_APP+4)
#define MYWM_TOGGLEJIT_ENABLE (WM_APP+5)
#define MYWM_TOGGLEJIT_REQD   (WM_APP+6)

#define MYWM_NOTIFYHEAPVER  (WM_APP+11)
#define MYWM_TOGGLEHEAPVER  (WM_APP+12)

#define MYWM_NOTIFYGC_DBG   (WM_APP+13)
#define MYWM_TOGGLEGC_DBG   (WM_APP+14)

#define MYWM_NOTIFYGC_STRESS (WM_APP+15)
#define MYWM_TOGGLEGC_STRESS (WM_APP+16)

#define MYWM_NOTIFYLOG      (WM_APP+17)
#define MYWM_TOGGLELOG      (WM_APP+18)

#define MYWM_NOTIFYVERIFIER  (WM_APP+19)
#define MYWM_TOGGLEVERIFIER  (WM_APP+20)

#define MYWM_NOTIFYFASTGCSTRESS  (WM_APP+21)
#define MYWM_TOGGLEFASTGCSTRESS  (WM_APP+22)

#define MYWM_TOGGLEGC_STRESS_1 (WM_APP+26)
#define MYWM_TOGGLEGC_STRESS_2 (WM_APP+27)
#define MYWM_TOGGLEGC_STRESS_4 (WM_APP+28)
#define MYWM_TOGGLEGC_STRESS_NONE (WM_APP+29)
#define MYWM_TOGGLEGC_STRESS_ALL (WM_APP+30)
#define MYWM_TOGGLEGC_STRESS_INSTRS (WM_APP+31)

#define MYWM_LOADER_OPTIMIZATION_DEFAULT            (WM_APP+32)
#define MYWM_LOADER_OPTIMIZATION_SINGLE_DOMAIN      (WM_APP+33)
#define MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN       (WM_APP+34)
#define MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST  (WM_APP+35)

#define MYWM_TOGGLE_AD_UNLOAD                       (WM_APP+36)
#define MYWM_TOGGLE_AD_AGILITY_CHECKED              (WM_APP+37)
#define MYWM_TOGGLE_AD_AGILITY_FASTCHECKED          (WM_APP+38)


enum {
    MYWM_DUMMY = WM_APP+50,
#define DEFINE_TOGGLE(id, regname, ontext, offtext) MYWM_NOTIFY##id,
#include "toggles.h"

};


#define MYWM_TOGGLELOGTOCONSOLE  (WM_APP+100)
#define MYWM_TOGGLELOGTODEBUGGER (WM_APP+101)
#define MYWM_TOGGLELOGTOFILE     (WM_APP+102)
#define MYWM_TOGGLELOGFILEAPPEND (WM_APP+103)
#define MYWM_TOGGLELOGFLUSHFILE  (WM_APP+104)


#define MYWM_SETLFALL            (WM_APP+207)
#define MYWM_SETLFNONE           (WM_APP+208)

enum
{
    dummydummy  = (WM_APP+210),
#define DEFINE_LOG_FACILITY(name,value)  MYWM_TOGGLE##name,
#include "loglf.h"
};



#define MYWM_TOGGLEJITSCHEDULER         (WM_APP+300)
#define MYWM_TOGGLEJITINLINER           (WM_APP+301)
#define MYWM_TOGGLECODEPITCH            (WM_APP+302)
#define MYWM_TOGGLEJITFULLYINT          (WM_APP+303)
#define MYWM_TOGGLEJITFRAMED            (WM_APP+304)
#define MYWM_TOGGLEJITNOREGLOC          (WM_APP+305)
#define MYWM_TOGGLEJITNOFPREGLOC        (WM_APP+306)
#define MYWM_TOGGLEJITPINVOKE           (WM_APP+307)
#define MYWM_TOGGLEJITPINVOKECHECK      (WM_APP+308)
#define MYWM_TOGGLEJITLOOSEEXCEPTORDER  (WM_APP+309)
#define MYWM_SET_JIT_BLENDED_CODE       (WM_APP+310)
#define MYWM_SET_JIT_SMALL_CODE         (WM_APP+311)
#define MYWM_SET_JIT_FAST_CODE          (WM_APP+312)
#define MYWM_SET_JIT_RANDOM_CODE        (WM_APP+313)


#define MYWM_TOGGLELEVELONE      (WM_APP+501)
#define MYWM_TOGGLELEVELTWO      (WM_APP+502)
#define MYWM_TOGGLELEVELTHREE    (WM_APP+503)
#define MYWM_TOGGLELEVELFOUR     (WM_APP+504)
#define MYWM_TOGGLELEVELFIVE     (WM_APP+505)
#define MYWM_TOGGLELEVELSIX      (WM_APP+506)
#define MYWM_TOGGLELEVELSEVEN    (WM_APP+507)
#define MYWM_TOGGLELEVELEIGHT    (WM_APP+508)
#define MYWM_TOGGLELEVELNINE     (WM_APP+509)
#define MYWM_TOGGLELEVELTEN      (WM_APP+510)


#define MYWM_TOGGLEALLOC         (WM_APP+600)
#define MYWM_TOGGLEALLOCPOISON   (WM_APP+601)
#define MYWM_TOGGLEALLOCDIST     (WM_APP+602)
#define MYWM_TOGGLEALLOCSTATS    (WM_APP+603)
#define MYWM_TOGGLEALLOCLEAK     (WM_APP+604)
#define MYWM_TOGGLEALLOCASSERTLK (WM_APP+605)
#define MYWM_TOGGLEALLOCBREAK    (WM_APP+606)
#define MYWM_TOGGLEALLOCRECHECK  (WM_APP+607)
#define MYWM_TOGGLEALLOCGUARD    (WM_APP+608)
#define MYWM_TOGGLEALLOCPRVHEAP  (WM_APP+609)
#define MYWM_TOGGLEALLOCVALIDATE (WM_APP+610)
#define MYWM_TOGGLEALLOCPPALLOC  (WM_APP+611)
#define MYWM_TOGGLEALLOCTOPUSAGE (WM_APP+612)
#define MYWM_TOGGLESHUTDOWNCLEANUP (WM_APP+613)
#define MYWM_TOGGLELOCKCOUNTASSERT (WM_APP+614)


#define MYWM_TOGGLELFREMOTING    (WM_APP+650)

#define MYWM_TOGGLECONCURRENTGC   (WM_APP+750)

#define MYWM_NOTIFYZAP                      (WM_APP+800)
#define MYWM_TOGGLEZAP                      (WM_APP+801)
#define MYWM_TOGGLEREQUIREZAPS              (WM_APP+803)
#define MYWM_TOGGLEVERSIONZAPSBYTIMESTAMP   (WM_APP+804)

#define MYWM_TOGGLEIGNORESERIALIZATIONBIT   (WM_APP+850)
#define MYWM_TOGGLELOGNONSERIALIZABLE       (WM_APP+851)
#define MYWM_TOGGLEBCLPERFWARNINGS          (WM_APP+852)
#define MYWM_TOGGLEBCLCORRECTNESSWARNINGS   (WM_APP+853)

/*
 * Global variables
 */
const char *szAppName="JIT Manager";

HWND ghwndJit;
NOTIFYICONDATA nidJit;
enum JitStatus { eJIT_OFF, eJIT_ON, eJIT_REQD, eJIT_COUNT };
enum JitStatus jitStatus;
/* If the jit gets turned off, we remember if the Jit was required or not,
 * so that when the jit is turned on again, we can set JitRequired accordingly
 */
enum JitStatus lastJitOn;

enum JitCodegen { JIT_OPT_BLENDED, 
                  JIT_OPT_SIZE,
                  JIT_OPT_SPEED, 
                  JIT_OPT_RANDOM, 
                  JIT_OPT_DEFAULT = JIT_OPT_BLENDED };
enum JitCodegen jitCodegen;

HICON hiconJIT_REQD, hiconJIT_ON, hiconJIT_OFF;

enum SchedCode { JIT_NO_SCHED,
                 JIT_CAN_SCHED,
                 JIT_MUST_SCHED,
                 JIT_RANDOM_SCHED,
                 JIT_BAD_SCHED, // Out-of-range value
                 JIT_DEFAULT_SCHED = JIT_CAN_SCHED };
enum SchedCode jitSchedCode;

BOOL bJitInliner;
BOOL bJitFullyInt;
BOOL bJitFramed;
BOOL bJitNoRegLoc;
BOOL bJitNoFPRegLoc;
BOOL bCodePitch;
BOOL bJitPInvoke;
BOOL bJitPInvokeCheck;
BOOL bJitLooseExceptOrder;

BOOL bConcurrentGC;

HWND ghwndHeapVer;
NOTIFYICONDATA nidHeapVer;
DWORD iHeapVerStatus;
DWORD iFastGCStressStatus;
HICON hiconHEAPVER_ON, hiconHEAPVER_ON_2, hiconHEAPVER_OFF;
BOOL bIgnoreSerializationBit;
BOOL bLogNonSerializable;
BOOL bBCLPerfWarnings;
BOOL bBCLCorrectnessWarnings;

HWND ghwndGC_Dbg;
NOTIFYICONDATA nidGC_Dbg;
BOOL bGC_DbgStatus;
HICON hiconGC_DBG_ON, hiconGC_DBG_OFF;

HWND ghwndGC_Stress;
NOTIFYICONDATA nidGC_Stress;
DWORD iGC_StressStatus;
HICON hiconGC_STRESS_ON, hiconGC_STRESS_OFF, hiconGC_STRESS_ON_1, hiconGC_STRESS_ON_2, hiconGC_STRESS_ON_3;

HWND ghwndLog;
NOTIFYICONDATA nidLog;
BOOL bLogStatus;
HICON hiconLOG_ON, hiconLOG_OFF;

HWND ghwndVerifier;
NOTIFYICONDATA nidVerifier;
BOOL bVerifierOffStatus;
HICON hiconVERIFIER_ON, hiconVERIFIER_OFF;

HWND ghwndZap;
NOTIFYICONDATA nidZap;
BOOL bZapStatus;
BOOL bRequireZapsStatus;
BOOL bVersionZapsByTimestampStatus;
HICON hiconZAP_ON, hiconZAP_OFF;


DWORD dwLoaderOptimization;
BOOL bAppDomainUnloadStatus;
BOOL bAppDomainAgilityCheckedStatus;
BOOL bAppDomainAgilityFastCheckedStatus;

#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
    HWND ghwnd##id; \
    NOTIFYICONDATA nid##id; \
    BOOL b##id##Status; \
    HICON hicon##id##_ON, hicon##id##_OFF; \

#include "toggles.h"


BOOL bAllocStatus;




/******************************************************************************
 * Functions local to this module
 */

LRESULT CALLBACK wndprocMainWindow(HWND, UINT, WPARAM, LPARAM);

    // can make it non-const if we want to set it as a command line parameter
const static HKEY defaultHive = HKEY_LOCAL_MACHINE;

/******************************************************************************
 * Gets the DWORD value in the registry in the COMPlus hive. If the value
 * does not exist, returns the defValue back
 */

DWORD   GetCOMPlusRegistryDwordValueEx(const char * valName, DWORD defValue, HKEY hRoot)
{
    HKEY      hkey;

    DWORD     value;
    DWORD     size = sizeof(value);
    DWORD     type = REG_BINARY;
    DWORD     res;

    res = RegOpenKeyEx   (hRoot, "Software\\Microsoft\\.NETFramework", 0, KEY_ALL_ACCESS, &hkey);
    if (res != ERROR_SUCCESS)
        return defValue;

    res = RegQueryValueEx(hkey, valName, 0, &type, (char *)&value, &size);

    RegCloseKey(hkey);

    if (res != ERROR_SUCCESS || type != REG_DWORD)
        return defValue;
    else
        return value;
}

DWORD   GetCOMPlusRegistryDwordValue(const char * valName, DWORD defValue)
{
    if (defaultHive == HKEY_LOCAL_MACHINE)
        defValue = GetCOMPlusRegistryDwordValueEx (valName, defValue, HKEY_CURRENT_USER);
    return GetCOMPlusRegistryDwordValueEx (valName, defValue, defaultHive) ;
}

/******************************************************************************/
BOOL    DeleteCOMPlusRegistryValueEx(const char * valName, HKEY hRoot)
{
    HKEY  hkey;
    DWORD op, res;

    res = RegCreateKeyEx(hRoot,
                        "Software\\Microsoft\\.NETFramework",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey,
                        &op);
    assert(res == ERROR_SUCCESS);
    res = RegDeleteValue(hkey, valName);

    RegCloseKey(hkey);
    return(res == ERROR_SUCCESS);
}

/******************************************************************************
 * Set the DWORD value in the registry in the COMPlus hive. If the key or
 * the value are not present, it creates them.
 * Returns TRUE on success, FALSE on failure.
 *    Currently always asserts on failure as we dont do error-handling anyway.
 */

BOOL    SetCOMPlusRegistryDwordValueEx(const char * valName, DWORD value, HKEY hRoot)
{
    HKEY  hkey;
    DWORD op, res;

    int   size = sizeof(DWORD);

    res = RegCreateKeyEx(hRoot,
                        "Software\\Microsoft\\.NETFramework",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey,
                        &op);

    assert(res == ERROR_SUCCESS);

    res = RegSetValueEx(hkey,
                        valName,
                        0,
                        REG_DWORD,
                        (char *)&value,
                        size);

    assert(res == ERROR_SUCCESS);

    RegCloseKey(hkey);

    return TRUE;
}


BOOL    SetCOMPlusRegistryDwordValue(const char * valName, DWORD value)
{
    BOOL ret = SetCOMPlusRegistryDwordValueEx (valName, value, defaultHive);

        // if you put it in the local machine, then remove it from current user
    if (defaultHive == HKEY_LOCAL_MACHINE) 
        DeleteCOMPlusRegistryValueEx(valName, HKEY_CURRENT_USER);
    return(ret);
}

/******************************************************************************
 * Gets the String value in the registry in the COMPlus hive. If the value
 * does not exist, returns the defValue back
 */

char *   GetCOMPlusRegistryStringValueEx(const char * valName, const char * defValue, HKEY hRoot)
{
    HKEY      hkey;

    char *    value = (char *)malloc(128);
    DWORD     size = sizeof(char) * 128;
    DWORD     type = REG_BINARY;
    DWORD     res;

    res = RegOpenKeyEx   (hRoot, "Software\\Microsoft\\.NETFramework", 0, KEY_ALL_ACCESS, &hkey);
    if (res != ERROR_SUCCESS){
        free(value);
        return (char *)defValue;
    }

    res = RegQueryValueEx(hkey, valName, 0, &type, value, &size);

    RegCloseKey(hkey);

    if (res != ERROR_SUCCESS || type != REG_SZ){
        free(value);
        return (char *)defValue;
    }
    else
        return value;
}

/******************************************************************************/

char *   GetCOMPlusRegistryStringValue(const char * valName, const char * defValue)
{
    char* retVal;
    char* defValue1 = (char*) defValue;
    if (defaultHive == HKEY_LOCAL_MACHINE) 
        defValue1 = GetCOMPlusRegistryStringValueEx (valName, defValue1, defaultHive);

    retVal = GetCOMPlusRegistryStringValueEx (valName, defValue1, defaultHive);
    if (defValue1 != defValue)
        free(defValue1);
    return retVal;
}

/******************************************************************************
 * Set the String value in the registry in the COMPlus hive. If the key or
 * the value are not present, it creates them.
 * Returns TRUE on success, FALSE on failure.
 *    Currently always asserts on failure as we dont do error-handling anyway.
 */

BOOL    SetCOMPlusRegistryStringValueEx(const char * valName, const char * value, HKEY hRoot)
{
    HKEY  hkey;
    DWORD op, res;

    int   size = strlen(valName);

    res = RegCreateKeyEx(hRoot,
                        "Software\\Microsoft\\.NETFramework",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey,
                        &op);

    assert(res == ERROR_SUCCESS);

    res = RegSetValueEx(hkey,
                        valName,
                        0,
                        REG_SZ,
                        value,
                        size);

    assert(res == ERROR_SUCCESS);

    RegCloseKey(hkey);

    return TRUE;
}

BOOL    SetCOMPlusRegistryStringValue(const char * valName, const char * value)
{
    BOOL ret = SetCOMPlusRegistryStringValueEx (valName, value, defaultHive) ;
    if (defaultHive == HKEY_LOCAL_MACHINE) 
        DeleteCOMPlusRegistryValueEx(valName, HKEY_CURRENT_USER);
    return ret;
}


/******************************************************************************
 * GetJitStatus()
 */

enum JitStatus GetJitStatus(void)
{
    // JITEnable is ON by default
    DWORD jitEnable = GetCOMPlusRegistryDwordValue("JITEnable", 1);

    if (jitEnable == 0)
    {
        return eJIT_OFF;
    }
    else
    {
        // JitRequired is ON by default
        DWORD jitRequired = GetCOMPlusRegistryDwordValue("JitRequired", 1);

        if (jitRequired == 1)
            return eJIT_REQD;
        else
            return eJIT_ON;
    }
}



void GetJitStatusInNOTIFYICONDATA(NOTIFYICONDATA * pnid)
{
    const char * szJitStatus;
    switch(jitStatus)
    {
    case eJIT_OFF  : pnid->hIcon = hiconJIT_OFF;   szJitStatus = "JIT Disabled";   break;
    case eJIT_ON   : pnid->hIcon = hiconJIT_ON;    szJitStatus = "JIT Enabled";    break;
    case eJIT_REQD : pnid->hIcon = hiconJIT_REQD;  szJitStatus = "JIT Required";   break;
    default       : assert(!"Invalid jitStatus");  break;
    }
    sprintf(pnid->szTip, szJitStatus);
}


void SetJitStatus(enum JitStatus newStatus)
{
    // assert(newStatus < eJIT_COUNT);
    DWORD newJitEnable  = (newStatus == eJIT_OFF ) ? 0 : 1;
    DWORD newJitReqd    = (newStatus == eJIT_REQD) ? 0 : 1;

    if (SetCOMPlusRegistryDwordValue("JITEnable",   newJitEnable))
    {
        if (newStatus != eJIT_OFF)
        {
            DWORD newJitReqd = (newStatus == eJIT_REQD) ? 1 : 0;

            if (SetCOMPlusRegistryDwordValue("JITRequired", newJitReqd))
                lastJitOn = newStatus;
        }

        jitStatus = GetJitStatus();

        /*
         * Update the notifyicon area
         */

        GetJitStatusInNOTIFYICONDATA(&nidJit);

        Shell_NotifyIcon(NIM_MODIFY, &nidJit);
    }
}


/*
 * CycleJit()
 *
 *    -->  eJIT_OFF  --> eJIT_ON  --> eJIT_REQD  --> (repeat)
 */

void CycleJit(void)
{
    SetJitStatus((jitStatus+1) % eJIT_COUNT);

    if (jitStatus != eJIT_OFF)
        lastJitOn = jitStatus;
}

void ToggleJitEnable(void)
{
//    assert(lastJitOn == eJIT_ON || lastJitOn == eJIT_REQD);

    enum JitStatus newStatus = (jitStatus == eJIT_OFF) ? lastJitOn : eJIT_OFF;

    SetJitStatus(newStatus);
}

void ToggleJitReqd(void)
{
//    assert(jitStatus == eJIT_ON || jitStatus == eJIT_REQD);
//    assert(lastJitOn == eJIT_ON || lastJitOn == eJIT_REQD);

    enum JitStatus newStatus = (jitStatus == eJIT_REQD) ? eJIT_ON : eJIT_REQD;

    lastJitOn = newStatus;

    SetJitStatus(newStatus);
}

/******************************************************************************
 * Allow forgiving get type
 */


BOOL GetConcurrentGC(void)
{
    return GetCOMPlusRegistryDwordValue("GCconcurrent", FALSE);
}

void ToggleConcurrentGC(void)
{
    BOOL data = GetConcurrentGC();
    data = ! data;
    if (SetCOMPlusRegistryDwordValue("GCConcurrent", data))
        bConcurrentGC = GetConcurrentGC();
}

BOOL GetSerializationBit(void) {
    return (GetCOMPlusRegistryDwordValue("IgnoreSerializationBit", FALSE)!=0);
}

void ToggleSerializationBit(void) {
    BOOL data = GetSerializationBit();
    data = ! data;
    if (SetCOMPlusRegistryDwordValue("IgnoreSerializationBit", data))
        bIgnoreSerializationBit = GetSerializationBit();

}

BOOL GetSerializationLog(void) {
    return (GetCOMPlusRegistryDwordValue("LogNonSerializable", FALSE)!=0);
}

void ToggleSerializationLog(void) {
    BOOL data = GetSerializationLog();
    data = ! data;
    if (SetCOMPlusRegistryDwordValue("LogNonSerializable", data))
        bLogNonSerializable = GetSerializationBit();

}

BOOL GetBCLPerfWarnings(void) {
    return (GetCOMPlusRegistryDwordValue("BCLPerfWarnings", FALSE)!=0);
}

void ToggleBCLPerfWarnings(void) {
    BOOL data = GetBCLPerfWarnings();
    data = ! data;
    if (SetCOMPlusRegistryDwordValue("BCLPerfWarnings", data))
        bBCLPerfWarnings = GetBCLPerfWarnings();
}

BOOL GetBCLCorrectnessWarnings(void) {
    return (GetCOMPlusRegistryDwordValue("BCLCorrectnessWarnings", FALSE)!=0);
}

void ToggleBCLCorrectnessWarnings(void) {
    BOOL data = GetBCLCorrectnessWarnings();
    data = ! data;
    if (SetCOMPlusRegistryDwordValue("BCLCorrectnessWarnings", data))
        bBCLCorrectnessWarnings = GetBCLCorrectnessWarnings();
}

/******************************************************************************
 * Heap verification
 */

DWORD GetHeapVerStatus(void)
{
    return GetCOMPlusRegistryDwordValue("HeapVerify", FALSE);
}

HICON GetHeapVerIcon(DWORD status)
{
    switch(status) {
        case 0:
            return(hiconHEAPVER_OFF);
        case 1:
            return(hiconHEAPVER_ON);
    }
    return(hiconHEAPVER_ON_2);
}

char* GetHeapVerString(DWORD status)
{
    switch(status) {
        case 0:
            return("HeapVerify Disabled");
        case 1:
            return("HeapVerify Level 1");
    }
    return("HeapVerify Level 2");
}

int nextHeapVer(int data) {
    data++;
    if (data > 2)
        data = 0;
    return(data);
}

void SetHeapVer(int data)
{
    if (SetCOMPlusRegistryDwordValue("HeapVerify", data))
    {
        iHeapVerStatus = GetHeapVerStatus();

        nidHeapVer.hIcon = GetHeapVerIcon(iHeapVerStatus);

        sprintf(nidHeapVer.szTip, GetHeapVerString(iHeapVerStatus));

        Shell_NotifyIcon(NIM_MODIFY, &nidHeapVer);
    }
}

void ToggleHeapVer(void) {
    SetHeapVer(nextHeapVer(GetHeapVerStatus()));
}



/******************************************************************************
 * Fast GC Stress
 */

DWORD GetFastGCStressStatus(void)
{
    return GetCOMPlusRegistryDwordValue("FastGCStress", FALSE);
}

char* GetFastGCStressString(DWORD status)
{
    switch(status) {
        case 0:
            return("FastGCStress Disabled");
        case 1:
            return("FastGCStress Level 1");
    }
    return("FastGCStress Level 2");
}

int nextFastGCStress(int data) {
    data++;
    if (data > 2)
        data = 0;
    return(data);
}

void SetFastGCStress(int data)
{
    if (SetCOMPlusRegistryDwordValue("FastGCStress", data))
        iFastGCStressStatus = data;
}

void ToggleFastGCStress(void) {
    SetFastGCStress(nextFastGCStress(GetFastGCStressStatus()));
}



/******************************************************************************
 * GC
 */

BOOL GetGC_DbgStatus(void)
{
    return GetCOMPlusRegistryDwordValue("EnableDebugGC", FALSE);
}


void ToggleGC_Dbg(void)
{
    BOOL data = GetGC_DbgStatus();
    data = !data;

    if (SetCOMPlusRegistryDwordValue("EnableDebugGC", data))
    {
        bGC_DbgStatus = GetGC_DbgStatus();

        nidGC_Dbg.hIcon = bGC_DbgStatus ? hiconGC_DBG_ON : hiconGC_DBG_OFF;

        sprintf(nidGC_Dbg.szTip, bGC_DbgStatus?"Debug GC Enabled" : "Debug GC Disabled");

        Shell_NotifyIcon(NIM_MODIFY, &nidGC_Dbg);
    }
}

DWORD GetGC_StressStatus(void)
{
    return GetCOMPlusRegistryDwordValue("GCStress", FALSE);
}

HICON GetGC_StressIcon(DWORD status)
{
    switch(status) {
        case 0:
            return(hiconGC_STRESS_OFF);
        case 1:
            return(hiconGC_STRESS_ON_1);
        case 2:
            return(hiconGC_STRESS_ON_2);
        case 3:
            return(hiconGC_STRESS_ON_3);
    }
    return(hiconGC_STRESS_ON);
}

int nextGC_Stress(int data) {
    data++;
    if (data > 3)
        data = 0;
    return(data);
}

void SetGC_Stress(int data)
{
    if (SetCOMPlusRegistryDwordValue("GCStress", data))
    {
        iGC_StressStatus = GetGC_StressStatus();

        nidGC_Stress.hIcon = GetGC_StressIcon(iGC_StressStatus);

        // sprintf(nidGC_Stress.szTip, GetGC_StressString(iGC_StressStatus));

        Shell_NotifyIcon(NIM_MODIFY, &nidGC_Stress);
    }
}

void ToggleGC_Stress(void) {
    if (GetGC_StressStatus() & 4)   // If we are turning off GCStress 4, then also clear fully int
        SetJitFullyInt(0);
    SetGC_Stress(nextGC_Stress(GetGC_StressStatus()));
}

/******************************************************************************
 * Logging
 */

BOOL GetLogStatus(void)
{
    return GetCOMPlusRegistryDwordValue("LogEnable", FALSE);
}

void SetLogStatus(BOOL value)
{
    if (SetCOMPlusRegistryDwordValue("LogEnable", value))
    {
        bLogStatus = value;

        nidLog.hIcon = bLogStatus ? hiconLOG_ON : hiconLOG_OFF;

        sprintf(nidLog.szTip, bLogStatus?"Logging Enabled" : "Logging Disabled");

        Shell_NotifyIcon(NIM_MODIFY, &nidLog);
    }
}// SetLogStatus


void ToggleLog(void)
{
    BOOL data = GetLogStatus();
    data = !data;

    SetLogStatus(data);
}// ToggleLog




/******************************************************************************
 * Verifier
 */

BOOL GetVerifierStatus(void)
{
    return GetCOMPlusRegistryDwordValue("VerifierOff", 0);
}

void SetVerifierStatus(BOOL value)
{
    if (SetCOMPlusRegistryDwordValue("VerifierOff", value))
    {
        bVerifierOffStatus = value;

        nidVerifier.hIcon = bVerifierOffStatus ? hiconVERIFIER_OFF : hiconVERIFIER_ON;

        sprintf(nidVerifier.szTip, bVerifierOffStatus?"Verifier Disabled" : "Verifier Enabled");

        Shell_NotifyIcon(NIM_MODIFY, &nidVerifier);
    }
}// SetVerifierStatus


void ToggleVerifier(void)
{
    BOOL data = GetVerifierStatus();
    data = ! data;

    SetVerifierStatus(data);
}// ToggleVerifier




/******************************************************************************
 * Zap files
 */

BOOL GetZapStatus(void)
{
    return !GetCOMPlusRegistryDwordValue("ZapDisable", 0);
}

BOOL GetRequireZapsStatus(void)
{
    return GetCOMPlusRegistryDwordValue("ZapRequire", 0);
}

BOOL GetVersionZapsByTimestampStatus(void)
{
    return GetCOMPlusRegistryDwordValue("ZapVersionByTimestamp", 1);
}

void UpdateZapIcon(void)
{
    BOOL enable = GetZapStatus();

    nidZap.hIcon = enable ? hiconZAP_ON : hiconZAP_OFF;

    sprintf(nidZap.szTip, 
            enable ? "Zap Files Used" : "Zap Files Ignored");

    Shell_NotifyIcon(NIM_MODIFY, &nidZap);
}

void ToggleZap(void)
{
    BOOL data = GetZapStatus();
    data = !data;

    if (SetCOMPlusRegistryDwordValue("ZapDisable", !data))
    {
        UpdateZapIcon();
        bZapStatus = GetZapStatus();
    }
}

void ToggleRequireZaps(void)
{
    BOOL data = GetRequireZapsStatus();
    data = !data;

    if (SetCOMPlusRegistryDwordValue("ZapRequire", data))
    {
        bRequireZapsStatus = GetRequireZapsStatus();
    }
}

void ToggleVersionZapsByTimestamp(void)
{
    BOOL data = GetVersionZapsByTimestampStatus();
    data = !data;

    if (SetCOMPlusRegistryDwordValue("ZapVersionByTimestamp", data))
    {
        bVersionZapsByTimestampStatus = GetVersionZapsByTimestampStatus();
    }
}

/******************************************************************************
 * Shared Assemblies
 */

DWORD GetLoaderOptimization(void)
{
    return GetCOMPlusRegistryDwordValue("LoaderOptimization", 0);
}

void SetLoaderOptimization(DWORD value)
{
    DWORD data = GetLoaderOptimization();
    if (data == value)
        return;

    if (SetCOMPlusRegistryDwordValue("LoaderOptimization", value))
    {
        dwLoaderOptimization = GetLoaderOptimization();
    }
}

BOOL GetAppDomainUnloadStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AppDomainNoUnload", 0);
}

void ToggleAppDomainUnload(void)
{
    BOOL data = GetAppDomainUnloadStatus();
    data = ! data;

    if (SetCOMPlusRegistryDwordValue("AppDomainNoUnload", data))
    {
        bAppDomainUnloadStatus = GetAppDomainUnloadStatus();
    }
}

DWORD GetAppDomainAgilityCheckedStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AppDomainAgilityChecked", 1);
}

void ToggleAppDomainAgilityChecked(void)
{
    BOOL data = GetAppDomainAgilityCheckedStatus();
    data = ! data;

    if (SetCOMPlusRegistryDwordValue("AppDomainAgilityChecked", data))
    {
        bAppDomainAgilityCheckedStatus = GetAppDomainAgilityCheckedStatus();
    }
}

DWORD GetAppDomainAgilityFastCheckedStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AppDomainAgilityFastChecked", 0);
}

void ToggleAppDomainAgilityFastChecked(void)
{
    BOOL data = GetAppDomainAgilityFastCheckedStatus();
    data = ! data;

    if (SetCOMPlusRegistryDwordValue("AppDomainAgilityFastChecked", data))
    {
        bAppDomainAgilityFastCheckedStatus = GetAppDomainAgilityFastCheckedStatus();
    }
}


#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
    BOOL Get##id##Status(void)  \
    { \
        return GetCOMPlusRegistryDwordValue(regname, 0); \
    } \
\
void Set##id(BOOL value) \
    { \
        b##id##Status = value; \
        if (SetCOMPlusRegistryDwordValue(regname, value)) \
        { \
            b##id##Status = Get##id##Status(); \
            nid##id##.hIcon = b##id##Status ? hicon##id##_ON : hicon##id##_OFF; \
            sprintf(nid##id##.szTip, b##id##Status?ontext : offtext); \
            Shell_NotifyIcon(NIM_MODIFY, &nid##id); \
        } \
    } \
\
    void Toggle##id(void) \
    { \
        BOOL data = b##id##Status;\
        data = ! data; \
        Set##id(data); \
    } \


#include "toggles.h"






/******************************************************************************
 * Helpers
 */

BOOL GetBoolStatus(LPCSTR value, BOOL defaultValue)
{
    return GetCOMPlusRegistryDwordValue(value, defaultValue);
}


void ToggleBool(LPCSTR value, BOOL defaultValue)
{
    DWORD data = ! GetBoolStatus(value,defaultValue);

    SetCOMPlusRegistryDwordValue(value, data);
}




/******************************************************************************
 *
 */


enum SchedCode GetJitSchedulerStatus()
{
    jitSchedCode = (enum SchedCode)GetCOMPlusRegistryDwordValue("JITSched", JIT_DEFAULT_SCHED);
    if (jitSchedCode >= JIT_BAD_SCHED)
        jitSchedCode = JIT_DEFAULT_SCHED;
    return jitSchedCode;
}

void ToggleJitScheduler(void)
{
    if (jitSchedCode == JIT_NO_SCHED)
        // Set to bad value so that the jitcompiler will use the appropriate default value
        SetCOMPlusRegistryDwordValue("JITSched", JIT_BAD_SCHED);
    else
        SetCOMPlusRegistryDwordValue("JITSched", JIT_NO_SCHED);
}


BOOL GetJitFullyIntStatus()
{
    return (bJitFullyInt = GetBoolStatus("JITFullyInt",FALSE));
}

void SetJitFullyInt(BOOL val)
{
    SetCOMPlusRegistryDwordValue("JITFullyInt", val);
}

void ToggleJitFullyInt(void)
{
    ToggleBool("JITFullyInt",FALSE);
}

BOOL GetJitFramedStatus()
{
    return (bJitFramed = GetBoolStatus("JITFramed",FALSE));
}

void ToggleJitFramed(void)
{
    ToggleBool("JITFramed",FALSE);
}

BOOL GetJitNoRegLocStatus()
{
    return (bJitNoRegLoc = GetBoolStatus("JITNoRegLoc",FALSE));
}

void ToggleJitNoRegLoc(void)
{
    ToggleBool("JITNoRegLoc",FALSE);
}

BOOL GetJitNoFPRegLocStatus()
{
    return (bJitNoFPRegLoc = GetBoolStatus("JITNoFPRegLoc",FALSE));
}

void ToggleJitNoFPRegLoc(void)
{
    ToggleBool("JITNoFPRegLoc",FALSE);
}

BOOL GetJitLooseExceptOrderStatus()
{
    return (bJitLooseExceptOrder = GetBoolStatus("JITLooseExceptOrder", FALSE));
}

enum JitCodegen GetJitCodegen()
{
    jitCodegen = (enum JitCodegen) GetCOMPlusRegistryDwordValue("JITOptimizeType", JIT_OPT_DEFAULT);
    return jitCodegen;
}

void SetJitCodegen(enum JitCodegen data)
{
    if (jitCodegen != data)
    {
        SetCOMPlusRegistryDwordValue("JITOptimizeType", data);
        jitCodegen = data;
    }
}

void ToggleJitLooseExceptOrder(void)
{
    ToggleBool("JITLooseExceptOrder", FALSE);
}

BOOL GetJitInlinerStatus()
{
    return (bJitInliner = GetBoolStatus("JITnoInline",FALSE));
}

void ToggleJitInliner(void)
{
    ToggleBool("JITnoInline",FALSE);
}

BOOL GetJitPInvokeEnabled()
{
    return (bJitPInvoke = GetBoolStatus("JITPInvokeEnabled", TRUE));
}

void ToggleJitPInvoke(void)
{
    ToggleBool("JITPInvokeEnabled", TRUE);
}

BOOL GetJitPInvokeCheckEnabled()
{
    return (bJitPInvoke = GetBoolStatus("JITPInvokeCheckEnabled", FALSE));
}

void ToggleJitPInvokeCheck(void)
{
    ToggleBool("JITPInvokeCheckEnabled", FALSE);
}

BOOL GetCodePitchStatus(void)
{
    return (bCodePitch = GetBoolStatus("CodePitchEnable",TRUE));
}

void ToggleCodePitch(void)
{
    ToggleBool("CodePitchEnable",TRUE);
}

BOOL GetLogToConsoleStatus(void)
{
    return GetBoolStatus("LogToConsole",FALSE);
}



void ToggleLogToConsole(void)
{
    ToggleBool("LogToConsole",FALSE);
}


BOOL GetLogToDebuggerStatus(void)
{
    return GetBoolStatus("LogToDebugger",FALSE);
}



void ToggleLogToDebugger(void)
{
    ToggleBool("LogToDebugger",FALSE);
}


BOOL GetLogToFileStatus(void)
{
    return GetBoolStatus("LogToFile",FALSE);
}


void ToggleLogToFile(void)
{
    ToggleBool("LogToFile",FALSE);
}



BOOL GetLogFileAppendStatus(void)
{
    return GetBoolStatus("LogFileAppend",FALSE);
}


void ToggleLogFileAppend(void)
{
    ToggleBool("LogFileAppend",FALSE);
}





BOOL GetLogFlushFileStatus(void)
{
    return GetBoolStatus("LogFlushFile",FALSE);
}


void ToggleLogFlushFile(void)
{
    ToggleBool("LogFlushFile",FALSE);
}



DWORD GetLogFacility()
{
    return GetCOMPlusRegistryDwordValue("LogFacility", LF_ALL);
}


void SetLogFacility(DWORD value)
{
    SetCOMPlusRegistryDwordValue("LogFacility", value);
}

DWORD GetLogLevel()
{
    return GetCOMPlusRegistryDwordValue("LogLevel", 0);
}

void SetLogLevel(DWORD value)
{
    SetCOMPlusRegistryDwordValue("LogLevel", value);
}


/******************************************************************************
 * Debug Allocation
 */


void EnableAllocLogging(void)
{
    SetLogFacility(GetLogFacility() | LF_DBGALLOC);
    if (!GetLogStatus())
        ToggleLog();
}


BOOL GetAllocPoisonStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocPoison", 0);
}


void ToggleAllocPoison(void)
{
    BOOL data = GetAllocPoisonStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocPoison", data);
}


BOOL GetAllocDistStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocDist", 0);
}


void ToggleAllocDist(void)
{
    BOOL data = GetAllocDistStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocDist", data);

    if (GetAllocDistStatus())
        EnableAllocLogging();
}


BOOL GetAllocStatsStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocStats", 0);
}


void ToggleAllocStats(void)
{
    BOOL data = GetAllocStatsStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocStats", data);

    if (GetAllocStatsStatus())
        EnableAllocLogging();
}


BOOL GetAllocLeakStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocLeakDetect", 0);
}


void ToggleAllocLeak(void)
{
    BOOL data = GetAllocLeakStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocLeakDetect", data);

  /*  if (GetAllocLeakStatus())
        EnableAllocLogging();
    */
}


BOOL GetAllocAssertLeakStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocAssertOnLeak", 0);
}


void ToggleAllocAssertLeak(void)
{
    BOOL data = GetAllocAssertLeakStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocAssertOnLeak", data);
}


BOOL GetAllocBreakAllocStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocBreakOnAllocEnable", 0);
}


void ToggleAllocBreakAlloc(void)
{
    BOOL data = GetAllocBreakAllocStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocBreakOnAllocEnable", data);
}


BOOL GetAllocBreakAllocNumber(void)
{
    return GetCOMPlusRegistryDwordValue("AllocBreakOnAllocNumber", 0);
}


BOOL GetAllocRecheckStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocRecheck", 0);
}


void ToggleAllocRecheck(void)
{
    BOOL data = GetAllocRecheckStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocRecheck", data);
}


BOOL GetAllocGuardStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocGuard", 0);
}


void ToggleAllocGuard(void)
{
    BOOL data = GetAllocGuardStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocGuard", data);
}


BOOL GetAllocPrivateHeapStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocUsePrivateHeap", 0);
}


void ToggleAllocPrivateHeap(void)
{
    BOOL data = GetAllocPrivateHeapStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocUsePrivateHeap", data);
}


BOOL GetAllocValidateStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocValidateHeap", 0);
}


void ToggleAllocValidate(void)
{
    BOOL data = GetAllocValidateStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocValidateHeap", data);
}


BOOL GetAllocPPAStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocPagePerAlloc", 0);
}


void ToggleAllocPPA(void)
{
    BOOL data = GetAllocPPAStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AllocPagePerAlloc", data);
}


BOOL GetAllocTopUsageStatus(void)
{
    return GetCOMPlusRegistryDwordValue("UsageByAllocator", 0);
}


void ToggleAllocTopUsage(void)
{
    BOOL data = GetAllocTopUsageStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("UsageByAllocator", data);

    if (GetAllocTopUsageStatus())
        EnableAllocLogging();
}


BOOL GetAllocStatus(void)
{
    return GetCOMPlusRegistryDwordValue("AllocDebug", 0);
}


void ToggleAlloc(void)
{
    BOOL data = GetAllocStatus();
    data = ! data;

    if (SetCOMPlusRegistryDwordValue("AllocDebug", data))
        bAllocStatus = GetAllocStatus();

    if (bAllocStatus &&
        (GetAllocDistStatus() ||
         GetAllocStatsStatus() ||
         GetAllocLeakStatus() ||
         GetAllocTopUsageStatus()))
        EnableAllocLogging();
}

BOOL GetShutdownCleanupStatus()
{
    return GetCOMPlusRegistryDwordValue("ShutdownCleanup", 0);
}

void ToggleShutdownCleanup(void)
{
    BOOL data = GetShutdownCleanupStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("ShutdownCleanup", data);
}

BOOL GetLockCountAssertStatus()
{
    return GetCOMPlusRegistryDwordValue("AssertOnLocks", 0);
}

void ToggleLockCountAssert(void)
{
    BOOL data = GetLockCountAssertStatus();
    data = ! data;

    SetCOMPlusRegistryDwordValue("AssertOnLocks", data);
}



/*****************************************************************************
******************************************************************************
******************************************************************************
M y C r e a t e P o p u p M e n u
******************************************************************************
******************************************************************************
*****************************************************************************/
HMENU MyCreatePopupMenu(HWND hwnd)
{
    HMENU hmenuPopup, hmenuLogLevel, hmenuLogOptions, hmenuJitOptions;
    HMENU hmenuAllocOptions, hmenuGCStressOptions, hmenuLoaderOptimization, hmenuAppDomainAgilityChecking;
    HMENU hmenuJitCodeOptions; 
    HMENU hmenuZapOptions;
    DWORD logenabled, ppaenabled;

    hmenuPopup=CreatePopupMenu();

    if (hmenuPopup)
    {
        MENUITEMINFO mii;

        /* Add menu commands. */

        // JIT

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLEJIT_ENABLE ,
                   (jitStatus == eJIT_OFF) ? "Enable Jit " : "Disable Jit ");

        AppendMenu(hmenuPopup,
                   (MFT_STRING | (jitStatus == eJIT_OFF) ? MFS_DISABLED : MFS_ENABLED),
                   MYWM_TOGGLEJIT_REQD ,
                   (lastJitOn == eJIT_REQD) ? "Dont require Jit " : "Require Jit ");

        hmenuJitOptions = CreateMenu();

        hmenuJitCodeOptions = CreateMenu();

        AppendMenu(hmenuJitCodeOptions,
                   (MFT_STRING | MFS_ENABLED | ((GetJitCodegen() == JIT_OPT_BLENDED) ? MFS_CHECKED : 0)),
                   MYWM_SET_JIT_BLENDED_CODE,
                   "Blended code");

        AppendMenu(hmenuJitCodeOptions,
                   (MFT_STRING | MFS_ENABLED | ((GetJitCodegen() == JIT_OPT_SIZE)    ? MFS_CHECKED : 0)),
                   MYWM_SET_JIT_SMALL_CODE,
                   "Small code");

        AppendMenu(hmenuJitCodeOptions,
                   (MFT_STRING | MFS_ENABLED | ((GetJitCodegen() == JIT_OPT_SPEED)   ? MFS_CHECKED : 0)),
                   MYWM_SET_JIT_FAST_CODE,
                   "Fast code");

        AppendMenu(hmenuJitCodeOptions,
                   (MFT_STRING | MFS_ENABLED | ((GetJitCodegen() == JIT_OPT_RANDOM)  ? MFS_CHECKED : 0)),
                   MYWM_SET_JIT_RANDOM_CODE,
                   "Random code");

        InsertMenu(hmenuJitOptions, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuJitCodeOptions,
                   "Jit Codegen Options");

        logenabled = (jitStatus != eJIT_OFF) ? MFS_ENABLED : MFS_DISABLED;

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | ((GetJitSchedulerStatus() != JIT_NO_SCHED) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITSCHEDULER,
                   "Allow Scheduling");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitInlinerStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITINLINER,
                   "Disable Inliner ");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitFullyIntStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITFULLYINT,
                   "All Methods Interruptable");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitFramedStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITFRAMED,
                   "All Methods Have Frame");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitNoRegLocStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITNOREGLOC,
                   "Locals Can Not Be Enregistered in EAX..EBP");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitNoFPRegLocStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITNOFPREGLOC,
                   "Locals Can Not Be Enregistered in FPU stack");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitLooseExceptOrderStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITLOOSEEXCEPTORDER,
                   "Loose Ordering of Exceptions");

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitPInvokeEnabled() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITPINVOKE,
                   "Inline PInvoke Stub");

        if (!GetJitPInvokeEnabled())
            logenabled = MFS_DISABLED;

        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetJitPInvokeCheckEnabled() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEJITPINVOKECHECK,
                   "Check stack on return from unmanaged code");

        logenabled = (jitStatus == eJIT_OFF) ? MFS_ENABLED : MFS_DISABLED;
        AppendMenu(hmenuJitOptions,
                   (MFT_STRING | logenabled | (GetCodePitchStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLECODEPITCH,
                   "Enable Code Pitch ");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuJitOptions,
                   "Jit Options");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);


            // Concurrent GC

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLECONCURRENTGC,
                   bConcurrentGC  ? "Disable Concurrent GC" : "Enable Concurrent GC");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // BCL Helpful Warnings
        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED | (bBCLPerfWarnings ? MF_CHECKED : 0)),
                   MYWM_TOGGLEBCLPERFWARNINGS,
                   "BCL Perf Warnings");

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED | (bBCLCorrectnessWarnings ? MF_CHECKED : 0)),
                   MYWM_TOGGLEBCLCORRECTNESSWARNINGS,
                   "BCL Correctness Warnings");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Serialization stuff
        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED | (bIgnoreSerializationBit ? MF_CHECKED : 0)),
                   MYWM_TOGGLEIGNORESERIALIZATIONBIT,
                   "Ignore Serialization Bit");

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED | (bLogNonSerializable ? MF_CHECKED : 0)),
                   MYWM_TOGGLELOGNONSERIALIZABLE,
                   "Log NonSerializable Classes");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Debugger, Heap verification, Debug GC, GC Stress
        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLEHEAPVER,
                   GetHeapVerString(iHeapVerStatus));

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLEFASTGCSTRESS,
                   GetFastGCStressString(iFastGCStressStatus));

        hmenuGCStressOptions = CreateMenu();

        AppendMenu(hmenuGCStressOptions,
                   (MFT_STRING | MFS_ENABLED | ((iGC_StressStatus & 1) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_1,
                   "GC on Allocations");

        AppendMenu(hmenuGCStressOptions,
                   (MFT_STRING | MFS_ENABLED | ((iGC_StressStatus & 2) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_2,
                   "GC on Transitions");

        logenabled = MFS_ENABLED;
        if ((iGC_StressStatus & 4) && GetJitFullyIntStatus())
            logenabled = MFS_DISABLED;

        AppendMenu(hmenuGCStressOptions, 
                   (MFT_STRING | logenabled | ((iGC_StressStatus & 4) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_4,
                   "GC on JIT safe points");

        AppendMenu(hmenuGCStressOptions,
                   (MFT_STRING | MFS_ENABLED | ((GetJitFullyIntStatus() && (iGC_StressStatus & 4)) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_INSTRS,
                   "GC on JIT instrs");

        AppendMenu(hmenuGCStressOptions,
                   (MFT_STRING | MFS_ENABLED | (((iGC_StressStatus & 7) == 7) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_ALL,
                   "GC Stress Full");

        AppendMenu(hmenuGCStressOptions,
                   (MFT_STRING | MFS_ENABLED | ((iGC_StressStatus == 0)? MFS_CHECKED : 0)),
                   MYWM_TOGGLEGC_STRESS_NONE,
                   "GC Stress Off");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuGCStressOptions,
                   "GCStress Options");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Static Heap Allocation

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLEALLOC,
                   bAllocStatus   ? "Disable Alloc Debug " : "Enable Alloc Debug ");

        hmenuAllocOptions = CreateMenu();

        logenabled = bAllocStatus ? MFS_ENABLED : MFS_DISABLED;

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocStatsStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCSTATS,
                   "Log Basic Stats ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocTopUsageStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCTOPUSAGE,
                   "Log Top Allocators ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocDistStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCDIST,
                   "Log Alloc Size Distribution ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocPoisonStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCPOISON,
                   "Poison Packets ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocLeakStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCLEAK,
                   "Detect Alloc Leaks ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocAssertLeakStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCASSERTLK,
                   "Assert On Alloc Leaks ");

        ppaenabled = (bAllocStatus && !GetAllocPPAStatus()) ? MFS_ENABLED : MFS_DISABLED;;

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | ppaenabled | (GetAllocGuardStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCGUARD,
                   "Alloc Guard Bytes ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocRecheckStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCRECHECK,
                   "Constant Heap Recheck ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | ppaenabled | (GetAllocPrivateHeapStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCPRVHEAP,
                   "Use Private Heap ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | ppaenabled | (GetAllocValidateStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCVALIDATE,
                   "Validate Underlying Heap ");

        AppendMenu(hmenuAllocOptions,
                   (MFT_STRING | logenabled | (GetAllocPPAStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLEALLOCPPALLOC,
                   "Page Per Alloc Mode ");

        {
            DWORD   alloc = GetAllocBreakAllocNumber();
            CHAR    szMenuString[256];
            DWORD   logenabled = (bAllocStatus && alloc) ? MFS_ENABLED : MFS_DISABLED;

            if (alloc)
                sprintf(szMenuString, "Break On Alloc %u", alloc);
            else
                sprintf(szMenuString, "Break On Alloc Disabled");

            AppendMenu(hmenuAllocOptions,
                       (MFT_STRING | logenabled | (GetAllocBreakAllocStatus() ? MFS_CHECKED : 0)),
                       MYWM_TOGGLEALLOCBREAK,
                       szMenuString);
        }

        AppendMenu(hmenuAllocOptions,
                    (MFT_STRING | logenabled | (GetShutdownCleanupStatus() ? MFS_CHECKED : 0)),
                    MYWM_TOGGLESHUTDOWNCLEANUP,
                    "Shutdown Cleanup");

        AppendMenu(hmenuAllocOptions,
                    (MFT_STRING | logenabled | (GetLockCountAssertStatus() ? MFS_CHECKED : 0)),
                    MYWM_TOGGLELOCKCOUNTASSERT,
                    "Assert on Lock Mismatch");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuAllocOptions,
                   "Alloc Debug Options");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Verifier

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLEVERIFIER,
                   bVerifierOffStatus   ? "Enable Verifier " : "Disable Verifier ");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Zap

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED 
                    | (bZapStatus ? MF_CHECKED : 0)),
                   MYWM_TOGGLEZAP,
                   "Use Zap Files");

        hmenuZapOptions = CreateMenu();

        AppendMenu(hmenuZapOptions,
                   (MFT_STRING | (bZapStatus ? MFS_ENABLED : MFS_DISABLED) | (bRequireZapsStatus ? MF_CHECKED : 0)),
                   MYWM_TOGGLEREQUIREZAPS,
                   "Require Zap Files");

        AppendMenu(hmenuZapOptions,
                   (MFT_STRING | (bZapStatus ? MFS_ENABLED : MFS_DISABLED) | (bVersionZapsByTimestampStatus ? MF_CHECKED : 0)),
                   MYWM_TOGGLEVERSIONZAPSBYTIMESTAMP,
                   "Version Zaps By Timestamp");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING
                   | (bZapStatus ? MFS_ENABLED : MFS_DISABLED),
                   (UINT)hmenuZapOptions,
                   "Zap Options");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Assemblies & Appdomains

        hmenuLoaderOptimization = CreateMenu();

        AppendMenu(hmenuLoaderOptimization,
                   (MFT_STRING | MFS_ENABLED | (dwLoaderOptimization == 0 ? MF_CHECKED : 0)),
                   MYWM_LOADER_OPTIMIZATION_DEFAULT,
                   "Default");

        AppendMenu(hmenuLoaderOptimization,
                   (MFT_STRING | MFS_ENABLED | (dwLoaderOptimization == 1 ? MF_CHECKED : 0)),
                   MYWM_LOADER_OPTIMIZATION_SINGLE_DOMAIN,
                   "Single Domain");

        AppendMenu(hmenuLoaderOptimization,
                   (MFT_STRING | MFS_ENABLED | (dwLoaderOptimization == 2 ? MF_CHECKED : 0)),
                   MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN,
                   "Multi Domain");

        AppendMenu(hmenuLoaderOptimization,
                   (MFT_STRING | MFS_ENABLED | (dwLoaderOptimization == 3 ? MF_CHECKED : 0)),
                   MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST,
                   "Multi Domain Host");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING | MFS_ENABLED,
                   (UINT)hmenuLoaderOptimization,
                   "Loader Optimization");

        hmenuAppDomainAgilityChecking = CreateMenu();

        AppendMenu(hmenuAppDomainAgilityChecking,
                   (MFT_STRING | MFS_ENABLED | (bAppDomainAgilityCheckedStatus == 1 ? MF_CHECKED : 0)),
                   MYWM_TOGGLE_AD_AGILITY_CHECKED,
                   "Enabled under checked");

        AppendMenu(hmenuAppDomainAgilityChecking,
                   (MFT_STRING | MFS_ENABLED | (bAppDomainAgilityFastCheckedStatus == 1 ? MF_CHECKED : 0)),
                   MYWM_TOGGLE_AD_AGILITY_FASTCHECKED,
                   "Enabled under fastchecked");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING | MFS_ENABLED,
                   (UINT)hmenuAppDomainAgilityChecking,
                   "AppDomain Agility Checking");

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED | (bAppDomainUnloadStatus ? MF_CHECKED : 0)),
                   MYWM_TOGGLE_AD_UNLOAD,
                   "Disable AppDomain Unload");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // Logging

        AppendMenu(hmenuPopup,
                   (MFT_STRING | MFS_ENABLED),
                   MYWM_TOGGLELOG ,
                   bLogStatus   ? "Disable Logging " : "Enable Logging ");

        logenabled = bLogStatus ? MFS_ENABLED : MFS_DISABLED;

        hmenuLogLevel = CreateMenu();

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 1) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELONE,
                   "1 - Fatal Errors");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 2) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELTWO,
                   "2 - Errors");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 3) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELTHREE,
                   "3 - Warnings");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 4) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELFOUR,
                   "4- 10 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 5) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELFIVE,
                   "5 - 100 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 6) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELSIX,
                   "6 - 1000 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 7) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELSEVEN,
                   "7 - 10,000 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 8) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELEIGHT,
                   "8 - 100,000 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 9) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELNINE,
                   "9 - 1,000,000 msgs");

        AppendMenu(hmenuLogLevel,
                  (MFT_STRING | logenabled | ((GetLogLevel() == 10) ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELEVELTEN,
                   "10 - everything");

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuLogLevel,
                   "Logging Level");

        hmenuLogOptions = CreateMenu();

        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled | (GetLogFileAppendStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELOGFILEAPPEND ,
                   "Log File Append ");

        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled | (GetLogFlushFileStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELOGFLUSHFILE ,
                   "Log File Flush ");


        AppendMenu(hmenuLogOptions,  MFT_SEPARATOR, 0, NULL);


#define DEFINE_LOG_FACILITY(name,val) \
        AppendMenu(hmenuLogOptions,   \
                   (MFT_STRING | logenabled | (GetLogFacility() & ##name ? MFS_CHECKED : 0)), \
                   MYWM_TOGGLE##name , \
                   #name);          \

#include "loglf.h"



        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled),
                   MYWM_SETLFALL ,
                   "All");

        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled),
                   MYWM_SETLFNONE ,
                   "None");

        AppendMenu(hmenuLogOptions,  MFT_SEPARATOR, 0, NULL);

        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled | (GetLogToConsoleStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELOGTOCONSOLE ,
                   "Log to Console ");

        AppendMenu(hmenuLogOptions,
                   (MFT_STRING | logenabled | (GetLogToDebuggerStatus() ? MFS_CHECKED : 0)),
                   MYWM_TOGGLELOGTODEBUGGER ,
                   "Log to Debugger ");

        {
            CHAR szLogFile[1000];
            CHAR szMenuString[1050];
            HKEY      hkey;
            DWORD     type = REG_SZ;
            DWORD size=sizeof(szLogFile);

            RegOpenKeyEx   (HKEY_CURRENT_USER, "Software\\Microsoft\\.NETFramework", 0, KEY_ALL_ACCESS, &hkey);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, "LogFile", 0, &type, szLogFile, &size))
            {
                strcpy(szLogFile, "COMPLUS.LOG");
            }
            RegCloseKey    (hkey);
            sprintf(szMenuString, "Log to '%s'.", szLogFile);


            AppendMenu(hmenuLogOptions,
                       (MFT_STRING | logenabled | (GetLogToFileStatus() ? MFS_CHECKED : 0)),
                       MYWM_TOGGLELOGTOFILE ,
                       szMenuString);
        }

        InsertMenu(hmenuPopup, -1,
                   MF_BYPOSITION | MF_POPUP | MF_STRING,
                   (UINT)hmenuLogOptions,
                   "Logging Options");

        AppendMenu(hmenuPopup,  MFT_SEPARATOR, 0, NULL);

        // "Close"

        AppendMenu(hmenuPopup, (MFT_STRING | MFS_ENABLED), ID_FILE_EXIT, "Close");

        /* Set default menu command. */

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_STATE;
        mii.fState = MFS_DEFAULT;

    }

    return hmenuPopup;
}

/*****************************************************************************
******************************************************************************
******************************************************************************
P o p u p M e n u
******************************************************************************
******************************************************************************
*****************************************************************************/
void PopupMenu(HWND hwnd, UINT uMenuFlags)
{
    HMENU hmenuPopup;

    hmenuPopup = MyCreatePopupMenu(hwnd);

    if (hmenuPopup)
    {
        POINT pt;

        GetCursorPos(&pt);
        SetForegroundWindow(hwnd);
        TrackPopupMenu(hmenuPopup, uMenuFlags, pt.x, pt.y, 0, hwnd, NULL);

        DestroyMenu(hmenuPopup);
    }

    return;
}

/*****************************************************************************
******************************************************************************
******************************************************************************
W i n M a i n
******************************************************************************
******************************************************************************
*****************************************************************************/
int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow)
{
    WNDCLASS wc;
    MSG msg;

    /*
     * Register the window class
     */
    wc.style=0;
    wc.lpfnWndProc=wndprocMainWindow;
    wc.cbClsExtra=0;
    wc.cbWndExtra=0;
    wc.hInstance=hinst;
    wc.hIcon=NULL;
    wc.hCursor=LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground=(HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName=NULL; /* MAKEINTRESOURCE(IDR_MENU1); */
    wc.lpszClassName=szAppName;
    if (!RegisterClass(&wc))
        return 1;

    /*
     * Create the main windows
     */
    ghwndJit = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            NULL, NULL, hinst, NULL);
    if (!ghwndJit)
        return 1;

    ghwndHeapVer = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, hinst, NULL);
    if (!ghwndHeapVer)
    {
        DestroyWindow( ghwndJit );
        return 1;
    }

    ghwndGC_Dbg = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                               CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                               NULL, NULL, hinst, NULL);
    if (!ghwndGC_Dbg)
    {
        DestroyWindow( ghwndJit );
        DestroyWindow( ghwndHeapVer );
        return 1;
    }

    ghwndGC_Stress = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                               CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                               NULL, NULL, hinst, NULL);
    if (!ghwndGC_Stress)
    {
        DestroyWindow( ghwndJit );
        DestroyWindow( ghwndHeapVer );
        DestroyWindow( ghwndGC_Dbg );
        return 1;
    }

    ghwndLog = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, hinst, NULL);
    if (!ghwndLog)
    {
        DestroyWindow( ghwndJit );
        DestroyWindow( ghwndHeapVer );
        DestroyWindow( ghwndGC_Dbg );
        DestroyWindow( ghwndGC_Stress );
        return 1;
    }

    ghwndVerifier = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, hinst, NULL);
    if (!ghwndVerifier)
    {
        DestroyWindow( ghwndJit );
        DestroyWindow( ghwndHeapVer );
        DestroyWindow( ghwndGC_Dbg );
        DestroyWindow( ghwndGC_Stress );
        DestroyWindow( ghwndLog );
        return 1;
    }


    ghwndZap = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, hinst, NULL);
    if (!ghwndZap)
    {
        DestroyWindow( ghwndJit );
        DestroyWindow( ghwndHeapVer );
        DestroyWindow( ghwndGC_Dbg );
        DestroyWindow( ghwndGC_Stress );
        DestroyWindow( ghwndLog );
        DestroyWindow( ghwndVerifier );
        return 1;
    }

#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
    ghwnd##id = CreateWindow(wc.lpszClassName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hinst, NULL); \
    if (!ghwnd##id) \
    { \
       return 1; \
    } \

#include "toggles.h"


    ShowWindow(ghwndJit, SW_HIDE);
    UpdateWindow(ghwndJit);

    ShowWindow(ghwndHeapVer, SW_HIDE);
    UpdateWindow(ghwndHeapVer);

    ShowWindow(ghwndGC_Dbg, SW_HIDE);
    UpdateWindow(ghwndGC_Dbg);

    ShowWindow(ghwndGC_Stress, SW_HIDE);
    UpdateWindow(ghwndGC_Stress);

    ShowWindow(ghwndLog, SW_HIDE);
    UpdateWindow(ghwndLog);

    ShowWindow(ghwndVerifier, SW_HIDE);
    UpdateWindow(ghwndVerifier);

    ShowWindow(ghwndZap, SW_HIDE);
    UpdateWindow(ghwndZap);

#define DEFINE_TOGGLE(id, regname, ontext, offtetx)  ShowWindow(ghwnd##id, SW_HIDE);UpdateWindow(ghwnd##id);
#include "toggles.h"

    /*
     * Determine the status of the flags
     */
    jitStatus  = GetJitStatus();
    lastJitOn  = (jitStatus == eJIT_REQD) ? eJIT_REQD : eJIT_ON;

    bConcurrentGC = GetConcurrentGC () ;
    bBCLPerfWarnings = GetBCLPerfWarnings();
    bBCLCorrectnessWarnings = GetBCLCorrectnessWarnings();
    bIgnoreSerializationBit = GetSerializationBit();
    bLogNonSerializable = GetSerializationLog();
    iHeapVerStatus = GetHeapVerStatus () ;
    iFastGCStressStatus = GetFastGCStressStatus () ;
    bGC_DbgStatus = GetGC_DbgStatus () ;
    iGC_StressStatus = GetGC_StressStatus () ;
    bLogStatus = GetLogStatus () ;
    bVerifierOffStatus = GetVerifierStatus () ;
    bZapStatus = GetZapStatus () ;
    bRequireZapsStatus = GetRequireZapsStatus() ;
    bVersionZapsByTimestampStatus = GetVersionZapsByTimestampStatus() ;
    dwLoaderOptimization = GetLoaderOptimization() ;
    bAppDomainAgilityCheckedStatus = GetAppDomainAgilityCheckedStatus();
    bAppDomainAgilityFastCheckedStatus = GetAppDomainAgilityFastCheckedStatus();
    bAppDomainUnloadStatus = GetAppDomainUnloadStatus () ;
    bAllocStatus = GetAllocStatus();

#define DEFINE_TOGGLE(id, regname, ontext, offtext) b##id##Status = Get##id##Status();
#include "toggles.h"

    /*
     * Load the Icons and create popup menu
     */
    hiconJIT_REQD = LoadIcon(hinst, MAKEINTRESOURCE(JIT_REQD));
    hiconJIT_ON   = LoadIcon(hinst, MAKEINTRESOURCE(JIT_ON));
    hiconJIT_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(JIT_OFF));
    hiconHEAPVER_ON    = LoadIcon(hinst, MAKEINTRESOURCE(HEAPVER_ON));
    hiconHEAPVER_ON_2  = LoadIcon(hinst, MAKEINTRESOURCE(HEAPVER_ON_2));
    hiconHEAPVER_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(HEAPVER_OFF));
    hiconGC_DBG_ON   = LoadIcon(hinst, MAKEINTRESOURCE(GC_DBG_ON));
    hiconGC_DBG_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(GC_DBG_OFF));
    hiconGC_STRESS_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(GC_STRESS_OFF));
    hiconGC_STRESS_ON   = LoadIcon(hinst, MAKEINTRESOURCE(GC_STRESS_ON));
    hiconGC_STRESS_ON_1 = LoadIcon(hinst, MAKEINTRESOURCE(GC_STRESS_ON_1));
    hiconGC_STRESS_ON_2 = LoadIcon(hinst, MAKEINTRESOURCE(GC_STRESS_ON_2));
    hiconGC_STRESS_ON_3 = LoadIcon(hinst, MAKEINTRESOURCE(GC_STRESS_ON_3));
    hiconLOG_ON         = LoadIcon(hinst, MAKEINTRESOURCE(LOG_ON));
    hiconLOG_OFF        = LoadIcon(hinst, MAKEINTRESOURCE(LOG_OFF));
    hiconVERIFIER_ON   = LoadIcon(hinst, MAKEINTRESOURCE(VERIFIER_ON));
    hiconVERIFIER_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(VERIFIER_OFF));
    hiconZAP_ON   = LoadIcon(hinst, MAKEINTRESOURCE(ZAP_ON));
    hiconZAP_OFF  = LoadIcon(hinst, MAKEINTRESOURCE(ZAP_OFF));
#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
    hicon##id##_ON = LoadIcon(hinst, MAKEINTRESOURCE(id##_ON)); \
    hicon##id##_OFF = LoadIcon(hinst, MAKEINTRESOURCE(id##_OFF)); \

#include "toggles.h"

    /*
     * Create the JIT Shell_NotifyIcon
     */
    nidJit.cbSize=sizeof(nidJit);
    nidJit.hWnd=ghwndJit;
    nidJit.uID=0;
    nidJit.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidJit.uCallbackMessage=MYWM_NOTIFYJIT;
    GetJitStatusInNOTIFYICONDATA(&nidJit);
    SetWindowText(ghwndJit, nidJit.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidJit);

    nidHeapVer.cbSize=sizeof(nidHeapVer);
    nidHeapVer.hWnd=ghwndHeapVer;
    nidHeapVer.uID=0;
    nidHeapVer.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidHeapVer.uCallbackMessage=MYWM_NOTIFYHEAPVER;
    nidHeapVer.hIcon=GetHeapVerIcon(iHeapVerStatus);
    sprintf(nidHeapVer.szTip, iHeapVerStatus?"Heap Verification Enabled" : "Heap Verification Disabled");
    SetWindowText(ghwndHeapVer, nidHeapVer.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidHeapVer);

    nidGC_Dbg.cbSize=sizeof(nidGC_Dbg);
    nidGC_Dbg.hWnd=ghwndGC_Dbg;
    nidGC_Dbg.uID=0;
    nidGC_Dbg.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidGC_Dbg.uCallbackMessage=MYWM_NOTIFYGC_DBG;
    nidGC_Dbg.hIcon=bGC_DbgStatus?hiconGC_DBG_ON:hiconGC_DBG_OFF;
    sprintf(nidGC_Dbg.szTip, bGC_DbgStatus?"Debug GC Enabled" : "Debug GC Disabled");
    SetWindowText(ghwndGC_Dbg, nidGC_Dbg.szTip );
//    Shell_NotifyIcon(NIM_ADD, &nidGC_Dbg);

    nidGC_Stress.cbSize=sizeof(nidGC_Stress);
    nidGC_Stress.hWnd=ghwndGC_Stress;
    nidGC_Stress.uID=0;
    nidGC_Stress.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidGC_Stress.uCallbackMessage=MYWM_NOTIFYGC_STRESS;
    nidGC_Stress.hIcon=GetGC_StressIcon(iGC_StressStatus);
    sprintf(nidGC_Stress.szTip, iGC_StressStatus?"GCStress Enabled" : "GCStress Disabled");
    SetWindowText(ghwndGC_Stress, nidGC_Stress.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidGC_Stress);

    nidLog.cbSize=sizeof(nidLog);
    nidLog.hWnd=ghwndLog;
    nidLog.uID=0;
    nidLog.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidLog.uCallbackMessage=MYWM_NOTIFYLOG;
    nidLog.hIcon=bLogStatus?hiconLOG_ON:hiconLOG_OFF;
    sprintf(nidLog.szTip, bLogStatus?"Logging Enabled" : "Logging Disabled");
    SetWindowText(ghwndLog, nidLog.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidLog);

    nidVerifier.cbSize=sizeof(nidVerifier);
    nidVerifier.hWnd=ghwndVerifier;
    nidVerifier.uID=0;
    nidVerifier.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidVerifier.uCallbackMessage=MYWM_NOTIFYVERIFIER;
    nidVerifier.hIcon=bVerifierOffStatus?hiconVERIFIER_OFF:hiconVERIFIER_ON;
    sprintf(nidVerifier.szTip, bVerifierOffStatus?"Verifier Disabled" : "Verifier Enabled");
    SetWindowText(ghwndVerifier, nidVerifier.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidVerifier);


    nidZap.cbSize=sizeof(nidZap);
    nidZap.hWnd=ghwndZap;
    nidZap.uID=0;
    nidZap.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
    nidZap.uCallbackMessage=MYWM_NOTIFYZAP;
    nidZap.hIcon=bZapStatus?hiconZAP_ON:hiconZAP_OFF;
    sprintf(nidZap.szTip, bZapStatus?"Zap Files Used" : "Zap Files Ignored");
    SetWindowText(ghwndZap, nidZap.szTip );
    Shell_NotifyIcon(NIM_ADD, &nidZap);

#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
    nid##id.cbSize=sizeof(nid##id); \
    nid##id.hWnd=ghwnd##id; \
    nid##id.uID=0; \
    nid##id.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP; \
    nid##id.uCallbackMessage=MYWM_NOTIFY##id; \
    nid##id.hIcon=b##id##Status?hicon##id##_ON:hicon##id##_OFF; \
    sprintf(nid##id.szTip, b##id##Status?ontext : offtext); \
    SetWindowText(ghwnd##id, nid##id.szTip ); \
    Shell_NotifyIcon(NIM_ADD, &nid##id); \

#include "toggles.h"


    /*
     * Main message pump
     */

    while (TRUE)
    {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message==WM_QUIT)
                break;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else
            WaitMessage();                    /* do idle processing here */
    }

#define DEFINE_TOGGLE(id, regname, ontext, offtext) DestroyWindow(ghwnd##id);
#include "toggles.h"

    DestroyWindow( ghwndZap );
    DestroyWindow( ghwndVerifier );
    DestroyWindow( ghwndJit );
    DestroyWindow( ghwndHeapVer );
    DestroyWindow( ghwndGC_Dbg );
    DestroyWindow( ghwndGC_Stress );
    DestroyWindow( ghwndLog );

#define DEFINE_TOGGLE(id, regname, ontext, offtext) Shell_NotifyIcon(NIM_DELETE, &nid##id);
#include "toggles.h"

    Shell_NotifyIcon(NIM_DELETE, &nidZap);
    Shell_NotifyIcon(NIM_DELETE, &nidVerifier);
    Shell_NotifyIcon(NIM_DELETE, &nidJit);
    Shell_NotifyIcon(NIM_DELETE, &nidHeapVer);
//    Shell_NotifyIcon(NIM_DELETE, &nidGC_Dbg);
    Shell_NotifyIcon(NIM_DELETE, &nidGC_Stress);
    Shell_NotifyIcon(NIM_DELETE, &nidLog);

    UnregisterClass(wc.lpszClassName, hinst);

    return msg.wParam;
}



/*****************************************************************************
******************************************************************************
******************************************************************************
w n d p r o c M a i n W i n d o w
******************************************************************************
******************************************************************************
*****************************************************************************/
LRESULT CALLBACK wndprocMainWindow(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = TRUE;
    LRESULT lr = 0;

    switch (message)
    {
    case WM_CREATE:
        // Set a timer to periodically check if we are displaying outdated
        // info (eg. if someone directly modified the registry)
        SetTimer(hwnd, 0, 2000, NULL);
        break;

    case WM_TIMER:
        // We'll only update the status bar items if necessary....
        if (GetJitStatus()!=jitStatus)
            SetJitStatus(GetJitStatus());
        if (GetHeapVerStatus()!= iHeapVerStatus)
            SetHeapVer(GetHeapVerStatus());
        if (GetFastGCStressStatus()!= iFastGCStressStatus)
            SetFastGCStress(GetFastGCStressStatus());
        if (GetGC_StressStatus()!= iGC_StressStatus)
            SetGC_Stress(GetGC_StressStatus());
        if (GetLogStatus()!=bLogStatus)
            SetLogStatus(GetLogStatus());
        if (GetVerifierStatus() != bVerifierOffStatus)
            SetVerifierStatus(GetVerifierStatus());
        if (GetZapStatus() != bZapStatus)
        {
            bZapStatus = GetZapStatus();
            UpdateZapIcon();
        }

        #define DEFINE_TOGGLE(id,regname,ontext,offtext) if (Get##id##Status() != b##id##Status) Set##id(Get##id##Status());
        #include "toggles.h"

        // We won't bother checking these to see if they're changed....
        bAllocStatus = GetAllocStatus();

        bCodePitch = GetCodePitchStatus();
        bConcurrentGC = GetConcurrentGC();
        bBCLPerfWarnings = GetBCLPerfWarnings();
        bBCLCorrectnessWarnings = GetBCLCorrectnessWarnings();
        bIgnoreSerializationBit = GetSerializationBit();
        bLogNonSerializable    = GetSerializationLog();
        bGC_DbgStatus = GetGC_DbgStatus();
        bJitFramed = GetJitFramedStatus();
        bJitFullyInt = GetJitFullyIntStatus();
        bJitInliner = GetJitInlinerStatus();
        bJitNoFPRegLoc = GetJitNoFPRegLocStatus(); 
        bJitNoRegLoc = GetJitNoRegLocStatus();
        bJitPInvoke = GetJitPInvokeEnabled();
        bJitPInvokeCheck = GetJitPInvokeCheckEnabled();
        bJitLooseExceptOrder = GetJitLooseExceptOrderStatus();
        bRequireZapsStatus = GetRequireZapsStatus();
        bAppDomainAgilityCheckedStatus = GetAppDomainAgilityCheckedStatus();
        bAppDomainAgilityFastCheckedStatus = GetAppDomainAgilityFastCheckedStatus();
        bVerifierOffStatus = GetVerifierStatus();
        bVersionZapsByTimestampStatus = GetVersionZapsByTimestampStatus();

        break;

    case WM_CLOSE:
        DestroyWindow(hwnd);
        PostQuitMessage(0);
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case ID_FILE_EXIT:
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case MYWM_TOGGLEJIT_ENABLE:
            ToggleJitEnable();
            break;

        case MYWM_TOGGLEJIT_REQD:
            ToggleJitReqd();
            break;

        case MYWM_TOGGLECONCURRENTGC:
            ToggleConcurrentGC();
            break;

        case MYWM_TOGGLEBCLPERFWARNINGS:
            ToggleBCLPerfWarnings();
            break;

        case MYWM_TOGGLEBCLCORRECTNESSWARNINGS:
            ToggleBCLCorrectnessWarnings();
            break;

        case MYWM_TOGGLEIGNORESERIALIZATIONBIT:
            ToggleSerializationBit();
            break;

        case MYWM_TOGGLELOGNONSERIALIZABLE:
            ToggleSerializationLog();
            break;

        case MYWM_TOGGLEHEAPVER:
            ToggleHeapVer();
            break;

        case MYWM_TOGGLEFASTGCSTRESS:
            ToggleFastGCStress();
            break;

        case MYWM_TOGGLEGC_DBG:
            ToggleGC_Dbg();
            break;

        case MYWM_TOGGLEGC_STRESS_NONE:
            SetJitFullyInt(0);
            SetGC_Stress(0);
            break;

        case MYWM_TOGGLEGC_STRESS_1:
            SetGC_Stress(GetGC_StressStatus() ^ 1);
            break;

        case MYWM_TOGGLEGC_STRESS_2:
            SetGC_Stress(GetGC_StressStatus() ^ 2);
            break;

        case MYWM_TOGGLEGC_STRESS_4:
            SetGC_Stress(GetGC_StressStatus() ^ 4);
            break;

        case MYWM_TOGGLEGC_STRESS_INSTRS:
            if ((GetGC_StressStatus() & 4) && GetJitFullyIntStatus()) {
                SetGC_Stress(GetGC_StressStatus() & ~4);
                SetJitFullyInt(0);
            }
            else {
                SetGC_Stress(GetGC_StressStatus() | 4);
                SetJitFullyInt(1);
            }
            break;

        case MYWM_TOGGLEGC_STRESS_ALL:
                        SetJitFullyInt(1);
                        SetGC_Stress(0x7);
                        break;

        case MYWM_TOGGLEGC_STRESS:
            ToggleGC_Stress();
            break;

        case MYWM_TOGGLELOG:
            ToggleLog();
            break;

        case MYWM_TOGGLEVERIFIER:
            ToggleVerifier();
            break;

        case MYWM_TOGGLEZAP:
            ToggleZap();
            break;
    
        case MYWM_TOGGLEREQUIREZAPS:
            ToggleRequireZaps();
            break;

        case MYWM_TOGGLEVERSIONZAPSBYTIMESTAMP:
            ToggleVersionZapsByTimestamp();
            break;

        case MYWM_LOADER_OPTIMIZATION_DEFAULT:
            SetLoaderOptimization(0);
            break;

        case MYWM_LOADER_OPTIMIZATION_SINGLE_DOMAIN:
            SetLoaderOptimization(1);
            break;

        case MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN:
            SetLoaderOptimization(2);
            break;

        case MYWM_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST:
            SetLoaderOptimization(3);
            break;

        case MYWM_TOGGLE_AD_UNLOAD:
            ToggleAppDomainUnload();
            break;

        case MYWM_TOGGLE_AD_AGILITY_CHECKED:
            ToggleAppDomainAgilityChecked();
            break;

        case MYWM_TOGGLE_AD_AGILITY_FASTCHECKED:
            ToggleAppDomainAgilityFastChecked();
            break;

        case MYWM_TOGGLELOGTOCONSOLE:
            ToggleLogToConsole();
            break;

        case MYWM_TOGGLELOGTODEBUGGER:
            ToggleLogToDebugger();
            break;

        case MYWM_TOGGLELOGTOFILE:
            ToggleLogToFile();
            break;

        case MYWM_TOGGLELOGFILEAPPEND:
            ToggleLogFileAppend();
            break;

        case MYWM_TOGGLELOGFLUSHFILE:
            ToggleLogFlushFile();
            break;


#define DEFINE_LOG_FACILITY(name,value)  case MYWM_TOGGLE##name: SetLogFacility(GetLogFacility() ^ name); break;
#include "loglf.h"


        case MYWM_SETLFALL:
            SetLogFacility(LF_ALL);
            break;

        case MYWM_SETLFNONE:
            SetLogFacility(0);
            break;

        case MYWM_TOGGLELEVELONE:
            SetLogLevel(1);
            break;
        case MYWM_TOGGLELEVELTWO:
            SetLogLevel(2);
            break;
        case MYWM_TOGGLELEVELTHREE:
            SetLogLevel(3);
            break;
        case MYWM_TOGGLELEVELFOUR:
            SetLogLevel(4);
            break;
        case MYWM_TOGGLELEVELFIVE:
            SetLogLevel(5);
            break;
        case MYWM_TOGGLELEVELSIX:
            SetLogLevel(6);
            break;
        case MYWM_TOGGLELEVELSEVEN:
            SetLogLevel(7);
            break;
        case MYWM_TOGGLELEVELEIGHT:
            SetLogLevel(8);
            break;
        case MYWM_TOGGLELEVELNINE:
            SetLogLevel(9);
            break;
        case MYWM_TOGGLELEVELTEN:
            SetLogLevel(10);
            break;
        case MYWM_TOGGLEJITSCHEDULER:
            ToggleJitScheduler();
            break;

        case MYWM_TOGGLEJITINLINER:
            ToggleJitInliner();
            break;

        case MYWM_TOGGLEJITFULLYINT:
            ToggleJitFullyInt();
            break;

        case MYWM_TOGGLEJITFRAMED:
            ToggleJitFramed();
            break;

        case MYWM_TOGGLEJITNOREGLOC:
            ToggleJitNoRegLoc();
            break;

        case MYWM_TOGGLEJITNOFPREGLOC:
            ToggleJitNoFPRegLoc();
            break;

        case MYWM_TOGGLEJITPINVOKE:
            ToggleJitPInvoke();
            break;

        case MYWM_TOGGLEJITPINVOKECHECK:
            ToggleJitPInvokeCheck();
            break;

        case MYWM_TOGGLEJITLOOSEEXCEPTORDER:
            ToggleJitLooseExceptOrder();
            break;

        case MYWM_SET_JIT_BLENDED_CODE:
            SetJitCodegen(JIT_OPT_BLENDED);
            break;

        case MYWM_SET_JIT_SMALL_CODE:
            SetJitCodegen(JIT_OPT_SIZE);
            break;

        case MYWM_SET_JIT_FAST_CODE:
            SetJitCodegen(JIT_OPT_SPEED);
            break;

        case MYWM_SET_JIT_RANDOM_CODE:
            SetJitCodegen(JIT_OPT_RANDOM);
            break;

        case MYWM_TOGGLECODEPITCH:
            ToggleCodePitch();
            break;

        case MYWM_TOGGLEALLOC:
            ToggleAlloc();
            break;

        case MYWM_TOGGLEALLOCPOISON:
            ToggleAllocPoison();
            break;

        case MYWM_TOGGLEALLOCDIST:
            ToggleAllocDist();
            break;

        case MYWM_TOGGLEALLOCSTATS:
            ToggleAllocStats();
            break;

        case MYWM_TOGGLEALLOCLEAK:
            ToggleAllocLeak();
            break;

        case MYWM_TOGGLEALLOCASSERTLK:
            ToggleAllocAssertLeak();
            break;

        case MYWM_TOGGLEALLOCBREAK:
            ToggleAllocBreakAlloc();
            break;

        case MYWM_TOGGLEALLOCGUARD:
            ToggleAllocGuard();
            break;

        case MYWM_TOGGLEALLOCRECHECK:
            ToggleAllocRecheck();
            break;

        case MYWM_TOGGLEALLOCPRVHEAP:
            ToggleAllocPrivateHeap();
            break;

        case MYWM_TOGGLEALLOCVALIDATE:
            ToggleAllocValidate();
            break;

        case MYWM_TOGGLEALLOCPPALLOC:
            ToggleAllocPPA();
            break;

        case MYWM_TOGGLEALLOCTOPUSAGE:
            ToggleAllocTopUsage();
            break;

        case MYWM_TOGGLESHUTDOWNCLEANUP:
            ToggleShutdownCleanup();
            break;

        case MYWM_TOGGLELOCKCOUNTASSERT:
            ToggleLockCountAssert();
            break;
            
        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYJIT:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            CycleJit();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;


    case MYWM_NOTIFYHEAPVER:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleHeapVer();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYFASTGCSTRESS:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleFastGCStress();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYGC_DBG:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleGC_Dbg();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYGC_STRESS:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleGC_Stress();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYLOG:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleLog();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;

    case MYWM_NOTIFYVERIFIER:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleVerifier();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;


    case MYWM_NOTIFYZAP:
        switch(lParam)
        {
        case WM_LBUTTONDBLCLK:
            ToggleZap();
            break;

        case WM_RBUTTONUP:
            PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON));
            break;

        default:
            bHandled = FALSE;
            break;
        }
        break;


#define DEFINE_TOGGLE(id, regname, ontext, offtext) \
        case MYWM_NOTIFY##id: \
        switch(lParam) \
        { \
            case WM_LBUTTONDBLCLK: \
                Toggle##id(); \
                break; \
            case WM_RBUTTONUP: \
                PopupMenu(hwnd, (TPM_LEFTALIGN | TPM_RIGHTBUTTON)); \
                break; \
            default: \
                bHandled = FALSE; \
                break; \
        } \
        break; \

#include "toggles.h"

    default:
        bHandled = FALSE;
        break;
    }

    return(bHandled ? lr : DefWindowProc(hwnd, message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jit\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "JIT.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM+ JIT Compiler\0"
#define VER_ORIGFILENAME_STR    "JIT.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\util.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// util.hpp
//
// Miscellaneous useful functions
//
#ifndef _H_UTIL
#define _H_UTIL

#include <objbase.h>

#ifdef _DEBUG
#include <crtdbg.h>
#undef _ASSERTE    // utilcode defines a custom _ASSERTE
#endif

#include "utilcode.h"

#endif /* _H_UTIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitman\jitman.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "resource.h"
#include <shellapi.h>
#include <stdlib.h>
#include <assert.h>
#include <tlhelp32.h>


#include "__file__.ver"
#include <corver.h>

// These are used to identify components in callbacks.
#define JIT_TRAY	0x2345

// Max size of the strings we'll be reading in this dialog
#define	REG_STRING_SIZE		100

// String we'll use to generate a named semaphore
#define SEMA_STRING		"JITMAN"

enum { JIT_OPT_OVERALL, JIT_OPT_SPEED , JIT_OPT_SIZE, JIT_OPT_ANY, JIT_OPT_DEFAULT = JIT_OPT_SPEED };

// Function Prototypes

// Callbacks for the window and the dialog
LRESULT CALLBACK wndprocMainWindow(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
int CALLBACK wndprocDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// Registry setting functions
DWORD GetCOMPlusRegistryDwordValueEx(const char * valName, DWORD defValue, HKEY hRoot);
BOOL  SetCOMPlusRegistryDwordValueEx(const char * valName, DWORD value, HKEY hRoot);
void DeleteCOMPlusRegistryValueEx(const char * valName, HKEY hRoot);

// Various functions used by the dialog
void onEconoJITClick(HWND hwnd);
void onLimitCacheClick(HWND hwnd);
void CheckConGC(HWND hwnd);
int GetData(HWND hwnd);
void SetData(HWND hwnd);

// Other stuff
void DisplayUsage();

// Global variables

// This variable keeps track is our Dialog Box is open
int		g_fDialogOpen=0;

// This is the handle for our dialog box
HWND	g_hDialog=NULL;	

// This is the popup menu for our program
HMENU	g_hMenu=NULL;

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	// See if we need to display usage information
	if (lpCmdLine && *lpCmdLine)
		DisplayUsage();


	// Check to see if we should run
	
	HANDLE	hSema=CreateSemaphore(NULL, 1, 1, SEMA_STRING);

	if (hSema && WaitForSingleObject(hSema, 0) == WAIT_TIMEOUT)
	{
		// There's already an instance running... we shouldn't run
		CloseHandle(hSema);
		exit(0);
	}
	
	// We need to create and set up a window so we can register it with the system tray
	// Let's register a window type
	WNDCLASS wc;

	wc.style=0;
    wc.lpfnWndProc=wndprocMainWindow;
    wc.cbClsExtra=0;
    wc.cbWndExtra=0;
    wc.hInstance=hInstance;
    wc.hIcon=NULL;
    wc.hCursor=NULL;
    wc.hbrBackground=(HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName=NULL;
    wc.lpszClassName="JIT Manager";
	RegisterClass(&wc);
	
	HWND hMainWindow=CreateWindow(wc.lpszClassName, "JIT Manager", 0,
                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                            NULL, NULL, wc.hInstance, NULL);


	// Now load the icon that will be placed in the system tray
	HICON hJITIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_JITMAN));
	
	// Set up the System Tray stuff

	// This holds the information needed to place our item in the system tray
	NOTIFYICONDATA nid;
    
	nid.cbSize=sizeof(nid);
	nid.hWnd=hMainWindow;
	nid.hIcon = hJITIcon;
    nid.uID=0;
    nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
	strcpy(nid.szTip,"JIT Manager");
    nid.uCallbackMessage=JIT_TRAY;

  	Shell_NotifyIcon(NIM_ADD, &nid);

	// Now create our Dialog Box
	g_hDialog = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_JITMANDLG_DIALOG), hMainWindow, wndprocDialog);
	// Give it the lightning bolt icon
	SendMessage(g_hDialog, WM_SETICON, ICON_SMALL, (long)hJITIcon);

	// Create the popup menu
	g_hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(IDR_MENU));

	
	// Now let's handle the messages we receive as long as we're supposed to
	MSG msg;
	int iErrorCode = GetMessage(&msg, NULL, 0,0);
	while (iErrorCode != 0 && iErrorCode != -1)
    {
		// See if this message is intended for our dialog box
		if (!IsDialogMessage(g_hDialog, &msg))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		iErrorCode = GetMessage(&msg, NULL, 0,0);
    }

	// Remove our icon from the System Tray
	Shell_NotifyIcon(NIM_DELETE, &nid);
	// Now clean up
	if (g_hDialog)
		DestroyWindow(g_hDialog);
		
	DestroyWindow(hMainWindow);
	DestroyIcon((HICON)hJITIcon);

	// Now clean up our semaphore
	ReleaseSemaphore(hSema, 1, NULL);
	CloseHandle(hSema);
	return 0;

}// WinMain

//---------------------------------------------------------------
// DisplayUsage
//
// This function will display the command line arguments available
// to this program
//---------------------------------------------------------------
void DisplayUsage()
{
	char	szUsage[1000]="";

	strcat(szUsage, "Microsoft (R) CLR JIT Compiler Manager Version ");
	strcat(szUsage, VER_FILEVERSION_STR);
	strcat(szUsage, "\n");
	strcat(szUsage, VER_LEGALCOPYRIGHT_DOS_STR);
	strcat(szUsage, "\n\n");
	strcat(szUsage, "Usage: jitman [-?]\n\n");
    strcat(szUsage, "    -?       Displays this text.\n");
    MessageBox(NULL, szUsage, "CLR JIT Compiler Manager Options", MB_OK);
    exit(0);
}// DisplayUsage

//---------------------------------------------------------------
// wndprocMainWindow
//
// This function handles all windows messages. Its main responsbility
// is popping up the Configuration Dialog when the user double clicks
// on the icon in the tray and bringing up the popup menu when the 
// user right clicks on the icon in the tray
//---------------------------------------------------------------
LRESULT CALLBACK wndprocMainWindow(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		case WM_CREATE:
			return 0;
		case JIT_TRAY:
			if (lParam == WM_LBUTTONDBLCLK)
			{

				// Check to see if the Dialog is open
				if (!g_fDialogOpen)
				{
					// Let's pop open the dialog
		
					// First make sure the dialog box will have the focus initially
					SetForegroundWindow(hwnd);

					// Let's reload all the values in the dialog box in case someone was
					// mucking with the registry while this dialog was down.
					SetData(g_hDialog);
					onEconoJITClick(g_hDialog);
					CheckConGC(g_hDialog);

					// And now show the dialog
					ShowWindow(g_hDialog, SW_SHOWNORMAL);
					g_fDialogOpen=1;
				}
			}
			else if (lParam == WM_RBUTTONDOWN && !g_fDialogOpen)
			{
				// We should create a menu that allows the user to close this thing
				HMENU myMenu = CreatePopupMenu();
				if (myMenu != NULL) // Make sure we could create it
				{
					POINT pt;
					GetCursorPos(&pt);
					SetForegroundWindow(hwnd);	
					
					// If they selected the "close" from the menu, we should inform the
					// main loop to quit.
					if (ID_CLOSE == TrackPopupMenu(GetSubMenu(g_hMenu,0), TPM_RIGHTALIGN|TPM_BOTTOMALIGN|TPM_RETURNCMD|TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL))
						 PostQuitMessage(0);

					PostMessage(hwnd, WM_NULL, 0, 0);
				}

			}
			return TRUE;
		default:
			return DefWindowProc(hwnd, message, wParam, lParam);
	}

}// wndprocMainWindow

//---------------------------------------------------------------
// wndprocDialog
//
// This function handles all message to the dialog. It handles all
// the housekeeping associated with the dialog box
//---------------------------------------------------------------
int CALLBACK wndprocDialog(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch(message)
	{
		// We need to get the Dialog box ready to be displayed
		case WM_INITDIALOG:
			SetData(hwnd);
			onEconoJITClick(hwnd);
			CheckConGC(hwnd);
			return TRUE;

		case WM_COMMAND:
			switch(wParam)
			{
				case IDCANCEL:
					ShowWindow(hwnd, SW_HIDE);
					g_fDialogOpen=0;
					return TRUE;
				case IDOK:
					// Check to see if it passes our validation
					if (GetData(hwnd))
					{
						ShowWindow(hwnd, SW_HIDE);
						g_fDialogOpen=0;
					}
					return TRUE;
				case IDC_ECONOJIT:
					onEconoJITClick(hwnd);
					return TRUE;
				case IDC_LIMITCACHE:
					onLimitCacheClick(hwnd);
					return TRUE;
				
			}
			return FALSE;

		default:
			return FALSE;
	}
}// wndprocDialog

//---------------------------------------------------------------
// CheckConGC
//
// This function will check to see if the OS (and its settings)
// will support Concurrent GC. If it doesn't, we disable the 
// checkbox.
//---------------------------------------------------------------
void CheckConGC(HWND hwnd)
{
	// If the registry key WriteWatch is not set to 1 in
	// [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management]
	// then the user cannot select Enabled Concurrent GC
	int		  iVal = 0;

	HKEY      hkey;
    DWORD     value;
    DWORD     size = sizeof(value);
    DWORD     type = REG_BINARY;
    DWORD     res;

    res = RegOpenKeyEx   (HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", 0, KEY_ALL_ACCESS, &hkey);
    if (res == ERROR_SUCCESS)
	{
	    res = RegQueryValueEx(hkey, "WriteWatch", 0, &type, (unsigned char *)&value, &size);

		RegCloseKey(hkey);

		if (res != ERROR_SUCCESS || type != REG_DWORD)
	        iVal = 0;
		else
			iVal = value;
	}
	// We do not support this option
	if (iVal != 1)
		EnableWindow(GetDlgItem(hwnd, IDC_CONCURGC), 0);
	else
		EnableWindow(GetDlgItem(hwnd, IDC_CONCURGC), 1);

}// CheckConGC

//---------------------------------------------------------------
// onEconoJITClick
//
// This function will toggle the activate of the text fields
// when the user selects/deselects use EconoJIT only
//---------------------------------------------------------------
void onEconoJITClick(HWND hwnd)
{
	// We'll enable them by default....
	int fEnable = 1;
	
	// They unchecked the box.... let's disable the text fields
	if (IsDlgButtonChecked(hwnd, IDC_ECONOJIT) == BST_CHECKED)
		fEnable = 0;

	// Enable/Disable the text field
	EnableWindow(GetDlgItem(hwnd, IDC_MAXPITCH), fEnable);
	// Enable/Disable the "LimitCache Size" checkbox
	EnableWindow(GetDlgItem(hwnd, IDC_LIMITCACHE), fEnable);


	// Make sure we're not stomping on LimitCache's properties on the max cache
	fEnable&=IsDlgButtonChecked(hwnd, IDC_LIMITCACHE) == BST_CHECKED;	
	EnableWindow(GetDlgItem(hwnd, IDC_MAXCACHE), fEnable);
}// onEconoJITClick

//---------------------------------------------------------------
// onLimitCacheClick
//
// This function will toggle the activatation of the text field
// to set the maximum code cache size
//---------------------------------------------------------------
void onLimitCacheClick(HWND hwnd)
{
	// We'll disable it by default....
	int fEnable = 0;
	
	// They unchecked the box.... let's disable the text fields
	if (IsDlgButtonChecked(hwnd, IDC_LIMITCACHE) == BST_CHECKED)
		fEnable = 1;

	// Make sure we're not overwriting the property that EconoJIT set on this item
	fEnable&=IsDlgButtonChecked(hwnd, IDC_ECONOJIT) != BST_CHECKED;

	// Enable/Disable the text field
	EnableWindow(GetDlgItem(hwnd, IDC_MAXCACHE), fEnable);
}// onLimitCacheClick
				
//---------------------------------------------------------------
// GetData
//
// This function will get the data from the dialog box and place
// it in the registry
//---------------------------------------------------------------
int GetData(HWND hwnd)
{
	char szMaxCache[100];
	char szMaxPitch[100];


	// First pull all the data off the dialog
	GetDlgItemText(hwnd, IDC_MAXPITCH, szMaxPitch, 99);
	GetDlgItemText(hwnd, IDC_MAXCACHE, szMaxCache, 99);

	int iEconJIT = IsDlgButtonChecked(hwnd, IDC_ECONOJIT);
	int iOp4Size = IsDlgButtonChecked(hwnd, IDC_OP4SIZE);
	int iConGC = IsDlgButtonChecked(hwnd, IDC_CONCURGC);
	int iLimitCC = IsDlgButtonChecked(hwnd, IDC_LIMITCACHE);

	// Now let's verify the text fields

	// We only need to verify the max cache field if we're limiting the 
	// size of the cache
	int	 iMaxCache;
	if (iLimitCC)
	{
		iMaxCache = atoi(szMaxCache);
		if (iMaxCache < 4096)
		{
			MessageBox(hwnd, "The Max Code Cache field must be at least 4096 bytes", "Error", MB_ICONEXCLAMATION);
			return 0;
		}
	}
	// Ok, MaxCache is ok... let's test the Max Pitch
	int iMaxPitch = atoi(szMaxPitch);
	if (iMaxPitch < 0)
	{
		MessageBox(hwnd, "The Max Code Pitch Overhead field may only contain positive values", "Error", MB_ICONEXCLAMATION);
		return 0;
	}
	else if (iMaxPitch > 100)
	{
		MessageBox(hwnd, "The Max Code Pitch Overhead field cannot be greater than 100", "Error", MB_ICONEXCLAMATION);
		return 0;
	}

	// See if we need to doctor up the text fields

	// If nothing was put in the Max Pitch Overhead box, we'll put in the default
	if (!szMaxPitch[0])
	{
		iMaxPitch=10;
	}

	// Ok, all the data is validated... let's put it where it belongs
	// If they're not limiting the size of the Code Cache, we shouldn't have an entry in 
	// the registry
	if (iLimitCC)
		SetCOMPlusRegistryDwordValueEx("MaxCodeCacheSize", iMaxCache, HKEY_LOCAL_MACHINE);
	else
		DeleteCOMPlusRegistryValueEx("MaxCodeCacheSize", HKEY_LOCAL_MACHINE);

	SetCOMPlusRegistryDwordValueEx("MaxPitchOverhead", iMaxPitch, HKEY_LOCAL_MACHINE);
	
	SetCOMPlusRegistryDwordValueEx("JITEnable", !iEconJIT, HKEY_LOCAL_MACHINE);

	SetCOMPlusRegistryDwordValueEx("GCconcurrent", iConGC, HKEY_LOCAL_MACHINE);

	// If they checked Optimize for Size, write out to opforSize, else we'll Op Overall
	SetCOMPlusRegistryDwordValueEx("JITOptimizeType", iOp4Size?JIT_OPT_SIZE:JIT_OPT_OVERALL, HKEY_LOCAL_MACHINE);

	return 1;
}// GetData

//---------------------------------------------------------------
// SetData
//
// This function will place the data from the registry into 
// the dialog box
//---------------------------------------------------------------
void SetData(HWND hwnd)
{
	char szMaxCache[REG_STRING_SIZE] = "";
	char szMaxPitch[REG_STRING_SIZE] = "10";

	// Now read the stuff from the registery
	
	// Get the value for the "Use EconoJIT only"
	int iEconJIT = !GetCOMPlusRegistryDwordValueEx("JITEnable", 1, HKEY_LOCAL_MACHINE);
	// Get the value for Optimize for Size
	int iOp4Size = GetCOMPlusRegistryDwordValueEx("JITOptimizeType", JIT_OPT_SPEED, HKEY_LOCAL_MACHINE) == JIT_OPT_SIZE;
	// Get the value for Concurrent GC
	int iConGC = GetCOMPlusRegistryDwordValueEx("GCconcurrent", 0, HKEY_LOCAL_MACHINE);
	// Now get the Max Code Cache
	int iMaxCache = GetCOMPlusRegistryDwordValueEx("MaxCodeCacheSize", -1, HKEY_LOCAL_MACHINE);

	// And get the Max Pitch Overhead
	int iMaxPitch= GetCOMPlusRegistryDwordValueEx("MaxPitchOverhead", 10, HKEY_LOCAL_MACHINE);
	
	// Now write this all to the dialog box
	CheckDlgButton(hwnd, IDC_ECONOJIT, iEconJIT?BST_CHECKED:BST_UNCHECKED);
	CheckDlgButton(hwnd, IDC_OP4SIZE, iOp4Size?BST_CHECKED:BST_UNCHECKED);
	CheckDlgButton(hwnd, IDC_CONCURGC, iConGC?BST_CHECKED:BST_UNCHECKED);
	CheckDlgButton(hwnd, IDC_LIMITCACHE, iMaxCache!=-1?BST_CHECKED:BST_UNCHECKED);

	SetDlgItemInt(hwnd, IDC_MAXPITCH, iMaxPitch, 0);
	if(iMaxCache != -1)
		SetDlgItemInt(hwnd, IDC_MAXCACHE, iMaxCache, 0);
	else
		SetDlgItemText(hwnd, IDC_MAXCACHE, "");

}// SetData


BOOL  SetCOMPlusRegistryDwordValueEx(const char * valName, DWORD value, HKEY hRoot)
{
    HKEY  hkey;
    DWORD op, res;

    int   size = sizeof(DWORD);

    res = RegCreateKeyEx(hRoot,
                        "Software\\Microsoft\\.NETFramework",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkey,
                        &op);

    assert(res == ERROR_SUCCESS);

    res = RegSetValueEx(hkey,
                        valName,
                        0,
                        REG_DWORD,
                        (unsigned char *)&value,
                        size);

    assert(res == ERROR_SUCCESS);

    RegCloseKey(hkey);

    return TRUE;
}// SetCOMPlusRegisteryDwordValueEx


DWORD GetCOMPlusRegistryDwordValueEx(const char * valName, DWORD defValue, HKEY hRoot)
{
    HKEY      hkey;

    DWORD     value;
    DWORD     size = sizeof(value);
    DWORD     type = REG_BINARY;
    DWORD     res;

    res = RegOpenKeyEx   (hRoot, "Software\\Microsoft\\.NETFramework", 0, KEY_ALL_ACCESS, &hkey);
    if (res != ERROR_SUCCESS)
        return defValue;

    res = RegQueryValueEx(hkey, valName, 0, &type, (unsigned char *)&value, &size);

    RegCloseKey(hkey);

    if (res != ERROR_SUCCESS || type != REG_DWORD)
        return defValue;
    else
        return value;
}// GetCOMPlusRegistryDwordValueEx

void DeleteCOMPlusRegistryValueEx(const char * valName, HKEY hRoot)
{
    HKEY      hkey;

    DWORD     res;

    res = RegOpenKeyEx   (hRoot, "Software\\Microsoft\\.NETFramework", 0, KEY_ALL_ACCESS, &hkey);
    if (res != ERROR_SUCCESS)
        return;

    res = RegDeleteValue(hkey, valName);

    RegCloseKey(hkey);
}// DeleteCOMPlusRegistryValueEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitmanager\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"JITMGR.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime JIT Compiler Manager\0"
#define VER_ORIGFILENAME_STR    "jitmgr.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\jitmanager\toggles.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


DEFINE_TOGGLE(EXCEPTION,
              "IgnoreUnmanagedExceptions",
              "Ignore unmanaged faults in managed handlers",
              "Turn unmanaged faults into managed exceptions"
              )

#undef DEFINE_TOGGLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\load64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <stdio.h>
#include <stddef.h>
#include <windows.h>
#include <malloc.h>
#include "ceeload.h"

void __cdecl main(int argc, char **argv)
{
    __int32 RetVal = -1;
    int x;
    char space = ' ';
    if (argc < 2) {
        printf("Load64: ProgramPath\n");
        return;
    }
    // expand the image pathname
    char exPath[MAX_PATH];
    LPTSTR lpFilePart;
    GetFullPathName(argv[1], MAX_PATH, exPath, &lpFilePart);
    // convert image name to wide char string
    DWORD cImageNameIn = MultiByteToWideChar(CP_ACP,    // determine the length of the image path
                                             0,
                                             exPath,
                                             -1,
                                             NULL,
                                             0);
    LPWSTR  pImageNameIn = (LPWSTR)_alloca((cImageNameIn+1) * sizeof(WCHAR)); // allocate space for it
    MultiByteToWideChar(CP_ACP,         // convert the ansi image path to wide
                        0,
                        exPath,
                        -1,
                        pImageNameIn,
                        cImageNameIn);
    // convert loaders path to wide char string
    DWORD cLoadersFileName = MultiByteToWideChar(CP_ACP,    // determine the length of the loaders path
                                                 0,
                                                 argv[0],
                                                 -1,
                                                 NULL,
                                                 0);
    LPWSTR pLoadersFileName = (LPWSTR)_alloca((cLoadersFileName+1) * sizeof(WCHAR)); // allocate space for it
    MultiByteToWideChar(CP_ACP,         // convert the ansi loaders path to wide
                        0,
                        argv[0],
                        -1,
                        pLoadersFileName,
                        cLoadersFileName);
    // build the command line
    int cCmdLine = argc + (int)strlen(exPath); // start with spaces between,image full path length,  and null terminator
    for (x=2;x < argc;x++) {
        cCmdLine += (int)strlen(argv[x]);
    }
    char* pAnsiCmdLine = (char*)_alloca(cCmdLine);
    strcpy(pAnsiCmdLine, exPath);
    for (x=2;x < argc;x++) {
        strcat(pAnsiCmdLine, &space);
        strcat(pAnsiCmdLine, argv[x]);
    }
    LPWSTR pCmdLine = (LPWSTR)_alloca(cCmdLine * sizeof(WCHAR));
    MultiByteToWideChar(CP_ACP,         // convert ansi command line to wide
                        0,
                        pAnsiCmdLine,
                        -1,
                        pCmdLine,
                        cCmdLine);

    // Load and execute the image
    PELoader* pe = new PELoader;
    if (!pe->open(argv[1])) {
        printf("Error(%d) Opening %s", GetLastError(), argv[1]);
        goto exit;
    }
    IMAGE_COR20_HEADER* CorHdr;
    if (!pe->getCOMHeader(&CorHdr)) {
        printf("%s is not Common Language Runtime format", argv[1]);
        goto exit;
    }
    RetVal = pe->execute(pImageNameIn,      // -> command to execute
                         pLoadersFileName,  // -> loaders file name
                         pCmdLine);         // -> command line


exit:
    delete pe;
    ExitProcess(RetVal);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\ceeload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.CPP
// 

// CEELOAD reads in the PE file format using LoadLibrary
// ===========================================================================
#pragma warning (disable : 4121) // ntkxapi.h(59) alignment warning
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;
#include "ceeload.h"
#include <CorHdr.h>
#include <Cor.h>
#pragma warning (default : 4121)
/*
#include "cor.h"
#include <ntrtl.h>
#include <nturtl.h>
*/
#include "util.hpp"


// ---------------------------------------------------------------------------
// LoadModule
// ---------------------------------------------------------------------------
// Following two functions lifted from NT sources, imagedir.c
PIMAGE_SECTION_HEADER
Cor_RtlImageRvaToSection(
	IN PIMAGE_NT_HEADERS32 NtHeaders,
	IN PVOID Base,
	IN ULONG Rva
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file
	that is mapped as a file and returns a pointer to the section
	table entry for that virtual address

Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

	NULL - The RVA was not found within any of the sections of the image.

	NON-NULL - Returns the pointer to the image section that contains
			   the RVA

--*/

{
	ULONG i;
	PIMAGE_SECTION_HEADER NtSection;

	NtSection = IMAGE_FIRST_SECTION( NtHeaders );
	for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
		if (Rva >= NtSection->VirtualAddress &&
			Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
		   ) {
			return NtSection;
			}
		++NtSection;
		}

	return NULL;
}

PVOID
Cor_RtlImageRvaToVa(
	IN PIMAGE_NT_HEADERS32 NtHeaders,
	IN PVOID Base,
	IN ULONG Rva,
	IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
	)

/*++

Routine Description:

	This function locates an RVA within the image header of a file that
	is mapped as a file and returns the virtual addrees of the
	corresponding byte in the file.


Arguments:

	NtHeaders - Supplies the pointer to the image or data file.

	Base - Supplies the base of the image or data file.  The image
		was mapped as a data file.

	Rva - Supplies the relative virtual address (RVA) to locate.

	LastRvaSection - Optional parameter that if specified, points
		to a variable that contains the last section value used for
		the specified image to translate and RVA to a VA.

Return Value:

	NULL - The file does not contain the specified RVA

	NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
	PIMAGE_SECTION_HEADER NtSection;

	if (!ARGUMENT_PRESENT( LastRvaSection ) ||
		(NtSection = *LastRvaSection) == NULL ||
		Rva < NtSection->VirtualAddress ||
		Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
	   ) {
		NtSection = Cor_RtlImageRvaToSection( NtHeaders,
										  Base,
										  Rva
										);
		}

	if (NtSection != NULL) {
		if (LastRvaSection != NULL) {
			*LastRvaSection = NtSection;
			}

		return (PVOID)((PCHAR)Base +
					   (Rva - NtSection->VirtualAddress) +
					   NtSection->PointerToRawData
					  );
		}
	else {
		return NULL;
		}
}



// Class PELoader...

/*************************************************************************************/
// Constructor and destructor!
/*************************************************************************************/
PELoader::PELoader()
{
    m_hFile = NULL;
    m_hMod = NULL;
    m_hMapFile = NULL;
    m_pNT = NULL;
}

PELoader::~PELoader()
{
	
	m_hMod = NULL;
	m_pNT = NULL;
	// If we have an hFile then we opened this file ourselves!
	// If we do not then this file was loaded by the OS and the OS will
	// close it for us.
    if (m_hFile)
	    this->close();
}

/*************************************************************************************/
/*************************************************************************************/
void PELoader::close()
{
	
	// _ASSERTE(m_hFile != NULL);
	if (m_hFile)
    {
	    if (m_hMod)
		    UnmapViewOfFile((void*)m_hMod);
	    if (m_hMapFile)
		    CloseHandle(m_hMapFile);
	    CloseHandle(m_hFile);

        m_hMod = NULL;
        m_hMapFile = NULL;
        m_hFile = NULL;
    }
}


BOOL PELoader::open(LPCSTR moduleName)
{    
    HMODULE newhMod = NULL;
    
    _ASSERTE(moduleName);
    if (!moduleName) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

    m_hFile = CreateFile(moduleName, GENERIC_READ, FILE_SHARE_READ,
                         0, OPEN_EXISTING, 0, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    m_hMapFile = CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMapFile == NULL)
        return FALSE;

    newhMod = (HMODULE) MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (newhMod == NULL)
        return FALSE;
   return open(newhMod);
}


/*************************************************************************************/
BOOL PELoader::open(HMODULE hMod)
{

    IMAGE_DOS_HEADER* pdosHeader;
    //DWORD cbRead;

    // _ASSERTE(hMod);
    // get the dos header...
	m_hMod = hMod;
	pdosHeader = (IMAGE_DOS_HEADER*) hMod;
    
    if (pdosHeader->e_magic == IMAGE_DOS_SIGNATURE && 
		0 < pdosHeader->e_lfanew && pdosHeader->e_lfanew < 0xFF0)	// has to start on first page
	{
		m_pNT = (IMAGE_NT_HEADERS32*) (pdosHeader->e_lfanew + (size_t) m_hMod);

	    if ((m_pNT->Signature != IMAGE_NT_SIGNATURE) ||
			(m_pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL32_HEADER) ||
		    (m_pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC))
		{
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
			// Make this appear uninitalized because for some reason this file is toast...
			// Not sure that this could ever happen because this file has already been loaded 
			// bye the system loader unless someone gave us garbage as the hmod
			m_pNT = NULL;
			m_hMod = NULL;
			return FALSE;
		}
	}
	else
	{
        SetLastError(ERROR_BAD_FORMAT);
		m_hMod = NULL;
		return FALSE;
	}

	return TRUE;
}

__int32 PELoader::execute(LPWSTR  pImageNameIn,
                          LPWSTR  pLoadersFileName,
                          LPWSTR  pCmdLine)
{
    DWORD dwHighSize;
    DWORD dwLowSize = GetFileSize(m_hFile, &dwHighSize);
    return _CorExeMain2((BYTE*)m_hMod,      //module address
                        dwLowSize,          //module size
                        pImageNameIn,       //-> module name
                        pLoadersFileName,   //-> loaders name
                        pCmdLine);          //-> command line
}

/*************************************************************************************/
void PELoader::dump()
{
	IMAGE_FILE_HEADER* pHeader = &m_pNT->FileHeader;
	IMAGE_OPTIONAL_HEADER32* pOptHeader = &m_pNT->OptionalHeader;
	IMAGE_SECTION_HEADER* rgsh = (IMAGE_SECTION_HEADER*) (pOptHeader + 1);
}

/*************************************************************************************/
BOOL PELoader::getCOMHeader(IMAGE_COR20_HEADER **ppCorHeader) 
{

    PIMAGE_NT_HEADERS32		pImageHeader;
	PIMAGE_SECTION_HEADER	pSectionHeader;

	// Get the image header from the image, then get the directory location
	// of the COM+ header which may or may not be filled out.
    pImageHeader = (PIMAGE_NT_HEADERS32)RtlpImageNtHeader(m_hMod);
	pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pImageHeader, m_hMod, 
		pImageHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
		NULL);

	// If the section header exists, then return ok and the address.
	if (pSectionHeader)
	{
		*ppCorHeader = (IMAGE_COR20_HEADER *) pSectionHeader;
        return TRUE;
	}
	// If there is no COM+ Data in this image, return false.
    else {
        SetLastError(ERROR_EXE_MARKED_INVALID);
		return FALSE;
    }
}

/*************************************************************************************/
BOOL PELoader::getVAforRVA(DWORD rva,void **ppva) 
{

    PIMAGE_NT_HEADERS32		pImageHeader;
	PIMAGE_SECTION_HEADER	pSectionHeader;

	// Get the image header from the image, then get the directory location
	// of the COM+ header which may or may not be filled out.
    pImageHeader = (PIMAGE_NT_HEADERS32)RtlpImageNtHeader(m_hMod);
	pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pImageHeader, m_hMod, 
		rva,
		NULL);

	// If the section header exists, then return ok and the address.
	if (pSectionHeader)
	{
		*ppva = pSectionHeader;
        return TRUE;
	}
	// If there is no COM+ Data in this image, return false.
	else
		return FALSE;
}

void SectionInfo::Init(PELoader *pPELoader, IMAGE_DATA_DIRECTORY *dir)
{
    _ASSERTE(dir);
    m_dwSectionOffset = dir->VirtualAddress;
	if (m_dwSectionOffset != 0)
		m_pSection = pPELoader->base() + m_dwSectionOffset;
	else
		m_pSection = 0;
    m_dwSectionSize = dir->Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\warningcontrol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// warningcontrol.h
//
// Header file to globally control the warning settings for the entire Viper build.
// You do not need to explicitly include this file; rather, it gets included
// on the command line with a /FI (force include) directive. This is controlled 
// in sources.vip.
//
// KEEP THIS LIST SORTED!
//
#pragma warning(disable :4001)	 // "nonstandard extension 'single line comment' was used"
#pragma warning(error	:4007)	 // 'main' : must be __cdecl
#pragma warning(disable :4010)	 // "single-line comment contains line-continuation character"		
#pragma warning(error	:4013)	 // 'function' undefined - assuming extern returning int
#pragma warning(disable :4022)	 // "'%s' : pointer mismatch for actual parameter %d"
#pragma warning(disable :4047)	 // "'%$L' : '%$T' differs in levels of indirection from '%$T'"
#pragma warning(disable :4053)	 // "one void operand for '?:'"
#pragma warning(disable :4056)	 // "overflow in floating-point constant arithmetic"
#pragma warning(disable :4061)	 // "enumerate '%$S' in switch of enum '%$S' is not explicitly handled by a case label"
#pragma warning(error	:4071)	 // no function prototype given
#pragma warning(error	:4072)	 // no function prototype given (fastcall)
#pragma warning(3		:4092)	 // sizeof returns 'unsigned long'
#pragma warning(disable :4100)	 // "'%$S' : unreferenced formal parameter"
//#pragma warning(error	:4101)	 // "'%$S' : unreferenced local variable"
//#pragma warning(error	:4102)	 // "'%$S' : unreferenced label"
#pragma warning(3		:4121)	 // structure is sensitive to alignment
#pragma warning(disable :4127)	 // "conditional expression is constant"
#pragma warning(3		:4125)	 // decimal digit in octal sequence
#pragma warning(3		:4130)	 // logical operation on address of string constant
#pragma warning(3		:4132)	 // const object should be initialized
#pragma warning(error	:4171)	 // no function prototype given (old style)
#pragma warning(4		:4177)	 // pragma data_seg s/b at global scope
#pragma warning(disable :4201)	 // "nonstandard extension used : nameless struct/union"
#pragma warning(disable :4204)	 // "nonstandard extension used : non-constant aggregate initializer"
#pragma warning(4		:4206)	 // Source File is empty
#pragma warning(3		:4212)	 // function declaration used ellipsis
#pragma warning(error	        :4259)	 // pure virtual function was not defined
#pragma warning(disable	        :4291)	 // delete not defined for new, c++ exception may cause leak
#pragma warning(3		:4509)	 // "nonstandard extension used: '%$S' uses SEH and '%$S' has destructor"
								 //
								 // But beware of doing a return from inside such a try block:
								 // 	
								 // 	int foo()
								 // 		{
								 // 		ClassWithDestructor c;
								 // 		__try {
								 // 			return 0;
								 // 		} __finally {
								 // 			printf("in finally");
								 // 		}
								 //
								 // as (it's a bug) the return value gets toasted. So DON'T casually 
								 // dismiss this warning if you're compiling w/o CXX EH turned on (the default).

#pragma warning(3		:4530)	 // C++ exception handler used, but unwind semantics are not enabled. Specify -GX
#pragma warning(error	:4551)	 // Function call missing argument list

#pragma warning(error	:4700)	 // Local used w/o being initialized
#pragma warning(disable	:4706)	 // assignment within conditional expression
#pragma warning(disable :4786)	 // identifier was truncated to '255' characters in the browser (or debug) information
#pragma warning(error	:4806)	 // unsafe operation involving type 'bool'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\common.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP
#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.

#include <stdio.h>
#include <cor.h>
#include <corpriv.h>
#include <wincrypt.h>
#include <CeeGen.h>
#include "hash.h"
#include <utilcode.h>
#include <corhost.h>
#include "fusion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\ceeload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.H
// 

// CEELOAD.H defines the class use to represent the PE file
// ===========================================================================
#ifndef CEELoad_H 
#define CEELoad_H

#include <windows.h>
#include <cor.h>
//#include <wtypes.h>	// for HFILE, HANDLE, HMODULE

class PELoader;

//
// Used to cache information about sections we're interested in (descr, callsig, il)
//
class SectionInfo
{
public:
    BYTE *  m_pSection;         // pointer to the beginning of the section
    DWORD   m_dwSectionOffset;  // RVA
    DWORD   m_dwSectionSize;    

    // init this class's member variables from the provided directory
    void Init(PELoader *pPELoader, IMAGE_DATA_DIRECTORY *dir);

    // returns whether this RVA is inside the section
    BOOL InSection(DWORD dwRVA)
    {
        return (dwRVA >= m_dwSectionOffset) && (dwRVA < m_dwSectionOffset + m_dwSectionSize);
    }
};

class PELoader {
  protected:

    HMODULE m_hMod;
    HANDLE m_hFile;
    HANDLE m_hMapFile;

    PIMAGE_NT_HEADERS32 m_pNT;

  public:
    SectionInfo m_DescrSection;
    SectionInfo m_CallSigSection;
    SectionInfo m_ILSection;

    PELoader();
	~PELoader();
	BOOL open(const char* moduleNameIn);
	BOOL open(HMODULE hMod);
    __int32 execute(LPWSTR  pImageNameIn,
                    LPWSTR  pLoadersFileName,
                    LPWSTR  pCmdLine);
	BOOL getCOMHeader(IMAGE_COR20_HEADER **ppCorHeader);
	BOOL getVAforRVA(DWORD rva,void **ppCorHeader);
	void close();
    void dump();
    inline PIMAGE_NT_HEADERS32 ntHeaders() { return m_pNT; }
    inline BYTE*  base() { return (BYTE*) m_hMod; }
    inline HMODULE getHModule() { return  m_hMod; }
	inline HANDLE getHFile()	{ return  m_hFile; }
};

#endif // CEELoad_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\load64\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_EXE
#define VER_INTERNALNAME_STR    "LOAD64.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Loader for IA64\0"
#define VER_ORIGFILENAME_STR    "load64.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\hash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: hash.cpp
//
#include "common.h"


LMClassHashTable::LMClassHashTable()
{
    m_pBuckets = NULL;
    m_dwNumBuckets = 0;
    m_pDataHead = NULL;
    m_pDataTail = NULL;

#ifdef _DEBUG
    m_dwDebugMemory = 0;
#endif
}

LMClassHashTable::~LMClassHashTable()
{
    if (m_pBuckets) {
        for (DWORD i = 0; i < m_dwNumBuckets; i++)
        {
            LMClassHashEntry_t *pEntry, *pNext;

            for (pEntry = m_pBuckets[i]; pEntry != NULL; pEntry = pNext)
            {
                pNext = pEntry->pNext;
                delete(pEntry);
            }
        }

        delete[] m_pBuckets;
    }

    TypeData *pData;
    while (m_pDataHead) {
        pData = m_pDataHead;
        m_pDataHead = m_pDataHead->pNext;
        delete pData;
    }
}


BOOL LMClassHashTable::Init(DWORD dwNumBuckets)
{
    if (!dwNumBuckets)
        dwNumBuckets = 1;

    m_pBuckets = new LMClassHashEntry_t*[dwNumBuckets];
    if (!m_pBuckets)
        return FALSE;

#ifdef _DEBUG
    m_dwDebugMemory += (dwNumBuckets * sizeof(LMClassHashEntry_t*));
#endif

    memset(m_pBuckets, 0, dwNumBuckets*sizeof(LMClassHashEntry_t*));

    m_dwNumBuckets = dwNumBuckets;

    return TRUE;
}


LMClassHashEntry_t *LMClassHashTable::AllocNewEntry()
{
#ifdef _DEBUG
    m_dwDebugMemory += (sizeof(LMClassHashEntry));
#endif

    return (LMClassHashEntry_t *) new BYTE[sizeof(LMClassHashEntry)];
}


LMClassHashEntry_t *LMClassHashTable::InsertValue(LPWSTR pszClassName, TypeData *pData, LMClassHashEntry_t *pEncloser)
{
    _ASSERTE(pszClassName != NULL);
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    LMClassHashEntry_t * pNewEntry;

    if (!(pNewEntry = AllocNewEntry()))
        return NULL;

    // Insert at head of bucket if non-nested, at end if nested
    if (pEncloser && m_pBuckets[dwBucket]) {
        LMClassHashEntry_t *pCurrent = m_pBuckets[dwBucket];
        while (pCurrent->pNext)
            pCurrent = pCurrent->pNext;

        pCurrent->pNext  = pNewEntry;
        pNewEntry->pNext = NULL;
    }
    else {
        pNewEntry->pNext     = m_pBuckets[dwBucket];
        m_pBuckets[dwBucket] = pNewEntry;
    }

    pNewEntry->pEncloser    = pEncloser;
    pNewEntry->pData         = pData;
    pNewEntry->dwHashValue  = dwHash;
    pNewEntry->Key          = pszClassName;

    return pNewEntry;
}

LMClassHashEntry_t *LMClassHashTable::FindItem(LPWSTR pszClassName, BOOL IsNested)
{
    _ASSERTE(pszClassName != NULL);
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    LMClassHashEntry_t * pSearch;

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && CompareKeys(pSearch->Key, pszClassName)) {
            // If (IsNested), then we're looking for a nested class
            // If (pSearch->pEncloser), we've found a nested class
            if (IsNested) {
                if (pSearch->pEncloser)
                    return pSearch;
            }
            else {
                if (pSearch->pEncloser)
                    return NULL; // searched past non-nested classes
                else                    
                    return pSearch;
            }
        }
    }

    return NULL;
}

LMClassHashEntry_t *LMClassHashTable::FindNextNestedClass(LPWSTR pszClassName, TypeData **ppData, LMClassHashEntry_t *pBucket)
{
    DWORD           dwHash = Hash(pszClassName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    LMClassHashEntry_t * pSearch = pBucket->pNext;

    for (; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && CompareKeys(pSearch->Key, pszClassName)) {
            *ppData = pSearch->pData;
            return pSearch;
        }
    }

    return NULL;
}


LMClassHashEntry_t * LMClassHashTable::GetValue(LPWSTR pszClassName, TypeData **ppData,
                                                BOOL IsNested)
{
    LMClassHashEntry_t *pItem = FindItem(pszClassName, IsNested);

    if (pItem)
        *ppData = pItem->pData;

    return pItem;
}


// Returns TRUE if two keys are the same string
BOOL LMClassHashTable::CompareKeys(LPWSTR Key1, LPWSTR Key2)
{
    if (Key1 == Key2)
        return TRUE;
    else
        return !wcscmp(Key1, Key2);
}

DWORD LMClassHashTable::Hash(LPWSTR pszClassName)
{
    DWORD dwHash = 5381;
    DWORD dwChar;

    while ((dwChar = *pszClassName++) != 0)
        dwHash = ((dwHash << 5) + dwHash) ^ dwChar;

    return  dwHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\hash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: hash.h
//


#ifndef _LM_HASH_H
#define _LM_HASH_H

class TypeData;

// One of these is present for each element in the table
typedef struct LMClassHashEntry
{
    struct LMClassHashEntry *pNext;
    struct LMClassHashEntry *pEncloser; // NULL if this is not a nested class
    DWORD               dwHashValue;
    TypeData            *pData;
    LPWSTR              Key;
} LMClassHashEntry_t;


class TypeData {
public:
    wchar_t   wszName[MAX_CLASS_NAME];
    mdToken   mdThisType; // ExportedType or TypeDef for this type
    DWORD     dwAttrs;    // flags
    mdExportedType mdComType;  // token for ComType emitted in new assembly
    LMClassHashEntry_t *pEncloser; // encloser entry, if this is a nested type
    TypeData  *pNext; // next type, in same order they were enum'd from the metadata
    // That's important since we need to know the encloser's ComType token
    // when emitting a ComType for a nested class.  So, we need to emit in order.

    TypeData() {
        dwAttrs = 0;
        mdComType = mdTokenNil; // mdTokenNil if no ComType emitted.
        // Otherwise, set to token for emitted CT.
        pEncloser = NULL;
        pNext = NULL;
    }

    ~TypeData() {
    }
};

class LMClassHashTable 
{
protected:
    LMClassHashEntry_t **m_pBuckets;    // Pointer to first entry for each bucket
    DWORD           m_dwNumBuckets;

public:
    TypeData *m_pDataHead;
    TypeData *m_pDataTail;

#ifdef _DEBUG
    DWORD           m_dwDebugMemory;
#endif

    LMClassHashTable();
    ~LMClassHashTable();

    BOOL Init(DWORD dwNumBuckets);
    LMClassHashEntry_t * GetValue(LPWSTR pszClassName, TypeData **ppData,
                                  BOOL IsNested);
    LMClassHashEntry_t *FindNextNestedClass(LPWSTR pszClassName, TypeData **pData, LMClassHashEntry_t *pBucket);
    LMClassHashEntry_t * InsertValue(LPWSTR pszClassName, TypeData *pData, LMClassHashEntry_t *pEncloser);

    // Case-sensitive if comparing type names, case-insensitive if
    // comparing file names
    static BOOL     CompareKeys(LPWSTR Key1, LPWSTR Key2);
    static DWORD    Hash(LPWSTR pszClassName);

private:
    LMClassHashEntry_t * AllocNewEntry();
    LMClassHashEntry_t * FindItem(LPWSTR pszClassName, BOOL IsNested);
};

#endif /* _LM_HASH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\lm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: lm.h
//

#ifndef _LM_H
#define _LM_H

EXTERN IMetaDataDispenser* g_pDispenser;
EXTERN bool                g_verbose;

void    PrintError(LPSTR szMessage, ...);
HRESULT PrintOutOfMemory();
HRESULT CheckEnvironmentPath(char *szFileName, char **szFinalPath,
                             char **szFinalPathName, int *iFinalPath,
                             HANDLE *hFile);
LPWSTR GetKeyContainerName();

void FindVersion(LPSTR szVersion,
                 DWORD cbVersion,
                 USHORT *usMajorVersion,
                 USHORT *usMinorVersion,
                 USHORT *usRevisionNumber,
                 USHORT *usBuildNumber);


//
// Various XML tags used to build security permission requests.
//
#define XML_PERMISSION_SET_LEADER   "<PermissionSet"
#define XML_PERMISSION_SET_HEAD     "<PermissionSet class=\"System.Security.PermissionSet\">"
#define XML_PERMISSION_SET_TAIL     "</PermissionSet>"
#define XML_PERMISSION_LEADER       "<Permission class=\""
#define XML_PERMISSION_TAIL         "</Permission>"
#define XML_SECURITY_PERM_CLASS     "System.Security.Permissions.SecurityPermission"
#define XML_SKIP_VERIFICATION_TAG   "<SkipVerification/>"
#define XML_UNRESTRICTED_TAG        "<Unrestricted/>"


//
// Global info for the PE - contains all info read from PE files containing IL
//
class ModuleReader
{
public:
    ModuleReader();
    ~ModuleReader();


    LPWSTR       m_wszInputFileName;
    mdTypeDef    *m_rgTypeDefs;
    DWORD        m_dwNumTypeDefs;
    DWORD        m_dwAttrs;
    char         *m_szFinalPath;
    int          m_iFinalPath;
    char         *m_szFinalPathName;  // Ptr to the name portion of m_szFinalPath
    bool         m_SkipVerification;
    mdModuleRef  *m_rgModuleRefs;
    bool         *m_rgModuleRefUnused;
    DWORD        m_dwNumModuleRefs;
    IMetaDataImport *m_pImport;

    IMetaDataAssemblyImport *m_pAsmImport;
    DWORD        m_dwNumAssemblyRefs;
    mdAssemblyRef *m_rgAssemblyRefs;
    wchar_t      m_wszAsmRefName[MAX_CLASS_NAME];
    ASSEMBLYMETADATA m_AssemblyIdentity;
    void         *m_pbOriginator;
    DWORD        m_dwOriginator;
    DWORD        m_dwFlags;

    mdToken      m_mdEntryPoint;
    mdTypeRef*   m_rgTypeRefs;
    DWORD        m_dwNumTypeRefs;
    PBYTE        m_pbHash;
    DWORD        m_dwHash;


    HRESULT     InitInputFile(char *szFileName, ALG_ID iHashAlg,
                              DWORD *dwManifestRVA, bool SecondPass,
                              bool FindEntry, bool AFile, FILETIME *filetime);
    HRESULT     CheckForSecondPass(HANDLE hFile, ALG_ID iHashAlg,
                                   DWORD *dwManifestRVA, bool FindEntry,
                                   bool AFile, FILETIME *filetime);
    HRESULT     ReadModuleFile();
    static HRESULT EnumTypeDefs(IMetaDataImport *pImport,
                                DWORD           *dwNumTypeDefs,
                                mdTypeDef       **rgTypeDefs);
    static HRESULT GetTypeDefProps(IMetaDataImport *pImport,
                                   mdTypeDef mdType, LPWSTR wszName,
                                   DWORD *pdwAttrs, mdTypeDef *mdEnclosingTD);
    HRESULT     EnumTypeRefs();
    HRESULT     GetTypeRefProps(mdTypeRef tr, LPWSTR wszTypeRefName,
                                mdToken *mdResScope);
    HRESULT     CheckForResolvedTypeRef(mdToken mdResScope);
    HRESULT     EnumModuleRefs();
    HRESULT     GetModuleRefProps(mdModuleRef mdModuleRef, LPWSTR wszName);
    HRESULT     EnumAssemblyRefs();
    HRESULT     GetAssemblyRefProps(DWORD index);

private:
    void        GetEntryPoint(IMAGE_COR20_HEADER *pICH);
    void        TranslateArrayName(LPWSTR wszTypeRefName, DWORD dwTypeRefName);
};


class ManifestModuleReader
{
public:
    ManifestModuleReader();
    ~ManifestModuleReader();

    PBYTE                 m_pbMapAddress;
    LPWSTR                m_wszInputFileName;  // Name of original file
    LPWSTR                m_wszAsmName;
    LPWSTR                m_wszDefaultAlias;
    void                  *m_pbOriginator;
    DWORD                 m_dwOriginator;
    ULONG                 m_ulHashAlgorithm;
    ASSEMBLYMETADATA      m_AssemblyIdentity;
    DWORD                 m_dwFlags;
    char                  *m_szFinalPath;
    int                   m_iFinalPath;
    char                  *m_szFinalPathName;  // Ptr to the name portion of m_szFinalPath
    PBYTE                 m_pbHash;
    DWORD                 m_dwHash;
    DWORD                 m_dwNumFiles;
    mdFile                *m_rgFiles;
    DWORD                 m_dwCurrentFileName;

    mdExportedType        *m_rgComTypes;
    DWORD                 m_dwNumComTypes;
    mdTypeDef             *m_rgTypeDefs;
    DWORD                 m_dwNumTypeDefs;

    DWORD                 m_dwNumResources;
    mdManifestResource    *m_rgResources;
    mdToken               m_mdCurrentResourceImpl;
    LPWSTR                m_wszCurrentResource;

    IMetaDataImport       *m_pImport; // importer for regular MD section
    IMetaDataImport       *m_pManifestImport;  // importer for the manifest's
    // MD section, which may be the regular MD section or the -a location

    HRESULT     InitInputFile(char *szCache, char *szFileName,
                              ALG_ID iHashAlg, ASSEMBLYMETADATA *pContext,
                              char *szVersion, DWORD cbVersion, FILETIME *filetime);
    HRESULT     ReadManifestFile();
    HRESULT     EnumFiles();
    HRESULT     GetFileProps(mdFile mdFile);
    HRESULT     EnumComTypes();
    HRESULT     GetComTypeProps(mdExportedType mdComType, LPWSTR wszClassName, mdToken* pmdImpl);
    HRESULT     EnumResources();
    HRESULT     GetResourceProps(mdManifestResource mdResource);


private:
    HRESULT CheckCacheForFile(char *szCache, char *szName, HANDLE *hFile,
                              ASSEMBLYMETADATA *pContext, char *szVersion,
                              DWORD cbVersion);
    HRESULT CheckHeaderInfo(HANDLE hFile, ALG_ID iHashAlg);

    IMetaDataAssemblyImport *m_pAsmImport;
};


class ResourceModuleReader
{
public:
    ResourceModuleReader();
    ~ResourceModuleReader();

    char    *m_szFinalPath;
    char    *m_szFinalPathName;  // Ptr to the name portion of m_szFinalPath
    wchar_t m_wszResourceName[MAX_CLASS_NAME];
    HANDLE  m_hFile;
    DWORD   m_dwFileSize;
    PBYTE   m_pbHash;
    DWORD   m_dwHash;

    HRESULT InitInputFile(LPCUTF8 szResName, char *szFileName,
                          bool FindHash, ALG_ID iHashAlg);
};


class ManifestWriter
{
public:
    ManifestWriter();
    ~ManifestWriter();

    HRESULT Init();
    HRESULT SetAssemblyFileName(char *szCache, char *szAsmName,
                                char *szFileName, bool NeedCopyDir);
    void AddExtensionToAssemblyName();
    HRESULT SetPlatform(char *szPlatform);
    HRESULT SetVersion(char *szVersion);
    HRESULT GetVersionFromResource(char *szFileName);
    HRESULT SetLocale(char *szLocale);
    HRESULT GetContext(int iNumPlatforms, DWORD *pdwPlatforms);
    void CheckForEntryPoint(mdToken mdEntryPoint);
    void SetEntryPoint(LPSTR szFileName);
    HRESULT InitializeFusion(PBYTE pbOriginator, DWORD cbOriginator);
    HRESULT CreateNewPE();
    HRESULT SaveMetaData(char **szMetaData, DWORD *dwMetaDataLen);
    HRESULT UpdatePE(char *szMetaData, DWORD dwMetaDataLen,
                     int iNumResources, ResourceModuleReader rgRMReaders[]);
    HRESULT CopyFile(char *szFilePath, char *szFileName, bool AFile, bool copy, bool move, bool module);
    HRESULT CopyFileToFusion(LPWSTR wszFileName, PBYTE pbOriginator, DWORD cbOriginator, LPSTR szInputFileName, DWORD dwFormat, bool module);
    HRESULT CommitAllToFusion();
    HRESULT EmitFile(ModuleReader *mr);
    HRESULT EmitFile(ResourceModuleReader *mrr, mdFile *mdFile);
    HRESULT WriteManifestInfo(ManifestModuleReader *mmr, 
                              mdAssemblyRef *mdAssemblyRef);
    HRESULT CopyAssemblyRefInfo(ModuleReader *mr);
    HRESULT EmitComType(LPWSTR    wszClassName,
                        mdToken   mdImpl,
                        mdTypeDef mdClass,
                        DWORD     dwAttrs,
                        mdExportedType *pmdComType);
    HRESULT EmitComType(LPWSTR    wszClassName,
                        mdToken   mdImpl,
                        mdExportedType *pmdComType);
    HRESULT EmitResource(LPWSTR wszName, mdToken mdImpl, DWORD dwOffset);
    HRESULT EmitRequestPermissions(char *szPermFile, bool SkipVerification);
    HRESULT EmitManifest(PBYTE pbOriginator, DWORD cbOriginator);
    HRESULT FinishNewPE(PBYTE pbOriginator, DWORD cbOriginator, BOOL fStrongName);
    void SaveResourcesInNewPE(int iNumResources, ResourceModuleReader rgRMReaders[]);

    bool                  m_MainFound;
    bool                  m_FusionInitialized;
    bool                  m_FusionCache;
    DWORD                 m_dwBindFlags;

    mdFile                m_mdFile;
    ALG_ID                m_iHashAlgorithm;
    WCHAR                 m_wszFusionPath[MAX_PATH];
    ASSEMBLYMETADATA     *m_pContext;
    LPWSTR                m_wszAssemblyName;  // output file name
    LPWSTR                m_wszName;  // assembly name
    DWORD                 m_dwManifestRVA;
    LPWSTR                m_wszZFilePath;
    FILETIME              m_FileTime;

private:
    BOOL MakeDir(LPSTR szPath);
    void CreateOutputPath();
    //    void FindVersion(DWORD *hi, DWORD *lo);

    //    HRESULT CreateLink(LPCWSTR wszAssembly, LPCWSTR wszPathLink, LPCSTR wszDesc);
    HRESULT DetermineCodeBase();
    HRESULT GetFusionAssemblyPath();
    HRESULT SaveManifestInPE(char *szCachedFile, char *szMetaData,
                             DWORD dwMetaDataLen, int iNumResources,
                             ResourceModuleReader rgRMReaders[]);
    HRESULT AllocateStrongNameSignatureInNewPE();
    HRESULT StrongNameSignNewPE();
    
    IMetaDataEmit         *m_pEmit;
    IMetaDataAssemblyEmit *m_pAsmEmit;
    ICeeFileGen           *m_gen;
    HCEEFILE              m_ceeFile;

    WCHAR                 m_wszCodeBase[MAX_PATH];
    LPUTF8                m_szLocale;
    LPUTF8                m_szPlatform;
    LPUTF8                m_szVersion;
    LPUTF8                m_szAFilePath;
    LPUTF8                m_szCopyDir; // cache or cache/platform/locale/AsmnameVer/
#ifndef UNDER_CE
    LPASSEMBLYNAME        m_pFusionName;
    IAssemblyCacheItem    *m_pFusionCache;
#endif
    mdAssembly            m_mdAssembly;
};


class UnresolvedTypeRef {
public:
    wchar_t  wszName[MAX_CLASS_NAME];
    mdToken mdResScope;
    ModuleReader *pModReader;
    UnresolvedTypeRef *pNext;

    UnresolvedTypeRef() {
        pModReader = NULL;
        pNext = NULL;
    }

    ~UnresolvedTypeRef() {
    }
};


class PEHeaders
{
public:

    static IMAGE_NT_HEADERS * FindNTHeader(PBYTE pbMapAddress);
    static IMAGE_COR20_HEADER * getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT);
    static PVOID Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders,
                                     IN PVOID Base,
                                     IN ULONG Rva);
    static PIMAGE_SECTION_HEADER Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders,
                                                          IN PVOID Base,
                                                          IN ULONG Rva);
};

#endif /* _LM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\manifestwriter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ManifestWriter.cpp
//
// Emits manifest metadata
//

#include "common.h"

#define EXTERN extern
#include "lm.h"
#include <direct.h>
#include <shlobj.h>
#include <shlguid.h>
#include <corperm.h>
#include <corperme.h>
#include <StrongName.h>


extern PBYTE g_pbOrig;
extern DWORD g_cbOrig;


void FindVersion(LPSTR szVersion,
                 DWORD cbVersion,
                 USHORT *usMajorVersion,
                 USHORT *usMinorVersion,
                 USHORT *usRevisionNumber,
                 USHORT *usBuildNumber)
{
    _ASSERTE(usMajorVersion);
    _ASSERTE(usMinorVersion);
    _ASSERTE(usRevisionNumber);
    _ASSERTE(usBuildNumber);

    *usMajorVersion = 0;
    *usMinorVersion = 0;
    *usRevisionNumber = 0;
    *usBuildNumber = 0;
    
    if(!szVersion) return;

    DWORD dwDot = 0;
    DWORD dwStart = 0;
    DWORD dwOffset  = 3;
    USHORT dwValue;

    while(dwDot < cbVersion) {
        for(;dwDot < cbVersion && szVersion[dwDot] != '.'; dwDot++);
        if(dwDot < cbVersion) {
            szVersion[dwDot] = '\0';
            dwValue = (USHORT) atoi(szVersion + dwStart);
            szVersion[dwDot] = '_';
            dwDot++;
        }
        else
            dwValue = (USHORT) atoi(szVersion + dwStart);

        dwStart = dwDot;

        switch(dwOffset) {
        case 3:
            *usMajorVersion = dwValue;
            break;
        case 2:
            *usMinorVersion = dwValue;
            break;
        case 1:
            *usRevisionNumber = dwValue;
            break;
        case 0:
            *usBuildNumber = dwValue;
            break;
        default:
            return;
        }
        dwOffset--;
    }

    dwOffset++;
    DWORD count = 4 - dwOffset;
    for(dwDot = 0; dwDot < cbVersion && count; dwDot++) {
        if(szVersion[dwDot] == '_') {
            if(--count == 0) 
                szVersion[dwDot] = '\0';
        }
    }

                                       
}
        

ManifestWriter::ManifestWriter()
{
    memset(this, 0, sizeof(*this));

    m_gen = NULL;
    m_ceeFile = NULL;
    m_pEmit = NULL;
    m_pAsmEmit = NULL;

    m_wszName = NULL;
    m_wszAssemblyName = NULL;
    m_szLocale = "";
    m_szVersion = NULL;
    m_szPlatform = NULL;
    m_szAFilePath = NULL;
    m_szCopyDir = NULL;

    m_pContext = NULL;
    m_iHashAlgorithm = 0;
    m_dwBindFlags = 0;
    m_MainFound = false;
    m_FusionInitialized = false;
    m_FusionCache = false;
#ifndef UNDER_CE
    m_pFusionName = NULL;
    m_pFusionCache = NULL;
#endif
}


ManifestWriter::~ManifestWriter()
{
    if (m_gen) {
        if (m_ceeFile)
            m_gen->DestroyCeeFile(&m_ceeFile);
        
        DestroyICeeFileGen(&m_gen);
        delete m_gen;
    }

    if (m_wszAssemblyName)
        delete[] m_wszAssemblyName;

    if (m_wszName)
        delete[] m_wszName;

    if (m_szVersion)
        delete[] m_szVersion;

    if (m_pContext) {
        if (m_pContext->szLocale)
            delete [] m_pContext->szLocale;
        if(m_pContext->rProcessor) 
            delete [] m_pContext->rProcessor;
        if(m_pContext->rOS) 
            delete [] m_pContext->rOS;
        delete m_pContext;
    }

    if (m_szAFilePath)
        delete[] m_szAFilePath;

    if (m_szCopyDir)
        delete[] m_szCopyDir;

#ifndef UNDER_CE
    if (m_pFusionCache)
        m_pFusionCache->Release();

    if (m_pFusionName)
        m_pFusionName->Release();
#endif

    if (m_pAsmEmit)
        m_pAsmEmit->Release();

    if (m_pEmit)
        m_pEmit->Release();
}


HRESULT ManifestWriter::Init()
{
    HRESULT hr = g_pDispenser->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit, (IUnknown **) &m_pEmit);
    if FAILED(hr)
    {
        PrintError("Failed to DefineScope for IID_IMetaDataEmit");
        return hr;
    }

    hr = m_pEmit->QueryInterface(IID_IMetaDataAssemblyEmit, (void **)&m_pAsmEmit);
    if FAILED(hr)
        PrintError("Failed to QI for IID_IMetaDataAssemblyEmit");

    return hr;
}


HRESULT ManifestWriter::SetLocale(char *szLocale)
{
    _ASSERTE(m_szLocale);
    m_szLocale = szLocale;

    return S_OK;
}

HRESULT ManifestWriter::SetPlatform(char *szPlatform)
{
    if (!m_szPlatform)
        m_szPlatform = szPlatform;

    return S_OK;
}


HRESULT ManifestWriter::SetVersion(char *szVersion)
{
    m_szVersion = new char[strlen(szVersion) + 1];
    if (!m_szVersion)
        return PrintOutOfMemory();

    strcpy(m_szVersion, szVersion); 
    return S_OK;
}


HRESULT ManifestWriter::GetVersionFromResource(char *szFileName)
{
    DWORD        dwHandle;
    char         *szBuffer;
    unsigned int iLen;
    BYTE         *pVI;
    char         szQuery[37];
    HRESULT      hr = S_OK;

    iLen = GetFileVersionInfoSizeA(szFileName, &dwHandle);
    if (iLen < 1)
        return S_OK;

    pVI = new BYTE[iLen];
    if (!pVI)
        return PrintOutOfMemory();

    if (!GetFileVersionInfo(szFileName, 0, iLen, (void*) pVI))
        goto exit;

    if (!VerQueryValue((void*) pVI,
                       "\\VarFileInfo\\Translation",
                       (void **) &szBuffer,
                       &iLen))
        goto exit;

    sprintf(szQuery, "\\StringFileInfo\\%.2x%.2x%.2x%.2x\\FileVersion",
            (0xFF & szBuffer[1]), (0xFF & szBuffer[0]),
            (0xFF & szBuffer[3]), (0xFF & szBuffer[2]));
    
    if (!VerQueryValue((void*) pVI,
                       szQuery,
                       (void **) &szBuffer,
                       &iLen))
        goto exit;
    
    m_szVersion = new char[iLen+1];
    if (!m_szVersion) {
        hr = PrintOutOfMemory();
        goto exit;
    }
    strncpy(m_szVersion, szBuffer, iLen+1);

    if (g_verbose)
        printf("* Version set as %s\n", m_szVersion);

 exit:
    delete[] pVI;
    return hr;
}


/*
void ManifestWriter::FindVersion(DWORD *dwHi, DWORD *dwLo)
{
    _ASSERTE(dwHi);
    _ASSERTE(dwLo);
    *dwHi = 0;
    *dwLo = 0;
    if(!m_szVersion) return;

    DWORD dwDot = 0;
    DWORD dwStart = 0;
    DWORD iLength = strlen(m_szVersion);
    DWORD dwOffset  = 3;
    DWORD dwValue;

    while(dwDot < iLength) {
        for(;dwDot < iLength && m_szVersion[dwDot] != '.'; dwDot++);
        if(dwDot < iLength) {
            m_szVersion[dwDot] = '\0';
            dwValue = (DWORD) atoi(m_szVersion + dwStart);
            m_szVersion[dwDot] = '_';
            dwDot++;
        }
        else
            dwValue = (DWORD) atoi(m_szVersion + dwStart);

        dwStart = dwDot;

        if(dwOffset > 1) {
            *dwHi |= dwValue << (dwOffset - 2) * 16;
        }
        else {
            *dwLo |= dwValue << (dwOffset * 16);
        }
        dwOffset--;
    }

    DWORD count = 1;
    if(*dwHi & 0xffff) count = 2;
    if(*dwLo >> 16) count = 3;
    if(*dwLo & 0xffff) count = 4;

    for(dwDot = 0; dwDot < iLength && count; dwDot++) {
        if(m_szVersion[dwDot] == '_') {
            if(--count == 0) 
                m_szVersion[dwDot] = '\0';
        }
    }                                       
}
*/


HRESULT ManifestWriter::SetAssemblyFileName(char *szCache, char *szAsmName,
                                            char *szFileName, bool NeedCopyDir)
{
    int iCacheLen;
    int iNameLen;

    // Don't put exe's in the fusion cache (for now)
    if ((!szCache) && (!m_MainFound))
        m_FusionCache = true;

    if(szAsmName == NULL) {
        szAsmName = strrchr(szFileName, '\\');
        if (szAsmName)
            szAsmName++;
        else
            szAsmName = szFileName;
    }

    // Allow names that look like directories
    char* szFile;
    if(szFileName == NULL)
        szFile = szAsmName;
    else 
        szFile = szFileName;

    char* ptr = strrchr(szFile, '/');
    if(ptr == NULL)
        ptr = strrchr(szFile, '\\');

    if(ptr) {
        ptr++;
        if(*ptr == NULL)
            return E_FAIL;

        DWORD lgth = strlen(ptr);
        m_wszAssemblyName = new wchar_t[lgth+10];
        if (!m_wszAssemblyName)
            return PrintOutOfMemory();
        mbstowcs(m_wszAssemblyName, ptr, lgth+10);
    }
    else {
        DWORD lgth = strlen(szFile);
        m_wszAssemblyName = new wchar_t[lgth+10];
        if (!m_wszAssemblyName)
            return PrintOutOfMemory();
        mbstowcs(m_wszAssemblyName, szFile, lgth+10);
    }

    DWORD lgth = strlen(szAsmName);
    m_wszName = new wchar_t[lgth+1];
    mbstowcs(m_wszName, szAsmName, lgth+1);
    if (!m_wszName)
        return PrintOutOfMemory();

    if(szCache && strcmp(szCache, ".") == 0)
        szCache = NULL;

    if (NeedCopyDir || szCache) {
        m_szCopyDir = new char[MAX_PATH];
        if (!m_szCopyDir)
            return PrintOutOfMemory();
    
        if (szCache) {
            iCacheLen = strlen(szCache);
            if (iCacheLen + 7 > MAX_PATH) // 7 = \ + \ + \0 + .mod
                goto toolong;

            strcpy(m_szCopyDir, szCache);
            m_szCopyDir[iCacheLen] = '\\';
        }
        else
            iCacheLen = -1;

        if (NeedCopyDir) {
            if (m_szPlatform) {
                int iTemp = strlen(m_szPlatform);
                if (iCacheLen + iTemp + 4 > MAX_PATH) // 4 = \ + \ + \0 + 1
                    goto toolong;

                strcpy(&m_szCopyDir[iCacheLen + 1], m_szPlatform);
                if (MakeDir(m_szCopyDir)) 
                    goto mkdirfailed;
                iCacheLen += iTemp + 1;
                m_szCopyDir[iCacheLen] = '\\';
            }
            _ASSERTE(m_szLocale);
            if (*m_szLocale) {
                int iTemp = strlen(m_szLocale);
                if (iCacheLen + iTemp + 4 > MAX_PATH) // 4 = \ + \ + \0 + 1
                    goto toolong;

                strcpy(&m_szCopyDir[iCacheLen + 1], m_szLocale);
                if (MakeDir(m_szCopyDir)) 
                    goto mkdirfailed;
                iCacheLen += iTemp + 1;
                m_szCopyDir[iCacheLen] = '\\';
            }

            
            int iLen = strlen(szAsmName);
            if (iCacheLen + iLen + 7 > MAX_PATH)  // 7 = \ + \0 + .mod + 1
                goto toolong;

            strcpy(&m_szCopyDir[iCacheLen + 1], szAsmName);
            for(iNameLen = iLen-1;
                (iNameLen >= 0) && (szAsmName[iNameLen] != '.');
                iNameLen--);
            
            if (iNameLen == -1)
                iCacheLen += iLen;
            else
                iCacheLen += iNameLen;
            
            if(m_szVersion) {
                int iTemp = strlen(m_szVersion);
                if (iCacheLen + iTemp + 7 > MAX_PATH) // 7 = \ + \0 + .mod + 1
                    goto toolong;

                strcpy(&m_szCopyDir[iCacheLen+1], m_szVersion);
                iCacheLen += iTemp;
            }
        
            m_szCopyDir[iCacheLen+1] = '\0';
            if (MakeDir(m_szCopyDir))
                goto mkdirfailed;
        }
        else
            m_szCopyDir[iCacheLen+1] = '\0';

        strcat(m_szCopyDir, "\\");
    }

    return S_OK;

 mkdirfailed:
    PrintError("Can't create directory %s", m_szCopyDir);
    return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);

 toolong:
    PrintError("The directory path is too long and cannot be created");
    return HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
}


void ManifestWriter::AddExtensionToAssemblyName()
{
    int iLen = wcslen(m_wszAssemblyName);
    WCHAR* isuffix = wcsrchr(m_wszAssemblyName, L'.');

    if(isuffix == NULL) {
        if (m_MainFound)
            wcscpy(&m_wszAssemblyName[iLen], L".exe");
        else
            wcscpy(&m_wszAssemblyName[iLen], L".dll");
    }
}


// If this dir doesn't already exist, makes it
BOOL ManifestWriter::MakeDir(LPSTR szPath)
{
    DWORD dwAttrib = GetFileAttributesA(szPath);

    if ((dwAttrib == -1) || !((dwAttrib & FILE_ATTRIBUTE_DIRECTORY)))
        return _mkdir(szPath);

    return false;
} 


HRESULT ManifestWriter::CopyFile(char *szFilePath, char *szFileName,
                                 bool AFile, bool copy, bool move, bool module)
{
    if ((AFile) && (!copy)) {
        m_szAFilePath = new char[MAX_PATH];
        if (!m_szAFilePath)
            return PrintOutOfMemory();
        strcpy(m_szAFilePath, szFilePath);
    }
    else {
        char szPath[MAX_PATH];
        int iLen;

        if (m_szCopyDir) {
            iLen = strlen(m_szCopyDir);
            strcpy(szPath, m_szCopyDir);
        }
        else
            iLen = 0;

        strcpy(&szPath[iLen], szFileName);

        /*
        if (module && !AFile) {
            char *szDot = strrchr(&szPath[iLen], '.');
            if (szDot)
                strcpy(szDot+1, "mod");
            else
                strcat(szPath, ".mod");
        }
        */

        if (move && !AFile) {
            
            if (!MoveFileA(szFilePath, szPath)) {
                char szDest[MAX_PATH];
                char szSource[MAX_PATH];
                
                // Don't allow multiple copies, but don't delete the only copy.
                if ((GetFullPathNameA(szFilePath, MAX_PATH, szDest, NULL)) &&
                    (GetFullPathNameA(szPath, MAX_PATH, szSource, NULL)) &&
                    (_stricmp(szDest, szSource))) {
                    DeleteFileA(szPath);
                    MoveFileA(szFilePath, szPath);
                }
            }
        }
        else
            // Overwrites file if it already exists in szPath.
            CopyFileA(szFilePath, szPath, FALSE);
    }

    return S_OK;
}

/*
// CreateLink - uses the shell's IShellLink and IPersistFile interfaces 
//   to create and store a shortcut to the specified object. 
// Returns the result of calling the member functions of the interfaces. 
// lpszPathObj - address of a buffer containing the path of the object. 
// lpszPathLink - address of a buffer containing the path where the 
//   shell link is to be stored. 
// lpszDesc - address of a buffer containing the description of the 
//   shell link.  
HRESULT ManifestWriter::CreateLink(LPCWSTR wszAssembly, 
                                   LPCWSTR wszPathLink, 
                                   LPCSTR wszDesc) 
{ 
    HRESULT    hr;
    IShellLink *psl; 

    WCHAR* ptr = wcsrchr(m_wszFusionPath , L'\\');
    if(!ptr)
        ptr = m_wszFusionPath;
    else
        ptr += 1;
    
    wcscpy(ptr, wszAssembly);
 
    // Get a pointer to the IShellLink interface. 
    hr = CoCreateInstance(CLSID_ShellLink, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IShellLink, 
                          (void**) &psl); 
    if (SUCCEEDED(hr)) { 
        IPersistFile* ppf; 
 
        // Set the path to the shortcut target and add the 
        // description. 
        char lpszPathObj[MAX_PATH];
        wcstombs(lpszPathObj, m_szFusionPath, MAX_PATH);
        psl->SetPath(lpszPathObj); 
        psl->SetDescription(wszDesc); 
 
       // Query IShellLink for the IPersistFile interface for saving the 
       // shortcut in persistent storage. 
        hr = psl->QueryInterface(IID_IPersistFile, 
                                 (void**) &ppf); 
 
        if (SUCCEEDED(hr)) { 
            // Save the link by calling IPersistFile::Save. 
            hr = ppf->Save(wszPathLink, TRUE); 
            ppf->Release(); 
        } 
        psl->Release(); 
    } 
    return hr; 
} 
*/

HRESULT ManifestWriter::CopyFileToFusion(LPWSTR wszFileName, PBYTE pbOriginator, DWORD cbOriginator, LPSTR szInputFileName, DWORD dwFormat, bool module)
{
#ifdef UNDER_CE
    PrintError("Adding an assembly to the Fusion cache is not implemented for WinCE");
    return E_NOTIMPL;
#else
    HRESULT hr;

    if(!m_FusionCache) return S_OK;
 
    if(!m_FusionInitialized) {
        hr = InitializeFusion(pbOriginator, cbOriginator);
        if(FAILED(hr)) return hr;
    }

    WCHAR wszName[MAX_PATH+4];
    WCHAR *wszSlash;

    // Trim off path
    wszSlash = wcsrchr(wszFileName, '\\');
    if(wszSlash)
        wcscpy(wszName, wszSlash+1);
    else
        wcscpy(wszName, wszFileName);

    /*
    if (module) {
        WCHAR *wszDot = wcsrchr(wszName, '.');
        if (wszDot)
            wcscpy(wszDot+1, L"mod");
        else
            wcscat(wszName, L".mod");
    }
    */

    IStream* ifile;
    hr = m_pFusionCache->CreateStream(wszName,
                                      dwFormat,
                                      0,
                                      0,
                                      &ifile);
    if(FAILED(hr)) {
        PrintError("Unable to create stream for Fusion");
        return hr;
    }
 
    HANDLE hFile = CreateFileA(szInputFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        ifile->Release();
        PrintError("Unable to create file %s", szInputFileName);
        return HRESULT_FROM_WIN32(GetLastError());
    }
  
    byte buffer[4098];
    BOOL fResult = TRUE;
    DWORD bytesRead;
    DWORD bytesWritten;
    DWORD bytesToWrite;
    do {
        fResult = ReadFile(hFile,
                           buffer,
                           sizeof(buffer)/sizeof(buffer[0]),
                           &bytesRead,
                           NULL);
        if(bytesRead) {
            bytesToWrite = bytesRead;
            bytesWritten = 0;
            while(SUCCEEDED(hr) && bytesToWrite) {
                hr = ifile->Write(buffer, bytesRead, &bytesWritten);
                bytesToWrite -= bytesWritten;
            }
        }
    } while(fResult && bytesRead != 0 && SUCCEEDED(hr));
    
    CloseHandle(hFile);
    if(SUCCEEDED(hr)) {
        hr = ifile->Commit(0);
        if (FAILED(hr))
            PrintError("Failed to commit file to Fusion stream");
    }
    else
        PrintError("Failed to save file to Fusion stream");

    ifile->Release();
    return hr;
#endif
}


HRESULT ManifestWriter::CommitAllToFusion()
{
    HRESULT hr = m_pFusionCache->Commit(0);

    if (FAILED(hr)) 
        PrintError("Failed to commit files to Fusion cache");
    else if (g_verbose)
        printf("* Assembly was successfully added to Fusion cache\n");

    return hr;
}


HRESULT ManifestWriter::GetContext(int iNumPlatforms, DWORD *pdwPlatforms)
{
    m_pContext = new ASSEMBLYMETADATA();
    if (!m_pContext)
        return PrintOutOfMemory();

    ZeroMemory(m_pContext, sizeof(ASSEMBLYMETADATA));

        
    if (iNumPlatforms) {
        m_pContext->rOS = new OSINFO[iNumPlatforms];
        m_pContext->ulOS = iNumPlatforms;
        ZeroMemory(m_pContext->rOS, sizeof(OSINFO)*iNumPlatforms);

        for (int i=0; i < iNumPlatforms; i++)
            m_pContext->rOS[i].dwOSPlatformId = pdwPlatforms[i];
    }

    m_pContext->cbLocale = strlen(m_szLocale) + 1;
    m_pContext->szLocale = new WCHAR[m_pContext->cbLocale];
    int bRet = WszMultiByteToWideChar(CP_UTF8, 0, m_szLocale, -1, m_pContext->szLocale,
                           m_pContext->cbLocale);
    _ASSERTE(bRet);

    FindVersion(m_szVersion,
                m_szVersion ? strlen(m_szVersion) : 0,
                &m_pContext->usMajorVersion,
                &m_pContext->usMinorVersion,
                &m_pContext->usRevisionNumber,
                &m_pContext->usBuildNumber);
    return S_OK;
}


HRESULT ManifestWriter::DetermineCodeBase()
{
    wcscpy(m_wszCodeBase, L"file://");

    if (m_szCopyDir) {
        DWORD dwLen = wcslen(m_wszAssemblyName) + 1;
        DWORD dwPathLen = WszGetCurrentDirectory(MAX_PATH-7, m_wszCodeBase+7);
        DWORD dwDirLen = strlen(m_szCopyDir);
        if (!dwPathLen || (dwPathLen + 8 + dwDirLen + dwLen > MAX_PATH))
            goto toolong;
            
        m_wszCodeBase[dwPathLen+7] = '\\';
        mbstowcs(&m_wszCodeBase[dwPathLen+8], m_szCopyDir, dwDirLen);
        wcscpy(&m_wszCodeBase[dwPathLen + 8 + dwDirLen], m_wszAssemblyName);
    }
    else if (m_wszZFilePath) {
        DWORD dwLen = wcslen(m_wszZFilePath);

        if (((dwLen > 1) && (m_wszZFilePath[0] == '\\') && (m_wszZFilePath[1] == '\\')) ||
            (wcschr(m_wszZFilePath, ':'))) {

            if (dwLen+7 >= MAX_PATH)
                goto toolong;
            wcscpy(m_wszCodeBase+7, m_wszZFilePath);
        }
        else {
            DWORD dwPathLen = WszGetCurrentDirectory(MAX_PATH-7, m_wszCodeBase+7);
            if (!dwPathLen || (dwPathLen + 8 + dwLen >= MAX_PATH))
                goto toolong;

            m_wszCodeBase[dwPathLen+7] = '\\';
            wcscpy(&m_wszCodeBase[dwPathLen+8], m_wszZFilePath);
        }

    }
    else {
        DWORD dwLen = wcslen(m_wszAssemblyName) + 1;
        DWORD dwPathLen = WszGetCurrentDirectory(MAX_PATH-7, m_wszCodeBase+7);
        if (!dwPathLen || (dwPathLen + 8 + dwLen > MAX_PATH))
            goto toolong;

        m_wszCodeBase[dwPathLen+7] = '\\';
        wcscpy(&m_wszCodeBase[dwPathLen+8], m_wszAssemblyName);
    }

    return S_OK;

 toolong:
    PrintError("Failed to determine codebase - path to manifest file exceeds maximum path length");
    return E_FAIL;
}


HRESULT ManifestWriter::InitializeFusion(PBYTE pbOriginator, DWORD cbOriginator)
{
#ifdef UNDER_CE
    PrintError("Adding an assembly to the Fusion cache is not implemented for WinCE");
    return E_NOTIMPL;
#else

    m_FusionInitialized = true;

    HRESULT hr = CreateAssemblyNameObject(&m_pFusionName, m_wszName, 0, NULL);
    if(FAILED(hr)) {
        PrintError("Failed to create fusion assembly name object");
        return hr;
    }

    if(cbOriginator) {
        hr = m_pFusionName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pbOriginator, cbOriginator);
        if (FAILED(hr))
            goto SetError;
    }
    else {
        PrintError("An originator must be set if the assembly is to be put in the Fusion cache");
        return E_FAIL;
    }

    if (FAILED(hr = DetermineCodeBase()))
        return hr;

    if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_REF_FLAGS, &m_dwBindFlags, sizeof(DWORD))))
        goto SetError;

    if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_MAJOR_VERSION, &m_pContext->usMajorVersion, sizeof(USHORT))))
        goto SetError;

    if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_MINOR_VERSION, &m_pContext->usMinorVersion, sizeof(USHORT))))
        goto SetError;

    if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_REVISION_NUMBER, &m_pContext->usRevisionNumber, sizeof(USHORT))))
        goto SetError;

    if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_BUILD_NUMBER, &m_pContext->usBuildNumber, sizeof(USHORT))))
        goto SetError;
    
    if (m_pContext->szLocale) {
        if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_CULTURE, m_pContext->szLocale, sizeof(WCHAR)*m_pContext->cbLocale)))
            goto SetError;
    }

    if (m_pContext->ulProcessor) {
        if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_PROCESSOR_ID_ARRAY, m_pContext->rProcessor, sizeof(DWORD)*m_pContext->ulProcessor)))
            goto SetError;
    }
    
    if (m_pContext->ulOS) {
        if (FAILED(hr = m_pFusionName->SetProperty(ASM_NAME_OSINFO_ARRAY, m_pContext->rOS, sizeof(OSINFO)*m_pContext->ulOS)))
            goto SetError;
    }

    hr = CreateAssemblyCacheItem(&m_pFusionCache,
                                 NULL,  // IAssemblyName
                                 m_wszCodeBase,
                                 &m_FileTime,
                                 INSTALLER_URT,
                                 0);    // reserved
    if(FAILED(hr))
        PrintError("Failed to create fusion assembly cache item");

    return hr;

 SetError:
    PrintError("Failed to set property for Fusion");
    return hr;

#endif
}


HRESULT ManifestWriter::CreateNewPE()
{
    HRESULT hr = CreateICeeFileGen(&m_gen);
    if FAILED(hr)
    {
        PrintError("Failed to create ICeeFileGen");
        return hr;
    }

    hr = m_gen->CreateCeeFile(&m_ceeFile);
    if FAILED(hr) {
        PrintError("Failed to create CeeFile");
        return hr;
    }

    // Default entry point is nil token
    m_gen->SetEntryPoint(m_ceeFile, mdTokenNil);

    return hr;
}


HRESULT ManifestWriter::GetFusionAssemblyPath()
{
    PrintError("Putting files in the Fusion cache with the -a option is no longer supported");
    return E_NOTIMPL;

#ifdef UNDER_CE
    PrintError("Adding an assembly to the Fusion cache is not implemented for WinCE");
    return E_NOTIMPL;
#else
//      LPMANIFEST pManifest;
//      DWORD      dwSize;
//      HRESULT    hr;

//      if(!m_FusionInitialized) {
//          hr = InitializeFusion();
//          if(FAILED(hr)) return hr;
//      }

//      hr = CommitAllToFusion();
//      if (FAILED(hr)) return hr;

//      hr = m_pFusionName->GetManifest(&pManifest);
//      if (FAILED(hr)) {
//          PrintError("Failed to get fusion manifest");
//          return hr;
//      }

//      hr = pManifest->GetAssemblyPath(&dwSize, m_wszFusionPath);
//      if (FAILED(hr)) {
//          PrintError("Failed to get assembly path");
//      }

//      pManifest->Release();
//      return hr;
#endif
}


HRESULT ManifestWriter::SaveMetaData(char **szMetaData, DWORD *dwMetaDataLen)
{
    IStream *pStream;

    m_pEmit->GetSaveSize(cssAccurate, dwMetaDataLen);
    if (!(*dwMetaDataLen)) {
        PrintError("No metadata to save");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *szMetaData = new char[*dwMetaDataLen];
    if (!(*szMetaData))
        return PrintOutOfMemory();

    HRESULT hr = CInMemoryStream::CreateStreamOnMemory(*szMetaData, *dwMetaDataLen, &pStream);
    if (FAILED(hr)) {
        PrintError("Unable to create stream on memory");
        delete[] *szMetaData;
        goto exit;
    }
        
    hr = m_pEmit->SaveToStream(pStream, 0);
    if (FAILED(hr)) {
        PrintError("Failed to save metadata to stream");
        delete[] *szMetaData;
    }

 exit:
    if (pStream)
        pStream->Release();

    return hr;
}


HRESULT ManifestWriter::UpdatePE(char *szMetaData, DWORD dwMetaDataLen, int iNumResources, ResourceModuleReader rgRMReaders[])
{
    if (m_FusionCache) {
        HRESULT hr = GetFusionAssemblyPath();
        if (FAILED(hr)) return hr;

        char szCachedFile[MAX_PATH];    
        wcstombs(szCachedFile, m_wszFusionPath, MAX_PATH);
        return SaveManifestInPE(szCachedFile, szMetaData, dwMetaDataLen, iNumResources, rgRMReaders);
    }
    else {
        if (m_szAFilePath)
            return SaveManifestInPE(m_szAFilePath, szMetaData,
                                    dwMetaDataLen, iNumResources, rgRMReaders);
        else {
            wcstombs(&m_szCopyDir[strlen(m_szCopyDir)], m_wszAssemblyName, MAX_CLASS_NAME);
            return SaveManifestInPE(m_szCopyDir, szMetaData,
                                    dwMetaDataLen, iNumResources, rgRMReaders);
        }
    }
}


HRESULT ManifestWriter::SaveManifestInPE(char *szCachedFile, char *szMetaData, DWORD dwMetaDataLen, int iNumResources, ResourceModuleReader rgRMReaders[])
{
    DWORD                 dwFileLen;
    DWORD                 dwAddLen;
    DWORD                 dwBytesRead;
    DWORD                 *pdwSize;
    HANDLE                hMapFile;
    IMAGE_COR20_HEADER    *pICH;
    IMAGE_NT_HEADERS      *pNT;
    PBYTE                 pbMapAddress = NULL;
    PBYTE                 pbFileEnd;
    HRESULT               hr = S_OK;
    
    HANDLE hFile = CreateFileA(szCachedFile,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);
 
    if (hFile == INVALID_HANDLE_VALUE) {
        PrintError("Unable to open file %s", szCachedFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }


    dwAddLen = dwMetaDataLen + sizeof(DWORD);
    for (int i=0; i < iNumResources; i++) {
        if (!rgRMReaders[i].m_pbHash)
            dwAddLen += rgRMReaders[i].m_dwFileSize + sizeof(DWORD);
    }

    // Overwrite the previous manifest
    if (m_dwManifestRVA)
        dwFileLen = m_dwManifestRVA;
    else
        dwFileLen = GetFileSize(hFile, 0);

    hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READWRITE, 0, dwFileLen + dwAddLen, NULL);
    CloseHandle(hFile);

    if ((dwFileLen == 0xFFFFFFFF) || (!hMapFile)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        PrintError("Unable to create file mapping");
        goto exit;
    }

    pbMapAddress = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_WRITE, 0, 0, 0);
    CloseHandle(hMapFile);
    
    if ((!pbMapAddress) || 
        (!(pNT = PEHeaders::FindNTHeader(pbMapAddress))) ||
        (!(pICH = PEHeaders::getCOMHeader((HMODULE) pbMapAddress, pNT))))
    {
        hr = E_FAIL;
        PrintError("Incompatible header - can't add manifest");
        goto exit;
    }

    // This code path would invalidate a checksum, if set.
    _ASSERTE(!pNT->OptionalHeader.CheckSum);

     //@todo: this is overloading the Resources directory, delete this when compilers upgrade
    pICH->Resources.Size = dwAddLen;
    pICH->Resources.VirtualAddress = dwFileLen;

    pbFileEnd = pbMapAddress+dwFileLen;
    pdwSize = (DWORD *) pbFileEnd;
    *pdwSize = dwMetaDataLen;

    pbFileEnd += sizeof(DWORD);
    memcpy(pbFileEnd, szMetaData, dwMetaDataLen);
    pbFileEnd += dwMetaDataLen;

    for (i=0; i < iNumResources; i++) {
        if (!rgRMReaders[i].m_pbHash) {
            pdwSize = (DWORD *) pbFileEnd;
            *pdwSize = rgRMReaders[i].m_dwFileSize;

            ReadFile(rgRMReaders[i].m_hFile,
                     pbFileEnd+sizeof(DWORD),
                     rgRMReaders[i].m_dwFileSize, &dwBytesRead, 0);
            pbFileEnd += rgRMReaders[i].m_dwFileSize + sizeof(DWORD);
        }
    }

    if (!FlushViewOfFile(pbMapAddress, dwAddLen+dwFileLen)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        PrintError("Unable to flush view of file");
        goto exit;
    }

    if (g_verbose)
        printf("* Manifest successfully added to file %s\n", szCachedFile);

 exit:
    if (pbMapAddress)
        UnmapViewOfFile(pbMapAddress);
    return hr;
}


void ManifestWriter::CheckForEntryPoint(mdToken mdEntryPoint)
{
    if ((mdEntryPoint != mdMethodDefNil) &&
        (mdEntryPoint != mdFileNil))
    {
        m_MainFound = true;

        // Don't put exe's in the fusion cache (for now)
        m_FusionCache = false;
    }
}


void ManifestWriter::SetEntryPoint(LPSTR szFileName)
{
    if (m_gen) {
        m_gen->SetEntryPoint(m_ceeFile, m_mdFile);
        if (g_verbose)
            printf("* Entry point set from file %s\n", szFileName);
    }   
}


HRESULT ManifestWriter::WriteManifestInfo(ManifestModuleReader *mmr, 
    mdAssemblyRef *mdAssemblyRef)
{
    BYTE   *pbToken = NULL;
    DWORD   cbToken = 0;

    // If an originator (public key) is provided, compress it to save space.
    if (mmr->m_dwOriginator) {
        if (!StrongNameTokenFromPublicKey((BYTE*)mmr->m_pbOriginator,
                                          mmr->m_dwOriginator,
                                          &pbToken,
                                          &cbToken)) {
            PrintError("Unable to compress originator for assembly ref");
            return StrongNameErrorInfo();
        }
    }

    HRESULT hr = m_pAsmEmit->DefineAssemblyRef(
        pbToken,
        cbToken,
        mmr->m_wszAsmName,       // name
        &(mmr->m_AssemblyIdentity),
        mmr->m_pbHash,
        mmr->m_dwHash,
        mmr->m_dwFlags,
        mdAssemblyRef
    );

    if (pbToken)
        StrongNameFreeBuffer(pbToken);

    if (FAILED(hr))
        PrintError("Unable to define assembly ref");

    return hr;
}

HRESULT ManifestWriter::CopyAssemblyRefInfo(ModuleReader *mr)
{
    mdAssemblyRef mdAssemblyRef;

    HRESULT hr = mr->EnumAssemblyRefs();
    if (FAILED(hr))
        return hr;

    // The hash saved in the AR in this other file may not have been
    // generated using the same algorithm as this assembly uses.
    // @TODO: The saved token for the execution location applies to
    // the other file's scope, not this one.  Just saving nil for now.

    for (DWORD i = 0; i < mr->m_dwNumAssemblyRefs; i++) {
        hr = mr->GetAssemblyRefProps(i);
        if (FAILED(hr))
            return hr;

        HRESULT hr = m_pAsmEmit->DefineAssemblyRef(
            (BYTE*) mr->m_pbOriginator,
            mr->m_dwOriginator,
            mr->m_wszAsmRefName,
            &(mr->m_AssemblyIdentity),
            NULL, //mr->m_pbHash,
            0, //mr->m_dwHash,
            mr->m_dwFlags,
            &mdAssemblyRef
            );

        if (FAILED(hr)) {
            PrintError("Unable to define assembly ref");
            return hr;
        }
    }

    return hr;
}

void ManifestWriter::SaveResourcesInNewPE(int iNumResources, ResourceModuleReader rgRMReaders[])
{
    DWORD dwDataLen = 0;
        
    for (int i=0; i < iNumResources; i++) {
        if (!rgRMReaders[i].m_pbHash)
            dwDataLen += rgRMReaders[i].m_dwFileSize + sizeof(DWORD);
    }

    if (dwDataLen) {
        HCEESECTION RData;
        char        *buffer;
        DWORD       dwBytes;
        DWORD       *pdwSize;

        m_gen->GetRdataSection(m_ceeFile, &RData);
        
        m_gen->GetSectionBlock(RData, dwDataLen, 4, (void **) &buffer);

        for (i=0; i < iNumResources; i++) {
            pdwSize = (DWORD *) buffer;
            *pdwSize = rgRMReaders[i].m_dwFileSize;
            
            ReadFile(rgRMReaders[i].m_hFile,
                     buffer+sizeof(DWORD),
                     rgRMReaders[i].m_dwFileSize, &dwBytes, 0);
            buffer += rgRMReaders[i].m_dwFileSize + sizeof(DWORD);
        }

        m_gen->SetManifestEntry(m_ceeFile, dwDataLen, 0);
    }
}


HRESULT ManifestWriter::AllocateStrongNameSignatureInNewPE()
{
    HCEESECTION TData;
    DWORD       dwDataOffset;
    DWORD       dwDataLength;
    DWORD       dwDataRVA;
    VOID       *pvBuffer;

    // Determine size of signature blob.
    if (!StrongNameSignatureSize(g_pbOrig, g_cbOrig, &dwDataLength)) {
        PrintError("Unable to determine size of strong name signature");
        return StrongNameErrorInfo();
    }

    // Allocate space for the signature in the text section and update the COM+
    // header to point to the space.
    m_gen->GetIlSection(m_ceeFile, &TData);
    m_gen->GetSectionDataLen(TData, &dwDataOffset);
    m_gen->GetSectionBlock(TData, dwDataLength, 4, &pvBuffer);
    m_gen->GetMethodRVA(m_ceeFile, dwDataOffset, &dwDataRVA);
    m_gen->SetStrongNameEntry(m_ceeFile, dwDataLength, dwDataRVA);

    return S_OK;
}


HRESULT ManifestWriter::StrongNameSignNewPE()
{
    LPWSTR  wszOutputFile;
    HRESULT hr = S_OK;

    m_gen->GetOutputFileName(m_ceeFile, &wszOutputFile);

    // Update the output PE image with a strong name signature.
    if (!StrongNameSignatureGeneration(wszOutputFile, GetKeyContainerName(),
                                       NULL, NULL, NULL, NULL)) {
        hr = StrongNameErrorInfo();
        PrintError("Unable to generate strong name signature");
    }

    return hr;
}


HRESULT ManifestWriter::FinishNewPE(PBYTE pbOriginator, DWORD cbOriginator, BOOL fStrongName)
{
    GUID    guid;
    wchar_t wszPEFileName[MAX_PATH];
    HRESULT hr;
    static COR_SIGNATURE _SIG[] = INTEROP_GUID_SIG;
    mdTypeRef tr;
    mdMemberRef mr;
    WCHAR wzGuid[40];
    BYTE  rgCA[50];

    if ((fStrongName || g_pbOrig) &&
        (FAILED(hr = AllocateStrongNameSignatureInNewPE())))
        return hr;

    hr = m_pEmit->SetModuleProps(m_wszAssemblyName);
    if (FAILED(hr)) {
        PrintError("Unable to set module props");
        return hr;
    }
    
    hr = CoCreateGuid(&guid);
    if (FAILED(hr)) {
        PrintError("Unable to create guid");
        return hr;
    }

    hr = m_pEmit->DefineTypeRefByName(mdTypeRefNil, INTEROP_GUID_TYPE_W, &tr);
    if (FAILED(hr)) {
        PrintError("Unable to create TypeRef for guid custom attribute");
        return hr;
    }
    hr = m_pEmit->DefineMemberRef(tr, L".ctor", _SIG, sizeof(_SIG), &mr);
    if (FAILED(hr)) {
        PrintError("Unable to create MemberRef for guid custom attribute");
        return hr;
    }
    StringFromGUID2(guid, wzGuid, lengthof(wzGuid));
    memset(rgCA, 0, sizeof(rgCA));
    // Tag is 0x0001
    rgCA[0] = 1;
    // Length of GUID string is 36 characters.
    rgCA[2] = 0x24;
    // Convert 36 characters, skipping opening {, into 3rd byte of buffer.
    WszWideCharToMultiByte(CP_UTF8,0, wzGuid+1,36, reinterpret_cast<char*>(&rgCA[3]),36, 0,0);
    // 1 is module token.  41 is 2 byte prolog, 1 byte length, 36 byte string, 2 byte epilog.
    hr = m_pEmit->DefineCustomAttribute(1,mr,rgCA,41,0);
    if (FAILED(hr)) {
        PrintError("Unable to create guid custom attribute");
        return hr;
    }

    //    hr = m_gen->EmitMetaDataWithNullMapper(m_ceeFile, m_pEmit);
    hr = m_gen->EmitMetaDataEx(m_ceeFile, m_pEmit);    
    if (FAILED(hr)) {
        PrintError("Failed to write meta data to file");
        return hr;
    }

    if (m_szCopyDir) {
        mbstowcs(wszPEFileName, m_szCopyDir, MAX_PATH);
        wcscpy(&wszPEFileName[strlen(m_szCopyDir)], m_wszAssemblyName);
        hr = m_gen->SetOutputFileName(m_ceeFile, wszPEFileName);
    }
    else
        hr = m_gen->SetOutputFileName(m_ceeFile, m_wszAssemblyName);

    if (FAILED(hr)) {
        PrintError("Failed to set output file name");
        return hr;
    }

    hr = m_gen->GenerateCeeFile(m_ceeFile);
    if (FAILED(hr)) {
        PrintError("Failed to generate new file");
        return hr;
    }

    if (fStrongName && 
        (FAILED(hr = StrongNameSignNewPE())))
        return hr;

    if (m_FusionCache) {
        if(!m_FusionInitialized) {
            hr = InitializeFusion(pbOriginator, cbOriginator);
            if(FAILED(hr))
                return hr;
        }

        char szPEFileName[MAX_PATH];
        wcstombs(szPEFileName, m_szCopyDir ? wszPEFileName : m_wszAssemblyName, MAX_PATH);
        hr = CopyFileToFusion(m_wszAssemblyName, pbOriginator, cbOriginator, szPEFileName, 1, false);
        if (FAILED(hr))
            return hr;

        hr = CommitAllToFusion();
    }

    return hr;
}


HRESULT ManifestWriter::EmitManifest(PBYTE pbOriginator, DWORD cbOriginator)
{
    HRESULT hr = m_pAsmEmit->DefineAssembly(
        (void*) pbOriginator,
        cbOriginator,
        m_iHashAlgorithm,     // hash algorithm
        m_wszName,    // assembly name
        m_pContext,           // pMetaData
        m_dwBindFlags,
        &m_mdAssembly);

    if (FAILED(hr))
        PrintError("Unable to define assembly");

    return hr;
}


HRESULT ManifestWriter::EmitFile(ModuleReader *mr)
{
    int iLen = strlen(mr->m_szFinalPathName) + 1;

    wchar_t *wszModuleName = new wchar_t[iLen+4];
    mbstowcs(wszModuleName, mr->m_szFinalPathName, iLen);

    /*
    wchar_t *wszDot = wcsrchr(wszModuleName, '.');
    if (wszDot)
        wcscpy(wszDot+1, L"mod");
    else
        wcscat(wszModuleName, L".mod");
    */

    HRESULT hr = m_pAsmEmit->DefineFile(
        wszModuleName,
        mr->m_pbHash,
        mr->m_dwHash,
        ffContainsMetaData,    // non-resource file
        &m_mdFile
    );
    delete[] wszModuleName;

    if (FAILED(hr))
        PrintError("Unable to define file");

    return hr;
}


HRESULT ManifestWriter::EmitFile(ResourceModuleReader *rmr, mdFile *mdFile)
{
    wchar_t wszModuleName[MAX_PATH];
    mbstowcs(wszModuleName, rmr->m_szFinalPathName, MAX_PATH);

    HRESULT hr = m_pAsmEmit->DefineFile(
        wszModuleName,
        rmr->m_pbHash,
        rmr->m_dwHash,
        ffContainsNoMetaData,     // resource file
        mdFile
    );

    if (FAILED(hr))
        PrintError("Unable to define file");

    return hr;
}


HRESULT ManifestWriter::EmitComType(LPWSTR    wszClassName,
                                    mdToken   mdImpl,
                                    mdTypeDef mdClass,
                                    DWORD     dwAttrs,
                                    mdExportedType *pmdComType)
{
    HRESULT   hr = m_pAsmEmit->DefineExportedType(
        wszClassName,
        mdImpl,             // mdFile or mdExportedType
        mdClass,            // type def
        dwAttrs,
        pmdComType
    );

    if (FAILED(hr))
        PrintError("Unable to define com type");

    return hr;
}


HRESULT ManifestWriter::EmitComType(LPWSTR    wszClassName,
                                    mdToken   mdImpl,
                                    mdExportedType *pmdComType)
{
    HRESULT   hr = m_pAsmEmit->DefineExportedType(
        wszClassName,
        mdImpl,   // mdAssembly or mdExportedType
        mdTypeDefNil,
        0,        // flags
        pmdComType
    );

    if (FAILED(hr))
        PrintError("Unable to define com type");

    return hr;
}


HRESULT ManifestWriter::EmitResource(LPWSTR wszName, mdToken mdImpl,
                                     DWORD dwOffset)
{
    mdManifestResource mdResource;
    
    HRESULT            hr = m_pAsmEmit->DefineManifestResource(
        wszName,
        mdImpl,             // tkImplementation
        dwOffset,
        0,                  // dwResourceFlags
        &mdResource
    );

    if (FAILED(hr))
        PrintError("Unable to define manifest resource");

    return hr;  
}


HRESULT ManifestWriter::EmitRequestPermissions(char *szPermFile, bool SkipVerification)
{
    HRESULT     hr;
    char        *pFileData;
    DWORD       dwFileSize;
    char        *pReqdData = NULL;
    char        *pOptData = NULL;
    char        *pDenyData = NULL;
    DWORD       cbReqdData;
    DWORD       cbOptData;
    DWORD       cbDenyData;
    LPWSTR      wszReqdData;
    LPWSTR      wszOptData;
    LPWSTR      wszDenyData;

    if (szPermFile) {

        // Read security permissions file into memory.
        HANDLE hFile = CreateFileA(szPermFile,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            PrintError("Unable to open security permissions file");
            return HRESULT_FROM_WIN32(GetLastError());
        }

        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize == 0) {
            CloseHandle(hFile);
            PrintError("Security permissions file is empty");
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
        
        pFileData = (char*)_alloca(dwFileSize + 1);
        DWORD dwBytesRead;

        if (!ReadFile(hFile, pFileData, dwFileSize, &dwBytesRead, NULL)) {
            CloseHandle(hFile);
            PrintError("Unable to read security permissions file");
            return HRESULT_FROM_WIN32(GetLastError());
        }

        pFileData[dwFileSize] = '\0';

        CloseHandle(hFile);

    } else {

        // No input file supplied, we're going to fabricate a request for
        // SkipVerification permission. Since we're building an explicit minimum
        // permission request, we better add an explicit request for full
        // optional permissions, to retain the normal semantic.

        _ASSERTE(SkipVerification);

        pFileData = XML_PERMISSION_SET_HEAD
                        XML_PERMISSION_LEADER XML_SECURITY_PERM_CLASS "\">"
                            XML_SKIP_VERIFICATION_TAG
                        XML_PERMISSION_TAIL
                    XML_PERMISSION_SET_TAIL
                    XML_PERMISSION_SET_HEAD
                        XML_UNRESTRICTED_TAG
                    XML_PERMISSION_SET_TAIL;
        dwFileSize = strlen(pFileData);

    }

    // Permissions request files should consist of between one and three
    // permission sets (in XML format). The order of sets is fixed:
    //  o  The first (non-optional) set describes the required permissions.
    //  o  The second describes optional permissions.
    //  o  The third describes permissions that must not be granted.
    pReqdData = strstr(pFileData, XML_PERMISSION_SET_LEADER);
    if (pReqdData == NULL) {
        PrintError("Security permissions file should contain at least one permission set");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    pOptData = strstr(pReqdData + 1, XML_PERMISSION_SET_LEADER);
    if (pOptData)
        cbReqdData = pOptData - pReqdData;
    else
        cbReqdData = dwFileSize - (pReqdData - pFileData);

    if (pOptData) {
        pDenyData = strstr(pOptData + 1, XML_PERMISSION_SET_LEADER);
        if (pDenyData)
            cbOptData = pDenyData - pOptData;
        else
            cbOptData = dwFileSize - cbReqdData;
        cbDenyData = dwFileSize - cbReqdData - cbOptData;
    }

    // If Permissions were explicitly requested and SkipVerification has been
    // asked for by one or more modules in the assembly, we add a skip verify
    // permission request to the required permission request set.
    if (szPermFile && SkipVerification) {
        char    *pOldReqdData = pReqdData;
        DWORD   cbOldReqdData = cbReqdData;
        char    *pSecPerm;

        // Things become more complicated if a request for SecurityPermission
        // has already been made (since the XML parser doesn't do a union/merge
        // for us). There are three cases:
        //  1)  An explicit request for SkipVerification has been made, no
        //      further work required.
        //  2)  An explicit request for Unrestricted has been made, no further
        //      work required.
        //  3)  An explicit request for some other set of SecurityPermission
        //      sub-categories has been made. We need to insert the skip
        //      verification tag into the SecurityPermission request (as opposed
        //      to adding an entire SecurityPermission request).
        if ((pSecPerm = strstr(pOldReqdData, XML_SECURITY_PERM_CLASS)) &&
            ((pOptData == NULL) || (pSecPerm < pOptData))) {

            // Look for end of SecurityPermission definition, then buffer the
            // definition in order to bound our searches.
            char *pSecBuffer = NULL;
            DWORD cbSecBuffer;
            char *pSecPermEnd = strstr(pSecPerm, XML_PERMISSION_TAIL);
            if (pSecPermEnd == NULL) {
                hr = E_FAIL;
                PrintError("Missing %s in permission request", XML_PERMISSION_TAIL);
                goto exit;
            }
            cbSecBuffer = pSecPermEnd - pSecPerm;
            pSecBuffer = (char*)_alloca(cbSecBuffer + 1);
            memcpy(pSecBuffer, pSecPerm, cbSecBuffer);
            pSecBuffer[cbSecBuffer] = '\0';

            if ((strstr(pSecBuffer, XML_SKIP_VERIFICATION_TAG) == NULL) &&
                (strstr(pSecBuffer, XML_UNRESTRICTED_TAG) == NULL)) {

                // SecurityPermission doesn't already ask for SkipVerification,
                // so insert the tag.

                cbReqdData += strlen(XML_SKIP_VERIFICATION_TAG);
                pReqdData = (char*)_alloca(cbReqdData + 1);
                memcpy(pReqdData, pOldReqdData, cbOldReqdData);
                pReqdData[cbReqdData] = '\0';

                // Move all text from the </Permission> of the
                // SecurityPermission definition up to accomodate the extra tag.
                DWORD dwEndTagOffset = pSecPermEnd - pOldReqdData;
                memcpy(pReqdData + dwEndTagOffset + strlen(XML_SKIP_VERIFICATION_TAG),
                       pSecPermEnd,
                       cbOldReqdData - dwEndTagOffset);

                // Copy the new tag into place.
                memcpy(pReqdData + dwEndTagOffset,
                       XML_SKIP_VERIFICATION_TAG,
                       strlen(XML_SKIP_VERIFICATION_TAG));
            }

        } else {

            // There was no explicit SecurityPermission request. So we can just
            // add one with a SkipVerification tag right at the end of the
            // permission set (where it's nice and easy to insert).

            char *pInsertText =     XML_PERMISSION_LEADER XML_SECURITY_PERM_CLASS "\">"
                                        XML_SKIP_VERIFICATION_TAG
                                    XML_PERMISSION_TAIL
                                XML_PERMISSION_SET_TAIL;
            cbReqdData += strlen(pInsertText) - strlen(XML_PERMISSION_SET_TAIL);
            pReqdData = (char*)_alloca(cbReqdData + 1);
            memcpy(pReqdData, pOldReqdData, cbOldReqdData);
            pReqdData[cbReqdData] = '\0';

            char *pInsert = strstr(pReqdData, XML_PERMISSION_SET_TAIL);
            if (pInsert == NULL) {
                hr = E_FAIL;
                PrintError("Missing %s in permission request", XML_PERMISSION_SET_TAIL);
                goto exit;
            }

            strcpy(pInsert, pInsertText);

        }

    }

    // DefinePermissionSet requires wide char XML.
    // Note that this parameter to DefinePermissionSet does not need to be null terminated,
    // but it's easier to debug if it is null terminated.
    wszReqdData = (LPWSTR)_alloca((1+cbReqdData) * sizeof(WCHAR));
    mbstowcs(wszReqdData, pReqdData, cbReqdData + 1);

    if (pOptData) {
        wszOptData = (LPWSTR)_alloca(cbOptData * sizeof(WCHAR));
        mbstowcs(wszOptData, pOptData, cbOptData);
    }

    if (pDenyData) {
        wszDenyData = (LPWSTR)_alloca(cbDenyData * sizeof(WCHAR));
        mbstowcs(wszDenyData, pDenyData, cbDenyData);
    }

    // Persist XML permission requests into the metadata.
    hr = m_pEmit->DefinePermissionSet(m_mdAssembly,
                                      dclRequestMinimum,
                                      (void const *)wszReqdData,
                                      cbReqdData * sizeof(WCHAR),
                                      NULL);
    if (FAILED(hr)) {
        PrintError("Unable to emit minimum permission request");
        goto exit;
    }

    if (pOptData) {
        hr = m_pEmit->DefinePermissionSet(m_mdAssembly,
                                          dclRequestOptional,
                                          (void const *)wszOptData,
                                          cbOptData * sizeof(WCHAR),
                                          NULL);
        if (FAILED(hr)) {
            PrintError("Unable to emit optional permission request");
            goto exit;
        }
    }

    if (pDenyData) {
        hr = m_pEmit->DefinePermissionSet(m_mdAssembly,
                                          dclRequestRefuse,
                                          (void const *)wszDenyData,
                                          cbDenyData * sizeof(WCHAR),
                                          NULL);
        if (FAILED(hr)) {
            PrintError("Unable to emit refuse permission request");
            goto exit;
        }
    }

 exit:
    return hr;
}


/* static */
PIMAGE_SECTION_HEADER PEHeaders::Cor_RtlImageRvaToSection(IN PIMAGE_NT_HEADERS NtHeaders,
                                                          IN PVOID Base,
                                                          IN ULONG Rva)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;
        
        ++NtSection;
    }

    return NULL;
}


/* static */
PVOID PEHeaders::Cor_RtlImageRvaToVa(IN PIMAGE_NT_HEADERS NtHeaders,
                                     IN PVOID Base,
                                     IN ULONG Rva)
{
    PIMAGE_SECTION_HEADER NtSection = Cor_RtlImageRvaToSection(NtHeaders,
                                                               Base,
                                                               Rva);

    if (NtSection != NULL) {
        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData);
    }
    else
        return NULL;
}


/* static */
IMAGE_COR20_HEADER * PEHeaders::getCOMHeader(HMODULE hMod, IMAGE_NT_HEADERS *pNT) 
{
    PIMAGE_SECTION_HEADER pSectionHeader;
    
    // Get the image header from the image, then get the directory location
    // of the COM+ header which may or may not be filled out.
    pSectionHeader = (PIMAGE_SECTION_HEADER) Cor_RtlImageRvaToVa(pNT, hMod, 
                                                                 pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);
    
    return (IMAGE_COR20_HEADER *) pSectionHeader;
}


/* static */
IMAGE_NT_HEADERS * PEHeaders::FindNTHeader(PBYTE pbMapAddress)
{
    IMAGE_DOS_HEADER   *pDosHeader;
    IMAGE_NT_HEADERS   *pNT;

    pDosHeader = (IMAGE_DOS_HEADER *) pbMapAddress;

    if ((pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) &&
        (pDosHeader->e_lfanew != 0))
    {
        pNT = (IMAGE_NT_HEADERS*) (pDosHeader->e_lfanew + (DWORD) pDosHeader);

        if ((pNT->Signature != IMAGE_NT_SIGNATURE) ||
            (pNT->FileHeader.SizeOfOptionalHeader != 
             IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
            (pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
            return NULL;
    }
    else
        return NULL;

    return pNT;
}


ULONG STDMETHODCALLTYPE CInMemoryStream::Release()
{
    ULONG cRef = InterlockedDecrement((long *) &m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::QueryInterface(REFIID riid, PVOID *ppOut)
{
    *ppOut = this;
    AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Read(
                               void        *pv,
                               ULONG       cb,
                               ULONG       *pcbRead)
{
    ULONG cbRead = min(cb, m_cbSize - m_cbCurrent);

    if (cbRead == 0)
        return (S_FALSE);
    memcpy(pv, (void *) ((long) m_pMem + m_cbCurrent), cbRead);

    if (pcbRead)
        *pcbRead = cbRead;
    m_cbCurrent += cbRead;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Write(
                                const void  *pv,
                                ULONG       cb,
                                ULONG       *pcbWritten)
{
    if (m_cbCurrent + cb > m_cbSize)
        return (OutOfMemory());

    memcpy((BYTE *) m_pMem + m_cbCurrent, pv, cb);
    m_cbCurrent += cb;
    if (pcbWritten) *pcbWritten = cb;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Seek(LARGE_INTEGER dlibMove,
                               DWORD       dwOrigin,
                               ULARGE_INTEGER *plibNewPosition)
{
    _ASSERTE(dwOrigin == STREAM_SEEK_SET);
    _ASSERTE(dlibMove.QuadPart <= ULONG_MAX);
    m_cbCurrent = (ULONG) dlibMove.QuadPart;
    //HACK HACK HACK
    //This allows dynamic IL to pass an assert in TiggerStorage::WriteSignature.
    plibNewPosition->LowPart=0;
    _ASSERTE(m_cbCurrent < m_cbSize);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::CopyTo(
                                 IStream     *pstm,
                                 ULARGE_INTEGER cb,
                                 ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr;
    // We don't handle pcbRead or pcbWritten.
    _ASSERTE(pcbRead == 0);
    _ASSERTE(pcbWritten == 0);

    _ASSERTE(cb.QuadPart <= ULONG_MAX);
    ULONG       cbTotal = min(static_cast<ULONG>(cb.QuadPart), m_cbSize - m_cbCurrent);
    ULONG       cbRead=min(1024, cbTotal);
    CQuickBytes rBuf;
    void        *pBuf = rBuf.Alloc(cbRead);
    if (pBuf == 0)
        return OutOfMemory();

    while (cbTotal)
        {
            if (cbRead > cbTotal)
                cbRead = cbTotal;
            if (FAILED(hr=Read(pBuf, cbRead, 0)))
                return (hr);
            if (FAILED(hr=pstm->Write(pBuf, cbRead, 0)))
                return (hr);
            cbTotal -= cbRead;
        }

    // Adjust seek pointer to the end.
    m_cbCurrent = m_cbSize;

    return S_OK;
}

HRESULT CInMemoryStream::CreateStreamOnMemory(           // Return code.
                                    void        *pMem,                  // Memory to create stream on.
                                    ULONG       cbSize,                 // Size of data.
                                    IStream     **ppIStream, BOOL fDeleteMemoryOnRelease)            // Return stream object here.
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return OutOfMemory();
    pIStream->InitNew(pMem, cbSize);
    if (fDeleteMemoryOnRelease)
    {
        // make sure this memory is allocated using new
        pIStream->m_dataCopy = (BYTE *)pMem;
    }
    *ppIStream = pIStream;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "LM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Manifest Linker\0"
#define VER_ORIGFILENAME_STR    "lm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\metainfo\mdinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mdinfo.cpp
//
//*****************************************************************************
#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <crtdbg.h>
#include <assert.h>

#define INIT_GUID
#include <initguid.h>

#include <corpriv.h>
#include <cor.h>
#include "assert.h"
#include "CorError.h"
#include <WinWrap.h>
#include <PrettyPrintSig.h>

#include <cahlpr.h>

#include "mdinfo.h"

#define ENUM_BUFFER_SIZE 10
#define TAB_SIZE 8

#define NumItems(s) (sizeof(s) / sizeof(s[0]))

#define ISFLAG(p,x) if (Is##p##x(flags)) strcat(sFlags, "["#x "] ");

extern HRESULT  _FillVariant(
    BYTE        bCPlusTypeFlag, 
    void const  *pValue,
    VARIANT     *pvar); 

// Validator declarations.
extern DWORD g_ValModuleType;
#include <ivehandler.h>
#include <ivehandler_i.c>

// Tables for mapping element type to text
char *g_szMapElementType[] = 
{
    "End",          // 0x0
    "Void",         // 0x1
    "Boolean",
    "Char", 
    "I1",
    "UI1",
    "I2",           // 0x6
    "UI2",
    "I4",
    "UI4",
    "I8",
    "UI8",
    "R4",
    "R8",
    "String",
    "Ptr",          // 0xf
    "ByRef",        // 0x10
    "ValueClass",
    "Class",
    "CopyCtor",
    "MDArray",      // 0x14
    "GENArray",
    "TypedByRef",
    "VALUEARRAY",
    "I",
    "U",
    "R",            // 0x1a
    "FNPTR",
    "Object",
    "SZArray",
    "GENERICArray",
    "CMOD_REQD",
    "CMOD_OPT",
    "INTERNAL",
};

char *g_szMapUndecorateType[] = 
{
    "",                 // 0x0
    "void",
    "boolean",
    "Char", 
    "byte",
    "unsigned byte",
    "short",
    "unsigned short",
    "int",
    "unsigned int",
    "long",
    "unsigned long",
    "float",
    "double",
    "String",
    "*",                // 0xf
    "ByRef",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Function Pointer",
    "Object",
    "",
    "",
    "CMOD_REQD",
    "CMOD_OPT",
    "INTERNAL",
};

char *g_strCalling[] = 
{   
    "[DEFAULT]",
    "[C]",
    "[STDCALL]",
    "[THISCALL]",
    "[FASTCALL]",
    "[VARARG]",
    "[FIELD]",
    "[LOCALSIG]",
    "[PROPERTY]",
    "[UNMANAGED]",
};

char *g_szNativeType[] =
{
    "NATIVE_TYPE_END(DEPRECATED!)",  //         = 0x0,    //DEPRECATED
    "NATIVE_TYPE_VOID(DEPRECATED!)",  //        = 0x1,    //DEPRECATED
    "NATIVE_TYPE_BOOLEAN",  //     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    "NATIVE_TYPE_I1",  //          = 0x3,  
    "NATIVE_TYPE_U1",  //          = 0x4,  
    "NATIVE_TYPE_I2",  //          = 0x5,  
    "NATIVE_TYPE_U2",  //          = 0x6,  
    "NATIVE_TYPE_I4",  //          = 0x7,  
    "NATIVE_TYPE_U4",  //          = 0x8,  
    "NATIVE_TYPE_I8",  //          = 0x9,  
    "NATIVE_TYPE_U8",  //          = 0xa,  
    "NATIVE_TYPE_R4",  //          = 0xb,  
    "NATIVE_TYPE_R8",  //          = 0xc,  
    "NATIVE_TYPE_SYSCHAR(DEPRECATED!)",  //     = 0xd,    //DEPRECATED 
    "NATIVE_TYPE_VARIANT(DEPRECATED!)",  //     = 0xe,    //DEPRECATED
    "NATIVE_TYPE_CURRENCY",				  //    = 0xf,
    "NATIVE_TYPE_PTR(DEPRECATED!)",  //         = 0x10,   //DEPRECATED  

    "NATIVE_TYPE_DECIMAL(DEPRECATED!)",  //     = 0x11,   //DEPRECATED
    "NATIVE_TYPE_DATE(DEPRECATED!)",  //        = 0x12,   //DEPRECATED
    "NATIVE_TYPE_BSTR",  //        = 0x13, 
    "NATIVE_TYPE_LPSTR",  //       = 0x14, 
    "NATIVE_TYPE_LPWSTR",  //      = 0x15, 
    "NATIVE_TYPE_LPTSTR",  //      = 0x16, 
    "NATIVE_TYPE_FIXEDSYSSTRING",  //  = 0x17, 
    "NATIVE_TYPE_OBJECTREF(DEPRECATED!)",  //   = 0x18,   //DEPRECATED
    "NATIVE_TYPE_IUNKNOWN",  //    = 0x19,
    "NATIVE_TYPE_IDISPATCH",  //   = 0x1a,
    "NATIVE_TYPE_STRUCT",  //      = 0x1b, 
    "NATIVE_TYPE_INTF",  //        = 0x1c, 
    "NATIVE_TYPE_SAFEARRAY",  //   = 0x1d, 
    "NATIVE_TYPE_FIXEDARRAY",  //  = 0x1e, 
    "NATIVE_TYPE_INT",  //         = 0x1f, 
    "NATIVE_TYPE_UINT",  //        = 0x20, 

    //@todo: sync up the spec   
    "NATIVE_TYPE_NESTEDSTRUCT(DEPRECATED!)",  //  = 0x21, //DEPRECATED (use "NATIVE_TYPE_STRUCT)   

    "NATIVE_TYPE_BYVALSTR",  //    = 0x22,
                              
    "NATIVE_TYPE_ANSIBSTR",  //    = 0x23,

    "NATIVE_TYPE_TBSTR",  //       = 0x24, // select BSTR or ANSIBSTR depending on platform


    "NATIVE_TYPE_VARIANTBOOL",  // = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    "NATIVE_TYPE_FUNC",  //        = 0x26,
    "NATIVE_TYPE_LPVOID",  //      = 0x27, // blind pointer (no deep marshaling)

    "NATIVE_TYPE_ASANY",  //       = 0x28,
	"<UNDEFINED NATIVE TYPE 0x29>",
    "NATIVE_TYPE_ARRAY",  //       = 0x2a,
    "NATIVE_TYPE_LPSTRUCT",  //    = 0x2b,
    "NATIVE_TYPE_CUSTOMMARSHALER", //           = 0x2c, // Custom marshaler.
    "NATIVE_TYPE_ERROR", //        = 0x2d, // VT_HRESULT when exporting to a typelib.
};


size_t g_cbCoffNames = 0;

mdMethodDef g_tkEntryPoint = 0; // integration with ILDASM



// helper to init signature buffer
void MDInfo::InitSigBuffer()
{
    strcpy((LPSTR)m_sigBuf.Ptr(), "");
} // void MDInfo::InitSigBuffer()

// helper to append a string into the signature buffer. If size of signature buffer is not big enough,
// we will grow it.
HRESULT MDInfo::AddToSigBuffer(char *string)
{
    HRESULT     hr;
    IfFailRet( m_sigBuf.ReSize(strlen((LPSTR)m_sigBuf.Ptr()) + strlen(string) + 1) );
    strcat((LPSTR)m_sigBuf.Ptr(), string);
    return NOERROR;
} // HRESULT MDInfo::AddToSigBuffer()

MDInfo::MDInfo(IMetaDataImport *pImport, IMetaDataAssemblyImport *pAssemblyImport, LPCWSTR szScope, strPassBackFn inPBFn, ULONG DumpFilter)
{   // This constructor is specific to ILDASM/MetaInfo integration

    _ASSERTE(pImport != NULL);
    _ASSERTE(NumItems(g_szMapElementType) == NumItems(g_szMapUndecorateType));
    _ASSERTE(NumItems(g_szMapElementType) == ELEMENT_TYPE_MAX);

    Init(inPBFn, (DUMP_FILTER)DumpFilter);
    
    m_pImport = pImport;
    m_pImport->AddRef();
    if (m_pAssemblyImport = pAssemblyImport) 
        m_pAssemblyImport->AddRef();
    else
    {
        HRESULT hr = m_pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**) &m_pAssemblyImport);
        if (FAILED(hr))
            Error("QueryInterface failed for IID_IMetaDataAssemblyImport.", hr);
    }

} // MDInfo::MDInfo()

MDInfo::MDInfo(IMetaDataDispenserEx *pDispenser, LPCWSTR szScope, strPassBackFn inPBFn, ULONG DumpFilter)
{
    HRESULT     hr = S_OK;
    VARIANT     value;

    _ASSERTE(pDispenser != NULL && inPBFn != NULL);
    _ASSERTE(NumItems(g_szMapElementType) == NumItems(g_szMapUndecorateType));
    _ASSERTE(NumItems(g_szMapElementType) == ELEMENT_TYPE_MAX);

    Init(inPBFn, (DUMP_FILTER)DumpFilter);

    // Attempt to open scope on given file
    V_VT(&value) = VT_UI4;
    V_UI4(&value) = MDImportOptionAll;
    if (FAILED(hr = pDispenser->SetOption(MetaDataImportOption, &value)))
            Error("SetOption failed.", hr);

    hr = pDispenser->OpenScope(szScope, 0, IID_IMetaDataImport, (IUnknown**)&m_pImport);
    if (hr == CLDB_E_BADUPDATEMODE)
    {
        V_VT(&value) = VT_UI4;
        V_UI4(&value) = MDUpdateIncremental;
        if (FAILED(hr = pDispenser->SetOption(MetaDataSetUpdate, &value)))
            Error("SetOption failed.", hr);
        hr = pDispenser->OpenScope(szScope, 0, IID_IMetaDataImport, (IUnknown**)&m_pImport);
    }
    if (FAILED(hr))
        Error("OpenScope failed", hr);

    // Query for the IMetaDataAssemblyImport interface.
    hr = m_pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**) &m_pAssemblyImport);
    if (FAILED(hr))
        Error("QueryInterface failed for IID_IMetaDataAssemblyImport.", hr);

} // MDInfo::MDInfo()


MDInfo::MDInfo(IMetaDataDispenserEx *pDispenser, PBYTE pbMetaData, DWORD dwSize, strPassBackFn inPBFn, ULONG DumpFilter)
{
    _ASSERTE(pDispenser != NULL && inPBFn != NULL);
    _ASSERTE(NumItems(g_szMapElementType) == NumItems(g_szMapUndecorateType));
    _ASSERTE(NumItems(g_szMapElementType) == ELEMENT_TYPE_MAX);

    Init(inPBFn, (DUMP_FILTER)DumpFilter);

    // Attempt to open scope on manifest. It's valid for this to fail, because
    // the blob we open may just be the assembly resources (the space is
    // overloaded until we remove LM -a assemblies, at which point this
    // constructor should probably be removed too).
    HRESULT hr;
    VARIANT     value;
    V_VT(&value) = VT_UI4;
    V_UI4(&value) = MDImportOptionAll;
    if (FAILED(hr = pDispenser->SetOption(MetaDataImportOption, &value)))
            Error("SetOption failed.", hr);
    if (SUCCEEDED(hr = pDispenser->OpenScopeOnMemory(pbMetaData, dwSize, 0,
                            IID_IMetaDataImport, (IUnknown**)&m_pImport)))
    {
        // Query for the IMetaDataAssemblyImport interface.
        hr = m_pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**) &m_pAssemblyImport);
        if (FAILED(hr))
            Error("QueryInterace failed for IID_IMetaDataAssemblyImport.", hr);
    }

} // MDInfo::MDInfo()

void MDInfo::Init(
    strPassBackFn inPBFn,               // Callback to write text.
    DUMP_FILTER DumpFilter)             // Flags to control the dump.
{
    m_VEHandlerReporterPtr = 0;
    m_pbFn = inPBFn;
    m_DumpFilter = DumpFilter;
    m_pTables = 0;
    m_pImport = NULL;
    m_pAssemblyImport = NULL;
} // void MDInfo::Init()

// Destructor
MDInfo::~MDInfo()
{
    if (m_pImport)
        m_pImport->Release();
    if (m_pAssemblyImport)
        m_pAssemblyImport->Release();
    if (m_pTables)
        m_pTables->Release();
} // MDInfo::~MDInfo()

//=====================================================================================================================
//#define EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION

HINSTANCE GetModuleInst()
{
    return NULL;
} // HINSTANCE GetModuleInst()

typedef HRESULT (*REPORTFCTN)(LPCWSTR, VEContext, HRESULT);
HRESULT DefaultReporter( // Return status.
    LPCWSTR     szMsg,                  // Error message.
    VEContext   Context,                // Error context (offset,token)
    HRESULT     hrRpt)                      // Original HRESULT
{ 
    WCHAR* wzMsg;
    if(szMsg)
    {
        wzMsg = new WCHAR[lstrlenW(szMsg)+256];
        lstrcpyW(wzMsg,szMsg);
        // include token and offset from Context
        if(Context.Token) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [token:0x%08X]",Context.Token);
        if(Context.uOffset) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [at:0x%X]",Context.uOffset);
        swprintf(&wzMsg[lstrlenW(wzMsg)],L" [hr:0x%08X]",hrRpt);
        wprintf(L"%s\n", wzMsg);
    }
    return S_OK;
} // HRESULT DefaultReporter()

class MDVEHandlerClass : public IVEHandler
{
public: 
    SIZE_T      m_refCount;
    REPORTFCTN  m_fnReport;

    MDVEHandlerClass() { m_refCount=0; m_fnReport=DefaultReporter; };
    virtual ~MDVEHandlerClass() { };

    //-----------------------------------------------------------
    // IUnknown support
    //-----------------------------------------------------------
    HRESULT STDMETHODCALLTYPE    QueryInterface(REFIID id, void** pInterface) 
    {
        if (id == IID_IVEHandler)
            *pInterface = (IVEHandler*)this;
        /*
        else if (id == IID_IUnknown)
            *pInterface = (IUnknown*)(IVEHandler*)this;
        */
        else
        {
            *pInterface = NULL;
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0) delete this;
        return (refCount);
    }
    //-----------------------------------------------------------
    // IVEHandler support
    //-----------------------------------------------------------
    HRESULT STDMETHODCALLTYPE   SetReporterFtn(__int64 lFnPtr)
    {
        m_fnReport = lFnPtr ? reinterpret_cast<REPORTFCTN>(lFnPtr) 
                             : DefaultReporter;
        return S_OK;
    };

//*****************************************************************************
// The Verification Event Handler itself. Declared in VEHandler.h as virtual, may be overridden
//*****************************************************************************
    HRESULT STDMETHODCALLTYPE VEHandler(HRESULT hrRpt, VEContext Context, SAFEARRAY *psa)
    {
        WCHAR       rcBuf[1024];             // Resource string.
        WCHAR       rcMsg[1024];             // Error message.
        va_list     marker,pval;             // User text.
        HRESULT     hr;
        VARIANT     *pVar,Var;
        ULONG       nVars,i,lVar,j,l,k;
        WCHAR       *pWsz[1024], *pwsz; // is more than 1024 string arguments likely?

        // Return warnings without text.
        if (!FAILED(hrRpt))
            return (hrRpt);
        memset(pWsz,0,sizeof(pWsz));
        // Convert safearray of variants into va_list
        if(psa && (nVars = psa->rgsabound[0].cElements))
        {
            _ASSERTE(psa->fFeatures & FADF_VARIANT);
            _ASSERTE(psa->cDims == 1);
            marker = (va_list)(new char[nVars*sizeof(double)]); // double being the largest variant element
            for(i=0,pVar=(VARIANT *)(psa->pvData),pval=marker; i < nVars; pVar++,i++)
            {
                memcpy(&Var,pVar,sizeof(VARIANT));
                switch(Var.vt)
                {
                    case VT_I1:
                    case VT_UI1:    lVar = 1; break;

                    case VT_I2:
                    case VT_UI2:    lVar = 2; break;

                    case VT_R8:
                    case VT_CY:
                    case VT_DATE:   lVar = 8; break;

                    case VT_BYREF|VT_I1:
                    case VT_BYREF|VT_UI1: // it's ASCII string, convert it to UNICODE
                        lVar = 4;
                        l = strlen((char *)(Var.pbVal))+1;
                        pwsz = new WCHAR[l];
                        for(j=0; j<l; j++) pwsz[j] = Var.pbVal[j];
                        for(k=0; pWsz[k]; k++);
                        pWsz[k] = pwsz;
                        Var.piVal = (short *)pwsz;
                        break;

                    default:        lVar = 4; break;
                }
                memcpy(pval,&(Var.bVal),lVar);
                pval += (lVar + sizeof(int) - 1) & ~(sizeof(int) - 1); //From STDARG.H: #define _INTSIZEOF(n)
            }
        }
        else
            marker = NULL;

        // If this is one of our errors, then grab the error from the rc file.
        if (HRESULT_FACILITY(hrRpt) == FACILITY_URT)
        {
            hr = LoadStringRC(LOWORD(hrRpt), rcBuf, NumItems(rcBuf), true);
            if (hr == S_OK)
            {
                // Format the error.
                _vsnwprintf(rcMsg, NumItems(rcMsg), rcBuf, marker);
                rcMsg[NumItems(rcMsg) - 1] = 0;
            }
        }
        // Otherwise it isn't one of ours, so we need to see if the system can
        // find the text for it.
        else
        {
            if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                    0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    rcMsg, NumItems(rcMsg), 0))
            {
                hr = S_OK;

                // System messages contain a trailing \r\n, which we don't want normally.
                int iLen = lstrlenW(rcMsg);
                if (iLen > 3 && rcMsg[iLen - 2] == '\r' && rcMsg[iLen - 1] == '\n')
                    rcMsg[iLen - 2] = '\0';
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if(marker) delete marker;

        // If we failed to find the message anywhere, then issue a hard coded message.
        if (FAILED(hr))
        {
            swprintf(rcMsg, L"COM+ Runtime Internal error: 0x%08x", hrRpt);
            //DEBUG_STMT(DbgWriteEx(rcMsg));
        }

        // delete WCHAR buffers allocated above (if any)
        for(k=0; pWsz[k]; k++) delete pWsz[k];

        return (m_fnReport(rcMsg, Context,hrRpt) == S_OK ? S_OK : E_FAIL);
    };

    static HRESULT STDMETHODCALLTYPE CreateObject(REFIID id, void **object)
    { return E_NOTIMPL; }
};

#endif
//=====================================================================================================================
// DisplayMD() function
//
// Displays the meta data content of a file

void MDInfo::DisplayMD()
{
    if (m_DumpFilter & dumpValidate)
    {
        IMetaDataValidate *pValidate = 0;
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
        MDVEHandlerClass    *pVEHandler = 0;
#else
        IVEHandler  *pVEHandler = 0;
#endif
        const char *szErrStr = 0;
        HRESULT     hr = S_OK;

        // Get a pointer to the Validator interface.
        hr = m_pImport->QueryInterface(IID_IMetaDataValidate, (void **) &pValidate);
        if (FAILED(hr))
        {
            szErrStr = "QueryInterface failed for IMetaDataValidate.";
            goto ErrExit;
        }

        // Get a pointer to the VEHandler interface.
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
        if(pVEHandler = new MDVEHandlerClass()) hr = S_OK;
        else hr = E_FAIL;
#else
        hr = CoCreateInstance(CLSID_VEHandlerClass,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IVEHandler,
                           (void **)&pVEHandler);
#endif
        if (FAILED(hr))
        {
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
            szErrStr = "Failed to create VEHandler.";
#else
            szErrStr = "CoCreateInstance(VEHandler) failed.";
#endif
            goto ErrExit;
        }

        if(m_VEHandlerReporterPtr) pVEHandler->SetReporterFtn((__int64)m_VEHandlerReporterPtr);

        hr = pValidate->ValidatorInit(g_ValModuleType, pVEHandler);
        if (FAILED(hr))
        {
            szErrStr = "ValidatorInit failed.";
            goto ErrExit;
        }

        hr = pValidate->ValidateMetaData();
        if (FAILED(hr))
        {
            szErrStr = "ValidateMetaData failed to run successfully.";
            goto ErrExit;
        }
        if (hr == S_OK)
            WriteLine("No warnings or errors found.");
        else if (hr == VLDTR_S_WRN)
            WriteLine("Warnings found.");
        else if (hr == VLDTR_S_ERR)
            WriteLine("Errors found.");
        else if (hr == VLDTR_S_WRNERR)
            WriteLine("Warnings and Errors found.");
        else
            VWriteLine("Validator returned unexpected success code, hr=0x%08x.", hr);
ErrExit:
        if (pValidate)
            pValidate->Release();
#ifdef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
        if (pVEHandler)
            pVEHandler->Release();
#endif
        if (szErrStr)
            Error(szErrStr, hr);
    }
    else if (m_DumpFilter & (dumpSchema | dumpHeader | dumpCSV | dumpRaw | dumpStats | dumpRawHeaps))
        DisplayRaw();
    else if ((m_DumpFilter & dumpAssem) && m_pAssemblyImport)
        DisplayAssemblyInfo();
    else
    {
        DisplayVersionInfo();
        DisplayScopeInfo();
        WriteLine("===========================================================");
        DisplayGlobalFunctions();
        DisplayGlobalFields();
        DisplayGlobalMemberRefs();
        DisplayTypeDefs();
        DisplayTypeRefs();
        DisplayTypeSpecs();
        DisplayModuleRefs();
        DisplaySignatures();
        DisplayAssembly();
        DisplayUserStrings();

        // WriteLine("============================================================");
        // WriteLine("Unresolved MemberRefs");
        // DisplayMemberRefs(0x00000001, "\t");

        if (m_DumpFilter & dumpUnsat)
            DisplayUnsatInfo();
    
    
        VWrite("\n\nCoff symbol name overhead:  %d\n", g_cbCoffNames);
    }
} // MDVEHandlerClass()

int MDInfo::WriteLine(char *str)
{
    int count = strlen(str);

    m_pbFn(str);
    m_pbFn("\n");
    return count;
} // int MDInfo::WriteLine()

int MDInfo::Write(char *str)
{
    int count = strlen(str);

    m_pbFn(str);
    return count;
} // int MDInfo::Write()

int MDInfo::VWriteLine(char *str, ...)
{
    va_list marker;
    int     count;

    va_start(marker, str);
    count = VWrite(str, marker);
    m_pbFn("\n");
    va_end(marker);
    return count;
} // int MDInfo::VWriteLine()

int MDInfo::VWrite(char *str, ...)
{
    va_list marker;
    int     count;

    va_start(marker, str);
    count = VWrite(str, marker);
    va_end(marker);
    return count;
} // int MDInfo::VWrite()

int MDInfo::VWrite(char *str, va_list marker)
{
    int     count = -1;
    int     i = 1;
    HRESULT hr;

    while (count < 0)
    {
        if (FAILED(hr = m_output.ReSize(STRING_BUFFER_LEN * i)))
            Error("ReSize failed.", hr);
        count = _vsnprintf((char *)m_output.Ptr(), STRING_BUFFER_LEN * i, str, marker);
        i *= 2;
    }
    m_pbFn((char *)m_output.Ptr());
    return count;
} // int MDInfo::VWriteToBuffer()

// Error() function -- prints an error and returns
void MDInfo::Error(const char* szError, HRESULT hr)
{
    printf("\n%s\n",szError);
    if (hr != S_OK)
    {
        IErrorInfo  *pIErr = NULL;          // Error interface.
        BSTR        bstrDesc = NULL;        // Description text.

        printf("Failed return code: 0x%08x\n", hr);

        // Try to get an error info object and display the message.
        if (GetErrorInfo(0, &pIErr) == S_OK &&
            pIErr->GetDescription(&bstrDesc) == S_OK)
        {
            printf("%ls ", bstrDesc);
            SysFreeString(bstrDesc);
        }

        // Free the error interface.
        if (pIErr)
            pIErr->Release();
    }
    CoUninitializeCor();
    CoUninitialize();
    exit(hr);
} // void MDInfo::Error()

// Print out the optional version info included in the MetaData.

void MDInfo::DisplayVersionInfo()
{
    if (!(m_DumpFilter & MDInfo::dumpNoLogo))
    {
        LPCUTF8 pVersionStr;
        HRESULT hr = S_OK;

        if (m_pTables == 0)
        {
            if (m_pImport)
                hr = m_pImport->QueryInterface(IID_IMetaDataTables, (void**)&m_pTables);
            else if (m_pAssemblyImport)
                hr = m_pAssemblyImport->QueryInterface(IID_IMetaDataTables, (void**)&m_pTables);
            else
                return;
            if (FAILED(hr))
                Error("QueryInterace failed for IID_IMetaDataTables.", hr);
        }

        hr = m_pTables->GetString(1, &pVersionStr);
        if (FAILED(hr))
            Error("GetString() failed.", hr);
        if (strstr(pVersionStr, "Version of runtime against which the binary is built : ")
                    == pVersionStr)
        {
            WriteLine(const_cast<char *>(pVersionStr));
        }
    }
} // void MDInfo::DisplayVersionInfo()

// Prints out information about the scope

void MDInfo::DisplayScopeInfo()
{
    HRESULT hr;
    mdModule mdm;
    GUID mvid;
    WCHAR scopeName[STRING_BUFFER_LEN];
    WCHAR guidString[STRING_BUFFER_LEN];

    hr = m_pImport->GetScopeProps( scopeName, STRING_BUFFER_LEN, 0, &mvid);
    if (FAILED(hr)) Error("GetScopeProps failed.", hr);

    VWriteLine("ScopeName : %ls",scopeName);

    if (!(m_DumpFilter & MDInfo::dumpNoLogo))
        VWriteLine("MVID      : %ls",GUIDAsString(mvid, guidString, STRING_BUFFER_LEN));

    hr = m_pImport->GetModuleFromScope(&mdm);
    if (FAILED(hr)) Error("GetModuleFromScope failed.", hr);
    DisplayPermissions(mdm, "");
    DisplayCustomAttributes(mdm, "\t");
} // void MDInfo::DisplayScopeInfo()

void MDInfo::DisplayRaw()
{
    int         iDump;                  // Level of info to dump.

    if (m_pTables == 0)
        m_pImport->QueryInterface(IID_IMetaDataTables, (void**)&m_pTables);
    if (m_pTables == 0)
        Error("Can't get table info.");

    if (m_DumpFilter & dumpCSV)
        DumpRawCSV();
    else
    {
        if (m_DumpFilter & dumpRaw)
            iDump = 3;
        else
        if (m_DumpFilter & dumpSchema)
            iDump = 2;
        else
            iDump = 1;
        
        DumpRaw(iDump, (m_DumpFilter & dumpStats) != 0);
    }
} // void MDInfo::DisplayRaw()

// return the name of the type of token passed in

char *MDInfo::TokenTypeName(mdToken inToken)
{
    switch(TypeFromToken(inToken))
    {
    case mdtTypeDef:        return "TypeDef";
    case mdtInterfaceImpl:  return "InterfaceImpl";
    case mdtMethodDef:      return "MethodDef";
    case mdtFieldDef:       return "FieldDef";
    case mdtTypeRef:        return "TypeRef";
    case mdtMemberRef:      return "MemberRef";
    case mdtCustomAttribute:return "CustomAttribute";
    case mdtParamDef:       return "ParamDef";
    case mdtProperty:       return "Property";
    case mdtEvent:          return "Event";
    default:                return "[UnknownTokenType]";
    }
} // char *MDInfo::TokenTypeName()

// Prints out name of the given memberref
//

LPCWSTR MDInfo::MemberRefName(mdMemberRef inMemRef, LPWSTR buffer, ULONG bufLen)
{
    HRESULT hr;
    

    hr = m_pImport->GetMemberRefProps( inMemRef, NULL, buffer, bufLen,
                                    NULL, NULL, NULL);
    if (FAILED(hr)) Error("GetMemberRefProps failed.", hr);
    
    return buffer;
} // LPCWSTR MDInfo::MemberRefName()


// Prints out information about the given memberref
//

void MDInfo::DisplayMemberRefInfo(mdMemberRef inMemRef, const char *preFix)
{
    HRESULT hr;
    WCHAR memRefName[STRING_BUFFER_LEN];
    ULONG nameLen;
    mdToken token;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG ulSigBlob;
    char newPreFix[STRING_BUFFER_LEN];


    hr = m_pImport->GetMemberRefProps( inMemRef, &token, memRefName, STRING_BUFFER_LEN,
                                    &nameLen, &pbSigBlob, &ulSigBlob);
    if (FAILED(hr)) Error("GetMemberRefProps failed.", hr);
    
    VWriteLine("%s\t\tMember: (%8.8x) %ls: ", preFix, inMemRef, memRefName);

    if (ulSigBlob)
        DisplaySignature(pbSigBlob, ulSigBlob, preFix);
	else
		VWriteLine("%s\t\tERROR: no valid signature ", preFix);

    sprintf (newPreFix, "\t\t%s", preFix);
    DisplayCustomAttributes(inMemRef, newPreFix);
} // void MDInfo::DisplayMemberRefInfo()

// Prints out information about all memberrefs of the given typeref
//

void MDInfo::DisplayMemberRefs(mdToken tkParent, const char *preFix)
{
    HCORENUM memRefEnum = NULL;
    HRESULT hr;
    mdMemberRef memRefs[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;


    while (SUCCEEDED(hr = m_pImport->EnumMemberRefs( &memRefEnum, tkParent,
                             memRefs, NumItems(memRefs), &count)) && 
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("%s\tMemberRef #%d", preFix, totalCount);
            VWriteLine("%s\t-------------------------------------------------------", preFix);
            DisplayMemberRefInfo(memRefs[i], preFix);
        }
    }
    m_pImport->CloseEnum( memRefEnum);
} // void MDInfo::DisplayMemberRefs()

// Prints out information about all resources in the com object
//

// Iterates through each typeref and prints out the information of each
//

void MDInfo::DisplayTypeRefs()
{
    HCORENUM typeRefEnum = NULL;
    mdTypeRef typeRefs[ENUM_BUFFER_SIZE];
    ULONG count, totalCount=1;
    HRESULT hr;
    
    while (SUCCEEDED(hr = m_pImport->EnumTypeRefs( &typeRefEnum,
                             typeRefs, NumItems(typeRefs), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("TypeRef #%d (%08x)", totalCount, typeRefs[i]);
            WriteLine("-------------------------------------------------------");
            DisplayTypeRefInfo(typeRefs[i]);
            DisplayMemberRefs(typeRefs[i], "");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( typeRefEnum);
} // void MDInfo::DisplayTypeRefs()

void MDInfo::DisplayTypeSpecs()
{
    HCORENUM typespecEnum = NULL;
    mdTypeSpec typespecs[ENUM_BUFFER_SIZE];
    ULONG count, totalCount=1;
    HRESULT hr;
    
    while (SUCCEEDED(hr = m_pImport->EnumTypeSpecs( &typespecEnum,
                             typespecs, NumItems(typespecs), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("TypeSpec #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayTypeSpecInfo(typespecs[i], "");
            DisplayMemberRefs(typespecs[i], "");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( typespecEnum);
} // void MDInfo::DisplayTypeSpecs()



// Called to display the information about all typedefs in the object.
//

void MDInfo::DisplayTypeDefs()
{
    HCORENUM typeDefEnum = NULL;
    mdTypeDef typeDefs[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;
    
    while (SUCCEEDED(hr = m_pImport->EnumTypeDefs( &typeDefEnum,
                             typeDefs, NumItems(typeDefs), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("TypeDef #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayTypeDefInfo(typeDefs[i]);
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( typeDefEnum);
} // void MDInfo::DisplayTypeDefs()

// Called to display the information about all modulerefs in the object.
//

void MDInfo::DisplayModuleRefs()
{
    HCORENUM moduleRefEnum = NULL;
    mdModuleRef moduleRefs[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;
    
    while (SUCCEEDED(hr = m_pImport->EnumModuleRefs( &moduleRefEnum,
                             moduleRefs, NumItems(moduleRefs), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("ModuleRef #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayModuleRefInfo(moduleRefs[i]);
            DisplayMemberRefs(moduleRefs[i], "");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( moduleRefEnum);
} // void MDInfo::DisplayModuleRefs()

// Prints out information about the given moduleref
//

void MDInfo::DisplayModuleRefInfo(mdModuleRef inModuleRef)
{
    HRESULT hr;
    WCHAR moduleRefName[STRING_BUFFER_LEN];
    ULONG nameLen;


    hr = m_pImport->GetModuleRefProps( inModuleRef, moduleRefName, STRING_BUFFER_LEN,
                                    &nameLen);
    if (FAILED(hr)) Error("GetModuleRefProps failed.", hr);
    
    VWriteLine("\t\tModuleRef: (%8.8x) %ls: ", inModuleRef, moduleRefName);
    DisplayCustomAttributes(inModuleRef, "\t\t");
} // void MDInfo::DisplayModuleRefInfo()


// Called to display the information about all signatures in the object.
//

void MDInfo::DisplaySignatures()
{
    HCORENUM signatureEnum = NULL;
    mdSignature signatures[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;
    
    while (SUCCEEDED(hr = m_pImport->EnumSignatures( &signatureEnum,
                             signatures, NumItems(signatures), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("Signature #%d (%#08x)", totalCount, signatures[i]);
            WriteLine("-------------------------------------------------------");
            DisplaySignatureInfo(signatures[i]);
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( signatureEnum);
} // void MDInfo::DisplaySignatures()


// Prints out information about the given signature
//

void MDInfo::DisplaySignatureInfo(mdSignature inSignature)
{
    HRESULT hr;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG   ulSigBlob;


    hr = m_pImport->GetSigFromToken( inSignature, &pbSigBlob, &ulSigBlob );
    if (FAILED(hr)) Error("GetSigFromToken failed.", hr);
    if(ulSigBlob)
		DisplaySignature(pbSigBlob, ulSigBlob, "");
	else
		VWriteLine("\t\tERROR: no valid signature ");
} // void MDInfo::DisplaySignatureInfo()


// returns the passed-in buffer which is filled with the name of the given 
// member in wide characters
//

LPCWSTR MDInfo::MemberName(mdToken inToken, LPWSTR buffer, ULONG bufLen)
{
    HRESULT hr;
    

    hr = m_pImport->GetMemberProps( inToken, NULL, buffer, bufLen,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) Error("GetMemberProps failed.", hr);

    return (buffer);
} // LPCWSTR MDInfo::MemberName()


// displays information for the given method
//

void MDInfo::DisplayMethodInfo(mdMethodDef inMethod, DWORD *pflags)
{
    HRESULT hr;
    mdTypeDef memTypeDef;
    WCHAR memberName[STRING_BUFFER_LEN];
    ULONG nameLen;
    DWORD flags;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG ulSigBlob;
    ULONG ulCodeRVA;
    ULONG ulImplFlags;


    hr = m_pImport->GetMethodProps( inMethod, &memTypeDef, memberName, STRING_BUFFER_LEN,
                            &nameLen, &flags, &pbSigBlob, &ulSigBlob, &ulCodeRVA, &ulImplFlags);
    if (FAILED(hr)) Error("GetMethodProps failed.", hr);
    if (pflags)
        *pflags = flags;

    VWriteLine("\t\tMethodName: %ls (%8.8X)", memberName, inMethod);

    char sFlags[STRING_BUFFER_LEN];

    strcpy(sFlags, "");
    ISFLAG(Md, Public);     
    ISFLAG(Md, Private);        
    ISFLAG(Md, Family);     
    ISFLAG(Md, Assem);      
    ISFLAG(Md, FamANDAssem);    
    ISFLAG(Md, FamORAssem); 
    ISFLAG(Md, PrivateScope);   
    ISFLAG(Md, Static);     
    ISFLAG(Md, Final);      
    ISFLAG(Md, Virtual);        
    ISFLAG(Md, HideBySig);  
    ISFLAG(Md, ReuseSlot);  
    ISFLAG(Md, NewSlot);        
    ISFLAG(Md, Abstract);       
    ISFLAG(Md, SpecialName);    
    ISFLAG(Md, RTSpecialName);
    ISFLAG(Md, PinvokeImpl);
    ISFLAG(Md, UnmanagedExport);
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    if (IsMdInstanceInitializerW(flags, memberName)) strcat(sFlags, "[.ctor] ");
    if (IsMdClassConstructorW(flags, memberName)) strcat(sFlags, "[.cctor] ");
    // "Reserved" flags
    ISFLAG(Md, HasSecurity);
    ISFLAG(Md, RequireSecObject);

    VWriteLine("\t\tFlags     : %s (%08x)", sFlags, flags);
    VWriteLine("\t\tRVA       : 0x%08x", ulCodeRVA);

    flags = ulImplFlags;
    strcpy(sFlags, "");
    ISFLAG(Mi, Native);     
    ISFLAG(Mi, IL);         
    ISFLAG(Mi, OPTIL);      
    ISFLAG(Mi, Runtime);        
    ISFLAG(Mi, Unmanaged);  
    ISFLAG(Mi, Managed);        
    ISFLAG(Mi, ForwardRef);
    ISFLAG(Mi, PreserveSig);            
    ISFLAG(Mi, InternalCall);
    ISFLAG(Mi, Synchronized);
    ISFLAG(Mi, NoInlining);    
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\t\tImplFlags : %s (%08x)", sFlags, flags);

    if (ulSigBlob)
        DisplaySignature(pbSigBlob, ulSigBlob, "");
	else
		VWriteLine("\t\tERROR: no valid signature ");

} // void MDInfo::DisplayMethodInfo()

// displays the member information for the given field
//

void MDInfo::DisplayFieldInfo(mdFieldDef inField, DWORD *pdwFlags)
{
    HRESULT hr;
    mdTypeDef memTypeDef;
    WCHAR memberName[STRING_BUFFER_LEN];
    ULONG nameLen;
    DWORD flags;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG ulSigBlob;
    DWORD dwCPlusTypeFlag;
    void const *pValue;
    ULONG cbValue;
    VARIANT defaultValue;


    ::VariantInit(&defaultValue);
    hr = m_pImport->GetFieldProps( inField, &memTypeDef, memberName, STRING_BUFFER_LEN,
                            &nameLen, &flags, &pbSigBlob, &ulSigBlob, &dwCPlusTypeFlag,
                            &pValue, &cbValue);
    if (FAILED(hr)) Error("GetFieldProps failed.", hr);

    if (pdwFlags)
        *pdwFlags = flags;

    _FillVariant((BYTE)dwCPlusTypeFlag, pValue, &defaultValue);

    char sFlags[STRING_BUFFER_LEN];

    strcpy(sFlags, "");
    ISFLAG(Fd, Public);     
    ISFLAG(Fd, Private);        
    ISFLAG(Fd, Family);     
    ISFLAG(Fd, Assembly);       
    ISFLAG(Fd, FamANDAssem);    
    ISFLAG(Fd, FamORAssem); 
    ISFLAG(Fd, PrivateScope);   
    ISFLAG(Fd, Static);     
    ISFLAG(Fd, InitOnly);       
    ISFLAG(Fd, Literal);        
    ISFLAG(Fd, NotSerialized);
    ISFLAG(Fd, SpecialName);
    ISFLAG(Fd, RTSpecialName);
    ISFLAG(Fd, PinvokeImpl);    
    // "Reserved" flags
    ISFLAG(Fd, HasDefault);
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\t\tField Name: %ls (%8.8X)", memberName, inField);
    VWriteLine("\t\tFlags     : %s (%08x)", sFlags, flags);
    if (IsFdHasDefault(flags))
        VWriteLine("\tDefltValue: (%s) %ls", g_szMapElementType[dwCPlusTypeFlag], VariantAsString(&defaultValue));
    if (!ulSigBlob) // Signature size should be non-zero for fields
		VWriteLine("\t\tERROR: no valid signature ");
	else
		DisplaySignature(pbSigBlob, ulSigBlob, "");
} // void MDInfo::DisplayFieldInfo()

// displays the RVA for the given global field.
void MDInfo::DisplayFieldRVA(mdFieldDef inFieldDef)
{
    HRESULT hr;
    ULONG   ulRVA;

    hr = m_pImport->GetRVA(inFieldDef, &ulRVA, 0);
    if (FAILED(hr) && hr != CLDB_E_RECORD_NOTFOUND) Error("GetRVA failed.", hr);

    VWriteLine("\t\tRVA       : 0x%08x", ulRVA);
} // void MDInfo::DisplayFieldRVA()

// displays information about every global function.
void MDInfo::DisplayGlobalFunctions()
{
    WriteLine("Global functions");
    WriteLine("-------------------------------------------------------");
    DisplayMethods(mdTokenNil);
    WriteLine("");
} // void MDInfo::DisplayGlobalFunctions()

// displays information about every global field.
void MDInfo::DisplayGlobalFields()
{
    WriteLine("Global fields");
    WriteLine("-------------------------------------------------------");
    DisplayFields(mdTokenNil, NULL, 0);
    WriteLine("");
} // void MDInfo::DisplayGlobalFields()

// displays information about every global memberref.
void MDInfo::DisplayGlobalMemberRefs()
{
    WriteLine("Global MemberRefs");
    WriteLine("-------------------------------------------------------");
    DisplayMemberRefs(mdTokenNil, "");
    WriteLine("");
} // void MDInfo::DisplayGlobalMemberRefs()

// displays information about every method in a given typedef
//

void MDInfo::DisplayMethods(mdTypeDef inTypeDef)
{
    HCORENUM methodEnum = NULL;
    mdToken methods[ENUM_BUFFER_SIZE];
    DWORD flags;
    ULONG count, totalCount = 1;
    HRESULT hr;
    

    while (SUCCEEDED(hr = m_pImport->EnumMethods( &methodEnum, inTypeDef,
                             methods, NumItems(methods), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\tMethod #%d %s", totalCount,(methods[i] == g_tkEntryPoint) ? "[ENTRYPOINT]" : "");
            WriteLine("\t-------------------------------------------------------");
            DisplayMethodInfo(methods[i], &flags);
            DisplayParams(methods[i]);
            DisplayCustomAttributes(methods[i], "\t\t");
            DisplayPermissions(methods[i], "\t");
            DisplayMemberRefs(methods[i], "\t");

            // P-invoke data if present.
            if (IsMdPinvokeImpl(flags))
                DisplayPinvokeInfo(methods[i]);

            WriteLine("");
        }
    }
    m_pImport->CloseEnum( methodEnum);
} // void MDInfo::DisplayMethods()


// displays information about every field in a given typedef
//

void MDInfo::DisplayFields(mdTypeDef inTypeDef, COR_FIELD_OFFSET *rFieldOffset, ULONG cFieldOffset)
{
    HCORENUM fieldEnum = NULL;
    mdToken fields[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    DWORD flags;
    HRESULT hr;
    

    while (SUCCEEDED(hr = m_pImport->EnumFields( &fieldEnum, inTypeDef,
                             fields, NumItems(fields), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\tField #%d",totalCount);
            WriteLine("\t-------------------------------------------------------");
            DisplayFieldInfo(fields[i], &flags);
            DisplayCustomAttributes(fields[i], "\t\t");
            DisplayPermissions(fields[i], "\t");
            DisplayFieldMarshal(fields[i]);

            // RVA if its a global field.
            if (inTypeDef == mdTokenNil)
                DisplayFieldRVA(fields[i]);

            // P-invoke data if present.
            if (IsFdPinvokeImpl(flags))
                DisplayPinvokeInfo(fields[i]);

            // Display offset if present.
            if (cFieldOffset)
            {
                bool found = false;
                for (ULONG iLayout = 0; i < cFieldOffset; ++iLayout)
                {
                    if (RidFromToken(rFieldOffset[iLayout].ridOfField) == RidFromToken(fields[i]))
                    {
                        found = true;
                        VWriteLine("\t\tOffset : 0x%08x", rFieldOffset[iLayout].ulOffset);
                        break;
                    }
                }
                _ASSERTE(found);
            }
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( fieldEnum);
} // void MDInfo::DisplayFields()


// displays information about every methodImpl in a given typedef
//

void MDInfo::DisplayMethodImpls(mdTypeDef inTypeDef)
{
    HCORENUM methodImplEnum = NULL;
    mdMethodDef rtkMethodBody[ENUM_BUFFER_SIZE];
    mdMethodDef rtkMethodDecl[ENUM_BUFFER_SIZE];

    ULONG count, totalCount=1;
    HRESULT hr;


    while (SUCCEEDED(hr = m_pImport->EnumMethodImpls( &methodImplEnum, inTypeDef,
                             rtkMethodBody, rtkMethodDecl, NumItems(rtkMethodBody), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\n\tMethodImpl #%d", totalCount);
            WriteLine("\t-------------------------------------------------------");
            VWriteLine("\t\tMethod Body Token : 0x%08x", rtkMethodBody[i]);
            VWriteLine("\t\tMethod Declaration Token : 0x%08x", rtkMethodDecl[i]);
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( methodImplEnum);
} // void MDInfo::DisplayMethodImpls()

// displays information about the given parameter
//

void MDInfo::DisplayParamInfo(mdParamDef inParamDef)
{
    mdMethodDef md;
    ULONG num;
    WCHAR paramName[STRING_BUFFER_LEN];
    ULONG nameLen;
    DWORD flags;
    VARIANT defValue;
    DWORD dwCPlusFlags;
    void const *pValue;
    ULONG cbValue;


    ::VariantInit(&defValue);
    HRESULT hr = m_pImport->GetParamProps( inParamDef, &md, &num, paramName, NumItems(paramName),
                            &nameLen, &flags, &dwCPlusFlags, &pValue, &cbValue);
    if (FAILED(hr)) Error("GetParamProps failed.", hr);
    
    _FillVariant((BYTE)dwCPlusFlags, pValue, &defValue);
    
    char sFlags[STRING_BUFFER_LEN];
    strcpy(sFlags, "");
    ISFLAG(Pd, In);     
    ISFLAG(Pd, Out);        
    ISFLAG(Pd, Optional);
    // "Reserved" flags.
    ISFLAG(Pd, HasDefault); 
    ISFLAG(Pd, HasFieldMarshal);    
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWrite("\t\t\t(%ld) ParamToken : (%08x) Name : %ls flags: %s (%08x)", num, inParamDef, paramName, sFlags, flags);
    if (IsPdHasDefault(flags))
        VWriteLine(" Default: (%s) %ls", g_szMapElementType[dwCPlusFlags], VariantAsString(&defValue));
    else
        VWriteLine("");
    DisplayCustomAttributes(inParamDef, "\t\t\t");
} // void MDInfo::DisplayParamInfo()


// displays all parameters for a given memberdef
//

void MDInfo::DisplayParams(mdMethodDef inMethodDef)
{
    HCORENUM paramEnum = NULL;
    mdParamDef params[ENUM_BUFFER_SIZE];
    ULONG count, paramCount;
    bool first = true;
    HRESULT hr;

  
    while (SUCCEEDED(hr = m_pImport->EnumParams( &paramEnum, inMethodDef,
                             params, NumItems(params), &count)) &&
            count > 0)
    {
        if (first)
        {
            m_pImport->CountEnum( paramEnum, &paramCount);
            VWriteLine("\t\t%d Parameters", paramCount);
        }
        for (ULONG i = 0; i < count; i++)
        {
            DisplayParamInfo(params[i]);
            DisplayFieldMarshal(params[i]);
        }
        first = false;
    }
    m_pImport->CloseEnum( paramEnum);
} // void MDInfo::DisplayParams()


LPCWSTR MDInfo::TokenName(mdToken inToken, LPWSTR buffer, ULONG bufLen)
{
    LPCUTF8     pName;                  // Token name in UTF8.

    if (IsNilToken(inToken))
        return L"";

    m_pImport->GetNameFromToken(inToken, &pName);

    WszMultiByteToWideChar(CP_UTF8,0, pName,-1, buffer,bufLen);

    return buffer;
} // LPCWSTR MDInfo::TokenName()

// prints out name of typeref or typedef
//

LPCWSTR MDInfo::TypeDeforRefName(mdToken inToken, LPWSTR buffer, ULONG bufLen)
{
    if (RidFromToken(inToken))
    {
        if (TypeFromToken(inToken) == mdtTypeDef)
            return (TypeDefName((mdTypeDef) inToken, buffer, bufLen));
        else if (TypeFromToken(inToken) == mdtTypeRef)
            return (TypeRefName((mdTypeRef) inToken, buffer, bufLen));
        else
            return (L"[InvalidReference]");
    }
    else
        return (L"");
} // LPCWSTR MDInfo::TypeDeforRefName()

LPCWSTR MDInfo::MemberDeforRefName(mdToken inToken, LPWSTR buffer, ULONG bufLen)
{
    if (RidFromToken(inToken))
    {
        if (TypeFromToken(inToken) == mdtMethodDef || TypeFromToken(inToken) == mdtFieldDef)
            return (MemberName(inToken, buffer, bufLen));
        else if (TypeFromToken(inToken) == mdtMemberRef)
            return (MemberRefName((mdMemberRef) inToken, buffer, bufLen));
        else
            return (L"[InvalidReference]");
    }
    else
        return (L"");
} // LPCWSTR MDInfo::MemberDeforRefName()

// prints out only the name of the given typedef
//
// available 98 and 99

LPCWSTR MDInfo::TypeDefName(mdTypeDef inTypeDef, LPWSTR buffer, ULONG bufLen)
{
    HRESULT hr;

    hr = m_pImport->GetTypeDefProps(
                            // [IN] The import scope.
        inTypeDef,              // [IN] TypeDef token for inquiry.
        buffer,                 // [OUT] Put name here.
        bufLen,                 // [IN] size of name buffer in wide chars.
        NULL,                   // [OUT] put size of name (wide chars) here.
        NULL,                   // [OUT] Put flags here.
        NULL);                  // [OUT] Put base class TypeDef/TypeRef here.
    if (FAILED(hr)) Error("GetTypeDefProps failed.", hr);

    return buffer;
} // LPCWSTR MDInfo::TypeDefName()

// prints out all the properties of a given typedef
//

void MDInfo::DisplayTypeDefProps(mdTypeDef inTypeDef)
{
    HRESULT hr;
    WCHAR typeDefName[STRING_BUFFER_LEN];
    ULONG nameLen;
    DWORD flags;
    mdToken extends;
    ULONG       dwPacking;              // Packing size of class, if specified.
    ULONG       dwSize;                 // Total size of class, if specified.

    hr = m_pImport->GetTypeDefProps(
        inTypeDef,              // [IN] TypeDef token for inquiry.
        typeDefName,            // [OUT] Put name here.
        STRING_BUFFER_LEN,      // [IN] size of name buffer in wide chars.
        &nameLen,               // [OUT] put size of name (wide chars) here.
        &flags,                 // [OUT] Put flags here.
        &extends);              // [OUT] Put base class TypeDef/TypeRef here.
    if (FAILED(hr)) Error("GetTypeDefProps failed.", hr);

    char sFlags[STRING_BUFFER_LEN];
    WCHAR szTempBuf[STRING_BUFFER_LEN];

    VWriteLine("\tTypDefName: %ls  (%8.8X)",typeDefName,inTypeDef);
    VWriteLine("\tFlags     : %s (%08x)",ClassFlags(flags, sFlags), flags);
    VWriteLine("\tExtends   : %8.8X [%s] %ls",extends,TokenTypeName(extends),
                                 TypeDeforRefName(extends, szTempBuf, NumItems(szTempBuf)));

    hr = m_pImport->GetClassLayout(inTypeDef, &dwPacking, 0,0,0, &dwSize);
    if (hr == S_OK)
        VWriteLine("\tLayout    : Packing:%d, Size:%d", dwPacking, dwSize);

    if (IsTdNested(flags))
    {
        mdTypeDef   tkEnclosingClass;

        hr = m_pImport->GetNestedClassProps(inTypeDef, &tkEnclosingClass);
        if (hr == S_OK)
        {
            VWriteLine("\tEnclosingClass : %ls (%8.8X)", TypeDeforRefName(tkEnclosingClass,
                                            szTempBuf, NumItems(szTempBuf)), tkEnclosingClass);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            WriteLine("ERROR: EnclosingClass not found for NestedClass");
        else
            Error("GetNestedClassProps failed.", hr);
    }
} // void MDInfo::DisplayTypeDefProps()

//  Prints out the name of the given TypeRef
//

LPCWSTR MDInfo::TypeRefName(mdTypeRef tr, LPWSTR buffer, ULONG bufLen)
{
    HRESULT hr;
    
    hr = m_pImport->GetTypeRefProps(           
        tr,                 // The class ref token.
        NULL,               // Resolution scope.
        buffer,             // Put the name here.
        bufLen,             // Size of the name buffer, wide chars.
        NULL);              // Put actual size of name here.
    if (FAILED(hr)) Error("GetTypeRefProps failed.", hr);

    return (buffer);
} // LPCWSTR MDInfo::TypeRefName()

// Prints out all the info of the given TypeRef
//

void MDInfo::DisplayTypeRefInfo(mdTypeRef tr)
{
    HRESULT hr;
    mdToken tkResolutionScope;
    WCHAR typeRefName[STRING_BUFFER_LEN];
    ULONG nameLen;

    hr = m_pImport->GetTypeRefProps(           
        tr,                 // The class ref token.
        &tkResolutionScope, // ResolutionScope.
        typeRefName,        // Put the name here.
        STRING_BUFFER_LEN,  // Size of the name buffer, wide chars.
        &nameLen);          // Put actual size of name here.

    if (FAILED(hr)) Error("GetTypeRefProps failed.", hr);

    VWriteLine("Token:             0x%08x", tr);
    VWriteLine("ResolutionScope:   0x%08x", tkResolutionScope);
    VWriteLine("TypeRefName:       %ls",typeRefName);

    DisplayCustomAttributes(tr, "\t");
} // void MDInfo::DisplayTypeRefInfo()


void MDInfo::DisplayTypeSpecInfo(mdTypeSpec ts, const char *preFix)
{
    HRESULT hr;
    PCCOR_SIGNATURE pvSig;
    ULONG           cbSig;
    ULONG           cb;

    InitSigBuffer();

    hr = m_pImport->GetTypeSpecFromToken(           
        ts,             // The class ref token.
        &pvSig,
        &cbSig);

    if (FAILED(hr)) Error("GetTypeSpecFromToken failed.", hr);

    if (FAILED(hr = GetOneElementType(pvSig, cbSig, &cb)))
        goto ErrExit;

    VWriteLine("%s\t\tTypeSpec : %s", preFix, (LPSTR)m_sigBuf.Ptr());
ErrExit:
    return;
} // void MDInfo::DisplayTypeSpecInfo()

// Return the passed-in buffer filled with a string detailing the class flags 
// associated with the class.
//

char *MDInfo::ClassFlags(DWORD flags, char *sFlags)
{
    strcpy(sFlags, "");
    ISFLAG(Td, NotPublic);
    ISFLAG(Td, Public);
    ISFLAG(Td, NestedPublic);
    ISFLAG(Td, NestedPrivate);
    ISFLAG(Td, NestedFamily);
    ISFLAG(Td, NestedAssembly);
    ISFLAG(Td, NestedFamANDAssem);
    ISFLAG(Td, NestedFamORAssem);
    ISFLAG(Td, AutoLayout);     
    ISFLAG(Td, SequentialLayout);   
    ISFLAG(Td, ExplicitLayout); 
    ISFLAG(Td, Class);          
    ISFLAG(Td, Interface);      
    ISFLAG(Td, Abstract);           
    ISFLAG(Td, Sealed);         
    ISFLAG(Td, SpecialName);
    ISFLAG(Td, RTSpecialName);
    ISFLAG(Td, Import);         
    ISFLAG(Td, Serializable);                  
    ISFLAG(Td, AnsiClass);      
    ISFLAG(Td, UnicodeClass);
    ISFLAG(Td, AutoClass);      
    // "Reserved" flags
    ISFLAG(Td, HasSecurity);        
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    return sFlags;
} // char *MDInfo::ClassFlags()

// prints out all info on the given typeDef, including all information that
// is specific to a given typedef
//

void MDInfo::DisplayTypeDefInfo(mdTypeDef inTypeDef)
{
    // available under 98 and 99
    DisplayTypeDefProps(inTypeDef);

    // only available under 99, but they'll figure it out

    // Get field layout information.
    HRESULT             hr = NOERROR;
    COR_FIELD_OFFSET    *rFieldOffset = NULL;
    ULONG               cFieldOffset = 0;
    hr = m_pImport->GetClassLayout(inTypeDef, NULL, rFieldOffset, 0, &cFieldOffset, NULL);
    if (SUCCEEDED(hr) && cFieldOffset)
    {
        if (!(rFieldOffset = (COR_FIELD_OFFSET *)_alloca(sizeof(COR_FIELD_OFFSET) * cFieldOffset)))
            Error("_calloc failed.", E_OUTOFMEMORY);
        hr = m_pImport->GetClassLayout(inTypeDef, NULL, rFieldOffset, cFieldOffset, &cFieldOffset, NULL);
        if (FAILED(hr)) Error("GetClassLayout() failed.", hr);
    }

    //No reason to display members if we're displaying fields and methods separately
    DisplayFields(inTypeDef, rFieldOffset, cFieldOffset);
    DisplayMethods(inTypeDef);
    DisplayProperties(inTypeDef);
    DisplayEvents(inTypeDef);
    DisplayMethodImpls(inTypeDef);
    DisplayPermissions(inTypeDef, "");
    
    // available under 98 and 99
    DisplayInterfaceImpls(inTypeDef);
    DisplayCustomAttributes(inTypeDef, "\t");
} // void MDInfo::DisplayTypeDefInfo()

// print out information about every the given typeDef's interaceImpls
//

void MDInfo::DisplayInterfaceImpls(mdTypeDef inTypeDef)
{
    HCORENUM interfaceImplEnum = NULL;
    mdTypeRef interfaceImpls[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;
    
    while(SUCCEEDED(hr = m_pImport->EnumInterfaceImpls( &interfaceImplEnum,
                             inTypeDef,interfaceImpls,NumItems(interfaceImpls), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\tInterfaceImpl #%d (%08x)", totalCount, interfaceImpls[i]);
            WriteLine("\t-------------------------------------------------------");
            DisplayInterfaceImplInfo(interfaceImpls[i]);
            DisplayPermissions(interfaceImpls[i], "\t");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( interfaceImplEnum);
} // void MDInfo::DisplayInterfaceImpls()

// print the information for the given interface implementation
//

void MDInfo::DisplayInterfaceImplInfo(mdInterfaceImpl inImpl)
{
    mdTypeDef typeDef;
    mdToken token;
    HRESULT hr;

    WCHAR szTempBuf[STRING_BUFFER_LEN];

    hr = m_pImport->GetInterfaceImplProps( inImpl, &typeDef, &token);
    if (FAILED(hr)) Error("GetInterfaceImplProps failed.", hr);

    VWriteLine("\t\tClass     : %ls",TypeDeforRefName(typeDef, szTempBuf, NumItems(szTempBuf)));
    VWriteLine("\t\tToken     : %8.8X [%s] %ls",token,TokenTypeName(token), TypeDeforRefName(token, szTempBuf, NumItems(szTempBuf)));

    DisplayCustomAttributes(inImpl, "\t\t");
} // void MDInfo::DisplayInterfaceImplInfo()

// displays the information for a particular property
//

void MDInfo::DisplayPropertyInfo(mdProperty inProp)
{
    HRESULT     hr;
    mdTypeDef   typeDef;
    WCHAR       propName[STRING_BUFFER_LEN];
    DWORD       flags;
    VARIANT     defaultValue;
    void const  *pValue;
    ULONG       cbValue;
    DWORD       dwCPlusTypeFlag;
    mdMethodDef setter, getter, otherMethod[ENUM_BUFFER_SIZE];
    ULONG       others;
    PCCOR_SIGNATURE pbSigBlob;
    ULONG       ulSigBlob;


    ::VariantInit(&defaultValue);

    hr = m_pImport->GetPropertyProps(
        inProp,                 // [IN] property token
        &typeDef,               // [OUT] typedef containing the property declarion.
        
        propName,               // [OUT] Property name
        STRING_BUFFER_LEN,      // [IN] the count of wchar of szProperty
        NULL,                   // [OUT] actual count of wchar for property name
        
        &flags,                 // [OUT] property flags.

        &pbSigBlob,             // [OUT] Signature Blob. 
        &ulSigBlob,             // [OUT] Number of bytes in the signature blob.

        &dwCPlusTypeFlag,       // [OUT] default value
        &pValue,
        &cbValue,

        &setter,                // [OUT] setter method of the property
        &getter,                // [OUT] getter method of the property
        
        otherMethod,            // [OUT] other methods of the property
        ENUM_BUFFER_SIZE,       // [IN] size of rmdOtherMethod
        &others);               // [OUT] total number of other method of this property

    if (FAILED(hr)) Error("GetPropertyProps failed.", hr);

    VWriteLine("\t\tProp.Name : %ls (%8.8X)",propName,inProp);

    char sFlags[STRING_BUFFER_LEN];
    
    strcpy(sFlags, "");
    ISFLAG(Pr, SpecialName);
    ISFLAG(Pr, RTSpecialName);
    ISFLAG(Pr, HasDefault);         
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\t\tFlags     : %s (%08x)", sFlags, flags);

    if (ulSigBlob)
        DisplaySignature(pbSigBlob, ulSigBlob, "");
	else
		VWriteLine("\t\tERROR: no valid signature ");

    WCHAR szTempBuf[STRING_BUFFER_LEN];

    _FillVariant((BYTE)dwCPlusTypeFlag, pValue, &defaultValue);
    VWriteLine("\t\tDefltValue: %ls",VariantAsString(&defaultValue));

    VWriteLine("\t\tSetter    : (%08x) %ls",setter,MemberDeforRefName(setter, szTempBuf, NumItems(szTempBuf)));
    VWriteLine("\t\tGetter    : (%08x) %ls",getter,MemberDeforRefName(getter, szTempBuf, NumItems(szTempBuf))); 

    // do something with others?
    VWriteLine("\t\t%ld Others",others);
    DisplayCustomAttributes(inProp, "\t\t");
} // void MDInfo::DisplayPropertyInfo()

// displays info for each property
//

void MDInfo::DisplayProperties(mdTypeDef inTypeDef)
{
    HCORENUM propEnum = NULL;
    mdProperty props[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;

    
    while(SUCCEEDED(hr = m_pImport->EnumProperties( &propEnum,
                             inTypeDef,props,NumItems(props), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\tProperty #%d", totalCount);
            WriteLine("\t-------------------------------------------------------");
            DisplayPropertyInfo(props[i]);
            DisplayPermissions(props[i], "\t");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( propEnum);
} // void MDInfo::DisplayProperties()

// Display all information about a particular event
//

void MDInfo::DisplayEventInfo(mdEvent inEvent)
{
    HRESULT hr;
    mdTypeDef typeDef;
    WCHAR eventName[STRING_BUFFER_LEN];
    DWORD flags;
    mdToken eventType;
    mdMethodDef addOn, removeOn, fire, otherMethod[ENUM_BUFFER_SIZE];
    ULONG totalOther;


    hr = m_pImport->GetEventProps(
                            // [IN] The scope.
        inEvent,                // [IN] event token
        &typeDef,               // [OUT] typedef containing the event declarion.
        
        eventName,              // [OUT] Event name
        STRING_BUFFER_LEN,      // [IN] the count of wchar of szEvent
        NULL,                   // [OUT] actual count of wchar for event's name

        &flags,                 // [OUT] Event flags.
        &eventType,             // [OUT] EventType class

        &addOn,                 // [OUT] AddOn method of the event
        &removeOn,              // [OUT] RemoveOn method of the event
        &fire,                  // [OUT] Fire method of the event

        otherMethod,            // [OUT] other method of the event
        NumItems(otherMethod),  // [IN] size of rmdOtherMethod
        &totalOther);           // [OUT] total number of other method of this event
    if (FAILED(hr)) Error("GetEventProps failed.", hr);

    VWriteLine("\t\tName      : %ls (%8.8X)",eventName,inEvent);
    
    char sFlags[STRING_BUFFER_LEN];

    strcpy(sFlags, "");
    ISFLAG(Ev, SpecialName); 
    ISFLAG(Ev, RTSpecialName);    
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\t\tFlags     : %s (%08x)", sFlags, flags);

    WCHAR szTempBuf[STRING_BUFFER_LEN];

    VWriteLine("\t\tEventType : %8.8X [%s]",eventType,TokenTypeName(eventType));
    VWriteLine("\t\tAddOnMethd: (%08x) %ls",addOn,MemberDeforRefName(addOn, szTempBuf, NumItems(szTempBuf)));
    VWriteLine("\t\tRmvOnMethd: (%08x) %ls",removeOn,MemberDeforRefName(removeOn, szTempBuf, NumItems(szTempBuf)));
    VWriteLine("\t\tFireMethod: (%08x) %ls",fire,MemberDeforRefName(fire, szTempBuf, NumItems(szTempBuf)));
    
    // todo: do something with these
    VWriteLine("\t\t%ld OtherMethods",totalOther);
    
    DisplayCustomAttributes(inEvent, "\t\t");
} // void MDInfo::DisplayEventInfo()

// Display information about all events in a typedef
// 
void MDInfo::DisplayEvents(mdTypeDef inTypeDef)
{
    HCORENUM eventEnum = NULL;
    mdProperty events[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;

    
    while(SUCCEEDED(hr = m_pImport->EnumEvents( &eventEnum,
                             inTypeDef,events,NumItems(events), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("\tEvent #%d", totalCount);
            WriteLine("\t-------------------------------------------------------");
            DisplayEventInfo(events[i]);
            DisplayPermissions(events[i], "\t");
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( eventEnum);
} // void MDInfo::DisplayEvents()

// returns a string represtenting the name of the type of the custom attribute passed
// in.  Client should sent allocated array into szAttr arg. where the attributes
// of the custom attribute will be placed.
//

char *MDInfo::VariantTypeName(ULONG valueType, char *sAttr)
{
    strcpy(sAttr,"");

    if (valueType & VT_BSTR_BLOB)   strcat(sAttr,"[BSTR_BLOB] ");
    if (valueType & VT_VECTOR)      strcat(sAttr,"[VECTOR] ");
    if (valueType & VT_ARRAY)       strcat(sAttr,"[ARRAY] ");
    if (valueType & VT_BYREF)       strcat(sAttr,"[BYREF] ");
    if (valueType & VT_RESERVED)    strcat(sAttr,"[RESERVED] ");
        
    switch(valueType & VT_TYPEMASK)
    {
    case VT_EMPTY:          strcat(sAttr,"VT_EMPTY"); break;
    case VT_NULL:           strcat(sAttr,"VT_NULL"); break;
    case VT_I2:             strcat(sAttr,"VT_I2"); break;
    case VT_I4:             strcat(sAttr,"VT_I4"); break;
    case VT_R4:             strcat(sAttr,"VT_EMPTY"); break;
    case VT_R8:             strcat(sAttr,"VT_EMPTY"); break;
    case VT_CY:             strcat(sAttr,"VT_R4"); break;
    case VT_DATE:           strcat(sAttr,"VT_DATE"); break;
    case VT_BSTR:           strcat(sAttr,"VT_BSTR"); break;
    case VT_DISPATCH:       strcat(sAttr,"VT_DISPATCH"); break;
    case VT_ERROR:          strcat(sAttr,"VT_ERROR"); break;
    case VT_BOOL:           strcat(sAttr,"VT_BOOL"); break;
    case VT_VARIANT:        strcat(sAttr,"VT_VARIANT"); break;
    case VT_UNKNOWN:        strcat(sAttr,"VT_UNKNOWN"); break;
    case VT_DECIMAL:        strcat(sAttr,"VT_DECIMAL"); break;
    case VT_I1:             strcat(sAttr,"VT_I1"); break;
    case VT_UI1:            strcat(sAttr,"VT_UI1"); break;
    case VT_UI2:            strcat(sAttr,"VT_UI2"); break;
    case VT_UI4:            strcat(sAttr,"VT_UI4"); break;
    case VT_I8:             strcat(sAttr,"VT_I8"); break;
    case VT_UI8:            strcat(sAttr,"VT_UI8"); break;
    case VT_INT:            strcat(sAttr,"VT_INT"); break;
    case VT_UINT:           strcat(sAttr,"VT_UINT"); break;
    case VT_VOID:           strcat(sAttr,"VT_VOID"); break;
    case VT_HRESULT:        strcat(sAttr,"VT_HRESULT"); break;
    case VT_PTR:            strcat(sAttr,"VT_PTR"); break;
    case VT_SAFEARRAY:      strcat(sAttr,"VT_SAFEARRAY"); break;
    case VT_CARRAY:         strcat(sAttr,"VT_CARRAY"); break;
    case VT_USERDEFINED:    strcat(sAttr,"VT_USERDEFINED"); break;
    case VT_LPSTR:          strcat(sAttr,"VT_LPSTR"); break;
    case VT_LPWSTR:         strcat(sAttr,"VT_LPWSTR"); break;
    case VT_RECORD:         strcat(sAttr,"VT_RECORD"); break;
    case VT_FILETIME:       strcat(sAttr,"VT_FILETIME"); break;
    case VT_BLOB:           strcat(sAttr,"VT_BLOB"); break;
    case VT_STREAM:         strcat(sAttr,"VT_STREAM"); break;
    case VT_STORAGE:        strcat(sAttr,"VT_STORAGE"); break;
    case VT_STREAMED_OBJECT:strcat(sAttr,"VT_STREAMED_OBJECT"); break;
    case VT_STORED_OBJECT:  strcat(sAttr,"VT_STORED_OBJECT"); break;
    case VT_BLOB_OBJECT:    strcat(sAttr,"VT_BLOB_OBJECT"); break;
    case VT_CF:             strcat(sAttr,"VT_CF"); break;
    case VT_CLSID:          strcat(sAttr,"VT_CLSID"); break;
    default:                strcat(sAttr,"[Unknown type]");
    }
    return sAttr;
} // char *MDInfo::VariantTypeName()

// print info for the passed-in custom attribute
// This function is used to print the custom attribute information for both TypeDefs and
// MethodDefs which need slightly different formatting.  preFix helps fix it up.
//

void MDInfo::DisplayCustomAttributeInfo(mdCustomAttribute inValue, const char *preFix)
{
    const BYTE  *pValue;                // The custom value.
    ULONG       cbValue;                // Length of the custom value.
    HRESULT     hr;                     // A result.
    mdToken     tkObj;                  // Attributed object.
    mdToken     tkType;                 // Type of the custom attribute.
    mdToken     tk;                     // For name lookup.
    LPCUTF8     pMethName=0;            // Name of custom attribute ctor, if any.
    CQuickBytes qSigName;               // Buffer to pretty-print signature.
    PCCOR_SIGNATURE pSig=0;             // Signature of ctor.
    ULONG       cbSig;                  // Size of the signature.
    BOOL        bCoffSymbol = false;    // true for coff symbol CA's.
    WCHAR       rcName[MAX_CLASS_NAME]; // Name of the type.

    hr = m_pImport->GetCustomAttributeProps( // S_OK or error.
        inValue,                    // The attribute.
        &tkObj,                     // The attributed object
        &tkType,                    // The attributes type.
        (const void**)&pValue,      // Put pointer to data here.
        &cbValue);                  // Put size here.
    if (FAILED(hr)) Error("GetCustomAttributeProps failed.", hr);

    VWriteLine("%s\tCustomAttribute Type: %08x", preFix, tkType);
    
    // Get the name of the memberref or methoddef.
    tk = tkType;
    rcName[0] = L'\0';
    // Get the member name, and the parent token.
    switch (TypeFromToken(tk))
    {
    case mdtMemberRef:
        hr = m_pImport->GetNameFromToken(tk, &pMethName);
        if (FAILED(hr)) Error("GetNameFromToken failed.", hr);
        hr = m_pImport->GetMemberRefProps( tk, &tk, 0, 0, 0, &pSig, &cbSig);
        if (FAILED(hr)) Error("GetMemberRefProps failed.", hr);
        break;
    case mdtMethodDef:
        hr = m_pImport->GetNameFromToken(tk, &pMethName);
        if (FAILED(hr)) Error("GetNameFromToken failed.", hr);
        hr = m_pImport->GetMethodProps(tk, &tk, 0, 0, 0, 0, &pSig, &cbSig, 0, 0);
        if (FAILED(hr)) Error("GetMethodProps failed.", hr);
        break;
    } // switch
    
    // Get the type name.
    switch (TypeFromToken(tk))
    {
    case mdtTypeDef:
        hr = m_pImport->GetTypeDefProps(tk, rcName,MAX_CLASS_NAME,0, 0,0);
        if (FAILED(hr)) Error("GetTypeDefProps failed.", hr);
        break;
    case mdtTypeRef:
        hr = m_pImport->GetTypeRefProps(tk, 0, rcName,MAX_CLASS_NAME,0);
        if (FAILED(hr)) Error("GetTypeRefProps failed.", hr);
        break;
    } // switch
        
    
    if (pSig && pMethName)
    {
        int iLen;
        LPWSTR pwzName = (LPWSTR)_alloca(sizeof(WCHAR)*(iLen=1+strlen(pMethName)));
        WszMultiByteToWideChar(CP_UTF8,0, pMethName,-1, pwzName,iLen);
        PrettyPrintSig(pSig, cbSig, pwzName, &qSigName, m_pImport);
    }

    VWrite("%s\tCustomAttributeName: %ls", preFix, rcName);
    if (pSig && pMethName)
        VWrite(" :: %S", qSigName.Ptr());

    // Keep track of coff overhead.
    if (!wcscmp(L"__DecoratedName", rcName))
    {
        bCoffSymbol = true;
        g_cbCoffNames += cbValue + 6;
    }
    WriteLine("");

    VWriteLine("%s\tLength: %ld", preFix, cbValue);
    char newPreFix[40];
    sprintf(newPreFix, "%s\tValue ", preFix);
    DumpHex(newPreFix, pValue, cbValue);
    if (bCoffSymbol)
        VWriteLine("%s\t            %s", preFix, pValue);

    // Try to decode the constructor blob.  This is incomplete, but covers the most popular cases.
    if (pSig)
    {   // Interpret the signature.
        //@todo: all sig elements
        PCCOR_SIGNATURE ps = pSig;
        ULONG cb;
        ULONG ulData;
        ULONG cParams;
        ULONG ulVal;
        unsigned __int64 uI64;
        double dblVal;
        ULONG cbVal;
        LPCUTF8 pStr;
        CustomAttributeParser CA(pValue, cbValue);
        CA.GetProlog();

        // Get the calling convention.
        cb = CorSigUncompressData(ps, &ulData);
        ps += cb;
        // Get the count of params.
        cb = CorSigUncompressData(ps, &cParams);
        ps += cb;
        // Get the return value.
        cb = CorSigUncompressData(ps, &ulData);
        ps += cb;
        if (ulData == ELEMENT_TYPE_VOID)
        {   
            VWrite("%s\tctor args: (", preFix);
            // For each param...
            for (ULONG i=0; i<cParams; ++i)
            {   // Get the next param type.
                cb = CorSigUncompressData(ps, &ulData);
                ps += cb;
                if (i) Write(", ");
            DoObject:                
                switch (ulData)
                {
                // For ET_OBJECT, the next byte in the blob is the ET of the actual data.
                case ELEMENT_TYPE_OBJECT:
                    ulData = CA.GetU1();
                    goto DoObject;
                case ELEMENT_TYPE_I1:
                case ELEMENT_TYPE_U1:
                    ulVal = CA.GetU1();
                    goto PrintVal;
                case ELEMENT_TYPE_I2:
                case ELEMENT_TYPE_U2:
                    ulVal = CA.GetU2();
                    goto PrintVal;
                case ELEMENT_TYPE_I4:
                case ELEMENT_TYPE_U4:
                    ulVal = CA.GetU4();
                PrintVal:
                VWrite("%d", ulVal);
                    break;
                case ELEMENT_TYPE_STRING:
                    pStr = CA.GetString(&cbVal);
                    VWrite("\"%s\"", pStr);
                    break;
                // The only class type that we accept is Type, which is stored as a string.
                case ELEMENT_TYPE_CLASS:
                    // Eat the class type.
                    cb = CorSigUncompressData(ps, &ulData);
                    ps += cb;
                    // Get the name of the type.
                    pStr = CA.GetString(&cbVal);
                    VWrite("typeof(%s)", pStr);
                    break;
                case SERIALIZATION_TYPE_TYPE:
                    pStr = CA.GetString(&cbVal);
                    VWrite("typeof(%s)", pStr);
                    break;
                case ELEMENT_TYPE_I8:
                case ELEMENT_TYPE_U8:
                    uI64 = CA.GetU8();
                    VWrite("%#lx", uI64);
                    break;
                case ELEMENT_TYPE_R4:
                    dblVal = CA.GetR4();
                    VWrite("%f", dblVal);
                    break;
                case ELEMENT_TYPE_R8:
                    dblVal = CA.GetR8();
                    VWrite("%f", dblVal);
                    break;
                default:
                    // bail...
                    i = cParams;
                    Write(" <can not decode> ");
                    break;
                }
            }
            WriteLine(")");
        }

    }
    WriteLine("");
} // void MDInfo::DisplayCustomAttributeInfo()

// Print all custom values for the given token
// This function is used to print the custom value information for all tokens.
// which need slightly different formatting.  preFix helps fix it up.
//

void MDInfo::DisplayCustomAttributes(mdToken inToken, const char *preFix)
{
    HCORENUM customAttributeEnum = NULL;
    mdTypeRef customAttributes[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;
    
    while(SUCCEEDED(hr = m_pImport->EnumCustomAttributes( &customAttributeEnum, inToken, 0,
                             customAttributes, NumItems(customAttributes), &count)) &&
          count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("%sCustomAttribute #%d (%08x)", preFix, totalCount, customAttributes[i]);
            VWriteLine("%s-------------------------------------------------------", preFix);
            DisplayCustomAttributeInfo(customAttributes[i], preFix);
        }
    }
    m_pImport->CloseEnum( customAttributeEnum);
} // void MDInfo::DisplayCustomAttributes()

//  Show the passed-in token's permissions
//
// avail: 99 only

void MDInfo::DisplayPermissions(mdToken tk, const char *preFix)
{
    HCORENUM permissionEnum = NULL;
    mdPermission permissions[ENUM_BUFFER_SIZE];
    ULONG count, totalCount = 1;
    HRESULT hr;

    
    while (SUCCEEDED(hr = m_pImport->EnumPermissionSets( &permissionEnum,
                     tk, 0, permissions, NumItems(permissions), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("%s\tPermission #%d", preFix, totalCount);
            VWriteLine("%s\t-------------------------------------------------------", preFix);
            DisplayPermissionInfo(permissions[i], preFix);
            WriteLine("");
        }
    }
    m_pImport->CloseEnum( permissionEnum);
} // void MDInfo::DisplayPermissions()

// print properties of given rolecheck
//
// avail 98 and 99

void MDInfo::DisplayPermissionInfo(mdPermission inPermission, const char *preFix)
{
    DWORD dwAction;
    const BYTE *pvPermission;
    ULONG cbPermission;
    char *flagDesc;
    char newPreFix[STRING_BUFFER_LEN];
    HRESULT hr;


    hr = m_pImport->GetPermissionSetProps( inPermission, &dwAction,
                                        (const void**)&pvPermission, &cbPermission);
    if (FAILED(hr)) Error("GetPermissionSetProps failed.", hr);

    switch(dwAction)
    {
    case dclActionNil:          flagDesc = "ActionNil"; break;
    case dclRequest:            flagDesc = "Request"; break;
    case dclDemand:             flagDesc = "Demand"; break;
    case dclAssert:             flagDesc = "Assert"; break;
    case dclDeny:               flagDesc = "Deny"; break;
    case dclPermitOnly:         flagDesc = "PermitOnly"; break;
    case dclLinktimeCheck:      flagDesc = "LinktimeCheck"; break;
    case dclInheritanceCheck:   flagDesc = "InheritanceCheck"; break;
    case dclRequestMinimum:     flagDesc = "RequestMinimum"; break;
    case dclRequestOptional:    flagDesc = "RequestOptional"; break;
    case dclRequestRefuse:      flagDesc = "RequestRefuse"; break;
    case dclPrejitGrant:        flagDesc = "PrejitGrant"; break;
    case dclPrejitDenied:       flagDesc = "PrejitDenied"; break;
    case dclNonCasDemand:       flagDesc = "NonCasDemand"; break;
    case dclNonCasLinkDemand:   flagDesc = "NonCasLinkDemand"; break;
    case dclNonCasInheritance:  flagDesc = "NonCasInheritance"; break;

    }
    VWriteLine("%s\t\tAction    : %s", preFix, flagDesc);
    VWriteLine("%s\t\tBlobLen   : %d", preFix, cbPermission);
    if (cbPermission)
    {
        sprintf(newPreFix, "%s\tBlob", preFix);
        DumpHex(newPreFix, pvPermission, cbPermission, false, 24);
    }

    sprintf (newPreFix, "\t\t%s", preFix);
    DisplayCustomAttributes(inPermission, newPreFix);
} // void MDInfo::DisplayPermissionInfo()


// simply prints out the given GUID in standard form

LPWSTR MDInfo::GUIDAsString(GUID inGuid, LPWSTR guidString, ULONG bufLen)
{
    StringFromGUID2(inGuid, guidString, bufLen);
    return guidString;
} // LPWSTR MDInfo::GUIDAsString()

LPWSTR MDInfo::VariantAsString(VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    if (pVariant->vt == VT_UNKNOWN)
    {
        _ASSERTE(pVariant->punkVal == NULL);
        return (L"<NULL>");
    }
    else if (SUCCEEDED(hr = ::VariantChangeType(pVariant, pVariant, 0, VT_BSTR)))
        return (LPWSTR) pVariant->pbstrVal;
    else if (hr == DISP_E_BADVARTYPE && pVariant->vt == VT_I8)
    {
        // allocate the bstr.
        char    szStr[32];
        WCHAR   wszStr[32];
        // Set variant type to bstr.
        pVariant->vt = VT_BSTR;
        // Create the ansi string.
        sprintf(szStr, "%I64d", pVariant->cyVal.int64);
        // Convert to unicode.
        WszMultiByteToWideChar(CP_ACP, 0, szStr, -1, wszStr, 32);
        // convert to bstr and set variant value.
        pVariant->bstrVal = ::SysAllocString(wszStr);
        if (pVariant->bstrVal == NULL)
            Error("SysAllocString() failed.", E_OUTOFMEMORY);
        return (LPWSTR) pVariant->pbstrVal;
    }
    else
        return (L"ERROR");
    
} // LPWSTR MDInfo::VariantAsString()

void MDInfo::DisplayFieldMarshal(mdToken inToken)
{
    PCCOR_SIGNATURE pvNativeType;     // [OUT] native type of this field
    ULONG       cbNativeType;         // [OUT] the count of bytes of *ppvNativeType
    HRESULT hr;


    hr = m_pImport->GetFieldMarshal( inToken, &pvNativeType, &cbNativeType);
    if (FAILED(hr) && hr != CLDB_E_RECORD_NOTFOUND) Error("GetFieldMarshal failed.", hr);
    if (hr != CLDB_E_RECORD_NOTFOUND)
    {
        ULONG cbCur = 0;
        ULONG ulData;
        ULONG ulStrLoc;

        char szNTDesc[STRING_BUFFER_LEN];

        while (cbCur < cbNativeType)
        {
            ulStrLoc = 0;

            ulData = NATIVE_TYPE_MAX;
            cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "%s ", (ulData < sizeof(g_szNativeType)/sizeof(*g_szNativeType)) ? g_szNativeType[ulData] : "*OUTOFRANGE*");
            switch (ulData)
            {
            case NATIVE_TYPE_FIXEDSYSSTRING:
                {
                    if (cbCur < cbNativeType)
                    {
                        cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{StringElementCount: %d} ",ulData);
                    }
                }
                break;
            case NATIVE_TYPE_FIXEDARRAY:
                {
                    if (cbCur < cbNativeType)
                    {
                        cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{ArrayElementCount: %d",ulData);

                        if (cbCur < cbNativeType)
                        {
                            cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, ", ArrayElementType(NT): %d",ulData);
                        }

                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "}");
                    }
                }
                break;
            case NATIVE_TYPE_ARRAY:
                {
                    if (cbCur < cbNativeType)
                    {
                        BOOL bElemTypeSpecified;

                        cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                        if (ulData != NATIVE_TYPE_MAX)
                        {
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{ArrayElementType(NT): %d", ulData);
                            bElemTypeSpecified = TRUE;
                        }
                        else
                        {
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{");
                            bElemTypeSpecified = FALSE;
                        }

                        if (cbCur < cbNativeType)
                        {
                            if (bElemTypeSpecified)
                                ulStrLoc += sprintf(szNTDesc + ulStrLoc, ", ",ulData);

                            cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "SizeParamIndex: %d",ulData);

                            if (cbCur < cbNativeType)
                            {
                                cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                                ulStrLoc += sprintf(szNTDesc + ulStrLoc, ", SizeParamMultiplier: %d",ulData);

                                if (cbCur < cbNativeType)
                                {
                                    cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                                    ulStrLoc += sprintf(szNTDesc + ulStrLoc, ", SizeConst: %d",ulData);
                                }
                            }
                        }

                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "}");
                    }
                }
                break;
            case NATIVE_TYPE_SAFEARRAY:
                {
                    if (cbCur < cbNativeType)
                    {
                        cbCur += CorSigUncompressData(&pvNativeType[cbCur], &ulData);
                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{SafeArraySubType(VT): %d, ",ulData);

                        // Extract the element type name if it is specified.
                        if (cbCur < cbNativeType)
                        {
                            LPUTF8 strTemp = NULL;
                            int strLen = 0;
                            int ByteCountLength = 0;         

                            strLen = CPackedLen::GetLength(&pvNativeType[cbCur], &ByteCountLength);
                            cbCur += ByteCountLength;
                            strTemp = (LPUTF8)_alloca(strLen + 1);
                            memcpy(strTemp, (LPUTF8)&pvNativeType[cbCur], strLen);
                            strTemp[strLen] = 0;
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "ElementTypeName: %s}", strTemp);
                            cbCur += strLen;
                            _ASSERTE(cbCur == cbNativeType);
                        }
                        else
                        {
                            ulStrLoc += sprintf(szNTDesc + ulStrLoc, "ElementTypeName: }");
                        }
                    }
                }
                break;
            case NATIVE_TYPE_CUSTOMMARSHALER:
                {
                    LPUTF8 strTemp = NULL;
                    int strLen = 0;
                    int ByteCountLength = 0;         

                    // Extract the typelib GUID.
                    strLen = CPackedLen::GetLength(&pvNativeType[cbCur], &ByteCountLength);
                    cbCur += ByteCountLength;
                    strTemp = (LPUTF8)_alloca(strLen + 1);
                    memcpy(strTemp, (LPUTF8)&pvNativeType[cbCur], strLen);
                    strTemp[strLen] = 0;
                    ulStrLoc += sprintf(szNTDesc + ulStrLoc, "{Typelib: %s, ", strTemp);
                    cbCur += strLen;
                    _ASSERTE(cbCur < cbNativeType);

                    // Extract the name of the native type.
                    strLen = CPackedLen::GetLength(&pvNativeType[cbCur], &ByteCountLength);
                    cbCur += ByteCountLength;
                    strTemp = (LPUTF8)_alloca(strLen + 1);
                    memcpy(strTemp, (LPUTF8)&pvNativeType[cbCur], strLen);
                    strTemp[strLen] = 0;
                    ulStrLoc += sprintf(szNTDesc + ulStrLoc, "Native: %s, ", strTemp);
                    cbCur += strLen;
                    _ASSERTE(cbCur < cbNativeType);

                    // Extract the name of the custom marshaler.
                    strLen = CPackedLen::GetLength(&pvNativeType[cbCur], &ByteCountLength);
                    cbCur += ByteCountLength;
                    strTemp = (LPUTF8)_alloca(strLen + 1);
                    memcpy(strTemp, (LPUTF8)&pvNativeType[cbCur], strLen);
                    strTemp[strLen] = 0;
                    ulStrLoc += sprintf(szNTDesc + ulStrLoc, "Marshaler: %s, ", strTemp);
                    cbCur += strLen;
                    _ASSERTE(cbCur < cbNativeType);

                    // Extract the cookie string.
                    strLen = CPackedLen::GetLength(&pvNativeType[cbCur], &ByteCountLength);
                    cbCur += ByteCountLength;
                    if (strLen > 0)
                    {
                        strTemp = (LPUTF8)_alloca(strLen + 1);
                        memcpy(strTemp, (LPUTF8)&pvNativeType[cbCur], strLen);
                        strTemp[strLen] = 0;
                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "Cookie: ");

                        // Copy the cookie string and transform the embedded nulls into \0's.
                        for (int i = 0; i < strLen - 1; i++, cbCur++)
                        {
                            if (strTemp[i] == 0)
                                ulStrLoc += sprintf(szNTDesc + ulStrLoc, "\\0");
                            else
                                szNTDesc[ulStrLoc++] = strTemp[i];
                        }
                        szNTDesc[ulStrLoc++] = strTemp[strLen - 1];
                        cbCur++;
                    }
                    else
                    {
                        ulStrLoc += sprintf(szNTDesc + ulStrLoc, "Cookie: ");
                    }

                    // Finish the custom marshaler native type description.
                    ulStrLoc += sprintf(szNTDesc + ulStrLoc, "}");
                    _ASSERTE(cbCur <= cbNativeType);
                    break;
                }           
                break;
            default:
                {
                    // normal nativetype element: do nothing
                }
            }
            VWriteLine("\t\t\t\t%s",szNTDesc);
            if (ulData >= NATIVE_TYPE_MAX)
                break;
        }
    }
} // void MDInfo::DisplayFieldMarshal()

void MDInfo::DisplayPinvokeInfo(mdToken inToken)
{
    HRESULT hr = NOERROR;
    DWORD flags;
    WCHAR rcImport[512];
    mdModuleRef tkModuleRef;
            
    char sFlags[STRING_BUFFER_LEN];

    hr = m_pImport->GetPinvokeMap(inToken, &flags, rcImport,
                                  NumItems(rcImport), 0, &tkModuleRef);
    if (FAILED(hr))
    {
        if (hr != CLDB_E_RECORD_NOTFOUND)
            VWriteLine("ERROR: GetPinvokeMap failed.", hr);
        return;
    }
                
    WriteLine("\t\tPinvoke Map Data:");
    VWriteLine("\t\tEntry point:      %S", rcImport);
    VWriteLine("\t\tModule ref:       %08x", tkModuleRef);
            
    strcpy(sFlags, "");
    ISFLAG(Pm, NoMangle);           
    ISFLAG(Pm, CharSetNotSpec);
    ISFLAG(Pm, CharSetAnsi);        
    ISFLAG(Pm, CharSetUnicode); 
    ISFLAG(Pm, CharSetAuto);
    ISFLAG(Pm, SupportsLastError);  
    ISFLAG(Pm, CallConvWinapi); 
    ISFLAG(Pm, CallConvCdecl);  
    ISFLAG(Pm, CallConvStdcall);
    ISFLAG(Pm, CallConvThiscall);   
    ISFLAG(Pm, CallConvFastcall);

    ISFLAG(Pm, BestFitEnabled);   
    ISFLAG(Pm, BestFitDisabled);   
    ISFLAG(Pm, BestFitUseAssem);   
    ISFLAG(Pm, ThrowOnUnmappableCharEnabled);   
    ISFLAG(Pm, ThrowOnUnmappableCharDisabled);
    ISFLAG(Pm, ThrowOnUnmappableCharUseAssem);

    if (!*sFlags)
        strcpy(sFlags, "[none]");
        
    VWriteLine("\t\tMapping flags:    %s (%08x)", sFlags, flags);
}   // void MDInfo::DisplayPinvokeInfo()


/////////////////////////////////////////////////////////////////////////
// void DisplaySignature(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob);
//
// Display COM+ signature -- taken from cordump.cpp's DumpSignature
/////////////////////////////////////////////////////////////////////////
void MDInfo::DisplaySignature(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, const char *preFix)
{
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulArgs;
    HRESULT     hr = NOERROR;
    ULONG       ulSigBlobStart = ulSigBlob;

    // initialize sigBuf
    InitSigBuffer();

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    VWriteLine("%s\t\tCallCnvntn: %s", preFix, (g_strCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]));
    if (cb>ulSigBlob) 
        goto ErrExit;
    cbCur += cb;
    ulSigBlob -= cb;

    if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
        VWriteLine("%s\t\thasThis ", preFix);
    if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
        VWriteLine("%s\t\texplicit ", preFix);

    // initialize sigBuf
    InitSigBuffer();
    if ( isCallConv(ulData,IMAGE_CEE_CS_CALLCONV_FIELD) )
    {

        // display field type
        if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
            goto ErrExit;
        VWriteLine("%s\t\tField type: %s", preFix, (LPSTR)m_sigBuf.Ptr());
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;
    }
    else 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulArgs);
        if (cb>ulSigBlob) 
            goto ErrExit;
        cbCur += cb;
        ulSigBlob -= cb;

        if (ulData != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG)
        {
            // display return type when it is not a local varsig
            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;
            VWriteLine("%s\t\tReturnType:%s", preFix, (LPSTR)m_sigBuf.Ptr());
            if (cb>ulSigBlob) 
                goto ErrExit;
            cbCur += cb;
            ulSigBlob -= cb;
        }

        // display count of argument
        // display arguments
        if (ulSigBlob)
            VWriteLine("%s\t\t%ld Arguments", preFix, ulArgs);
        else
            VWriteLine("%s\t\tNo arguments.", preFix);

        ULONG       i = 0;
        while (i < ulArgs && ulSigBlob > 0)
        {
            ULONG       ulData;

            // Handle the sentinal for varargs because it isn't counted in the args.
            CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
            ++i;

            // initialize sigBuf
            InitSigBuffer();

            if (FAILED(hr = GetOneElementType(&pbSigBlob[cbCur], ulSigBlob, &cb)))
                goto ErrExit;

            VWriteLine("%s\t\t\tArgument #%ld: %s",preFix, i, (LPSTR)m_sigBuf.Ptr());
    
            if (cb>ulSigBlob) 
                goto ErrExit;

            cbCur += cb;
            ulSigBlob -= cb;
        }
    }

    // Nothing consumed but not yet counted.
    cb = 0;

ErrExit:
    // We should have consumed all signature blob.  If not, dump the sig in hex.
    //  Also dump in hex if so requested.
    if (m_DumpFilter & dumpMoreHex || ulSigBlob != 0)
    {
        // Did we not consume enough, or try to consume too much?
        if (cb > ulSigBlob)
            WriteLine("\tERROR IN SIGNATURE:  Signature should be larger.");
        else
        if (cb < ulSigBlob)
        {
            VWrite("\tERROR IN SIGNATURE:  Not all of signature blob was consumed.  %d byte(s) remain", ulSigBlob);
            // If it is short, just append it to the end.
            if (ulSigBlob < 4)
            {
                Write(": ");
                for (; ulSigBlob; ++cbCur, --ulSigBlob)
                    VWrite("%02x ", pbSigBlob[cbCur]);
                WriteLine("");
                goto ErrExit2;
            }
            WriteLine("");
        }

        // Any appropriate error message has been issued.  Dump sig in hex, as determined
        //  by error or command line switch.
        cbCur = 0;
        ulSigBlob = ulSigBlobStart;
        char rcNewPrefix[80];
        sprintf(rcNewPrefix, "%s\t\tSignature ", preFix);
        DumpHex(rcNewPrefix, pbSigBlob, ulSigBlob, false, 24);
    }
ErrExit2:
    if (FAILED(hr))
        Error("ERROR!! Bad signature blob value!");
    return;
} // void MDInfo::DisplaySignature()


/////////////////////////////////////////////////////////////////////////
// HRESULT GetOneElementType(mdScope tkScope, BYTE *pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
//
// Adds description of element type to the end of buffer -- caller must ensure
// buffer is large enough.
/////////////////////////////////////////////////////////////////////////
HRESULT MDInfo::GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb)
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbCur = 0;
    ULONG       cb;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iTemp;
    mdToken     tk;

    cb = CorSigUncompressData(pbSigBlob, &ulData);
    cbCur += cb;

    // Handle the modifiers.
    if (ulData & ELEMENT_TYPE_MODIFIER)
    {
        if (ulData == ELEMENT_TYPE_SENTINEL)
            IfFailGo(AddToSigBuffer("<ELEMENT_TYPE_SENTINEL>"));
        else if (ulData == ELEMENT_TYPE_PINNED)
            IfFailGo(AddToSigBuffer("PINNED"));
        else
        {
            hr = E_FAIL;
            goto ErrExit;
        }
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }

    // Handle the underlying element types.
    if (ulData >= ELEMENT_TYPE_MAX) 
    {
        hr = E_FAIL;
        goto ErrExit;
    }
    while (ulData == ELEMENT_TYPE_PTR || ulData == ELEMENT_TYPE_BYREF)
    {
        IfFailGo(AddToSigBuffer(" "));
        IfFailGo(AddToSigBuffer(g_szMapElementType[ulData]));
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
    }
    IfFailGo(AddToSigBuffer(" "));
    IfFailGo(AddToSigBuffer(g_szMapElementType[ulData]));
    if (CorIsPrimitiveType((CorElementType)ulData) || 
        ulData == ELEMENT_TYPE_TYPEDBYREF ||
        ulData == ELEMENT_TYPE_OBJECT ||
        ulData == ELEMENT_TYPE_I ||
        ulData == ELEMENT_TYPE_U ||
        ulData == ELEMENT_TYPE_R)
    {
        // If this is a primitive type, we are done
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_VALUETYPE || 
        ulData == ELEMENT_TYPE_CLASS || 
        ulData == ELEMENT_TYPE_CMOD_REQD ||
        ulData == ELEMENT_TYPE_CMOD_OPT)
    {
        cb = CorSigUncompressToken(&pbSigBlob[cbCur], &tk);
        cbCur += cb;

        // get the name of type ref. Don't care if truncated
        if (TypeFromToken(tk) == mdtTypeDef || TypeFromToken(tk) == mdtTypeRef)
        {
            sprintf(m_tempFormatBuffer, " %ls",TypeDeforRefName(tk, m_szTempBuf, NumItems(m_szTempBuf)));
            IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
        }
        else
        {
            _ASSERTE(TypeFromToken(tk) == mdtTypeSpec);
            sprintf(m_tempFormatBuffer, " %8x", tk);
            IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
        }
        if (ulData == ELEMENT_TYPE_CMOD_REQD ||
            ulData == ELEMENT_TYPE_CMOD_OPT)
        {
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
        }

        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_VALUEARRAY)
    {
        // display the base type of SDARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        // display the size of SDARRAY
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        sprintf(m_tempFormatBuffer, " %d", ulData);
        IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_SZARRAY)
    {
        // display the base type of SZARRAY or GENERICARRAY
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;
        goto ErrExit;
    }
    if (ulData == ELEMENT_TYPE_FNPTR) 
    {
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
        cbCur += cb;
        if (ulData & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
            IfFailGo(AddToSigBuffer(" explicit"));
        if (ulData & IMAGE_CEE_CS_CALLCONV_HASTHIS)
            IfFailGo(AddToSigBuffer(" hasThis"));

        IfFailGo(AddToSigBuffer(" "));
        IfFailGo(AddToSigBuffer(g_strCalling[ulData & IMAGE_CEE_CS_CALLCONV_MASK]));

            // Get number of args
        ULONG numArgs;
        cb = CorSigUncompressData(&pbSigBlob[cbCur], &numArgs);
        cbCur += cb;

            // do return type
        if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
            goto ErrExit;
        cbCur += cb;

        IfFailGo(AddToSigBuffer("("));
        while (numArgs > 0) 
        {
            if (cbCur > ulSigBlob)
                goto ErrExit;
            if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
                goto ErrExit;
            cbCur += cb;
            --numArgs;
            if (numArgs > 0) 
                IfFailGo(AddToSigBuffer(","));
        }
        IfFailGo(AddToSigBuffer(" )"));
        goto ErrExit;
    }

    if(ulData != ELEMENT_TYPE_ARRAY) return E_FAIL;

    // display the base type of SDARRAY
    if (FAILED(GetOneElementType(&pbSigBlob[cbCur], ulSigBlob-cbCur, &cb)))
        goto ErrExit;
    cbCur += cb;

    // display the rank of MDARRAY
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    sprintf(m_tempFormatBuffer, " %d", ulData);
    IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
    if (ulData == 0)
        // we are done if no rank specified
        goto ErrExit;

    // how many dimensions have size specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    sprintf(m_tempFormatBuffer, " %d", ulData);
    IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
    while (ulData)
    {

        cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulTemp);
        sprintf(m_tempFormatBuffer, " %d", ulTemp);
        IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
        cbCur += cb;
        ulData--;
    }
    // how many dimensions have lower bounds specified?
    cb = CorSigUncompressData(&pbSigBlob[cbCur], &ulData);
    cbCur += cb;
    sprintf(m_tempFormatBuffer, " %d", ulData);
    IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
    while (ulData)
    {

        cb = CorSigUncompressSignedInt(&pbSigBlob[cbCur], &iTemp);
        sprintf(m_tempFormatBuffer, " %d", iTemp);
        IfFailGo(AddToSigBuffer(m_tempFormatBuffer));
        cbCur += cb;
        ulData--;
    }
    
ErrExit:
    if (cbCur > ulSigBlob)
        hr = E_FAIL;
    *pcb = cbCur;
    return hr;
} // HRESULT MDInfo::GetOneElementType()

// Display the fields of the N/Direct custom value structure.

void MDInfo::DisplayCorNativeLink(COR_NATIVE_LINK *pCorNLnk, const char *preFix)
{
    // Print the LinkType.
    char *curField = "\tLink Type : ";
    switch(pCorNLnk->m_linkType)
    {
    case nltNone:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nltNone", pCorNLnk->m_linkType);
        break;
    case nltAnsi:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nltAnsi", pCorNLnk->m_linkType);
        break;
    case nltUnicode:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nltUnicode", pCorNLnk->m_linkType);
        break;
    case nltAuto:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nltAuto", pCorNLnk->m_linkType);
        break;
    default:
        _ASSERTE(!"Invalid Native Link Type!");
    }

    // Print the link flags
    curField = "\tLink Flags : ";
    switch(pCorNLnk->m_flags)
    {
    case nlfNone:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nlfNone", pCorNLnk->m_flags);
        break;
    case nlfLastError:
        VWriteLine("%s%s%s(%02x)", preFix, curField, "nlfLastError", pCorNLnk->m_flags);
            break;
    default:
        _ASSERTE(!"Invalid Native Link Flags!");
    }

    // Print the entry point.
    WCHAR memRefName[STRING_BUFFER_LEN];
    HRESULT hr;
    hr = m_pImport->GetMemberRefProps( pCorNLnk->m_entryPoint, NULL, memRefName,
                                    STRING_BUFFER_LEN, NULL, NULL, NULL);
    if (FAILED(hr)) Error("GetMemberRefProps failed.", hr);
    VWriteLine("%s\tEntry Point : %ls (0x%08x)", preFix, memRefName, pCorNLnk->m_entryPoint);
} // void MDInfo::DisplayCorNativeLink()

// Fills given varaint with value given in pValue and of type in bCPlusTypeFlag
//
// Taken from MetaInternal.cpp

HRESULT _FillVariant(
    BYTE        bCPlusTypeFlag, 
    const void  *pValue,
    VARIANT     *pvar) 
{
    HRESULT     hr = NOERROR;
    switch (bCPlusTypeFlag)
    {
    case ELEMENT_TYPE_BOOLEAN:
        pvar->vt = VT_BOOL;
        pvar->boolVal = *((BYTE*)pValue); //*((VARIANT_BOOL *)pValue);
        break;
    case ELEMENT_TYPE_I1:
        pvar->vt = VT_I1;
        pvar->cVal = *((CHAR*)pValue);
        break;  
    case ELEMENT_TYPE_U1:
        pvar->vt = VT_UI1;
        pvar->bVal = *((BYTE*)pValue);
        break;  
    case ELEMENT_TYPE_I2:
        pvar->vt = VT_I2;
        pvar->iVal = *((SHORT*)pValue);
        break;  
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pValue);
        break;  
    case ELEMENT_TYPE_I4:
        pvar->vt = VT_I4;
        pvar->lVal = *((LONG*)pValue);
        break;  
    case ELEMENT_TYPE_U4:
        pvar->vt = VT_UI4;
        pvar->ulVal = *((ULONG*)pValue);
        break;  
    case ELEMENT_TYPE_R4:
        pvar->vt = VT_R4;
        pvar->fltVal = *((FLOAT*)pValue);
        break;  
    case ELEMENT_TYPE_R8:
        pvar->vt = VT_R8;
        pvar->dblVal = *((DOUBLE*)pValue);
        break;  
    case ELEMENT_TYPE_STRING:
        pvar->vt = VT_BSTR;

        // allocated bstr here
        pvar->bstrVal = ::SysAllocString((LPWSTR)pValue);
        if (pvar->bstrVal == NULL)
            hr = E_OUTOFMEMORY;
        break;  
    case ELEMENT_TYPE_CLASS:
        pvar->punkVal = NULL;
        pvar->vt = VT_UNKNOWN;
        _ASSERTE( *((IUnknown **)pValue) == NULL );
        break;  
    case ELEMENT_TYPE_I8:
        pvar->vt = VT_I8;
        pvar->cyVal.int64 = *((LONGLONG*)pValue);
        break;
    case ELEMENT_TYPE_U8:
        pvar->vt = VT_UI8;
        pvar->cyVal.int64 = *((LONGLONG*)pValue);
        break;
    case ELEMENT_TYPE_VOID:
        pvar->vt = VT_EMPTY;
        break;
    default:
        _ASSERTE(!"bad constant value type!");
    }

    return hr;
} // HRESULT _FillVariant()

void MDInfo::DisplayAssembly()
{
    if (m_pAssemblyImport) 
    {
        DisplayAssemblyInfo();
        DisplayAssemblyRefs();
        DisplayFiles();
        DisplayExportedTypes();
        DisplayManifestResources();
    }
} // void MDInfo::DisplayAssembly()

void MDInfo::DisplayAssemblyInfo()
{
    HRESULT         hr;
    mdAssembly      mda;
    const BYTE      *pbPublicKey;
    ULONG           cbPublicKey;
    ULONG           ulHashAlgId;
    WCHAR           szName[STRING_BUFFER_LEN];
    ASSEMBLYMETADATA MetaData;
    DWORD           dwFlags;

    hr = m_pAssemblyImport->GetAssemblyFromScope(&mda);
    if (hr == CLDB_E_RECORD_NOTFOUND)
        return;
    else if (FAILED(hr)) Error("GetAssemblyFromScope() failed.", hr);

    // Get the required sizes for the arrays of locales, processors etc.
    ZeroMemory(&MetaData, sizeof(ASSEMBLYMETADATA));
    hr = m_pAssemblyImport->GetAssemblyProps(mda, 
                                             NULL, NULL,    // Public Key.
                                             NULL,          // Hash Algorithm.
                                             NULL, 0, NULL, // Name.
                                             &MetaData,
                                             NULL);         // Flags.
    if (FAILED(hr)) Error("GetAssemblyProps() failed.", hr);

    // Allocate space for the arrays in the ASSEMBLYMETADATA structure.
    if (MetaData.cbLocale)
        MetaData.szLocale = (WCHAR *)_alloca(sizeof(WCHAR) * MetaData.cbLocale);
    if (MetaData.ulProcessor)
        MetaData.rProcessor = (DWORD *)_alloca(sizeof(DWORD) * MetaData.ulProcessor);
    if (MetaData.ulOS)
        MetaData.rOS = (OSINFO *)_alloca(sizeof(OSINFO) * MetaData.ulOS);

    hr = m_pAssemblyImport->GetAssemblyProps(mda, 
                                             (const void **)&pbPublicKey, &cbPublicKey,
                                             &ulHashAlgId,
                                             szName, STRING_BUFFER_LEN, NULL,
                                             &MetaData,
                                             &dwFlags);
    if (FAILED(hr)) Error("GetAssemblyProps() failed.", hr);
    WriteLine("Assembly");
    WriteLine("-------------------------------------------------------");
    VWriteLine("\tToken: 0x%08x", mda);
    VWriteLine("\tName : %ls", szName);
    DumpHex("\tPublic Key    ", pbPublicKey, cbPublicKey, false, 24);
    VWriteLine("\tHash Algorithm : 0x%08x", ulHashAlgId);
    DisplayASSEMBLYMETADATA(&MetaData);

    char sFlags[STRING_BUFFER_LEN];
    DWORD flags = dwFlags;

    strcpy(sFlags, "");
    ISFLAG(Af, SideBySideCompatible);
    ISFLAG(Af, NonSideBySideAppDomain);
    ISFLAG(Af, NonSideBySideProcess);
    ISFLAG(Af, NonSideBySideMachine);
    ISFLAG(Af, PublicKey);
    ISFLAG(Af, Retargetable);
    ISFLAG(Af, EnableJITcompileTracking);
    ISFLAG(Af, DisableJITcompileOptimizer);
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\tFlags : %s (%08x)", sFlags, dwFlags);
    DisplayCustomAttributes(mda, "\t");
    DisplayPermissions(mda, "\t");
    WriteLine("");
}   // void MDInfo::DisplayAssemblyInfo()

void MDInfo::DisplayAssemblyRefs()
{
    HCORENUM        assemblyRefEnum = NULL;
    mdAssemblyRef   AssemblyRefs[ENUM_BUFFER_SIZE];
    ULONG           count;
    ULONG           totalCount = 1;
    HRESULT         hr;

    while (SUCCEEDED(hr = m_pAssemblyImport->EnumAssemblyRefs( &assemblyRefEnum,
                             AssemblyRefs, NumItems(AssemblyRefs), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("AssemblyRef #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayAssemblyRefInfo(AssemblyRefs[i]);
            WriteLine("");
        }
    }
    m_pAssemblyImport->CloseEnum(assemblyRefEnum);
}   // void MDInfo::DisplayAssemblyRefs()

void MDInfo::DisplayAssemblyRefInfo(mdAssemblyRef inAssemblyRef)
{
    HRESULT         hr;
    const BYTE      *pbPublicKeyOrToken;
    ULONG           cbPublicKeyOrToken;
    WCHAR           szName[STRING_BUFFER_LEN];
    ASSEMBLYMETADATA MetaData;
    const BYTE      *pbHashValue;
    ULONG           cbHashValue;
    DWORD           dwFlags;
    
    VWriteLine("\tToken: 0x%08x", inAssemblyRef);

    // Get sizes for the arrays in the ASSEMBLYMETADATA structure.
    ZeroMemory(&MetaData, sizeof(ASSEMBLYMETADATA));
    hr = m_pAssemblyImport->GetAssemblyRefProps(inAssemblyRef,
                                             NULL, NULL,    // Public Key or Token.
                                             NULL, 0, NULL, // Name.
                                             &MetaData,
                                             NULL, NULL,    // HashValue.
                                             NULL);         // Flags.
    if (FAILED(hr)) Error("GetAssemblyRefProps() failed.", hr);
    
    // Allocate space for the arrays in the ASSEMBLYMETADATA structure.
    if (MetaData.cbLocale)
        MetaData.szLocale = (WCHAR *)_alloca(sizeof(WCHAR) * MetaData.cbLocale);
    if (MetaData.ulProcessor)
        MetaData.rProcessor = (DWORD *)_alloca(sizeof(DWORD) * MetaData.ulProcessor);
    if (MetaData.ulOS)
        MetaData.rOS = (OSINFO *)_alloca(sizeof(OSINFO) * MetaData.ulOS);

    hr = m_pAssemblyImport->GetAssemblyRefProps(inAssemblyRef,
                                             (const void **)&pbPublicKeyOrToken, &cbPublicKeyOrToken,
                                             szName, STRING_BUFFER_LEN, NULL,
                                             &MetaData,
                                             (const void **)&pbHashValue, &cbHashValue,
                                             &dwFlags);
    if (FAILED(hr)) Error("GetAssemblyRefProps() failed.", hr);

    DumpHex("\tPublic Key or Token", pbPublicKeyOrToken, cbPublicKeyOrToken, false, 24);
    VWriteLine("\tName: %ls", szName);
    DisplayASSEMBLYMETADATA(&MetaData);
    DumpHex("\tHashValue Blob", pbHashValue, cbHashValue, false, 24);

    char sFlags[STRING_BUFFER_LEN];
    DWORD flags = dwFlags;

    strcpy(sFlags, "");
    ISFLAG(Af, PublicKey);     
    ISFLAG(Af, Retargetable);
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\tFlags: %s (%08x)", sFlags, dwFlags);
    DisplayCustomAttributes(inAssemblyRef, "\t");
    WriteLine("");
}   // void MDInfo::DisplayAssemblyRefInfo()

void MDInfo::DisplayFiles()
{
    HCORENUM        fileEnum = NULL;
    mdFile          Files[ENUM_BUFFER_SIZE];
    ULONG           count;
    ULONG           totalCount = 1;
    HRESULT         hr;

    while (SUCCEEDED(hr = m_pAssemblyImport->EnumFiles( &fileEnum,
                             Files, NumItems(Files), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("File #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayFileInfo(Files[i]);
            WriteLine("");
        }
    }
    m_pAssemblyImport->CloseEnum(fileEnum);
}   // void MDInfo::DisplayFiles()

void MDInfo::DisplayFileInfo(mdFile inFile)
{
    HRESULT         hr;
    WCHAR           szName[STRING_BUFFER_LEN];
    const BYTE      *pbHashValue;
    ULONG           cbHashValue;
    DWORD           dwFlags;

    VWriteLine("\tToken: 0x%08x", inFile);

    hr = m_pAssemblyImport->GetFileProps(inFile,
                                         szName, STRING_BUFFER_LEN, NULL,
                                         (const void **)&pbHashValue, &cbHashValue,
                                         &dwFlags);
    if (FAILED(hr)) Error("GetFileProps() failed.", hr);
    VWriteLine("\tName : %ls", szName);
    DumpHex("\tHashValue Blob ", pbHashValue, cbHashValue, false, 24);

    char sFlags[STRING_BUFFER_LEN];
    DWORD flags = dwFlags;

    strcpy(sFlags, "");
    ISFLAG(Ff, ContainsMetaData);      
    ISFLAG(Ff, ContainsNoMetaData);      
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\tFlags : %s (%08x)", sFlags, dwFlags);
    DisplayCustomAttributes(inFile, "\t");
    WriteLine("");

}   // MDInfo::DisplayFileInfo()

void MDInfo::DisplayExportedTypes()
{
    HCORENUM        comTypeEnum = NULL;
    mdExportedType       ExportedTypes[ENUM_BUFFER_SIZE];
    ULONG           count;
    ULONG           totalCount = 1;
    HRESULT         hr;

    while (SUCCEEDED(hr = m_pAssemblyImport->EnumExportedTypes( &comTypeEnum,
                             ExportedTypes, NumItems(ExportedTypes), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("ExportedType #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayExportedTypeInfo(ExportedTypes[i]);
            WriteLine("");
        }
    }
    m_pAssemblyImport->CloseEnum(comTypeEnum);
}   // void MDInfo::DisplayExportedTypes()

void MDInfo::DisplayExportedTypeInfo(mdExportedType inExportedType)
{
    HRESULT         hr;
    WCHAR           szName[STRING_BUFFER_LEN];
    mdToken         tkImplementation;
    mdTypeDef       tkTypeDef;
    DWORD           dwFlags;
    char            sFlags[STRING_BUFFER_LEN];

    VWriteLine("\tToken: 0x%08x", inExportedType);

    hr = m_pAssemblyImport->GetExportedTypeProps(inExportedType,
                                            szName, STRING_BUFFER_LEN, NULL,
                                            &tkImplementation,
                                            &tkTypeDef,
                                            &dwFlags);
    if (FAILED(hr)) Error("GetExportedTypeProps() failed.", hr);
    VWriteLine("\tName: %ls", szName);
    VWriteLine("\tImplementation token: 0x%08x", tkImplementation);
    VWriteLine("\tTypeDef token: 0x%08x", tkTypeDef);
    VWriteLine("\tFlags     : %s (%08x)",ClassFlags(dwFlags, sFlags), dwFlags);
    DisplayCustomAttributes(inExportedType, "\t");
    WriteLine("");
}   // void MDInfo::DisplayExportedTypeInfo()

void MDInfo::DisplayManifestResources()
{
    HCORENUM        manifestResourceEnum = NULL;
    mdManifestResource ManifestResources[ENUM_BUFFER_SIZE];
    ULONG           count;
    ULONG           totalCount = 1;
    HRESULT         hr;

    while (SUCCEEDED(hr = m_pAssemblyImport->EnumManifestResources( &manifestResourceEnum,
                             ManifestResources, NumItems(ManifestResources), &count)) &&
            count > 0)
    {
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            VWriteLine("ManifestResource #%d", totalCount);
            WriteLine("-------------------------------------------------------");
            DisplayManifestResourceInfo(ManifestResources[i]);
            WriteLine("");
        }
    }
    m_pAssemblyImport->CloseEnum(manifestResourceEnum);
}   // void MDInfo::DisplayManifestResources()

void MDInfo::DisplayManifestResourceInfo(mdManifestResource inManifestResource)
{
    HRESULT         hr;
    WCHAR           szName[STRING_BUFFER_LEN];
    mdToken         tkImplementation;
    DWORD           dwOffset;
    DWORD           dwFlags;

    VWriteLine("\tToken: 0x%08x", inManifestResource);

    hr = m_pAssemblyImport->GetManifestResourceProps(inManifestResource,
                                                     szName, STRING_BUFFER_LEN, NULL,
                                                     &tkImplementation,
                                                     &dwOffset,
                                                     &dwFlags);
    if (FAILED(hr)) Error("GetManifestResourceProps() failed.", hr);
    VWriteLine("Name: %ls", szName);
    VWriteLine("Implementation token: 0x%08x", tkImplementation);
    VWriteLine("Offset: 0x%08x", dwOffset);

    char sFlags[STRING_BUFFER_LEN];
    DWORD flags = dwFlags;

    strcpy(sFlags, "");
    ISFLAG(Mr, Public);     
    ISFLAG(Mr, Private);            
    if (!*sFlags)
        strcpy(sFlags, "[none]");

    VWriteLine("\tFlags: %s (%08x)", sFlags, dwFlags);
    DisplayCustomAttributes(inManifestResource, "\t");
    WriteLine("");
}   // void MDInfo::DisplayManifestResourceInfo()

void MDInfo::DisplayASSEMBLYMETADATA(ASSEMBLYMETADATA *pMetaData)
{
    ULONG           i;

    VWriteLine("\tMajor Version: 0x%08x", pMetaData->usMajorVersion);
    VWriteLine("\tMinor Version: 0x%08x", pMetaData->usMinorVersion);
    VWriteLine("\tBuild Number: 0x%08x", pMetaData->usBuildNumber);
    VWriteLine("\tRevision Number: 0x%08x", pMetaData->usRevisionNumber);
    VWriteLine("\tLocale: %ls", pMetaData->cbLocale ? pMetaData->szLocale : L"<null>");
    for (i = 0; i < pMetaData->ulProcessor; i++)
        VWriteLine("\tProcessor #%ld: 0x%08x", i+1, pMetaData->rProcessor[i]);
    for (i = 0; i < pMetaData->ulOS; i++)
    {
        VWriteLine("\tOS #%ld:", i+1);
        VWriteLine("\t\tOS Platform ID: 0x%08x", pMetaData->rOS[i].dwOSPlatformId);
        VWriteLine("\t\tOS Major Version: 0x%08x", pMetaData->rOS[i].dwOSMajorVersion);
        VWriteLine("\t\tOS Minor Version: 0x%08x", pMetaData->rOS[i].dwOSMinorVersion);
    }
}   // void MDInfo::DisplayASSEMBLYMETADATA()

void MDInfo::DisplayUserStrings()
{
    HCORENUM    stringEnum = NULL;      // string enumerator.
    mdString    Strings[ENUM_BUFFER_SIZE]; // String tokens from enumerator.
    CQuickArray<WCHAR> rUserString;     // Buffer to receive string.
    WCHAR       *szUserString;          // Working pointer into buffer.
    ULONG       chUserString;           // Size of user string.
    CQuickArray<char> rcBuf;            // Buffer to hold the BLOB version of the string.
    char        *szBuf;                 // Working pointer into buffer.
    ULONG       chBuf;                  // Saved size of the user string.
    ULONG       count;                  // Items returned from enumerator.
    ULONG       totalCount = 1;         // Running count of strings.
    bool        bUnprint = false;       // Is an unprintable character found?
    HRESULT     hr;                     // A result.

    while (SUCCEEDED(hr = m_pImport->EnumUserStrings( &stringEnum,
                             Strings, NumItems(Strings), &count)) &&
            count > 0)
    {
        if (totalCount == 1)
        {   // If only one, it is the NULL string, so don't print it.
            WriteLine("User Strings");
            WriteLine("-------------------------------------------------------");
        }
        for (ULONG i = 0; i < count; i++, totalCount++)
        {
            do { // Try to get the string into the existing buffer.
                hr = m_pImport->GetUserString( Strings[i], rUserString.Ptr(),rUserString.MaxSize(), &chUserString);
                if (hr == CLDB_S_TRUNCATION)
                {   // Buffer wasn't big enough, try to enlarge it.
                    if (FAILED(rUserString.ReSize(chUserString)))
                        Error("malloc failed.", E_OUTOFMEMORY);
                    continue;
                }
            } while (0);
            if (FAILED(hr)) Error("GetUserString failed.", hr);

            szUserString = rUserString.Ptr();
            chBuf = chUserString;

            VWrite("%08x : (%2d) L\"", Strings[i], chUserString);
            while (chUserString)
            {   
                switch (*szUserString)
                {
                case 0:
                    Write("\\0"); break;
                case L'\r':
                    Write("\\r"); break;
                case L'\n':
                    Write("\\n"); break;
                case L'\t':
                    Write("\\t"); break;
                default:
                    if (iswprint(*szUserString))
                        VWrite("%lc", *szUserString);
                    else 
                    {
                        bUnprint = true;
                        Write(".");
                    }
                    break;
                }
                ++szUserString;
                --chUserString;
            }
            WriteLine("\"");

            // Print the user string as a blob if an unprintable character is found.
            if (bUnprint)
            {
                bUnprint = false;
                szUserString = rUserString.Ptr();
                rcBuf.ReSize(chBuf * 5 + 1);
                szBuf = rcBuf.Ptr();
                ULONG j;
                for (j = 0; j < chBuf; j++)
                    sprintf (&szBuf[j*5], "%04x ", szUserString[j]);
                szBuf[j*5] = '\0';
                WriteLine("\t\tUser string has unprintables, hex format below:");
                VWriteLine("\t\t%s", szBuf);
            }
        }
    }
    if (stringEnum)
        m_pImport->CloseEnum(stringEnum);
}   // void MDInfo::DisplayUserStrings()

void MDInfo::DisplayUnsatInfo()
{
    HRESULT     hr = S_OK;

    HCORENUM henum = 0;
    mdToken  tk;
    ULONG cMethods;

    Write("\nUnresolved Externals\n");
    Write("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");

    while ( (hr = m_pImport->EnumUnresolvedMethods(
        &henum, 
        &tk, 
        1, 
        &cMethods)) == S_OK && cMethods )
    {
        if ( TypeFromToken(tk) == mdtMethodDef )
        {
            // a method definition without implementation
            DisplayMethodInfo( tk );
        }
        else if ( TypeFromToken(tk) == mdtMemberRef )
        {
            // an unresolved MemberRef to a global function 
            DisplayMemberRefInfo( tk, "" );
        }
        else
        { 
            _ASSERTE(!"Unknown token kind!");
        }
    }
    m_pImport->CloseEnum(henum);
} // void MDInfo::DisplayUnsatInfo()

//*******************************************************************************
// This code is used for debugging purposes only.  This will just print out the
// entire database.
//*******************************************************************************
const char *MDInfo::DumpRawNameOfType(ULONG iType)
{
    if (iType <= iRidMax)
    {
        const char *pNameTable;
        m_pTables->GetTableInfo(iType, 0,0,0,0, &pNameTable);
        return pNameTable;
    }
    else
    // Is the field a coded token?
    if (iType <= iCodedTokenMax)
    {
        int iCdTkn = iType - iCodedToken;
        const char *pNameCdTkn;
        m_pTables->GetCodedTokenInfo(iCdTkn, 0,0, &pNameCdTkn);
        return pNameCdTkn;
    }

    // Fixed type.
    switch (iType)
    {
    case iBYTE:
        return "BYTE";
    case iSHORT:
        return "short";
    case iUSHORT:
        return "USHORT";
    case iLONG:
        return "long";
    case iULONG:
        return "ULONG";
    case iSTRING:
        return "string";
    case iGUID:
        return "GUID";
    case iBLOB:
        return "blob";
    }
    // default:
    static char buf[30];
    sprintf(buf, "unknown type 0x%02x", iType);
    return buf;
} // const char *MDInfo::DumpRawNameOfType()

void MDInfo::DumpRawCol(ULONG ixTbl, ULONG ixCol, ULONG rid, bool bStats)
{
    ULONG       ulType;                 // Type of a column.
    ULONG       ulVal;                  // Value of a column.
    LPCUTF8     pString;                // Pointer to a string.
    const void  *pBlob;                 // Pointer to a blob.
    ULONG       cb;                     // Size of something.

    m_pTables->GetColumn(ixTbl, ixCol, rid, &ulVal);
    m_pTables->GetColumnInfo(ixTbl, ixCol, 0, 0, &ulType, 0);

    if (ulType <= iRidMax)
    {
        const char *pNameTable;
        m_pTables->GetTableInfo(ulType, 0,0,0,0, &pNameTable);
        VWrite("%s[%x]", pNameTable, ulVal);
    }
    else
    // Is the field a coded token?
    if (ulType <= iCodedTokenMax)
    {
        int iCdTkn = ulType - iCodedToken; 
        const char *pNameCdTkn;
        m_pTables->GetCodedTokenInfo(iCdTkn, 0,0, &pNameCdTkn);
        VWrite("%s[%08x]", pNameCdTkn, ulVal);
    }
    else
    {
        // Fixed type.
        switch (ulType)
        {
        case iBYTE:
            VWrite("%02x", ulVal);
            break;
        case iSHORT:
        case iUSHORT:
            VWrite("%04x", ulVal);
            break;
        case iLONG:
        case iULONG:
            VWrite("%08x", ulVal);
            break;
        case iSTRING:
            VWrite("string#%x", ulVal);
            if (bStats && ulVal)
            {
                m_pTables->GetString(ulVal, &pString);
                cb = strlen(pString) + 1;
                VWrite("(%d)", cb);
            }
            break;
        case iGUID:
            VWrite("guid#%x", ulVal);
            if (bStats && ulVal)
            {
                VWrite("(16)");
            }
            break;
        case iBLOB:
            VWrite("blob#%x", ulVal);
            if (bStats && ulVal)
            {
                m_pTables->GetBlob(ulVal, &cb, &pBlob);
                cb += 1;
                if (cb > 128)
                    cb += 1;
                if (cb > 16535)
                    cb += 1;
                VWrite("(%d)", cb);
            }
            break;
        default:
            VWrite("unknown type 0x%04x", ulVal);
            break;
        }
    }
} // void MDInfo::DumpRawCol()

ULONG MDInfo::DumpRawColStats(ULONG ixTbl, ULONG ixCol, ULONG cRows)
{
    ULONG rslt = 0;
    ULONG       ulType;                 // Type of a column.
    ULONG       ulVal;                  // Value of a column.
    LPCUTF8     pString;                // Pointer to a string.
    const void  *pBlob;                 // Pointer to a blob.
    ULONG       cb;                     // Size of something.

    m_pTables->GetColumnInfo(ixTbl, ixCol, 0, 0, &ulType, 0);

    if (IsHeapType(ulType))
    {
        for (ULONG rid=1; rid<=cRows; ++rid)
        {
            m_pTables->GetColumn(ixTbl, ixCol, rid, &ulVal);
            // Fixed type.
            switch (ulType)
            {
            case iSTRING:
                if (ulVal)
                {
                    m_pTables->GetString(ulVal, &pString);
                    cb = strlen(pString);
                    rslt += cb + 1;
                }
                break;
            case iGUID:
                if (ulVal)
                    rslt += 16;
                break;
            case iBLOB:
                if (ulVal)
                {
                    m_pTables->GetBlob(ulVal, &cb, &pBlob);
                    rslt += cb + 1;
                    if (cb > 128)
                        rslt += 1;
                    if (cb > 16535)
                        rslt += 1;
                }
                break;
            default:
                break;
            }
        }
    }
    return rslt;
} // ULONG MDInfo::DumpRawColStats()

int MDInfo::DumpHex(
    const char  *szPrefix,              // String prefix for first line.
    const void  *pvData,                // The data to print.
    ULONG       cbData,                 // Bytes of data to print.
    int         bText,                  // If true, also dump text.
    ULONG       nLine)                  // Bytes per line to print.
{
    const BYTE  *pbData = static_cast<const BYTE*>(pvData);
    ULONG       i;                      // Loop control.
    ULONG       nPrint;                 // Number to print in an iteration.
    ULONG       nSpace;                 // Spacing calculations.
    ULONG       nPrefix;                // Size of the prefix.
    ULONG       nLines=0;               // Number of lines printed.
    const char  *pPrefix;               // For counting spaces in the prefix.

    // Round down to 8 characters.
    nLine = nLine & ~0x7;

    for (nPrefix=0, pPrefix=szPrefix; *pPrefix; ++pPrefix)
    {
        if (*pPrefix == '\t')
            nPrefix = (nPrefix + 8) & ~7;
        else
            ++nPrefix;
    }
    //nPrefix = strlen(szPrefix);
    do 
    {   // Write the line prefix.
        if (szPrefix)
            VWrite("%s:", szPrefix);
        else
            VWrite("%*s:", nPrefix, "");
        szPrefix = 0;
        ++nLines;

        // Calculate spacing.
        nPrint = min(cbData, nLine);
        nSpace = nLine - nPrint;

            // dump in hex.
        for(i=0; i<nPrint; i++)
            {
            if ((i&7) == 0)
                    Write(" ");
            VWrite("%02x ", pbData[i]);
            }
        if (bText)
        {
            // Space out to the text spot.
            if (nSpace)
                VWrite("%*s", nSpace*3+nSpace/8, "");
            // Dump in text.
            Write(">");
            for(i=0; i<nPrint; i++)
                VWrite("%c", (isprint(pbData[i])) ? pbData[i] : ' ');
            // Space out the text, and finish the line.
            VWrite("%*s<", nSpace, "");
        }
        VWriteLine("");

        // Next data to print.
        cbData -= nPrint;
        pbData += nPrint;
        }
    while (cbData > 0);

    return nLines;
} // int MDInfo::DumpHex()

void MDInfo::DumpRawHeaps()
{
    HRESULT     hr;                     // A result.
    ULONG       ulSize;                 // Bytes in a heap.
    const BYTE  *pData;                 // Pointer to a blob.
    ULONG       cbData;                 // Size of a blob.
    ULONG       oData;                  // Offset of current blob.
    char        rcPrefix[30];           // To format line prefix.

    m_pTables->GetBlobHeapSize(&ulSize);
    VWriteLine("");
    VWriteLine("Blob Heap:  %d(%#x) bytes", ulSize,ulSize);
    oData = 0;
    do 
    {
        m_pTables->GetBlob(oData, &cbData, (const void**)&pData);
        sprintf(rcPrefix, "%5x,%-2x", oData, cbData);
        DumpHex(rcPrefix, pData, cbData);
        hr = m_pTables->GetNextBlob(oData, &oData);
    }
    while (hr == S_OK);

    m_pTables->GetStringHeapSize(&ulSize);
    VWriteLine("");
    VWriteLine("String Heap:  %d(%#x) bytes", ulSize,ulSize);
    oData = 0;
    const char *pString;
    do 
    {
        m_pTables->GetString(oData, &pString);
        if (m_DumpFilter & dumpMoreHex)
        {
            sprintf(rcPrefix, "%08x", oData);
            DumpHex(rcPrefix, pString, strlen(pString)+1);
        }
        else
        if (*pString != 0)
            VWrite("%08x: %s\n", oData, pString);
        hr = m_pTables->GetNextString(oData, &oData);
    }
    while (hr == S_OK);
    VWriteLine("");
    
    DisplayUserStrings();

} // void MDInfo::DumpRawHeaps()


void MDInfo::DumpRaw(int iDump, bool bStats)
{
    ULONG       cTables;                // Tables in the database.
    ULONG       cCols;                  // Columns in a table.
    ULONG       cRows;                  // Rows in a table.
    ULONG       cbRow;                  // Bytes in a row of a table.
    ULONG       iKey;                   // Key column of a table.
    const char  *pNameTable;            // Name of a table.
    ULONG       oCol;                   // Offset of a column.
    ULONG       cbCol;                  // Size of a column.
    ULONG       ulType;                 // Type of a column.
    const char  *pNameColumn;           // Name of a column.
    ULONG       ulSize;

    m_pTables->GetNumTables(&cTables);

    m_pTables->GetStringHeapSize(&ulSize);
    VWrite("Strings: %d(%#x)", ulSize, ulSize);
    m_pTables->GetBlobHeapSize(&ulSize);
    VWrite(", Blobs: %d(%#x)", ulSize, ulSize);
    m_pTables->GetGuidHeapSize(&ulSize);
    VWrite(", Guids: %d(%#x)", ulSize, ulSize);
    m_pTables->GetUserStringHeapSize(&ulSize);
    VWriteLine(", User strings: %d(%#x)", ulSize, ulSize);

    for (ULONG ixTbl = 0; ixTbl < cTables; ++ixTbl)
    {
        m_pTables->GetTableInfo(ixTbl, &cbRow, &cRows, &cCols, &iKey, &pNameTable);

        if (cRows == 0 && iDump < 3)
            continue;

        if (iDump >= 2)
            VWriteLine("=================================================");
        VWriteLine("%2d: %-20s cRecs:%5d(%#x), cbRec:%3d(%#x), cbTable:%6d(%#x)",
            ixTbl, pNameTable, cRows, cRows, cbRow, cbRow, cbRow * cRows, cbRow * cRows);

        if (iDump < 2)
            continue;

        // Dump column definitions for the table.
        for (ULONG ixCol=0; ixCol<cCols; ++ixCol)
        {
            m_pTables->GetColumnInfo(ixTbl, ixCol, &oCol, &cbCol, &ulType, &pNameColumn);

            VWrite("  col %2x:%c %-12s oCol:%2x, cbCol:%x, %-7s",
                ixCol, ((ixCol==iKey)?'*':' '), pNameColumn, oCol, cbCol, DumpRawNameOfType(ulType));

            if (bStats)
            {
                ulSize = DumpRawColStats(ixTbl, ixCol, cRows);
                if (ulSize)
                    VWrite("(%d)", ulSize);
            }
            VWriteLine("");
        }

        if (iDump < 3) 
            continue;

        // Dump the rows.
        for (ULONG rid = 1; rid <= cRows; ++rid)
        {
            if (rid == 1)
                VWriteLine("-------------------------------------------------");
            VWrite(" %3x == ", rid);
            for (ixCol=0; ixCol < cCols; ++ixCol)
            {
                if (ixCol) VWrite(", ");
                VWrite("%d:", ixCol);
                DumpRawCol(ixTbl, ixCol, rid, bStats);
            }
            VWriteLine("");
        }
    }

    if (m_DumpFilter & dumpRawHeaps)
        DumpRawHeaps();

} // void MDInfo::DumpRaw()

void MDInfo::DumpRawCSV()
{
    ULONG       cTables;                // Tables in the database.
    ULONG       cCols;                  // Columns in a table.
    ULONG       cRows;                  // Rows in a table.
    ULONG       cbRow;                  // Bytes in a row of a table.
    const char  *pNameTable;            // Name of a table.
    ULONG       ulSize;

    m_pTables->GetNumTables(&cTables);

    VWriteLine("Name,Size,cRecs,cbRec");

    m_pTables->GetStringHeapSize(&ulSize);
    VWriteLine("Strings,%d", ulSize);

    m_pTables->GetBlobHeapSize(&ulSize);
    VWriteLine("Blobs,%d", ulSize);

    m_pTables->GetGuidHeapSize(&ulSize);
    VWriteLine("Guids,%d", ulSize);

    for (ULONG ixTbl = 0; ixTbl < cTables; ++ixTbl)
    {
        m_pTables->GetTableInfo(ixTbl, &cbRow, &cRows, &cCols, NULL, &pNameTable);
        VWriteLine("%s,%d,%d,%d", pNameTable, cbRow*cRows, cRows, cbRow);
    }

} // void MDInfo::DumpRawCSV()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\modulereader.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// ModuleReader.cpp
//

// Contains functions for the ModuleReader, ManifestModuleReader and
// ResourceModuleReader classes.
//
// Sets up data structures for the given input file.
//
#include "common.h"

#define EXTERN extern
#include "lm.h"


#define HASH_BUFFER_SIZE  4096
#define MAX_ENVIRONMENT_PATH 1024

HRESULT SetInputFile(char *szFileName, HANDLE *hFile)
{
    *hFile = CreateFileA(
        szFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
    );

    if (*hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    return S_OK;
}


HRESULT CheckEnvironmentPath(char *szFileName, char **szFinalPath,
                             char **szFinalPathName, int *iFinalPath, HANDLE *hFile)
{
    char  *rcPath;
    int   iPath;
    LPSTR szPath;
    char  *szTemp;
    int   iNameLen = strlen(szFileName);
    int   iMaxLen = MAX_PATH - iNameLen - 1;
    int   iLen;
    int   iNameOffset = iNameLen;

    for(; (iNameOffset >= 0) && (szFileName[iNameOffset] != '\\'); iNameOffset--);

    if (SUCCEEDED(SetInputFile(szFileName, hFile))) {
        strcpy(*szFinalPath, szFileName);
        *szFinalPathName = &(*szFinalPath)[iNameOffset+1];
        *iFinalPath = iNameLen;
        return S_OK;
    }

    if (iPath = GetEnvironmentVariableA("Path", NULL, 0))
    {
        rcPath = (char *) _alloca(iPath);
        if (!rcPath) return E_OUTOFMEMORY;

        if (GetEnvironmentVariableA("Path", rcPath, iPath))
        {   
            szPath = rcPath;

            // Try each directory in the path.
            for( ; szTemp = StrTok(szPath, ';') ; )
            {
                if ((iLen = strlen(szTemp)) >= iMaxLen)
                    continue;
                
                strcpy(*szFinalPath, szTemp);
                (*szFinalPath)[iLen] = '\\';
                strcpy(&(*szFinalPath)[++iLen], szFileName);
                
                if (SUCCEEDED(SetInputFile(*szFinalPath, hFile))) {
                    *iFinalPath = iLen + iNameLen;
                    *szFinalPathName = &(*szFinalPath)[iLen + iNameOffset + 1];
                    return S_OK;
                }
            }   
        }
    }

    *iFinalPath = iNameLen;
    *szFinalPathName = &szFileName[iNameOffset+1];
    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}


// Finds Com+ Header in an executable image of a file
IMAGE_COR20_HEADER* FindCor20Header(PBYTE pbMapAddress)
{
    IMAGE_NT_HEADERS *pNT;
    IMAGE_COR20_HEADER *pICH;

    if (!(pNT = PEHeaders::FindNTHeader(pbMapAddress)))
        return NULL;

    pICH = (IMAGE_COR20_HEADER*) (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress + pbMapAddress);

    if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].Size == pICH->cb)
        return pICH;

    return NULL;
}


HRESULT GetHash(PBYTE pbBuffer, DWORD dwBufferLen, ALG_ID iHashAlg, PBYTE *pbHash, DWORD *dwHash)
{
    HRESULT    hr = S_OK;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;

    if(!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        PrintError("CryptAcquireContext failed");
        goto exit;
    }

    if(!CryptCreateHash(hProv, iHashAlg, 0, 0, &hHash)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        PrintError("CryptBeginHash failed");
        goto exit;
    }

     while(dwBufferLen >= HASH_BUFFER_SIZE) {
        if(!CryptHashData(hHash, pbBuffer, HASH_BUFFER_SIZE, 0)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            PrintError("CryptHashData failed");
            goto exit;
        }

        dwBufferLen -= HASH_BUFFER_SIZE;
        pbBuffer += HASH_BUFFER_SIZE;
    }

    if ((dwBufferLen) &&
        (!CryptHashData(hHash, pbBuffer, dwBufferLen, 0))) {
        PrintError("CryptHashData failed");
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    if (iHashAlg == CALG_SHA1)
        *dwHash = 20;
    else
        *dwHash = 16;  // CALG_MD5

    *pbHash = new BYTE[*dwHash];
    if (!pbHash) {
        hr = PrintOutOfMemory();
        goto exit;
    }

    if(!CryptGetHashParam(hHash, HP_HASHVAL, *pbHash, dwHash, 0)) {
        PrintError("CryptGetHashParam failed");
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
 exit:
    if (hHash)
        CryptDestroyHash(hHash);
    if (hProv)
        CryptReleaseContext(hProv,0);

    return hr;
}


ModuleReader::ModuleReader()
{
    memset(this, 0, sizeof(*this));

    m_szFinalPath = NULL;
    m_wszInputFileName = NULL;
    m_pbHash = NULL;
    m_mdEntryPoint = mdMethodDefNil;
    m_pImport = NULL;
    m_pAsmImport = NULL;
    m_rgTypeDefs = NULL;
    m_rgTypeRefs = NULL;
    m_rgModuleRefs = NULL;
    m_rgModuleRefUnused = NULL;
    m_SkipVerification = false;

    ZeroMemory(&m_AssemblyIdentity, sizeof(ASSEMBLYMETADATA));
}


ModuleReader::~ModuleReader()
{
    if (m_pImport)
        m_pImport->Release();

    if (m_pAsmImport)
        m_pAsmImport->Release();

    if (m_szFinalPath)
        delete[] m_szFinalPath;

    if (m_wszInputFileName)
        delete[] m_wszInputFileName;

    if (m_pbHash)
        delete[] m_pbHash;

    if (m_rgTypeDefs)
        delete[] m_rgTypeDefs;

    if (m_rgTypeRefs)
        delete[] m_rgTypeRefs;

    if (m_rgModuleRefs)
        delete[] m_rgModuleRefs;

    if (m_rgModuleRefUnused)
        delete[] m_rgModuleRefUnused;

    if(m_AssemblyIdentity.rOS)
        delete[] m_AssemblyIdentity.rOS;

    if(m_AssemblyIdentity.szLocale)
        delete[] m_AssemblyIdentity.szLocale;
            
    if(m_AssemblyIdentity.rProcessor)
        delete[] m_AssemblyIdentity.rProcessor;
}


HRESULT ModuleReader::InitInputFile(char *szFileName, ALG_ID iHashAlg,
                                    DWORD *dwManifestRVA, bool SecondPass,
                                    bool FindEntry, bool AFile, FILETIME *filetime)
{
    HANDLE hFile;

    m_szFinalPath = new char[MAX_PATH];
    if (!m_szFinalPath)
        return PrintOutOfMemory();

    HRESULT hr = CheckEnvironmentPath(szFileName, &m_szFinalPath,
                                      &m_szFinalPathName, &m_iFinalPath, &hFile);
    if (FAILED(hr)) {
        PrintError("File '%s' not found", szFileName);
        return hr;
    }

    if (SecondPass) {
        hr = CheckForSecondPass(hFile, iHashAlg, dwManifestRVA, FindEntry, AFile, filetime);
        CloseHandle(hFile);
        if (FAILED(hr))
            return hr;
    }
    else
        CloseHandle(hFile);

    m_wszInputFileName = new wchar_t[m_iFinalPath + 1];
    if (!m_wszInputFileName)
        return PrintOutOfMemory();

    mbstowcs(m_wszInputFileName, m_szFinalPath, m_iFinalPath + 1);

    hr = g_pDispenser->OpenScope( m_wszInputFileName, 0, IID_IMetaDataImport, (IUnknown **) &m_pImport);
    if (FAILED(hr)) {
        if (g_verbose) {
            fprintf(stderr, "\nError: Failed to open scope on %ws", m_wszInputFileName);
            fprintf(stderr, " - No CLR metadata found?\n");
            fprintf(stderr, "If this is a Classic COM file, provide its .tlb instead.\n");
        }
    }
    else {
        mdAssembly mda;
        
        if (SUCCEEDED(hr = m_pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void **) &m_pAsmImport))) {
            if (SUCCEEDED(m_pAsmImport->GetAssemblyFromScope(&mda))) {
                PrintError("File %s contains a manifest", m_szFinalPath);
                hr = E_FAIL;
            }
        }
        else
            // Note: this ignores the importer for LM -a
            PrintError("Unable to query interface for assembly metadata importer");
    }

    return hr;
}


HRESULT ModuleReader::CheckForSecondPass(HANDLE hFile, ALG_ID iHashAlg,
                                         DWORD *dwManifestRVA, bool FindEntry,
                                         bool AFile, FILETIME *filetime)
{
    PBYTE              pbMapAddress = NULL;
    IMAGE_COR20_HEADER *pICH = NULL;
    ICorRuntimeHost    *pCorHost;

    if ((AFile) &&
        (!GetFileTime(hFile, NULL, NULL, filetime))) {
            PrintError("Unable to get file's last modified time");
            return HRESULT_FROM_WIN32(GetLastError());
    }

    HRESULT hr = CoCreateInstance(CLSID_CorRuntimeHost,NULL,CLSCTX_INPROC_SERVER,IID_ICorRuntimeHost,(void**)&pCorHost);
    if (FAILED(hr)) {
        PrintError("Unable to instantiate Common Language Runtime");
        return hr;
    }

    pCorHost->MapFile(hFile, (HMODULE*) &pbMapAddress);
    pCorHost->Release();

    DWORD dwFileLen = GetFileSize(hFile, 0);
    if (dwFileLen == 0xFFFFFFFF) {
        PrintError("Unable to get file size");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (pbMapAddress) {
        pICH = FindCor20Header(pbMapAddress);
        if ((pICH) && 
            (pICH->Resources.Size)) {


            if (AFile) {
                if (pICH->Resources.Size + pICH->Resources.VirtualAddress < dwFileLen) {
                    UnmapViewOfFile(pbMapAddress);
                    PrintError("Given -a file may have been signed after a manifest was added to it previously.  Or, it may have been given a manifest and then later given a smaller manifest.  Please recompile this file and try again.");
                    return E_FAIL;
                }
                
                *dwManifestRVA = pICH->Resources.VirtualAddress;
            }

            else if (_stricmp(m_szFinalPathName, "mscorlib.dll")) {
                UnmapViewOfFile(pbMapAddress);
                PrintError("File %s contains a manifest", m_szFinalPath);
                return E_FAIL;
            }
        }   
    }

    if (FindEntry)
        GetEntryPoint(pICH);

    if (pbMapAddress)
        UnmapViewOfFile(pbMapAddress);

    if (!AFile) {
        DWORD dwBytesRead;
        PBYTE pbBuffer = new BYTE[dwFileLen];
        if ((SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) ||
            (!ReadFile(hFile, pbBuffer, dwFileLen, &dwBytesRead, NULL))) {
            PrintError("Unable to read file");
            delete[] pbBuffer;
            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = GetHash(pbBuffer, dwBytesRead, iHashAlg, &m_pbHash, &m_dwHash);
        delete[] pbBuffer;
    }

    return hr;
}


void ModuleReader::GetEntryPoint(IMAGE_COR20_HEADER *pICH)
{
    if (pICH) {
        DWORD dwTokenType = TypeFromToken(pICH->EntryPointToken);

        if ((dwTokenType == mdtMethodDef) ||
            (dwTokenType == mdtFile))
            m_mdEntryPoint = pICH->EntryPointToken;
    }
}


/*
HRESULT ModuleReader::GetTLBEntryPoint()
{
    DWORD   dwMethod;
    HRESULT hr;
    DWORD   dwClass;

    for(dwClass = 0; dwClass < m_dwNumTypeDefs; dwClass++) {
        hr = EnumMethods(dwClass);

        if (FAILED(hr))
            return hr;

        dwMethod = FindMainMethod();

        if (dwMethod != -1) {
            m_mdEntryPoint = m_rgMethodDefs[dwMethod];
            return S_OK;
        }
    }

    return S_OK;
}


HRESULT ModuleReader::EnumMethods(DWORD dwClassIndex)
{
    HCORENUM hMethodEnum = 0;
    HRESULT  hr = m_pImport->EnumMethods(&hMethodEnum,
                                         mdTypeDefNil,
                                         NULL,
                                         0,
                                         NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pImport->CountEnum(hMethodEnum, &m_dwNumMethods);

        if (SUCCEEDED(hr)) {
            if (m_rgMethodDefs)
                delete[] m_rgMethodDefs;

            m_rgMethodDefs = new mdMethodDef[m_dwNumMethods];
            if (!m_rgMethodDefs) {
                m_pImport->CloseEnum(hMethodEnum);
                return PrintOutOfMemory();
            }

            hr = m_pImport->EnumMethods(&hMethodEnum,
                                        m_rgTypeDefs[dwClassIndex],
                                        m_rgMethodDefs,
                                        m_dwNumMethods,
                                        &m_dwNumMethods);
        }
    }

    m_pImport->CloseEnum(hMethodEnum);
    if (FAILED(hr))
        PrintError("Unable to enum methods");

    return hr;
}


DWORD ModuleReader::FindMainMethod()
{
    for(DWORD i = 0; i < m_dwNumMethods; i++)
    {
        // Do a case-insensitive compare to see if this is an entry point method
        if ( (SUCCEEDED( GetMethodProps(i) )) &&
             ((!_wcsicmp(m_wszMethodName, L"main")) ||
              ((!_wcsicmp(m_wszMethodName, L"dllmain")))))
            return i;
    }

    return -1;
}


HRESULT ModuleReader::GetMethodProps(DWORD dwMethodIndex)
{
    DWORD   dwMethodName;

    HRESULT hr = m_pImport->GetMethodProps(
        m_rgMethodDefs[dwMethodIndex],
        0,                // mdParent
        m_wszMethodName,
        MAX_CLASS_NAME,
        &dwMethodName,
        0,                // dwMethodAttrs
        0,                // pvSigBlob
        0,                // cbSigBlob
        0,                // ulCodeRVA
        0                 // dwImplFlags
    );

    if (FAILED(hr))
        PrintError("Unable to get method props");

    return hr;
}
*/


HRESULT ModuleReader::ReadModuleFile()
{
    HRESULT hr;

    if (FAILED(hr = EnumTypeDefs(m_pImport,
                                 &m_dwNumTypeDefs,
                                 &m_rgTypeDefs)))
        return hr;

    // Check if this module requests skipping verification.
    mdModule mdModule;
    hr = m_pImport->GetModuleFromScope(&mdModule);
    if (FAILED(hr)) {
        PrintError("Unable to locate module token");
        return hr;
    }
    hr = m_pImport->GetCustomAttributeByName(mdModule,
                                             COR_UNVER_CODE_ATTRIBUTE,
                                             NULL,
                                             NULL);
    if (FAILED(hr)) {
        PrintError("Unable to check for unverifiable code custom attribute");
        return hr;
    }

    m_SkipVerification = S_OK;
    return S_OK;
}

/* static */
HRESULT ModuleReader::EnumTypeDefs(IMetaDataImport *pImport,
                                   DWORD           *dwNumTypeDefs,
                                   mdTypeDef       **rgTypeDefs)
{
    HCORENUM hEnum = 0;
    HRESULT  hr = pImport->EnumTypeDefs(&hEnum,
                                        NULL,
                                        0,
                                        NULL);

    if (SUCCEEDED(hr)) {
        hr = pImport->CountEnum(hEnum, dwNumTypeDefs);

        if (SUCCEEDED(hr)) {
            *rgTypeDefs = new mdTypeDef[*dwNumTypeDefs];
            if (!*rgTypeDefs) {
                pImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = pImport->EnumTypeDefs(&hEnum,
                                       *rgTypeDefs,
                                       *dwNumTypeDefs,
                                       dwNumTypeDefs);
        }
    }
    pImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate TypeDefs");

    return hr;
}

/* static */
HRESULT ModuleReader::GetTypeDefProps(IMetaDataImport *pImport,
                                      mdTypeDef mdType, LPWSTR wszName,
                                      DWORD *pdwAttrs, mdTypeDef *mdEnclosingTD)
{
    HRESULT hr = pImport->GetTypeDefProps(
        mdType,
        wszName,
        MAX_CLASS_NAME,
        NULL,
        pdwAttrs,
        NULL
        );

    if (FAILED(hr)) {
        PrintError("Unable to get type def props");
        return hr;
    }

    if (FAILED(pImport->GetNestedClassProps(mdType, mdEnclosingTD)))
        *mdEnclosingTD = mdTypeDefNil;

    return S_OK;
}


HRESULT ModuleReader::EnumTypeRefs()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pImport->EnumTypeRefs(&hEnum,
                                          NULL,
                                          0,
                                          NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pImport->CountEnum(hEnum, &m_dwNumTypeRefs);

        if (SUCCEEDED(hr)) {
            m_rgTypeRefs = new mdTypeRef[m_dwNumTypeRefs];
            if (!m_rgTypeRefs) {
                m_pImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pImport->EnumTypeRefs(&hEnum,
                                         m_rgTypeRefs,
                                         m_dwNumTypeRefs,
                                         &m_dwNumTypeRefs);
        }
    }

    m_pImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enum type refs");
    
    return hr;
}


HRESULT ModuleReader::GetTypeRefProps(mdTypeRef tr, LPWSTR wszTypeRefName,
                                      mdToken *mdResScope)
{
    DWORD dwTypeRefName;

    HRESULT hr = m_pImport->GetTypeRefProps(
        tr,
        mdResScope,
        wszTypeRefName,
        MAX_CLASS_NAME,
        &dwTypeRefName
    );

    if (FAILED(hr)) {
        PrintError("Unable to get type refs props");
        return hr;
    }

    TranslateArrayName(wszTypeRefName, dwTypeRefName);
    return S_OK;
}

// Returns S_FALSE if the TR has a set resolution scope,
// S_OK if not, error on error.
HRESULT ModuleReader::CheckForResolvedTypeRef(mdToken mdResScope)
{
    HRESULT hr;
        
    // Get the top level resolution scope, if this is a nested type
    while ((TypeFromToken(mdResScope) == mdtTypeRef) &&
           (mdResScope != mdTypeRefNil)) {
        if (FAILED(hr = m_pImport->GetTypeRefProps(mdResScope,
                                                   &mdResScope,
                                                   NULL, //wszTypeRefName
                                                   0, //MAX_CLASS_NAME,
                                                   NULL //&dwTypeRefName
                                                   ))) {
            PrintError("Unable to get enclosing type ref props");
            return hr;
        }
    }

    if (IsNilToken(mdResScope))
        return S_OK;

    // This TR is already resolved, so we don't need to resolve it again
    return S_FALSE;
}


// The "<??" mappings should be the same as in vm\array.cpp
void ModuleReader::TranslateArrayName(LPWSTR wszTypeRefName, DWORD dwTypeRefName)
{
    wchar_t c = wszTypeRefName[0];
    int     i;
    DWORD   dwCount;

    if (c == '[' || c == ']')
    {
        dwCount = 1;

        while (wszTypeRefName[dwCount] == c)
            dwCount++;

        if (wszTypeRefName[dwCount++] == '<') {
            if (!wcscmp(&wszTypeRefName[dwCount], L"I1"))
                wcscpy(wszTypeRefName, L"System.SByte");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"I2"))
                wcscpy(wszTypeRefName, L"System.Int16");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"I4"))
                wcscpy(wszTypeRefName, L"System.Int32");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"I8"))
                wcscpy(wszTypeRefName, L"System.Int64");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"U1"))
                wcscpy(wszTypeRefName, L"System.Byte");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"U2"))
                wcscpy(wszTypeRefName, L"System.UInt16");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"U4"))
                wcscpy(wszTypeRefName, L"System.UInt32");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"U8"))
                wcscpy(wszTypeRefName, L"System.UInt64");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"R4"))
                wcscpy(wszTypeRefName, L"System.Single");
            else if (!wcscmp(&wszTypeRefName[dwCount], L"R8"))
                wcscpy(wszTypeRefName, L"System.Double");
            else {
                for (i = 0; dwCount <= dwTypeRefName; i++, dwCount++)
                    wszTypeRefName[i] = wszTypeRefName[dwCount]; 
                return;
            }
        }

        else {
            dwCount--;
            for (i = 0; dwCount <= dwTypeRefName; i++, dwCount++)
                wszTypeRefName[i] = wszTypeRefName[dwCount]; 
        }
    }

    else {
        dwCount = dwTypeRefName - 2;
        while ((wszTypeRefName[dwCount] == ']') &&
               (wszTypeRefName[dwCount-1] == '['))
            dwCount -= 2;

        if (wszTypeRefName[dwCount] == ']') {
            dwCount--;

            while (wszTypeRefName[dwCount] == ',')
                dwCount--;

            dwCount--;
        }

        wszTypeRefName[dwCount+1] = '\0';
    }
}


HRESULT ModuleReader::EnumModuleRefs()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pImport->EnumModuleRefs(&hEnum,
                                            NULL,
                                            0,
                                            NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pImport->CountEnum(hEnum, &m_dwNumModuleRefs);

        if (SUCCEEDED(hr)) {
            m_rgModuleRefs = new mdModuleRef[m_dwNumModuleRefs];
            if (!m_rgModuleRefs) {
                m_pImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pImport->EnumModuleRefs(&hEnum,
                                           m_rgModuleRefs,
                                           m_dwNumModuleRefs,
                                           &m_dwNumModuleRefs);

            // Create a rid table for MRs
            DWORD dwMaxRid = RidFromToken(m_rgModuleRefs[m_dwNumModuleRefs-1]) + 1;
            m_rgModuleRefUnused = new bool[dwMaxRid];
            if (!m_rgModuleRefUnused) {
                m_pImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            for(DWORD i = 0; i < dwMaxRid; i++)
                m_rgModuleRefUnused[i] = true;
        }
    }
    m_pImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate ModuleRefs");

    return hr;
}


HRESULT ModuleReader::GetModuleRefProps(mdModuleRef mdModuleRef, LPWSTR wszName)
{
    HRESULT hr = m_pImport->GetModuleRefProps(
        mdModuleRef,
        wszName,
        MAX_CLASS_NAME,// @TODO: fix - will need to call twice
        NULL
        );

    if (FAILED(hr))
        PrintError("Unable to get module ref props");

    return hr;
}

HRESULT ModuleReader::EnumAssemblyRefs()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pAsmImport->EnumAssemblyRefs(&hEnum,
                                                 NULL,
                                                 0,
                                                 NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pImport->CountEnum(hEnum, &m_dwNumAssemblyRefs);

        if (SUCCEEDED(hr)) {
            m_rgAssemblyRefs = new mdAssemblyRef[m_dwNumAssemblyRefs];
            if (!m_rgAssemblyRefs) {
                m_pAsmImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pAsmImport->EnumAssemblyRefs(&hEnum,
                                                m_rgAssemblyRefs,
                                                m_dwNumAssemblyRefs,
                                                &m_dwNumAssemblyRefs);
        }
    }
    m_pAsmImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate assembly refs");

    return hr;
}


HRESULT ModuleReader::GetAssemblyRefProps(DWORD index)
{
    DWORD dwSize;

    if (m_AssemblyIdentity.rOS)
        delete[] m_AssemblyIdentity.rOS;

    if (m_AssemblyIdentity.szLocale)
        delete[] m_AssemblyIdentity.szLocale;

    if (m_AssemblyIdentity.rProcessor)
        delete[] m_AssemblyIdentity.rProcessor;
    ZeroMemory(&m_AssemblyIdentity, sizeof(ASSEMBLYMETADATA));

    HRESULT hr = m_pAsmImport->GetAssemblyRefProps(
        m_rgAssemblyRefs[index],
        NULL, // (const void **) &m_pbOriginator,
        NULL, // &m_dwOriginator,
        NULL, //m_wszAsmName,
        0, //MAX_CLASS_NAME,
        NULL, //&dwSize,
        &m_AssemblyIdentity,
        NULL, // ppbHashValue,
        NULL, // pcbHashValue,
        NULL//&m_dwFlags
    );

    if(SUCCEEDED(hr)) {
        if(m_AssemblyIdentity.ulOS) m_AssemblyIdentity.rOS = new OSINFO[m_AssemblyIdentity.ulOS];
        if (m_AssemblyIdentity.cbLocale) m_AssemblyIdentity.szLocale = new WCHAR[m_AssemblyIdentity.cbLocale];
        if(m_AssemblyIdentity.ulProcessor) m_AssemblyIdentity.rProcessor = new DWORD[m_AssemblyIdentity.ulProcessor];
        
        hr = m_pAsmImport->GetAssemblyRefProps(
            m_rgAssemblyRefs[index],
            (const void **) &m_pbOriginator,
            &m_dwOriginator,
            m_wszAsmRefName,
            MAX_CLASS_NAME,
            &dwSize,
            &m_AssemblyIdentity,
            NULL, // ppbHashValue,
            NULL, // pcbHashValue,
            &m_dwFlags);
    }

    if (FAILED(hr))
        PrintError("Unable to get assembly ref props");

    return hr;
}


ManifestModuleReader::ManifestModuleReader()
{
    memset(this, 0, sizeof(*this));

    m_szFinalPath = NULL;
    m_pAsmImport = NULL;
    m_pImport = NULL;
    m_pManifestImport = NULL;
    m_wszAsmName = NULL;
    m_wszDefaultAlias = NULL;
    m_pbOriginator = NULL;
    m_wszInputFileName = NULL;
    m_pbMapAddress = NULL;
    m_pbHash = NULL;
    m_rgFiles = NULL;
    m_rgComTypes = NULL;
    m_rgResources = NULL;
    m_wszCurrentResource = NULL;

    ZeroMemory(&m_AssemblyIdentity, sizeof(ASSEMBLYMETADATA));
}


ManifestModuleReader::~ManifestModuleReader()
{
    if (m_pAsmImport)
        m_pAsmImport->Release();

    if (m_pImport)
        m_pImport->Release();

    if (m_pManifestImport)
        m_pManifestImport->Release();

    if (m_szFinalPath)
        delete[] m_szFinalPath;

    if (m_wszInputFileName)
        delete[] m_wszInputFileName;

    if (m_wszAsmName)
        delete[] m_wszAsmName;

    if (m_wszDefaultAlias)
        delete[] m_wszDefaultAlias;

    if (m_pbMapAddress)
        UnmapViewOfFile(m_pbMapAddress);

    if (m_pbHash)
        delete[] m_pbHash;

    if (m_rgFiles)
        delete[] m_rgFiles;

    if (m_rgComTypes)
        delete[] m_rgComTypes;

    if (m_rgResources)
        delete[] m_rgResources;

    if (m_wszCurrentResource)
        delete[] m_wszCurrentResource;

    if(m_AssemblyIdentity.rOS) {
        delete [] m_AssemblyIdentity.rOS;
        m_AssemblyIdentity.rOS = NULL;
        m_AssemblyIdentity.ulOS = 0;
    }

    if(m_AssemblyIdentity.szLocale) {
        delete [] m_AssemblyIdentity.szLocale;
        m_AssemblyIdentity.szLocale = NULL;
        m_AssemblyIdentity.cbLocale = 0;
    }
            
    if(m_AssemblyIdentity.rProcessor) {
        delete [] m_AssemblyIdentity.rProcessor;
        m_AssemblyIdentity.rProcessor = NULL;
        m_AssemblyIdentity.ulProcessor = 0;
    }
}


HRESULT ManifestModuleReader::InitInputFile(char *szCache,
                                            char *szFileName,
                                            ALG_ID iHashAlg,
                                            ASSEMBLYMETADATA *pContext,
                                            char *szVersion,
                                            DWORD cbVersion,
                                            FILETIME *filetime)
{
    HANDLE hFile;
    
    m_szFinalPath = new char[MAX_PATH];
    if (!m_szFinalPath)
        return PrintOutOfMemory();
    
    HRESULT hr = CheckEnvironmentPath(szFileName, &m_szFinalPath,
                                      &m_szFinalPathName, &m_iFinalPath, &hFile);

    if (FAILED(hr)) {
        hr = CheckCacheForFile(szCache, szFileName, &hFile,
                               pContext, szVersion, cbVersion);
        if (FAILED(hr)) {
            PrintError("File or assembly '%s' not found", szFileName);
            return hr;
        }
    }

    if ((filetime) &&
        (!GetFileTime(hFile, NULL, NULL, filetime))) {
        PrintError("Unable to get file's last modified time");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!m_wszInputFileName) {
        m_wszInputFileName = new wchar_t[MAX_PATH];
        if (!m_wszInputFileName) {
            CloseHandle(hFile);
            return PrintOutOfMemory();
        }
        mbstowcs(m_wszInputFileName, m_szFinalPath, m_iFinalPath + 1);
    }

    if (FAILED(hr = g_pDispenser->OpenScope(m_wszInputFileName, 0, IID_IMetaDataImport, (IUnknown **) &m_pImport))) {
        PrintError("Unable to open scope on file ", m_szFinalPath);
        return hr;
    }

    if ((hr = CheckHeaderInfo(hFile, iHashAlg)) == S_FALSE) {
        if (FAILED(hr = m_pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void **)&m_pAsmImport)))
            PrintError("No manifest found in %ws: %x", m_wszInputFileName, hr);
        else {
            m_pManifestImport = m_pImport;
            m_pManifestImport->AddRef();            
        }
    }

    return hr;
}


HRESULT ManifestModuleReader::CheckCacheForFile(char *szCache, char *szName, HANDLE *hFile, ASSEMBLYMETADATA *pContext, char *szVersion, DWORD cbVersion)
{
    int iDirLen;
    int iNameLen;

    if (szCache) {
        iNameLen = strlen(szName);
        iDirLen = strlen(szCache);
        if (iNameLen + iDirLen + 2 > MAX_PATH)
            return E_FAIL;

        m_iFinalPath += iDirLen + 1;
        strcpy(m_szFinalPath, szCache);
        m_szFinalPath[iDirLen] = '\\';
        strcpy(&m_szFinalPath[iDirLen+1], szName);
        m_szFinalPathName = &m_szFinalPath[iDirLen+(m_szFinalPathName-szName)+1];
    }
    else {
        strcpy(m_szFinalPath, szName);
        m_szFinalPathName = &m_szFinalPath[m_szFinalPathName-szName];
    }

    HRESULT hr = SetInputFile(m_szFinalPath, hFile);

#ifndef UNDER_CE
   // Check Fusion cache for assembly with name szName
    if ((FAILED(hr)) && (pContext)) {
        return E_NOTIMPL; // Not currently supported.
        /*  
        ASSEMBLYMETADATA NewContext;
        memcpy(&NewContext, pContext, sizeof (ASSEMBLYMETADATA));

        if (cbVersion) {
            char szNewVersion[MAX_CLASS_NAME];
            strncpy(szNewVersion, szVersion, cbVersion+1);

            FindVersion(szNewVersion, cbVersion,
                        &NewContext.usMajorVersion,
                        &NewContext.usMinorVersion,
                        &NewContext.usRevisionNumber,
                        &NewContext.usBuildNumber);
        }
        else {
            NewContext.usMajorVersion = 0;
            NewContext.usMinorVersion = 0;
            NewContext.usRevisionNumber = 0;
            NewContext.usBuildNumber = 0;
        }

        wchar_t wszAsmName[MAX_CLASS_NAME];
        mbstowcs(wszAsmName, szName, MAX_CLASS_NAME);

        LPASSEMBLYNAME pFusionName;
        hr = CreateAssemblyNameObject(&pFusionName, wszAsmName, &NewContext, NULL);
        if(FAILED(hr))
            return hr;

//          LPMANIFEST pManifest;
//          hr = pFusionName->GetManifest(&pManifest);
//          pFusionName->Release();
//          if (FAILED(hr))
//              return hr;

//          m_wszInputFileName = new wchar_t[MAX_PATH];
//          if (!m_wszInputFileName) {
//              pManifest->Release();
//              return PrintOutOfMemory();
//          }

//          DWORD dwSize;
//          hr = pManifest->GetAssemblyPath(&dwSize, m_wszInputFileName);
//          pManifest->Release();

//          if (FAILED(hr))
//              return hr;

//          m_iFinalPath = (int) dwSize;
//          wcstombs(m_szFinalPath, m_wszInputFileName, m_iFinalPath+1);
//          for(iDirLen = m_iFinalPath;
//              (iDirLen >= 0) && (m_szFinalPath[iDirLen] != '\\'); iDirLen--);
//          m_szFinalPathName = &m_szFinalPath[iDirLen+1];

//          hr = SetInputFile(m_szFinalPath, hFile);

        */
    }
#endif

    return hr;
}


// Returns S_FALSE if no errors, but no manifest found at location pointed
// to by Manifest dir of Com+ header
HRESULT ManifestModuleReader::CheckHeaderInfo(HANDLE hFile, ALG_ID iHashAlg)
{
    IMAGE_COR20_HEADER *pICH;
    IMAGE_NT_HEADERS   *pNT;
    DWORD *dwSize;
    HRESULT hr;

    HANDLE hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    DWORD dwFileLen = GetFileSize(hFile, 0);
    CloseHandle(hFile);
    if (!hMapFile)
        return HRESULT_FROM_WIN32(GetLastError());

    m_pbMapAddress = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapFile);
    if (!m_pbMapAddress)
        return HRESULT_FROM_WIN32(GetLastError());

    if ((!(pNT = PEHeaders::FindNTHeader(m_pbMapAddress))) ||
        (!(pICH = PEHeaders::getCOMHeader((HMODULE) m_pbMapAddress, pNT)))) {
        UnmapViewOfFile(m_pbMapAddress);
        m_pbMapAddress = NULL;
        return S_FALSE;
    }

    m_pbHash = 0;
    m_dwHash = 0;

    PBYTE pbMetaDataRVA = (PBYTE) PEHeaders::Cor_RtlImageRvaToVa(pNT,
                                                                 m_pbMapAddress,
                                                                 pICH->MetaData.VirtualAddress);

    if (iHashAlg) {
        hr = GetHash(pbMetaDataRVA,
                     pICH->MetaData.Size,
                     iHashAlg, &m_pbHash, &m_dwHash);
        if (FAILED(hr)) {
            UnmapViewOfFile(m_pbMapAddress);
            m_pbMapAddress = NULL;
            return hr;
        }
    }

    if ((!pICH->Resources.Size) ||
        (dwFileLen < pICH->Resources.VirtualAddress + pICH->Resources.Size) ||
        (!(dwSize = (DWORD *) (m_pbMapAddress + pICH->Resources.VirtualAddress))) ||
        (FAILED(g_pDispenser->OpenScopeOnMemory(pICH->Resources.VirtualAddress + m_pbMapAddress + sizeof(DWORD), 

                                                *dwSize, 
                                                0, 
                                                IID_IMetaDataAssemblyImport,
                                                (IUnknown **) &m_pAsmImport)))) {
        UnmapViewOfFile(m_pbMapAddress);
        m_pbMapAddress = NULL;
        return S_FALSE;
    }
    else {
        if (FAILED(hr = m_pAsmImport->QueryInterface(IID_IMetaDataImport, (void **)&m_pManifestImport)))
            PrintError("Unable to query interface for importer", m_szFinalPath);
    }

    return S_OK;
}


HRESULT ManifestModuleReader::ReadManifestFile()
{
    DWORD      dwSize;
    mdAssembly mda;

    m_wszAsmName = new wchar_t[MAX_CLASS_NAME];
    m_wszDefaultAlias = new wchar_t[MAX_CLASS_NAME];

    if ((!m_wszAsmName) || (!m_wszDefaultAlias))
        return PrintOutOfMemory();
    
    HRESULT hr = m_pAsmImport->GetAssemblyFromScope(&mda);
    if (FAILED(hr)) {
        PrintError("Unable to get assembly from scope - no manifest?");
        return hr;
    }

    _ASSERTE(m_AssemblyIdentity.rOS == NULL);
    _ASSERTE(m_AssemblyIdentity.szLocale == NULL);
    _ASSERTE(m_AssemblyIdentity.rProcessor == NULL);

    hr = m_pAsmImport->GetAssemblyProps(
        mda,
        NULL, // (const void **) &m_pbOriginator,
        NULL, // &m_dwOriginator,
        NULL, //hash algorithm.
        NULL, //m_wszAsmName,
        0, //MAX_CLASS_NAME,
        NULL, //&dwSize,
        &m_AssemblyIdentity,
        NULL//&m_dwFlags
    );

    if(SUCCEEDED(hr)) {
        if(m_AssemblyIdentity.ulOS) m_AssemblyIdentity.rOS = new OSINFO[m_AssemblyIdentity.ulOS];
        if (m_AssemblyIdentity.cbLocale) m_AssemblyIdentity.szLocale = new WCHAR[m_AssemblyIdentity.cbLocale];
        if(m_AssemblyIdentity.ulProcessor) m_AssemblyIdentity.rProcessor = new DWORD[m_AssemblyIdentity.ulProcessor];
        
        hr = m_pAsmImport->GetAssemblyProps(
            mda,
            (const void **) &m_pbOriginator,
            &m_dwOriginator,
            &m_ulHashAlgorithm, // hash algorithm.
            m_wszAsmName,
            MAX_CLASS_NAME,
            &dwSize,
            &m_AssemblyIdentity,
            &m_dwFlags);
    }
    if (FAILED(hr))
        PrintError("Unable to get assembly props");

    return hr;
}


HRESULT ManifestModuleReader::EnumFiles()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pAsmImport->EnumFiles(&hEnum,
                                          NULL,
                                          0,
                                          NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pManifestImport->CountEnum(hEnum, &m_dwNumFiles);

        if (SUCCEEDED(hr)) {
            m_rgFiles = new mdFile[m_dwNumFiles];
            if (!m_rgFiles) {
                m_pAsmImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pAsmImport->EnumFiles(&hEnum,
                                         m_rgFiles,
                                         m_dwNumFiles,
                                         &m_dwNumFiles);
        }
    }
    m_pAsmImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate files");
    else
        m_iFinalPath = m_szFinalPathName - m_szFinalPath;

    return hr;
}


HRESULT ManifestModuleReader::GetFileProps(mdFile mdFile)
{
    HRESULT hr = m_pAsmImport->GetFileProps(mdFile,
                                            &m_wszInputFileName[m_iFinalPath],
                                            MAX_PATH - m_iFinalPath,
                                            &m_dwCurrentFileName,
                                            NULL,  // pbHash
                                            NULL,  // cbHash
                                            NULL); // flags

    if (FAILED(hr))
        PrintError("Unable to get file props");
    return hr;
}


HRESULT ManifestModuleReader::EnumComTypes()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pAsmImport->EnumExportedTypes(&hEnum,
                                             NULL,
                                             0,
                                             NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pManifestImport->CountEnum(hEnum, &m_dwNumComTypes);

        if (SUCCEEDED(hr)) {
            m_rgComTypes = new mdExportedType[m_dwNumComTypes];
            if (!m_rgComTypes) {
                m_pAsmImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pAsmImport->EnumExportedTypes(&hEnum,
                                            m_rgComTypes,
                                            m_dwNumComTypes,
                                            &m_dwNumComTypes);
        }
    }
    m_pAsmImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate comtypes");

    return hr;
}


HRESULT ManifestModuleReader::GetComTypeProps(mdExportedType mdComType,
                                              LPWSTR wszClassName,
                                              mdToken *pmdImpl)
{
    DWORD   dwClassName;
    DWORD   dwAttrs;

    HRESULT hr = m_pAsmImport->GetExportedTypeProps(
        mdComType,
        wszClassName,
        MAX_CLASS_NAME,
        &dwClassName,
        pmdImpl,
        NULL, // mdClass
        &dwAttrs);
    
    if (FAILED(hr)) {
        PrintError("Unable to get com type props");
        return hr;
    }

    // S_FALSE if not visible to outside assemblies, or it's defined in
    // the manifest file (we'll use the TD instead)
    if ((*pmdImpl == mdFileNil) ||
        (TypeFromToken(*pmdImpl) == mdtAssemblyRef) ||
        (!(IsTdPublic(dwAttrs) || IsTdNestedPublic(dwAttrs))))
        return S_FALSE;

    return S_OK;
}


HRESULT ManifestModuleReader::EnumResources()
{
    HCORENUM hEnum = 0;
    HRESULT  hr = m_pAsmImport->EnumManifestResources(&hEnum,
                                                      NULL,
                                                      0,
                                                      NULL);

    if (SUCCEEDED(hr)) {
        hr = m_pManifestImport->CountEnum(hEnum, &m_dwNumResources);

        if (SUCCEEDED(hr)) {
            m_rgResources = new mdManifestResource[m_dwNumResources];
            m_wszCurrentResource = new WCHAR[MAX_PATH];
            if (!m_rgResources || !m_wszCurrentResource) {
                m_pAsmImport->CloseEnum(hEnum);
                return PrintOutOfMemory();
            }

            hr = m_pAsmImport->EnumManifestResources(&hEnum,
                                                     m_rgResources,
                                                     m_dwNumResources,
                                                     &m_dwNumResources);
        }
    }
    m_pAsmImport->CloseEnum(hEnum);

    if (FAILED(hr))
        PrintError("Unable to enumerate resources");

    return hr;
}


HRESULT ManifestModuleReader::GetResourceProps(mdManifestResource mdResource)
{
    DWORD dwName;

    HRESULT hr = m_pAsmImport->GetManifestResourceProps(mdResource,
                                                        m_wszCurrentResource,
                                                        MAX_PATH,
                                                        &dwName,
                                                        &m_mdCurrentResourceImpl,
                                                        NULL,
                                                        NULL);

    if (FAILED(hr))
        PrintError("Unable to get manifest resource props");
    return hr;
}


ResourceModuleReader::ResourceModuleReader()
{
    m_szFinalPath = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
    m_pbHash = NULL;
}


ResourceModuleReader::~ResourceModuleReader()
{
    if (m_szFinalPath)
        delete[] m_szFinalPath;

    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);

    if (m_pbHash)
        delete m_pbHash;
}


HRESULT ResourceModuleReader::InitInputFile(LPCUTF8 szResName, char *szFileName,
                                            bool FindHash, ALG_ID iHashAlg)
{
    m_szFinalPath = new char[MAX_PATH];
    if (!m_szFinalPath)
        return PrintOutOfMemory();

    int iFinalPath;
    HRESULT hr = CheckEnvironmentPath(szFileName, &m_szFinalPath,
                                      &m_szFinalPathName, &iFinalPath, &m_hFile);
    if (FAILED(hr)) {
        PrintError("File '%s' not found", szFileName);
        return hr;
    }

    m_dwFileSize = GetFileSize(m_hFile, 0);

    mbstowcs(m_wszResourceName, szResName, MAX_CLASS_NAME);

    if (FindHash) {
        DWORD dwBytesRead;
        PBYTE pbResourceBlob = new BYTE[m_dwFileSize];
        if ((SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) ||
            (!ReadFile(m_hFile, pbResourceBlob, m_dwFileSize, &dwBytesRead, NULL))) {
            delete[] pbResourceBlob;
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
            PrintError("Unable to read resource file");
            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = GetHash(pbResourceBlob, m_dwFileSize, iHashAlg, &m_pbHash, &m_dwHash);
        delete[] pbResourceBlob;
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\manifest\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//

#include "common.h"

#define EXTERN
#include "lm.h"
#include <__file__.ver>
#include <corver.h>
#include <stdarg.h>
#include <StrongName.h>

char*         g_RuntimeLibName = "mscorlib.dll";

char*         g_EvidenceString = "T,Security.Evidence,";
wchar_t*      g_EvidenceResourceName = L"Security.Evidence";
char*         g_EvidenceReservedError = "Resources cannot have the name 'Security.Evidence'";

UnresolvedTypeRef *g_pTRNotFound; // head of 'not yet found type ref' name list
UnresolvedTypeRef *g_pTRNotFoundTail; // tail of same list

LMClassHashTable *g_rgFileHashMaps;
LMClassHashTable *g_pFileNameHashMap;
mdAssemblyRef    *g_rgAssemblyRefs;
mdFile           *g_rgFiles;

bool          g_init = false;
int           g_iAFileIndex;
int           g_iCacheIndex;
bool          g_remove;
bool          g_CopyDir;
int           g_iEntryFile;
int           g_iVersion;
int           g_iAsmName;
int           g_iOriginator;
bool          g_StrongName;
LPWSTR        g_wszKeyContainerName;
bool          g_SkipVerification = false;
int           g_iRuntimeLib = -1;

PBYTE         g_pbOrig = NULL;
DWORD         g_cbOrig = 0;


// Don't give a warning if we can't resolve TypeRefs for the CorDB
// custom attributes
bool SameNameAsRuntimeCustomAttribute(LPWSTR wszTypeRefName)
{
    if ((wcslen(wszTypeRefName) > 44) &&
        (!wcsncmp(wszTypeRefName,
                 L"System.Runtime.Diagnostic.SymbolStore.CORDB_",
                 44)))
        return true;

    return false;
}


// Checks type ref name to see if it matches the special case
bool SpecialTypeRefName(LPWSTR wszTypeRefName)
{
    if ((!wcscmp(wszTypeRefName, L"<GlobalFunctionsHolderClass>")) ||
        (SameNameAsRuntimeCustomAttribute(wszTypeRefName)))
        return true;

    return false;
}


void PrintError(LPSTR szMessage, ...)
{
    if (g_verbose) {
        va_list pArgs;
        CHAR    szBuffer[1024];

        va_start(pArgs, szMessage);
        vsprintf(szBuffer, szMessage, pArgs);
        va_end(pArgs);
        
        fprintf(stderr, "\nError: %s\n", szBuffer);
    }
}


HRESULT PrintOutOfMemory()
{
    PrintError("Insufficient memory");
    return E_OUTOFMEMORY;
}


void Title()
{
    if (g_verbose) {
        printf("\nMicrosoft (R) Common Language Runtime Manifest Linker.  Version " VER_FILEVERSION_STR);
        printf("\n" VER_LEGALCOPYRIGHT_DOS_STR);
        printf("\n\n");
    }
}


void Usage()
{
    if (g_verbose) {
        printf("\nUsage: lm [options]\n");

        printf("\nOptions:\n");
        
        printf("\t-a DestFile       (Deprecated) The input dll or exe which will contain the new manifest\n");
        printf("\t-c Cache          Use this existing directory instead of Fusion's cache\n");
        printf("\t-d                Create Platform\\Locale\\AsmNameVersion dir and copy input/output files into it\n");
        printf("\t-e FileName       Attach a binary serialized evidence blob to the assembly\n");
        printf("\t-f FileList       Dll's or exe's that contain the bits for the assembly\n");
        printf("\t-h HashAlg        The algorithm for determining the hash (SHA1 or MD5)\n");
        printf("\t-i DependentsList Dll's or exe's containing manifests for dependent assemblies, in the form Version,File\n");
        printf("\t-k KeyPairFile    Key pair used to sign strong name assembly (read from file)\n");
        printf("\t-K KeyPairCont    Key pair used to sign strong name assembly (read from key container)\n");
        printf("\t-l Locale         Locale string (see HKEY_CLASSES_ROOT\\MIME\\Database\\Rfc1766)\n");
        printf("\t-n AsmName        Assembly name - required if not using -a or -z options\n");
        printf("\t-o OriginatorFile Originator of this assembly\n");
        printf("\t-p PlatformList   Valid values are x86 and alpha (CE not supported yet)\n");
        printf("\t-q                Quiet mode\n");
        printf("\t-r ResourceList   List of items in the form SaveInFile,ResourceName,File where SaveInFile is either True or False\n");
        printf("\t-s PermissionFile Add security permission requests in file to assembly\n");
        printf("\t-t                Create a strong name for the assembly\n");
        printf("\t-u                Don't check for modules marked as unverifiable\n");
        printf("\t-v AsmVer         The version of the assembly being created: 1.2.3.4\n");
        printf("\t-x                Remove original -f files (when using -d option)\n");
        printf("\t-y ManifestFile   Resign a strong name assembly\n");
        printf("\t-z ManifestFile   Copy this assembly's files to the Fusion cache\n");
    }
}


HRESULT Init()
{
    HRESULT hr;

    CoInitialize(NULL);
    CoInitializeEE(COINITEE_DEFAULT);
    g_init = true;

    if (FAILED(hr = CoCreateInstance(CLSID_CorMetaDataDispenser,
                                     NULL,
                                     CLSCTX_INPROC_SERVER, 
                                     IID_IMetaDataDispenser,
                                     (void **) &g_pDispenser)))
        PrintError("Failed to get IID_IMetaDataDispenser");

    return hr;
}


void Cleanup()
{
    if (g_pDispenser)
        g_pDispenser->Release();

    if (g_init) {
        CoUninitializeEE(COUNINITEE_DEFAULT);
        CoUninitialize();
    }
}


BOOL CompareNestedEntryWithTypeRef(ModuleReader *pFileReader,
                                   mdTypeRef     mdCurrent,
                                   LMClassHashEntry_t *pEntry)
{
    mdToken mdResScope;
    wchar_t wszRefName[MAX_CLASS_NAME];

    if (FAILED(pFileReader->GetTypeRefProps(mdCurrent, wszRefName,
                                            &mdResScope)))
        return FALSE;

    if (LMClassHashTable::CompareKeys(pEntry->Key, wszRefName)) {
        if ((TypeFromToken(mdResScope) != mdtTypeRef) ||
            (mdResScope == mdTypeRefNil))
            return (!pEntry->pEncloser);

        if (pEntry->pEncloser)
            return CompareNestedEntryWithTypeRef(pFileReader, mdResScope,
                                                 pEntry->pEncloser);
    }

    return FALSE;
}


bool IsInFileHashTables(ModuleReader *pFileReader, UnresolvedTypeRef *pCurrent, int iNumFiles)
{
    TypeData *pData;
    int      iRes;

    if ((TypeFromToken(pCurrent->mdResScope) == mdtTypeRef) &&
        (pCurrent->mdResScope != mdTypeRefNil)) {
        LMClassHashEntry_t *pBucket;

        for(int i = 0; i < iNumFiles; i++) {
            if (pBucket = g_rgFileHashMaps[i].GetValue(pCurrent->wszName, &pData, TRUE)) {
                do {
                    iRes = CompareNestedEntryWithTypeRef(pFileReader,
                                                         pCurrent->mdResScope,
                                                         pBucket->pEncloser);
                } while ((!iRes) &&
                         (pBucket = g_rgFileHashMaps[i].FindNextNestedClass(pCurrent->wszName, &pData, pBucket)));
                
                if (pBucket)
                    return true;
            }
        }
    }
    else {
        for(int i = 0; i < iNumFiles; i++) {
            if (g_rgFileHashMaps[i].GetValue(pCurrent->wszName, &pData, FALSE))
                return true;
        }
    }

    return false;
}


TypeData * IsInDependentHashTable(LMClassHashTable *pDependentHashMap, UnresolvedTypeRef *pCurrent)
{
    TypeData *pData;
    int      iRes;

    if ((TypeFromToken(pCurrent->mdResScope) == mdtTypeRef) &&
        (pCurrent->mdResScope != mdTypeRefNil)) {
        LMClassHashEntry_t *pBucket;

            if (pBucket = pDependentHashMap->GetValue(pCurrent->wszName, &pData, TRUE)) {
                do {
                    iRes = CompareNestedEntryWithTypeRef(pCurrent->pModReader,
                                                         pCurrent->mdResScope,
                                                         pBucket->pEncloser);
                } while ((!iRes) &&
                         (pBucket = pDependentHashMap->FindNextNestedClass(pCurrent->wszName, &pData, pBucket)));
                
                if (pBucket)
                    return pData;
            }
    }
    else {
        if (pDependentHashMap->GetValue(pCurrent->wszName, &pData, FALSE))
            return pData;
    }

    return NULL;
}


// It's a unique type if there has not been any CTs emitted with this
// name yet.
bool IsUniqueType(TypeData *pData, int iFileMapIndex)
{
    // This is only a dup if the top-level encloser is one, so only check that.
    if (pData->pEncloser) {
        LMClassHashEntry_t *pHashEntry = pData->pEncloser;
        while (pHashEntry->pEncloser)
            pHashEntry = pHashEntry->pEncloser;
        pData = pHashEntry->pData;
    }

    TypeData *pFoundData;
    for(int i = 0; i < iFileMapIndex; i++) {
        if (g_rgFileHashMaps[i].GetValue(pData->wszName, &pFoundData, FALSE)) {
            if (pFoundData->mdComType != mdTokenNil)
                return false;
        }
    }

    return true;
}


void PrintNames(UnresolvedTypeRef *pHead)
{
    while(pHead) {
        fprintf(stderr, "%ws\n", pHead->wszName);
        pHead = pHead->pNext;
    }
}


void DeleteNames(UnresolvedTypeRef *pHead)
{
    UnresolvedTypeRef *pCurrent;

    while(pHead) {
        pCurrent = pHead;
        pHead = pHead->pNext;
        delete pCurrent;
    }       
}


HRESULT CopyFilesToFusion(ManifestWriter *mw, int iFileIndex, char **argv)
{
    HRESULT              hr;
    ManifestModuleReader mmr;

    if ( (FAILED(hr = Init()))                                               ||
         (FAILED(hr = mmr.InitInputFile(NULL, argv[ iFileIndex ],
                                        0, NULL, NULL, 0, &mw->m_FileTime))) ||
         (FAILED(hr = mmr.ReadManifestFile())) )
        return hr;

    mw->m_wszName = mmr.m_wszAsmName;
    mw->m_pContext = &mmr.m_AssemblyIdentity;

    mw->m_wszZFilePath = mmr.m_wszInputFileName;
    mw->m_FusionCache = true;
    hr = mw->CopyFileToFusion(mmr.m_wszInputFileName,
                              (PBYTE) mmr.m_pbOriginator, mmr.m_dwOriginator,
                              mmr.m_szFinalPath, 1, false);

    mw->m_wszName = NULL;
    mw->m_pContext = NULL;

    if ( (FAILED(hr)) ||
         (FAILED(hr = mmr.EnumFiles())) )
        return hr;

    for(DWORD i=0; i < mmr.m_dwNumFiles; i++) {
        if (FAILED(hr = mmr.GetFileProps(mmr.m_rgFiles[i])))
            return hr;

        char szFinalPath[MAX_PATH];
        wcstombs(szFinalPath, mmr.m_wszInputFileName,
                 mmr.m_iFinalPath + mmr.m_dwCurrentFileName + 1);

        if (FAILED(hr = mw->CopyFileToFusion(mmr.m_wszInputFileName,
                                             (PBYTE) mmr.m_pbOriginator, mmr.m_dwOriginator,
                                             szFinalPath, 0, false)))
            return hr;
    }
    
    return mw->CommitAllToFusion();
}


HRESULT AddComTypeToHash(ManifestModuleReader *mmr, LMClassHashTable *DependentHashMap,
                         TypeData *pData, mdToken mdImpl)
{
    HRESULT hr;

    if (TypeFromToken(mdImpl) == mdtExportedType) {
        LMClassHashEntry_t *pBucket;
        TypeData *pFoundData;
        wchar_t wszEnclosingName[MAX_CLASS_NAME];
        mdExportedType mdEnclEncloser;

        if ((hr = mmr->GetComTypeProps(mdImpl,
                                       wszEnclosingName,
                                       &mdEnclEncloser)) != S_OK)
            return hr;
        
        if (pBucket = DependentHashMap->GetValue(wszEnclosingName,
                                                 &pFoundData,
                                                 TypeFromToken(mdEnclEncloser) == mdtExportedType)) {
            do {
                // check to see if this is the correct class
                if (mdImpl == pFoundData->mdThisType) {
                    if (DependentHashMap->InsertValue(pData->wszName, pData, pBucket)) {
                        pData->pEncloser = pBucket;
                        return S_OK;
                    }

                    return PrintOutOfMemory();;
                }
            } while (pBucket = DependentHashMap->FindNextNestedClass(wszEnclosingName, &pFoundData, pBucket));
        }
        
        // If the encloser is not in the hash table, it's not public,
        // so this nested type isn't publicly available, either.
        return S_FALSE;
    }
    else if (DependentHashMap->InsertValue(pData->wszName, pData, NULL))
        return S_OK;

    return PrintOutOfMemory();
}


HRESULT AddTypeDefToHash(IMetaDataImport *pImport, LMClassHashTable *HashMap,
                         TypeData *pData, mdToken mdImpl)
{
    HRESULT hr;

    if ((TypeFromToken(mdImpl) == mdtTypeDef) &&
        (mdImpl != mdTypeDefNil)) {
        LMClassHashEntry_t *pBucket;
        TypeData *pFoundData;
        wchar_t wszEnclosingName[MAX_CLASS_NAME];
        mdExportedType mdEnclEncloser;
        DWORD dwAttrs;

        if (FAILED(hr = ModuleReader::GetTypeDefProps(pImport,
                                                      mdImpl,
                                                      wszEnclosingName,
                                                      &dwAttrs,
                                                      &mdEnclEncloser)))
            return hr;

        if (!(IsTdPublic(dwAttrs) || IsTdNestedPublic(dwAttrs)))
            return S_FALSE;

        if (pBucket = HashMap->GetValue(wszEnclosingName,
                                        &pFoundData,
                                        (TypeFromToken(mdEnclEncloser) == mdtTypeDef) && mdEnclEncloser != mdTypeDefNil)) {
            do {
                // check to see if this is the correct class
                if (mdImpl == pFoundData->mdThisType) {
                    if (HashMap->InsertValue(pData->wszName, pData, pBucket)) {
                        pData->pEncloser = pBucket;
                        return S_OK;
                    }

                    return PrintOutOfMemory();;
                }
            } while (pBucket = HashMap->FindNextNestedClass(wszEnclosingName, &pFoundData, pBucket));
        }
        
        // If the encloser is not in the hash table, it's not public,
        // so this nested type isn't publicly available, either.
        return S_FALSE;
    }
    else if (HashMap->InsertValue(pData->wszName, pData, NULL))
        return S_OK;

    return PrintOutOfMemory();
}


HRESULT HashDependentAssembly(ManifestModuleReader *mmr, LMClassHashTable *pDependentHashMap)
{
    mdToken mdImpl;
    HRESULT hr;

    // Populate the hash table with public classes from the given asm
    if (FAILED(hr = mmr->EnumComTypes()))
        return hr;
    
    if (FAILED(hr = ModuleReader::EnumTypeDefs(mmr->m_pImport,
                                               &mmr->m_dwNumTypeDefs,
                                               &mmr->m_rgTypeDefs)))
        return hr;
    
    if (!pDependentHashMap->Init(mmr->m_dwNumComTypes + mmr->m_dwNumTypeDefs))
        return PrintOutOfMemory();
    
    for(DWORD i=0; i < mmr->m_dwNumComTypes; i++) {
        TypeData *pNewData = new TypeData();
        hr = mmr->GetComTypeProps(mmr->m_rgComTypes[i],
                                  pNewData->wszName,
                                  &mdImpl);
        
        // (hr == S_FALSE) means either this isn't public,
        // or it's defined in the manifest file - don't add it
        if ((hr != S_OK) ||
            ((hr = AddComTypeToHash(mmr, pDependentHashMap, pNewData, mdImpl)) != S_OK))
            delete pNewData;
        else {
            // add to head of list
            pNewData->mdThisType = mmr->m_rgComTypes[i];
            pNewData->pNext = pDependentHashMap->m_pDataHead;
            pDependentHashMap->m_pDataHead = pNewData;
        }

        if (FAILED(hr))
            return hr;
    }
    
    // Add the TD defined in the manifest file to the hash table
    // (we skipped the CTs for these earlier)
    for(i=0; i < mmr->m_dwNumTypeDefs; i++) {
        TypeData *pNewData = new TypeData();
        DWORD dwAttrs;
        hr = ModuleReader::GetTypeDefProps(mmr->m_pImport,
                                           mmr->m_rgTypeDefs[i],
                                           pNewData->wszName,
                                           &dwAttrs,
                                           &mdImpl);
        
        if (FAILED(hr) ||
            (!(IsTdPublic(dwAttrs) || IsTdNestedPublic(dwAttrs))) ||
            ((hr = AddTypeDefToHash(mmr->m_pImport, pDependentHashMap, pNewData, mdImpl)) != S_OK))
            delete pNewData;
        else {
            // add to head of list
            pNewData->mdThisType = mmr->m_rgTypeDefs[i];
            pNewData->pNext = pDependentHashMap->m_pDataHead;
            pDependentHashMap->m_pDataHead = pNewData;
        }
        
        if (FAILED(hr))
            return hr;
    }       
    
    return S_OK;
}


// Adds all of the public classes for the given assembly to a hash table.
// Then, determines whether or not an AssemblyRef is needed by looking
// for each TR in the TR list.  (Also, an AssemblyRef is needed if that
// assembly contains resources - a Resource entry is emitted for each.)
// A ComType is emitted for each resolved TR, if a ComType has not already
// been emitted for that type.
HRESULT EmitIfFileNeeded(ManifestWriter *mw, ManifestModuleReader *mmr, LPWSTR wszExeLocation, int iFile)
{
    UnresolvedTypeRef   *pFound;
    UnresolvedTypeRef   *pCurrent = g_pTRNotFound;
    UnresolvedTypeRef   *pPrevious = NULL;
    bool                TRResolved = false;
    bool                ResourceEmitted = false;
    HRESULT             hr;
    LMClassHashTable    DependentHashMap;
    TypeData            *pCurrentData;

    if (pCurrent) {
        if (FAILED(hr = HashDependentAssembly(mmr, &DependentHashMap)))
            return hr;
    }

    while(pCurrent) {
        if (pCurrentData = IsInDependentHashTable(&DependentHashMap, pCurrent)) {

            if (!TRResolved) {                
                if (FAILED(hr = mw->WriteManifestInfo(mmr, &g_rgAssemblyRefs[iFile])))
                    return hr;
            }

            // If the top-level resolution scope of this TR is nil, emit it
            // (but don't emit more than one ComType for the same type)
            if (pCurrentData->mdComType == mdTokenNil) {
                mdToken mdImpl;

                if (pCurrentData->pEncloser) {
                    _ASSERTE(pCurrentData->pEncloser->pData->mdComType);
                    mdImpl = pCurrentData->pEncloser->pData->mdComType;
                }
                else
                    mdImpl = g_rgAssemblyRefs[iFile];

                hr = mw->EmitComType(pCurrentData->wszName, mdImpl,
                                     &pCurrentData->mdComType);
                if (FAILED(hr))
                    return hr;
            }

            TRResolved = true;
            
            // Remove from the 'type ref not found' list
            if (pPrevious)
                pPrevious->pNext = pCurrent->pNext;
            else
                g_pTRNotFound = g_pTRNotFound->pNext;
            
            pFound = pCurrent;
            pCurrent = pCurrent->pNext;
            delete pFound;
        }
        else {
            if (pPrevious)
                pPrevious = pPrevious->pNext;
            else
                pPrevious = g_pTRNotFound;
 
            pCurrent = pCurrent->pNext;          
        }
    }

    if (FAILED(hr = mmr->EnumResources()))
        return hr;

    for(DWORD i=0; i < mmr->m_dwNumResources; i++) {
        if (FAILED(mmr->GetResourceProps(mmr->m_rgResources[i])))
            return hr;

        if (TypeFromToken(mmr->m_mdCurrentResourceImpl) == mdtFile) {

            if (!TRResolved && !ResourceEmitted) {
                if (FAILED(hr = mw->WriteManifestInfo(mmr, &g_rgAssemblyRefs[iFile])))
                    return hr;

                ResourceEmitted = true;
            }


            if (FAILED(hr = mw->EmitResource(mmr->m_wszCurrentResource, g_rgAssemblyRefs[iFile], 0)))
                return hr;
        }
    }

    if ((!TRResolved) && (!ResourceEmitted) && (g_verbose))
        printf("* File %s not used because it was determined unnecessary\n", mmr->m_szFinalPathName);
    /*
    else {
        // @TODO: Strongly named assemblies can't have simple dependencies
        if (g_cbOrig && (!mmr->m_dwOriginator)) {
            PrintError("Strongly-named assemblies can not reference simply-named assemblies (%s)", mmr->m_wszAsmName);
            return E_FAIL;
        }
    }
    */

    return hr;
}


HRESULT HashRuntimeLib(LMClassHashTable *pRuntimeLibHashMap)
{
    ManifestModuleReader mmr;
    HRESULT      hr;

    // Don't need to make this hash if the runtime lib is on the -f list
    if (g_iRuntimeLib != -1) {
        if (!pRuntimeLibHashMap->Init(1))
            return PrintOutOfMemory();
        return S_OK;
    }

    if (FAILED(hr = mmr.InitInputFile(NULL,
                                      g_RuntimeLibName,
                                      0,
                                      NULL,
                                      NULL,
                                      0, NULL)))
        return hr;

    if (FAILED(HashDependentAssembly(&mmr, pRuntimeLibHashMap)))
        return hr;

    return S_OK;
}


// S_FALSE if a dup, S_OK if not, or error
HRESULT CheckForDuplicateName(LPWSTR wszName)
{   
    TypeData *pData;
    if (g_pFileNameHashMap->GetValue(wszName, &pData, FALSE))
        // return S_FALSE if this is a duplicate name
        return S_FALSE;

    if (!g_pFileNameHashMap->InsertValue(wszName, NULL, NULL))
        return PrintOutOfMemory();

    return S_OK;
}


// Opens scope on each regular file, and puts the TypeDefs
// from each in that file's hash table.
HRESULT FirstPass(ManifestWriter *mw, int iNumFiles,
                  int iNumPlatforms, int *piFileIndexes,
                  DWORD *pdwPlatforms, ModuleReader rgModReaders[],
                  char **argv, DWORD *dwManifestRVA)
{
    TypeData  *pCurrent;
    HRESULT   hr;
    DWORD     dwClass;

    // Make sure there are no duplicate file names
    if (!g_pFileNameHashMap->Init(iNumFiles))
        return PrintOutOfMemory();

    for (int i = 0; i < iNumFiles; i++)
    {
        if ((FAILED(hr = rgModReaders[i].InitInputFile(argv[ piFileIndexes[i] ] ,
                                                      mw->m_iHashAlgorithm,
                                                      dwManifestRVA,
                                                      true,
                                                      !mw->m_MainFound,
                                                      i == g_iAFileIndex,
                                                      &mw->m_FileTime))) ||
            (FAILED( hr = rgModReaders[i].ReadModuleFile() )))
            return hr;

        // don't need the path when checking for dup file name
        WCHAR* wszFileName = wcsrchr(rgModReaders[i].m_wszInputFileName, L'\\');
        if (wszFileName)
            wszFileName++;
        else
            wszFileName = rgModReaders[i].m_wszInputFileName;

        // convert to lowercase
        _wcslwr(wszFileName);

        if (FAILED(hr = CheckForDuplicateName(wszFileName)))
            return hr;
        if (hr == S_FALSE) {
            PrintError("Cannot have two input modules with the same name");
            return E_FAIL;
        }

       if (!mw->m_MainFound) {
            mw->CheckForEntryPoint(rgModReaders[i].m_mdEntryPoint);
            if (mw->m_MainFound)
                g_iEntryFile = i;
        }

        if (rgModReaders[i].m_SkipVerification)
            g_SkipVerification = true;

        if (!g_rgFileHashMaps[i].Init(rgModReaders[i].m_dwNumTypeDefs))
            return PrintOutOfMemory();

        for(dwClass = 0; dwClass < rgModReaders[i].m_dwNumTypeDefs; dwClass++)
        {
            pCurrent = new TypeData();
            if (!pCurrent)
                return PrintOutOfMemory();

            // Insert at end of list to preserve order
            if (g_rgFileHashMaps[i].m_pDataTail)
                g_rgFileHashMaps[i].m_pDataTail->pNext = pCurrent;
            else
                g_rgFileHashMaps[i].m_pDataHead = pCurrent;

            g_rgFileHashMaps[i].m_pDataTail = pCurrent;
            pCurrent->mdThisType = rgModReaders[i].m_rgTypeDefs[dwClass];

            mdTypeDef mdEncloser;
            if (FAILED(hr = ModuleReader::GetTypeDefProps(rgModReaders[i].m_pImport,
                                                          rgModReaders[i].m_rgTypeDefs[dwClass],
                                                          pCurrent->wszName,
                                                          &(pCurrent->dwAttrs),
                                                          &mdEncloser)))
                return hr;


            if (mdEncloser == mdTypeDefNil) {
                if (!g_rgFileHashMaps[i].InsertValue(pCurrent->wszName, pCurrent, NULL))
                    return PrintOutOfMemory();
            }
            else {
                LMClassHashEntry_t *pBucket;
                TypeData *pFoundData;
                wchar_t wszEnclosingName[MAX_CLASS_NAME];
                DWORD dwAttrs;
                mdTypeDef mdEnclEncloser;

                if (FAILED(ModuleReader::GetTypeDefProps(rgModReaders[i].m_pImport,
                                                         mdEncloser,
                                                         wszEnclosingName,
                                                         &dwAttrs,
                                                         &mdEnclEncloser)))
                    return hr;

                // Find entry for enclosing class - NOTE, this assumes that the
                // enclosing class's TypeDef was inserted previously, which assumes that,
                // when enuming TypeDefs, we get the enclosing class first
                if (pBucket = g_rgFileHashMaps[i].GetValue(wszEnclosingName,
                                                           &pFoundData,
                                                           mdEnclEncloser != mdTypeDefNil)) {
                    do {
                        // check to see if this is the correct class
                        if (mdEncloser == pFoundData->mdThisType) {
                            
                            if (g_rgFileHashMaps[i].InsertValue(pCurrent->wszName, pCurrent, pBucket)) {
                                pCurrent->pEncloser = pBucket;
                                break;
                            }

                            return PrintOutOfMemory();
                        }
                    } while (pBucket = g_rgFileHashMaps[i].FindNextNestedClass(wszEnclosingName, &pFoundData, pBucket));
                }
                
                if (!pBucket) {
                    _ASSERTE(!"Could not find enclosing class in hash table");
                    return E_FAIL;
                }
            }
        }

        if (!_stricmp(rgModReaders[i].m_szFinalPathName, g_RuntimeLibName))
            g_iRuntimeLib = i;
    }


    if (g_iVersion) { 
        if (FAILED(hr = mw->SetVersion(argv[g_iVersion])))
            return hr;
    }
    else if (g_iAFileIndex != -1){
        if (FAILED(hr = mw->GetVersionFromResource(rgModReaders[g_iAFileIndex].m_szFinalPath)))
            return hr;
    }

    if ( (FAILED(hr = mw->GetContext(iNumPlatforms, pdwPlatforms))) ||
         (FAILED(hr = mw->SetAssemblyFileName(g_iCacheIndex ? argv[g_iCacheIndex] : NULL, 
                                              g_iAsmName ? argv[g_iAsmName] : NULL,
                                              (g_iAFileIndex == -1) ? NULL : argv[piFileIndexes[g_iAFileIndex]],
                                              g_CopyDir))) ||
         ( (g_iAFileIndex == -1) && (FAILED(hr = mw->CreateNewPE()))) )
        return hr;

    return S_OK;
}


// For each regular file, enums TypeRefs, and checks
// each TR against the runtime's hash table and then the regular files'
// hash tables.  Each TR not in the tables is added to the g_pTRNotFound
// linked list.  Emits a File for each module.
HRESULT SecondPass(ManifestWriter *mw, int iNumFiles,
                   ModuleReader rgModReaders[])
{
    int      i;
    UnresolvedTypeRef *pCurrent;
    DWORD    dwIndex;
    HRESULT  hr;
    LMClassHashTable  RuntimeLibHashMap;

    g_rgFiles = new mdFile[iNumFiles];
    if (!g_rgFiles)
        return PrintOutOfMemory();

    if (FAILED(hr = HashRuntimeLib(&RuntimeLibHashMap)))
        return hr;

    for (i = 0; i < iNumFiles; i++)
    {
        if (FAILED( hr = rgModReaders[i].EnumModuleRefs() ) || 
            FAILED( hr = rgModReaders[i].EnumTypeRefs() ))
            return hr;

        for(dwIndex = 0; dwIndex < rgModReaders[i].m_dwNumTypeRefs; dwIndex++)
        {
            pCurrent = new UnresolvedTypeRef();
            if (!pCurrent)
                return PrintOutOfMemory();

            if (FAILED(hr = rgModReaders[i].GetTypeRefProps(rgModReaders[i].m_rgTypeRefs[dwIndex],
                                                            pCurrent->wszName,
                                                            &pCurrent->mdResScope)) ||
                FAILED(hr = rgModReaders[i].CheckForResolvedTypeRef(pCurrent->mdResScope))) {
                delete pCurrent;
                return hr;
            }

            pCurrent->pModReader = &rgModReaders[i];

            // If this TR has not already been resolved (its resolution
            // scope token is nil), check each TR against the runtime
            // lib first, then the files,
            // that will be in this assembly, then special names
            if (hr == S_FALSE) {
                // Ensure that all ModuleRefs are resolved by -f or -a files,
                // but don't need to check the same MR token twice
                if ((TypeFromToken(pCurrent->mdResScope) == mdtModuleRef) &&
                    rgModReaders[i].m_rgModuleRefUnused[RidFromToken(pCurrent->mdResScope)]) {

                    wchar_t wszModuleRefName[MAX_CLASS_NAME];
                    if (FAILED(hr = rgModReaders[i].GetModuleRefProps(pCurrent->mdResScope, wszModuleRefName))) {
                        delete pCurrent;
                        return hr;
                    }

                    // convert to lowercase
                    _wcslwr(wszModuleRefName);

                    if (CheckForDuplicateName(wszModuleRefName) == S_OK) {
                        /*
                        PrintError("Referenced module %ws is not on -f list", wszModuleRefName);
                        delete pCurrent;
                        return E_FAIL;
                        */
                        fprintf(stderr, "\nWarning: Referenced module %ws is not on -f list\n", wszModuleRefName);
                    }

                    rgModReaders[i].m_rgModuleRefUnused[RidFromToken(pCurrent->mdResScope)] = false;
                }

                delete pCurrent;
            }
            else if ((IsInDependentHashTable(&RuntimeLibHashMap, pCurrent)) ||
                     (IsInFileHashTables(&rgModReaders[i], pCurrent, iNumFiles)) ||
                     (SpecialTypeRefName(pCurrent->wszName)))
                delete pCurrent;
            else {

                // insert at tail of list to preserve order
                if (g_pTRNotFound)
                    g_pTRNotFoundTail->pNext = pCurrent;
                else
                    g_pTRNotFound = pCurrent;

                g_pTRNotFoundTail = pCurrent;
            }
        }

        if (i != g_iAFileIndex) {
            if (FAILED(hr = mw->EmitFile(&rgModReaders[i])))
                return hr;

            if (i == g_iEntryFile)
                mw->SetEntryPoint(rgModReaders[i].m_szFinalPathName);
        }

        g_rgFiles[i] = mw->m_mdFile;
    }

    return S_OK;
}


// Opens scope on each manifest file, and checks if each TR
// in the g_pTRNotFound list is in that file.  If it is, it's
// removed from the list and hashed in that file's hash table.
// For each manifest file that could remove a TR from the list,
// an AssemblyRef is emitted, and the ComTypes corresponding
// to each of those TRs is emitted.

// If a dependent file contains any resources, a ManifestResource
// is emitted for each, and an AssemblyRef is emitted.
HRESULT ExamineDependents(ManifestWriter *mw, int iNumDependents,
                          int *piDependentIndexes, char **argv)
{
    LPSTR                szFile;
    LPSTR                szVersion;
    HRESULT              hr;
    int                  i;
    ManifestModuleReader *mmr = NULL;
    LPWSTR               wszExeLocation;

    g_rgAssemblyRefs = new mdAssemblyRef[iNumDependents];

    if (!g_rgAssemblyRefs)
        goto outofmemory;
    
    for(i = 0; i < iNumDependents; i++)
    {       
        mmr = new ManifestModuleReader();
        if (!mmr)
            goto outofmemory;

        if ((!(szVersion = strchr(argv[ piDependentIndexes[i] ], ','))) ||
            (!(szFile = strchr(++szVersion, ',')))) {
            PrintError("Dependent files must be listed in the format Version,File");
            hr = E_INVALIDARG;
            goto exit;
        }
        szFile++;

        if ( (FAILED( hr = mmr->InitInputFile(argv[g_iCacheIndex],
                                              szFile,
                                              mw->m_iHashAlgorithm,
                                              mw->m_pContext,
                                              szVersion,
                                              szFile - szVersion - 1, 
                                              NULL))) ||
             (FAILED( hr = mmr->ReadManifestFile() )))
            goto exit;

        if (szVersion == argv[ piDependentIndexes[i] ]+1)
            wszExeLocation = NULL;
        else {
            int count = szVersion - argv[ piDependentIndexes[i] ];
            wszExeLocation = new wchar_t[count--];
            if (!wszExeLocation)
                goto outofmemory;

            mbstowcs(wszExeLocation, argv[ piDependentIndexes[i] ], count);
            wszExeLocation[count] = '\0';
        }

        hr = EmitIfFileNeeded(mw, mmr, wszExeLocation, i);
        if (wszExeLocation)
            delete[] wszExeLocation;
        if (FAILED(hr))
            goto exit;

        delete mmr;
    }

    if (g_pTRNotFound && g_verbose) {
        fprintf(stderr, "\nWarning: Not all type refs could be resolved (ignore if these are all custom attributes):\n");
        PrintNames(g_pTRNotFound);
        fprintf(stderr, "\n");
    }

    return S_OK;

 outofmemory:
    hr = PrintOutOfMemory();

 exit:
    if (mmr)
        delete mmr;

    return hr;
}


// For each class that is not a duplicate, emits a ComType in the new scope.
HRESULT ThirdPass(ManifestWriter *mw, int iNumFiles, int iNumDependents, ModuleReader rgModReaders[])
{
    int     iTemp;
    int     i;
    HRESULT hr = S_OK;

    if (g_iAFileIndex == -1) {
        //convert to lowercase
        _wcslwr(mw->m_wszAssemblyName);

        if (CheckForDuplicateName(mw->m_wszAssemblyName) == S_FALSE) {
            PrintError("The manifest file name will be the same as a module in this assembly");
            return E_FAIL;
        }
    }

    for (i = 0; i < iNumFiles; i++)
    {
        iTemp = strlen(rgModReaders[i].m_szFinalPathName) + 1;

        /*
        // We really want to copy the .dll, not the .tlb
        if ((iTemp >= 4) &&
            (!_stricmp(&rgModReaders[i].m_szFinalPathName[iTemp-5], ".tlb"))) {
            HANDLE hFile = CreateFileA(rgModReaders[i].m_szFinalPath,
                                       GENERIC_READ,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL);

            if (hFile == INVALID_HANDLE_VALUE) {
                PrintError("Expected to find matching .dll in same directory as .tlb file");
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }
            CloseHandle(hFile);

            rgModReaders[i].m_szFinalPathName[iTemp-4] = 'd';
            rgModReaders[i].m_szFinalPathName[iTemp-3] = 'l';
            rgModReaders[i].m_szFinalPathName[iTemp-2] = 'l';
        }
        */


        if(FAILED(hr = mw->CopyFile(rgModReaders[i].m_szFinalPath,
                                    rgModReaders[i].m_szFinalPathName, 
                                    (i == g_iAFileIndex),
                                    g_CopyDir, g_remove, true)))
            return hr;

        if (mw->m_FusionCache) {
            if (g_iAFileIndex != -1) {
                PrintError("Putting files in the Fusion cache with the -a option is no longer supported");
                return E_NOTIMPL;
            }

            if (FAILED(hr = mw->CopyFileToFusion(rgModReaders[i].m_wszInputFileName,
                                                 g_pbOrig,
                                                 g_cbOrig,
                                                 rgModReaders[i].m_szFinalPath,
                                                 0, // 1 for if this file contains a manifest
                                                 true))) // false if the ext should not be changed to .mod
                return hr;
        }

        // Don't emit ComTypes for the runtime lib's file
        if (g_iRuntimeLib == i)
            continue;

        TypeData *pCurrentData = g_rgFileHashMaps[i].m_pDataHead;
        while(pCurrentData) {

            // Ignores this class if it's an unwanted duplicate
            if (IsUniqueType(pCurrentData, i)) {
                /*
                bool emit;
                if (pCurrentData->mdComType == mdComTypeNil)
                    emit = true; // Nil-scoped TR resolves to this type
                else {
                    TypeData *pTemp = pCurrentData;
                    while ((pTemp->pEncloser) &&
                           (IsTdNestedPublic(pTemp->dwAttrs)))
                        pTemp = pTemp->pEncloser->pData;
                    
                    emit = IsTdPublic(pTemp->dwAttrs);
                }
                */

                mdToken impl;
                if (pCurrentData->pEncloser) {
                    _ASSERTE(pCurrentData->pEncloser->pData->mdComType);
                    impl = pCurrentData->pEncloser->pData->mdComType;
                }
                else if (g_iAFileIndex == i)
                    impl = mdFileNil;
                else
                    impl = g_rgFiles[i];
                
                if (FAILED(hr = mw->EmitComType(pCurrentData->wszName,
                                                impl,
                                                pCurrentData->mdThisType,
                                                pCurrentData->dwAttrs,
                                                &pCurrentData->mdComType)))
                    return hr;
            }

            pCurrentData = pCurrentData->pNext;
        }

        hr = mw->CopyAssemblyRefInfo(&rgModReaders[i]);
    }

    return hr;
}


HRESULT ExamineResources(ManifestWriter *mw, ResourceModuleReader rgRMReaders[],
                         int iNumResources, int *piResourceIndexes,
                         char **argv)
{
    int        i;
    char       *szName;
    //    char       *szMimeType;
    char       *szFile;
    HRESULT    hr;
    DWORD      dwSize = 0;
    LMClassHashTable ResourceHashMap;
    bool       SaveInFile;

    if (!ResourceHashMap.Init(iNumResources))
        return PrintOutOfMemory();

    for(i = 0; i < iNumResources; i++)
    {
        if (argv[ piResourceIndexes[i] ][0] == 'T')
            SaveInFile = true;
        else if (argv[ piResourceIndexes[i] ][0] == 'F')
            SaveInFile = false;
        else
            goto badformat;

        if ( (!(szName = strchr(argv[ piResourceIndexes[i] ], ','))) || 
             //             (!(szMimeType = strchr(++szName, ',')))                 ||
             (!(szFile = strchr(++szName, ','))) )
            //             (szMimeType == szName+1) )
            goto badformat;

        if (FAILED(hr = rgRMReaders[i].InitInputFile(szName, ++szFile, !SaveInFile, mw->m_iHashAlgorithm)))
            return hr;

        rgRMReaders[i].m_wszResourceName[szFile - szName - 1] = '\0';

        if ((!wcscmp(rgRMReaders[i].m_wszResourceName, g_EvidenceResourceName)) &&
            (argv[ piResourceIndexes[i]-1 ][1] != 'e')) {
            PrintError(g_EvidenceReservedError);
            return E_FAIL;
        }

        TypeData *pData;
        if (ResourceHashMap.GetValue(rgRMReaders[i].m_wszResourceName,
                                     &pData, FALSE)) {
            PrintError("Each resource name must be unique");
            return E_FAIL;
        }

        if (!ResourceHashMap.InsertValue(rgRMReaders[i].m_wszResourceName,
                                         NULL, NULL))
            return PrintOutOfMemory();

        /*
        wchar_t wszMimeType[MAX_CLASS_NAME];
        mbstowcs(wszMimeType, szMimeType, MAX_CLASS_NAME);
        wszMimeType[szFile - szMimeType - 1] = '\0';
        */

        if (SaveInFile) {
            if (FAILED(hr = mw->EmitResource(rgRMReaders[i].m_wszResourceName, mdFileNil, dwSize)))
                return hr;
            
            dwSize += ( sizeof(DWORD) + rgRMReaders[i].m_dwFileSize );
        }
        else {
            mdFile mdFile;
            if (FAILED(hr = mw->EmitFile(&rgRMReaders[i], &mdFile)))
               return hr;
            if (FAILED(hr = mw->EmitResource(rgRMReaders[i].m_wszResourceName, mdFile, 0)))
                return hr;
        
            if(FAILED(hr = mw->CopyFile(rgRMReaders[i].m_szFinalPath,
                                        rgRMReaders[i].m_szFinalPathName, 
                                        false, g_CopyDir, g_remove, false)))
                return hr;

            if (!g_iCacheIndex) {
                wchar_t wszFilePath[MAX_PATH];
                mbstowcs(wszFilePath, rgRMReaders[i].m_szFinalPath, MAX_PATH);
                if (FAILED(hr = mw->CopyFileToFusion(wszFilePath,
                                                     g_pbOrig,
                                                     g_cbOrig,
                                                     rgRMReaders[i].m_szFinalPath,
                                                     0, false)))
                    return hr;
            }
        }
    }

    mw->m_dwBindFlags = iNumResources;
    return S_OK;

 badformat:
    PrintError("Resources must be listed in the format SaveInFile,ResourceName,File where SaveInFile is either True or False");
    return E_INVALIDARG;
}


HRESULT ExamineFiles(ManifestWriter *mw, int iNumFiles, int iNumDependents,
                     int iNumPlatforms, int *piFileIndexes,
                     int *piDependentIndexes,
                     DWORD *pdwPlatforms, char **argv)
{
    HRESULT      hr;
    ModuleReader *rgModReaders = NULL;

    g_pTRNotFound = NULL;
    g_pTRNotFoundTail = NULL;
    g_rgFileHashMaps = NULL;
    g_pFileNameHashMap = NULL;
    g_rgFiles = NULL;
    g_rgAssemblyRefs = NULL;    
    g_iEntryFile = -1;

    g_pFileNameHashMap = new LMClassHashTable;
    g_rgFileHashMaps = new LMClassHashTable[iNumFiles];
    rgModReaders = new ModuleReader[iNumFiles];
    if (!(g_pFileNameHashMap && g_rgFileHashMaps && rgModReaders)) {
        hr = PrintOutOfMemory();
        goto exit;
    }

    if ( (FAILED(hr = Init()))                                      ||
         (FAILED(hr = mw->Init()))                                  ||
         (FAILED(hr = FirstPass(mw, iNumFiles, iNumPlatforms,
                                piFileIndexes, pdwPlatforms,
                                rgModReaders, argv, &mw->m_dwManifestRVA))) ||
         (FAILED(hr = SecondPass(mw, iNumFiles, rgModReaders)))     ||
         (FAILED(hr = ExamineDependents(mw, iNumDependents,
                                        piDependentIndexes, argv))) )
        goto exit;

    
    if (g_iAFileIndex == -1)
        mw->AddExtensionToAssemblyName();

    if (FAILED(hr = mw->EmitManifest(g_pbOrig, g_cbOrig)))
        goto exit;

    hr = ThirdPass(mw, iNumFiles, iNumDependents, rgModReaders);

 exit:
    DeleteNames(g_pTRNotFound);

    if (rgModReaders)
        delete[] rgModReaders;

    if (g_pFileNameHashMap)
        delete g_pFileNameHashMap;

    if (g_rgFileHashMaps)
        delete[] g_rgFileHashMaps;

    if (g_rgAssemblyRefs)
        delete[] g_rgAssemblyRefs;

    if (g_rgFiles)
        delete[] g_rgFiles;

    return hr;
}


HRESULT FinishManifestFile(ManifestWriter *mw, int iNumResources,
                           int *piResourceIndexes, char **argv)
{
    ResourceModuleReader *rgRMReaders = NULL;
    HRESULT              hr;

    rgRMReaders = new ResourceModuleReader[iNumResources];
    if (!rgRMReaders)
        return PrintOutOfMemory();

    if (FAILED(hr = ExamineResources(mw, rgRMReaders, iNumResources,
                                     piResourceIndexes, argv)))
        goto exit;

    if (g_iAFileIndex == -1) {
        mw->SaveResourcesInNewPE(iNumResources, rgRMReaders);
        if (FAILED(hr = mw->FinishNewPE(g_pbOrig, g_cbOrig, g_StrongName)))
             goto exit;
    }
    else {
        char *szMetaData;
        DWORD dwMetaDataSize;
        if (FAILED(hr = mw->SaveMetaData(&szMetaData, &dwMetaDataSize)))
            goto exit;

        hr = mw->UpdatePE(szMetaData, dwMetaDataSize,
                          iNumResources, rgRMReaders);
        delete[] szMetaData;
    }

 exit:
    delete[] rgRMReaders;

    return hr;
}


HRESULT ResignAssembly(CHAR *szManifestFile)
{
    HRESULT hr = S_OK;
    WCHAR   wszManifestFile[MAX_PATH + 1];

    mbstowcs(wszManifestFile, szManifestFile, strlen(szManifestFile));
    wszManifestFile[strlen(szManifestFile)] = L'\0';

    // Update the output PE image with a strong name signature.
    if (!StrongNameSignatureGeneration(wszManifestFile, GetKeyContainerName(),
                                       NULL, NULL, NULL, NULL)) {
        hr = StrongNameErrorInfo();
        PrintError("Unable to resign strong name assembly");
    }

    return hr;
}


HRESULT ReadFileIntoBuffer(LPSTR szFile, BYTE **ppbBuffer, DWORD *pcbBuffer)
{
   HANDLE hFile = CreateFileA(szFile,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        PrintError("Unable to open %s", szFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *pcbBuffer = GetFileSize(hFile, NULL);
    *ppbBuffer = new BYTE[*pcbBuffer];
    if (!*ppbBuffer) {
        CloseHandle(hFile);
        return PrintOutOfMemory();
    }

    DWORD dwBytesRead;
    if (!ReadFile(hFile, *ppbBuffer, *pcbBuffer, &dwBytesRead, NULL)) {
        CloseHandle(hFile);
        PrintError("Unable to read %s", szFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    CloseHandle(hFile);

    return S_OK;
}

// Set a specific key container name (must be called before first call to
// GetKeyContainerName).
HRESULT SetKeyContainerName(char *szContainer)
{
    DWORD cbContainer = strlen(szContainer) + 1;

    g_wszKeyContainerName = new WCHAR[cbContainer];
    if (g_wszKeyContainerName == NULL)
        return E_OUTOFMEMORY;

    mbstowcs(g_wszKeyContainerName, szContainer, cbContainer - 1);
    g_wszKeyContainerName[cbContainer - 1] = L'\0';

    return S_OK;
}

// Generate a strong name key container name based on our process ID (unless a
// specific name has already been given, in which case that is returned
// instead).
LPWSTR GetKeyContainerName()
{
    char            szName[32];
    static WCHAR    wszName[32];

    if (g_wszKeyContainerName == NULL) {

        // Generate a name based on 'LM' and the current pid to minimize the
        // chance of collisions.
        sprintf(szName, "LM[%08X]", GetCurrentProcessId());
        mbstowcs(wszName, szName, strlen(szName));
        wszName[strlen(szName)] = L'\0';

        // If we've got an old key container lying around with the same name, delete
        // it now.
        StrongNameKeyDelete(wszName);

        g_wszKeyContainerName = wszName;
    }

    return g_wszKeyContainerName;
}


void __cdecl main(int argc, char **argv)
{
    int            i;
    HRESULT        hr;
    ManifestWriter *mw = NULL;

    int            *piFileIndexes = NULL;
    int            *piDependentIndexes = NULL;
    int            *piResourceIndexes = NULL;
    DWORD          *pdwPlatforms = NULL;
    int            iNumFiles = 0;
    int            iNumDependents = 0;
    int            iNumResources = 0;
    int            iNumPlatforms = 0;
    int            iSFileIndex = -1;
    int            iZFileIndex = 0;
    int            iYFileIndex = 0;
    int            iKFileIndex = 0;
    int            iKContIndex = 0;
    bool           bLocaleSet = false;
    bool           DontCheckSkipVerify = false;
    char*          strResourceReplacement;
    bool           bFoundEvidence = false;

    OnUnicodeSystem();      // initialize WIN32 wrapper
    g_verbose = true;

    for (i = 1; i < argc; i++) {
        if ((!strcmp(argv[i], "-q")) ||
            (!strcmp(argv[i], "/q"))) {
            g_verbose = false;
            break;
        }
    }

    Title();

    if (argc < 2) {
        Usage();
        exit(S_OK);
    }
    
    mw = new ManifestWriter();
    piFileIndexes = new int[argc];
    piDependentIndexes = new int[argc];
    piResourceIndexes = new int[argc];
    pdwPlatforms = new DWORD[argc];
    strResourceReplacement = NULL;

    if ( (!mw) || (!piFileIndexes) ||
         (!piDependentIndexes)     ||
         (!piResourceIndexes)      ||
         (!pdwPlatforms) ) {
        hr = PrintOutOfMemory();
        goto exit;
    }

    g_iAFileIndex = -1;
    g_iCacheIndex = 0;
    g_remove = false;
    g_CopyDir = false;
    g_iVersion = 0;
    g_iAsmName = 0;
    g_iOriginator = 0;
    g_StrongName = false;
    g_wszKeyContainerName = NULL;

    for (i = 1; i < argc; i++) {

        if ((strlen(argv[i]) == 2) &&
            ((argv[i][0] == '-') || (argv[i][0] == '/'))) {
            switch(argv[i][1]) {
            case 'e':
                if (bFoundEvidence) {
                    Usage();
                    PrintError("Only one evidence blob can be added to an assembly");
                    goto invalidarg;
                }
                if (i+1 >= argc || argv[i+1][0] == '-') {
                    Usage();
                    PrintError("'-e' option requires a filename");
                    goto invalidarg;
                }
                bFoundEvidence = TRUE;
                // Evidence is just a special type of resource, so make the resource array point to it...
                piResourceIndexes[iNumResources] = i+1;
                iNumResources++;
                // ...build a string that the resource parser expects....
                strResourceReplacement = new char[strlen( g_EvidenceString ) + strlen( argv[i+1] )];
                strcpy( strResourceReplacement, g_EvidenceString );
                strcpy( &strResourceReplacement[strlen( g_EvidenceString )], argv[i+1] );
                // ...and replace the command line argument.
                argv[i+1] = strResourceReplacement;
                ++i;
                break;

            case 'f':
                for (i++; (i < argc) && (argv[i][0] != '-'); i++) {
                    piFileIndexes[iNumFiles] = i;
                    iNumFiles++;
                }
                i--;
                break;
                
            case 'i':
                for (i++; (i < argc) && (argv[i][0] != '-'); i++) {
                    piDependentIndexes[iNumDependents] = i;
                    iNumDependents++;
                }
                i--;
                break;

            case 'r':
                for (i++; (i < argc) && (argv[i][0] != '-'); i++) {
                    piResourceIndexes[iNumResources] = i;
                    iNumResources++;
                }
                i--;
                break;

            case 'l':
                if (bLocaleSet) {
                    Usage();
                    PrintError("Too many -l locales specified");
                    goto invalidarg;
                }
                if (++i == argc) {
                    Usage();
                    PrintError("Missing -l locale parameter");
                    goto invalidarg;
                }

                mw->SetLocale(argv[i]);
                bLocaleSet = true;
                break;

            case 'p':
                for (i++; (i < argc) && (argv[i][0] != '-'); i++) {
                    if (!strcmp(argv[i], "x86"))
                        pdwPlatforms[iNumPlatforms] = IMAGE_FILE_MACHINE_I386;
                    else if (!strcmp(argv[i], "alpha"))
                        pdwPlatforms[iNumPlatforms] = IMAGE_FILE_MACHINE_ALPHA;
                    else {
                        PrintError("Platform %s is not supported", argv[i]);
                        goto invalidarg;
                    }
                    
                    mw->SetPlatform(argv[i]);
                    iNumPlatforms++;
                }
                i--;
                break;

            case 'z':
                if (iZFileIndex) {
                    Usage();
                    PrintError("Too many -z files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -z file parameter");
                    goto invalidarg;
                }

                iZFileIndex = i;
                break;

            case 'h':
                if (++i == argc) {
                    Usage();
                    PrintError("Missing hash algorithm parameter");
                    goto invalidarg;
                }

                if (mw->m_iHashAlgorithm) {
                    PrintError("Too many hash algorithm parameters given");
                    goto invalidarg;
                }
                
                if (!strcmp(argv[i], "MD5"))
                    mw->m_iHashAlgorithm = CALG_MD5;
                else if (!strcmp(argv[i], "SHA1"))
                    mw->m_iHashAlgorithm = CALG_SHA1;
                else {
                    Usage();
                    PrintError("Given hash algorithm is not supported");
                    goto invalidarg;
                }
                break;

            case 'a':
                if (g_iAFileIndex != -1) {
                    Usage();
                    PrintError("Too many -a files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -a file parameter");
                    goto invalidarg;
                }

                if (g_verbose)
                    fprintf(stderr, "\nWarning: The -a option has been deprecated.\n");
                
                // argv[i] = Input file which will contain the new manifest
                g_iAFileIndex = iNumFiles;
                piFileIndexes[iNumFiles] = i;
                iNumFiles++;
                break;

            case 'c':
                if (g_iCacheIndex) {
                    Usage();
                    PrintError("Too many -c paths specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -c cache parameter");
                    goto invalidarg;
                }
                
                g_iCacheIndex = i;
                break;

            case 'n':
                if (g_iAsmName) {
                    Usage();
                    PrintError("Too many assembly names specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -n assembly name parameter");
                    goto invalidarg;
                }
                
                g_iAsmName = i;
                break;
                
            case 'd':
            g_CopyDir = true;
            break;

            case 'x':
            g_remove = true;
            break;

            case 'v':
                if (g_iVersion) {
                    Usage();
                    PrintError("Too many -v versions specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -v version parameter");
                    goto invalidarg;
                }
                
                g_iVersion = i;
                break;

            case 's':
                if (iSFileIndex != -1) {
                    Usage();
                    PrintError("Too many -s files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -s file parameter");
                    goto invalidarg;
                }
                
                iSFileIndex = i;
                break;

            case 'o':
                if (g_iOriginator) {
                    Usage();
                    PrintError("Too many -o originator files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -o originator parameter");
                    goto invalidarg;
                }

                g_iOriginator = i;
                break;

            case 'k':
                if (iKFileIndex) {
                    Usage();
                    PrintError("Too many -k key pair files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -k key pair parameter");
                    goto invalidarg;
                }
                
                iKFileIndex = i;
                break;

            case 'K':
                if (iKContIndex) {
                    Usage();
                    PrintError("Too many -K key pair containers specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -K key pair parameter");
                    goto invalidarg;
                }

                iKContIndex = i;
                break;

            case 't':
                g_StrongName = true;
                break;

            case 'y':
                if (iYFileIndex) {
                    Usage();
                    PrintError("Too many -y files specified");
                    goto invalidarg;
                }

                if (++i == argc) {
                    Usage();
                    PrintError("Missing -y file parameter");
                    goto invalidarg;
                }
                
                iYFileIndex = i;
                break;

            case 'q':
                break;

            case 'u':
                DontCheckSkipVerify = true;
                break;

            case '?':
                Usage();
                hr = S_OK;
                goto exit;

            default:
                Usage();
                PrintError("Unknown option: %s", argv[i]);
                goto invalidarg;
            }
        }
        else {
            Usage();
            PrintError("Unknown argument: %s", argv[i]);
            goto invalidarg;
        }
    }

    // Default file time for Fusion
    GetSystemTimeAsFileTime(&mw->m_FileTime);

    // Default hash algorithm is SHA1
    if (!mw->m_iHashAlgorithm)
        mw->m_iHashAlgorithm = CALG_SHA1;

    if (iZFileIndex) {
        if (iNumFiles || iNumDependents || iNumResources) {
            Usage();
            PrintError("Invalid use of -z option");
        }
        else
            hr = CopyFilesToFusion(mw, iZFileIndex, argv);

        goto exit;
    }

    if ((g_iAFileIndex == -1) && !iYFileIndex) {
        if (!g_iAsmName) {
            Usage();
            PrintError("Must specify an assembly name (-n) if not using -a option");
            goto invalidarg;
        }

        if (strrchr(argv[g_iAsmName], '\\')) {
            PrintError("An assembly name cannot contain the character '\\'");
            goto invalidarg;
        }
        
        if (!iNumFiles && !iNumResources) { 
            Usage();
            PrintError("Insufficient number of input files");
            goto invalidarg;
        }
    } else if (g_StrongName) {
        Usage();
        PrintError("-t option incompatible with -a and -y options");
        goto invalidarg;
    }

    if (g_iOriginator && argv[g_iOriginator])
        if (FAILED(hr = ReadFileIntoBuffer(argv[g_iOriginator],
                                           &g_pbOrig,
                                           &g_cbOrig)))
            goto exit;

    if (iKFileIndex && argv[iKFileIndex]) {
        if (iKContIndex) {
            Usage();
            PrintError("Can't specify both -k and -K options");
            goto invalidarg;
        }
        // Read public/private key pair into memory.
        PBYTE pbKeyPair;
        DWORD cbKeyPair;
        if (FAILED(hr = ReadFileIntoBuffer(argv[iKFileIndex],
                                           &pbKeyPair,
                                           &cbKeyPair)))
            goto exit;
        // Install the key pair into a temporary container.
        if (!StrongNameKeyInstall(GetKeyContainerName(), pbKeyPair, cbKeyPair)) {
            PrintError("Unable to install strong name key");
            hr = StrongNameErrorInfo();
            goto exit;
        }
    } else if (iKContIndex && argv[iKContIndex]) {
        // Record the container name used to retrieve key pair.
        if (FAILED(hr = SetKeyContainerName(argv[iKContIndex])))
            goto exit;
    } else if (g_StrongName || iYFileIndex) {
        // Else generate a temporary key pair.
        if (!StrongNameKeyGen(GetKeyContainerName(), SN_LEAVE_KEY, NULL, NULL)) {
            PrintError("Unable to generate strong name key");
            hr = StrongNameErrorInfo();
            goto exit;
        }
    }

    if ((g_StrongName || iYFileIndex || iKFileIndex || iKContIndex) && (g_pbOrig == NULL)) {
        // If no originator was provided, derive it from the key pair (it's
        // essentially a wrapped version of the public key).
        if (!StrongNameGetPublicKey(GetKeyContainerName(),
                                    NULL,
                                    NULL,
                                    &g_pbOrig,
                                    &g_cbOrig)) {
            hr = StrongNameErrorInfo();
            PrintError("Failed to derive originator from key pair");
            goto exit;
        }
    }

    if (iYFileIndex) {
        if (iNumFiles || iNumDependents || iNumResources) {
            Usage();
            PrintError("Invalid use of -y option");
            goto invalidarg;
        }

        hr = ResignAssembly(argv[iYFileIndex]);
        goto exit;
    }

    if (FAILED(hr = ExamineFiles(mw, iNumFiles, iNumDependents,
                                 iNumPlatforms, piFileIndexes,
                                 piDependentIndexes, pdwPlatforms, argv)))
        goto exit;

    if (DontCheckSkipVerify)
        g_SkipVerification = false;

    if ((iSFileIndex != -1) || g_SkipVerification)
        if (FAILED(hr = mw->EmitRequestPermissions((iSFileIndex != -1) ? argv[iSFileIndex] : NULL,
                                                   g_SkipVerification)))
            goto exit;

    hr = FinishManifestFile(mw, iNumResources, piResourceIndexes, argv);
    goto exit;

    
 invalidarg:
    hr = E_INVALIDARG;
    
 exit:
    if (mw)
        delete mw;

    if (piFileIndexes)
        delete[] piFileIndexes;

    if (piDependentIndexes)
        delete[] piDependentIndexes;

    if (piResourceIndexes)
        delete[] piResourceIndexes;

    if (pdwPlatforms)
        delete[] pdwPlatforms;

    if (!iKContIndex)
        StrongNameKeyDelete(GetKeyContainerName());
    else
        delete [] g_wszKeyContainerName;

    if (strResourceReplacement != NULL)
        delete [] strResourceReplacement;


    Cleanup();

    exit(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\metainfo\mdinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mdinfo.h
//
//*****************************************************************************
#ifndef _mdinfo_h
#define _mdinfo_h

#include "winwrap.h"
#include "cor.h"
#include "corhlpr.h"

#define STRING_BUFFER_LEN 1024

typedef void (*strPassBackFn)(char *str);

class MDInfo {
public:
	enum DUMP_FILTER
	{
		dumpDefault		= 0x00000000,				// Dump everything but debugger data.
		dumpSchema		= 0x00000002,				// Dump the metadata schema.
		dumpRaw			= 0x00000004,				// Dump the metadata in raw table format.
		dumpHeader		= 0x00000008,				// Dump just the metadata header info.
		dumpCSV			= 0x00000010,				// Dump the metadata header info in CSV format.
		dumpUnsat		= 0x00000020,				// Dump unresolved methods or memberref
		dumpAssem		= 0x00000040,
		dumpStats		= 0x00000080,				// Dump more statistics about tables.
		dumpMoreHex		= 0x00000100,				// Dump more things in hex.
        dumpValidate    = 0x00000200,               // Validate MetaData.
        dumpRawHeaps    = 0x00000400,               // Also dump the heaps in the raw dump.
		dumpNoLogo		= 0x00000800,				// Don't display the logo or MVID
	};


public:
	MDInfo(IMetaDataImport* pImport, IMetaDataAssemblyImport* pAssemblyImport, LPCWSTR szScope, strPassBackFn inPBFn, ULONG DumpFilter);
    MDInfo(IMetaDataDispenserEx *pDispenser, LPCWSTR  szScope, strPassBackFn inPBFn, ULONG DumpFilter=dumpDefault);
    MDInfo(IMetaDataDispenserEx *pDispenser, PBYTE pManifest, DWORD dwSize, strPassBackFn inPBFn, ULONG DumpFilter=dumpDefault);
    ~MDInfo();

    void DisplayMD(void);

    LPWSTR VariantAsString(VARIANT *pVariant);

    void DisplayVersionInfo(void);

    void DisplayScopeInfo(void);

    void DisplayGlobalFunctions(void);
	void DisplayGlobalFields(void);
	void DisplayFieldRVA(mdFieldDef field);
	void DisplayGlobalMemberRefs(void);

    void DisplayTypeDefs(void);
    void DisplayTypeDefInfo(mdTypeDef inTypeDef);
    void DisplayTypeDefProps(mdTypeDef inTypeDef);
    
    void DisplayModuleRefs(void);
    void DisplayModuleRefInfo(mdModuleRef inModuleRef);

	void DisplaySignatures(void);
	void DisplaySignatureInfo(mdSignature inSignature);

    LPCWSTR TokenName(mdToken inToken, LPWSTR buffer, ULONG bufLen);

    LPCWSTR TypeDeforRefName(mdToken inToken, LPWSTR buffer, ULONG bufLen);
    LPCWSTR TypeDefName(mdTypeDef inTypeDef, LPWSTR buffer, ULONG bufLen);
    LPCWSTR TypeRefName(mdTypeRef tr, LPWSTR buffer, ULONG bufLen);

    LPCWSTR MemberDeforRefName(mdToken inToken, LPWSTR buffer, ULONG bufLen);
    LPCWSTR MemberRefName(mdToken inMemRef, LPWSTR buffer, ULONG bufLen);
    LPCWSTR MemberName(mdToken inMember, LPWSTR buffer, ULONG bufLen);

    LPCWSTR MethodName(mdMethodDef inToken, LPWSTR buffer, ULONG bufLen);
    LPCWSTR FieldName(mdFieldDef inToken, LPWSTR buffer, ULONG bufLen);

    char *ClassFlags(DWORD flags, char *sFlags);

    void DisplayTypeRefs(void);
    void DisplayTypeRefInfo(mdTypeRef tr);
    void DisplayTypeSpecs(void);
    void DisplayTypeSpecInfo(mdTypeSpec ts, const char *preFix);
    
    void DisplayCorNativeLink(COR_NATIVE_LINK *pCorNLnk, const char *preFix);
    void DisplayCustomAttributeInfo(mdCustomAttribute inValue, const char *preFix);
    void DisplayCustomAttributes(mdToken inToken, const char *preFix);

    void DisplayInterfaceImpls(mdTypeDef inTypeDef);
    void DisplayInterfaceImplInfo(mdInterfaceImpl inImpl);

    LPWSTR GUIDAsString(GUID inGuid, LPWSTR guidString, ULONG bufLen);

    char *VariantTypeName(ULONG valueType, char *szAttr);
    char *TokenTypeName(mdToken inToken);

    // Com99 function prototypes

    void DisplayMemberInfo(mdToken inMember);
    void DisplayMethodInfo(mdMethodDef method, DWORD *pflags = 0);
    void DisplayFieldInfo(mdFieldDef field, DWORD *pflags = 0);
    
    void DisplayMethods(mdTypeDef inTypeDef);
    void DisplayFields(mdTypeDef inTypeDef, COR_FIELD_OFFSET *rFieldOffset, ULONG cFieldOffset);

    void DisplaySignature(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, const char *preFix);
    HRESULT GetOneElementType(PCCOR_SIGNATURE pbSigBlob, ULONG ulSigBlob, ULONG *pcb);

    void DisplayMemberRefs(mdToken tkParent, const char *preFix);
    void DisplayMemberRefInfo(mdMemberRef inMemRef, const char *preFix);

    void DisplayMethodImpls(mdTypeDef inTypeDef);

    void DisplayParams(mdMethodDef inMthDef);
    void DisplayParamInfo(mdParamDef inParam);

    void DisplayPropertyInfo(mdProperty inProp);
    void DisplayProperties(mdTypeDef inTypeDef);

    void DisplayEventInfo(mdEvent inEvent);
    void DisplayEvents(mdTypeDef inTypeDef);

    void DisplayPermissions(mdToken tk, const char *preFix);
    void DisplayPermissionInfo(mdPermission inPermission, const char *preFix);

    void DisplayFieldMarshal(mdToken inToken);

	void DisplayPinvokeInfo(mdToken inToken);

	void DisplayAssembly();

    void DisplayAssemblyInfo();

	void DisplayAssemblyRefs();
	void DisplayAssemblyRefInfo(mdAssemblyRef inAssemblyRef);

	void DisplayFiles();
	void DisplayFileInfo(mdFile inFile);

	void DisplayExportedTypes();
	void DisplayExportedTypeInfo(mdExportedType inExportedType);

	void DisplayManifestResources();
	void DisplayManifestResourceInfo(mdManifestResource inManifestResource);

	void DisplayASSEMBLYMETADATA(ASSEMBLYMETADATA *pMetaData);

	void DisplayUserStrings();

    void DisplayUnsatInfo();

	void DisplayRaw();
    void DumpRawHeaps();
	void DumpRaw(int iDump=1, bool bStats=false);
	void DumpRawCSV();
	void DumpRawCol(ULONG ixTbl, ULONG ixCol, ULONG rid, bool bStats);
	ULONG DumpRawColStats(ULONG ixTbl, ULONG ixCol, ULONG cRows);
	const char *DumpRawNameOfType(ULONG ulType);
	void SetVEHandlerReporter(__int64 VEHandlerReporterPtr) { m_VEHandlerReporterPtr = VEHandlerReporterPtr; };

    static void Error(const char *szError, HRESULT hr = S_OK);
private:
    void Init(strPassBackFn inPBFn, DUMP_FILTER DumpFilter); // Common initialization code.

    int DumpHex(const char *szPrefix, const void *pvData, ULONG cbData, int bText=true, ULONG nLine=16);

    int Write(char *str);
    int WriteLine(char *str);

    int VWrite(char *str, ...);
    int VWriteLine(char *str, ...);
	int	VWrite(char *str, va_list marker);
    
	void InitSigBuffer();
	HRESULT AddToSigBuffer(char *string);

    IMetaDataImport *m_pRegImport;
    IMetaDataImport *m_pImport;
    IMetaDataAssemblyImport *m_pAssemblyImport;
    strPassBackFn m_pbFn;
	__int64 m_VEHandlerReporterPtr;
	IMetaDataTables *m_pTables;

	CQuickBytes m_output;
    DUMP_FILTER m_DumpFilter;

	// temporary buffer for TypeDef or TypeRef name. Consume immediately
	// because other functions may overwrite it.
	WCHAR			m_szTempBuf[STRING_BUFFER_LEN];

	// temporary buffer for formatted string. Consume immediately before any function calls.
	char			m_tempFormatBuffer[STRING_BUFFER_LEN];

	// Signature buffer.
	CQuickBytes		m_sigBuf;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\metainfo\metainfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: metainfo.cpp
//
//*****************************************************************************
#include <stdio.h>
#include <ctype.h>
#include <crtdbg.h>
#include <utilcode.h>
#include "mdinfo.h"

#include "__file__.ver"
#include <corver.h>

// Global variables
bool g_bSchema = false; 
bool g_bRaw = false;
bool g_bDebug = false;
bool g_bHeader = false;

// Validator module type.
DWORD g_ValModuleType = ValidatorModuleTypeInvalid;

IMetaDataImport *g_pImport = NULL;
IMetaDataDispenserEx *g_pDisp = NULL;

void DisplayFile(wchar_t* szFile, BOOL isFile, ULONG DumpFilter, wchar_t* szObjFile, strPassBackFn pDisplayString);
void DisplayArchive(wchar_t* szFile, ULONG DumpFilter, wchar_t* szObjName, strPassBackFn pDisplayString);

extern BOOL OnUnicodeSystem();

void PrintLogo()
{
    printf("Microsoft (R) .Net Frameworks Runtime Meta Data Dump Utility   Version %s\n", VER_FILEVERSION_STR);
    wprintf(VER_LEGALCOPYRIGHT_DOS_STR);
    printf("\n");
}// PrintLogo

void Usage()
{
    printf("\n");
    printf("metainfo [-? | -header | -schema | -raw | -validate] [-nologo] [-obj <obj file name>] [<filname> | <file pattern>]\n");
    printf("    -?       Displays this text.\n");
    printf("    -hex     Prints more things in hex as well as words.\n");
    printf("    -header  Prints MetaData header information and sizes.\n");
    printf("    -csv     Prints the header sizes in Comma Separated format.\n");
    printf("    -unsat   Prints unresolved externals.\n");
    printf("    -assem   Prints only the Assembly information.\n");
    printf("    -schema  Prints the MetaData schema information.\n");
    printf("    -raw     Prints the raw MetaData tables.\n");
    printf("    -heaps   Prints the raw heaps (only if -raw).\n");
    printf("    -validate Validate the consistency of the metadata.\n");
    printf("    -nologo  Do not display the logo and MVID.\n");
    printf("    -obj <objFileName>\n");
    printf("             Prints the MetaData for the specified obj file in the given \n");
    printf("             archive(.lib) - e.g metainfo libc.lib -obj wMSILWinCRTStartup.obj\n");

    MDInfo::Error("");
}

void DisplayString(char *str)
{
    printf("%s", str);
}

extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    wchar_t *pArg = NULL;
    wchar_t *szObjName = NULL;
    ULONG DumpFilter = MDInfo::dumpDefault;
    HRESULT hr = 0;
    BOOL    fWantHelp=FALSE;
    
    // Validate incoming arguments
    for (int i=1;  i<argc;  i++)
    {
        const wchar_t *szArg = argv[i];
        if (*szArg == L'-' || *szArg == L'/')
        {
            if (_wcsicmp(szArg + 1, L"?") == 0)
                fWantHelp=TRUE;

            else if (_wcsicmp(szArg + 1, L"nologo") == 0)
                DumpFilter |= MDInfo::dumpNoLogo;

            else if (_wcsicmp(szArg + 1, L"Hex") == 0)
                DumpFilter |= MDInfo::dumpMoreHex;

            else if (_wcsicmp(szArg + 1, L"header") == 0)
                DumpFilter |= MDInfo::dumpHeader;

            else if (_wcsicmp(szArg + 1, L"csv") == 0)
                DumpFilter |= MDInfo::dumpCSV;

            else if (_wcsicmp(szArg + 1, L"raw") == 0)
                DumpFilter |= MDInfo::dumpRaw;

            else if (_wcsicmp(szArg + 1, L"heaps") == 0)
                DumpFilter |= MDInfo::dumpRawHeaps;

            else if (_wcsicmp(szArg + 1, L"schema") == 0)
                DumpFilter |= MDInfo::dumpSchema;

            else if (_wcsicmp(szArg + 1, L"unsat") == 0)
                DumpFilter |= MDInfo::dumpUnsat;

            else if (_wcsicmp(szArg + 1, L"stats") == 0)
                DumpFilter |= MDInfo::dumpStats;

            else if (_wcsicmp(szArg + 1, L"assem") == 0)
                DumpFilter |= MDInfo::dumpAssem;

            else if (_wcsicmp(szArg + 1, L"validate") == 0)
                DumpFilter |= MDInfo::dumpValidate;

            else if (_wcsicmp(szArg + 1, L"obj") == 0)
            {
                if (++i == argc)
                    Usage();
                else
                    szObjName = argv[i];
            }
        }
        else
            pArg = argv[i];
    }

    // Print banner.
    if (!(DumpFilter & MDInfo::dumpNoLogo))
        PrintLogo();


    if (!pArg || fWantHelp)
        Usage();

    
    // Init and run.
    CoInitialize(0);    
    CoInitializeCor(0);

    hr = CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER, 
                  IID_IMetaDataDispenserEx, (void **) &g_pDisp);
    if(FAILED(hr)) MDInfo::Error("Unable to CoCreate Meta-data Dispenser", hr);

    // Loop through all files in the file pattern passed
    WIN32_FIND_DATA fdFiles;
    HANDLE hFind;
    wchar_t szSpec[_MAX_PATH];
    wchar_t szDrive[_MAX_DRIVE];
    wchar_t szDir[_MAX_DIR];

    OnUnicodeSystem();

    hFind = WszFindFirstFile(pArg, &fdFiles);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        DisplayFile(pArg, false, DumpFilter, szObjName, DisplayString);
    }
    else
    {
        // Convert relative paths to full paths.
        LPWSTR szFname;
        WszGetFullPathName(pArg, _MAX_PATH, szSpec, &szFname);
        SplitPath(szSpec, szDrive, szDir, NULL, NULL);
        do
        {
            MakePath(szSpec, szDrive, szDir, fdFiles.cFileName, NULL);
            // display the meta data of the file
            DisplayFile(szSpec, true, DumpFilter, szObjName, DisplayString);
        } while (WszFindNextFile(hFind, &fdFiles)) ;
        FindClose(hFind);
    }
    g_pDisp->Release();
    CoUninitializeCor();
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\common.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: common.cpp
//
//*****************************************************************************

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\metainfo\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "METAINFO.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Metadata Info\0"
#define VER_ORIGFILENAME_STR    "metainfo.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\metainfo\mdobj.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mdobj.cpp
//
//*****************************************************************************
#include <stdio.h>
#include <ctype.h>
#include <crtdbg.h>
#include "mdinfo.h"

#ifndef STRING_BUFFER_LEN
#define STRING_BUFFER_LEN 255
#endif

#define OBJ_EXT         ".obj"
#define OBJ_EXT_W       L".obj"
#define OBJ_EXT_LEN     4
#define LIB_EXT         ".lib"
#define LIB_EXT_W       L".lib"
#define LIB_EXT_LEN     4

extern IMetaDataDispenserEx *g_pDisp;
extern DWORD g_ValModuleType;

// This function is copied from peparse.c file.  Making this static, so we won't end up with
// duplicate definitions causing confusion.
static const char g_szCORMETA[] = ".cormeta";
static HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData)
{
    IMAGE_FILE_HEADER *pImageHdr;       // Header for the .obj file.
    IMAGE_SECTION_HEADER *pSectionHdr;  // Section header.
    WORD        i;                      // Loop control.

    // Get a pointer to the header and the first section.
    pImageHdr = (IMAGE_FILE_HEADER *) pImage;
    pSectionHdr = (IMAGE_SECTION_HEADER *)(pImageHdr + 1);

    // Avoid confusion.
    *ppMetaData = NULL;
    *pcbMetaData = 0;

    // Walk each section looking for .cormeta.
    for (i=0;  i<pImageHdr->NumberOfSections;  i++, pSectionHdr++)
    {
        // Simple comparison to section name.
        if (strcmp((const char *) pSectionHdr->Name, g_szCORMETA) == 0)
        {
            *pcbMetaData = pSectionHdr->SizeOfRawData;
            *ppMetaData = (void *) ((long) pImage + pSectionHdr->PointerToRawData);
            break;
        }
    }

    // Check for errors.
    if (*ppMetaData == NULL || *pcbMetaData == 0)
        return (E_FAIL);
    return (S_OK);
}


// This function returns the address to the MapView of file and file size.
void GetMapViewOfFile(wchar_t *szFile, PBYTE *ppbMap, DWORD *pdwFileSize)
{
    HANDLE      hMapFile;
    DWORD       dwHighSize;

    HANDLE hFile = WszCreateFile(szFile,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL); 
    if (hFile == INVALID_HANDLE_VALUE) 
        MDInfo::Error("CreateFileA failed!");

    *pdwFileSize = GetFileSize(hFile, &dwHighSize);

    if ((*pdwFileSize == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
        MDInfo::Error("GetFileSize failed!");
    _ASSERTE(dwHighSize == 0);

    hMapFile = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    CloseHandle(hFile);
    if (!hMapFile)
        MDInfo::Error("CreateFileMappingA failed!");

    *ppbMap = (PBYTE) MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMapFile);
    
    if (!*ppbMap)
        MDInfo::Error("MapViewOfFile failed!");
} // void GetMapViewOfFile()

// This function skips a member given the pointer to the member header
// and returns a pointer to the next hea