ragma hdrstop

#include <ntddk.h>
#include "TSQ.h"
#include "TSQPublic.h"

#define TSQ_TAG 'QST '

//=================================================================================
//
//  TSInitQueue
//      This function initializes the TS queue with the specified parameters.
//
//  Inputs:
//      Flags: Properties of the TS Queue.
//      MaxThreads: Max number of worker threads to process the item.
//
//  Return value:
//      Pointer to the TS Queue. NULL if init failed for any reason.
//      BUGBUG: Better to have a status: 
//              Access denied, Invalid parameters, memory failure or success.
//      
//=================================================================================

PVOID TSInitQueue( 
        IN ULONG Flags,         
        IN ULONG MaxThreads,    
        IN PDEVICE_OBJECT pDeviceObject
        )
{
    PTSQUEUE    pTsQueue = NULL;

    // Validate the inputs.
    if ( ( Flags & TSQUEUE_BEING_DELETED ) || 
         ( MaxThreads > MAX_WORKITEMS ) || 
         ( pDeviceObject == NULL ) ) {
        // BUGBUG: Ideally should check all the bits in the flags using mask.
        goto Exit;
    }

    // If the caller wants TS Queue to use its own thread, then caller must be running at PASSIVE_LEVEL.
    if ( ( KeGetCurrentIrql() != PASSIVE_LEVEL ) && 
         ( Flags & TSQUEUE_OWN_THREAD ) ) {
        goto Exit;
    }

    // Allocate space for the new TS Queue.
    pTsQueue = (PTSQUEUE) ExAllocatePoolWithTag( NonPagedPool, sizeof( TSQUEUE ), TSQ_TAG );
    if (pTsQueue == NULL) {
        goto Exit;
    }

    // Initialize the terminate event.
    KeInitializeEvent( &pTsQueue->TerminateEvent, NotificationEvent, FALSE );

    // Initialize the TS Queue spin lock.
    KeInitializeSpinLock( &pTsQueue->TsqSpinLock );

    // Initialize the list of work items and number of items being processed.
    InitializeListHead( &pTsQueue->WorkItemsHead );
    pTsQueue->ThreadsCount = 0;

    // Initialize the rest of the TS Queue fields as specified in the inputs.
    pTsQueue->Flags = Flags;
    pTsQueue->MaxThreads = MaxThreads;
    pTsQueue->pDeviceObject = pDeviceObject;

Exit:
    return ( PVOID ) pTsQueue;
}


//=================================================================================
//
//  TSAddWorkItemToQueue
//      This function allocates a work item (TSQ type) and adds it to the queue
//      from where it is processed by either system queue thread or TS queue 
//      worker thread. 
//
//  Inputs:
//      TS Queue: To which the work item is to be added.
//      pContext: Caller context.
//      CallBack: The user's callback routine 
//
//  Return value:
//      Status of the operation:
//          STATUS_INVALID_PARAMETER: Incorrect TS Queue pointer, OR
//          STATUS_ACCESS_DENIED: The queue is being deleted, OR
//          STATUS_NO_MEMORY: Insufficient resources OR
//          STATUS_SUCCESS: Operation successful.
//      
//=================================================================================

NTSTATUS TSAddWorkItemToQueue(
        IN PTSQUEUE pTsQueue,       // Pointer to the TS Queue.
        IN PVOID pContext,          // Context.
        IN PTSQ_CALLBACK pCallBack  // Callback function.    
        )
{
    KIRQL       Irql;
    NTSTATUS    Status;
    PTSQUEUE_WORK_ITEM pWorkItem = NULL;
    HANDLE      ThreadHandle;

    // Check if the Input TS Queue pointer is valid.
    // May be we need a better error check on TS Queue pointer here (Like use of signature)
    // I don't need to care about validity of the other parameters.
    if ( pTsQueue == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate space for the new work item (TSQ type).
    // NOTE: Allocation is done before validation, because this is a costly operation and we
    // don't want to do it with spin-lock held for perf reasons.
    pWorkItem = (PTSQUEUE_WORK_ITEM) ExAllocatePoolWithTag( NonPagedPool, sizeof( TSQUEUE_WORK_ITEM ), TSQ_TAG );
    if ( pWorkItem == NULL ) {
        return STATUS_NO_MEMORY;
    }

    // Initialize the TSQ work item.
    pWorkItem->pContext = pContext;
    pWorkItem->pCallBack = pCallBack;

    // Acquire the Queue spin lock first.
    KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );

    // Check if this queue is being deleted. If so, return error.
    if ( pTsQueue->Flags & TSQUEUE_BEING_DELETED ) {
        KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );
        if ( pWorkItem ) {
            ExFreePool( pWorkItem );
        }
        return STATUS_ACCESS_DENIED;
    }

    // All right, insert the work item in TS queue.
    InsertTailList( &pTsQueue->WorkItemsHead, &pWorkItem->Links );

    // NOTE: Once the work item is queued, we are going to return status success anyway.
    // Failed cases, if any, will be handled either by already running worker threads or
    // later when the queue is deleted.

    // Check if we need to start another worker thread.
    if ( pTsQueue->ThreadsCount >= pTsQueue->MaxThreads ) {
        // Do nothing else, when there are already enough number of worker threads serving the queue.
        KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );
        return STATUS_SUCCESS;
    }
        
    // We are about to start a new thread (own thread or system thread).
    // So, increment the thread count and release the spin lock.
    pTsQueue->ThreadsCount ++;
    KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );

    // Check if we are allowed to start a worker thread.
    if ( ( pTsQueue->Flags & TSQUEUE_OWN_THREAD ) && 
         ( KeGetCurrentIrql() == PASSIVE_LEVEL ) ) {
        // We can create our own thread for processing work item.
        Status = PsCreateSystemThread(  &ThreadHandle,
                                        THREAD_ALL_ACCESS,
                                        NULL,
                                        NULL,
                                        NULL,
                                        (PKSTART_ROUTINE) TSQueueWorker,
                                        (PVOID) pTsQueue );
        if ( Status != STATUS_SUCCESS ) {
            goto QueueError;
        }

        ZwClose( ThreadHandle );
    }
    else {  // Means, we can not create thread. Then call IOQueueWorkItem.
        PIO_WORKITEM pIoWorkItem = NULL;
        PTSQ_CONTEXT pTsqContext = NULL;
        WORK_QUEUE_TYPE QueueType = ( pTsQueue->Flags & TSQUEUE_CRITICAL ) ? CriticalWorkQueue : DelayedWorkQueue;

        // Allocate space for TSQ context.
        pTsqContext = (PTSQ_CONTEXT) ExAllocatePoolWithTag( NonPagedPool, sizeof( TSQ_CONTEXT ), TSQ_TAG );
        if ( pTsqContext == NULL ) {
            goto QueueError;
        }

        // Allocate the IO work item.
        pIoWorkItem = IoAllocateWorkItem( pTsQueue->pDeviceObject );
        if ( pIoWorkItem == NULL ) {
            ExFreePool( pTsqContext );
            goto QueueError;
        }

        // Initialize the TSQ context and queue the work item in the system queue.
        pTsqContext->pTsQueue = pTsQueue;      
        pTsqContext->pWorkItem = pIoWorkItem;   // This is IO work item.

        IoQueueWorkItem( pIoWorkItem, ( PIO_WORKITEM_ROUTINE )TSQueueCallback, QueueType, (PVOID) pTsqContext );
    }

    return STATUS_SUCCESS;

QueueError:
    KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );
    pTsQueue->ThreadsCount --;

    // If the thread count is zero, we are the last one who finished processing work items.
    // Now if the queue is marked "being deleted", we should set the Terminate event.
    if  ( ( pTsQueue->Flags & TSQUEUE_BEING_DELETED ) && 
          ( pTsQueue->ThreadsCount == 0 ) ) {
        KeSetEvent( &pTsQueue->TerminateEvent, 0, FALSE );
    }

    KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );

    return STATUS_SUCCESS;
}


//=================================================================================
//
//  TSDeleteQueue
//      This function deletes the specified TS Queue. It first processes all the 
//      pending work items before deleting.
//
//  Inputs:
//      TS Queue: To be deleted.
//
//  Return value:
//      STATUS_SUCCESS: Operation successful.
//      BUGBUG: Wondering why we have this.
//      
//=================================================================================

NTSTATUS TSDeleteQueue(PVOID pTsq)
{
    KIRQL       Irql;
    PTSQUEUE    pTsQueue = (PTSQUEUE) pTsq;
    NTSTATUS    Status;

    // BUGBUG: There should be better way of checking TS Queue pointer (Use of signature or alike).
    if ( pTsQueue == NULL ) {
        return STATUS_SUCCESS;
    } 

    KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );

    // Check if the queue is already being deleted. 
    // It should not happen, but just in case, if the driver is not good.
    if ( pTsQueue->Flags & TSQUEUE_BEING_DELETED ) {
        ASSERT( FALSE );
        return STATUS_ACCESS_DENIED;
    }

    // Mark the queue "being deleted", so that it won't accept any new work items.
    pTsQueue->Flags |= TSQUEUE_BEING_DELETED;

    // Now help other worker threads in processing the pending work items on the queue.
    // So, increment the thread count, which will be decremented in the TSQueueWorker routine.
    pTsQueue->ThreadsCount ++;

    KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );

    // NOTE: This will also clean up the queue, if there are work items in the queue and no
    // worker threads to process them.
    TSQueueWorker( pTsQueue );

    // It is still possible that other threads are still working with their work items.
    // So, we can not just go and free the queue. So wait for the termination event.
    KeWaitForSingleObject( &pTsQueue->TerminateEvent, Executive, KernelMode, TRUE, NULL );

    // BUGBUG: Now the worker threads have set the event, but they have done that while holding
    // the spin lock. If we free the TS queue right away, they will access NULL pointer and 
    // bug-check. So, acquire spin-lock, so that the thread which set the event will release it.
    // We know that there will be only one such thread at a give time. So, we don't need ref-count 
    // now. But using ref-count is more eligent solution here.
    KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );
    KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );

    // We are all done.
    // Clean up the space allocated for the TS queue.
    ExFreePool( pTsQueue );
    pTsQueue = NULL;

    return STATUS_SUCCESS;
}


//=================================================================================
//
//  TSQueueWorker
//      This is a worker thread for the TS Queue, which goes through the queue and
//      processes the pending work items (TSQ type) one by one.
//
//=================================================================================

void TSQueueWorker(PTSQUEUE pTsQueue)
{
    PLIST_ENTRY         Item;
    PTSQUEUE_WORK_ITEM  pWorkItem;
    KIRQL               Irql;

    // Acquire the Queue spin lock first.
    KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );

    // Process the work items on the queue, while the queue is not empty
    while( !IsListEmpty( &pTsQueue->WorkItemsHead ) ) {

        // Get the next TSQ work item from the queue.
        Item = RemoveHeadList( &pTsQueue->WorkItemsHead );
        pWorkItem = CONTAINING_RECORD( Item, TSQUEUE_WORK_ITEM, Links );

        // Release the Queue spin lock.
        KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );

        // Call the callback routine specified in the work item.
        if ( pWorkItem->pCallBack ) {
            ( *pWorkItem->pCallBack ) ( pTsQueue->pDeviceObject, pWorkItem->pContext );
        }

        // Free the TSQ work item.
        ExFreePool( pWorkItem );

        // Acquire the Queue spin lock again.
        KeAcquireSpinLock( &pTsQueue->TsqSpinLock, &Irql );
    }

    // We are done processing the work items. This thread is going to exit now.
    // Decrememnt the thread count so that next work item gets processed by a new thread
    // or queued in the system queue.
    pTsQueue->ThreadsCount --;

    // If the thread count is zero, we are the last one who finished processing work items.
    // Now if the queue is marked "being deleted", we should set the Terminate event.
    if  ( ( pTsQueue->Flags & TSQUEUE_BEING_DELETED ) && 
          ( pTsQueue->ThreadsCount == 0 ) ) {
        KeSetEvent( &pTsQueue->TerminateEvent, 0, FALSE );
    }

    KeReleaseSpinLock( &pTsQueue->TsqSpinLock, Irql );
}


//=================================================================================
//
//  TSQueueCallback
//      This is the callback routine we specify, when we use system queue for 
//      processing the TSQ work item. This will in turn call the routine that 
//      TS Queue worker thread executes. And that routine will process all the
//      pending work items from the queue. We use this callback routine just for
//      cleaning up the IO work item that we allocated for using system queue.
//
//=================================================================================

void TSQueueCallback(PDEVICE_OBJECT pDeviceObject, PVOID pContext)
{
    PTSQ_CONTEXT    pTsqContext = (PTSQ_CONTEXT) pContext;

    // BUGBUG: It's better to have a check on pDeviceObject.

    // If input context here is NULL, then we sure have a big problem in system worker queue implementation.
    ASSERT( pTsqContext != NULL );

    // Process the TSQ work items on the queue.
    TSQueueWorker( pTsqContext->pTsQueue );

    // Cleanup the IO work Item.
    if ( pTsqContext->pWorkItem ) {
        IoFreeWorkItem( pTsqContext->pWorkItem );
        pTsqContext->pWorkItem = NULL;
    }

    // Free TSQ context. 
    ExFreePool( pTsqContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\trace.c ===
/*******************************************************************************
*
* TRACE.C
*    This module implements the trace functions
*
* Copyright 1998, Microsoft.
*
*
******************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

#include <ctxdd.h>


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS    IcaStartStopTrace( PICA_TRACE_INFO, PICA_TRACE );

VOID _cdecl IcaSystemTrace( ULONG, ULONG, CHAR *, ... );
VOID        IcaSystemTraceBuffer( ULONG, ULONG, PVOID, ULONG );

VOID _cdecl IcaStackTrace( PSDCONTEXT, ULONG, ULONG, CHAR *, ... );
VOID        IcaStackTraceBuffer( PSDCONTEXT, ULONG, ULONG, PVOID, ULONG );

VOID        IcaTraceFormat( PICA_TRACE_INFO, ULONG, ULONG, CHAR * );

VOID _cdecl _IcaTrace( PICA_CONNECTION, ULONG, ULONG, CHAR *, ... );
VOID _cdecl _IcaStackTrace( PICA_STACK, ULONG, ULONG, CHAR *, ... );
VOID        _IcaStackTraceBuffer( PICA_STACK, ULONG, ULONG, PVOID, ULONG );
VOID _cdecl _IcaChannelTrace( PICA_CHANNEL, ULONG, ULONG, CHAR *, ... );


/*=============================================================================
==   Internal functions
=============================================================================*/

NTSTATUS _IcaOpenTraceFile( PICA_TRACE_INFO, PWCHAR );
VOID _IcaCloseTraceFile( PICA_TRACE_INFO );
VOID _IcaTraceWrite( PICA_TRACE_INFO, PVOID );
VOID _IcaFlushDeferredTrace( PICA_TRACE_INFO );
int _FormatTime( CHAR *, ULONG );
int _FormatThreadId( CHAR *, ULONG );
VOID _WriteHexData( PICA_TRACE_INFO, PVOID, ULONG );


/*=============================================================================
==   Global variables
=============================================================================*/

/*
 *  Trace info
 */
ICA_TRACE_INFO G_TraceInfo = { 0, 0, FALSE, FALSE, NULL, NULL, NULL };


/*******************************************************************************
 *
 *  IcaStartStopTrace
 *
 *  Start/stop tracing
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pTrace (input)
 *        pointer to ICA_TRACE (IOCTL) trace settings
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaStartStopTrace(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PICA_TRACE pTrace
    )
{
    NTSTATUS Status;

    /*
     * If a trace file was specified,
     * then open it and save a pointer to the file object.
     */
    if ( pTrace->TraceFile[0] ) {
        /*
         * Force a null termination for file name.
         */
        pTrace->TraceFile[255] = (WCHAR)0;
        Status = _IcaOpenTraceFile( pTraceInfo, pTrace->TraceFile );
        if ( !NT_SUCCESS( Status ) )
            return( Status );

    /*
     * If no trace file specified, then close any existing trace file
     */
    } else if ( pTraceInfo->pTraceFileName ) {
        _IcaCloseTraceFile( pTraceInfo );
    }

    /*
     *  Set trace flags
     */
    pTraceInfo->fTraceDebugger  = pTrace->fDebugger;
    pTraceInfo->fTraceTimestamp = pTrace->fTimestamp;
    pTraceInfo->TraceClass      = pTrace->TraceClass;
    pTraceInfo->TraceEnable     = pTrace->TraceEnable;


    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaSystemTrace
 *
 *  This routine conditional writes a trace record to the system trace file
 *
 *  ENTRY:
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
IcaSystemTrace( IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * Format,
                IN ... )
{
    va_list arg_marker;
    char Buffer[256];

    va_start( arg_marker, Format );

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & G_TraceInfo.TraceClass) || !(TraceEnable & G_TraceInfo.TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );
    Buffer[sizeof(Buffer) -1] = '\0';

    /*
     *  Write trace data
     */
    IcaTraceFormat( &G_TraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  IcaSystemTraceBuffer
 *
 *  This routine conditional writes a data buffer to the system trace file
 *
 *  ENTRY:
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaSystemTraceBuffer( IN ULONG TraceClass,
                      IN ULONG TraceEnable,
                      IN PVOID pBuffer,
                      IN ULONG ByteCount )
{
    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & G_TraceInfo.TraceClass) ||
         !(TraceEnable & G_TraceInfo.TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( &G_TraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  IcaStackTrace
 *
 *  This routine conditional writes a trace record depending on the trace mask
 *
 *  ENTRY:
 *     pContext (input)
 *        pointer to stack driver context
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
IcaStackTrace( IN PSDCONTEXT pContext,
               IN ULONG TraceClass,
               IN ULONG TraceEnable,
               IN CHAR * Format,
               IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    va_start( arg_marker, Format );

    /*
     * Use SD passed context to get the STACK object pointer.
     */
    pStack = (CONTAINING_RECORD( pContext, SDLINK, SdContext ))->pStack;
    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );
    Buffer[sizeof(Buffer) -1] = '\0';

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  IcaStackTraceBuffer
 *
 *  This routine conditional writes a data buffer to the trace file
 *
 *  ENTRY:
 *     pContext (input)
 *        pointer to stack driver context
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaStackTraceBuffer( IN PSDCONTEXT pContext,
                     IN ULONG TraceClass,
                     IN ULONG TraceEnable,
                     IN PVOID pBuffer,
                     IN ULONG ByteCount )
{
    PICA_TRACE_INFO pTraceInfo;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;

    /*
     * Use SD passed context to get the STACK object pointer.
     */
    pStack = (CONTAINING_RECORD( pContext, SDLINK, SdContext ))->pStack;
    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( pTraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  IcaTraceFormat
 *
 *  This routine conditional writes trace data depending on the trace mask
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pData (input)
 *        pointer to null terminated trace data
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaTraceFormat( IN PICA_TRACE_INFO pTraceInfo,
                IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * pData )
{
    char Buffer[256];
    char * pBuf;
    int len = 0;
    int i;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    pBuf = Buffer;

    /*
     *  Append time stamp
     */
    if ( pTraceInfo->fTraceTimestamp ) {
        len = _FormatTime( pBuf, sizeof(Buffer) );
        pBuf += len;
    }

    /*
     *  Append thread id
     */
    i = _FormatThreadId( pBuf, sizeof(Buffer) - len );
    len += i;
    pBuf += i;

    /*
     *  Append trace data
     */
    _snprintf( pBuf, sizeof(Buffer) - len, pData );

    /*
     *  Write trace data
     */
    _IcaTraceWrite( pTraceInfo, Buffer );
}


/*******************************************************************************
 *
 *  _IcaTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pConnect (input)
 *        pointer to connection structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaTrace( IN PICA_CONNECTION pConnect,
           IN ULONG TraceClass,
           IN ULONG TraceEnable,
           IN CHAR * Format,
           IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pConnect->Header.Type == IcaType_Connection );

    va_start( arg_marker, Format );

    pTraceInfo = &pConnect->TraceInfo;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );
    Buffer[sizeof(Buffer) -1] = '\0';

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaStackTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pStack (input)
 *        pointer to stack structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaStackTrace( IN PICA_STACK pStack,
                IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * Format,
                IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pStack->Header.Type == IcaType_Stack );

    va_start( arg_marker, Format );

    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );
    Buffer[sizeof(Buffer) -1] = '\0';

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaStackTraceBuffer
 *
 *  This routine conditional writes a data buffer to the trace file
 *
 *  ENTRY:
 *     pStack (input)
 *        pointer to stack structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaStackTraceBuffer( IN PICA_STACK pStack,
                      IN ULONG TraceClass,
                      IN ULONG TraceEnable,
                      IN PVOID pBuffer,
                      IN ULONG ByteCount )
{
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pStack->Header.Type == IcaType_Stack );

    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( pTraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  _IcaChannelTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pChannel (input)
 *        pointer to Channel structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaChannelTrace( IN PICA_CHANNEL pChannel,
                  IN ULONG TraceClass,
                  IN ULONG TraceEnable,
                  IN CHAR * Format,
                  IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pChannel->Header.Type == IcaType_Channel );

    va_start( arg_marker, Format );

    pTraceInfo = &pChannel->pConnect->TraceInfo;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );
    Buffer[sizeof(Buffer) -1] = '\0';

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaOpenTraceFile
 *
 *  Open a trace file
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pTraceFile (input)
 *        pointer to trace file name
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

#define NAMEPREFIX L"\\DosDevices\\"

NTSTATUS
_IcaOpenTraceFile(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PWCHAR pTraceFile
    )
{
    UNICODE_STRING TraceString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK iosb;
    HANDLE TraceFileHandle;
    PFILE_OBJECT pTraceFileObject;
    ULONG PrefixLength;
    ULONG TraceFileLength;
    NTSTATUS Status;

    PrefixLength    = wcslen( NAMEPREFIX ) * sizeof(WCHAR);
    TraceFileLength = wcslen( pTraceFile ) * sizeof(WCHAR);

    TraceString.Length = (USHORT) (PrefixLength + TraceFileLength);
    TraceString.MaximumLength = TraceString.Length + sizeof(UNICODE_NULL);
    TraceString.Buffer = ICA_ALLOCATE_POOL( NonPagedPool, TraceString.MaximumLength );

    if (TraceString.Buffer != NULL) {
        RtlCopyMemory( TraceString.Buffer, NAMEPREFIX, PrefixLength );
        RtlCopyMemory( (char *)TraceString.Buffer + PrefixLength, pTraceFile, TraceFileLength );
        TraceString.Buffer[(PrefixLength + TraceFileLength) / sizeof(WCHAR)] = UNICODE_NULL;
    }
    else {
        return STATUS_NO_MEMORY;        
    }

    /*
     * If we already have a trace file and the name is the same
     * as a previous call, then there's nothing to be done.
     */
    if ( pTraceInfo->pTraceFileName != NULL &&
         !_wcsicmp( TraceString.Buffer, pTraceInfo->pTraceFileName ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( STATUS_SUCCESS );
    }

    /*
     * Close the existing trace file if there is one
     */
    if ( pTraceInfo->pTraceFileName ) {
        _IcaCloseTraceFile( pTraceInfo );
    }

    InitializeObjectAttributes( &ObjectAttributes, &TraceString,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL );

    Status = ZwCreateFile(
             &TraceFileHandle,
             GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
             &ObjectAttributes,
             &iosb,                          // returned status information.
             0,                              // block size (unused).
             0,                              // file attributes.
             FILE_SHARE_READ | FILE_SHARE_WRITE,
             FILE_OVERWRITE_IF,              // create disposition.
             0,                              // create options.
             NULL,
             0
             );
    if ( !NT_SUCCESS( Status ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( Status );
    }

    /*
     * Use the trace file handle to get a pointer to the file object.
     */
    Status = ObReferenceObjectByHandle(
                 TraceFileHandle,
                 0L,                         // DesiredAccess
                 *IoFileObjectType,
                 KernelMode,
                 (PVOID *)&pTraceFileObject,
                 NULL
                 );
    ZwClose( TraceFileHandle );
    if ( !NT_SUCCESS( Status ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( Status );
    }

    /*
     * Save Trace file name and file object pointer
     */
    pTraceInfo->pTraceFileName = TraceString.Buffer;
    pTraceInfo->pTraceFileObject = pTraceFileObject;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _IcaCloseTraceFile
 *
 *  Close a trace file
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

VOID
_IcaCloseTraceFile(
    IN PICA_TRACE_INFO pTraceInfo
    )
{
    PWCHAR pTraceFileName;
    PFILE_OBJECT pTraceFileObject;

    /*
     * First write out any deferred trace records that exist
     */
    _IcaFlushDeferredTrace( pTraceInfo );

    /*
     * Get/reset trace info fields
     */
    pTraceFileName = pTraceInfo->pTraceFileName;
    pTraceFileObject = pTraceInfo->pTraceFileObject;
    pTraceInfo->pTraceFileName = NULL;
    pTraceInfo->pTraceFileObject = NULL;

    /*
     * Close trace file and free resources
     */
    ICA_FREE_POOL( pTraceFileName );
    ObDereferenceObject( pTraceFileObject );
}


/*******************************************************************************
 *
 *  _IcaTraceWrite
 *
 *  Write a trace file entry
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     Buffer (input)
 *        pointer to trace buffer to write
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaTraceWrite(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PVOID Buffer
    )
{
    KIRQL irql;
    ULONG Length;
    PDEFERRED_TRACE pDeferred;
    PDEFERRED_TRACE *ppDeferredTrace;
    NTSTATUS Status;

    /*
     * Write to kernel debugger if necessary
     */
    if ( pTraceInfo->fTraceDebugger )
        DbgPrint( "%s", Buffer );

    /*
     * If no file object pointer, then we're done
     */
    if ( pTraceInfo->pTraceFileObject == NULL )
        return;

    Length = strlen(Buffer);

    /*
     * If current Irql is DISPATCH_LEVEL or higher, then we can't
     * write the data now, so queue it for later writing.
     */
    irql = KeGetCurrentIrql();
    if ( irql >= DISPATCH_LEVEL ) {
        KIRQL oldIrql;

        /*
         * Allocate and initialize a deferred trace entry
         */
        pDeferred = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pDeferred) + Length );
        if ( pDeferred == NULL )
            return;
        pDeferred->Next = NULL;
        pDeferred->Length = Length;
        RtlCopyMemory( pDeferred->Buffer, Buffer, Length );

        /*
         *  Since the deferred list may be manipulated in
         *  _IcaFlushDeferredTrace on behalf of an IOCTL_SYSTEM_TRACE
         *  which does not hold any locks, IcaSpinLock is used to
         *  ensure the list's integrity.
         */
        IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );

        /*
         * Add it to the end of the list
         */
        ppDeferredTrace = &pTraceInfo->pDeferredTrace;
        while ( *ppDeferredTrace )
            ppDeferredTrace = &(*ppDeferredTrace)->Next;
        *ppDeferredTrace = pDeferred;

        IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );
        return;
    }

    /*
     * Write out any deferred trace records that exist
     */
    _IcaFlushDeferredTrace( pTraceInfo );

    /*
     * Now write the current trace buffer
     */
    CtxWriteFile( pTraceInfo->pTraceFileObject, Buffer, Length, NULL, NULL, NULL );
}


/*******************************************************************************
 *
 *  _IcaFlushDeferredTrace
 *
 *  Write any deferred trace file entries
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaFlushDeferredTrace( PICA_TRACE_INFO pTraceInfo )
{
    KIRQL oldIrql;
    PDEFERRED_TRACE pDeferred;

    IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );
    while ( (pDeferred = pTraceInfo->pDeferredTrace) ) {
        pTraceInfo->pDeferredTrace = pDeferred->Next;
        IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );

        CtxWriteFile( pTraceInfo->pTraceFileObject, pDeferred->Buffer,
                      pDeferred->Length, NULL, NULL, NULL );
        ICA_FREE_POOL( pDeferred );

        IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );
    }
    IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );
}


/*******************************************************************************
 *
 *  _FormatTime
 *
 *  format current time into buffer
 *
 *  ENTRY:
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

int
_FormatTime( CHAR * pBuffer, ULONG Length )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    int len;

    /*
     *  Get local time
     */
    KeQuerySystemTime( &SystemTime );
    ExSystemTimeToLocalTime( &SystemTime, &LocalTime );
    RtlTimeToTimeFields( &LocalTime, &TimeFields );

    /*
     *  Format buffer
     */
    len = _snprintf( pBuffer,
                     Length,
                     "%02d:%02d:%02d.%03d ",
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     TimeFields.Milliseconds );

    return( len );
}


/*******************************************************************************
 *
 *  _FormatThreadId
 *
 *  format thread id into buffer
 *
 *  ENTRY:
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

#define TEB_CLIENTID_OFFSET 0x1e0

int
_FormatThreadId( CHAR * pBuffer, ULONG Length )
{
    PCLIENT_ID pClientId;
    char Number[40]; //on WIN64, %p is 16 chars, we need two of these. So 32 + 2 bytes for "." and "\0". Use 40 just in case
    int len;

    /*
     *  Get pointer to clientid structure in teb
     *  - use hardcoded teb offset
     */
    pClientId = (PCLIENT_ID) ((char*)PsGetCurrentThread() + TEB_CLIENTID_OFFSET);

    /*
     *  Format buffer
     */
    _snprintf( Number, sizeof(Number), "%p.%p",
               pClientId->UniqueProcess, pClientId->UniqueThread );

    Number[39] = '\0';

    len = _snprintf( pBuffer, Length, "%-7s ", Number );

    return( len );
}


/*******************************************************************************
 *
 *  _WriteHexData
 *
 *  format and write hex data
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

VOID
_WriteHexData(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PVOID pBuffer,
    IN ULONG ByteCount
    )
{
    PUCHAR pData;
    ULONG i;
    ULONG j;
    char Buffer[256];

    /*
     *  Output data
     */
    pData = (PUCHAR) pBuffer;
    for ( i=0; i < ByteCount; i += 16 ) {
        ULONG c = 0;
        for ( j=0; j < 16 && (i+j) < ByteCount; j++ )
            c += _snprintf( &Buffer[c], sizeof(Buffer)-c, "%02X ", pData[j] );
        for ( ; j < 16; j++ ) {
            Buffer[c++] = ' ';
            Buffer[c++] = ' ';
            Buffer[c++] = ' ';
        }
        Buffer[c++] = ' ';
        Buffer[c++] = ' ';
        for ( j=0; j < 16 && (i+j) < ByteCount; j++, pData++ ) {
            if ( *pData < 0x20 || *pData > 0x7f )
                Buffer[c++] = '.';
            else
                Buffer[c++] = *pData;
        }
        Buffer[c++] = '\n';
        Buffer[c++] = '\0';
        _IcaTraceWrite( pTraceInfo, Buffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\cd.c ===
/*************************************************************************
* CD.C
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External procedures defined
=============================================================================*/
NTSTATUS IcaCdIoControl( HANDLE pContext, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS IcaCdWaitForSingleObject( HANDLE pContext, HANDLE, LONG );
NTSTATUS IcaCdWaitForMultipleObjects( HANDLE pContext, ULONG, HANDLE *, BOOL, LONG );
HANDLE   IcaCdCreateThread( HANDLE pContext, PVOID, PVOID, PULONG );

/*=============================================================================
==   Internal procedures defined
=============================================================================*/
NTSTATUS _CdOpen( PSTACK pStack, PWINSTATIONCONFIG2 );
VOID     _CdClose( PSTACK pStack );


/*=============================================================================
==   Procedures used
=============================================================================*/
void     _DecrementStackRef( IN PSTACK pStack );



/****************************************************************************
 *
 * IcaCdIoControl
 *
 *   Generic interface to an ICA stack  (for use by Connection Driver)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaCdIoControl( IN HANDLE pContext,
                IN ULONG IoControlCode,
                IN PVOID pInBuffer,
                IN ULONG InBufferSize,
                OUT PVOID pOutBuffer,
                IN ULONG OutBufferSize,
                OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = IcaIoControl( pStack->hStack,
                           IoControlCode,
                           pInBuffer,
                           InBufferSize,
                           pOutBuffer,
                           OutBufferSize,
                           pBytesReturned );


    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing && (IoControlCode != IOCTL_ICA_STACK_POP) )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdWaitForSingleObject
 *
 *   Wait for handle to be signaled
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   hHandle (input)
 *     handle to wait on
 *   Timeout (input)
 *     timeout in milliseconds
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS 
IcaCdWaitForSingleObject( HANDLE pContext, 
                          HANDLE hHandle,
                          LONG Timeout )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = WaitForSingleObject( hHandle, Timeout );

    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdWaitForMultipleObjects
 *
 *   Wait for one or more handles to be signaled
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   Count (input)
 *     count of handles
 *   phHandle (input)
 *     pointer to array of handles
 *   bWaitAll (input)
 *     wait for all flag
 *   Timeout (input)
 *     timeout in milliseconds
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS 
IcaCdWaitForMultipleObjects( HANDLE pContext, 
                             ULONG Count,
                             HANDLE * phHandle,
                             BOOL bWaitAll,
                             LONG Timeout )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = WaitForMultipleObjects( Count, phHandle, bWaitAll, Timeout );

    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdCreateThread
 *
 *   Create a thread
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   pProc (input)
 *     pointer to thread procedure
 *   pParam (input)
 *     parameter for thread procedure
 *   pThreadId (output)
 *     address to return thread id
 *
 * EXIT:
 *   thread handle (null on error)
 *
 ****************************************************************************/

typedef NTSTATUS (*PTHREAD_ROUTINE) ( PVOID );

typedef struct _CDCREATETHREADINFO {
    PTHREAD_ROUTINE pProc;
    PVOID pParam;
    PSTACK pStack;
} CDCREATETHREADINFO, *PCDCREATETHREADINFO;

NTSTATUS _CdThread( IN PCDCREATETHREADINFO pThreadInfo );


HANDLE
IcaCdCreateThread( HANDLE pContext, 
                   PVOID pProc, 
                   PVOID pParam, 
                   PULONG pThreadId )
{
    CDCREATETHREADINFO ThreadInfo;
    HANDLE Handle;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Initialize thread info
     */
    ThreadInfo.pProc = pProc;
    ThreadInfo.pParam = pParam;
    ThreadInfo.pStack = pStack;

    /*
     *  Increment reference 
     *  - this will be decremented when the thread exits
     */
    pStack->RefCount++;

    /*
     *  Create thread
     */
    Handle = CreateThread( NULL, 
                           5000, 
                           (LPTHREAD_START_ROUTINE) 
                           _CdThread,
                           &ThreadInfo, 
                           0, 
                           pThreadId );

    return( Handle );
}


NTSTATUS
_CdThread( IN PCDCREATETHREADINFO pThreadInfo )
{
    PSTACK pStack = pThreadInfo->pStack;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );   

    /*
     *  Call thread procedure in CD driver
     */
    (void) (pThreadInfo->pProc)( pThreadInfo->pParam );

    /*
     *  Decrement reference made in IcaCdCreateThread when thread exits
     */
    _DecrementStackRef( pStack );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );   

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _CdOpen
 *
 *  Load and open connection driver dll
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationConfig (input)
 *      pointer to winstation config structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
_CdOpen( IN PSTACK pStack,
         IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    PCDCONFIG pCdConfig;
    HANDLE Handle;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    pCdConfig = &pWinStationConfig->Cd;

    /*
     *  Return if there is no connection driver to load
     */
    if ( pCdConfig->CdClass == CdNone ) {
        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _CdOpen, no dll\n" ));
        return( STATUS_SUCCESS );
    }

    /*
     *  load CD DLL
     */
    Handle = LoadLibrary( pCdConfig->CdDLL );
    if ( Handle == NULL ) {
        Status = STATUS_CTX_PD_NOT_FOUND;
        goto badload;
    }

    /*
     *  get connection driver entry points
     */
    pStack->pCdOpen      = (PCDOPEN)      GetProcAddress( Handle, "CdOpen" );
    pStack->pCdClose     = (PCDCLOSE)     GetProcAddress( Handle, "CdClose" );
    pStack->pCdIoControl = (PCDIOCONTROL) GetProcAddress( Handle, "CdIoControl" );

    if ( pStack->pCdOpen == NULL || 
         pStack->pCdClose == NULL || 
         pStack->pCdIoControl == NULL ) {
        Status = STATUS_CTX_INVALID_PD;
        goto badproc;
    }

    /*
     *  Open CD driver
     */
    Status = (*pStack->pCdOpen)( pStack, 
				 &pWinStationConfig->Pd[0], // td parameters
                                 &pStack->pCdContext
			       );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     *  Save CD handle
     */
    pStack->hCdDLL = Handle;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _CdOpen, %S, success\n",
                 pCdConfig->CdDLL ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  Open failed
     *  get proc address failed
     */
badopen:
badproc:
    pStack->pCdOpen      = NULL;
    pStack->pCdClose     = NULL;
    pStack->pCdIoControl = NULL;

    FreeLibrary( Handle );

    /*
     *  CD DLL load failed
     */
badload:
    pStack->pCdContext = NULL;

    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _CdOpen, %S, 0x%x\n", pCdConfig->CdDLL, Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  _CdClose
 *
 *  Free local context structure
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
_CdClose( IN PSTACK pStack )
{
    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Close CD driver
     */
    if ( pStack->pCdClose ) {
        (void) (*pStack->pCdClose)( pStack->pCdContext );
    }

    /*
     *  Clear procedure pointers
     */
    pStack->pCdOpen      = NULL;
    pStack->pCdClose     = NULL;
    pStack->pCdIoControl = NULL;

    /*
     *  Unload dll
     */
    if ( pStack->hCdDLL ) {
        FreeLibrary( pStack->hCdDLL );
        pStack->hCdDLL = NULL;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1,  "TSAPI: _CdClose\n" ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\drivers\termdd\virtual.c ===
/*************************************************************************
*
* virtual.c
*
* This module contains routines for managing ICA virtual channels.
*
* Copyright 1998, Microsoft.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
IcaFlushChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlVirtual(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )



/*++

Routine Description:

    This is the device control routine for the ICA Virtual channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    PICA_STACK pStack;
    PVOID pTempBuffer = NULL;
    PVOID pInputBuffer = NULL;
    PVOID pUserBuffer = NULL;
    BOOLEAN bStackIsReferenced = FALSE;
    ULONG i;

    // these are the set of ioctls that can be expected on non system created VCs.
    ULONG PublicIoctls[] =
    {
	IOCTL_ICA_VIRTUAL_LOAD_FILTER,
	IOCTL_ICA_VIRTUAL_UNLOAD_FILTER,
	IOCTL_ICA_VIRTUAL_ENABLE_FILTER,
	IOCTL_ICA_VIRTUAL_DISABLE_FILTER,
	IOCTL_ICA_VIRTUAL_BOUND,
	IOCTL_ICA_VIRTUAL_CANCEL_INPUT,
	IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT
    };

    try{
        /*
         * Extract the IOCTL control code and process the request.
         */
        code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlVirtual, fc %d, ref %u (enter)\n", 
                       (code & 0x3fff) >> 2, pChannel->RefCount ));

        if (!IrpSp->FileObject->FsContext2)
	 {
            /*
		* if the object was not created by system. dont let it sent IOCTLS on VCs.
		* except for the public ioctls. 
		*/
		
            for ( i=0; i < sizeof(PublicIoctls) / sizeof(PublicIoctls[0]); i++)
            {
                 if (code == PublicIoctls[i])
                 	break;
            }

            if (i ==  sizeof(PublicIoctls) / sizeof(PublicIoctls[0]))
            {
               TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, denying IOCTL(0x%x) on non-system VC. \n" , code));
               return STATUS_ACCESS_DENIED;
            }
        }
            		
        /*
         *  Process ioctl request
         */
        switch ( code ) {

            case IOCTL_ICA_VIRTUAL_LOAD_FILTER :
            case IOCTL_ICA_VIRTUAL_UNLOAD_FILTER :
            case IOCTL_ICA_VIRTUAL_ENABLE_FILTER :
            case IOCTL_ICA_VIRTUAL_DISABLE_FILTER :
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;


            case IOCTL_ICA_VIRTUAL_BOUND :
                Status = (pChannel->VirtualClass == UNBOUND_CHANNEL) ?
                           STATUS_INVALID_DEVICE_REQUEST : STATUS_SUCCESS;
                break;


            case IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA : 
                IcaLockConnection( pChannel->pConnect );
                if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                    IcaUnlockConnection( pChannel->pConnect );
                    return( STATUS_INVALID_DEVICE_REQUEST );
                }
                pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                            ICA_STACK, StackEntry );

                if( (pStack->StackClass != Stack_Console) && 
                    (pStack->StackClass != Stack_Primary) ) {
                    IcaUnlockConnection( pChannel->pConnect );
                    return( STATUS_INVALID_DEVICE_REQUEST );
                }

                IcaReferenceStack( pStack );
                bStackIsReferenced = TRUE;
                IcaUnlockConnection( pChannel->pConnect );

                if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                    IcaDereferenceStack( pStack );
                    bStackIsReferenced = FALSE;
                    TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, channel not bound\n" ));
                    return( STATUS_INVALID_DEVICE_REQUEST );
                }

                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA begin\n" ));
                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, pStack 0x%x\n", pStack ));

                if ( Irp->RequestorMode != KernelMode && IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }


                Status = CaptureUsermodeBuffer ( Irp,
                                                 IrpSp,
                                                 NULL,
                                                 0,
                                                 &pUserBuffer,
                                                 IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                                 FALSE,
                                                 &pTempBuffer);
                if (Status != STATUS_SUCCESS) {
                    break;
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = &pChannel->VirtualClass;
                SdIoctl.InputBufferLength = sizeof(pChannel->VirtualClass);
                SdIoctl.OutputBuffer = pUserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

                if (gCapture && (Status == STATUS_SUCCESS) && (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
                    RtlCopyMemory( Irp->UserBuffer,
                                   pUserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength );
                }
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, Status 0x%x\n", Status ));
                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA end\n" ));

                IcaDereferenceStack( pStack );
                bStackIsReferenced = FALSE;
                break;

            case IOCTL_ICA_VIRTUAL_CANCEL_INPUT :

                Status = IcaFlushChannel( pChannel, Irp, IrpSp );
                if ( !NT_SUCCESS(Status) )
                    break;

                /* fall through */

            default :


                /*
                 *  Make sure virtual channel is bound to a virtual channel number
                 */
                if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                    TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, channel not bound\n" ));
                    return( STATUS_INVALID_DEVICE_REQUEST );
                }

                /*
                 *  Save virtual class in first 4 bytes of the input buffer 
                 *  - this is used by the wd
                 */

                if ( Irp->RequestorMode != KernelMode && IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if ( Irp->RequestorMode != KernelMode && IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) {

                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VIRTUALCHANNELCLASS) ) {
                    SdIoctl.InputBuffer = &pChannel->VirtualClass;
                    SdIoctl.InputBufferLength = sizeof(pChannel->VirtualClass);
                    Status = CaptureUsermodeBuffer ( Irp,
                                                     IrpSp,
                                                     NULL,
                                                     0,
                                                     &pUserBuffer,
                                                     IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                                     FALSE,
                                                     &pTempBuffer);
                    if (Status != STATUS_SUCCESS) {
                        break;
                    }


                } else {

                    Status = CaptureUsermodeBuffer ( Irp,
                                                     IrpSp,
                                                     &pInputBuffer,
                                                     IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                                     &pUserBuffer,
                                                     IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                                     FALSE,
                                                     &pTempBuffer);
                    if (Status != STATUS_SUCCESS) {
                        break;
                    }
                    SdIoctl.InputBuffer = pInputBuffer;
                    SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

                    RtlCopyMemory( SdIoctl.InputBuffer, &pChannel->VirtualClass, sizeof(pChannel->VirtualClass) );
                }

                /*
                 *  Send request to WD
                 */
                SdIoctl.IoControlCode = code;
                SdIoctl.OutputBuffer = pUserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
                if (gCapture && (Status == STATUS_SUCCESS) && (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
                    RtlCopyMemory( Irp->UserBuffer,
                                   pUserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength );
                }

                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;
        }

        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlVirtual, fc %d, ref %u, 0x%x\n", 
                       (code & 0x3fff) >> 2, pChannel->RefCount, Status ));

    } except(EXCEPTION_EXECUTE_HANDLER){
        Status = GetExceptionCode();
        if (bStackIsReferenced) {
            IcaDereferenceStack( pStack );
        }

    }

    if (pTempBuffer!= NULL) {
        ExFreePool(pTempBuffer);
    }
    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\channel.c ===
/*************************************************************************
* CHANNEL.C
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External procedures defined
=============================================================================*/
NTSTATUS IcaChannelOpen( HANDLE hIca, CHANNELCLASS, PVIRTUALCHANNELNAME, HANDLE * phChannel );
NTSTATUS IcaChannelClose( HANDLE hChannel );
NTSTATUS IcaChannelIoControl( HANDLE hChannel, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
VOID cdecl IcaChannelTrace( IN HANDLE hChannel, ULONG, ULONG, char *, ... );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

/*=============================================================================
==   Procedures used
=============================================================================*/
NTSTATUS _IcaStackOpen( HANDLE hIca, HANDLE * phStack, ICA_OPEN_TYPE, PICA_TYPE_INFO );



/****************************************************************************
 *
 * IcaChannelOpen
 *
 *   Open an ICA channel
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   Channel (input)
 *     ICA channel
 *
 *   pVirtualName (input)
 *     pointer to virtual channel name

 *   phChannel (output)
 *     Pointer to ICA channel handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelOpen( IN HANDLE hIca, 
                IN CHANNELCLASS Channel, 
                IN PVIRTUALCHANNELNAME pVirtualName,
                OUT HANDLE * phChannel )
{
    ICA_TYPE_INFO TypeInfo;
    NTSTATUS Status;

    RtlZeroMemory( &TypeInfo, sizeof(TypeInfo) );
    TypeInfo.ChannelClass = Channel;
    if ( pVirtualName ) 
        strncpy( TypeInfo.VirtualName, pVirtualName, sizeof(TypeInfo.VirtualName) );

    Status = _IcaStackOpen( hIca, phChannel, IcaOpen_Channel, &TypeInfo );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaChannelOpen, %u/%s, %u, success\n", 
            Channel, TypeInfo.VirtualName, *phChannel ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    TRACE(( hIca, TC_ICAAPI, TT_ERROR, "TSAPI: IcaChannelOpen, %u/%s, 0x%x\n", 
            Channel, TypeInfo.VirtualName, Status ));
    return( Status );
}


/****************************************************************************
 *
 * IcaChannelClose
 *
 *   Close an ICA channel
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelClose( IN HANDLE hChannel )
{
    NTSTATUS Status;

    TRACECHANNEL(( hChannel, TC_ICAAPI, TT_API1, "TSAPI: IcaChannelClose[%u]\n", hChannel ));

    /*
     * Close the ICA device driver channel instance 
     */
    Status = NtClose( hChannel );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}

/****************************************************************************
 *
 * IcaChannelIoControl
 *
 *   Generic interface to an ICA channel
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *
 *   IoControlCode (input)
 *     I/O control code
 *
 *   pInBuffer (input)
 *     Pointer to input parameters
 *
 *   InBufferSize (input)
 *     Size of pInBuffer
 *
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelIoControl( IN HANDLE hChannel,
                     IN ULONG IoControlCode,
                     IN PVOID pInBuffer,
                     IN ULONG InBufferSize,
                     OUT PVOID pOutBuffer,
                     IN ULONG OutBufferSize,
                     OUT PULONG pBytesReturned )
{
    NTSTATUS Status;

    Status = IcaIoControl( hChannel,
                           IoControlCode,
                           pInBuffer,
                           InBufferSize,
                           pOutBuffer,
                           OutBufferSize,
                           pBytesReturned );

    return( Status );
}


/*******************************************************************************
 *
 *  IcaChannelTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaChannelTrace( IN HANDLE hChannel,
                 IN ULONG TraceClass, 
                 IN ULONG TraceEnable, 
                 IN char * Format, 
                 IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    
    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hChannel,
                         IOCTL_ICA_CHANNEL_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\icaapi.c ===
/*************************************************************************
* ICAAPI.C
*
* ICA DLL Interface for ICA Device Driver
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*=============================================================================
==   External procedures defined
=============================================================================*/

#ifdef BUILD_AS_DLL
BOOL WINAPI DllEntryPoint( HINSTANCE, DWORD, LPVOID );
#endif

NTSTATUS IcaOpen( HANDLE * phIca );
NTSTATUS IcaClose( HANDLE hIca );
VOID cdecl IcaSystemTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );
VOID cdecl IcaTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );
NTSTATUS IcaIoControl( HANDLE hIca, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _IcaOpen( PHANDLE hIca, PVOID, ULONG );

/*=============================================================================
==   Procedures used
=============================================================================*/


#ifdef BUILD_AS_DLL
/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *   fdwReason (input)
 *     Why function was called
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hinstDLL);
            break;
    
        default:
            break;
    }

    return( TRUE );
}
#endif

/****************************************************************************
 *
 * IcaOpen
 *
 *   Open an instance to the ICA Device Driver
 *
 * ENTRY:
 *   phIca (output)
 *     Pointer to ICA instance handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaOpen( OUT HANDLE * phIca )
{
    NTSTATUS Status;        

    Status = _IcaOpen( phIca, NULL, 0 );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE(( *phIca, TC_ICAAPI, TT_API1, "TSAPI: IcaOpen, success\n" ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    *phIca = NULL;
    return( Status );
}


/****************************************************************************
 *
 * IcaClose
 *
 *   Close an instance to the ICA Device Driver
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaClose( IN HANDLE hIca )
{
    NTSTATUS Status;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaClose\n" ));

    /*
     * Close the ICA device driver instance 
     */
    Status = NtClose( hIca );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaSystemTrace
 *
 *  Write a trace record to the system trace file
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaSystemTrace( IN HANDLE hIca,
                IN ULONG TraceClass, 
                IN ULONG TraceEnable, 
                IN char * Format, 
                IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;

    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hIca,
                         IOCTL_ICA_SYSTEM_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}


/*******************************************************************************
 *
 *  IcaTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaTrace( IN HANDLE hIca,
          IN ULONG TraceClass, 
          IN ULONG TraceEnable, 
          IN char * Format, 
          IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    
    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hIca,
                         IOCTL_ICA_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}


/****************************************************************************
 *
 * IcaIoControl
 *
 *   Generic interface to the ICA Device Driver
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   IoControlCode (input)
 *     I/O control code
 *
 *   pInBuffer (input)
 *     Pointer to input parameters
 *
 *   InBufferSize (input)
 *     Size of pInBuffer
 *
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaIoControl( IN HANDLE hIca,
              IN ULONG IoControlCode,
              IN PVOID pInBuffer,
              IN ULONG InBufferSize,
              OUT PVOID pOutBuffer,
              IN ULONG OutBufferSize,
              OUT PULONG pBytesReturned )
{
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    /*
     *  Issue ioctl
     */
    Status = NtDeviceIoControlFile( hIca,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &Iosb,
                                    IoControlCode, 
                                    pInBuffer, 
                                    InBufferSize,
                                    pOutBuffer,
                                    OutBufferSize );

    /*
     *  Wait for ioctl to complete
     */
    if ( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( hIca, FALSE, NULL );
        if ( NT_SUCCESS(Status)) 
            Status = Iosb.Status;
    }

    /*
     *  Convert warning into error
     */
    if ( Status == STATUS_BUFFER_OVERFLOW )
        Status = STATUS_BUFFER_TOO_SMALL;

    /*
     *  Initialize bytes returned
     */
    if ( pBytesReturned )
        *pBytesReturned = (ULONG)Iosb.Information;

    return( Status );
}


/****************************************************************************
 *
 * _IcaOpen
 *
 *   Open an instance to the ICA Device Driver or an ICA stack
 *
 * ENTRY:
 *   ph (output)
 *     Pointer to ICA or ICA stack instance handle
 *
 *   pEa (input)
 *     Pointer to extended attribute buffer
 *
 *   cbEa (input)
 *     Size of extended attribute buffer
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaOpen( PHANDLE ph,
          PVOID   pEa,
          ULONG   cbEa )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    IcaName;
    IO_STATUS_BLOCK   ioStatusBlock;

    /*
     * Initialize the object attributes
     */
    RtlInitUnicodeString( &IcaName, ICA_DEVICE_NAME );

    InitializeObjectAttributes( &objectAttributes,
                                &IcaName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    /*
     * Open an instance to the ICA device driver
     */
    Status = NtCreateFile( ph,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,                               // AllocationSize
                           0L,                                 // FileAttributes
                           FILE_SHARE_READ | FILE_SHARE_WRITE, // ShareAccess
                           FILE_OPEN_IF,                       // CreateDisposition
                           0,
                           pEa,
                           cbEa );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winsta.h>
#include <icadd.h>
#include <icaapi.h>

#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include <limits.h>

#include "icaapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\icakey.c ===
/*************************************************************************
* T1.C
*
* Test program for ICA DLL Interface to ICA Device Driver
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <stdio.h>


#define MAX_READ 2

/*
 *   Data types and definitions
 */
#define KEYBOARD_THREAD_STACKSIZE 1024 * 4
typedef struct _THREADDATA {
    HANDLE handle;
} THREADDATA, * PTHREADDATA;

/*
 * Global variables
 */
static HANDLE ghIca                = NULL;
static HANDLE ghStack              = NULL;
static HANDLE ghKeyboard           = NULL;
static HANDLE ghMouse              = NULL;
static HANDLE ghVideo              = NULL;
static HANDLE ghBeep               = NULL;
static HANDLE ghCommand            = NULL;
static HANDLE ghCdm                = NULL;
static HANDLE ghThreadKeyboardRead = NULL;
static HANDLE ghStopEvent          = NULL;

/*
 * Private procedures
 */
LONG OpenStacks( void );
LONG ConnectStacks( void );
LONG CloseStacks( void );
LONG Initialize( void );
VOID KeyboardReadThread( PTHREADDATA pThreadData );
LONG KeyboardTest( void ); 

/****************************************************************************
 *
 * main
 *
 *   Main process entry point
 *
 * ENTRY:
 *   argc (input)
 *     Number of parameters
 *
 *   argv (input)
 *     Array of argument strings
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

int _cdecl
main (int argc, char *argv[])
{
    BOOL fSuccess = TRUE;
    LONG rc;


    /*
     * Open the ICA driver, an ICA stack, and some channels
     */
    if ( rc = OpenStacks() ) {
        goto done;
    }

    /*
     * Do some initialization
     */
    if ( rc = Initialize() ) {
        goto done;
    }

    printf( "Sleeping...\n" );
    Sleep(3000); // Give thread some time

    if ( rc = KeyboardTest() ) {
        goto done;
    }


    /*
     * Wait for stop event to be triggered.
     */
    printf( "ICAKEY main: Waiting for stop event...\n" );
    WaitForSingleObject( ghStopEvent, (DWORD)30000 );
    printf( "ICAKEY main: ...Stop event triggered\n" );

done:
    fSuccess = !rc;

    if ( rc = CloseStacks() ) {
        fSuccess = FALSE;
    }


    printf( "ICAKEY main: Test %s!\n", fSuccess ? "successful" : "failed" );
    return( 0 );
}


/****************************************************************************
 *
 * OpenStacks
 *
 *   Open ICA device driver, ICA stack, and ICA channels
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
OpenStacks( void )
{
    NTSTATUS rc;

    /*
     * Open an instance of the ICA device driver
     */
    if ( rc = IcaOpen( &ghIca ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaOpen\n",
                rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to ICA device driver: %08lX\n", ghIca );

    /*
     * Open an ICA stack instance
     */
    if ( rc = IcaStackOpen( ghIca, Stack_Primary, &ghStack ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaStackOpen\n", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to ICA stack: %08lX\n", ghStack );

    /*
     * Open the keyboard channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Keyboard, NULL, &ghKeyboard ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( keyboard )\n", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to keyboard channel: %08lX\n", ghKeyboard );

    /*
     * Open the mouse channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Mouse, NULL, &ghMouse ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( mouse )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to mouse channel: %08lX\n", ghMouse );

    /*
     * Open the video channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Video, NULL, &ghVideo ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( video )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to video channel: %08lX\n", ghVideo );

    /*
     * Open the beep channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Beep, NULL, &ghBeep ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( beep )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to beep channel: %08lX\n", ghBeep );

    /*
     * Open the command channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Command, NULL, &ghCommand ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( command )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to command channel: %08lX\n", ghCommand );

    /*
     * Open the cdm channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Virtual, VIRTUAL_CDM, &ghCdm ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( VIRTUAL_CDM )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to cdm channel: %08lX\n", ghCdm );

done:
    return( rc );
}


/****************************************************************************
 *
 * CloseStacks
 *
 *   Close the ICA device driver, ICA stack, and ICA channels
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
CloseStacks( void )
{
    LONG rc = STATUS_SUCCESS;


    /*
     * Close the stop event handle
     */
    if ( ghStopEvent ) {
        CloseHandle( ghStopEvent );
    }

    /*
     * Kill the keyboard read thread
     */
    if ( ghThreadKeyboardRead ) {
        TerminateThread( ghThreadKeyboardRead, 0 );
        CloseHandle( ghThreadKeyboardRead );
    }

    /*
     * Close the keyboard channel
     */
    if ( ghKeyboard ) {
        if ( rc = IcaChannelClose( ghKeyboard ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Keyboard )\n", rc );
        }
    }

    /*
     * Close the mouse channel
     */
    if ( ghMouse ) {
        if ( rc = IcaChannelClose( ghMouse ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Mouse )\n", rc );
        }
    }

    /*
     * Close the video channel
     */
    if ( ghVideo ) {
        if ( rc = IcaChannelClose( ghVideo ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Video )\n", rc );
        }
    }

    /*
     * Close the beep channel
     */
    if ( ghBeep ) {
        if ( rc = IcaChannelClose( ghBeep ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Beep )\n", rc );
        }
    }

    /*
     * Close the command channel
     */
    if ( ghCommand ) {
        if ( rc = IcaChannelClose( ghCommand ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Command )\n", rc );
        }
    }

    /*
     * Close the cdm channel
     */
    if ( ghCdm ) {
        if ( rc = IcaChannelClose( ghCdm ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Cdm )\n", rc );
        }
    }


    /*
     * Close the ICA stack instance
     */
    if ( ghStack ) {
        if ( rc = IcaStackClose( ghStack ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaStackClose\n", rc );
        }
    }


    /*
     * Close the ICA device driver instance
     */
    if ( ghIca ) {
        if ( rc = IcaClose( ghIca ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaClose\n", rc );
        }
    }

    return( rc );
}

/****************************************************************************
 *
 * Initialize
 *
 *   Do some initialization
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
Initialize( void ) 
{
    LONG  rc = STATUS_SUCCESS;
    DWORD tidKeyboardReadThread;
    THREADDATA ThreadData;

    /*
     * Create stop event to wait on later.
     */
    if ( !(ghStopEvent = CreateEvent( NULL, TRUE, FALSE, NULL )) ) {
        printf( "ICAKEY Initialize: Error 0x%x in CreateEvent\n", GetLastError() );
        goto done;
    }

    ThreadData.handle = ghKeyboard;

    /*
     * Startup the virtual channel read thread
     */
    if ( !(ghThreadKeyboardRead = CreateThread( NULL,
                                   KEYBOARD_THREAD_STACKSIZE,
                                   (LPTHREAD_START_ROUTINE)KeyboardReadThread,
                                   (LPVOID)&ThreadData, 0,
                                   (LPDWORD)&tidKeyboardReadThread )) ) {
        rc = GetLastError();
        printf( "ICAKEY Initialize: Error 0x%x creating keyboard read thread\n", rc );
        goto done;
    }

done:
    return( rc );
}

/*******************************************************************************
 *
 *  Function: KeyboardReadThread
 *
 *  Purpose: Keyboard read thread
 *
 *  Entry:
 *     pThreadData
 *        Pointer to thread creation data
 *
 *  Exit:
 *     void
 *
 ******************************************************************************/
VOID KeyboardReadThread( PTHREADDATA pThreadData )
{
    int                 rc;
    HANDLE              handle = pThreadData->handle;
    KEYBOARD_INPUT_DATA KeyboardInputData;
    DWORD               cbRead;
    OVERLAPPED          Overlapped;
    DWORD               dwError;
    int                 NumberRead = 0;

    Overlapped.Offset     = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent     = NULL;

    printf( "Keyboard read thread starting...\n" );

    /*
     * Now dedicate this thread to monitor the keyboard
     */
    do {
        cbRead = 0;
        
        if ( !ReadFile( ghKeyboard,
                        &KeyboardInputData,
                        sizeof( KeyboardInputData ),
                        &cbRead, &Overlapped ) ) {

            dwError = GetLastError();

            if ( dwError == ERROR_IO_PENDING ) {
	        // check on the results of the asynchronous read
	        if ( !GetOverlappedResult( ghKeyboard, &Overlapped, 
	   			       &cbRead, TRUE) ) { // wait for result
                    printf( "ICAKEY KeyboardReadThread: Error 0x%x from GetOverlappedResult( Channel_Keyboard )\n",
                            GetLastError() );
                    break;
                }
            }
	    else {

                printf( "ICAKEY KeyboardReadThread: Error 0x%x from ReadFile( Channel_Keyboard )\n",
                        dwError );
                break;
	    }
        }

        printf( "Unit number: 0x%x\nScan code: %02X\nFlags: %04X\nExtra info: %08X\n",
                KeyboardInputData.UnitId,
                KeyboardInputData.MakeCode,
                KeyboardInputData.Flags,
                KeyboardInputData.ExtraInformation );
        NumberRead++;

	if ( NumberRead == MAX_READ )
	    break;

    } while ( 1 );

    printf( "Keyboard read thread exiting...\n" );
    SetEvent( ghStopEvent );
    ExitThread( 0 );
}

/****************************************************************************
 *
 * KeyboardTest
 *
 *   Stuff some data into the keyboard channel for testing purposes
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
KeyboardTest( void ) 
{
    LONG                rc = STATUS_SUCCESS;
    KEYBOARD_INPUT_DATA KeyboardInputData;
    ULONG               cbReturned;

    /*
     * Initialize the keystroke to fabricate
     */
    KeyboardInputData.UnitId           = 0;
    KeyboardInputData.MakeCode         = 0x32;  // Capital 'M'
    KeyboardInputData.Flags            = KEY_MAKE;
    KeyboardInputData.Reserved         = 0;
    KeyboardInputData.ExtraInformation = 0;

    /*
     * First stuff the make
     */
    if ( rc = IcaChannelIoControl( ghKeyboard,
                                   IOCTL_KEYBOARD_ICA_INPUT,
                                   &KeyboardInputData,
                                   sizeof( KeyboardInputData ),
                                   NULL,
                                   0,
                                   &cbReturned ) ) {
        printf( "ICAKEY KeyboardTest: Error 0x%x in IcaChannelIoControl\n", rc );
        goto done;
    }

    KeyboardInputData.Flags    = KEY_BREAK;

    /*
     * Now stuff the break
     */
    if ( rc = IcaChannelIoControl( ghKeyboard,
                                   IOCTL_KEYBOARD_ICA_INPUT,
                                   &KeyboardInputData,
                                   sizeof( KeyboardInputData ),
                                   NULL,
                                   0,
                                   &cbReturned ) ) {
        printf( "ICAKEY KeyboardTest: Error 0x%x in IcaChannelIoControl\n", rc );
        goto done;
    }

done:
    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\memory.c ===
/*******************************************************************************
* MEMORY.C
*
*   Memory allocation routines
*
* Copyright Citrix Systems Inc. 1996
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   Author:   Brad Pedersen
******************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External Functions Defined
=============================================================================*/
NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/


/*******************************************************************************
 *
 *  IcaMemoryAllocate
 *
 *  This routine allocate a block of memory
 *
 *  ENTRY:
 *     Length (input)
 *        length of memory to allocate
 *     ppMemory (output)
 *        address to return pointer to memory
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
IcaMemoryAllocate( ULONG Length, PVOID * ppMemory )
{
    ASSERT( Length > 0 );

    *ppMemory = LocalAlloc( 0, Length );
    if ( *ppMemory == NULL )
        return( STATUS_NO_MEMORY );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaMemoryFree
 *
 *  This routine frees a block of memory allocated by "MemoryAllocate"
 *
 *  ENTRY:
 *     pMemory (output)
 *        pointer to memory to free
 *
 *  EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
IcaMemoryFree( PVOID pMemory )
{
    LocalFree( pMemory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\stack.c ===
/*************************************************************************
* STACK.C
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _IcaStackOpen( HANDLE hIca, HANDLE * phStack, ICA_OPEN_TYPE, PICA_TYPE_INFO );
NTSTATUS _IcaStackIoControlWorker( PSTACK pStack, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS _IcaPushStackAndCreateEndpoint( PSTACK pStack, PWINSTATIONNAME,
                                         PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                         PICA_STACK_ADDRESS );
NTSTATUS _IcaPushStackAndOpenEndpoint( PSTACK pStack, PWINSTATIONNAME,
                                       PWINSTATIONCONFIG2, PVOID, ULONG );
NTSTATUS _IcaPushStack( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2 );
NTSTATUS _IcaPushPd( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2,
                     PDLLNAME, PPDCONFIG );
NTSTATUS _IcaPushWd( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2 );
VOID     _IcaPopStack( PSTACK pStack );
NTSTATUS _IcaPopSd( PSTACK pStack );
NTSTATUS _IcaStackWaitForIca( PSTACK pStack, PWINSTATIONCONFIG2, BOOLEAN * );
void     _DecrementStackRef( IN PSTACK pStack );

/*=============================================================================
==   Procedures used
=============================================================================*/

NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );
NTSTATUS _IcaOpen( PHANDLE hIca, PVOID, ULONG );
NTSTATUS _CdOpen( PSTACK pStack, PWINSTATIONCONFIG2 );
VOID     _CdClose( PSTACK pStack );



/****************************************************************************
 *
 * IcaStackOpen
 *
 *   Open an ICA stack
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   Class (input)
 *     class (type) of stack
 *   pStackIoControlCallback (input)
 *     Pointer to StackIoControl callback procedure
 *   pCallbackContext (input)
 *     StackIoControl callback context value
 *   ppContext (output)
 *     Pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/


NTSTATUS
IcaStackOpen( IN HANDLE   hIca,
              IN STACKCLASS Class,
              IN PROC pStackIoControlCallback,
              IN PVOID pCallbackContext,
              OUT HANDLE * ppContext )
{
    ICA_TYPE_INFO TypeInfo;
    PSTACK pStack;
    NTSTATUS Status;


    /*
     *  Allocate Memory for stack context data structure
     */
    Status = IcaMemoryAllocate( sizeof(STACK), &pStack );
    if ( !NT_SUCCESS(Status) )
        goto badalloc;

    /*
     *  Zero STACK data structure
     */
    RtlZeroMemory( pStack, sizeof(STACK) );

    /*
     *  Initialize critical section
     */
    INITLOCK( &pStack->CritSec, Status );
    if ( !NT_SUCCESS( Status ) )
        goto badcritsec;

    /*
     *  Open stack handle to ica device driver
     */
    RtlZeroMemory( &TypeInfo, sizeof(TypeInfo) );
    TypeInfo.StackClass = Class;
    Status = _IcaStackOpen( hIca, &pStack->hStack, IcaOpen_Stack, &TypeInfo );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     * Save StackIoControl and Context callback values
     */
    pStack->pCallbackContext = pCallbackContext;
    pStack->pStackIoControlCallback = (PSTACKIOCONTROLCALLBACK)pStackIoControlCallback;

    *ppContext = pStack;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaStackOpen, type %u, success\n", Class ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    DELETELOCK( &pStack->CritSec );

badcritsec:
    IcaMemoryFree( pStack );

badalloc:
    TRACE(( hIca, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackOpen, type %u, 0x%x\n", Class, Status ));
    *ppContext = NULL;
    return( Status );
}


/****************************************************************************
 *
 * IcaStackClose
 *
 *   Close an ICA stack
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackClose( IN HANDLE pContext )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackClose\n" ));

    /*
     *  Set closing flag
     */
    pStack->fClosing = TRUE;

    /*
     *  Unload stack
     */
    _IcaPopStack( pContext );

    /*
     *  Wait for reference count to go to zero before we continue
     */
    while ( pStack->RefCount > 0 ) {

        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack: waiting for refcount %d\n", pStack->RefCount ));

        pStack->hCloseEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pStack->hCloseEvent );

        UNLOCK( &pStack->CritSec );
        (void) WaitForSingleObject( pStack->hCloseEvent, INFINITE );
        LOCK( &pStack->CritSec );

        CloseHandle( pStack->hCloseEvent );
        pStack->hCloseEvent = NULL;
    }
    /*
     * Close the ICA device driver stack instance
     */
    Status = NtClose( pStack->hStack );
    pStack->hStack = NULL;

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );
    DELETELOCK( &pStack->CritSec );

    /*
     *  Free stack context memory
     */
    IcaMemoryFree( pContext );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackUnlock
 *
 *   Unlocks an ICA stack
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackUnlock( IN HANDLE pContext )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );
}


/****************************************************************************
 *
 * IcaStackTerminate
 *
 *   Prepare to close an ICA stack
 *   (unloads all stack drivers and marks stack as being closed)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackTerminate( IN HANDLE pContext )
{
    PSTACK pStack;
    NTSTATUS Status = STATUS_SUCCESS;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackTerminate\n" ));

    /*
     *  Set closing flag
     */
    pStack->fClosing = TRUE;

    /*
     *  Unload stack
     */
    _IcaPopStack( pContext );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionWait
 *
 *    Load template stack and wait for a connection
 *
 * NOTE: On an error the endpoint is closed and the stack is unloaded
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to WinStation registry configuration data
 *   pAddress (input)
 *     Pointer to optional local address to wait on (or null)
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint (optional)
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionWait( IN  HANDLE pContext,
                        IN  PWINSTATIONNAME pWinStationName,
                        IN  PWINSTATIONCONFIG2 pWinStationConfig,
                        IN  PICA_STACK_ADDRESS pAddress,
                        OUT PVOID pEndpoint,
                        IN  ULONG BufferLength,
                        OUT PULONG pEndpointLength )
{
    NTSTATUS Status;
    PSTACK pStack;
    BOOLEAN fStackLoaded;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  load template stack and create stack endpoint
     */
    if ( !(fStackLoaded = (BOOLEAN)pStack->fStackLoaded) ) {
        Status = _IcaPushStackAndCreateEndpoint( pStack,
                                                 pWinStationName,
                                                 pWinStationConfig,
                                                 pAddress,
                                                 NULL );
        if ( !NT_SUCCESS(Status) )
            goto badcreate;
    }

    /*
     *  Now wait for a connection.
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_WAIT,
                                 NULL,
                                 0,
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );
    if ( !NT_SUCCESS(Status) )
        goto badwait;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionWait, success\n" ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/
    /*
     * If the stack wasn't already loaded,
     * then pop all stack drivers now.
     */
badwait:
    if ( !fStackLoaded ) {
        _IcaPopStack( pContext );
    }

badcreate:
    *pEndpointLength = 0;
    memset( pEndpoint, 0, BufferLength );
    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionWait, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackQueryLocalAddress
 *
 *    Load template stack and query RDP-Enabled local IP Address
 *
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to WinStation registry configuration data
 *   pAddress (input)
 *     Pointer to optional local address to wait on (or null)
 *   pLocalIPAddress (output)
 *     Pointer to buffer to return RDP-Enabled Local IP Address
 *   BufferLength (input)
 *     length of input data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of LocaIPAddress 
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackQueryLocalAddress( IN  HANDLE pContext,
                           IN  PWINSTATIONNAME pWinStationName,
                           IN  PWINSTATIONCONFIG2 pWinStationConfig,
                           IN  PICA_STACK_ADDRESS pAddress,
                           OUT PVOID pLocalIPAddress,
                           IN  ULONG BufferLength,
                           OUT PULONG pLocalIPAddressLength )
{
    NTSTATUS Status;
    PSTACK pStack;
    BOOLEAN fStackLoaded;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  load template stack and create stack endpoint
     */
    if ( !(fStackLoaded = (BOOLEAN)pStack->fStackLoaded) ) {
        Status = _IcaPushStackAndCreateEndpoint( pStack,
                                                 pWinStationName,
                                                 pWinStationConfig,
                                                 pAddress,
                                                 NULL );
        if ( !NT_SUCCESS(Status) )
            goto badcreate;
    }

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_QUERY_LOCALADDRESS,
                                 NULL,
                                 0,
                                 pLocalIPAddress,
                                 BufferLength,
                                 pLocalIPAddressLength );
    if ( !NT_SUCCESS(Status) )
        goto badquery;    

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackQueryLocalAddress, success\n" ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/
    /*
     * If the stack wasn't already loaded,
     * then pop all stack drivers now.
     */
badquery:
    if ( !fStackLoaded ) {
        _IcaPopStack( pContext );
    }

badcreate:
    *pLocalIPAddressLength = 0;
    memset( pLocalIPAddress, 0, BufferLength );
    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackQueryLocalAddress, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}



/****************************************************************************
 *
 * IcaStackConnectionRequest
 *
 *   Load query stack and try to make a connection with the client
 *
 * NOTE: On an error the endpoint is NOT closed and the stack is unloaded
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pAddress (input)
 *     address to connect to (remote address)
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint (optional)
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionRequest( IN  HANDLE pContext,
                           IN  PWINSTATIONNAME pWinStationName,
                           IN  PWINSTATIONCONFIG2 pWinStationConfig,
                           IN  PICA_STACK_ADDRESS pAddress,
                           OUT PVOID pEndpoint,
                           IN  ULONG BufferLength,
                           OUT PULONG pEndpointLength )
{
    ULONG ReturnLength;
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Load template Stack
     */
    Status = _IcaPushStack( pContext, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badpush;

    /*
     *  Now initiate a connection to the specified address
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_REQUEST,
                                 pAddress,
                                 sizeof(*pAddress),
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );
    if ( !NT_SUCCESS(Status) )
        goto badrequest;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionRequest, success\n" ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badrequest:
    /* pop all stack drivers */
    _IcaPopStack( pContext );

badpush:
    *pEndpointLength = 0;
    memset( pEndpoint, 0, BufferLength );
    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionRequest, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionAccept
 *
 *   Load final stack and complete the connection
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *     - this can be different from the initially connecting stack
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     pointer to endpoint data
 *   EndpointLength (input)
 *     Length of endpoint
 *   pStackState (input) (optional)
 *     Set if this Accept is for a re-connection
 *     Points to ICA_STACK_STATE_HEADER buffer returned by IcaStackQueryState
 *   BufferLength (input)
 *     Length of pStackState buffer
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionAccept( IN  HANDLE hIca,
                          IN  HANDLE pContext,
                          IN  PWINSTATIONNAME pWinStationName,
                          IN  PWINSTATIONCONFIG2 pWinStationConfig,
                          IN  PVOID pEndpoint,
                          IN  ULONG EndpointLength,
                          IN  PICA_STACK_STATE_HEADER pStackState,
                          IN  ULONG BufferLength,
                          IN  PICA_TRACE pTrace )
{
    NTSTATUS Status;
    ULONG cbReturned;
    ICA_STACK_CONFIG IcaStackConfig;
    BOOLEAN fQueryAgain;
    BOOLEAN fStackModified;
    ULONG i;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Verify parameters
     */
    if ( pEndpoint == NULL )
        return( STATUS_INVALID_PARAMETER );

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Check if we need to load and open the template stack again
     */
    if ( !pStack->fStackLoaded ) {
        Status = _IcaPushStackAndOpenEndpoint( pContext,
                                               pWinStationName,
                                               pWinStationConfig,
                                               pEndpoint,
                                               EndpointLength );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Enable trace now that the WD is loaded
         */

        IcaIoControl( hIca,
                      IOCTL_ICA_SET_TRACE,
                      pTrace,
                      sizeof ( ICA_TRACE ),
                      NULL,
                      0,
                      NULL );

    }

    /*
     *  If this is a reconnect, then issue set stack state call
     *  now that we have loaded the required PDs.
     */
    if ( pStackState ) {
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_SET_STATE,
                                     pStackState,
                                     BufferLength,
                                     NULL,
                                     0,
                                     NULL );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

    /*
     * If this is not a re-connect of a previous session, then
     * prepare the stack for initial negotiation with the client.
     */
    } else {
        ICA_STACK_CONFIG_DATA ConfigData;

        memset(&ConfigData, 0, sizeof(ICA_STACK_CONFIG_DATA));
        ConfigData.colorDepth = pWinStationConfig->Config.User.ColorDepth;
        ConfigData.fDisableEncryption = pWinStationConfig->Config.User.fDisableEncryption;
        ConfigData.encryptionLevel = pWinStationConfig->Config.User.MinEncryptionLevel;
        ConfigData.fDisableAutoReconnect = pWinStationConfig->Config.User.fDisableAutoReconnect;

        /*
         *  Send the config data to stack driver
         */
        _IcaStackIoControl( pStack,
                            IOCTL_ICA_STACK_SET_CONFIG,
                            &ConfigData,
                            sizeof(ICA_STACK_CONFIG_DATA),
                            NULL,
                            0,
                            NULL);


        /*
         *  Wait for ICA Detect string from client
         */
        Status = _IcaStackWaitForIca( pContext,
                                      pWinStationConfig,
                                      &fStackModified );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         *  Check if the query stack is different than the template stack
         */
        if ( fStackModified ) {

            TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept, load query stack\n"));
            ASSERT(FALSE);

#ifdef notdef
            /*
             *  Unload all stack drivers except the transport
             *  and connection drivers
             *            -- we can not pop the td or cd
             *            -- we can not issue a cancel i/o
             */
            _IcaPopStack( pContext );

            /*
             *  Load and open the new query stack
             */
            Status = _IcaPushStackAndOpenEndpoint( pContext,
                                                   pWinStationName,
                                                   pWinStationConfig,
                                                   pEndpoint,
                                                   EndpointLength );
            if ( !NT_SUCCESS(Status) ) {
                goto badaccept;
            }
#endif
        }
    }


    /*
     * At this point the stack is now set up (again).  The client is
     * now queried for any configuration changes.
     *
     *  - repeat this loop until WD does not change
     */
    do {

        /*
         *  Clear query again flag
         */
        fQueryAgain = FALSE;

        /*
         * Query the client for the optional PD's
         */
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_CONNECTION_QUERY,
                                     NULL,
                                     0,
                                     &IcaStackConfig,
                                     sizeof(IcaStackConfig),
                                     &cbReturned );

        if ( !NT_SUCCESS(Status) ) {
            TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept: IOCTL_ICA_STACK_CONNECTION_QUERY, 0x%x\n", Status ));
            goto badaccept;
        }

        if ( cbReturned != sizeof(IcaStackConfig) ) {
            TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept: Bad size %d from IOCTL_ICA_STACK_CONNECTION_QUERY\n", cbReturned ));
            Status = STATUS_INVALID_BUFFER_SIZE;
            goto badaccept;
        }

        TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept: IOCTL_ICA_STACK_CONNECTION_QUERY success\n" ));

        /*
         * If the WD changed we must load it (and the rest of the stack) and
         * reissue the query.
         */
        if ( _wcsnicmp( IcaStackConfig.WdDLL,
                        pWinStationConfig->Wd.WdDLL,
                        DLLNAME_LENGTH ) ) {

            TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept WD changing from %S to %S\n", pWinStationConfig->Wd.WdDLL, IcaStackConfig.WdDLL ));

            memcpy( pWinStationConfig->Wd.WdDLL,
                    IcaStackConfig.WdDLL,
                    sizeof( pWinStationConfig->Wd.WdDLL ) );

            fQueryAgain = TRUE;
        }

        /*
         *  If no new modules were requested, we are done querying
         */
        if ( !fQueryAgain && (IcaStackConfig.SdClass[0] == SdNone) )
            break;

        /*
         * Pop the WD to load new PD's underneath.
         */
        Status = _IcaPopSd( pContext );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Push Optional PD's
         */
        for ( i=0; i < SdClass_Maximum; i++ ) {

            if ( IcaStackConfig.SdClass[i] == SdNone )
                break;

            Status = _IcaPushPd( pContext,
                                 pWinStationName,
                                 pWinStationConfig,
                                 IcaStackConfig.SdDLL[i],
                                 &pWinStationConfig->Pd[0] );

            /*
             *  If the PD driver is not found, the client is using an optional
             *  PD that is not supported by the host.  Continue loading and let
             *  the client and server negoatiate the connection.
             */
            if ( !NT_SUCCESS(Status) && (Status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
                goto badaccept;
            }
        }

        /*
         * Re-push the WD
         */
        Status = _IcaPushWd( pContext, pWinStationName, pWinStationConfig );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Re-Enable trace now that the WD is loaded
         */
        IcaIoControl( hIca,
                      IOCTL_ICA_SET_TRACE,
                      pTrace,
                      sizeof ( ICA_TRACE ),
                      NULL,
                      0,
                      NULL );

    } while ( fQueryAgain );

    /*
     *  If this is a reconnect, then issue set stack state call
     *  now that we have loaded the optional PDs.
     */
    if ( pStackState ) {
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_SET_STATE,
                                     pStackState,
                                     BufferLength,
                                     NULL,
                                     0,
                                     NULL );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }
    }

    /*
     *  Send host module data to client
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_SEND,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS(Status) )
        goto badaccept;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept, success\n" ));

    /*
     *  Leave the critical section locked because the protocol sequence has
     *	not been finished. The sequence will be finished by the licensing core
     *	in termsrv.exe, and the critical section will be unlocked at that point.
     */
    //UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badaccept:
    /* pop all stack drivers */
    _IcaPopStack( pContext );

    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackQueryState
 *
 *   Query stack driver state information
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *     - this can be different from the initially connecting stack
 *
 *   pStackState (output)
 *     pointer to buffer to return stack state information
 *
 *   BufferLength (input)
 *     Length of pStackState buffer
 *
 *   pStateLength (output)
 *     length of returned stack state information
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackQueryState( IN HANDLE pContext,
                    OUT PICA_STACK_STATE_HEADER pStackState,
                    IN ULONG BufferLength,
                    OUT PULONG pStateLength )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Query state
     */
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_QUERY_STATE,
                                 NULL,
                                 0,
                                 pStackState,
                                 BufferLength,
                                 pStateLength );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackQueryState, 0x%x\n", Status ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * IcaStackCreateShadowEndpoint
 *
 *    Load template stack and create the endpoint
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pAddressIn (input)
 *     Pointer to local address of endpoint to create
 *   pAddressOut (output)
 *     Pointer to location to return address of endpoint created
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackCreateShadowEndpoint( HANDLE pContext,
                              PWINSTATIONNAME pWinStationName,
                              PWINSTATIONCONFIG2 pWinStationConfig,
                              PICA_STACK_ADDRESS pAddressIn,
                              PICA_STACK_ADDRESS pAddressOut )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  load template stack and create stack endpoint
     */
    if ( pStack->fStackLoaded ) {
        Status = STATUS_ADDRESS_ALREADY_ASSOCIATED;
    } else {
        Status = _IcaPushStackAndCreateEndpoint( pStack,
                                                 pWinStationName,
                                                 pWinStationConfig,
                                                 pAddressIn,
                                                 pAddressOut );
    }

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    if ( !NT_SUCCESS( Status ) ) {
        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: IcaStackCreateShadowEndpoint, success\n" ));
    } else {
        TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackCreateShadowEndpoint, 0x%x\n", Status ));
    }

    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionClose
 *
 *   Close the connection endpoint
 *
 *   This is the only way to close the connecting connection.
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     Structure defining connection endpoint
 *   EndpointLength (input)
 *     Length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionClose( IN  HANDLE pContext,
                         IN  PWINSTATIONCONFIG2 pWinStationConfig,
                         IN  PVOID pEndpoint,
                         IN  ULONG EndpointLength
                       )
{
    ULONG cbReturned;
    NTSTATUS Status;
    PSTACK pStack;
    BOOLEAN fPopStack = FALSE;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  If necessary, load the template stack
     *  - we can't issue ioctls without a stack
     */
    if ( !pStack->fStackLoaded ) {

        /*
         *  Load and open the template stack
         */
        Status = _IcaPushStackAndOpenEndpoint( pContext,
                                               TEXT(""),
                                               pWinStationConfig,
                                               pEndpoint,
                                               EndpointLength );
        if ( !NT_SUCCESS(Status) ) {
            goto badclose;
        }

        fPopStack = TRUE;   // remember we have to pop the stack below
    }

    /*
     *  Close endpoint
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CLOSE_ENDPOINT,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );

    /*
     *  Pop stack drivers if we loaded them above
     */
    if ( fPopStack )
        _IcaPopStack( pContext );

badclose:
    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionClose, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackCallback
 *
 *   dial specified phone number and make connection to client
 *
 * NOTE: On an error the endpoint is NOT closed and the stack is unloaded
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pPhoneNumber (input)
 *     pointer to client phone number
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackCallback( IN  HANDLE pContext,
                  IN  PWINSTATIONCONFIG2 pWinStationConfig,
                  IN  WCHAR * pPhoneNumber,
                  OUT PVOID pEndpoint,
                  IN  ULONG BufferLength,
                  OUT PULONG pEndpointLength )
{
    NTSTATUS Status;
    ICA_STACK_CALLBACK Cb;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    wcscpy( Cb.PhoneNumber, pPhoneNumber );

    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_CALLBACK_INITIATE,
                                 &Cb,
                                 sizeof(Cb),
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );


    TRACESTACK(( pContext, TC_ICAAPI, TT_API1,
                 "TSAPI: IcaStackCallback: %S, 0x%x\n",
                 pPhoneNumber, Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackDisconnect
 *
 *   Disconnect the specified stack from its ICA connection
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   hIca (input)
 *     handle to temp ICA connection
 *   pCallbackContext (input)
 *     New StackIoControl callback context value
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackDisconnect(
    HANDLE pContext,
    HANDLE hIca,
    PVOID pCallbackContext
    )
{
    PSTACK pStack;
    ICA_STACK_RECONNECT IoctlReconnect;
    NTSTATUS Status;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    IoctlReconnect.hIca = hIca;
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_DISCONNECT,
                                 &IoctlReconnect,
                                 sizeof(IoctlReconnect),
                                 NULL,
                                 0,
                                 NULL );
    if ( NT_SUCCESS( Status ) ) {
        pStack->pCallbackContext = pCallbackContext;
    }

    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackReconnect
 *
 *   Reconnect the specified stack to a new ICA connection
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   hIca (input)
 *     handle to temp ICA connection
 *   pCallbackContext (input)
 *     New StackIoControl callback context value
 *   sessionId (input)
 *     Session ID of the Winstation we are reconnecting to
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackReconnect(
    HANDLE pContext,
    HANDLE hIca,
    PVOID pCallbackContext,
    ULONG sessionId
    )
{
    PSTACK pStack;
    ICA_STACK_RECONNECT IoctlReconnect;
    PVOID SaveContext;
    NTSTATUS Status;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    SaveContext = pStack->pCallbackContext;
    pStack->pCallbackContext = pCallbackContext;

    IoctlReconnect.hIca = hIca;
    IoctlReconnect.sessionId = sessionId;
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_RECONNECT,
                                 &IoctlReconnect,
                                 sizeof(IoctlReconnect),
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS( Status ) ) {
        pStack->pCallbackContext = SaveContext;
    }

    UNLOCK( &pStack->CritSec );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaStackTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaStackTrace( IN HANDLE pContext,
               IN ULONG TraceClass,
               IN ULONG TraceEnable,
               IN char * Format,
               IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker ) + 1;

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;
    if (pStack->hStack != NULL) {
        (void) IcaIoControl( pStack->hStack,
                             IOCTL_ICA_STACK_TRACE,
                             &Buffer,
                             sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                             NULL,
                             0,
                             NULL );
    }

}


/****************************************************************************
 *
 * IcaStackIoControl
 *
 *   Generic interface to an ICA stack  (with locking)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackIoControl( IN HANDLE pContext,
                   IN ULONG IoControlCode,
                   IN PVOID pInBuffer,
                   IN ULONG InBufferSize,
                   OUT PVOID pOutBuffer,
                   IN ULONG OutBufferSize,
                   OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Call worker routine
     */
    Status = _IcaStackIoControlWorker( pContext,
                                       IoControlCode,
                                       pInBuffer,
                                       InBufferSize,
                                       pOutBuffer,
                                       OutBufferSize,
                                       pBytesReturned );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * IcaPushConsoleStack
 *
 *   Load initial stack
 *
 *       stack push for each stack driver
 *           in order td - pd - wd
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaPushConsoleStack( IN HANDLE pContext,
                     IN PWINSTATIONNAME pWinStationName,
                     IN PWINSTATIONCONFIG2 pWinStationConfig,
                     IN PVOID pModuleData,
                     IN ULONG ModuleDataLength )
{
    NTSTATUS Status;
    PSTACK   pStack;
    ULONG cbReturned;
    ULONG i;

    pStack = (PSTACK) pContext;

    LOCK( &pStack->CritSec );

    /*
     * build the stack
     */
    Status = _IcaPushStack( pStack,
                            pWinStationName,
                            pWinStationConfig);


    if ( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "IcaPushConsoleStack _IcaPushStack failed\n"));
        goto failure;
    }

    /*
     * and now set up the connection to the console
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONSOLE_CONNECT,
                                 pModuleData,
                                 ModuleDataLength,
                                 NULL,
                                 0,
                                 &cbReturned );

    if ( !NT_SUCCESS(Status) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "IcaPushConsoleStack - stack wait failed\n"));
        goto failure;
    }

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "IcaPushConsoleStack - done stack wait\n"));

failure:
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackOpen
 *
 *   Open an ICA stack or an ICA channel
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   phStack (output)
 *     Pointer to ICA stack or channel handle
 *
 *   OpenType (input)
 *     ICA open type
 *
 *   pTypeInfo (input)
 *     Pointer to ICA type info
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackOpen( HANDLE   hIca,
               HANDLE * phStack,
               ICA_OPEN_TYPE OpenType,
               PICA_TYPE_INFO pTypeInfo )
{
    NTSTATUS                  Status;
    PFILE_FULL_EA_INFORMATION pEa = NULL;
    ICA_OPEN_PACKET UNALIGNED * pIcaOpenPacket;
    ULONG                     cbEa = sizeof( FILE_FULL_EA_INFORMATION )
                                   + ICA_OPEN_PACKET_NAME_LENGTH
                                   + sizeof( ICA_OPEN_PACKET );


    /*
     * Allocate some memory for the EA buffer
     */
    Status = IcaMemoryAllocate( cbEa, &pEa );
    if ( !NT_SUCCESS(Status) )
        goto done;

    /*
     * Initialize the EA buffer
     */
    pEa->NextEntryOffset = 0;
    pEa->Flags           = 0;
    pEa->EaNameLength    = ICA_OPEN_PACKET_NAME_LENGTH;
    memcpy( pEa->EaName, ICAOPENPACKET, ICA_OPEN_PACKET_NAME_LENGTH + 1 );

    pEa->EaValueLength   = sizeof( ICA_OPEN_PACKET );
    pIcaOpenPacket       = (ICA_OPEN_PACKET UNALIGNED *)(pEa->EaName +
                                                          pEa->EaNameLength + 1);

    /*
     * Now put the open packe parameters into the EA buffer
     */
    pIcaOpenPacket->IcaHandle = hIca;
    pIcaOpenPacket->OpenType  = OpenType;
    pIcaOpenPacket->TypeInfo  = *pTypeInfo;


    Status = _IcaOpen( phStack, pEa, cbEa );

done:
    if ( pEa ) {
        IcaMemoryFree( pEa );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackIoControl
 *
 *   Local (ICAAPI) interface to an ICA stack through callback routine
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackIoControl( IN HANDLE pContext,
                    IN ULONG IoControlCode,
                    IN PVOID pInBuffer,
                    IN ULONG InBufferSize,
                    OUT PVOID pOutBuffer,
                    IN ULONG OutBufferSize,
                    OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Call callback function to handle StackIoControl
     */
    if ( pStack->pStackIoControlCallback ) {

        /*
         *  Unlock critical section
         */
        pStack->RefCount++;
        UNLOCK( &pStack->CritSec );

        Status = pStack->pStackIoControlCallback(
                            pStack->pCallbackContext,
                            pStack,
                            IoControlCode,
                            pInBuffer,
                            InBufferSize,
                            pOutBuffer,
                            OutBufferSize,
                            pBytesReturned );

        /*
         *  Re-lock critical section
         */
        LOCK( &pStack->CritSec );
        _DecrementStackRef( pStack );

    } else {

        Status = _IcaStackIoControlWorker( pStack,
                                           IoControlCode,
                                           pInBuffer,
                                           InBufferSize,
                                           pOutBuffer,
                                           OutBufferSize,
                                           pBytesReturned );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackIoControlWorker
 *
 *   Private worker interface to an ICA stack
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackIoControlWorker( IN PSTACK pStack,
                          IN ULONG IoControlCode,
                          IN PVOID pInBuffer,
                          IN ULONG InBufferSize,
                          OUT PVOID pOutBuffer,
                          IN ULONG OutBufferSize,
                          OUT PULONG pBytesReturned )
{
    NTSTATUS Status;

    if ( pStack->pCdIoControl ) {

        /*
         *  Call connection driver, CD will call ICA device driver
         */
        Status = (*pStack->pCdIoControl)( pStack->pCdContext,
                                          IoControlCode,
                                          pInBuffer,
                                          InBufferSize,
                                          pOutBuffer,
                                          OutBufferSize,
                                          pBytesReturned );

        if ( pStack->fClosing && (IoControlCode != IOCTL_ICA_STACK_POP) )
            Status = STATUS_CTX_CLOSE_PENDING;

    } else {

        /*
         *  Unlock critical section
         */
        pStack->RefCount++;
        UNLOCK( &pStack->CritSec );

        /*
         *  Call ICA device driver directly
         *  - this stack does not have a connection driver
         */
        Status = IcaIoControl( pStack->hStack,
                               IoControlCode,
                               pInBuffer,
                               InBufferSize,
                               pOutBuffer,
                               OutBufferSize,
                               pBytesReturned );

        /*
         *  Re-lock critical section
         */
        LOCK( &pStack->CritSec );
        _DecrementStackRef( pStack );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStackAndCreateEndpoint
 *
 *   Load and create stack endpoint
 *
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pInAddress (input)
 *     pointer to address to use (optional)
 *   pOutAddress (output)
 *     pointer to location to return final address (optional)
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStackAndCreateEndpoint( IN PSTACK pStack,
                                IN PWINSTATIONNAME pWinStationName,
                                IN PWINSTATIONCONFIG2 pWinStationConfig,
                                IN PICA_STACK_ADDRESS pInAddress,
                                OUT PICA_STACK_ADDRESS pOutAddress )
{
    ULONG BytesReturned;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load template Stack
     */
    Status = _IcaPushStack( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) ) {
        goto badpush;
    }

    /*
     * Open the transport driver endpoint
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CREATE_ENDPOINT,
                                 pInAddress,
                                 pInAddress ? sizeof(*pInAddress) : 0,
                                 pOutAddress,
                                 pOutAddress ? sizeof(*pOutAddress) : 0,
                                 &BytesReturned );
    if ( !NT_SUCCESS(Status) ) {
        goto badendpoint;
    }


    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStackAndCreateEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badendpoint:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badpush:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStackAndCreateEndpoint, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStackAndOpenEndpoint
 *
 *   Load and open stack endpoint
 *
 *
 * ENTRY:
 *
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     Structure defining connection endpoint
 *   EndpointLength (input)
 *     Length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStackAndOpenEndpoint( IN PSTACK pStack,
                              IN PWINSTATIONNAME pWinStationName,
                              IN PWINSTATIONCONFIG2 pWinStationConfig,
                              IN PVOID pEndpoint,
                              IN ULONG EndpointLength )
{
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load the template stack again
     */
    Status = _IcaPushStack( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) ) {
        goto badpush;
    }

    /*
     *  Give open endpoint to the transport driver
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_OPEN_ENDPOINT,
                                 pEndpoint,
                                 EndpointLength,
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS(Status) ) {
        goto badendpoint;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStackAndOpenEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badendpoint:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badpush:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStackAndOpenEndpoint, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStack
 *
 *   Load initial stack
 *
 *       stack push for each stack driver
 *           in order td - pd - wd
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStack( IN PSTACK pStack,
               IN PWINSTATIONNAME pWinStationName,
               IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    PPDCONFIG pPdConfig;
    NTSTATUS Status;
    ULONG i;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load and open connection driver
     */
    Status = _CdOpen( pStack, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badcdopen;

    /*
     *  Load PD(s)
     */
    pPdConfig = &pWinStationConfig->Pd[0];
    for ( i = 0; i < MAX_PDCONFIG; i++, pPdConfig++ ) {

        if ( pPdConfig->Create.SdClass == SdNone )
            break;

        /*
         * Do the push.
         */
        Status = _IcaPushPd( pStack,
                             pWinStationName,
                             pWinStationConfig,
                             pPdConfig->Create.PdDLL,
                             pPdConfig );
        if ( !NT_SUCCESS( Status ) ) {
            goto badpdpush;
        }

        if ( pStack->fClosing ) {
            goto stackclosing;
        }
    }

    /*
     *  Push the WD.
     */
    Status = _IcaPushWd( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badwdpush;

    if ( pStack->fClosing ) {
        goto stackclosing;
    }

    /*
     *  Set stack loaded flag
     */
    pStack->fStackLoaded = TRUE;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStack, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badwdpush:
badpdpush:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badcdopen:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStack, 0x%x\n", Status ));
    return( Status );

stackclosing:
    /*
     *  Unload all stack drivers
     */
    while ( _IcaPopSd( pStack ) == STATUS_SUCCESS ) {;}

    return( STATUS_CTX_CLOSE_PENDING );
}


/****************************************************************************
 *
 * _IcaPushPd
 *
 *   Push a PD module.
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pDllName (input)
 *     Name of module to push
 *   pPdConfig (input)
 *     pointer to configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushPd( IN PSTACK pStack,
            IN PWINSTATIONNAME pWinStationName,
            IN PWINSTATIONCONFIG2 pWinStationConfig,
            IN PDLLNAME pDllName,
            IN PPDCONFIG pPdConfig )
{
    ICA_STACK_PUSH IcaStackPush;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushPd, %S\n", pDllName ));

    memset( &IcaStackPush, 0, sizeof(IcaStackPush) );

    IcaStackPush.StackModuleType = Stack_Module_Pd;

    ASSERT( pDllName[0] );

    memcpy( IcaStackPush.StackModuleName, pDllName,
            sizeof( IcaStackPush.StackModuleName ) );

#ifndef _HYDRA_
//    wcscat( IcaStackPush.StackModuleName, ICA_SD_MODULE_EXTENTION );
#endif

    memcpy( IcaStackPush.OEMId,
            pWinStationConfig->Config.OEMId,
            sizeof(pWinStationConfig->Config.OEMId) );

    IcaStackPush.WdConfig = pWinStationConfig->Wd;
    IcaStackPush.PdConfig = *pPdConfig;

    memcpy( IcaStackPush.WinStationRegName,
            pWinStationName,
            sizeof(IcaStackPush.WinStationRegName) );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_PUSH,
                                 &IcaStackPush,
                                 sizeof( IcaStackPush ),
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushPd, %S, 0x%x\n", pDllName, Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushWd
 *
 *   Push a WD module.
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushWd( IN PSTACK pStack,
            IN PWINSTATIONNAME pWinStationName,
            IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    ICA_STACK_PUSH IcaStackPush;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushWd, %S\n", pWinStationConfig->Wd.WdDLL ));

    memset( &IcaStackPush, 0, sizeof(IcaStackPush) );

    IcaStackPush.StackModuleType = Stack_Module_Wd;

    memcpy( IcaStackPush.StackModuleName, pWinStationConfig->Wd.WdDLL,
            sizeof( IcaStackPush.StackModuleName ) );

#ifndef _HYDRA_
    //wcscat( IcaStackPush.StackModuleName, ICA_SD_MODULE_EXTENTION );
#endif

    memcpy( IcaStackPush.OEMId,
            pWinStationConfig->Config.OEMId,
            sizeof(pWinStationConfig->Config.OEMId) );

    IcaStackPush.WdConfig = pWinStationConfig->Wd;
    IcaStackPush.PdConfig = pWinStationConfig->Pd[0];

    memcpy( IcaStackPush.WinStationRegName,
            pWinStationName,
            sizeof(IcaStackPush.WinStationRegName) );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_PUSH,
                                 &IcaStackPush,
                                 sizeof( IcaStackPush ),
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushWd, %S, 0x%x\n", pWinStationConfig->Wd.WdDLL, Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPopStack
 *
 *   Pop all the stack drivers
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

void
_IcaPopStack( IN PSTACK pStack )
{
    ASSERTLOCK( &pStack->CritSec );

    /*
     *  If another thread is doing the unload, then nothing else to do.
     */
    if ( pStack->fUnloading )
        return;
    pStack->fUnloading = TRUE;

    /*
     *  Unload all stack drivers
     */
    while ( _IcaPopSd( pStack ) == STATUS_SUCCESS ) {
        ;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack all stack drivers unloaded\n" ));

    /*
     *  Release CD threads
     */
    (void) _IcaStackIoControl( pStack,
                               IOCTL_ICA_STACK_CD_CANCEL_IO,
                               NULL, 0, NULL, 0, NULL );

    /*
     *  Wait for all other references (besides our own) to go away
     */
    pStack->RefCount++;
waitagain:
    while ( pStack->RefCount > 1 ) {

        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack: waiting for refcount %d\n", pStack->RefCount ));

        pStack->hUnloadEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pStack->hUnloadEvent );

        UNLOCK( &pStack->CritSec );
        (void) WaitForSingleObject( pStack->hUnloadEvent, INFINITE );
        LOCK( &pStack->CritSec );

		//	NOTE: seems to me that between being notified and locking the
		//	stack, some other thread could have locked the stack and bumped
		//	the ref count. no breaks have ever been hit, though.
		if (pStack->RefCount > 1) {
			goto waitagain;
		}

        CloseHandle( pStack->hUnloadEvent );
        pStack->hUnloadEvent = NULL;
    }
    _DecrementStackRef( pStack );

    /*
     *  Unload connection driver
     */
    _CdClose( pStack );

    /*
     *  Clear stack loaded flag
     */
    pStack->fStackLoaded = FALSE;
    pStack->fUnloading = FALSE;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack\n" ));
}


/****************************************************************************
 *
 * _IcaPopSd
 *
 *   Pop a stack driver module  (wd or pd)
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPopSd( IN PSTACK pStack )
{
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_POP,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopSd, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaStackWaitForIca
 *
 *   Wait for ICA Detect string
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationConfig (input/output)
 *     pointer to winstation registry configuration data
 *   pfStackModified (output)
 *     Pointer to stack modified flag
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackWaitForIca( IN PSTACK pStack,
                     IN OUT PWINSTATIONCONFIG2 pWinStationConfig,
                     OUT BOOLEAN * pfStackModified )
{
    ICA_STACK_CONFIG IcaStackConfig;
    PPDCONFIG pPdConfig;
    NTSTATUS Status;
    ULONG cbReturned;
    ULONG i;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Initialize flag
     */
    *pfStackModified = FALSE;

    /*
     *  Wait for ICA Detect string from client
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_WAIT_FOR_ICA,
                                 NULL,
                                 0,
                                 &IcaStackConfig,
                                 sizeof(IcaStackConfig),
                                 &cbReturned );
    if ( !NT_SUCCESS(Status) ) {
        goto baddetect;
    }

    /*
     *  If ICA Detect returned any stack information, then update it
     */
    if ( cbReturned > 0 ) {

        ASSERT( FALSE );
#ifdef notdef

        /*
         *   this path has not been tested
         *
         *  Return configuration data
         *  -- skip transport driver (index 0)
         */
        for ( i = 0; i < (MAX_PDCONFIG-1); i++ ) {

            pPdConfig = &pWinStationConfig->Pd[i+1];

            memset( pPdConfig, 0, sizeof(PDCONFIG) );

            if ( IcaStackConfig.SdClass[i] == SdNone )
                break;

            pPdConfig->Create.SdClass = IcaStackConfig.SdClass[i];
            memcpy( pPdConfig->Create.PdDLL, IcaStackConfig.SdDLL[i], sizeof(DLLNAME) );
        }

        if ( IcaStackConfig.WdDLL[0] )
            memcpy( pWinStationConfig->Wd.WdDLL, IcaStackConfig.WdDLL, sizeof(DLLNAME) );

        /*
         *  Set modify flag
         */
        *pfStackModified = TRUE;
#endif
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaWaitForIca, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

baddetect:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaWaitForIca, 0x%x\n", Status ));
    return( Status );
}



/****************************************************************************
 *
 * _DecrementStackRef
 *
 *   decrement stack reference
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

void
_DecrementStackRef( IN PSTACK pStack )
{
    pStack->RefCount--;

    if ( pStack->RefCount == 1 && pStack->hUnloadEvent ) {
        SetEvent( pStack->hUnloadEvent );

    } else if ( pStack->RefCount == 0 && pStack->hCloseEvent ) {
        SetEvent( pStack->hCloseEvent );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\icaapi\icaapip.h ===
/*************************************************************************
* ICAAPIP.H
*
*  This module contains private ICA DLL defines and structures
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author:   Brad Pedersen (7/12/96)
*************************************************************************/


/*=============================================================================
==   Defines
=============================================================================*/

#ifdef DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg)
#endif

#if DBG
#undef TRACE
#undef TRACESTACK
#undef TRACECHANNEL
#define TRACE(_arg)         IcaTrace _arg
#define TRACESTACK(_arg)    IcaStackTrace _arg
#define TRACECHANNEL(_arg)  IcaChannelTrace _arg
#else
#define TRACE(_arg)
#define TRACESTACK(_arg)
#define TRACECHANNEL(_arg)
#endif


#define ICA_SD_MODULE_EXTENTION L".SYS"


/*=============================================================================
==   Typedefs
=============================================================================*/

typedef NTSTATUS (APIENTRY * PCDOPEN)( HANDLE, PPDCONFIG, PVOID * );
typedef NTSTATUS (APIENTRY * PCDCLOSE)( PVOID );
typedef NTSTATUS (APIENTRY * PCDIOCONTROL)( PVOID, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );

typedef NTSTATUS (APIENTRY * PSTACKIOCONTROLCALLBACK)( PVOID, PVOID, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );


/*=============================================================================
==   Semaphores
=============================================================================*/

/*
 *  Citrical section macros
 */
#define INITLOCK( _sem, _status ) { \
    _status = RtlInitializeCriticalSection( _sem ); \
    TRACE((hIca,TC_ICAAPI,TT_SEM,"INITLOCK: "#_sem"\n")); \
}
#define DELETELOCK( _sem ) { \
    RtlDeleteCriticalSection( _sem ); \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"DELETELOCK: "#_sem"\n")); \
}
#define LOCK( _sem ) { \
    ASSERTUNLOCK( _sem ); \
    RtlEnterCriticalSection( _sem ); \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"LOCK:   "#_sem"\n")); \
}
#define UNLOCK( _sem ) { \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"UNLOCK: "#_sem"\n")); \
    ASSERTLOCK( _sem ); \
    RtlLeaveCriticalSection( _sem ); \
}


#ifdef DBG
// (per JHavens) DWORD ThreadId is comparable to HANDLE OwningThread despite different sizes.
// Objects will still remain in <2GB address speace in Win64.


#define ASSERTLOCK(_sem) { ASSERT( LongToHandle(GetCurrentThreadId()) == (_sem)->OwningThread ); }
#define ASSERTUNLOCK(_sem) { ASSERT( LongToHandle(GetCurrentThreadId()) != (_sem)->OwningThread ); }

#else
#define ASSERTLOCK(_sem)
#define ASSERTUNLOCK(_sem)
#endif


/*=============================================================================
==   Structures
=============================================================================*/

/*
 *  Stack data structure
 */
typedef struct _STACK {

    /*
     *  Critical section protecting this structure and the
     *  connection driver
     */
    CRITICAL_SECTION CritSec;
    ULONG RefCount;
    HANDLE hUnloadEvent;
    HANDLE hCloseEvent;

    /*
     *  ICA Device driver stack handle
     */
    HANDLE hStack;

    /*
     *  Data for Connection Driver
     */
    HANDLE       hCdDLL;       // connection driver dll handle
    PVOID        pCdContext;   // pointer to connection driver context
    PCDOPEN      pCdOpen;      // pointer to connection driver open
    PCDCLOSE     pCdClose;     // pointer to connection driver close
    PCDIOCONTROL pCdIoControl; // pointer to connection driver IoControl

    ULONG fStackLoaded: 1;     // stack drivers are loaded
    ULONG fUnloading: 1;       // stack drivers are being unloaded
    ULONG fClosing: 1;         // stack is being closed

    PSTACKIOCONTROLCALLBACK pStackIoControlCallback;
    PVOID pCallbackContext;
} STACK, * PSTACK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\acpudefs.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter                                                        */
/*                                                                          */
/****************************************************************************/

#if defined(OS_WIN32) && !defined(DC_DEBUG) && defined(_M_IX86) && defined(PERF)
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter macros                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* variables used to store the count                                        */
/****************************************************************************/
#define MAX_FNS     12

/****************************************************************************/
/* Counter identifiers                                                      */
/****************************************************************************/
#define FC_MEM2SCRN_BITBLT      0
#define FC_DSTBLT_TYPE          1
#define FC_PATBLT_TYPE          2
#define FC_OPAQUERECT_TYPE      3
#define FC_SCRBLT_TYPE          4
#define FC_MEMBLT_TYPE          5
#define FC_LINETO_TYPE          6
#define FC_POLYLINE_TYPE        7
#define FC_INDEX_TYPE           8
#define FC_UHADDUPDATEREGION    9
#define FC_UHSETCLIPREGION      10
#define FC_UHPROCESSPALETTEPDU  11
#define FC_POLYGONSC_TYPE       12
#define FC_POLYGONCB_TYPE       13
#define FC_ELLIPSESC_TYPE       14
#define FC_ELLIPSECB_TYPE       15
#define FC_FAST_INDEX_TYPE      16
#define FC_FAST_GLYPH_TYPE      17

/****************************************************************************/
/* Routines to measure the count before and after                           */
/****************************************************************************/
#define TIMERSTART                     \
        {                              \
            unsigned long startHi;     \
            unsigned long startLo;     \
            unsigned long endHi;       \
            unsigned long endLo;       \
                                       \
            unsigned long timeLo;      \
            unsigned long timeHi;      \
                                       \
                                       \
            _asm mov eax,0             \
            _asm mov edx,0             \
                                       \
            _asm _emit 0Fh             \
            _asm _emit 31h             \
            _asm mov startHi, edx      \
            _asm mov startLo, eax      \

#define TIMERSTOP                      \
            _asm mov eax,0             \
            _asm mov edx,0             \
                                       \
            _asm _emit 0Fh             \
            _asm _emit 31h             \
            _asm mov endHi, edx        \
            _asm mov endLo, eax        \

#define UPDATECOUNTER(fn)                                       \
            callCount[fn]++;                                    \
                                                                \
            if (endLo < startLo)                                \
            {                                                   \
                timeLo = 0xFFFFFFFF - (startLo - endLo - 1);    \
                endHi--;                                        \
            }                                                   \
            else                                                \
            {                                                   \
                timeLo = endLo - startLo;                       \
            }                                                   \
                                                                \
            timeHi = endHi - startHi;                           \
                                                                \
            cycleCountLo[fn] = (unsigned long)(cycleCountLo[fn] + timeLo);\
                                                                \
            if (cycleCountLo[fn] < timeLo)                      \
            {                                                   \
                timeHi++;                                       \
            }                                                   \
                                                                \
            cycleCountHi[fn] += timeHi;                         \
        }

#define RESET_COUNTERS                         \
        {                                      \
            int idx;                           \
            for (idx = 0; idx < MAX_FNS; idx++)\
            {                                  \
                callCount[idx]    = 0;         \
                cycleCountHi[idx] = 0;         \
                cycleCountLo[idx] = 0;         \
            }                                  \
                                               \
            OutputDebugString(_T("Counters Reset\n"));   \
                                               \
        }                                      \

#define OUTPUT_COUNTERS                                                       \
        {                                                                     \
            int idx;                                                          \
            TCHAR result[80];                                                 \
            TCHAR fnNames[MAX_FNS][30] =                                      \
            {                                                                 \
              _T("BitmapRect sub order *"),                                   \
              _T("DSTBLT order"),                                             \
              _T("PATBLT order"),                                             \
              _T("OPAQUERECT order"),                                         \
              _T("SCRBLT order"),                                             \
              _T("MEMBLT order **"),                                          \
              _T("LINETO order **"),                                          \
              _T("POLYLINE order"),                                           \
              _T("INDEX (glyph) order *"),                                    \
              _T("UHAddUpdateRegion *"),                                      \
              _T("UHSetClipRegion *"),                                        \
              _T("UHProcessPalettePDU *"),                                    \
              _T("POLYGONSC order"),                                          \
              _T("POLYGONCB order"),                                          \
              _T("ELLIPSESC order"),                                          \
              _T("ELLIPSECB order"),                                          \
              _T("FASTINDEX order"),                                          \
              _T("FASTGLYPH order")                                       
            };                                                                \
                                                                              \
            OutputDebugString(_T("******************************************")\
                    _T("\n"));                                                \
            _stprintf(result, _T("%-29s %-6s %-12s %-12s\n"), _T("Operation"),\
                    _T("Hits"), _T("High cycles"), _T("Low cycles"));         \
                                                                              \
            OutputDebugString(result);                                        \
            for (idx = 0; idx < MAX_FNS; idx++)                               \
            {                                                                 \
                _stprintf(result, _T("%-29s %6lu %12lu %12lu\n"),             \
                       fnNames[idx], callCount[idx],                          \
                       cycleCountHi[idx], cycleCountLo[idx]);                 \
                OutputDebugString(result);                                    \
            }                                                                 \
            OutputDebugString(_T("******************************************")\
                    _T("\n"));                                                \
        }                                                                           \

#else

#define MAX_FNS
#define TIMERSTART
#define TIMERSTOP
#define UPDATECOUNTER(fn)

#define RESET_COUNTERS
#define OUTPUT_COUNTERS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgctyp.h ===
/**INC+**********************************************************************/
/* Header:    adcgctyp.h                                                    */
/*                                                                          */
/* Purpose:   Complex types - portable include file.                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ADCGCTYP.H_v  $
 *
 *    Rev 1.7   07 Aug 1997 14:33:46   MR
 * SFR1133: Persuade Wd to compile under C++
 *
 *    Rev 1.6   23 Jul 1997 10:47:54   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.5   10 Jul 1997 11:51:36   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ADCGCTYP
#define _H_ADCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include appropriate header files.                                        */
/****************************************************************************/
#ifndef __midl
#ifndef OS_WINCE
#include <time.h>
#endif // OS_WINCE
#endif

/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgctyp.h>

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DC-Share specific types.  Note that some of these are OS specific so     */
/* the actual type definition appears in an OS specific header.  However    */
/* the definition of the pointer to type is OS independant and therefore    */
/* appears in this file.                                                    */
/****************************************************************************/
typedef DCUINT32                       DCAPPID;
typedef DCUINT32                       DCWINID;
typedef DCUINT                         DCLOCALPERSONID;
typedef DCUINT                         DCNETPERSONID;
typedef DCUINT32                       DCENTITYID;

typedef DCAPPID              DCPTR     PDCAPPID;
typedef DCWINID              DCPTR     PDCWINID;
typedef DCLOCALPERSONID      DCPTR     PDCLOCALPERSONID;
typedef DCNETPERSONID        DCPTR     PDCNETPERSONID;
typedef DCENTITYID           DCPTR     PDCENTITYID;

typedef DCREGIONID           DCPTR     PDCREGIONID;
typedef DCPALID              DCPTR     PDCPALID;
typedef DCCURSORID           DCPTR     PDCCURSORID;
typedef DCHFONT              DCPTR     PDCHFONT;
typedef DCFILETIME           DCPTR     PDCFILETIME;
typedef DCHFILE              DCPTR     PDCHFILE;

typedef PDCACHAR                       PDCSTR;
typedef DCUINT                         ATRETCODE;
typedef PDCVOID                        SYSREGION;

typedef SYSRECT              DCPTR     PSYSRECT;
typedef SYSAPPID             DCPTR     PSYSAPPID;
typedef SYSWINID             DCPTR     PSYSWINID;
typedef SYSBITMAP            DCPTR     PSYSBITMAP;
typedef SYSBMIHEADER         DCPTR     PSYSBMIHEADER;
typedef SYSBMI               DCPTR     PSYSBMI;
typedef SYSPOINT             DCPTR     PSYSPOINT;
typedef SYSREGION            DCPTR     PSYSREGION;

/****************************************************************************/
/* Window and dialog procedure typedefs.                                    */
/****************************************************************************/
#if !defined(DLL_DISP) && !defined(DLL_WD)
typedef WNDPROC                        PDCWNDPROC;
typedef DLGPROC                        PDCDLGPROC;
#endif

typedef WPARAM                         DCPARAM1;
typedef LPARAM                         DCPARAM2;

/****************************************************************************/
/* Time typedefs.                                                           */
/****************************************************************************/
typedef time_t                         DC_LONGTIME;
typedef struct tm                      DC_TMTIME;

/****************************************************************************/
/*                                                                          */
/* STRUCTURES                                                               */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* RGBQUAD                                                                  */
/* =======                                                                  */
/* rgbBlue         : blue value.                                            */
/* rgbGreen        : green value.                                           */
/*                                                                          */
/* rgbRed          : red value.                                             */
/* rgbReserved     : reserved.                                              */
/****************************************************************************/
typedef struct tagDCRGBQUAD
{
    DCUINT8     rgbBlue;
    DCUINT8     rgbGreen;
    DCUINT8     rgbRed;
    DCUINT8     rgbReserved;
} DCRGBQUAD;
typedef DCRGBQUAD DCPTR PDCRGBQUAD;

/****************************************************************************/
/* DCRECT16                                                                 */
/* ========                                                                 */
/* This is an OS independant rectangle structure.                           */
/*                                                                          */
/* left            : left position.                                         */
/* top             : top position.                                          */
/* right           : right position.                                        */
/* bottom          : bottom position.                                       */
/****************************************************************************/
typedef struct tagDCRECT16
{
    DCINT16     left;
    DCINT16     top;
    DCINT16     right;
    DCINT16     bottom;
} DCRECT16;
typedef DCRECT16 DCPTR PDCRECT16;

/****************************************************************************/
/* DCRECT                                                                   */
/* ======                                                                   */
/* left            : left position.                                         */
/* top             : top position.                                          */
/* right           : right position.                                        */
/* bottom          : bottom position.                                       */
/****************************************************************************/
typedef struct tagDCRECT
{
    DCINT       left;
    DCINT       top;
    DCINT       right;
    DCINT       bottom;
} DCRECT;
typedef DCRECT DCPTR PDCRECT;

/****************************************************************************/
/* DCRGB                                                                    */
/* =====                                                                    */
/* red             : red value.                                             */
/* green           : green value.                                           */
/* blue            : blue value.                                            */
/****************************************************************************/
typedef struct tagDCRGB
{
    DCUINT8 red;
    DCUINT8 green;
    DCUINT8 blue;
} DCRGB;
typedef DCRGB DCPTR PDCRGB;

/****************************************************************************/
/* DCCOLOR                                                                  */
/* =======                                                                  */
/*                                                                          */
/* Union of DCRGB and an index into a color table                           */
/*                                                                          */
/****************************************************************************/
typedef struct tagDCCOLOR
{
    union
    {
        DCRGB   rgb;
        DCUINT8 index;
    } u;
} DCCOLOR;
typedef DCCOLOR DCPTR PDCCOLOR;

/****************************************************************************/
/* DCSIZE                                                                   */
/* ======                                                                   */
/* width           : x dimension.                                           */
/* height          : y dimension.                                           */
/****************************************************************************/
typedef struct tagDCSIZE
{
    DCUINT      width;
    DCUINT      height;
} DCSIZE;
typedef DCSIZE DCPTR PDCSIZE;

/****************************************************************************/
/* DCPOINT                                                                  */
/* =======                                                                  */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT
{
    DCINT       x;
    DCINT       y;
} DCPOINT;
typedef DCPOINT DCPTR PDCPOINT;

/****************************************************************************/
/* DCPOINT16                                                                */
/* =========                                                                */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT16
{
    DCINT16     x;
    DCINT16     y;
} DCPOINT16;
typedef DCPOINT16 DCPTR PDCPOINT16;

/****************************************************************************/
/* DCPOINT32                                                                */
/* =========                                                                */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT32
{
    DCINT32     x;
    DCINT32     y;
} DCPOINT32;
typedef DCPOINT32 DCPTR PDCPOINT32;

#ifndef __midl
/****************************************************************************/
/* BITMAPINFO_ours                                                          */
/* ===============                                                          */
/* bmiHeader       :                                                        */
/* bmiColors       :                                                        */
/****************************************************************************/
typedef struct tagBITMAPINFO_ours
{
    SYSBMIHEADER       bmiHeader;
    DCRGBQUAD          bmiColors[256];
} BITMAPINFO_ours;

/****************************************************************************/
/* BITMAPINFO_PLUS                                                          */
/* ===============                                                          */
/* bmiHeader       :                                                        */
/* bmiColors       :                                                        */
/****************************************************************************/
typedef struct tagBINFO_PLUS
{
    SYSBMIHEADER       bmiHeader;
    DCRGBQUAD          bmiColors[256];
} BITMAPINFO_PLUS_COLOR_TABLE;
#endif

/****************************************************************************/
/* DC_DATE                                                                  */
/* =======                                                                  */
/* day             : day of the month (1-31).                               */
/* month           : month (1-12).                                          */
/* year            : year (e.g. 1996).                                      */
/****************************************************************************/
typedef struct tagDC_DATE
{
    DCUINT8  day;
    DCUINT8  month;
    DCUINT16 year;
} DC_DATE;
typedef DC_DATE DCPTR PDC_DATE;

/****************************************************************************/
/* DC_TIME                                                                  */
/* =======                                                                  */
/* hour            : hour (0-23).                                           */
/* min             : minute (0-59).                                         */
/* sec             : seconds (0-59).                                        */
/* hundredths      : hundredths of a second (0-99).                         */
/****************************************************************************/
typedef struct tagDC_TIME
{
    DCUINT8  hour;
    DCUINT8  min;
    DCUINT8  sec;
    DCUINT8  hundredths;
} DC_TIME;
typedef DC_TIME DCPTR PDC_TIME;

/****************************************************************************/
/* Types of addresses supported by Groupware (these go in the <addressType> */
/* field of the DC_PERSON_ADDRESS structure):                               */
/****************************************************************************/
#define DC_ADDRESS_TYPE_NONE                   0
#define DC_ADDRESS_TYPE_NETBIOS                1
#define DC_ADDRESS_TYPE_IPXSPX                 2
#define DC_ADDRESS_TYPE_VIRTUAL_ASYNC          3
#define DC_ADDRESS_TYPE_MODEM                  4
#define DC_ADDRESS_TYPE_LIVELAN                5
#define DC_ADDRESS_TYPE_PCS100                 6

/****************************************************************************/
/* This is the max number of addresses the address book will store for      */
/* one person:                                                              */
/****************************************************************************/
#define DC_MAX_ADDRESSES_PER_PERSON         6

/****************************************************************************/
/* These constants define the maximum length of person names and addresses  */
/* supported by the Address Book.                                           */
/****************************************************************************/
#define DC_MAX_NAME_LEN       48    /* for general purpose names            */
                                    /* (includes the nul term)              */
#define DC_MAX_ADDR_DATA_LEN  48    /* for general purpose addresses        */
                                    /* this may be binary data              */

/****************************************************************************/
/* Defines the maximum number of BYTES allowed in a translated "shared by " */
/* string.                                                                  */
/****************************************************************************/
#define DC_MAX_SHARED_BY_BUFFER     64
#ifdef DESKTOPSHARING
#define DC_MAX_SHAREDDESKTOP_BUFFER 64
#endif /*DESKTOPSHARING*/

/****************************************************************************/
/* Address for a specific transport type:                                   */
/****************************************************************************/
typedef struct tagDC_PERSON_ADDRESS
{
    DCUINT16      addressType;                    /* N'bios, async, IPX...  */
    DCUINT16      addressLen;                     /* length of <addressData>*/
    DCACHAR       addressData[DC_MAX_ADDR_DATA_LEN];   /* TDD specific data */
} DC_PERSON_ADDRESS;
typedef DC_PERSON_ADDRESS DCPTR PDC_PERSON_ADDRESS;

/****************************************************************************/
/* General purpose address holder                                           */
/****************************************************************************/
typedef struct tagDC_PERSON
{
    DCACHAR                  name[DC_MAX_NAME_LEN];

                                 /* textual name - displayed to user        */
                                 /* (must be NULL-terminated).              */

    DC_PERSON_ADDRESS        address[DC_MAX_ADDRESSES_PER_PERSON];

                                 /* array of addresses for this person      */
} DC_PERSON;
typedef DC_PERSON DCPTR PDC_PERSON;

#endif /* _H_ADCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgcnst.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* adcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - portable include file.                   */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/adcgcnst.h_v  $
//
//    Rev 1.7   05 Sep 1997 15:52:12   KH
// SFR1346: Define user message constants
//
//    Rev 1.6   20 Aug 1997 10:29:44   NL
// SFR1312: add DCS_RC_BUSY
//
//    Rev 1.5   15 Aug 1997 16:13:24   OBK
// SFR1133: Kernelisation: remove unused constants
//
//    Rev 1.4   06 Aug 1997 10:41:00   AK
// SFR1016: Complete removal of DCCHAR etc
//
//    Rev 1.3   23 Jul 1997 10:47:52   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:44:18   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/

/****************************************************************************/
/* CONTENTS                                                                 */
/* ========                                                                 */
/* This file contains constants for all:                                    */
/*                                                                          */
/* - names of shared memory blocks, locks and files                         */
/* - base and limit values by component for return values and events        */
/*                                                                          */
/* used by DC-Groupware components.                                         */
/*                                                                          */
/* The rationale for this file is to make it easier to detect name clashes  */
/* between components.  Therefore, even if you don't expect anyone else to  */
/* use your mutex, file, etc., you MUST include its name in here to ensure  */
/* that it doesn't happen inadvertently.                                    */
/****************************************************************************/
#ifndef _H_ADCGCNST
#define _H_ADCGCNST

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgcnst.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Give numbers to our operating systems.                                   */
/****************************************************************************/
#define WIN_31                         1
#define MAC_S7                         3
#define WIN_95                         4
#define WIN_95_32                      5
#define WIN_NT                         6

/****************************************************************************/
/* Limits                                                                   */
/****************************************************************************/
#define MAX_DCUINT16                   65535

/****************************************************************************/
/* Drive and directory separators.                                          */
/****************************************************************************/
#define DC_MAX_PATH                    MAX_PATH

/****************************************************************************/
/* Return codes                                                             */
/* ============                                                             */
/* This section lists the ranges available for each component when defining */
/* its return codes.  A component must not define return codes outside its  */
/* permitted range.  The following ranges are currently defined:            */
/*                                                                          */
/* 0x0b00 - 0x0bFF : Share programming                                      */
/* 0x0f00 - 0x0fFF : Common functions                                       */
/* 0x1100 - 0x11FF : Trace functions                                        */
/*                                                                          */
/****************************************************************************/

#define SPI_BASE_RC                    ((DCUINT16) 0x0B00)
#define SPI_LAST_RC                    ((DCUINT16) 0x0BFF)

#define COM_BASE_RC                    ((DCUINT16) 0x0F00)
#define COM_LAST_RC                    ((DCUINT16) 0x0FFF)

#define TRC_BASE_RC                    ((DCUINT16) 0x1000)
#define TRC_LAST_RC                    ((DCUINT16) 0x10FF)

/****************************************************************************/
/* DC-Share return codes                                                    */
/* =====================                                                    */
/* These codes are intended to be very specific, such that the error code   */
/* (when in the trace log) clearly identifies the specific class of error,  */
/* as follows:                                                              */
/*                                                                          */
/* DCS_RC_OK             : OK                                               */
/* DCS_RC_ERR_LOGIC      : DC-Share internal logic                          */
/* DCS_RC_ERR_PARAM      : DC-Share internal parameter error                */
/* DCS_RC_ERR_MEMORY     : allocating memory                                */
/* DCS_RC_ERR_MEMLOCK    : locking memory                                   */
/* DCS_RC_ERR_STRING     : loading strings from resources                   */
/* DCS_RC_ERR_LOADBITMAP : loading bitmaps or icons from resources          */
/* DCS_RC_ERR_PROCADDR   : getting a proc address                           */
/* DCS_RC_ERR_WINDOW     : creating/registering Windows windows/classes     */
/* DCS_RC_ERR_HOOK       : setting a Windows hook                           */
/* DCS_RC_ERR_MSGQUEUE   : creating/manipulating Windows message queues     */
/* DCS_RC_ERR_BITMAP     : creating a Windows bitmap                        */
/* DCS_RC_ERR_DC         : creating/querying Windows DCs                    */
/* DCS_RC_ERR_OBJECT     : creating Windows objects (eg Palettes, Pens, ...)*/
/* DCS_RC_ERR_MMTIMER    : initialising multimedia timer                    */
/*                                                                          */
/****************************************************************************/
#define DC_RC_OK                       ((DCUINT16) 0)
#define DCS_RC_OK                      0
#define DCS_RC_ERR_LOGIC               2
#define DCS_RC_ERR_PARAM               3
#define DCS_RC_ERR_MEMORY              4
#define DCS_RC_ERR_MEMLOCK             5
#define DCS_RC_ERR_STRING              6
#define DCS_RC_ERR_LOADBITMAP          7
#define DCS_RC_ERR_PROCADDR            8
#define DCS_RC_ERR_WINDOW              9
#define DCS_RC_ERR_HOOK                10
#define DCS_RC_ERR_MSGQUEUE            11
#define DCS_RC_ERR_BITMAP              12
#define DCS_RC_ERR_DC                  13
#define DCS_RC_ERR_OBJECT              14
#define DCS_RC_ERR_MMTIMER             15
#define DCS_RC_FAIL_GENERAL            16
#define DCS_RC_FAIL_RESOURCE           17
#define DCS_RC_BUSY                    18

/****************************************************************************/
/* Shared memory block names                                                */
/* =========================                                                */
/* This section lists the shared memory block names used by each component. */
/****************************************************************************/

/****************************************************************************/
/* INI file section names for each of the DC-Groupware components.          */
/****************************************************************************/
#define TRC_INI_SECTION_NAME           _T("Trace")

#define DCS_INI_SECTION_NAME           L"Share"
#define PRI_INI_SECTION_NAME           L"PropertyIndex"
#define PRD_INI_SECTION_NAME           L"PropertyDefault"
#define PRO_INI_SECTION_NAME           L"PropertyOverride"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_HWND                      ((HWND)0)
#define NULL_DCWINID                   ((DCWINID)0)
#define NULL_DCAPPID                   ((DCAPPID)0)
#define NULL_DCPALID                   ((DCPALID)0)
#define NULL_DCREGIONID                ((DCREGIONID)0)

/****************************************************************************/
/* Win3.1 doesn't have WM_APP, so we define it here to be well separated    */
/* from WM_USER. As long as it's less than 0x8000, we're OK.                */
/****************************************************************************/
#ifdef OS_WIN16
#define WM_APP WM_USER+0x1000
#endif

/****************************************************************************/
/* User defined messages.                                                   */
/****************************************************************************/
#define DUC_TD_MESSAGE_BASE  (WM_APP + 0)
#define DUC_CD_MESSAGE_BASE  (WM_APP + 10)
#define DUC_UI_MESSAGE_BASE  (WM_APP + 20)
#define DUC_CO_MESSAGE_BASE  (WM_APP + 30)

#endif /* _H_ADCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgcfnc.h ===
/**INC+**********************************************************************/
/* Header:    adcgcfnc.h                                                    */
/*                                                                          */
/* Purpose:   C runtime functions - portable include file                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/adcgcfnc.h_v  $
 * 
 *    Rev 1.7   06 Aug 1997 14:32:22   AK
 * SFR1016: Apply Markups
 *
 *    Rev 1.6   06 Aug 1997 10:40:42   AK
 * SFR1016: Complete removal of DCCHAR etc
 *
 *    Rev 1.5   23 Jul 1997 10:47:52   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.4   15 Jul 1997 15:42:48   AK
 * SFR1016: Add Unicode support
 *
 *    Rev 1.3   09 Jul 1997 16:56:24   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ADCGCFNC
#define _H_ADCGCFNC

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the required C headers                                           */
/****************************************************************************/
#ifndef OS_WINCE
#include <stdio.h>
#endif // OS_WINCE
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#ifndef OS_WINCE
#include <time.h>
#endif // OS_WINCE
/****************************************************************************/
/* Include the Windows-specific header.                                     */
/****************************************************************************/
#include <wdcgcfnc.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Character Class Tests (normally in ctype.h)                              */
/* =====================                                                    */
/* In these definitions:                                                    */
/*                                                                          */
/*    'C' is of type DCINT.                                                 */
/*                                                                          */
/* These functions return a DCBOOL.                                         */
/****************************************************************************/
#define DC_ISALNUM(C)                  isalnum(C)
#define DC_ISALPHA(C)                  isalpha(C)
#define DC_ISCNTRL(C)                  iscntrl(C)
#define DC_ISDIGIT(C)                  isdigit(C)
#define DC_ISGRAPH(C)                  isgraph(C)
#define DC_ISLOWER(C)                  islower(C)
#define DC_ISPRINT(C)                  isprint(C)
#define DC_ISPUNCT(C)                  ispunct(C)
#define DC_ISSPACE(C)                  isspace(C)
#define DC_ISUPPER(C)                  isupper(C)
#define DC_ISXDIGIT(C)                 isxdigit(C)

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_TOLOWER(C)                  tolower(C)
#ifdef OS_WINCE
#define DC_TOUPPER(C)                  towupper(C)
#else // OS_WINCE
#define DC_TOUPPER(C)                  toupper(C)
#endif // OS_WINCE

/****************************************************************************/
/* Memory functions (from string.h)                                         */
/* ================                                                         */
/* In these definitions:                                                    */
/*    'S' and 'T' are of type PDCVOID.                                      */
/*    'CS' and 'CT' are of type (constant) PDCVOID.                         */
/*    'N' is of type DCINT.                                                 */
/*    'C' is an DCINT converted to DCACHAR.                                 */
/****************************************************************************/
/****************************************************************************/
/* These functions return a PDCVOID.                                        */
/****************************************************************************/
#define DC_MEMCPY(S, CT, N)            memcpy(S, CT, N)
#define DC_MEMMOVE(S, CT, N)           memmove(S, CT, N)
#define DC_MEMSET(S, C, N)             memset(S, C, N)

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_MEMCMP(CS, CT, N)           memcmp(CS, CT, N)

/****************************************************************************/
/* Utility functions (from stdlib.h)                                        */
/* =================                                                        */
/* In these defintions:                                                     */
/*    'CS' is of type (constant) PDCACHAR.                                  */
/*    'N' is of type DCINT.                                                 */
/*    'L' is of type DCINT32                                                */
/****************************************************************************/

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_ABS(N)                      abs(N)

/****************************************************************************/
/* These functions return a DCINT32.                                        */
/****************************************************************************/
#define DC_ATOL(CS)                    atol(CS)
#define DC_LABS(L)                     labs(L)

/****************************************************************************/
/* The maximum characters DC_?ITOA will convert into plus one for a         */
/* NULLTERM (see C library documentation).                                  */
/****************************************************************************/
#define MAX_ITOA_LENGTH 18

#endif /* _H_ADCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgbtyp.h ===
/****************************************************************************/
/* adcgbtyp.h                                                               */
/*                                                                          */
/* Basic types - portable                                                   */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/
#ifndef _H_ADCGBTYP
#define _H_ADCGBTYP


/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgbtyp.h>


/****************************************************************************/
/* Basic types abstracted from compiler built ins.                          */
/****************************************************************************/
#ifdef OS_WIN16
typedef short INT16;
typedef unsigned short UINT16;
typedef long INT32;
typedef unsigned long UINT32;
#define UNALIGNED
#endif

typedef unsigned long UNALIGNED FAR *PUINT32_UA;
typedef unsigned short UNALIGNED FAR *PUINT16_UA;
typedef UINT32 *PUINT32;


typedef int                            DCINT;
typedef signed char                    DCINT8;
typedef long                           DCINT32;

typedef unsigned int                   DCUINT;
typedef unsigned char                  DCUINT8;
typedef unsigned long                  DCUINT32;

#ifdef __midl
typedef long                           DCVOID;
#else
typedef void                           DCVOID;
#endif

typedef DCUINT                         DCBOOL;
typedef DCUINT16                       DCBOOL16;
typedef DCUINT32                       DCBOOL32;

typedef unsigned short UINT16;

#ifdef OS_WIN16
typedef unsigned long  UINT32;
#endif


/****************************************************************************/
/* Now derive further convenience types from system specific types.         */
/* First of all pointers to types.                                          */
/****************************************************************************/
typedef DCINT                DCPTR     PDCINT;
typedef DCINT8               DCPTR     PDCINT8;
typedef DCINT16              DCPTR     PDCINT16;
typedef DCINT32              DCPTR     PDCINT32;

typedef DCUINT               DCPTR     PDCUINT;
typedef DCUINT8              DCPTR     PDCUINT8;
typedef DCUINT16             DCPTR     PDCUINT16;
typedef DCUINT32             DCPTR     PDCUINT32;

typedef DCBOOL               DCPTR     PDCBOOL;
typedef DCBOOL16             DCPTR     PDCBOOL16;
typedef DCBOOL32             DCPTR     PDCBOOL32;
typedef DCVOID               DCPTR     PDCVOID;

/****************************************************************************/
/* Now define pointers to pointers of types.                                */
/****************************************************************************/
typedef PDCINT               DCPTR     PPDCINT;
typedef PDCINT8              DCPTR     PPDCINT8;
typedef PDCINT16             DCPTR     PPDCINT16;
typedef PDCINT32             DCPTR     PPDCINT32;

typedef PDCUINT              DCPTR     PPDCUINT;
typedef PDCUINT8             DCPTR     PPDCUINT8;
typedef PDCUINT16            DCPTR     PPDCUINT16;
typedef PDCUINT32            DCPTR     PPDCUINT32;

typedef PDCBOOL              DCPTR     PPDCBOOL;
typedef PDCBOOL16            DCPTR     PPDCBOOL16;
typedef PDCBOOL32            DCPTR     PPDCBOOL32;
typedef PDCVOID              DCPTR     PPDCVOID;

/****************************************************************************/
/* Define huge pointers to basic types.                                     */
/****************************************************************************/
typedef DCINT                DCHPTR    HPDCINT;
typedef DCINT8               DCHPTR    HPDCINT8;
typedef DCINT16              DCHPTR    HPDCINT16;
typedef DCINT32              DCHPTR    HPDCINT32;

typedef DCUINT               DCHPTR    HPDCUINT;
typedef DCUINT8              DCHPTR    HPDCUINT8;
typedef DCUINT16             DCHPTR    HPDCUINT16;
typedef DCUINT32             DCHPTR    HPDCUINT32;

typedef DCBOOL               DCHPTR    HPDCBOOL;
typedef DCBOOL16             DCHPTR    HPDCBOOL16;
typedef DCBOOL32             DCHPTR    HPDCBOOL32;
typedef DCVOID               DCHPTR    HPDCVOID;

/****************************************************************************/
/* Define pointers to huge pointers to types.                               */
/****************************************************************************/
typedef HPDCINT              DCPTR     PHPDCINT;
typedef HPDCINT8             DCPTR     PHPDCINT8;
typedef HPDCINT16            DCPTR     PHPDCINT16;
typedef HPDCINT32            DCPTR     PHPDCINT32;

typedef HPDCUINT             DCPTR     PHPDCUINT;
typedef HPDCUINT8            DCPTR     PHPDCUINT8;
typedef HPDCUINT16           DCPTR     PHPDCUINT16;
typedef HPDCUINT32           DCPTR     PHPDCUINT32;

typedef HPDCBOOL             DCPTR     PHPDCBOOL;
typedef HPDCBOOL16           DCPTR     PHPDCBOOL16;
typedef HPDCBOOL32           DCPTR     PHPDCBOOL32;
typedef HPDCVOID             DCPTR     PHPDCVOID;

/****************************************************************************/
/* Define unaligned pointers to types.                                      */
/****************************************************************************/
typedef DCINT    DCUNALIGNED DCPTR     PDCINT_UA;
typedef DCINT8   DCUNALIGNED DCPTR     PDCINT8_UA;
typedef DCINT16  DCUNALIGNED DCPTR     PDCINT16_UA;
typedef DCINT32  DCUNALIGNED DCPTR     PDCINT32_UA;

typedef DCUINT   DCUNALIGNED DCPTR     PDCUINT_UA;
typedef DCUINT8  DCUNALIGNED DCPTR     PDCUINT8_UA;
typedef DCUINT16 DCUNALIGNED DCPTR     PDCUINT16_UA;
typedef DCUINT32 DCUNALIGNED DCPTR     PDCUINT32_UA;

typedef DCBOOL   DCUNALIGNED DCPTR     PDCBOOL_UA;
typedef DCBOOL16 DCUNALIGNED DCPTR     PDCBOOL16_UA;
typedef DCBOOL32 DCUNALIGNED DCPTR     PDCBOOL32_UA;
typedef DCVOID   DCUNALIGNED DCPTR     PDCVOID_UA;

/****************************************************************************/
/* MCS/GCC use enumerations - we pretend they're longs                      */
/****************************************************************************/
typedef unsigned long                  DC_ENUM;


#if defined(OS_WIN16) || defined(OS_WINCE)
/****************************************************************************/
// Win16 types corresponding to new Win64/Win32 definitions.
/****************************************************************************/
typedef int INT_PTR;  // For dialog proc returns.
typedef unsigned UINT_PTR;  // On Win16 this is not exchangeable w/FAR *.
typedef long LONG_PTR;
typedef unsigned long ULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
#endif  // OS_WIN16


#endif /* _H_ADCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\aducdefs.h ===
/**INC+**********************************************************************/
/* Header:  aduxdefs.h                                                      */
/*                                                                          */
/* Purpose: Optional defines used in the client                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/inc/aducdefs.h_v  $
 *
 *    Rev 1.1   24 Sep 1997 14:29:30   AK
 * SFR1424: Rename adcgdefs.h for client
**/
/**INC-**********************************************************************/
#ifndef _H_ADUCDEFS
#define _H_ADUCDEFS

/****************************************************************************/
/* This header contains a list of all the optional defines used throughout  */
/* the project.  To compile-in some optionally defined code, enable the     */
/* appropriate option here.  Note that:                                     */
/*                                                                          */
/*  - all defines must be declared and documented here.  This is enforced   */
/*    by moans.                                                             */
/*  - the list must be sorted alphabetically.  This makes it easy to spot   */
/*    duplicate defines.                                                    */
/****************************************************************************/

/****************************************************************************/
/* DC_ANSI_TEXT_ORDERS enables support for encoded text orders where the    */
/* characters are in ANSI format.                                           */
/****************************************************************************/
#ifndef OS_WINCE
#define DC_ANSI_TEXT_ORDERS
#endif // OS_WINCE

/****************************************************************************/
/* DC_LATENCY enables the latency test code in UH and OP.  This code        */
/* generates a dummy key press (of the Ctrl key) whenever a large piece of  */
/* drawing is done.  This allows the client processing time for a single    */
/* key stroke to be accurately measured using a network sniffer (e.g.       */
/* NetMon).  In a typical situation Notepad is running in a remote session  */
/* (no other apps are running in the session) and the following occurs:     */
/*                                                                          */
/*  - Notepad has the focus on the client.                                  */
/*  - Press a key.                                                          */
/*  - Key-press is packaged by the client and sent on the wire.             */
/*  - Server interprets packet and injects the key-press.                   */
/*  - Notepad does some processing which results in a character being       */
/*    drawn on the screen.                                                  */
/*  - Server detects this drawing, packages it and sends it on the wire.    */
/*  - Client receives update packets and processes them.                    */
/*  - The drawing operation results in a dummy key-press being generated.   */
/*  - Dummy key-press is packaged by the client and sent on the wire.       */
/*                                                                          */
/* The time between the first update packet arriving and the dummy          */
/* key-press being sent is the total client processing time for a           */
/* key-press.                                                               */
/****************************************************************************/
#undef DC_LATENCY
/* #define DC_LATENCY */

/****************************************************************************/
/* DC_LOOPBACK enables the NL loopback testing code.  This stresses the     */
/* network layer by attempting to send a continual stream of packets with   */
/* incrementing size.  The equivalent code on the server detects loopback   */
/* packets and reflects them straight back to the client where they are     */
/* compared to ensure that they have not been corrupted by the round trip.  */
/****************************************************************************/
#undef DC_LOOPBACK
/* #define DC_LOOPBACK */

/****************************************************************************/
/* Code within DC_NLTEST is used solely for testing the network layer.  It  */
/* consists of:                                                             */
/*                                                                          */
/*  - a modification to TD_Recv so that it only ever tries to retrieve a    */
/*    single byte from WinSock regardless of the amount of data that the    */
/*    caller to TD_Recv asks for.  This stresses the common failure path    */
/*    within NL where processing of a packet has to be temporarily          */
/*    suspended until more data arrives.                                    */
/*  - random failure of NL_GetBuffer.  This stresses the whole of the       */
/*    client by simulating network layer back-pressure.                     */
/*                                                                          */
/****************************************************************************/
#undef DC_NLTEST
/* #define DC_NLTEST */

/****************************************************************************/
/* DC_SERVER_ORDERS_ONLY compiles the client using just the T.128 orders    */
/* that the server sends (i.e. removes unused T.128 orders).                */
/****************************************************************************/
/* #undef DC_SERVER_ORDERS_ONLY */
#define DC_SERVER_ORDERS_ONLY

/****************************************************************************/
/* Defining DC_PERF enables the timing code which enables the time spent    */
/* in several key functions to be easily determined.                        */
/****************************************************************************/
#undef DC_PERF
/* #define DC_PERF */

/****************************************************************************/
/* Defining SL_UNICODE_PROTOCOL enables code to send security package names */
/* in Unicode, rather than ANSI, format.                                    */
/****************************************************************************/
#undef SL_UNICODE_PROTOCOL
/* #define SL_UNICODE_PROTOCOL */

/****************************************************************************/
/* The following flags are defined elsewehere - for example in the build    */
/* scripts.  They are placed here to enable moans to detect legal defines - */
/* the moans use '/* FLAG:' to find these names.                            */
/*                                                                          */
/* FLAG: OS_WIN16                                                           */
/* - flag to indicate a Win16 build                                         */
/*                                                                          */
/* FLAG: OS_WIN32                                                           */
/* - flag to indicate a Win32 build                                         */
/*                                                                          */
/* FLAG: OS_WINDOWS                                                         */
/* - flag to indicate a Windows build                                       */
/*                                                                          */
/* FLAG: DC_DEBUG                                                           */
/* - flag to indicate a debug build                                         */
/*                                                                          */
/* FLAG: DC_DEFINE_GLOBAL_DATA                                              */
/* - used in aglobal.c to define global data                                */
/*                                                                          */
/* FLAG: UNICODE                                                            */
/* - Windows Unicode option                                                 */
/*                                                                          */
/* FLAG: HIPROF                                                             */
/* - HiProf profiler build                                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* The following flags are used in the server code.                         */
/* FLAG: CH_NO_COUNT                                                        */
/* FLAG: COMP_STATS                                                         */
/* FLAG: DC_FIXED_CODE_MODULE                                               */
/* FLAG: DC_INCLUDE_DATA                                                    */
/* FLAG: DC_INCL_PROTOTYPES                                                 */
/* FLAG: DC_INCL_TYPEDEFS                                                   */
/* FLAG: DC_INIT_DATA                                                       */
/* FLAG: DEBUG_EVICTION_LIST                                                */
/* FLAG: DIAGNOSE_BOUNDS                                                    */
/* FLAG: DITHER_MONO_CURSORS                                                */
/* FLAG: DLL_COREP                                                          */
/* FLAG: DLL_DISP                                                           */
/* FLAG: DLL_WD                                                             */
/* FLAG: GIN_ACCEPT_INVITES                                                 */
/* FLAG: HYDRA                                                              */
/* FLAG: NOT_SERVICE                                                        */
/* FLAG: ORDER_TRACE                                                        */
/* FLAG: QUERY_THROUGHPUT                                                   */
/* FLAG: RC_INVOKED                                                         */
/* FLAG: REMOVE_LINEAR                                                      */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: TRC_ENABLE_ALT                                                     */
/* FLAG: TRC_ENABLE_DBG                                                     */
/* FLAG: TRC_ENABLE_NRM                                                     */
/* FLAG: TRC_GROUP                                                          */
/* FLAG: TRC_TEST_LEVEL                                                     */
/* FLAG: V1_COMPRESSION                                                     */
/* FLAG: VER_APPSERV                                                        */
/* FLAG: VER_CPP                                                            */
/* FLAG: __cplusplus                                                        */
/* FLAG: USE_HET                                                            */
/* FLAG: USE_DS                                                             */
/* FLAG: USE_AWC                                                            */
/* FLAG: USE_FULL_CA                                                        */
/* FLAG: CA_MULTIPLE_CLIENTS                                                */
/*                                                                          */
/****************************************************************************/

#endif /* _H_ADUCDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgmcro.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* adcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - portable include file.                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/adcgmcro.h_v  $
// 
//    Rev 1.9   22 Aug 1997 10:34:52   MD
// SFR1162: Retire DC_LOCAL_TO_WIRE16
//
//    Rev 1.8   24 Jul 1997 16:48:28   KH
// SFR1033: Add DCMAKEDCUINT16
//
//    Rev 1.7   23 Jul 1997 10:47:56   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.2   30 Jun 1997 15:23:52   OBK
// SFR0000: Fix erroneous DCHI8 macro
//
//    Rev 1.1   19 Jun 1997 21:45:40   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_ADCGMCRO
#define _H_ADCGMCRO

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the Windows header.  This will then include the appropriate      */
/* specific header (Win31, Win NT, etc).                                    */
/****************************************************************************/
#include <wdcgmcro.h>

/****************************************************************************/
/*                                                                          */
/* STRUCTURES                                                               */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DC_ID_STAMP2                                                             */
/* ============                                                             */
/* This is used by the stamp macros below.                                  */
/*                                                                          */
/* component       :                                                        */
/* structure       :                                                        */
/* instance        :                                                        */
/****************************************************************************/
typedef struct tagDC_ID_STAMP2
{
    DCUINT16    component;
    DCUINT16    structure;
    DCUINT32    instance;
} DC_ID_STAMP2;
typedef DC_ID_STAMP2 DCPTR PDC_ID_STAMP2;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Common function macros used throughout the product.                      */
/****************************************************************************/
#define DC_QUIT                        goto DC_EXIT_POINT
#define DC_QUIT_ON_FAIL(hr)     if (FAILED(hr)) DC_QUIT;

/****************************************************************************/
/* New function entry/exit macros.                                          */
/****************************************************************************/
#define DC_BEGIN_FN(str)               TRC_FN(str); TRC_ENTRY;
#define DC_END_FN()                    TRC_EXIT;

/****************************************************************************/
/* Conversion macros.                                                       */
/****************************************************************************/
#define DCMAKEDCUINT32(lo16, hi16) ((DCUINT32)(((DCUINT16)(lo16)) |         \
                                     (((DCUINT32)((DCUINT16)(hi16))) << 16)))
#define DCMAKEDCUINT16(lowByte, highByte)                                   \
                            ((DCUINT16)(((DCUINT8)(lowByte)) |              \
                            (((DCUINT16)((DCUINT8)(highByte))) << 8)))

#define DCLO16(u32)  ((DCUINT16)((u32) & 0xFFFF))
#define DCHI16(u32)  ((DCUINT16)((((DCUINT32)(u32)) >> 16) & 0xFFFF))
#define DCLO8(w)     ((DCUINT8)((w) & 0xFF))
#define DCHI8(w)     ((DCUINT8)(((DCUINT16)(w) >> 8) & 0xFF))

/****************************************************************************/
/* Macro to round up a number to the nearest multiple of four.              */
/****************************************************************************/
#define DC_ROUND_UP_4(x)  ((x + 3) & ~((DCUINT32)0X03))

/****************************************************************************/
/* PAD macro - use it to add X pad bytes to a structure.                    */
/*                                                                          */
/* Can only be used once per structure.                                     */
/****************************************************************************/
#define DCPAD(X)                       DCINT8 padBytes[X]

/****************************************************************************/
/* Byte swapping macros for different endian architectures.                 */
/*                                                                          */
/*   DC_xx_WIRExx          converts in a functional form                    */
/*   DC_xx_WIRExx_INPLACE  converts a given field (must be an lvalue)       */
/*                                                                          */
/* Note that these macros require aligned access.  See below for unaligned  */
/* access macros.                                                           */
/*                                                                          */
/* Note that on bigendian machines DC_{TO,FROM}_WIRE16 casts to a DCUINT16. */
/* In code of the form                                                      */
/*     B = DC_{TO,FROM}_WIRE16(A)                                           */
/* there is an implicit cast to the type of B.  So if A is a DCINT16 and is */
/* negative, and B has > 16 bits, then B will end up being large and        */
/* positive.  It is therefore necessary to add a cast to a DCINT16.         */
/*                                                                          */
/****************************************************************************/
#ifndef DC_BIGEND

#define DC_TO_WIRE16(A)                (A)
#define DC_TO_WIRE32(A)                (A)
#define DC_FROM_WIRE16(A)              (A)
#define DC_FROM_WIRE32(A)              (A)
#define DC_TO_WIRE16_INPLACE(A)
#define DC_TO_WIRE32_INPLACE(A)
#define DC_FROM_WIRE16_INPLACE(A)
#define DC_FROM_WIRE32_INPLACE(A)

#else

#define DC_TO_WIRE16(A)                                                     \
                      (DCUINT16) (((DCUINT16)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT16)(((PDCUINT8)&(A))[0])))
#define DC_FROM_WIRE16(A)                                                   \
                      (DCUINT16) (((DCUINT16)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT16)(((PDCUINT8)&(A))[0])))
#define DC_TO_WIRE32(A)                                                     \
                      (DCUINT32) (((DCUINT32)(((PDCUINT8)&(A))[3]) << 24)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[2]) << 16)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[0])))
#define DC_FROM_WIRE32(A)                                                   \
                      (DCUINT32) (((DCUINT32)(((PDCUINT8)&(A))[3]) << 24)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[2]) << 16)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[0])))

#define DC_TO_WIRE16_INPLACE(A)        (A) = DC_TO_WIRE16(A)
#define DC_TO_WIRE32_INPLACE(A)        (A) = DC_TO_WIRE32(A)
#define DC_FROM_WIRE16_INPLACE(A)      (A) = DC_FROM_WIRE16(A)
#define DC_FROM_WIRE32_INPLACE(A)      (A) = DC_FROM_WIRE32(A)

#endif

/****************************************************************************/
/* Unaligned pointer access macros -- first macros to extract an integer    */
/* from an unaligned pointer.  Note that these macros assume that the       */
/* integer is in local byte order                                           */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_EXTRACT_UINT16_UA(pA)      (*(PDCUINT16_UA)(pA))
#define DC_EXTRACT_INT16_UA(pA)       (*(PDCINT16_UA)(pA))
#define DC_EXTRACT_UINT32_UA(pA)      (*(PDCUINT32_UA)(pA))
#define DC_EXTRACT_INT32_UA(pA)       (*(PDCINT32_UA)(pA))

#else

#ifndef DC_BIGEND
#define DC_EXTRACT_UINT16_UA(pA) ((DCUINT16)  (((PDCUINT8)(pA))[0]) |        \
                                  (DCUINT16) ((((PDCUINT8)(pA))[1]) << 8) )

#define DC_EXTRACT_INT16_UA(pA)  ((DCINT16)   (((PDCUINT8)(pA))[0]) |        \
                                  (DCINT16)  ((((PDCUINT8)(pA))[1]) << 8) )

#define DC_EXTRACT_UINT32_UA(pA) ((DCUINT32)  (((PDCUINT8)(pA))[0])        | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[1]) << 8)  | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[2]) << 16) | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[3]) << 24) )

#define DC_EXTRACT_INT32_UA(pA)  ((DCINT32)   (((PDCUINT8)(pA))[0])        | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[1]) << 8)  | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[2]) << 16) | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[3]) << 24) )
#else
#define DC_EXTRACT_UINT16_UA(pA) ((DCUINT16)  (((PDCUINT8)(pA))[1]) |        \
                                  (DCUINT16) ((((PDCUINT8)(pA))[0]) << 8) )

#define DC_EXTRACT_INT16_UA(pA)  ((DCINT16)   (((PDCUINT8)(pA))[1]) |        \
                                  (DCINT16)  ((((PDCUINT8)(pA))[0]) << 8) )

#define DC_EXTRACT_UINT32_UA(pA) ((DCUINT32)  (((PDCUINT8)(pA))[3])        | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[2]) << 8)  | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[1]) << 16) | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[0]) << 24) )

#define DC_EXTRACT_INT32_UA(pA)  ((DCINT32)   (((PDCUINT8)(pA))[3])        | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[2]) << 8)  | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[1]) << 16) | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[0]) << 24) )
#endif

#endif

/****************************************************************************/
/* Now macros to insert an integer at an unaligned pointer value.  Again,   */
/* the value inserted will be in local format.                              */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_INSERT_UINT16_UA(pA,V)      (*(PDCUINT16_UA)(pA)) = (V)
#define DC_INSERT_INT16_UA(pA,V)       (*(PDCINT16_UA)(pA)) = (V)
#define DC_INSERT_UINT32_UA(pA,V)      (*(PDCUINT32_UA)(pA)) = (V)
#define DC_INSERT_INT32_UA(pA,V)       (*(PDCINT32_UA)(pA)) = (V)

#else

#ifndef DC_BIGEND
#define DC_INSERT_UINT16_UA(pA,V)                                       \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_INT16_UA(pA,V)                                        \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_INT32_UA(pA,V)                                            \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#else
#define DC_INSERT_UINT16_UA(pA,V)                                       \
             {                                                          \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_INT16_UA(pA,V)                                        \
             {                                                          \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_INT32_UA(pA,V)                                            \
             {                                                              \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#endif

#endif

/****************************************************************************/
/* Now another version of these macros, to insert an integer at an          */
/* unaligned pointer value.  This time, the value inserted should be in     */
/* wire format.                                                             */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_INSERT_WIRE_UINT16_UA(pA,V)      \
                               (*(PDCUINT16_UA)(pA)) = DC_TO_WIRE16(V)
#define DC_INSERT_WIRE_INT16_UA(pA,V)       \
                               (*(PDCINT16_UA)(pA))  = DC_TO_WIRE16(V)
#define DC_INSERT_WIRE_UINT32_UA(pA,V)      \
                               (*(PDCUINT32_UA)(pA)) = DC_TO_WIRE32(V)
#define DC_INSERT_WIRE_INT32_UA(pA,V)       \
                               (*(PDCINT32_UA)(pA))  = DC_TO_WIRE32(V)

#else

#define DC_INSERT_WIRE_UINT16_UA(pA,V)                                  \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_WIRE_INT16_UA(pA,V)                                   \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_WIRE_UINT32_UA(pA,V)                                      \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_WIRE_INT32_UA(pA,V)                                       \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#endif

/****************************************************************************/
/* Unaligned pointer in-place flipping macros.  These macros flip an        */
/* integer field to or from wire format in-place, but do not do any         */
/* unaligned accesses while they are doing it.                              */
/****************************************************************************/
#ifndef DC_BIGEND

#define DC_TO_WIRE16_INPLACE_UA(A)
#define DC_TO_WIRE32_INPLACE_UA(A)
#define DC_FROM_WIRE16_INPLACE_UA(A)
#define DC_FROM_WIRE32_INPLACE_UA(A)

#else

#ifndef DC_NO_UNALIGNED
#define DC_TO_WIRE16_INPLACE_UA(A)    DC_TO_WIRE16_INPLACE(A)
#define DC_TO_WIRE32_INPLACE_UA(A)    DC_TO_WIRE32_INPLACE(A)
#define DC_FROM_WIRE16_INPLACE_UA(A)  DC_FROM_WIRE16_INPLACE(A)
#define DC_FROM_WIRE32_INPLACE_UA(A)  DC_FROM_WIRE32_INPLACE(A)
#else
#define DC_TO_WIRE16_INPLACE_UA(A)               \
             {                                   \
                 DCUINT16 val;                   \
                 val = DC_TO_WIRE16(A);          \
                 DC_INSERT_UINT16_UA(&(A), val)  \
             }
#define DC_TO_WIRE32_INPLACE_UA(A)               \
             {                                   \
                 DCUINT32 val;                   \
                 val = DC_TO_WIRE32(A);          \
                 DC_INSERT_UINT32_UA(&(A), val)  \
             }
#define DC_FROM_WIRE16_INPLACE_UA(A)             \
             {                                   \
                 DCUINT16 val;                   \
                 val = DC_FROM_WIRE16(A);        \
                 DC_INSERT_UINT16_UA(&(A), val)  \
             }
#define DC_FROM_WIRE32_INPLACE_UA(A)             \
             {                                   \
                 DCUINT32 val;                   \
                 val = DC_FROM_WIRE32(A);        \
                 DC_INSERT_UINT32_UA(&(A), val)  \
             }
#endif

#endif

/****************************************************************************/
/* FLAG macro - parameter indicates bit which flag uses - use as follows:   */
/*                                                                          */
/* #define FILE_OPEN        DCFLAG8(0)                                      */
/* #define FILE_LOCKED      DCFLAG8(1)                                      */
/****************************************************************************/
#define DCFLAG(X)                      ((DCUINT8)  (1 << X))
#define DCFLAG8(X)                     ((DCUINT8)  (1 << X))
#define DCFLAG16(X)                    ((DCUINT16) (1 << X))
#define DCFLAG32(X)                    ((DCUINT32) (1 << X))
#define DCFLAGN(X)                     ((DCUINT)   (1 << X))

/****************************************************************************/
/* Flag manipulation macros:                                                */
/*                                                                          */
/* SET_FLAG       : sets a flag (i.e. assigns 1 to it).                     */
/* CLEAR_FLAG     : clears a flag (i.e. assigns 0 to it).                   */
/* TEST_FLAG      : returns the value of a flag.                            */
/* ASSIGN_FLAG    : takes a boolean value and uses it to set or clear a     */
/*                  flag.                                                   */
/****************************************************************************/
#define SET_FLAG(var, flag)            ((var) |=  (flag))

#ifndef CLEAR_FLAG
#define CLEAR_FLAG(var, flag)          ((var) &= ~(flag))
#endif

#define TEST_FLAG(var, flag)           (((var) &   (flag)) != 0)

#define ASSIGN_FLAG(var, flag, value)                                        \
    if (TRUE == value)                                                       \
    {                                                                        \
        SET_FLAG(var, flag);                                                 \
    }                                                                        \
    else                                                                     \
    {                                                                        \
        CLEAR_FLAG(var, flag);                                               \
    }

/****************************************************************************/
/* Stamp type and macro: each module should use these when stamping its     */
/* data structures.                                                         */
/****************************************************************************/
typedef DCUINT32                       DC_ID_STAMP;

#define DC_MAKE_ID_STAMP(X1, X2, X3, X4)                                    \
   ((DC_ID_STAMP) (((DCUINT32) X4) << 24) |                                 \
                  (((DCUINT32) X3) << 16) |                                 \
                  (((DCUINT32) X2) <<  8) |                                 \
                  (((DCUINT32) X1) <<  0) )

#define MAKE_STAMP16(X1, X2)                                                \
   ((DCUINT16)      (((DCUINT16) X2) <<  8) |                               \
                    (((DCUINT16) X1) <<  0) )

#define MAKE_STAMP32(X1, X2, X3, X4)                                        \
   ((DCUINT32)      (((DCUINT32) X4) << 24) |                               \
                    (((DCUINT32) X3) << 16) |                               \
                    (((DCUINT32) X2) <<  8) |                               \
                    (((DCUINT32) X1) <<  0) )

/****************************************************************************/
/* Other common macros.                                                     */
/****************************************************************************/
#define COM_SIZEOF_RECT(r)                                                  \
    (DCUINT32)((DCUINT32)((r).SRXMAX-(r).SRXMIN)*                           \
               (DCUINT32)((r).SRYMAX-(r).SRYMIN))

/****************************************************************************/
/* Macro to remove the "Unreferenced parameter" warning.                    */
/****************************************************************************/
#define DC_IGNORE_PARAMETER(PARAMETER)   \
                            PARAMETER;

/****************************************************************************/
/* Convert a non-zero value to 1.                                           */
/****************************************************************************/
#define MAKE_BOOL(A)                   (!(!(A)))

/****************************************************************************/
/* This macro works on 32 bit unsigned ticks and returns TRUE if TIME is    */
/* between BEGIN and END (both inclusive) allowing for the wraparound.      */
/****************************************************************************/
#define IN_TIME_RANGE(BEGIN, END, TIME)                                     \
    (((BEGIN) < (END)) ?                                                    \
    (((TIME) >= (BEGIN)) && ((TIME) <= (END))) :                            \
    (((TIME) >= (BEGIN)) || ((TIME) <= (END))))

/****************************************************************************/
/* Minimum and maximum macros.                                              */
/****************************************************************************/
#define DC_MIN(a, b)                   (((a) < (b)) ? (a) : (b))
#define DC_MAX(a, b)                   (((a) > (b)) ? (a) : (b))

/****************************************************************************/
/* Convert BPP to number of colors.                                         */
/****************************************************************************/
#define COLORS_FOR_BPP(BPP) (((BPP) > 8) ? 0 : (1 << (BPP)))

/****************************************************************************/
/* Normalize PALETTEINDEX macro across platforms                            */
/****************************************************************************/
#ifdef OS_WINCE
#define DC_PALINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
#else // OS_WINCE
#define DC_PALINDEX(i)      PALETTEINDEX(i)
#endif // OS_WINCE

#endif /* _H_ADCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgbase.h ===
/****************************************************************************/
// adcgbase.h
//
// Common headers - portable include file. This is the main header which
// should be included by ALL files. It defines common and OS specific types
// and structures as well as including OS-specific headers.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ADCGBASE
#define _H_ADCGBASE


/****************************************************************************/
/* Include basic type definitions.  Some of these may be OS-specific and    */
/* will be defined via a proxy header.                                      */
/****************************************************************************/
#include <adcgbtyp.h>

/****************************************************************************/
/* Include complex type definitions.  Some of these may be OS-specific and  */
/* will be defined via a proxy header.                                      */
/****************************************************************************/
#include <adcgctyp.h>

/****************************************************************************/
/* Include constants.                                                       */
/****************************************************************************/
#include <adcgcnst.h>

/****************************************************************************/
/* Include macros.                                                          */
/****************************************************************************/
#include <adcgmcro.h>

/****************************************************************************/
/* Include C runtime functions.                                             */
/****************************************************************************/
#include <adcgcfnc.h>

/****************************************************************************/
/* Include performance monitoring macros.                                   */
/****************************************************************************/
#include <adcgperf.h>

/****************************************************************************/
/* Include optional defines.                                                */
/****************************************************************************/
#include <aducdefs.h>

/****************************************************************************/
/* Include T.120 header files                                               */
/****************************************************************************/
#include <license.h>
#include <at128.h>
#include <at120ex.h>

//
// Use wide on CE leave unchange on other plats
//
#ifndef OS_WINCE
#define CE_WIDETEXT(x) (x)
#else
#define CE_WIDETEXT(x) _T(x)
#endif


#define SIZE_TCHARS(xx) sizeof(xx)/sizeof(TCHAR)

#endif /* _H_ADCGBASE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\adcgperf.h ===
/*INC+***********************************************************************/
/*                                                                          */
/* adcgperf.h                                                               */
/*                                                                          */
/* Performance Monitoring - portable include file                           */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  10Sep96 AK  SFR0569     Created for performance monitoring              */
/*                                                                          */
/*INC-***********************************************************************/
#ifndef _H_ADCGPERF
#define _H_ADCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgperf.h>

#endif /* _H_ADCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ddcgbtyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ddcgbtyp.h                                                               */
/*                                                                          */
/* DC-Groupware basic types - 16-bit Windows specific header                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ddcgbtyp.h_v  $
 *
 *    Rev 1.8   22 Sep 1997 15:10:22   KH
 * SFR1368: Keep the Win16 INI file in Windows, not Ducati, directory
 *
 *    Rev 1.7   22 Aug 1997 17:36:50   AK
 * SFR1330: Win16 retail build support
 *
 *    Rev 1.6   04 Aug 1997 14:54:44   KH
 * SFR1022: Move DCCALLBACK to wdcgbtyp, add LOADDS
 *
 *    Rev 1.5   10 Jul 1997 17:18:56   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.4   09 Jul 1997 17:09:48   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   04 Jul 1997 11:13:50   KH
 * SFR1022: Fix 16-bit compiler warnings
 *
 *    Rev 1.2   25 Jun 1997 14:32:52   KH
 * Win16Port: 16-bit basic types
 *
 *    Rev 1.1   19 Jun 1997 15:02:44   ENH
 * Win16Port: 16 bit specifics
**/
/**INC-**********************************************************************/
#ifndef _H_DDCGBTYP
#define _H_DDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Check whether we should include the system headers.                      */
/****************************************************************************/
#ifndef DC_NO_SYSTEM_HEADERS

/****************************************************************************/
/* Force strict type checking.                                              */
/****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/****************************************************************************/
/* Disable the following warnings for the Windows headers:                  */
/*                                                                          */
/* 4115: named type definition in parentheses                               */
/* 4201: nonstandard extension used : nameless struct/union                 */
/* 4214: nonstandard extension used : bit field types other than int        */
/* 4702: unreachable code effect                                            */
/* 4704: in-line assembler precludes global optimizations                   */
/* 4705: statement has no effect                                            */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4115)
#pragma warning (disable: 4201)
#pragma warning (disable: 4214)
#ifndef DC_DEBUG
#pragma warning (disable: 4702)
#pragma warning (disable: 4704)
#pragma warning (disable: 4705)
#endif

/****************************************************************************/
/* Include the system headers.                                              */
/****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stddef.h>

#pragma warning (default: 4115)
#pragma warning (default: 4201)
#pragma warning (default: 4214)

/****************************************************************************/
/* Disable the following warnings for our code:                             */
/*                                                                          */
/* 4102: "Unreferenced label" warnings so that DC_EXIT_POINT can be placed  */
/*       in each function if there aren't (yet) any DC_QUITs.               */
/* 4514: unreferenced inline function has been removed                      */
/* 4001: nonstandard extension 'single line comment' was used               */
/* 4058: unions are now aligned on alignment requirement, not size          */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4102)
#pragma warning (disable: 4514)
#pragma warning (disable: 4001)
#pragma warning (disable: 4058)

/****************************************************************************/
/* Promote the following warnings to errors:                                */
/*                                                                          */
/* 4706 - "Assignment in conditional expression"                            */
/* 4013 - "'FunctionName' undefined; assuming extern returning int"         */
/*                                                                          */
/* Promote the following warnings to level 3:                               */
/*                                                                          */
/* 4100 - "unreferenced formal parameter"                                   */
/* 4701 - "Local variable may be used before being initialized".            */
/* 4244 - "conversion from 'int ' to 'short ', possible loss of data        */
/* 4127 - "conditional expression is constant                               */
/*                                                                          */
/****************************************************************************/
// #pragma warning (error: 4706)
// #pragma warning (error: 4013)
// #pragma warning (3    : 4100)
// #pragma warning (3    : 4701)
// #pragma warning (3    : 4244)
// #pragma warning (4    : 4127)

#endif /* DCS_NO_SYSTEM_HEADERS */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* INI file access.                                                         */
/****************************************************************************/
#define DC_INIFILE "mstsc.ini"
#define DC_INI_INTVAL1 0x7fff
#define DC_INI_INTVAL2 (DC_INI_INTVAL1 - 1)
#define DC_INI_STRVAL1 "x"
#define DC_INI_STRVAL2 "w"

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DCPTR is used when declaring pointers to variables.  Use it to get the   */
/* correct pointer types for your memory model/compiler.                    */
/****************************************************************************/
#define DCPTR               FAR *

/****************************************************************************/
/* DCUNALIGNED is used to define pointers to values which are not aligned   */
/* on the correct boundary.  Doesn't apply for 16-bit.                      */
/****************************************************************************/
#define DCUNALIGNED

/****************************************************************************/
/* Define function calling conventions.  Note that PDCAPI should be used to */
/* declare a pointer to a function.                                         */
/****************************************************************************/
#define DCEXPORT           __export
#define DCLOADDS           __loadds
#define DCAPI              _pascal
#define DCINTERNAL         _pascal

#define PDCAPI              DCAPI      DCPTR
#define PDCCALLBACK         DCCALLBACK DCPTR
#define PDCINTERNAL         DCINTERNAL DCPTR

/****************************************************************************/
/* Define DCHPTR.                                                           */
/****************************************************************************/
#define HUGE               _huge
#define DCHPTR              HUGE *

#ifdef OS_WIN16
#define UNREFERENCED_PARAMETER(P)          (P)
#endif // OS_WIN16

#endif /* _H_DDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\compress.h ===
//************************************************************************
// compress.h
//
// Header for MPPC compression for RDP.
//
// Copyright (C) 1994-2000 Microsoft Corporation
//************************************************************************
#ifndef __COMPRESS_H
#define __COMPRESS_H


#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

// History buffer sizes for various compression levels.
#define HISTORY_SIZE_8K  (8192L)
#define HISTORY_SIZE_64K (65536L)

#ifndef OS_WINCE
// Enabling the compression instrumentation only for debug bits.
#ifdef DC_DEBUG
#define COMPR_DEBUG 1
#endif 

#endif

// Server-only items. The Win16 client compile will complain otherwise.
//#if defined(DLL_WD) || defined(DLL_DISP)

// Hash table number of entries used on the compress side.
#define HASH_TABLE_SIZE 32768

typedef struct SendContext {
    UCHAR    History [HISTORY_SIZE_64K];
    int      CurrentIndex;     // how far into the history buffer we are
    PUCHAR   ValidHistory;     // how much of history is valid
    unsigned ClientComprType;  // The compression types supported by decompress.
    ULONG    HistorySize;      // History size used based on ComprType.
    USHORT   HashTable[HASH_TABLE_SIZE];  // 16 bits=max 64K for HistorySize.
} SendContext;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


void initsendcontext(SendContext *, unsigned);

UCHAR compress(UCHAR *, UCHAR *, ULONG *, SendContext *);

#ifdef __cplusplus
}
#endif // __cplusplus



//#else //(DLL_WD) || (DLL_DISP)


// We split the receive context into two pieces to deal with the Win16
// client's inability to malloc over 64K without using a nasty HUGE pointer.

typedef struct RecvContext1 {
    UCHAR FAR *CurrentPtr;  // how far into the history buffer we are
} RecvContext1;

//
// 64K decompression context
//
typedef struct RecvContext2_64K {
    // We use one less byte to allow this struct to be allocated with
    // LocalAlloc() on the Win16 client.
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[HISTORY_SIZE_64K - 1];

// Won't work if on Win16.
// Debug Fence code only works for 64K contexts
#ifdef COMPR_DEBUG
#define DEBUG_FENCE_16K_VALUE    0xABABABAB
    ULONG Debug16kFence;
#endif

} RecvContext2_64K;

//
// 8K decompression context
//
typedef struct RecvContext2_8K {
    // We use one less byte to allow this struct to be allocated with
    // LocalAlloc() on the Win16 client.
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[HISTORY_SIZE_8K - 1];

#ifdef COMPR_DEBUG
#define DEBUG_FENCE_8K_VALUE    0xABCABCAB
    ULONG Debug8kFence;
#endif

} RecvContext2_8K;

//
// Generic decompression context.
// This is the 'type' we use when passing around
// compression contexts as parameters
// size field tells us which one we're using
//
//
// IMPORTANT: Field ordering must match exactly
//            Between the Generic type and any
//            size specific contexts.
typedef struct RecvContext2_Generic {
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[1];
} RecvContext2_Generic;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int initrecvcontext(RecvContext1 *, RecvContext2_Generic *, unsigned ComprType);

int decompress(
        UCHAR FAR *inbuf,
        int inlen,
        int start,
        UCHAR FAR * FAR *output,
        int *outlen,
        RecvContext1 *context1,
        RecvContext2_Generic *context2,
        unsigned ComprType);

#ifdef __cplusplus
}
#endif // __cplusplus



//#endif  // DLL_WD | DLL_DISP


//
// Other defines
//

// There are 8 bits of packet data in the generalCompressedType field of the
// SHAREDATAHEADER. Note that PACKET_ENCRYPTED is unused (therefore
// reusable in the future).
#define PACKET_FLUSHED    0x80
#define PACKET_AT_FRONT   0x40
#define PACKET_COMPRESSED 0x20
#define PACKET_ENCRYPTED  0x10

// Defines which of 16 potential compression types we are using.
// 8K corresponds to the TSE4 client and server. 64K is the newer re-optimized
// version used in TSE5. Note that the type values are re-used in the
// GCC conference client capability set. Any client advertising support for
// type N must support types 0..(N-1) since it could be talking to an older
// server and receive any older type.
#define PACKET_COMPR_TYPE_MASK 0x0F
#define PACKET_COMPR_TYPE_8K   0
#define PACKET_COMPR_TYPE_64K  1
#define PACKET_COMPR_TYPE_MAX  1

// VC compression options take up bytes 5 of the VC header flags field
#define VC_FLAG_COMPRESS_MASK              0xFF
#define VC_FLAG_COMPRESS_SHIFT             16
#define VC_FLAG_PRIVATE_PROTOCOL_MASK      0xFFFF0000



#endif  // __COMPRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\at128.h ===
/****************************************************************************/
// at128.h
//
// RDP/T.128 definitions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AT128
#define _H_AT128

/****************************************************************************/
/* Define basic types used in the rest of this header                       */
/****************************************************************************/
typedef unsigned long  TSUINT32, *PTSUINT32;
typedef unsigned short TSUINT16, *PTSUINT16;
typedef short          TSINT16,  *PTSINT16;
typedef unsigned char  TSUINT8,  *PTSUINT8;
typedef char           TSINT8,   *PTSINT8;
typedef short          TSBOOL16, *PTSBOOL16;
typedef long           TSINT32,  *PTSINT32;

typedef unsigned short TSWCHAR; 
typedef TCHAR          TSTCHAR;
typedef ULONG          TSCOLORREF;

/****************************************************************************/
// Turn off compiler padding of structures. Note this means that *all*
// pointers to structs defined in this file will be automatically UNALIGNED,
// which can cause a lot of problems for RISC platforms where unaligned
// means about eight times as much code.
// Save previous packing style if 32-bit build.
/****************************************************************************/
#ifdef OS_WIN16
#pragma pack (1)
#else
#pragma pack (push, t128pack, 1)
#endif

#define INT16_MIN   (-32768) 

/****************************************************************************/
/* Basic type definitions                                                   */
/****************************************************************************/
typedef TSUINT32 TS_SHAREID;

/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/
#define TS_MAX_SOURCEDESCRIPTOR      48
#define TS_MAX_TERMINALDESCRIPTOR    16
#define TS_MAX_FACENAME              32
#define TS_MAX_ORDERS                32
#define TS_MAX_ENC_ORDER_FIELDS      24
#define TS_MAX_DOMAIN_LENGTH         512 
#define TS_MAX_DOMAIN_LENGTH_OLD     52
#define TS_MAX_USERNAME_LENGTH_OLD   44
#define TS_MAX_USERNAME_LENGTH       512
#define TS_MAX_PASSWORD_LENGTH       512 
#define TS_MAX_PASSWORD_LENGTH_OLD   32
#define TS_MAX_ALTERNATESHELL_LENGTH 512
#define TS_MAX_WORKINGDIR_LENGTH     512
#define TS_MAX_CLIENTADDRESS_LENGTH  64
#define TS_MAX_SERVERADDRESS_LENGTH  64
#define TS_MAX_CLIENTDIR_LENGTH      512
#define TS_MAX_GLYPH_CACHES          10
// Max size might be expand if exist very long IME file name.
#define TS_MAX_IMEFILENAME           32
// Length of the autoreconnect cookie
#define TS_MAX_AUTORECONNECT_LEN     128

//
// Autoreconnect verifier that is sent up to the server
//
#define TS_ARC_VERIFIER_LEN          16


/****************************************************************************/
/* Encoded Order types.                                                     */
/* These numbers are the values sent in encoded orders to identify the      */
/* order type. Range is 0..31.                                              */
/****************************************************************************/
#define TS_ENC_DSTBLT_ORDER           0x00
#define TS_ENC_PATBLT_ORDER           0x01
#define TS_ENC_SCRBLT_ORDER           0x02
#define TS_ENC_MEMBLT_ORDER           0x03
#define TS_ENC_MEM3BLT_ORDER          0x04
#define TS_ENC_ATEXTOUT_ORDER         0x05
#define TS_ENC_AEXTTEXTOUT_ORDER      0x06

#ifdef DRAW_NINEGRID
#define TS_ENC_DRAWNINEGRID_ORDER     0x07
#define TS_ENC_MULTI_DRAWNINEGRID_ORDER 0x08
#endif

#define TS_ENC_LINETO_ORDER           0x09
#define TS_ENC_OPAQUERECT_ORDER       0x0a
#define TS_ENC_SAVEBITMAP_ORDER       0x0b
// unused 0x0C
#define TS_ENC_MEMBLT_R2_ORDER        0x0d
#define TS_ENC_MEM3BLT_R2_ORDER       0x0e
#define TS_ENC_MULTIDSTBLT_ORDER      0x0f
#define TS_ENC_MULTIPATBLT_ORDER      0x10
#define TS_ENC_MULTISCRBLT_ORDER      0x11
#define TS_ENC_MULTIOPAQUERECT_ORDER  0x12
#define TS_ENC_FAST_INDEX_ORDER       0x13
#define TS_ENC_POLYGON_SC_ORDER       0x14
#define TS_ENC_POLYGON_CB_ORDER       0x15
#define TS_ENC_POLYLINE_ORDER         0x16
// unused  0x17
#define TS_ENC_FAST_GLYPH_ORDER       0x18
#define TS_ENC_ELLIPSE_SC_ORDER       0x19
#define TS_ENC_ELLIPSE_CB_ORDER       0x1a
#define TS_ENC_INDEX_ORDER            0x1b
#define TS_ENC_WTEXTOUT_ORDER         0x1c
#define TS_ENC_WEXTTEXTOUT_ORDER      0x1d
#define TS_ENC_LONG_WTEXTOUT_ORDER    0x1e
#define TS_ENC_LONG_WEXTTEXTOUT_ORDER 0x1f

#define TS_LAST_ORDER                 0x1f


/****************************************************************************/
/* Order Negotiation constants.                                             */
/* These numbers are indices to TS_ORDER_CAPABILITYSET.orderSupport, used   */
/* to advertise a node's capability to receive each type of encoded order.  */
/* Range is 0..TS_MAX_ORDERS-1.                                             */
/****************************************************************************/
#define TS_NEG_DSTBLT_INDEX          0x0000
#define TS_NEG_PATBLT_INDEX          0x0001
#define TS_NEG_SCRBLT_INDEX          0x0002
#define TS_NEG_MEMBLT_INDEX          0x0003
#define TS_NEG_MEM3BLT_INDEX         0x0004
#define TS_NEG_ATEXTOUT_INDEX        0x0005
#define TS_NEG_AEXTTEXTOUT_INDEX     0x0006

#ifdef DRAW_NINEGRID
#define TS_NEG_DRAWNINEGRID_INDEX    0x0007
#endif

#define TS_NEG_LINETO_INDEX          0x0008

#ifdef DRAW_NINEGRID
#define TS_NEG_MULTI_DRAWNINEGRID_INDEX 0x0009
#endif

#define TS_NEG_OPAQUERECT_INDEX      0x000A
#define TS_NEG_SAVEBITMAP_INDEX      0x000B
#define TS_NEG_WTEXTOUT_INDEX        0x000C
#define TS_NEG_MEMBLT_R2_INDEX       0x000D
#define TS_NEG_MEM3BLT_R2_INDEX      0x000E
#define TS_NEG_MULTIDSTBLT_INDEX     0x000F
#define TS_NEG_MULTIPATBLT_INDEX     0x0010
#define TS_NEG_MULTISCRBLT_INDEX     0x0011
#define TS_NEG_MULTIOPAQUERECT_INDEX 0x0012
#define TS_NEG_FAST_INDEX_INDEX      0x0013
#define TS_NEG_POLYGON_SC_INDEX      0x0014
#define TS_NEG_POLYGON_CB_INDEX      0x0015
#define TS_NEG_POLYLINE_INDEX        0x0016
// unused 0x17
#define TS_NEG_FAST_GLYPH_INDEX      0x0018
#define TS_NEG_ELLIPSE_SC_INDEX      0x0019
#define TS_NEG_ELLIPSE_CB_INDEX      0x001A
#define TS_NEG_INDEX_INDEX           0x001B
#define TS_NEG_WEXTTEXTOUT_INDEX     0x001C
#define TS_NEG_WLONGTEXTOUT_INDEX    0x001D
#define TS_NEG_WLONGEXTTEXTOUT_INDEX 0x001E


/****************************************************************************/
// Primary order bounds encoding description flags.
/****************************************************************************/
#define TS_BOUND_LEFT            0x01
#define TS_BOUND_TOP             0x02
#define TS_BOUND_RIGHT           0x04
#define TS_BOUND_BOTTOM          0x08
#define TS_BOUND_DELTA_LEFT      0x10
#define TS_BOUND_DELTA_TOP       0x20
#define TS_BOUND_DELTA_RIGHT     0x40
#define TS_BOUND_DELTA_BOTTOM    0x80


/****************************************************************************/
/* Structure types                                                          */
/****************************************************************************/

/****************************************************************************/
// TS_POINT16
/****************************************************************************/
typedef struct tagTS_POINT16
{
    TSINT16 x;
    TSINT16 y;
} TS_POINT16, FAR *PTS_POINT16;


/****************************************************************************/
// TS_RECTANGLE16
/****************************************************************************/
typedef struct tagTS_RECTANGLE16
{
    TSINT16 left;
    TSINT16 top;
    TSINT16 right;
    TSINT16 bottom;
} TS_RECTANGLE16, FAR *PTS_RECTANGLE16;


/****************************************************************************/
// TS_RECTANGLE32
/****************************************************************************/
typedef struct tagTS_RECTANGLE32
{
    TSINT32 left;
    TSINT32 top;
    TSINT32 right;
    TSINT32 bottom;
} TS_RECTANGLE32, FAR *PTS_RECTANGLE32;


/****************************************************************************/
/* Structure: TS_SHARECONTROLHEADER                                         */
/*                                                                          */
/* Description: ShareControlHeader                                          */
/* Note that this structure is not DWORD aligned, it relies on the packing  */
/* to ensure that structures following this (within a PDU) are correctly    */
/* aligned (i.e. do not have pad bytes inserted).                           */
/****************************************************************************/
typedef struct tagTS_SHARECONTROLHEADER
{
    TSUINT16 totalLength;
    TSUINT16 pduType;              /* Also encodes the protocol version  */
    TSUINT16 pduSource;
} TS_SHARECONTROLHEADER, FAR *PTS_SHARECONTROLHEADER;


/****************************************************************************/
// TS_BLENDFUNC
//
// This is the alphablend function information
/****************************************************************************/
typedef struct tagTS_BLENDFUNC
{
    BYTE     BlendOp;
    BYTE     BlendFlags;
    BYTE     SourceConstantAlpha;
    BYTE     AlphaFormat;

} TS_BLENDFUNC, FAR *PTS_BLENDFUNC;


/****************************************************************************/
/* Macros to access packet length field.                                    */
/****************************************************************************/
#define TS_DATAPKT_LEN(pPkt) \
        ((pPkt)->shareDataHeader.shareControlHeader.totalLength)
#define TS_CTRLPKT_LEN(pPkt) \
        ((pPkt)->shareControlHeader.totalLength)
#define TS_UNCOMP_LEN(pPkt)  ((pPkt)->shareDataHeader.uncompressedLength)


/****************************************************************************/
/* the pduType field contains the Protocol Version and the PDU type.  These */
/* masks select the relevant field.                                         */
/****************************************************************************/
#define TS_MASK_PDUTYPE          0x000F
#define TS_MASK_PROTOCOLVERSION  0xFFF0

/****************************************************************************/
/* PDUType values                                                           */
/****************************************************************************/
#define TS_PDUTYPE_FIRST                           1
#define TS_PDUTYPE_DEMANDACTIVEPDU                 1
#define TS_PDUTYPE_REQUESTACTIVEPDU                2
#define TS_PDUTYPE_CONFIRMACTIVEPDU                3
#define TS_PDUTYPE_DEACTIVATEOTHERPDU              4
#define TS_PDUTYPE_DEACTIVATESELFPDU               5
#define TS_PDUTYPE_DEACTIVATEALLPDU                6
#define TS_PDUTYPE_DATAPDU                         7
#define TS_PDUTYPE_SERVERCERTIFICATEPDU            8
#define TS_PDUTYPE_CLIENTRANDOMPDU                 9

#define TS_PDUTYPE_LAST                            9
#define TS_NUM_PDUTYPES                            9


/****************************************************************************/
// TS_SHAREDATAHEADER
/****************************************************************************/
typedef struct tagTS_SHAREDATAHEADER
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT8               pad1;
    TSUINT8               streamID;
    TSUINT16              uncompressedLength;
    TSUINT8               pduType2;
    TSUINT8               generalCompressedType;
    TSUINT16              generalCompressedLength;
} TS_SHAREDATAHEADER, FAR * PTS_SHAREDATAHEADER;


/****************************************************************************/
/* streamID values                                                          */
/****************************************************************************/
#define TS_STREAM_LOW       1
#define TS_STREAM_MED       2
#define TS_STREAM_HI        4


/****************************************************************************/
/* PDUType2 values                                                          */
/****************************************************************************/
#define TS_PDUTYPE2_APPLICATION                    25
#define TS_PDUTYPE2_CONTROL                        20
#define TS_PDUTYPE2_FONT                           11
#define TS_PDUTYPE2_INPUT                          28
#define TS_PDUTYPE2_MEDIATEDCONTROL                29
#define TS_PDUTYPE2_POINTER                        27
#define TS_PDUTYPE2_REMOTESHARE                    30
#define TS_PDUTYPE2_SYNCHRONIZE                    31
#define TS_PDUTYPE2_UPDATE                         2
#define TS_PDUTYPE2_UPDATECAPABILITY               32
#define TS_PDUTYPE2_WINDOWACTIVATION               23
#define TS_PDUTYPE2_WINDOWLISTUPDATE               24
#define TS_PDUTYPE2_DESKTOP_SCROLL                 26
#define TS_PDUTYPE2_REFRESH_RECT                   33
#define TS_PDUTYPE2_PLAY_SOUND                     34
#define TS_PDUTYPE2_SUPPRESS_OUTPUT                35
#define TS_PDUTYPE2_SHUTDOWN_REQUEST               36
#define TS_PDUTYPE2_SHUTDOWN_DENIED                37
#define TS_PDUTYPE2_SAVE_SESSION_INFO              38
#define TS_PDUTYPE2_FONTLIST                       39
#define TS_PDUTYPE2_FONTMAP                        40
#define TS_PDUTYPE2_SET_KEYBOARD_INDICATORS        41
#define TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST    43
#define TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU          44
#define TS_PDUTYPE2_SET_KEYBOARD_IME_STATUS        45
#define TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU          46
#define TS_PDUTYPE2_SET_ERROR_INFO_PDU             47
#ifdef DRAW_NINEGRID
#define TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU         48
#endif
#ifdef DRAW_GDIPLUS
#define TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU          49
#endif
#define TS_PDUTYPE2_ARC_STATUS_PDU                 50

/****************************************************************************/
/* Capabilities Structures:                                                 */
/****************************************************************************/

#define TS_CAPSETTYPE_GENERAL           1
#define TS_CAPSETTYPE_BITMAP            2
#define TS_CAPSETTYPE_ORDER             3
#define TS_CAPSETTYPE_BITMAPCACHE       4
#define TS_CAPSETTYPE_CONTROL           5
#define TS_CAPSETTYPE_ACTIVATION        7
#define TS_CAPSETTYPE_POINTER           8
#define TS_CAPSETTYPE_SHARE             9
#define TS_CAPSETTYPE_COLORCACHE        10
#define TS_CAPSETTYPE_WINDOWLIST        11
#define TS_CAPSETTYPE_SOUND             12
#define TS_CAPSETTYPE_INPUT             13
#define TS_CAPSETTYPE_FONT              14
#define TS_CAPSETTYPE_BRUSH             15
#define TS_CAPSETTYPE_GLYPHCACHE        16
#define TS_CAPSETTYPE_OFFSCREENCACHE    17
#define TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT 18
#define TS_CAPSETTYPE_BITMAPCACHE_REV2  19
#define TS_CAPSETTYPE_VIRTUALCHANNEL    20

#ifdef DRAW_NINEGRID
#define TS_CAPSETTYPE_DRAWNINEGRIDCACHE 21
#endif

#ifdef DRAW_GDIPLUS
#define TS_CAPSETTYPE_DRAWGDIPLUS        22
#endif

#define TS_CAPSFLAG_UNSUPPORTED         0
#define TS_CAPSFLAG_SUPPORTED           1


/****************************************************************************/
// TS_GENERAL_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_GENERAL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 osMajorType;
#define TS_OSMAJORTYPE_UNSPECIFIED 0
#define TS_OSMAJORTYPE_WINDOWS     1
#define TS_OSMAJORTYPE_OS2         2
#define TS_OSMAJORTYPE_MACINTOSH   3
#define TS_OSMAJORTYPE_UNIX        4

    TSUINT16 osMinorType;
#define TS_OSMINORTYPE_UNSPECIFIED    0
#define TS_OSMINORTYPE_WINDOWS_31X    1
#define TS_OSMINORTYPE_WINDOWS_95     2
#define TS_OSMINORTYPE_WINDOWS_NT     3
#define TS_OSMINORTYPE_OS2_V21        4
#define TS_OSMINORTYPE_POWER_PC       5
#define TS_OSMINORTYPE_MACINTOSH      6
#define TS_OSMINORTYPE_NATIVE_XSERVER 7
#define TS_OSMINORTYPE_PSEUDO_XSERVER 8

    TSUINT16 protocolVersion;
#define TS_CAPS_PROTOCOLVERSION   0x0200
    TSUINT16 pad2octetsA;

    TSUINT16 generalCompressionTypes;

    // This field used to be pad2octetsB.
    // We are reusing the field to hold extra flags
    //
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR capability indicates if the
    // server/client supports compressed bitmap without the redundent BC header
    // Note this value is defined in REV2 bitmap extraflags value for consistency
    TSUINT16 extraFlags;
    // Determines that server-to-client fast-path output is supported.
#define TS_FASTPATH_OUTPUT_SUPPORTED        0x0001
    // Tells if the compression level is set and can be negociated for the shadow.
#define TS_SHADOW_COMPRESSION_LEVEL         0x0002
    // Determine if the Client can support Long UserNames and Passwords
#define TS_LONG_CREDENTIALS_SUPPORTED       0x0004
    // Does the client support the reconnect cookie
#define TS_AUTORECONNECT_COOKIE_SUPPORTED   0x0008
    //
    // Support for safe-encryption checksumming
    //  Salt the checksum with the packet count
    //
#define TS_ENC_SECURE_CHECKSUM              0x0010
    

    TSBOOL16 updateCapabilityFlag;
    TSBOOL16 remoteUnshareFlag;
    TSUINT16 generalCompressionLevel;
    TSUINT8  refreshRectSupport; /* can receive refreshRect */
    TSUINT8  suppressOutputSupport; /* and suppressOutputPDU */
} TS_GENERAL_CAPABILITYSET, FAR *PTS_GENERAL_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAP_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BITMAP_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 preferredBitsPerPixel;
    TSBOOL16 receive1BitPerPixel;
    TSBOOL16 receive4BitsPerPixel;
    TSBOOL16 receive8BitsPerPixel;
    TSUINT16 desktopWidth;
    TSUINT16 desktopHeight;
    TSUINT16 pad2octets;
    TSBOOL16 desktopResizeFlag;
    TSUINT16 bitmapCompressionFlag;

    /************************************************************************/
    /* T.128 extension: fields for supporting > 8bpp color depths           */
    /* highColorFlags values - undefined bits must be set to zero.          */
    /************************************************************************/
#define TS_COLOR_FL_RECEIVE_15BPP 1 /* can receive (5,5,5) */
                                    /* rgbs in bitmap data */
#define TS_COLOR_FL_RECEIVE_16BPP 2 /* can receive (5,6,5) */
#define TS_COLOR_FL_RECEIVE_24BPP 4 /* can receive (8,8,8) */
    TSUINT8  highColorFlags;
    TSUINT8  pad1octet;

    /************************************************************************/
    /* Extension: indicate multiple rectangle support.                      */
    /************************************************************************/
    TSUINT16 multipleRectangleSupport;
    TSUINT16 pad2octetsB;
} TS_BITMAP_CAPABILITYSET, FAR *PTS_BITMAP_CAPABILITYSET;


/****************************************************************************/
// TS_ORDER_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_ORDER_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT8  terminalDescriptor[TS_MAX_TERMINALDESCRIPTOR];
    TSUINT32 pad4octetsA;
    TSUINT16 desktopSaveXGranularity;
    TSUINT16 desktopSaveYGranularity;
    TSUINT16 pad2octetsA;
    TSUINT16 maximumOrderLevel;
    TSUINT16 numberFonts;
    TSUINT16 orderFlags;
#define TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT 0x0002
#define TS_ORDERFLAGS_CANNOTRECEIVEORDERS   0x0004
    /************************************************************************/
    /* TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT                                */
    /* Indicates support for the order encoding flag for zero bounds delta  */
    /* coords (TS_ZERO_BOUNDS_DELTAS).                                      */
    /*                                                                      */
    /* TS_ORDERFLAGS_COLORINDEXSUPPORT                                      */
    /* Indicates support for sending color indices, not RGBs, in orders.    */
    /*                                                                      */
    /* TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY                                  */
    /* Indicates that this party can receive only solid and pattern brushes.*/
    /************************************************************************/
#define TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT 0x0008
#define TS_ORDERFLAGS_COLORINDEXSUPPORT       0x0020
#define TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY   0x0040

    TSUINT8  orderSupport[TS_MAX_ORDERS];
    TSUINT16 textFlags;
#define TS_TEXTFLAGS_CHECKFONTASPECT      0x0001
#define TS_TEXTFLAGS_ALLOWDELTAXSIM       0x0020
#define TS_TEXTFLAGS_CHECKFONTSIGNATURES  0x0080
#define TS_TEXTFLAGS_USEBASELINESTART     0x0200
    /************************************************************************/
    /* T.128 extension: allow support for sending font "Cell Height" in     */
    /* addition to the standard "Character Height" in text orders.          */
    /************************************************************************/
#define TS_TEXTFLAGS_ALLOWCELLHEIGHT      0x0400 /* cell height allowed     */
#define TS_TEXT_AND_MASK (TS_TEXTFLAGS_CHECKFONTASPECT     \
                        | TS_TEXTFLAGS_CHECKFONTSIGNATURES \
                        | TS_TEXTFLAGS_USEBASELINESTART    \
                        | TS_TEXTFLAGS_ALLOWCELLHEIGHT)
#define TS_TEXT_OR_MASK (TS_TEXTFLAGS_ALLOWDELTAXSIM)

    TSUINT16 pad2octetsB;
    TSUINT32 pad4octetsB;
    TSUINT32 desktopSaveSize;
    TSUINT16 pad2octetsC;
    TSUINT16 pad2octetsD;
    TSUINT16 textANSICodePage;
#define TS_ANSI_CP_DEFAULT                1252    /* Windows mulitlingual   */
    TSUINT16 pad2octetsE;                         /* caps are DWord aligned */
} TS_ORDER_CAPABILITYSET, FAR * PTS_ORDER_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BITMAPCACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT32 pad1;
    TSUINT32 pad2;
    TSUINT32 pad3;
    TSUINT32 pad4;
    TSUINT32 pad5;
    TSUINT32 pad6;
    TSUINT16 Cache1Entries;
    TSUINT16 Cache1MaximumCellSize;
    TSUINT16 Cache2Entries;
    TSUINT16 Cache2MaximumCellSize;
    TSUINT16 Cache3Entries;
    TSUINT16 Cache3MaximumCellSize;
} TS_BITMAPCACHE_CAPABILITYSET, FAR * PTS_BITMAPCACHE_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT
//
// Sent from the server when it supports greater than rev1 bitmap caching.
// Allows the client to determine what sort of return capabilitites it should
// return in its ConfirmActivePDU.
/****************************************************************************/
typedef struct
{
    TSUINT16 capabilitySetType;  // TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT
    TSUINT16 lengthCapability;

    // Indicates the level of support available on the server. Note
    // that using TS_BITMAPCACHE_REV1 is not supported here, since in that
    // case the HOSTSUPPORT capability should simply not be included in
    // the capabilities sent to the client.
    TSUINT8 CacheVersion;
#define TS_BITMAPCACHE_REV1 0
#define TS_BITMAPCACHE_REV2 1

    TSUINT8  Pad1;
    TSUINT16 Pad2;
} TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT,
        FAR *PTS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET_REV2
//
// Sent from client to server when the server indicates it supports rev2
// caching by sending TS_BITMAPCACHE_CAPABILITYSET_REV2_HOSTSUPPORT.
// Corresponds to the expanded capabilities used with persistent bitmap
// caches.
/****************************************************************************/
#define TS_BITMAPCACHE_0_CELL_SIZE 256

#define TS_BITMAPCACHE_SCREEN_ID 0xFF

typedef struct
{
    TSUINT32 NumEntries : 31;
    TSUINT32 bSendBitmapKeys : 1;
} TS_BITMAPCACHE_CELL_CACHE_INFO;

#define BITMAPCACHE_WAITING_LIST_INDEX  32767

typedef struct tagTS_BITMAPCACHE_CAPABILITYSET_REV2
{
    TSUINT16 capabilitySetType;  // TS_CAPSETTYPE_BITMAPCACHE_REV2
    TSUINT16 lengthCapability;

    // Flags.
    TSUINT16 bPersistentKeysExpected : 1;  // Persistent keys to be sent.
    TSUINT16 bAllowCacheWaitingList : 1;
    TSUINT16 Pad1 : 14;

    TSUINT8 Pad2;

    // Number of cell caches ready to be used.
    // The protocol allows maximum 5 caches, the server currently only
    // handles 3 caches.
    TSUINT8 NumCellCaches;
#define TS_BITMAPCACHE_MAX_CELL_CACHES 5
#define TS_BITMAPCACHE_SERVER_CELL_CACHES 3

    // Following space reserved for up to TS_BITMAPCACHE_MAX_CELL_CACHES
    // sets of information.
    TS_BITMAPCACHE_CELL_CACHE_INFO CellCacheInfo[
            TS_BITMAPCACHE_MAX_CELL_CACHES];
} TS_BITMAPCACHE_CAPABILITYSET_REV2, FAR *PTS_BITMAPCACHE_CAPABILITYSET_REV2;


/****************************************************************************/
// TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY
//
// Single bitmap entry for the list of entries that is used to preload the
// bitmap cache at connect time.
/****************************************************************************/
#define TS_BITMAPCACHE_NULL_KEY 0xFFFFFFFF
typedef struct
{
    TSUINT32 Key1;
    TSUINT32 Key2;
} TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY,
        FAR *PTS_BITMAPCACHE_PERSISTENT_LIST_ENTRY;


/****************************************************************************/
// TS_BITMAPCACHE_PERSISTENT_LIST
//
// Specifies one of a set of bitmap cache persistent entry preload lists.
/****************************************************************************/

// Defines the upper limit on the number of keys that can be specified
// in the combined TotalEntries below. More than this constitutes a
// breach of protocol and is cause for session termination.
#define TS_BITMAPCACHE_MAX_TOTAL_PERSISTENT_KEYS (256 * 1024)

typedef struct
{
    // Contains TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST as the secondary
    // PDU type.
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT16 NumEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    TSUINT16 TotalEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    TSUINT8  bFirstPDU : 1;
    TSUINT8  bLastPDU : 1;
    TSUINT8  Pad1 : 6;
    TSUINT8  Pad2;
    TSUINT16 Pad3;
    TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY Entries[1];
} TS_BITMAPCACHE_PERSISTENT_LIST, FAR *PTS_BITMAPCACHE_PERSISTENT_LIST;


/****************************************************************************/
// TS_BITMAPCACHE_ERROR_PDU
//
// Sent when the client encounters a catastrophic error in its caching.
// This PDU is sent to inform the server of the problem and what actions to
// take with each of the cell caches.
/****************************************************************************/

// maximum number of error pdus a client is allowed to send for a session
// this is also the maximum number of error pdus a server will handle
#define MAX_NUM_ERROR_PDU_SEND     5

typedef struct
{
    // Specifies the cache ID in this info block.
    TSUINT8 CacheID;

    // Specifies that the cache should have its contents emptied.
    // If FALSE and a NewNumEntries specifies a new nonzero size, the previous
    // cache contents in the initial (NewNumEntries) cells will be preserved.
    TSUINT8 bFlushCache : 1;

    // Specifies that the NewNumEntries field is valid.
    TSUINT8 bNewNumEntriesValid : 1;

    TSUINT8  Pad1 : 6;
    TSUINT16 Pad2;

    // New number of entries in the cache. Must be less than or equal to the
    // number of entries previously sent in the capabilities.
    TSUINT32 NewNumEntries;
} TS_BITMAPCACHE_ERROR_INFO, FAR *PTS_BITMAPCACHE_ERROR_INFO;

typedef struct
{
    // Contains TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU as the secondary
    // PDU type.
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT8 NumInfoBlocks;

    TSUINT8  Pad1;
    TSUINT16 Pad2;

    TS_BITMAPCACHE_ERROR_INFO Info[1];
} TS_BITMAPCACHE_ERROR_PDU, FAR *PTS_BITMAPCACHE_ERROR_PDU;


/****************************************************************************/
// TS_OFFSCRCACHE_ERROR_PDU
/****************************************************************************/
typedef struct
{
    // Contains TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_OFFSCREEN    0x1

} TS_OFFSCRCACHE_ERROR_PDU, FAR *PTS_OFFSCRCACHE_ERROR_PDU;

#ifdef DRAW_NINEGRID
/****************************************************************************/
// TS_DRAWNINEGRID_ERROR_PDU
/****************************************************************************/
typedef struct
{
    // Contains TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_DRAWNINEGRID    0x1

} TS_DRAWNINEGRID_ERROR_PDU, FAR *PTS_DRAWNINEGRID_ERROR_PDU;
#endif

#ifdef DRAW_GDIPLUS
typedef struct
{
    // Contains TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_DRAWGDIPLUS    0x1

} TS_DRAWGDIPLUS_ERROR_PDU, FAR *PTS_DRAWGDIPLUS_ERROR_PDU;
#endif


/****************************************************************************/
// TS_COLORTABLECACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_COLORTABLECACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 colorTableCacheSize;
    TSUINT16 pad2octets;                          /* caps are DWORD aligned */
} TS_COLORTABLECACHE_CAPABILITYSET, FAR * PTS_COLORTABLECACHE_CAPABILITYSET;


/****************************************************************************/
// TS_WINDOWACTIVATION_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_WINDOWACTIVATION_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSBOOL16 helpKeyFlag;
    TSBOOL16 helpKeyIndexFlag;
    TSBOOL16 helpExtendedKeyFlag;
    TSBOOL16 windowManagerKeyFlag;
} TS_WINDOWACTIVATION_CAPABILITYSET, FAR * PTS_WINDOWACTIVATION_CAPABILITYSET;


/****************************************************************************/
// TS_CONTROL_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_CONTROL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 controlFlags;
#define TS_CAPS_CONTROL_ALLOWMEDIATEDCONTROL 1

    TSBOOL16 remoteDetachFlag;
    TSUINT16 controlInterest;
#define TS_CONTROLPRIORITY_ALWAYS    1
#define TS_CONTROLPRIORITY_NEVER     2
#define TS_CONTROLPRIORITY_CONFIRM   3

    TSUINT16 detachInterest;
} TS_CONTROL_CAPABILITYSET, FAR * PTS_CONTROL_CAPABILITYSET;


/****************************************************************************/
// TS_POINTER_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_POINTER_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSBOOL16 colorPointerFlag;
    TSUINT16 colorPointerCacheSize;
    TSUINT16 pointerCacheSize;
} TS_POINTER_CAPABILITYSET, FAR * PTS_POINTER_CAPABILITYSET;


/****************************************************************************/
// TS_SHARE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_SHARE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 nodeID;
    TSUINT16 pad2octets;                          /* caps are DWORD aligned */
} TS_SHARE_CAPABILITYSET, FAR * PTS_SHARE_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_SOUND_CAPABILITYSET                                        */
/*                                                                          */
/* Description: Extension to T.128 for sound support                        */
/*                                                                          */
/* Set TS_SOUND_FLAG_BEEPS if capable of replaying beeps                    */
/* all undefined bits in soundFlags must be zero                            */
/****************************************************************************/
typedef struct tagTS_SOUND_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 soundFlags;
#define TS_SOUND_FLAG_BEEPS 0x0001

    TSUINT16 pad2octetsA;
} TS_SOUND_CAPABILITYSET, FAR * PTS_SOUND_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_INPUT_CAPABILITYSET                                        */
/*                                                                          */
/* Description: Extension to T.128 for input support                        */
/****************************************************************************/
typedef struct tagTS_INPUT_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 inputFlags;
    /************************************************************************/
    /* If TS_INPUT_FLAG_SCANCODES is set, it should be interpreted as 'this */
    /* party understands TS_INPUT_EVENT_SCANCODE'.  When all parties in a   */
    /* call support scancodes, scancodes should be sent in preference to    */
    /* codepoints, virtual keys or hotkeys.                                 */
    /************************************************************************/
#define TS_INPUT_FLAG_SCANCODES      0x0001
    /************************************************************************/
    /* If TS_INPUT_FLAG_CPVK is set, it should be interpreted as 'this      */
    /* party understands TS_INPUT_EVENT_CODEPOINT and                       */
    /* TS_INPUT_EVENT_VIRTUALKEY'                                           */
    /************************************************************************/
#define TS_INPUT_FLAG_CPVK           0x0002
    /************************************************************************/
    /* If TS_INPUT_FLAG_MOUSEX is set, it should be interpreted as 'this    */
    /* party can send or receive TS_INPUT_EVENT_MOUSEX'                     */
    /************************************************************************/
#define TS_INPUT_FLAG_MOUSEX         0x0004
    //
    // Specifies server support for fast-path input packets.
    // Deprecated because of an encryption security bug which affects input
    // packets
    //
#define TS_INPUT_FLAG_FASTPATH_INPUT 0x0008
    // Server support for receiving injected Unicode input from the client
#define TS_INPUT_FLAG_VKPACKET       0x0010
    //
    // New style fast path input identifier added to allow new clients that
    // have safe (fixed) encryption checksumming to use fastpath, all old clients
    // have to use slow path as that is unaffected by the security bug
    //
#define TS_INPUT_FLAG_FASTPATH_INPUT2 0x0020

    TSUINT16 pad2octetsA;
    TSUINT32 keyboardLayout;
    TSUINT32 keyboardType;
    TSUINT32 keyboardSubType;
    TSUINT32 keyboardFunctionKey;
    TSUINT16 imeFileName[TS_MAX_IMEFILENAME]; /* Unicode string, ASCII only */
} TS_INPUT_CAPABILITYSET, FAR * PTS_INPUT_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_FONT_CAPABILITYSET                                         */
/*                                                                          */
/* Description: Fontlist/map support                                        */
/****************************************************************************/
typedef struct tagTS_FONT_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

#define TS_FONTSUPPORT_FONTLIST 0x0001

    TSUINT16 fontSupportFlags;
    TSUINT16 pad2octets;
} TS_FONT_CAPABILITYSET, FAR * PTS_FONT_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_CACHE_DEFINITION                                           */
/*                                                                          */
/* Description: Extension to T.128 for glyph cache support                  */
/****************************************************************************/
typedef struct tagTS_CACHE_DEFINITION
{
    TSUINT16 CacheEntries;
    TSUINT16 CacheMaximumCellSize;
} TS_CACHE_DEFINITION, FAR * PTS_CACHE_DEFINITION;


/****************************************************************************/
// TS_GLYPHCACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_GLYPHCACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TS_CACHE_DEFINITION GlyphCache[TS_MAX_GLYPH_CACHES];
    TS_CACHE_DEFINITION FragCache;

    TSUINT16            GlyphSupportLevel;
    TSUINT16            pad2octets;
} TS_GLYPHCACHE_CAPABILITYSET, FAR * PTS_GLYPHCACHE_CAPABILITYSET;


/****************************************************************************/
// TS_BRUSH_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BRUSH_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

#define TS_BRUSH_DEFAULT    0x0000
#define TS_BRUSH_COLOR8x8   0x0001
#define TS_BRUSH_COLOR_FULL 0x0002

    TSUINT32 brushSupportLevel;
} TS_BRUSH_CAPABILITYSET, FAR * PTS_BRUSH_CAPABILITYSET;


/****************************************************************************/
// Structure: TS_OFFSCREEN_CAPABILITYSET                                        
//   
// This is the capability set for the offscreen bitmap support
/****************************************************************************/
typedef struct tagTS_OFFSCREEN_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 offscreenSupportLevel;
#define TS_OFFSCREEN_DEFAULT     0x0000
#define TS_OFFSCREEN_SUPPORTED   0x0001
    
    // Unlike memory bitmap cache which has fixed bitmap cache entry size,
    // offscreen bitmap size varies depending on the apps.  So, we want to
    // allow both entries and cache size be to adjustable
    TSUINT16 offscreenCacheSize;

    // in KB, 2.5 MB cache memory for 8bpp, 5 MB for 16bpp, 7.5 MB for 24bpp
#define TS_OFFSCREEN_CACHE_SIZE_CLIENT_DEFAULT    (2560)    
#define TS_OFFSCREEN_CACHE_SIZE_SERVER_DEFAULT    (2560 * 3)

    TSUINT16 offscreenCacheEntries;
#define TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT 100     // 100 cache entries

} TS_OFFSCREEN_CAPABILITYSET, FAR * PTS_OFFSCREEN_CAPABILITYSET;

#ifdef DRAW_GDIPLUS
typedef struct tagTS_GDIPLUS_CACHE_ENTRIES
{
    TSUINT16 GdipGraphicsCacheEntries;
#define TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT  10
    TSUINT16 GdipObjectBrushCacheEntries;
#define TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT  5
    TSUINT16 GdipObjectPenCacheEntries;
#define TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT  5
    TSUINT16 GdipObjectImageCacheEntries;
#define TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT  10
    TSUINT16 GdipObjectImageAttributesCacheEntries;
#define TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT  2
} TS_GDIPLUS_CACHE_ENTRIES, FAR *PTS_GDIPLUS_CACHE_ENTRIES;

typedef struct tagTS_GDIPLUS_CACHE_CHUNK_SIZE
{
    TSUINT16 GdipGraphicsCacheChunkSize;
#define TS_GDIP_GRAPHICS_CACHE_CHUNK_SIZE_DEFAULT 512
    TSUINT16 GdipObjectBrushCacheChunkSize;
#define TS_GDIP_BRUSH_CACHE_CHUNK_SIZE_DEFAULT 2*1024
    TSUINT16 GdipObjectPenCacheChunkSize;
#define TS_GDIP_PEN_CACHE_CHUNK_SIZE_DEFAULT 1024
    TSUINT16 GdipObjectImageAttributesCacheChunkSize;
#define TS_GDIP_IMAGEATTRIBUTES_CACHE_CHUNK_SIZE_DEFAULT 64
} TS_GDIPLUS_CACHE_CHUNK_SIZE, FAR * PTS_GDIPLUS_CACHE_CHUNK_SIZE;

typedef struct tag_TS_GDIPLUS_IMAGE_CACHE_PROPERTIES
{
    TSUINT16 GdipObjectImageCacheChunkSize;
#define TS_GDIP_IMAGE_CACHE_CHUNK_SIZE_DEFAULT 4*1024
    TSUINT16 GdipObjectImageCacheTotalSize;
#define TS_GDIP_IMAGE_CACHE_TOTAL_SIZE_DEFAULT 256 // In number of chunks
    TSUINT16 GdipObjectImageCacheMaxSize;
#define TS_GDIP_IMAGE_CACHE_MAX_SIZE_DEFAULT 128 //  In number of chunks
} TS_GDIPLUS_IMAGE_CACHE_PROPERTIES, FAR * PTS_GDIPLUS_IMAGE_CACHE_PROPERTIES;

typedef struct tagTS_DRAW_GDIPLUS_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 drawGdiplusSupportLevel;
#define TS_DRAW_GDIPLUS_DEFAULT     0x0000
#define TS_DRAW_GDIPLUS_SUPPORTED   0x0001
    TSUINT32 GdipVersion;
#define TS_GDIPVERSION_DEFAULT 0x0
    TSUINT32 drawGdiplusCacheLevel;
#define TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT 0x0
#define TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE     0x1
    TS_GDIPLUS_CACHE_ENTRIES GdipCacheEntries;
    TS_GDIPLUS_CACHE_CHUNK_SIZE GdipCacheChunkSize;
    TS_GDIPLUS_IMAGE_CACHE_PROPERTIES GdipImageCacheProperties;
} TS_DRAW_GDIPLUS_CAPABILITYSET, FAR * PTS_DRAW_GDIPLUS_CAPABILITYSET;

#define ActualSizeToChunkSize(Size, ChunkSize) (((Size) + (ChunkSize - 1)) / ChunkSize)
#endif // DRAW_GDIPLUS

#ifdef DRAW_NINEGRID
/****************************************************************************/
// Structure: TS_DRAW_NINEGRID_CAPABILITYSET                                        
//   
// This is the capability set for the draw ninegrid support
/****************************************************************************/
typedef struct tagTS_DRAW_NINEGRID_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 drawNineGridSupportLevel;
#define TS_DRAW_NINEGRID_DEFAULT     0x0000
#define TS_DRAW_NINEGRID_SUPPORTED   0x0001
#define TS_DRAW_NINEGRID_SUPPORTED_REV2   0x0002
    
    // Unlike memory bitmap cache which has fixed bitmap cache entry size,
    // drawninegrid bitmap size varies.  So, we want to allow both entries 
    // and cache size be to adjustable
    TSUINT16 drawNineGridCacheSize;
#define TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT    2560    // in KB, 2.5 MB cache memory

    TSUINT16 drawNineGridCacheEntries;
#define TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT 256     // 256 cache entries

} TS_DRAW_NINEGRID_CAPABILITYSET, FAR * PTS_DRAW_NINEGRID_CAPABILITYSET;
#endif

/****************************************************************************/
// Structure: TS_VIRTUALCHANNEL_CAPABILITYSET                                        
//   
// This is the capability set for virtual channels
/****************************************************************************/
typedef struct tagTS_VIRTUALCHANNEL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    //
    // Server and client may adverise different capabilities
    // e.g today for scalability reasons C->S is limited to 8K
    // but S->C is 64K
    //
    //
#define TS_VCCAPS_DEFAULT                 0x0000
#define TS_VCCAPS_COMPRESSION_64K         0x0001
#define TS_VCCAPS_COMPRESSION_8K          0x0002
    TSUINT32 vccaps1;
} TS_VIRTUALCHANNEL_CAPABILITYSET, FAR * PTS_VIRTUALCHANNEL_CAPABILITYSET;

/****************************************************************************/
// TS_COMBINED_CAPABILITIES
/****************************************************************************/
typedef struct tagTS_COMBINED_CAPABILITIES
{
    TSUINT16 numberCapabilities;
    TSUINT16 pad2octets;
    TSUINT8  data[1];
} TS_COMBINED_CAPABILITIES, FAR * PTS_COMBINED_CAPABILITIES;


/****************************************************************************/
// TS_CAPABILITYHEADER
/****************************************************************************/
typedef struct tagTS_CAPABILITYHEADER
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
} TS_CAPABILITYHEADER, FAR * PTS_CAPABILITYHEADER;


/****************************************************************************/
// TS_FONT_ATTRIBUTE
/****************************************************************************/
typedef struct tagTS_FONT_ATTRIBUTE
{
    TSUINT8  faceName[TS_MAX_FACENAME];
    TSUINT16 fontAttributeFlags;
#define TS_FONTFLAGS_FIXED_PITCH       0x0001
#define TS_FONTFLAGS_FIXED_SIZE        0x0002
#define TS_FONTFLAGS_ITALIC            0x0004
#define TS_FONTFLAGS_UNDERLINE         0x0008
#define TS_FONTFLAGS_STRIKEOUT         0x0010
#define TS_FONTFLAGS_TRUETYPE          0x0080
#define TS_FONTFLAGS_BASELINE          0x0100
#define TS_FONTFLAGS_UNICODE_COMPLIANT 0x0200
// Cell Height (rather than default Character Height) support.
#define TS_FONTFLAGS_CELLHEIGHT        0x0400

    TSUINT16 averageWidth;
    TSUINT16 height;
    TSUINT16 aspectX;
    TSUINT16 aspectY;
    TSUINT8  signature1;
#define TS_SIZECALCULATION_HEIGHT 100
#define TS_SIZECALCULATION_WIDTH  100
#define TS_SIG1_RANGE1_FIRST      0x30
#define TS_SIG1_RANGE1_LAST       0x5A
#define TS_SIG1_RANGE2_FIRST      0x24
#define TS_SIG1_RANGE2_LAST       0x26

    TSUINT8  signature2;
#define TS_SIG2_RANGE_FIRST       0x20
#define TS_SIG2_RANGE_LAST        0x7E

    TSUINT16 signature3;
#define TS_SIG3_RANGE1_FIRST      0x00
#define TS_SIG3_RANGE1_LAST       0x1E
#define TS_SIG3_RANGE2_FIRST      0x80
#define TS_SIG3_RANGE2_LAST       0xFE

    TSUINT16 codePage;
#define TS_CODEPAGE_ALLCODEPOINTS  0
#define TS_CODEPAGE_CORECODEPOINTS 255

    TSUINT16 ascent;
} TS_FONT_ATTRIBUTE, FAR *PTS_FONT_ATTRIBUTE;


/****************************************************************************/
// TS_KEYBOARD_EVENT
//
// See also the fast-path keyboard format specified below.
/****************************************************************************/
typedef struct tagTS_KEYBOARD_EVENT
{
    TSUINT16 keyboardFlags;
#define TS_KBDFLAGS_RIGHT           0x0001
#define TS_KBDFLAGS_QUIET           0x1000
#define TS_KBDFLAGS_DOWN            0x4000
#define TS_KBDFLAGS_RELEASE         0x8000

#define TS_KBDFLAGS_SECONDARY       0x0080
#define TS_KBDFLAGS_EXTENDED        0x0100
#define TS_KBDFLAGS_EXTENDED1       0x0200
#define TS_KBDFLAGS_ALT_DOWN        0x2000

    TSUINT16 keyCode;
    TSUINT16 pad2octets;
} TS_KEYBOARD_EVENT, FAR *PTS_KEYBOARD_EVENT;


/****************************************************************************/
// TS_SYNC_EVENT
//
// Sets toggle keys on server.
// See also the fast-path sync format specified below.
/****************************************************************************/
typedef struct tagTS_SYNC_EVENT
{
    TSUINT16 pad2octets;
    TSUINT32 toggleFlags;
#define TS_SYNC_KANA_LOCK     8
#define TS_SYNC_CAPS_LOCK     4
#define TS_SYNC_NUM_LOCK      2
#define TS_SYNC_SCROLL_LOCK   1

} TS_SYNC_EVENT, FAR *PTS_SYNC_EVENT;


/****************************************************************************/
// TS_POINTER_EVENT
//
// See also the fast-path mouse format specified below.
/****************************************************************************/
typedef struct tagTS_POINTER_EVENT
{
    TSUINT16 pointerFlags;

// Extensions for wheel-mouse support.
#define TS_FLAG_MOUSE_WHEEL         ((TSUINT16)0x0200)
#define TS_FLAG_MOUSE_DIRECTION     ((TSUINT16)0x0100)
#define TS_FLAG_MOUSE_ROTATION_MASK ((TSUINT16)0x01FF)
#define TS_FLAG_MOUSE_DOUBLE        ((TSUINT16)0x0400)

#define TS_FLAG_MOUSE_MOVE          ((TSUINT16)0x0800)
#define TS_FLAG_MOUSE_BUTTON1       ((TSUINT16)0x1000)
#define TS_FLAG_MOUSE_BUTTON2       ((TSUINT16)0x2000)
#define TS_FLAG_MOUSE_BUTTON3       ((TSUINT16)0x4000)
#define TS_FLAG_MOUSE_DOWN          ((TSUINT16)0x8000)

#define TS_FLAG_MOUSEX_BUTTON1      ((TSUINT16)0x0001)
#define TS_FLAG_MOUSEX_BUTTON2      ((TSUINT16)0x0002)
#define TS_FLAG_MOUSEX_DOWN         ((TSUINT16)0x8000)

    TSINT16  x;
    TSINT16  y;
} TS_POINTER_EVENT, FAR *PTS_POINTER_EVENT;


/****************************************************************************/
// TS_INPUT_EVENT
//
// See also the fast-path input event formats specified below.
/****************************************************************************/
typedef struct tagTS_INPUT_EVENT
{
    TSUINT32 eventTime;
    TSUINT16 messageType;
#define TS_INPUT_EVENT_SYNC            0
#define TS_INPUT_EVENT_CODEPOINT       1
#define TS_INPUT_EVENT_VIRTUALKEY      2
#define TS_INPUT_EVENT_HOTKEY          3
// Indicates client sends all keyboard input as raw scan codes.
#define TS_INPUT_EVENT_SCANCODE        4
// Indivates support for VKPACKET input. This is the same format
// as TS_INPUT_EVENT_SCANCODE but the meaning is interpreted
// differently - scancode is a unicode character
//
#define TS_INPUT_EVENT_VKPACKET        5
#define TS_INPUT_EVENT_MOUSE      0x8001
// MOUSEX allows us to support extended mouse buttons
// It still implies TS_POINTER_EVENT, but with different flag meanings
#define TS_INPUT_EVENT_MOUSEX     0x8002

    union
    {
        TS_KEYBOARD_EVENT key;
        TS_POINTER_EVENT  mouse;
        TS_SYNC_EVENT     sync;
    } u;
} TS_INPUT_EVENT, FAR * PTS_INPUT_EVENT;


/****************************************************************************/
// TS_INPUT_PDU
//
// Variable length list of TS_INPUT_EVENTs.
// See also the fast-path input format specified below.
/****************************************************************************/
typedef struct tagTS_INPUT_PDU
{
    TS_SHAREDATAHEADER       shareDataHeader;
    TSUINT16                 numberEvents;
    TSUINT16                 pad2octets;
    TS_INPUT_EVENT           eventList[1];
} TS_INPUT_PDU, FAR * PTS_INPUT_PDU;

// Sizes are for an InputPDU with 0 events attached.
#define TS_INPUTPDU_SIZE (sizeof(TS_INPUT_PDU) - sizeof(TS_INPUT_EVENT))
#define TS_INPUTPDU_UNCOMP_LEN  8


/****************************************************************************/
// Fast-path input codes. Fast-path input is designed to reduce the wire
// overhead of all the regular input PDU headers, by collapsing all the
// headers -- including X.224, MCS, encryption, share data, and input --
// into a bit-packed, optimized bytestream. Total win for a single keydown or
// keyup: before = 60 bytes, after = 12 bytes, an 80% decrease.
//
// Fast-path bytestream format:
//
// +--------+------+---------------+-----------+--------+
// | Header | Size | MAC signature | NumEvents | Events |
// +--------+------+---------------+-----------+--------+
//
// Header: Byte 0. This byte coincides with X.224 RFC1006 header byte 0,
//     which is always 0x03. In fastpath, we collapse three pieces of
//     information into this byte, 2 bits for security, 2 bits for
//     the action (to tell the difference between X.224 and other
//     actions), and 4 bits for a NumEvents field, which holds the
//     number of input events in the packet if in the range 1..15,
//     or 0 if we have a NumEvents field later on.
//
// Size: Overall packet length, first byte. The high bit determines
//     what the size of the size field is -- high bit 0 means the size
//     field is the low 7 bits, giving a range 0..127. High bit 1 means
//     the size field is the low 7 bits of this byte, plus the 8 bits of
//     the next byte, in big-endian order (the second byte contains the
//     low-order bits). This encoding scheme is based on ASN.1 PER
//     encoding used in MCS.
//
// Encryption signature: 8 bytes for encryption MAC signature of the
//     encrypted payload.
//
// NumEvents: If the header byte NumEvents is 0, there is a 1-byte field
//     here containing up to 256 for NumEvents.
//
// Bytestream input events: These correspond to the same event types already
//     defined for TS_INPUT_EVENT above, optimized for small size.
//     In each of the events following, there is at least one byte, where
//     the high 3 bits are the event type, and the bottom 5 bits are flags.
//     Additionally, each order type can use a defined number of extra bytes.
//     Descriptions of the event formats follow.
//
//     Keyboard: 2 bytes. Byte 0 contains the event type, plus special
//             extended and release flags. Byte 1 is the scan code.
//     Mouse: 7 bytes. Byte 0 contains only the event type. Bytes 1-6 contain
//             the same contents as a normal TS_POINTER_EVENT.
//     Sync: 1 byte. Byte 0 is the event type plus the regular sync flags.
/****************************************************************************/
    
// Masks for first-byte bits.
#define TS_INPUT_FASTPATH_ACTION_MASK     0x03
#define TS_INPUT_FASTPATH_NUMEVENTS_MASK  0x3C
#define TS_INPUT_FASTPATH_ENCRYPTION_MASK 0xC0

// Encryption settings
#define TS_INPUT_FASTPATH_ENCRYPTED       0x80
//
// Encrypted checksum packet
//
#define TS_INPUT_FASTPATH_SECURE_CHECKSUM 0x40

// 2 values here for future expansion.
#define TS_INPUT_FASTPATH_ACTION_FASTPATH 0x0
#define TS_INPUT_FASTPATH_ACTION_X224     0x3

// Event mask and type for each event in input.
// Event is encoded into high 3 bits of first byte.
// 4 values here for future expansion.
#define TS_INPUT_FASTPATH_EVENT_MASK     0xE0
#define TS_INPUT_FASTPATH_FLAGS_MASK     0x1F
#define TS_INPUT_FASTPATH_EVENT_KEYBOARD 0x00
#define TS_INPUT_FASTPATH_EVENT_MOUSE    0x20
#define TS_INPUT_FASTPATH_EVENT_MOUSEX   0x40
#define TS_INPUT_FASTPATH_EVENT_SYNC     0x60
#define TS_INPUT_FASTPATH_EVENT_VKPACKET 0x80

// Fastpath keyboard flags. These are set to be the same values as the server
// driver KEY_BREAK, KEY_E0, and KEY_E1 to simplify translation to kernel
// input event.
#define TS_INPUT_FASTPATH_KBD_RELEASE   0x01
#define TS_INPUT_FASTPATH_KBD_EXTENDED  0x02
#define TS_INPUT_FASTPATH_KBD_EXTENDED1 0x04


/****************************************************************************/
/* Structure: TS_CONFIRM_ACTIVE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_CONFIRM_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              originatorID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT16              lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8               data[1];
} TS_CONFIRM_ACTIVE_PDU, FAR * PTS_CONFIRM_ACTIVE_PDU;


/****************************************************************************/
/* Size of Confirm Active without the data. 6 is the 3 UINT16's.            */
/****************************************************************************/
#define TS_CA_NON_DATA_SIZE (sizeof(TS_SHARECONTROLHEADER) + \
                            sizeof(TS_SHAREID) + 6)


/****************************************************************************/
/* Structure: TS_DEMAND_ACTIVE_PDU                                          */
/****************************************************************************/
typedef struct tagTS_DEMAND_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT16              lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8               data[1];
} TS_DEMAND_ACTIVE_PDU, FAR * PTS_DEMAND_ACTIVE_PDU;


/****************************************************************************/
/* Structure: TS_SERVER_CERTIFICATE_PDU                                     */
/*                                                                          */
/* Description: Used during shadowing to send the target server's cert +    */
/*              random to the client server.                                */
/****************************************************************************/
typedef struct tagTS_SERVER_CERTIFICATE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TSUINT16              pad1;
    TSUINT32              encryptionMethod;
    TSUINT32              encryptionLevel;
    TSUINT32              shadowRandomLen;
    TSUINT32              shadowCertLen;

    // server random followed by server cert start here
    TSUINT8               data[1];
} TS_SERVER_CERTIFICATE_PDU, FAR * PTS_SERVER_CERTIFICATE_PDU;


/****************************************************************************/
/* Structure: TS_CLIENT_RANDOM_PDU                                          */
/*                                                                          */
/* Description: Used during shadowing to send the client's encrypted random */
/*              back to the shadow target server.                           */
/****************************************************************************/
typedef struct tagTS_CLIENT_RANDOM_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TSUINT16              pad1;
    TSUINT32              clientRandomLen;

    // client random starts here
    TSUINT8               data[1];
} TS_CLIENT_RANDOM_PDU, FAR * PTS_CLIENT_RANDOM_PDU;


/****************************************************************************/
/* Structure: TS_REQUEST_ACTIVE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_REQUEST_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER    shareControlHeader;
    TSUINT16                 lengthSourceDescriptor;
    TSUINT16                 lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8                  data[1];
} TS_REQUEST_ACTIVE_PDU, FAR * PTS_REQUEST_ACTIVE_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_ALL_PDU                                         */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_ALL_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT8               sourceDescriptor[1];
} TS_DEACTIVATE_ALL_PDU, FAR * PTS_DEACTIVATE_ALL_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_OTHER_PDU                                       */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_OTHER_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              deactivateID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT8               sourceDescriptor[1];
} TS_DEACTIVATE_OTHER_PDU, FAR * PTS_DEACTIVATE_OTHER_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_SELF_PDU                                        */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_SELF_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
} TS_DEACTIVATE_SELF_PDU, FAR * PTS_DEACTIVATE_SELF_PDU;


/****************************************************************************/
/* Structure: TS_SYNCHRONIZE_PDU                                            */
/****************************************************************************/
typedef struct tagTS_SYNCHRONIZE_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           messageType;
#define TS_SYNCMSGTYPE_SYNC  1

    TSUINT16           targetUser;
} TS_SYNCHRONIZE_PDU, FAR * PTS_SYNCHRONIZE_PDU;
#define TS_SYNC_PDU_SIZE sizeof(TS_SYNCHRONIZE_PDU)
#define TS_SYNC_UNCOMP_LEN 8


/****************************************************************************/
/* Structure: TS_CONTROL_PDU                                                */
/****************************************************************************/
typedef struct tagTS_CONTROL_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           action;
#define TS_CTRLACTION_FIRST            1
#define TS_CTRLACTION_REQUEST_CONTROL  1
#define TS_CTRLACTION_GRANTED_CONTROL  2
#define TS_CTRLACTION_DETACH           3
#define TS_CTRLACTION_COOPERATE        4
#define TS_CTRLACTION_LAST             4

    TSUINT16           grantId;
    TSUINT32           controlId;
} TS_CONTROL_PDU, FAR * PTS_CONTROL_PDU;
#define TS_CONTROL_PDU_SIZE sizeof(TS_CONTROL_PDU)
#define TS_CONTROL_UNCOMP_LEN 12


/****************************************************************************/
/* Structure: TS_FLOW_PDU                                                   */
/****************************************************************************/
typedef struct tagTS_FLOW_PDU
{
    TSUINT16 flowMarker;
#define TS_FLOW_MARKER        0x8000

    TSUINT16 pduType;              /* also includes protocol version     */
#define TS_PDUTYPE_FLOWTESTPDU                     65
#define TS_PDUTYPE_FLOWRESPONSEPDU                 66
#define TS_PDUTYPE_FLOWSTOPPDU                     67

    TSUINT8  flowIdentifier;
#define TS_MAX_FLOWIDENTIFIER 127

    TSUINT8  flowNumber;
    TSUINT16 pduSource;
} TS_FLOW_PDU, FAR * PTS_FLOW_PDU;
#define TS_FLOW_PDU_SIZE sizeof(TS_FLOW_PDU)


/****************************************************************************/
/* Structure: TS_FONT_PDU                                                   */
/****************************************************************************/
typedef struct tagTS_FONT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           numberFonts;
    TSUINT16           entrySize;
    TS_FONT_ATTRIBUTE  fontList[1];
} TS_FONT_PDU, FAR * PTS_FONT_PDU;


/****************************************************************************/
/* Structure: TS_FONT_LIST_PDU                                              */
/****************************************************************************/
typedef struct tagTS_FONT_LIST_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT16           numberFonts;
    TSUINT16           totalNumFonts;

#define TS_FONTLIST_FIRST       0x0001
#define TS_FONTLIST_LAST        0x0002
    TSUINT16           listFlags;
    TSUINT16           entrySize;
    TS_FONT_ATTRIBUTE  fontList[1];
} TS_FONT_LIST_PDU, FAR * PTS_FONT_LIST_PDU;


/****************************************************************************/
/* Structure: TS_FONTTABLE_ENTRY                                            */
/****************************************************************************/
typedef struct tagTS_FONTTABLE_ENTRY
{
    TSUINT16 serverFontID;
    TSUINT16 clientFontID;
} TS_FONTTABLE_ENTRY, FAR * PTS_FONTTABLE_ENTRY;


/****************************************************************************/
/* Structure: TS_FONT_MAP_PDU                                               */
/*                                                                          */
/* Description: Font mapping table (sent from server to client)             */
/****************************************************************************/
typedef struct tagTS_FONT_MAP_PDU_DATA
{
    TSUINT16 numberEntries;
    TSUINT16 totalNumEntries;

#define TS_FONTMAP_FIRST        0x0001
#define TS_FONTMAP_LAST         0x0002
    TSUINT16 mapFlags;
    TSUINT16 entrySize;
    TS_FONTTABLE_ENTRY fontTable[1];
} TS_FONT_MAP_PDU_DATA, FAR * PTS_FONT_MAP_PDU_DATA;

typedef struct tagTS_FONT_MAP_PDU
{
    TS_SHAREDATAHEADER   shareDataHeader;
    TS_FONT_MAP_PDU_DATA data;
} TS_FONT_MAP_PDU, FAR * PTS_FONT_MAP_PDU;


/****************************************************************************/
// Fast-path output codes. Fast-path output is designed to reduce the wire
// overhead of all the server-to-client output "packages." These packages
// can contain one or more of the following PDU types, each of which is
// individually compressed (if compression is enabled):
//
//     Mouse pointers (TS_POINTER_PDU_DATA)
//     Output sync (No PDU body in fastpath version)
//     Orders (TS_UPDATE_ORDERS_PDU_DATA - fastpath version)
//     Screen data (TS_UPDATE_BITMAP_PDU_DATA)
//     Palettes (TS_UPDATE_PALETTE_PDU_DATA)
//
// The contents of the package can also be encrypted if high encryption
// is enabled.
//
// Fast-path output collapses a whole series of headers -- including X.224,
// MCS, encryption, and TS_SHAREDATAHEADERs included on each individual
// update PDU subpacket included in the package. It also defines a
// slightly different version of the original TS_UPDATE_XXX_PDU_DATA structs
// which optimize the TS_UPDATE_HDR space and combine the information
// into other headers in a bit-packed form.
//
// Fast-path bytestream format:
//
// +--------+------+---------------+-------------------------+
// | Header | Size | MAC signature | One or more update PDUs |
// +--------+------+---------------+-------------------------+
//
// Header: Byte 0. This byte coincides with X.224 RFC1006 header byte 0,
//     which is always 0x03. In fastpath, we collapse two pieces of
//     information into this byte, 2 bits for security, 2 bits for
//     the action (to tell the difference between X.224 and other
//     actions), and 4 bits currently unused but set to zero for possible
//     future use.
//
// Size: Overall packet length, first byte. The high bit determines
//     what the size of the size field is -- high bit 0 means the size
//     field is the low 7 bits, giving a range 0..127. High bit 1 means
//     the size field is the low 7 bits of this byte, plus the 8 bits of
//     the next byte, in big-endian order (the second byte contains the
//     low-order bits). This encoding scheme is based on ASN.1 PER
//     encoding used in MCS.
//
// Encryption signature: 8 bytes for encryption MAC signature of the
//     encrypted payload, if encryption enabled.
//
// Update PDU format:
//
// +--------+-------------------+------+-------------+
// | Header | Compression flags | Size | Update data |
// +--------+-------------------+------+-------------+
//
// Header: 1 byte. Contains two pieces of information, the update type
//     (TS_UPDATETYPE_XXX values) and a compression-used flag. If
//     compression-used is set, the next byte is a set of compression flags.
//
// Compression flags: Identical to the usage defined compress.h. Optional
//     byte -- if compression is not enabled on the session, it is not
//     included.
//
// Size: 2-byte size in little-endian (Intel) byte ordering. Fixed size
//     to allow update PDU header length to be determined before encoding
//     starting in the next byte after this field. Note that this is the
//     size of the data following this field -- if compression
//     is used the size is the compressed size.
//
// Update data: Formats as defined for individual PDUs. Some
//     formats match the non-fast-path formats for low-frequency packets,
//     others are special newer formats that collapse even more headers.
/****************************************************************************/

// Masks for first-byte bits.
#define TS_OUTPUT_FASTPATH_ACTION_MASK     0x03
#define TS_OUTPUT_FASTPATH_UNUSED_MASK     0x3C
#define TS_OUTPUT_FASTPATH_ENCRYPTION_MASK 0xC0

// Encryption flags
#define TS_OUTPUT_FASTPATH_ENCRYPTED       0x80
#define TS_OUTPUT_FASTPATH_SECURE_CHECKSUM 0x40

// 2 values here for future expansion.
#define TS_OUTPUT_FASTPATH_ACTION_FASTPATH 0x0
#define TS_OUTPUT_FASTPATH_ACTION_X224     0x3

// Masks and values for update PDU header byte.
// 11 values empty in update type field for future expansion of PDUs in
// packages. 1 extra bit available in compression flags for future
// expansion. 2 extra bits unused but available for future use.
#define TS_OUTPUT_FASTPATH_UPDATETYPE_MASK         0x0F
#define TS_OUTPUT_FASTPATH_UPDATE_COMPRESSION_MASK 0xC0
#define TS_OUTPUT_FASTPATH_COMPRESSION_USED        0x80


/****************************************************************************/
// TS_MONOPOINTERATTRIBUTE
/****************************************************************************/
typedef struct tagTS_MONOPOINTERATTRIBUTE
{
    TS_POINT16 hotSpot;
    TSUINT16   width;
    TSUINT16   height;
    TSUINT16   lengthPointerData;
    TSUINT8    monoPointerData[1];
} TS_MONOPOINTERATTRIBUTE, FAR * PTS_MONOPOINTERATTRIBUTE;


/****************************************************************************/
// TS_COLORPOINTERATTRIBUTE
//
// 24bpp color pointer.
/****************************************************************************/
typedef struct tagTS_COLORPOINTERATTRIBUTE
{
    TSUINT16   cacheIndex;
    TS_POINT16 hotSpot;
    TSUINT16   width;
    TSUINT16   height;
    TSUINT16   lengthANDMask;
    TSUINT16   lengthXORMask;
    TSUINT8    colorPointerData[1];
} TS_COLORPOINTERATTRIBUTE, FAR * PTS_COLORPOINTERATTRIBUTE;


/****************************************************************************/
// TS_POINTERATTRIBUTE
//
// Variable color depth pointer.
/****************************************************************************/
typedef struct tagTS_POINTERATTRIBUTE
{
    TSUINT16                 XORBpp;
    TS_COLORPOINTERATTRIBUTE colorPtrAttr;
} TS_POINTERATTRIBUTE, FAR * PTS_POINTERATTRIBUTE;


/****************************************************************************/
// TS_POINTER_PDU
//
// Container definition for various mouse pointer types.
// See also the fast-path output pointer definitions and types defined below.
/****************************************************************************/
typedef struct tagTS_POINTER_PDU_DATA
{
    TSUINT16 messageType;
#define TS_PTRMSGTYPE_SYSTEM      1
#define TS_PTRMSGTYPE_MONO        2
#define TS_PTRMSGTYPE_POSITION    3
#define TS_PTRMSGTYPE_COLOR       6
#define TS_PTRMSGTYPE_CACHED      7
#define TS_PTRMSGTYPE_POINTER     8

    TSUINT16 pad2octets;
    union
    {
        TSUINT32                 systemPointerType;
#define TS_SYSPTR_NULL    0
#define TS_SYSPTR_DEFAULT 0x7f00
        TS_MONOPOINTERATTRIBUTE  monoPointerAttribute;
        TS_COLORPOINTERATTRIBUTE colorPointerAttribute;
        TS_POINTERATTRIBUTE      pointerAttribute;
        TSUINT16                 cachedPointerIndex;
        TS_POINT16               pointerPosition;
    } pointerData;
} TS_POINTER_PDU_DATA, FAR * PTS_POINTER_PDU_DATA;

typedef struct tagTS_POINTER_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_POINTER_PDU_DATA data;
} TS_POINTER_PDU, FAR * PTS_POINTER_PDU;

#define TS_POINTER_PDU_SIZE sizeof(TS_POINTER_PDU)


/****************************************************************************/
// Fast-path output for mouse pointers - overview.
//
// We use the fast-path header packet type to contain the mouse pointer
// update type explicitly. This allows us to collapse headers inside the
// TS_POINTER_PDU definition. Following are format descriptions for each
// pointer update type:
//
// TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL: Replaces systemPointerType ==
//     TS_SYSPTR_NULL. Payload is zero bytes.
//
// TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT: Replaces systemPointerType ==
//     TS_SYSPTR_DEFAULT. Zero-byte payload.
//
// TS_UPDATETYPE_MOUSEPTR_MONO: Payload is TS_MONOPOINTERATTRIBUTE.
//
// TS_UPDATETYPE_MOUSEPTR_POSITION: Payload is a TS_POINT16.
//
// TS_UPDATETYPE_MOUSEPTR_COLOR: Payload is TS_COLORPOINTERATTRIBUTE.
//
// TS_UPDATETYPE_MOUSEPTR_CACHED: Payload is TSUINT16 cachedPointerIndex.
//
// TS_UPDATETYPE_MOUSEPTR_POINTER: Payload is TS_POINTERATTRIBUTE.
/****************************************************************************/


/****************************************************************************/
// Update types, used by TS_UPDATE_HDR and fast-path output.
/****************************************************************************/
#define TS_UPDATETYPE_ORDERS        0
#define TS_UPDATETYPE_BITMAP        1
#define TS_UPDATETYPE_PALETTE       2
#define TS_UPDATETYPE_SYNCHRONIZE   3

// Fast-path-only mouse pointer types, see fast-path output pointer
// description above.
#define TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL    5
#define TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT 6
#define TS_UPDATETYPE_MOUSEPTR_MONO           7
#define TS_UPDATETYPE_MOUSEPTR_POSITION       8
#define TS_UPDATETYPE_MOUSEPTR_COLOR          9
#define TS_UPDATETYPE_MOUSEPTR_CACHED         10
#define TS_UPDATETYPE_MOUSEPTR_POINTER        11


/****************************************************************************/
/* Structure: TS_UPDATE_HDR                                                 */
/****************************************************************************/
typedef struct tagTS_UPDATE_HDR_DATA
{
    TSUINT16 updateType;
    TSUINT16 pad2octets;
} TS_UPDATE_HDR_DATA, FAR * PTS_UPDATE_HDR_DATA;

typedef struct tagTS_UPDATE_HDR
{
    TS_SHAREDATAHEADER shareDataHeader;
    TS_UPDATE_HDR_DATA data;
} TS_UPDATE_HDR, FAR * PTS_UPDATE_HDR;


/****************************************************************************/
/* Structure: TS_BITMAP_DATA                                                */
/*                                                                          */
/* Description: Data for a single rectangle in a BitmapUpdatePDU            */
/* Note: bitsPerPixel is included for backwards compatibility, although it  */
/* is the same for every rectangle sent.                                    */
/****************************************************************************/
typedef struct tagTS_BITMAP_DATA
{
    TSINT16  destLeft;
    TSINT16  destTop;
    TSINT16  destRight;
    TSINT16  destBottom;
    TSUINT16 width;
    TSUINT16 height;
    TSUINT16 bitsPerPixel;
    TSBOOL16 compressedFlag;

    // Bit 1:  TS_BITMAP_COMPRESSION Bitmap data is compressed or not
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR indicates if the compressed
    //     bitmap data contains the redundant BC header or not. Note this
    //     value is defined in REV2 bitmap extraflags value for consistency.
#define TS_BITMAP_COMPRESSION 0x0001

    TSUINT16 bitmapLength;
    TSUINT8  bitmapData[1];            /* variable length field  */
} TS_BITMAP_DATA, FAR * PTS_BITMAP_DATA;


/****************************************************************************/
/* Structure: TS_UPDATE_BITMAP_PDU                                          */
/****************************************************************************/
typedef struct tagTS_UPDATE_BITMAP_PDU_DATA
{
    TSUINT16       updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16       numberRectangles;
    TS_BITMAP_DATA rectangle[1];
} TS_UPDATE_BITMAP_PDU_DATA, FAR * PTS_UPDATE_BITMAP_PDU_DATA;

typedef struct tagTS_UPDATE_BITMAP_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TS_UPDATE_BITMAP_PDU_DATA data;
} TS_UPDATE_BITMAP_PDU, FAR * PTS_UPDATE_BITMAP_PDU;

/****************************************************************************/
/* Structure: TS_UPDATE_CAPABILITYSET                                       */
/****************************************************************************/
typedef struct tagTS_UPDATE_CAPABILITYSET
{
    TS_BITMAP_CAPABILITYSET bitmapCapabilitySet;
} TS_UPDATE_CAPABILITYSET, FAR * PTS_UPDATE_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_UPDATE_CAPABILITY_PDU                                      */
/****************************************************************************/
typedef struct tagTS_UPDATE_CAPABILITY_PDU
{
    TS_SHAREDATAHEADER      shareDataHeader;
    TS_UPDATE_CAPABILITYSET updateCapabilitySet;
} TS_UPDATE_CAPABILITY_PDU, FAR * PTS_UPDATE_CAPABILITY_PDU;


/****************************************************************************/
// TS_UPDATE_ORDERS_PDU
//
// Variable size UpdateOrdersPDU.
// See also the fastpath version described below.
/****************************************************************************/
typedef struct tagTS_UPDATE_ORDERS_PDU_DATA
{
    TSUINT16 updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16 pad2octetsA;
    TSUINT16 numberOrders;
    TSUINT16 pad2octetsB;
    TSUINT8  orderList[1];
} TS_UPDATE_ORDERS_PDU_DATA, FAR * PTS_UPDATE_ORDERS_PDU_DATA;

typedef struct tagTS_UPDATE_ORDERS_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_UPDATE_ORDERS_PDU_DATA data;
} TS_UPDATE_ORDERS_PDU, FAR * PTS_UPDATE_ORDERS_PDU;


/****************************************************************************/
// TS_UPDATE_ORDERS_PDU_DATA - fast-path bytestream version
//
// Rather than waste 6 of the 8 header bytes in the TS_UPDATE_ORDERS_PDU_DATA
// (updateType is already known in the fastpath header), we simply define
// a new optimized version: numberOrders is a 2-byte little-endian (Intel)
// format field preceding the bytestream of encoded orders.
/****************************************************************************/


/****************************************************************************/
/* Structure: TS_COLOR                                                      */
/****************************************************************************/
typedef struct tagTS_COLOR
{
    TSUINT8 red;
    TSUINT8 green;
    TSUINT8 blue;
} TS_COLOR, FAR * PTS_COLOR;


/****************************************************************************/
/* Structure: TS_COLOR_QUAD                                                 */
/****************************************************************************/
typedef struct tagTS_COLOR_QUAD
{
    TSUINT8 red;
    TSUINT8 green;
    TSUINT8 blue;
    TSUINT8 pad1octet;
} TS_COLOR_QUAD, FAR * PTS_COLOR_QUAD;


/****************************************************************************/
// TS_ORDER_HEADER
//
// There are several types of orders available using this control flag byte.
// They include:
//
// Primary orders: Denoted by the lower two control bits 01 meaning
// TS_STANDARD but not TS_SECONDARY. Primary orders are field encoded
// using the OE2 encoding logic on the server and the OD logic on the
// client. See oe2.h in the server code for field encoding rules.
// The upper six bits of the control byte are used for further information
// about the field encoding.
//
// Secondary orders: Denoted by low 2 control bits 11 meaning TS_STANDARD |
// TS_SECONDARY. The upper 6 bits are not used. Followed by the next 5
// bytes of the TS_SECONDARY_ORDER_HEADER definition, then followed by
// order-specific data.
//
// Alternate secondary orders: Introduced in RDP 5.1, these orders are
// denoted by low 2 control bits 10, meaning TS_SECONDARY but not
// TS_STANDARD. The upper 6 bits are used to encode the order type; the
// order format following the control byte is order-specific but not field
// encoded. This order type was introduced to overcome the wastefulness
// inherent in the secondary order header, allowing nonstandard secondary
// orders to follow whatever form best suits the data being carried.
//
// Control flag low 2 bit value 00 is not used in RDP 4.0, 5.0, or 5.1,
// but is reserved for future use.
/****************************************************************************/

#define TS_STANDARD                   1
#define TS_SECONDARY                  2
#define TS_BOUNDS                     4
#define TS_TYPE_CHANGE                8
#define TS_DELTA_COORDINATES         16

// Indicates that there are zero modified bounds coordinates.
// Used in conjunction with the TS_BOUNDS flags, the presence of this flag
// means that there is no subsequent byte for the bounds fields (it would be
// zero).
#define TS_ZERO_BOUNDS_DELTAS        32

// T.128 extension: two bits that contain the number of consecutive
// field encoding bytes that are zero.  When these bits indicate that
// there are zero-value field bytes, the corresponding bytes are not
// sent.  The count is for consecutive zeros from the last byte
// scanning backwards (the non-zero bytes normally appear at the
// beginning).
//
// Example: order that has three field encoding bytes
//
// field encoding bytes: 0x20 0x00 0x00
//
// There are two zeros (counting from the end backwards), so the
// control flags contain 0x80 (0x02 << 6), and the order is sent with
// just 0x20.  We therefore save sending the two bytes.
#define TS_ZERO_FIELD_BYTE_BIT0      64
#define TS_ZERO_FIELD_BYTE_BIT1     128
#define TS_ZERO_FIELD_COUNT_SHIFT     6
#define TS_ZERO_FIELD_COUNT_MASK   0xC0

// Alternate secondary order mask and shift values for the order type.
#define TS_ALTSEC_ORDER_TYPE_MASK 0xFC
#define TS_ALTSEC_ORDER_TYPE_SHIFT 2

typedef struct tagTS_ORDER_HEADER
{
    TSUINT8 controlFlags;
} TS_ORDER_HEADER, FAR *PTS_ORDER_HEADER;


/****************************************************************************/
// TS_SECONDARY_ORDER_HEADER
/****************************************************************************/

#define TS_CACHE_BITMAP_UNCOMPRESSED      0
#define TS_CACHE_COLOR_TABLE              1
#define TS_CACHE_BITMAP_COMPRESSED        2
#define TS_CACHE_GLYPH                    3
#define TS_CACHE_BITMAP_UNCOMPRESSED_REV2 4
#define TS_CACHE_BITMAP_COMPRESSED_REV2   5
#define TS_STREAM_BITMAP                  6
#define TS_CACHE_BRUSH                    7

#define TS_NUM_SECONDARY_ORDERS           8

typedef struct tagTS_SECONDARY_ORDER_HEADER
{
    TS_ORDER_HEADER orderHdr;
    TSUINT16        orderLength;

    // This field was used in RDP 4.0 to hold TS_EXTRA_SECONDARY, but was
    // re-tasked to allow secondary orders to use these two bytes as encoding
    // bytes and flags.
    TSUINT16        extraFlags;

    TSUINT8         orderType;
} TS_SECONDARY_ORDER_HEADER, FAR *PTS_SECONDARY_ORDER_HEADER;


/****************************************************************************/
/* The calculation of the value to store in the orderLength field of        */
/* TS_SECONDARY_ORDER_HEADER is non-trivial.  Hence we provide some macros  */
/* to make life easier.                                                     */
/****************************************************************************/
#define TS_SECONDARY_ORDER_LENGTH_FUDGE_FACTOR  8

#define TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT                                \
                    (sizeof(TS_SECONDARY_ORDER_HEADER)  -                   \
                     FIELDSIZE(TS_SECONDARY_ORDER_HEADER, orderType) +      \
                     TS_SECONDARY_ORDER_LENGTH_FUDGE_FACTOR)

#define TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(actualOrderLength)         \
           ((actualOrderLength) - TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT)

#define TS_DECODE_SECONDARY_ORDER_ORDERLENGTH(secondaryOrderLength)         \
           ((secondaryOrderLength) + TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT)


/****************************************************************************/
// Alternate secondary order type values.
/****************************************************************************/
#define TS_ALTSEC_SWITCH_SURFACE           0
#define TS_ALTSEC_CREATE_OFFSCR_BITMAP     1

#ifdef DRAW_NINEGRID
#define TS_ALTSEC_STREAM_BITMAP_FIRST      2
#define TS_ALTSEC_STREAM_BITMAP_NEXT       3
#define TS_ALTSEC_CREATE_NINEGRID_BITMAP   4
#endif

#ifdef DRAW_GDIPLUS
#define TS_ALTSEC_GDIP_FIRST              5
#define TS_ALTSEC_GDIP_NEXT               6
#define TS_ALTSEC_GDIP_END                7

#define TS_ALTSEC_GDIP_CACHE_FIRST              8
#define TS_ALTSEC_GDIP_CACHE_NEXT               9
#define TS_ALTSEC_GDIP_CACHE_END                10
#endif // DRAW_GDIPLUS

#ifdef DRAW_GDIPLUS
#define TS_NUM_ALTSEC_ORDERS               11
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define TS_NUM_ALTSEC_ORDERS               5
#else
#define TS_NUM_ALTSEC_ORDERS               2
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS


/****************************************************************************/
/* Convert BPP to number of colors.                                         */
/****************************************************************************/
#ifdef DC_HICOLOR
/****************************************************************************/
/* This macro as it was doesn't cater for 15bpp.  Consider a 64 pel wide    */
/* bitmap at 15 and 16bpp.  It really has the same numner of bytes per scan */
/* line but this macro gives 128 for 16bpp and only 120 for 15bpp...        */
/****************************************************************************/
// WRONG: #define TS_BYTES_IN_SCANLINE(width, bpp) (((((width)*(bpp))+31)/32) * 4)
#define TS_BYTES_IN_SCANLINE(width, bpp) ((((width)*((((bpp)+3)/4)*4)+31)/32) * 4)
#else
#define TS_BYTES_IN_SCANLINE(width, bpp) (((((width)*(bpp))+31)/32) * 4)
#endif
#define TS_BYTES_IN_BITMAP(width, height, bpp) \
                             (TS_BYTES_IN_SCANLINE((width), (bpp)) * (height))


/****************************************************************************/
/* The Compressed Data header structure.                                    */
/*                                                                          */
/* Rather than add a field to indicate V1 vs V2 compression we use the      */
/* fact that V2 compression treats all the bitmap as main body and sets     */
/* the first row size to zero to distinguish them.  I hesitate to do this   */
/* but any bandwidth saving is important.                                   */
/****************************************************************************/
typedef struct tagTS_CD_HEADER
{
    TSUINT16 cbCompFirstRowSize;
    TSUINT16 cbCompMainBodySize;
    TSUINT16 cbScanWidth;
    TSUINT16 cbUncompressedSize;
} TS_CD_HEADER, FAR *PTS_CD_HEADER;
typedef TS_CD_HEADER UNALIGNED FAR *PTS_CD_HEADER_UA;


/****************************************************************************/
// Structure: TS_CACHE_BITMAP_ORDER
//
// Description: First cache-bitmap order revision used in RDP 4.0.
/****************************************************************************/
typedef struct tagTS_CACHE_BITMAP_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;

    // header.extraflags
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR indicates if the compressed
    // bitmap data contains the redundant BC header or not. Note this value
    // is defined in REV2 bitmap extraflags value for consistency

    TSUINT8  cacheId;
    TSUINT8  pad1octet;
    TSUINT8  bitmapWidth;
    TSUINT8  bitmapHeight;
    TSUINT8  bitmapBitsPerPel;
    TSUINT16 bitmapLength;
    TSUINT16 cacheIndex;
    TSUINT8  bitmapData[1];
} TS_CACHE_BITMAP_ORDER, FAR *PTS_CACHE_BITMAP_ORDER;


/****************************************************************************/
// TS_CACHE_BITMAP_ORDER_REV2_HEADER
//
// Second version of cache-bitmap order that includes the hash key and
// changes the field definitions to minimize wire bytes.
/****************************************************************************/
// Maximum worst-case order size, rounded up to the nearest DWORD boundary.
#define TS_CACHE_BITMAP_ORDER_REV2_MAX_SIZE \
        (((sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER) + 18) + 3) & ~0x03)
typedef struct
{
    // Two bytes in header.extraFlags are encoded as follows:
    //   Bits 0..2 (mask 0x0007): CacheID.
    //   Bits 3..6 (mask 0x0078): BitsPerPixelID, see below for values.
    //   Bit 7 (mask 0x0080): bHeightSameAsWidth, set to 1 when the bitmap
    //       height is the same as the encoded width.
    //   Bit 8 (mask 0x0100): bKeyPresent, set to 1 when the persistent key
    //       is encoded in the stream.
    //   Bit 9 (mask 0x0200): bStreamBitmap, set to 1 if this cache-bitmap
    //       order is a bitmap-streaming header.
    //   Bit 10 (mask 0x0400): noBitmapCompressionHdr, set to 1 if the
    //       compressed bitmap doesn't contain redundent header (8 bytes)
    //       This mask is used by REV1 bitmap header, SDA bitmap data
    //       and TS_GENERAL_CAPS as well
    //   Bit 11 (mask 0x0800): not cache flag, set to 1 if the bitmap
    //       is not to be cached in the bitmap cache

    TS_SECONDARY_ORDER_HEADER header;
#define TS_CacheBitmapRev2_CacheID_Mask            0x0007
#define TS_CacheBitmapRev2_BitsPerPixelID_Mask     0x0078
#define TS_CacheBitmapRev2_bHeightSameAsWidth_Mask 0x0080
#define TS_CacheBitmapRev2_bKeyPresent_Mask        0x0100
#define TS_CacheBitmapRev2_bStreamBitmap_Mask      0x0200
#define TS_EXTRA_NO_BITMAP_COMPRESSION_HDR         0x0400
#define TS_CacheBitmapRev2_bNotCacheFlag           0x0800

// These are defined to be in the same position they would be in the
// extraFlags field.
#define TS_CacheBitmapRev2_1BitPerPel   (0 << 3)
#define TS_CacheBitmapRev2_2BitsPerPel  (1 << 3)
#define TS_CacheBitmapRev2_4BitsPerPel  (2 << 3)
#define TS_CacheBitmapRev2_8BitsPerPel  (3 << 3)
#define TS_CacheBitmapRev2_16BitsPerPel (4 << 3)
#define TS_CacheBitmapRev2_24BitsPerPel (5 << 3)
#define TS_CacheBitmapRev2_32BitsPerPel (6 << 3)

    // 64-bit key. These are absent from the wire encoding if the cache
    // properties in the bitmap cache capabilities indicate the cache
    // is not persistent and bKeyPresent is false above.
    TSUINT32 Key1;
    TSUINT32 Key2;

    // Following fields are variable-sized and so only have a description.
    // Encoding rules:
    //   2-byte encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 7 low
    //       bits of the first byte), 1 means it is 2 bytes (low 7 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 15 bits available).
    //   4-byte encoding: Uses high 2 bits of first byte as a field length
    //       indicator: 00 means a one-byte field (low 6 bits of that byte
    //       are the value), 01=2-byte field (low 6 bits + next byte, with
    //       1st 6 bits being most significant, 14 bits total for value),
    //       10=3-byte field (22 bits total for value), 11=4-byte field (30
    //       bits for value).

    // Bitmap width: 2-byte encoding.
    // Bitmap height: If same as width, the bHeightSameAsWidth bit is
    //     set above, otherwise appears here as a 2-byte encoding.
    // Bitmap length: 4-byte encoding.
    // Streaming extended info: This field is present only if the bStreamBitmap
    //     flag was set in the header field. This field is a 2-byte encoding
    //     specifying the length of the portion of the bitmap in this PDU.
    //     The rest of the bitmap data will be sent later with a series of
    //     TS_STREAM_BITMAP secondary orders.
    // Cache index: 2-byte encoding.
} TS_CACHE_BITMAP_ORDER_REV2_HEADER, FAR *PTS_CACHE_BITMAP_ORDER_REV2_HEADER;


/****************************************************************************/
// TS_STREAM_BITMAP_ORDER_HEADER
//
// Follow-up PDU to TS_CACHE_BITMAP_ORDER_REV2 that provides further blocks
// of data for the streamed bitmap. Note there are no first/last streaming
// bits provided, the block sizes sent are sufficient information to
// determine when the bitmap stream is complete.
/****************************************************************************/
// Maximum worst-case order size, rounded up to the nearest DWORD boundary.
#define TS_STREAM_BITMAP_ORDER_MAX_SIZE \
        (((sizeof(TS_STREAM_BITMAP_ORDER_HEADER) + 2) + 3) & ~0x03)
typedef struct
{
    TS_SECONDARY_ORDER_HEADER header;

    // Following fields are variable-sized according to encoding descriptions
    // given for TS_CACHE_BITMAP_ORDER_HEADER_REV2.

    // Data length: 2-byte encoding.
} TS_STREAM_BITMAP_ORDER_HEADER, FAR *PTS_STREAM_BITMAP_ORDER_HEADER;


/****************************************************************************/
/* Structure: TS_CACHE_COLOR_TABLE_ORDER                                    */
/****************************************************************************/
typedef struct tagTS_CACHE_COLOR_TABLE_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheIndex;
    TSUINT16                  numberColors;
    TS_COLOR_QUAD             colorTable[1];
} TS_CACHE_COLOR_TABLE_ORDER, FAR * PTS_CACHE_COLOR_TABLE_ORDER;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_DATA                                           */
/****************************************************************************/
typedef struct tagTS_CACHE_GLYPH_DATA
{
    TSUINT16 cacheIndex;
    TSINT16  x;
    TSINT16  y;
    TSUINT16 cx;
    TSUINT16 cy;
    TSUINT8  aj[1];
} TS_CACHE_GLYPH_DATA, FAR * PTS_CACHE_GLYPH_DATA;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_ORDER                                          */
/****************************************************************************/
#define TS_EXTRA_GLYPH_UNICODE       16
typedef struct tagTS_CACHE_GLYPH_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheId;
    TSUINT8                   cGlyphs;
    TS_CACHE_GLYPH_DATA       glyphData[1];
} TS_CACHE_GLYPH_ORDER, FAR * PTS_CACHE_GLYPH_ORDER;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_ORDER_REV2                                     */
/****************************************************************************/
#define TS_GLYPH_DATA_REV2_HDR_MAX_SIZE    9

typedef struct tagTS_CACHE_GLYPH_ORDER_REV2
{
    // Two bytes in header.extraFlags are encoded as follows:
    //   Bits 0..3 (mask 0x000f): CacheID.
    //   Bit  4 (mask 0x0010): glyph unicode
    //   Bit  5 (mask 0x0020): Glyph REV2 order
    //   Bits 6..7: free
    //   Bits 8..15 (mask 0xff00): cGlyphs
    TS_SECONDARY_ORDER_HEADER header;

#define TS_CacheGlyphRev2_CacheID_Mask            0x000f
#define TS_CacheGlyphRev2_Mask                    0x0020
#define TS_CacheGlyphRev2_cGlyphs_Mask            0xff00

    // array of glyph data
    BYTE glyphData[1];

    // Following fields are variable-sized and so only have a description.
    // Encoding rules:
    //   2-byte encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 7 low
    //       bits of the first byte), 1 means it is 2 bytes (low 7 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 15 bits available).
    //
    //   2-byte signed encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 6 low
    //       bits of the first byte), 1 means it is 2 bytes (low 6 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 14 bits available).
    //       The second high bit used as a sign indicator.  0 means the
    //       field is unsigned, 1 means the field is signed
    //
    // cacheIndex: 1-byte field
    // Glyph x: 2-byte signed encoding
    // Glyph y: 2-byte signed encoding
    // Glyph cx: 2-byte unsigned encoding
    // Glyph cy: 2-byte unsigned encoding
    // Glyph bitmap data: in bytes

} TS_CACHE_GLYPH_ORDER_REV2, FAR * PTS_CACHE_GLYPH_ORDER_REV2;


/****************************************************************************/
/* Structure: TS_CACHE_BRUSH_ORDER                                          */
/****************************************************************************/
#define TS_CACHED_BRUSH 0x80
#define MAX_BRUSH_ENCODE_COLORS 4
typedef struct tagTS_CACHE_BRUSH_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheEntry;
    TSUINT8                   iBitmapFormat;
    TSUINT8                   cx;
    TSUINT8                   cy;
    TSUINT8                   style;
    TSUINT8                   iBytes;
    TSUINT8                   brushData[1];
#ifdef DC_HICOLOR
    // The layout of the brush data is dependent on the format of the
    // bitmap, and if it has been compressed in any way.  In particular,
    // many brushes actually only use two different colors, and the
    // majority use four or less.
    //
    // Two-color brushes are treated as mono bitmaps, so the brushData
    // array contains the bits encoded in 8 bytes.
    //
    // Four color brushes are represented as 2-bit indices into a color
    // table.  The brushData array thus contains
    //
    // - 16 bytes of bitmap data (8x8 pels x 2bpp)
    // - either
    //   - 4 1-byte indices into the current color table (for 8bpp
    //     sessions)
    //   - 4 4-byte color values, either color indices for 15/16bpp or full
    //     RGB values for 24bpp sessions
    //
    // The bits of brushes using more than 4 colors are simply copied into
    // the brushData at the appropriate color depth.
#endif

} TS_CACHE_BRUSH_ORDER, FAR * PTS_CACHE_BRUSH_ORDER;


/****************************************************************************/
// TS_CREATE_OFFSCR_BITMAP_ORDER
//
// This alternate secondary order creates an offscreen bitmap of size
// cx by cy. The bitmap ID is stored at the ExtraFlags field in the header
/****************************************************************************/
typedef struct tagTS_CREATE_OFFSCR_BITMAP_ORDER
{
    BYTE ControlFlags;

    // Bit 0..14: Offscreen bitmap ID
    // Bit 15: Flag to indicate if offscreen bitmap delete list is appended.
    TSUINT16 Flags;

    TSUINT16 cx;
    TSUINT16 cy;

    // Number offscreen bitmaps to delete: 2 bytes
    // Offscreen bitmap ID delete list: 2-bytes list
    TSUINT16 variableBytes[1];
} TS_CREATE_OFFSCR_BITMAP_ORDER, FAR * PTS_CREATE_OFFSCR_BITMAP_ORDER;


/****************************************************************************/
// TS_SWITCH_SURFACE_ORDER_HEADER
//
// This alternate secondary order switches the target drawing surface at the
// client, identified by the bitmap ID. The primary drawing surface (screen)
// has the bitmap ID of 0xFFFF.
/****************************************************************************/
#define SCREEN_BITMAP_SURFACE  0xFFFF

typedef struct tagTS_SWITCH_SURFACE_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
} TS_SWITCH_SURFACE_ORDER, FAR * PTS_SWITCH_SURFACE_ORDER;



#ifdef DRAW_GDIPLUS
/****************************************************************************/
// Structure: TS_DRAW_GDIPLUS_ORDER
//
// Description: DrawGdiplus order
/****************************************************************************/
typedef struct tagTS_DRAW_GDIPLUS_ORDER_FRIST
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
    TSUINT32 cbTotalEmfSize;
} TS_DRAW_GDIPLUS_ORDER_FIRST, FAR * PTS_DRAW_GDIPLUS_ORDER_FIRST;

typedef struct tagTS_DRAW_GDIPLUS_ORDER_NEXT
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
} TS_DRAW_GDIPLUS_ORDER_NEXT, FAR * PTS_DRAW_GDIPLUS_ORDER_NEXT;

typedef struct tagTS_DRAW_GDIPLUS_ORDER_END
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
    TSUINT32 cbTotalEmfSize;
} TS_DRAW_GDIPLUS_ORDER_END, FAR * PTS_DRAW_GDIPLUS_ORDER_END;

#define TS_GDIPLUS_ORDER_SIZELIMIT 4096

/****************************************************************************/
// Structure: TS_CACHE_DRAW_GDIPLUS_CACHE_ORDER
//
// Description: DrawGdiplus cache order
/****************************************************************************/
typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST
{
    BYTE ControlFlags;
    BYTE Flags;
    #define TS_GDIPLUS_CACHE_ORDER_REMOVE_CACHEENTRY 0x1
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST;

typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT
{
    BYTE ControlFlags;
    BYTE Flags;
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT;

typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_END
{
    BYTE ControlFlags;
    BYTE Flags;
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_END, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_END;
                                                           
#define GDIP_CACHE_GRAPHICS_DATA 0x1
#define GDIP_CACHE_OBJECT_BRUSH 0x2
#define GDIP_CACHE_OBJECT_PEN 0x3
#define GDIP_CACHE_OBJECT_IMAGE 0x4
#define GDIP_CACHE_OBJECT_IMAGEATTRIBUTES 0x5

typedef struct tagTSEmfPlusRecord
{
    TSINT16 Type;        
    TSUINT16 Flags;     // Higher 8 bits is Gdi+ object type 
    TSUINT32 Size;      // If MSB is set, the following data will be cacheID
} TSEmfPlusRecord, FAR * PTSEmfPlusRecord;
#endif // DRAW_GDIPLUS


#ifdef DRAW_NINEGRID
/****************************************************************************/
// Structure: TS_CREATE_DRAW_NINEGRID_ORDER
//
// Description: Luna DrawNineGrid bitmap order
/****************************************************************************/
typedef struct tagTS_NINEGRID_BITMAP_INFO
{
    ULONG      flFlags;
    TSUINT16   ulLeftWidth;
    TSUINT16   ulRightWidth;
    TSUINT16   ulTopHeight;
    TSUINT16   ulBottomHeight;
    TSCOLORREF crTransparent;
} TS_NINEGRID_BITMAP_INFO, FAR * PTS_NINEGRID_BITMAP_INFO;

typedef struct tagTS_CREATE_NINEGRID_BITMAP_ORDER
{
    BYTE ControlFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapID;
    TSUINT16 cx;
    TSUINT16 cy;
    TS_NINEGRID_BITMAP_INFO nineGridInfo;
} TS_CREATE_NINEGRID_BITMAP_ORDER, FAR * PTS_CREATE_NINEGRID_BITMAP_ORDER;

/****************************************************************************/
// Streaming bitmap orders
/****************************************************************************/
#define TS_STREAM_BITMAP_BLOCK      4 * 1024    // stream bitmap block is 4k chunk
#define TS_STREAM_BITMAP_END        0x1
#define TS_STREAM_BITMAP_COMPRESSED 0x2
#define TS_STREAM_BITMAP_REV2 0x4

typedef struct tagTS_STREAM_BITMAP_FIRST_PDU
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapId;
#define TS_DRAW_NINEGRID_BITMAP_CACHE 0x1
    
    TSUINT16 BitmapWidth;
    TSUINT16 BitmapHeight;
    TSUINT16 BitmapLength;

    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_FIRST_PDU, FAR * PTS_STREAM_BITMAP_FIRST_PDU;

typedef struct tagTS_STREAM_BITMAP_NEXT_PDU
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    TSUINT16 BitmapId;
    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_NEXT_PDU, FAR * PTS_STREAM_BITMAP_NEXT_PDU;

// For DRAW_STREM_REV2, the only change is the BitmapLength in tagTS_STREAM_BITMAP_FIRST_PDU
//  from TSUINT16 to TSUINT32
typedef struct tagTS_STREAM_BITMAP_FIRST_PDU_REV2
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapId;
#define TS_DRAW_NINEGRID_BITMAP_CACHE 0x1
    
    TSUINT16 BitmapWidth;
    TSUINT16 BitmapHeight;
    TSUINT32 BitmapLength;

    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_FIRST_PDU_REV2, FAR * PTS_STREAM_BITMAP_FIRST_PDU_REV2;


#if 0
/****************************************************************************/
// Structure: TS_CREATE_DRAW_STREAM_ORDER
//
// Description: Luna DrawStream order
/****************************************************************************/
typedef struct tagTS_CREATE_DRAW_STREAM_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
    TSUINT16 cx;
    TSUINT16 cy;
    TSUINT8  bitmapBpp;
} TS_CREATE_DRAW_STREAM_ORDER, FAR * PTS_CREATE_DRAW_STREAM_ORDER;

/****************************************************************************/
// Structure: TS_DRAW_STREAM_ORDER
//
// Description: Luna DrawStream order
/****************************************************************************/
typedef struct tagTS_DRAW_STREAM_ORDER
{
    BYTE ControlFlags;
    TS_RECTANGLE16 Bounds; 
    TSUINT16 BitmapID;
    TSUINT8  nClipRects;
    TSUINT16 StreamLen;       
} TS_DRAW_STREAM_ORDER, FAR * PTS_DRAW_STREAM_ORDER;

typedef struct tagTS_DRAW_NINEGRID_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
    TS_RECTANGLE16 dstBounds; 
    TS_RECTANGLE16 srcBounds;
    TSUINT8 nClipRects;    
} TS_DRAW_NINEGRID_ORDER, FAR * PTS_DRAW_NINEGRID_ORDER;

typedef struct _RDP_DS_COPYTILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
} RDP_DS_COPYTILE;

typedef struct _RDP_DS_SOLIDFILL
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TSCOLORREF crSolidColor;
} RDP_DS_SOLIDFILL;

typedef struct _RDP_DS_TRANSPARENTTILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
    TSCOLORREF crTransparentColor;
} RDP_DS_TRANSPARENTTILE;

typedef struct _RDP_DS_ALPHATILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
    TS_BLENDFUNC blendFunction;
} RDP_DS_ALPHATILE;

typedef struct _RDP_DS_STRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
} RDP_DS_STRETCH;

typedef struct _RDP_DS_TRANSPARENTSTRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TSCOLORREF crTransparentColor;
} RDP_DS_TRANSPARENTSTRETCH;

typedef struct _RDP_DS_ALPHASTRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_BLENDFUNC blendFunction;
} RDP_DS_ALPHASTRETCH;
#endif
#endif //DRAW_NINEGRID

/****************************************************************************/
/* Structure: TS_SECONDARY_ORDER                                            */
/****************************************************************************/
typedef struct tagTS_SECONDARY_ORDER
{
    union
    {
        TS_CACHE_BITMAP_ORDER      cacheBitmap;
        TS_CACHE_COLOR_TABLE_ORDER cacheColorTable;
        TS_CACHE_GLYPH_ORDER       cacheGlyph;
        TS_CACHE_BRUSH_ORDER       cacheBrush;
    } u;
} TS_SECONDARY_ORDER, FAR * PTS_SECONDARY_ORDER;


/****************************************************************************/
/* Structure: TS_UPDATE_PALETTE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_UPDATE_PALETTE_PDU_DATA
{
    TSUINT16 updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16 pad2octets;
    TSUINT32 numberColors;
    TS_COLOR palette[1];      /* 16 or 256 entries               */
} TS_UPDATE_PALETTE_PDU_DATA, FAR * PTS_UPDATE_PALETTE_PDU_DATA;

typedef struct tagTS_UPDATE_PALETTE_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_UPDATE_PALETTE_PDU_DATA data;
} TS_UPDATE_PALETTE_PDU, FAR * PTS_UPDATE_PALETTE_PDU;


/****************************************************************************/
/* Structure: TS_UPDATE_SYNCHRONIZE_PDU                                     */
/****************************************************************************/
typedef struct tagTS_UPDATE_SYNCHRONIZE_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16           pad2octets;
} TS_UPDATE_SYNCHRONIZE_PDU, FAR * PTS_UPDATE_SYNCHRONIZE_PDU;


/****************************************************************************/
/* CONSTANTS                                                                */
/****************************************************************************/
#define TS_PROTOCOL_VERSION 0x0010

/****************************************************************************/
/* MCS priorities                                                           */
/****************************************************************************/
#define TS_LOWPRIORITY   3
#define TS_MEDPRIORITY   2
#define TS_HIGHPRIORITY  1

#ifdef DC_HICOLOR
/****************************************************************************/
/* Mask definitions for high color support                                  */
/****************************************************************************/
#define TS_RED_MASK_24BPP    0xff0000;
#define TS_GREEN_MASK_24BPP  0x00ff00;
#define TS_BLUE_MASK_24BPP   0x0000ff;

#define TS_RED_MASK_16BPP    0xf800
#define TS_GREEN_MASK_16BPP  0x07e0
#define TS_BLUE_MASK_16BPP   0x001f

#define TS_RED_MASK_15BPP    0x7c00
#define TS_GREEN_MASK_15BPP  0x03e0
#define TS_BLUE_MASK_15BPP   0x001f
#endif

/****************************************************************************/
/* Structure: TS_REFRESH_RECT_PDU                                           */
/*                                                                          */
/* Name of PDU: RefreshRectanglePDU (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server (and optionally: Server -> Client)         */
/*      Requests that the Server should send data to the client to allow    */
/*      the client to redraw the areas defined by the rectangles defined in */
/*      the PDU. The server responds by sending updatePDUs (orders, bitmap  */
/*      data etc.) containing all the drawing information necessary to      */
/*      "fill in" the rectangle.  The server will probably implement this   */
/*      by invalidating the rectangle - which results in a bunch of drawing */
/*      orders from the affected apps, which are then remoted to the Client */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      numberOfAreas:   count of rectangles included                       */
/*      areaToRefresh:   area the client needs repainted                    */
/****************************************************************************/
typedef struct tagTS_REFRESH_RECT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT8            numberOfAreas;
    TSUINT8            pad3octets[3];
    TS_RECTANGLE16     areaToRefresh[1];        /* inclusive               */
} TS_REFRESH_RECT_PDU, FAR * PTS_REFRESH_RECT_PDU;
#define TS_REFRESH_RECT_PDU_SIZE sizeof(TS_REFRESH_RECT_PDU)
#define TS_REFRESH_RECT_UNCOMP_LEN 12


/****************************************************************************/
/* Structure: TS_SUPPRESS_OUTPUT_PDU                                        */
/*                                                                          */
/* Name of PDU: SuppressOutputPDU (a T.128 extension)                       */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server                                            */
/*      Notifies the Server that there are changes in the areas of the      */
/*      shared desktop that are visible at the client.                      */
/*                                                                          */
/*      By default, at the start of a new session, the server assumes that  */
/*      the entire desktop is visible at the client and will send all       */
/*      remoted output to it.  During a session, the client can use this    */
/*      PDU to notify the server that only certain areas of the shared      */
/*      desktop are visible.  The server may then choose NOT to send output */
/*      for the other areas (note: the server does not guarantee to not     */
/*      send the output; the client must be capable of handling such output */
/*      by ignoring it).                                                    */
/*                                                                          */
/*      Once the client has sent one of these PDUs it is then responsible   */
/*      for keeping the server up to date i.e.  it must send further        */
/*      PDUs whenever the areas that can be excluded changes.  Note that    */
/*      processing the PDU at the server can be quite an expensive          */
/*      operation (because areas that were excluded but are now not-        */
/*      excluded need to be redrawn to ensure that the client has an        */
/*      up to date view of them).                                           */
/*                                                                          */
/*      The intent behind this PDU is not that the Client should notify the */
/*      server every time the client area is resized (by the user dragging  */
/*      the frame border for example) but to allow line-utilization         */
/*      optimization whenever there is any "significant" reason for         */
/*      output to be excluded.  The definition of "significant" is          */
/*      entirely a client decision but reasons might include                */
/*      - the client is minimized (which suggests that the user is          */
/*          likely to not want to see the Client output for a lengthy       */
/*          period of time)                                                 */
/*      - another application is maximized and has the focus (which         */
/*          again suggests that the client user may not be interested in    */
/*          output for a lengthy period of time)                            */
/*      - with multiple-monitor configuration at the client there may       */
/*          be some areas of the server desktop that are simply NEVER       */
/*          visible at the client; selectively suppressing output for       */
/*          those areas is a good idea.                                     */
/*                                                                          */
/*      Note that in TSE4.0 and Win2000, the Client only ever excludes      */
/*      output for the entire desktop, or for none of it. Similarly, the    */
/*      server only actually suppresses all output or none (it cannot       */
/*      suppress output for selected areas).                                */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      numberOfRectangles: TS_QUIET_FULL_SUPPRESSION (zero): indicates     */
/*                            that the Server may choose to stop sending    */
/*                            all output (including sound).                 */
/*                          1..TS_MAX_INCLUDED_RECTS: number of rectangles  */
/*                            following.                                    */
/*                          any other value: ASSERTABLE ERROR.              */
/*      includedRectangle[] Each rectangle defines an area of the desktop   */
/*                          for which the client requires output.           */
/****************************************************************************/
typedef struct tagTS_SUPPRESS_OUTPUT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT8            numberOfRectangles;
#define TS_QUIET_FULL_SUPPRESSION   0
#define TS_MAX_INCLUDED_RECTS       128

    TSUINT8            pad3octets[3];
    TS_RECTANGLE16     includedRectangle[1];                 /* optional. */

} TS_SUPPRESS_OUTPUT_PDU, FAR * PTS_SUPPRESS_OUTPUT_PDU;
#define TS_SUPPRESS_OUTPUT_PDU_SIZE(n) \
       ((sizeof(TS_SUPPRESS_OUTPUT_PDU)-sizeof(TS_RECTANGLE16)) + \
        (n * sizeof(TS_RECTANGLE16)))
#define TS_SUPPRESS_OUTPUT_UNCOMP_LEN(n) \
                                             (8 + n * sizeof(TS_RECTANGLE16))


/****************************************************************************/
/* Structure: TS_PLAY_SOUND_PDU                                             */
/*                                                                          */
/* Name of PDU: PlaySoundPDU        (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Server -> Client                                            */
/*      On receipt, the Client should (if possible) generate some local     */
/*      audio output as indicated by the information in the packet.         */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      duration:     duration in ms                                        */
/*      frequency:    frequency in Hz                                       */
/****************************************************************************/
typedef struct tagTS_PLAY_SOUND_PDU_DATA
{
    TSUINT32 duration;
    TSUINT32 frequency;
} TS_PLAY_SOUND_PDU_DATA, FAR * PTS_PLAY_SOUND_PDU_DATA;

typedef struct tagTS_PLAY_SOUND_PDU
{
    TS_SHAREDATAHEADER       shareDataHeader;
    TS_PLAY_SOUND_PDU_DATA   data;
} TS_PLAY_SOUND_PDU, FAR * PTS_PLAY_SOUND_PDU;


/****************************************************************************/
/* Structure: TS_SHUTDOWN_REQUEST_PDU                                       */
/*                                                                          */
/* Name of PDU: ShutdownRequestPDU  (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server                                            */
/*      Notifies the Server that the Client wishes to terminate. If the     */
/*      server objects for some reason (in RNS/Ducati this reason is        */
/*      "the user is still logged on to the underlying session") then       */
/*      the server responds with a shutdownDeniedPDU.  Otherwise, this      */
/*      PDU has no response, and the Server disconnects the Client (which   */
/*      then terminates).                                                   */
/****************************************************************************/
typedef struct tagTS_SHUTDOWN_REQ_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
} TS_SHUTDOWN_REQ_PDU, FAR * PTS_SHUTDOWN_REQ_PDU;
#define TS_SHUTDOWN_REQ_PDU_SIZE sizeof(TS_SHUTDOWN_REQ_PDU)
#define TS_SHUTDOWN_REQ_UNCOMP_LEN 4


/****************************************************************************/
/* Structure: TS_SHUTDOWN_DENIED_PDU                                        */
/*                                                                          */
/* Name of PDU: ShutdownDeniedPDU   (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Server -> Client                                            */
/*      Notifies the Client that the remote user is still logged on to      */
/*      the NT session, and for this reason RNS is not going to end the     */
/*      conference (even though the client has signalled that this should   */
/*      happen by sending a ShutdownRequestPDU).                            */
/****************************************************************************/
typedef struct tagTS_SHUTDOWN_DENIED_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
} TS_SHUTDOWN_DENIED_PDU, FAR * PTS_SHUTDOWN_DENIED_PDU;


/****************************************************************************/
/* Structure: TS_LOGON_INFO                                                 */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO
{
    TSUINT32 cbDomain;
    TSUINT8  Domain[TS_MAX_DOMAIN_LENGTH_OLD];

    TSUINT32 cbUserName;
    TSUINT8  UserName[TS_MAX_USERNAME_LENGTH];

    TSUINT32 SessionId;
} TS_LOGON_INFO, FAR * PTS_LOGON_INFO;

/****************************************************************************/
/* Structure: TS_LOGON_INFO_VERSION_2 ; For Supporting Long Credentials     */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO_VERSION_2
{
    TSUINT16 Version; 
    #define SAVE_SESSION_PDU_VERSION_ONE 1
    TSUINT32 Size; 
    TSUINT32 SessionId;
    TSUINT32 cbDomain;
    TSUINT32 cbUserName;
    // NOTE -- Actual Domain and UserName follows this structure
    // The actual Domain name follows this structure immediately 
    // The actual UserName follows the Domain Name
    // Both the Domain and UserName are NULL terminated
} TS_LOGON_INFO_VERSION_2, FAR * PTS_LOGON_INFO_VERSION_2; 


/****************************************************************************/
/* Structure: TS_LOGON_INFO_EXTENDED ; Supports extended logon info         */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO_EXTENDED
{
    // Overall length of this packet, including the header fields.
    TSUINT16 Length;
    // Flags specify which pieces of data are present (ordered)
    TSUINT32 Flags;
#define LOGON_EX_AUTORECONNECTCOOKIE    0x1

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} TS_LOGON_INFO_EXTENDED, FAR * PTS_LOGON_INFO_EXTENDED; 

/****************************************************************************/
/* Structure: TS_SAVE_SESSION_INFO_PDU                                      */
/****************************************************************************/
typedef struct tagTS_SAVE_SESSION_INFO_PDU_DATA
{
    TSUINT32 InfoType;
#define TS_INFOTYPE_LOGON               0
#define TS_INFOTYPE_LOGON_LONG          1
// Plain notify just notifies of the fact that we've logged on.
#define TS_INFOTYPE_LOGON_PLAINNOTIFY   2
// Extended logon info packet (e.g contains autoreconnect cookie)
#define TS_INFOTYPE_LOGON_EXTENDED_INFO 3

    union
    {
        TS_LOGON_INFO           LogonInfo;
        TS_LOGON_INFO_VERSION_2 LogonInfoVersionTwo;
        TS_LOGON_INFO_EXTENDED  LogonInfoEx;
    } Info;
} TS_SAVE_SESSION_INFO_PDU_DATA, FAR * PTS_SAVE_SESSION_INFO_PDU_DATA;

typedef struct tagTS_SAVE_SESSION_INFO_PDU
{
    TS_SHAREDATAHEADER            shareDataHeader;
    TS_SAVE_SESSION_INFO_PDU_DATA data;
} TS_SAVE_SESSION_INFO_PDU, FAR * PTS_SAVE_SESSION_INFO_PDU;
#define TS_SAVE_SESSION_INFO_PDU_SIZE sizeof(TS_SAVE_SESSION_INFO_PDU)


/****************************************************************************/
/* Structure: TS_SET_ERROR_INFO_PDU                                         */
/****************************************************************************/
typedef struct tagTS_SET_ERROR_INFO_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           errorInfo;
} TS_SET_ERROR_INFO_PDU, FAR * PTS_SET_ERROR_INFO_PDU;
#define TS_SET_ERROR_INFO_PDU_SIZE sizeof(TS_SET_ERROR_INFO_PDU)

/****************************************************************************/
/* Structure: TS_SET_KEYBOARD_INDICATORS_PDU                                */
/****************************************************************************/
typedef struct tagTS_SET_KEYBOARD_INDICATORS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16 UnitId;
    TSUINT16 LedFlags;
} TS_SET_KEYBOARD_INDICATORS_PDU, FAR * PTS_SET_KEYBOARD_INDICATORS_PDU;
#define TS_SET_KEYBOARD_INDICATORS_PDU_SIZE       sizeof(TS_SET_KEYBOARD_INDICATORS_PDU)


/****************************************************************************/
/* Structure: TS_SET_KEYBOARD_IME_STATUS_PDU                                */
/****************************************************************************/
typedef struct tagTS_SET_KEYBOARD_IME_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16 UnitId;
    TSUINT32 ImeOpen;
    TSUINT32 ImeConvMode;
} TS_SET_KEYBOARD_IME_STATUS_PDU, FAR * PTS_SET_KEYBOARD_IME_STATUS_PDU;
#define TS_SET_KEYBOARD_IME_STATUS_PDU_SIZE sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU)

/****************************************************************************/
/* Structure: TS_AUTORECONNECT_STATUS_PDU                                   */
/****************************************************************************/
typedef struct tagTS_AUTORECONNECT_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           arcStatus;
} TS_AUTORECONNECT_STATUS_PDU, FAR * PTS_AUTORECONNECT_STATUS_PDU;
#define TS_AUTORECONNECT_STATUS_PDU_SIZE sizeof(TS_AUTORECONNECT_STATUS_PDU)



/****************************************************************************/
/* Restore packing style (previous for 32-bit, default for 16-bit).         */
/****************************************************************************/
#ifdef OS_WIN16
#pragma pack ()
#else
#pragma pack (pop, t128pack)
#endif


#endif /* _H_AT128 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\at120ex.h ===
/****************************************************************************/
// at120ex.h
//
// RDP T.120 protocol extensions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AT120EX
#define _H_AT120EX


/****************************************************************************/
/* TShare security constants.                                               */
/****************************************************************************/
#include <tssec.h>

#if !defined(OS_WINCE) && !defined(OS_WIN16)
#include <winsta.h>
#endif //OS_WIN16

/****************************************************************************/
/*                                                                          */
/* Definition of GCC User Data used by RDP                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* H221 keys.                                                               */
/****************************************************************************/
#define H221_KEY_LEN            4
#define SERVER_H221_KEY         "McDn"
#define CLIENT_H221_KEY         "Duca"


/****************************************************************************/
/* User data identifiers                                                    */
/****************************************************************************/
/****************************************************************************/
/* Client to Server IDs                                                     */
/****************************************************************************/
#define RNS_UD_CS_CORE_ID       0xc001
#define RNS_UD_CS_SEC_ID        0xc002
#define RNS_UD_CS_NET_ID        0xc003
#define TS_UD_CS_CLUSTER_ID     0xC004

/****************************************************************************/
/* Server to Client IDs                                                     */
/****************************************************************************/
#define RNS_UD_SC_CORE_ID       0x0c01
#define RNS_UD_SC_SEC_ID        0x0c02
#define RNS_UD_SC_NET_ID        0x0c03

/****************************************************************************/
/* Color depths supported                                                   */
/****************************************************************************/
#define RNS_UD_COLOR_4BPP       0xca00
#define RNS_UD_COLOR_8BPP       0xca01
#define RNS_UD_COLOR_16BPP_555  0xca02
#define RNS_UD_COLOR_16BPP_565  0xca03
#define RNS_UD_COLOR_24BPP      0xca04

#ifdef DC_HICOLOR
/****************************************************************************/
/* High color support                                                       */
/****************************************************************************/
#define RNS_UD_24BPP_SUPPORT    0x01
#define RNS_UD_16BPP_SUPPORT    0x02
#define RNS_UD_15BPP_SUPPORT    0x04
#endif

/****************************************************************************/
/* SAS Sequence identifiers (incomplete).                                   */
/* Specifies the SAS sequence the client will use to access the login       */
/* screen in the Server.                                                    */
/****************************************************************************/
#define RNS_UD_SAS_NONE         0xaa01
#define RNS_UD_SAS_CADEL        0xaa02
#define RNS_UD_SAS_DEL          0xaa03
#define RNS_UD_SAS_SYSRQ        0xaa04
#define RNS_UD_SAS_ESC          0xaa05
#define RNS_UD_SAS_F8           0xaa06

/****************************************************************************/
/* Keyboard layout identifiers.                                             */
/****************************************************************************/
#define RNS_UD_KBD_DEFAULT          0


/****************************************************************************/
/* Version number                                                           */
/*      Major version   Minor version                                       */
/*      0xFFFF0000      0x0000FFFF                                          */
/****************************************************************************/
#define RNS_UD_VERSION          0x00080004  // Major 0008 - Minor 0004

#define _RNS_MAJOR_VERSION(x)   (x >> 16)
#define _RNS_MINOR_VERSION(x)   (x & 0x0000ffff)

#define RNS_UD_MAJOR_VERSION    (RNS_UD_VERSION >> 16)
#define RNS_UD_MINOR_VERSION    (RNS_UD_VERSION & 0x0000ffff)

#define RNS_TERMSRV_40_UD_VERSION 0x00080001  // UD version used by Terminal
                                              // server 4.0 RTM
#define RNS_DNS_USERNAME_UD_VERSION 0x00080004 // Usernames longer than 20 ok


/****************************************************************************/
// Security header flags
/****************************************************************************/
#define RNS_SEC_EXCHANGE_PKT        0x0001
#define RNS_SEC_ENCRYPT             0x0008
#define RNS_SEC_RESET_SEQNO         0x0010
#define RNS_SEC_IGNORE_SEQNO        0x0020
#define RNS_SEC_INFO_PKT            0x0040
#define RNS_SEC_LICENSE_PKT         0x0080
#define RDP_SEC_REDIRECTION_PKT     0x0100
#define RDP_SEC_REDIRECTION_PKT2    0x0200
#define RDP_SEC_REDIRECTION_PKT3    0x0400
#define RDP_SEC_SECURE_CHECKSUM     0x0800

//
// If this flag is specified by the server
// it means the client should encrypt all licensing
// packets it sends up to the server.
//
// This happens at this early stage because the server
// has to expose this capability before normal capability
// negotiation.
//
// We also have licensing packets encrypted from the
// server to the client, reusing the same flag here.
// For clarify, the flag is defined twice to indicate
// the encryption-direction (CS vs. SC)
//
#define RDP_SEC_LICENSE_ENCRYPT_CS  0x0200
#define RDP_SEC_LICENSE_ENCRYPT_SC  0x0200


/****************************************************************************/
/* Flags which define non-data packets                                      */
/****************************************************************************/
#define RNS_SEC_NONDATA_PKT (RNS_SEC_EXCHANGE_PKT |                         \
                             RNS_SEC_INFO_PKT     |                         \
                             RNS_SEC_LICENSE_PKT  |                         \
                             RDP_SEC_REDIRECTION_PKT |                      \
                             RDP_SEC_REDIRECTION_PKT2 |                     \
                             RDP_SEC_REDIRECTION_PKT3)


/****************************************************************************/
/* RNS info packet flags                                                    */
/****************************************************************************/
#define RNS_INFO_MOUSE                  0x0001
#define RNS_INFO_DISABLECTRLALTDEL      0x0002
#define RNS_INFO_DOUBLECLICKDETECT      0x0004
#define RNS_INFO_AUTOLOGON              0x0008
#define RNS_INFO_UNICODE                0x0010
#define RNS_INFO_MAXIMIZESHELL          0x0020
#define RNS_INFO_LOGONNOTIFY            0x0040
#define RNS_INFO_COMPRESSION            0x0080
#define RNS_INFO_ENABLEWINDOWSKEY       0x0100
#define RNS_INFO_REMOTECONSOLEAUDIO     0x2000

// See compress.h for type values that can appear in these 4 bits.
#define RNS_INFO_COMPR_TYPE_MASK        0x1E00
#define RNS_INFO_COMPR_TYPE_SHIFT       9

// When this flag is set, the client should only send encrypted packet to server
#define RNS_INFO_FORCE_ENCRYPTED_CS_PDU 0x4000

/****************************************************************************/
/* Structure: RNS_SECURITY_HEADER                                           */
/*                                                                          */
/* Description: Security header sent with all packets if encryption is in   */
/*              force.                                                      */
/*                                                                          */
/* This header has the following structure:                                 */
/* - flags  (one or more of the RNS_SEC_ flags above)                       */
/****************************************************************************/
typedef struct tagRNS_SECURITY_HEADER
{
    TSUINT16 flags;
    TSUINT16 flagsHi;
} RNS_SECURITY_HEADER, FAR *PRNS_SECURITY_HEADER;
typedef RNS_SECURITY_HEADER UNALIGNED FAR *PRNS_SECURITY_HEADER_UA;


/****************************************************************************/
/* Structure: RNS_SECURITY_HEADER                                           */
/*                                                                          */
/* Description: Security header sent with all packets if encryption is in   */
/*              force.                                                      */
/*                                                                          */
/* This header has the following structure:                                 */
/* - flags  (one or more of the RNS_SEC_ flags above)                       */
/****************************************************************************/
typedef struct tagRNS_SECURITY_HEADER1
{
    TSUINT16 flags;
    TSUINT16 flagsHi;
    TSINT8   dataSignature[DATA_SIGNATURE_SIZE];
} RNS_SECURITY_HEADER1, FAR *PRNS_SECURITY_HEADER1;
typedef RNS_SECURITY_HEADER1 UNALIGNED FAR *PRNS_SECURITY_HEADER1_UA;

/****************************************************************************/
/* Structure: RNS_SECURITY_HEADER                                           */
/*                                                                          */
/* Description: Security header sent with all packets if encryption is in   */
/*              force.                                                      */
/*                                                                          */
/* This header has the following structure:                                 */
/* - flags  (one or more of the RNS_SEC_ flags above)                       */
/****************************************************************************/
typedef struct tagRNS_SECURITY_HEADER2
{
    TSUINT16 flags;
    TSUINT16 flagsHi;   
    TSUINT16 length;    // length of the this header
    TSUINT8  version;
#define TSFIPS_VERSION1 1
    TSUINT8  padlen;    // length of the padding in the encrypted data, has to be next to last
    TSINT8   dataSignature[MAX_SIGN_SIZE];
} RNS_SECURITY_HEADER2, FAR *PRNS_SECURITY_HEADER2;
typedef RNS_SECURITY_HEADER2 UNALIGNED FAR *PRNS_SECURITY_HEADER2_UA;



/****************************************************************************/
/* Structure: RNS_SECURITY_PACKET                                           */
/*                                                                          */
/* Description: Structure of security packet sent during security exchange  */
/*                                                                          */
/* The packet has the following structure                                   */
/* - flags  (RNS_SEC_EXCHANGE_PKT)                                          */
/* - length   length of data                                                */
/* - variable length data                                                   */
/****************************************************************************/
typedef struct tagRNS_SECURITY_PACKET
{
    TSUINT32 flags;
    TSUINT32 length;
    /* data follows */
} RNS_SECURITY_PACKET, FAR *PRNS_SECURITY_PACKET;
typedef RNS_SECURITY_PACKET UNALIGNED FAR *PRNS_SECURITY_PACKET_UA;


/****************************************************************************/
// RDP_SERVER_REDIRECTION_PACKET
//
// Used to communicate a server redirection to the client.
/****************************************************************************/
typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;

    // Variable-length, zero-terminated Unicode string. No accompanying size
    // field is given since the size can be determined from the length above.
    // Up to TS_MAX_SERVERADDRESS_LENGTH Unicode characters in length (incl.
    // terminating null).
    TSUINT16 ServerAddress[1];
} RDP_SERVER_REDIRECTION_PACKET, FAR *PRDP_SERVER_REDIRECTION_PACKET;


typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;
    TSUINT32 RedirFlags;
#define TARGET_NET_ADDRESS      0x1
#define LOAD_BALANCE_INFO       0x2

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} RDP_SERVER_REDIRECTION_PACKET_V2, FAR *PRDP_SERVER_REDIRECTION_PACKET_V2;


typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;
    TSUINT32 RedirFlags;
#define TARGET_NET_ADDRESS      0x1
#define LOAD_BALANCE_INFO       0x2
#define LB_USERNAME             0x4
#define LB_DOMAIN               0x8
#define LB_PASSWORD             0x10
//    In case the policy is set on the server side the client should not store
//    the user name it gets from the V3 redirection packet in the default.rdp 
//    file
#define LB_DONTSTOREUSERNAME    0x20

#define LB_SMARTCARD_LOGON      0x40
// used to inform client the machine IP for later ARC use
#define LB_NOREDIRECT           0x80

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} RDP_SERVER_REDIRECTION_PACKET_V3, FAR *PRDP_SERVER_REDIRECTION_PACKET_V3;

//
// Time zone packet
//
#ifndef _RDP_TIME_ZONE_INFORMATION_
#define _RDP_TIME_ZONE_INFORMATION_
typedef struct _RDP_SYSTEMTIME {
    TSUINT16 wYear;
    TSUINT16 wMonth;
    TSUINT16 wDayOfWeek;
    TSUINT16 wDay;
    TSUINT16 wHour;
    TSUINT16 wMinute;
    TSUINT16 wSecond;
    TSUINT16 wMilliseconds;
} RDP_SYSTEMTIME;

typedef struct _RDP_TIME_ZONE_INFORMATION {
    TSINT32 Bias;
    TSWCHAR StandardName[ 32 ];
    RDP_SYSTEMTIME StandardDate;
    TSINT32 StandardBias;
    TSWCHAR DaylightName[ 32 ];
    RDP_SYSTEMTIME DaylightDate;
    TSINT32 DaylightBias;
} RDP_TIME_ZONE_INFORMATION;
#endif //_RDP_TIME_ZONE_INFORMATION_


/****************************************************************************/
/* Structure: RNS_INFO_PACKET                                               */
/*                                                                          */
/* The packet has the following structure                                   */
/* - fMouse                 Mouse enabled flag                              */
/* - fDisableCtrlAltDel     CtrlAltDel disable state                        */
/* - fDoubleClickDetect     Double click detect state                       */
/* - Domain                 Domain                                          */
/* - UserName               UserName                                        */
/* - Password               Password                                        */
/****************************************************************************/
// The following fields are added post Win2000 Beta 3
// Future variable length fields can be appended to this struct in similar
// fashion

#define RNS_INFO_INVALID_SESSION_ID     LOGONID_NONE

typedef struct tagRNS_EXTENDED_INFO_PACKET
{
   TSUINT16     clientAddressFamily;
   TSUINT16     cbClientAddress;
   TSUINT8      clientAddress[TS_MAX_CLIENTADDRESS_LENGTH];
   TSUINT16     cbClientDir;
   TSUINT8      clientDir[TS_MAX_CLIENTDIR_LENGTH];
   //client time zone information
   RDP_TIME_ZONE_INFORMATION      clientTimeZone;
   TSUINT32     clientSessionId;
   //
   // List of features to disable
   // (flags are defined in the protocol independent header tsperf.h)
   //
   TSUINT32     performanceFlags;
   //
   // Flags field
   //
   TSUINT16     cbAutoReconnectLen;

   //
   // Variable length portion. Only sent up if autoreconnection info
   // is specified
   //
   TSUINT8      autoReconnectCookie[TS_MAX_AUTORECONNECT_LEN];
} RNS_EXTENDED_INFO_PACKET, FAR *PRNS_EXTENDED_INFO_PACKET;
typedef RNS_EXTENDED_INFO_PACKET UNALIGNED FAR *PRNS_EXTENDED_INFO_PACKET_UA;

typedef struct tagRNS_INFO_PACKET
{
    //
    // In UNICODE we reuse the CodePage field to hold the active input
    // locale identifier (formerly called keyboard layout)
    //
    TSUINT32 CodePage;
    TSUINT32 flags;
    TSUINT16 cbDomain;
    TSUINT16 cbUserName;
    TSUINT16 cbPassword;
    TSUINT16 cbAlternateShell;
    TSUINT16 cbWorkingDir;
    TSUINT8  Domain[TS_MAX_DOMAIN_LENGTH];
    TSUINT8  UserName[TS_MAX_USERNAME_LENGTH];
    TSUINT8  Password[TS_MAX_PASSWORD_LENGTH];
    TSUINT8  AlternateShell[TS_MAX_ALTERNATESHELL_LENGTH];
    TSUINT8  WorkingDir[TS_MAX_WORKINGDIR_LENGTH];
    RNS_EXTENDED_INFO_PACKET ExtraInfo;
} RNS_INFO_PACKET, FAR *PRNS_INFO_PACKET;
typedef RNS_INFO_PACKET UNALIGNED FAR *PRNS_INFO_PACKET_UA;


/****************************************************************************/
/* User Data Structures                                                     */
/****************************************************************************/

/****************************************************************************/
/* Structure: RNS_UD_HEADER                                                 */
/*                                                                          */
/* Header included in all user data structures                              */
/* - type       one of the RNS_UD constants above                           */
/* - length     length of data (including this header)                      */
/* - data       one of the data structures below                            */
/****************************************************************************/
typedef struct tagRNS_UD_HEADER
{
    TSUINT16 type;
    TSUINT16 length;
} RNS_UD_HEADER;
typedef RNS_UD_HEADER UNALIGNED FAR *PRNS_UD_HEADER;


/****************************************************************************/
/* Structure: RNS_UD_CS_CORE                                                */
/*                                                                          */
/* Client to Server core data                                               */
/* - header         standard header                                         */
/* - version        software version number                                 */
/* - desktopWidth   width of desktop in pels                                */
/* - desktopHeight  height of desktop in pels                               */
/* - colorDepth     color depth supported - see note below                  */
/* - SASSequence    SAS sequence to use - one of the SAS constants above    */
/* - keyboardLayout Keyboard layout / locale                                */
/* - clientName     Name in Unicode characters                              */
/* - keyboardType        ]                                                  */
/* - keyboardSubType     ] FE stuff                                         */
/* - keyboardFunctionKey ]                                                  */
/* - imeFileName         ]                                                  */
/* - postBeta2ColorDepth Color depth supported - see note below             */
/* - clientProductId                                                        */
/* - serialNumber                                                           */
#ifdef DC_HICOLOR
/* - highColorDepth       preferred color depth (if not 8bpp)               */
/* - supportedColorDepths high color depths supported by client             */
#endif
/****************************************************************************/
#ifdef DC_HICOLOR
/****************************************************************************/
/* Notes on color depths:                                                   */
/*                                                                          */
/* In the NT4 TSE development, beta 2 servers would only accept connections */
/* from clients requesting 8bpp - 4bpp support was only added later.  To    */
/* get around this problem while maintaining back compatibility with beta 2 */
/* servers, the postBeta2ColorDepth field was added which is recognised by  */
/* servers later than beta 2                                                */
/*                                                                          */
/* Later, support for high color depth (15, 16, and 24bpp) connections was  */
/* added to the protocol.  Again, for compatibility with old servers, new   */
/* fields are required.  The highColorDepth field contains the color depth  */
/* the client would like (one of the RNS_UD_COLOR_XX values) while the      */
/* supportedColorDepths field lists the high color depths the client is     */
/* capable of supporting (using the RNS_UD_XXBPP_SUPPORT flags ORed         */
/* together).                                                               */
/*                                                                          */
/* Thus a new client on a 24bpp system will typically advertise the         */
/* following color-related capabilities:                                    */
/*                                                                          */
/* colorDepth           = RNS_UD_COLOR_8BPP   - NT4 TSE Beta 2 servers look */
/*                                              at this field               */
/* postBeta2ColorDepth  = RNS_UD_COLOR_8BPP   - NT4 TSE and Win2000 servers */
/*                                              examine this field          */
/* highColorDepth       = RNS_UD_COLOR_24BPP  - post Win2000 (NT5.1?)       */
/* supportedColorDepths = RNS_UD_24BPP_SUPPORT  servers check these fields  */
/*                        RNS_UD_16BPP_SUPPORT  for preferred and supported */
/*                        RNS_UD_15BPP_SUPPORT  color depths                */
/*                                                                          */
/****************************************************************************/
#else
/****************************************************************************/
/* A note on color depths: A beta2 Server rejects connections from a        */
/* Client with a color depth of 4bpp.  A released Server supports this.     */
/* Therefore a new field, postBeta2ColorDepth, is added, which is           */
/* recognised by released Servers and can take the value 4bpp.  Beta2       */
/* Servers continue to check colorDepth only.                               */
/****************************************************************************/
#endif
typedef struct tagRNS_UD_CS_CORE
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      clientProductId;
    TSUINT32      serialNumber;
#ifdef DC_HICOLOR
    TSUINT16      highColorDepth;
    TSUINT16      supportedColorDepths;
#endif
    //Used to specify early capability info
    //e.g support for error info PDU has to be
    //setup before licensing (which unfortunately
    //happens after caps negotiation)
#define RNS_UD_CS_SUPPORT_ERRINFO_PDU 0x0001

    TSUINT16      earlyCapabilityFlags;  
//fix shadow loop detection
//meherm 02/09/2001
#define CLIENT_PRODUCT_ID_LENGTH 32
    TSUINT16      clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
        
} RNS_UD_CS_CORE;
typedef RNS_UD_CS_CORE UNALIGNED FAR *PRNS_UD_CS_CORE;
typedef PRNS_UD_CS_CORE UNALIGNED FAR *PPRNS_UD_CS_CORE;

// Original size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_CORE_V0
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      pad;
} RNS_UD_CS_CORE_V0, FAR *PRNS_UD_CS_CORE_V0;
typedef PRNS_UD_CS_CORE_V0 FAR *PPRNS_UD_CS_CORE_V0;

// Intermediate size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_CORE_V1
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      clientProductId;
    TSUINT32      serialNumber;
} RNS_UD_CS_CORE_V1, FAR *PRNS_UD_CS_CORE_V1;
typedef PRNS_UD_CS_CORE_V1 FAR *PPRNS_UD_CS_CORE_V1;


/****************************************************************************/
/* Structure: RNS_UD_CS_SEC                                                 */
/*                                                                          */
/* Client to Server security data                                           */
/* - header                 standard header                                 */
/* - encryptionMethods      encryption method supported by the client       */
/* - extEncryptionMethods   used by the French Locale system for backward   */
/*                          compatibility.                                  */
/****************************************************************************/
typedef struct tagRNS_UD_CS_SEC
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethods;
    TSUINT32      extEncryptionMethods;
} RNS_UD_CS_SEC;
typedef RNS_UD_CS_SEC UNALIGNED FAR *PRNS_UD_CS_SEC;
typedef PRNS_UD_CS_SEC UNALIGNED FAR *PPRNS_UD_CS_SEC;

// Original size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_SEC_V0
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethods;
} RNS_UD_CS_SEC_V0, RNS_UD_CS_SEC_V1, FAR *PRNS_UD_CS_SEC_V0, FAR *PRNS_UD_CS_SEC_V1;
typedef PRNS_UD_CS_SEC_V0 FAR *PPRNS_UD_CS_SEC_V0;

/****************************************************************************/
/* Structure: RNS_UD_CS_NET                                                 */
/*                                                                          */
/* Description: Client to Server network data                               */
/* - header             standard header                                     */
/* - channelCount       number of channel names                             */
/* - channel names                                                          */
/****************************************************************************/
typedef struct tagRNS_UD_CS_NET
{
    RNS_UD_HEADER header;
    TSUINT32      channelCount;
    /* array of CHANNEL_DEF structures follows          */
} RNS_UD_CS_NET;
typedef RNS_UD_CS_NET UNALIGNED FAR *PRNS_UD_CS_NET;
typedef PRNS_UD_CS_NET UNALIGNED FAR *PPRNS_UD_CS_NET;

/****************************************************************************/
// TS_UD_CS_CLUSTER
//
// Client-to-server information for server clustering-aware clients.
/****************************************************************************/

// Flag values.

// Client supports basic redirection.
#define TS_CLUSTER_REDIRECTION_SUPPORTED            0x01

// Bits 2..5 represent the version for the PDU
#define TS_CLUSTER_REDIRECTION_VERSION              0x3C
#define TS_CLUSTER_REDIRECTION_VERSION1             0x0
#define TS_CLUSTER_REDIRECTION_VERSION2             0x1
#define TS_CLUSTER_REDIRECTION_VERSION3             0x2
#define TS_CLUSTER_REDIRECTION_VERSION4             0x3

// Set if the client has already been redirected and the SessionID field
// in the struct contains a valid value.
#define TS_CLUSTER_REDIRECTED_SESSIONID_FIELD_VALID 0x02
#define TS_CLUSTER_REDIRECTED_SMARTCARD             0x40

typedef struct
{
    RNS_UD_HEADER header;
    TSUINT32 Flags;
    TSUINT32 RedirectedSessionID;
} TS_UD_CS_CLUSTER;
typedef TS_UD_CS_CLUSTER UNALIGNED FAR *PTS_UD_CS_CLUSTER;


/****************************************************************************/
/* Structure: RNS_UD_SC_CORE                                                */
/*                                                                          */
/* Server to Client core data                                               */
/* - header             standard header                                     */
/* - version            software version number                             */
/****************************************************************************/
typedef struct tagRNS_UD_SC_CORE
{
    RNS_UD_HEADER header;
    TSUINT32      version;
} RNS_UD_SC_CORE, FAR *PRNS_UD_SC_CORE;


/****************************************************************************/
/* Structure: RNS_UD_SC_SEC                                                 */
/*                                                                          */
/* Server to Client security data                                           */
/* - header             standard header                                     */
/* - encryptionMethod   encryption method selected by the server            */
/* - encryptionLevel    encryption level supported by the server            */
/****************************************************************************/
typedef struct tagRNS_UD_SC_SEC
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethod;
    TSUINT32      encryptionLevel;
} RNS_UD_SC_SEC, FAR *PRNS_UD_SC_SEC, FAR * FAR *PPRNS_UD_SC_SEC;


/****************************************************************************/
/* Structure: RNS_UD_SC_SEC1                                                */
/*                                                                          */
/* Server to Client security data                                           */
/* - header             standard header                                     */
/* - encryptionMethod   encryption method selected by the server            */
/* - serverRandomLen    length of the server random                         */
/* - serverCertLen      server certificate length                           */
/* - server random data                                                     */
/* - server certificate data                                                */
/****************************************************************************/
typedef struct tagRNS_UD_SC_SEC1
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethod;
    TSUINT32      encryptionLevel;
    TSUINT32      serverRandomLen;
    TSUINT32      serverCertLen;
    /* server random key data follows */
    /* server certificate data follows */
} RNS_UD_SC_SEC1, FAR *PRNS_UD_SC_SEC1;


/****************************************************************************/
/* Structure: RNS_UD_SC_NET                                                 */
/*                                                                          */
/* Server to Client network data                                            */
/* - header             standard header                                     */
/* - MCSChannelID       T128 MCS channel ID to use                          */
/* - pad                unused                                              */
/* - channelCount       number of channels                                  */
/* - channel IDs                                                            */
/****************************************************************************/
typedef struct tagRNS_UD_SC_NET
{
    RNS_UD_HEADER header;
    TSUINT16      MCSChannelID;
    TSUINT16      channelCount;  /* was pad, but always 0, in release 1   */
    /* array of 2-byte integer MCS channel IDs follows (0 = unknown)        */
} RNS_UD_SC_NET, FAR *PRNS_UD_SC_NET, FAR * FAR *PPRNS_UD_SC_NET;

/****************************************************************************/
/* Virtual channel protocol flags                                           */
/* Header flags (internal protocol use only)                                */
/****************************************************************************/
#define CHANNEL_FLAG_SHOW_PROTOCOL 0x10
#define CHANNEL_FLAG_SUSPEND       0x20
#define CHANNEL_FLAG_RESUME        0x40
#define CHANNEL_FLAG_SHADOW_PERSISTENT 0x80



#endif /* _H_AT120EX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\atrcapi.h ===
/**INC+**********************************************************************/
/* Header:    atrcapi.h                                                     */
/*                                                                          */
/* Purpose:   tracing API header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/atrcapi.h_v  $
 *
 *    Rev 1.12   05 Sep 1997 10:36:56   SJ
 * SFR1334: Zippy enhancements
 *
 *    Rev 1.11   01 Sep 1997 19:44:04   SJ
 * SFR1333: win16 trace DLL fails to set its default trace options
 *
 *    Rev 1.10   28 Aug 1997 14:46:08   SJ
 * SFR1004: Use new trace groups - modify zippy accordingly
 *
 *    Rev 1.9   22 Aug 1997 15:10:20   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.8   19 Aug 1997 10:58:26   SJ
 * SFR1219: UT_Malloc and UT_Free tracing is confusing
 *
 *    Rev 1.7   31 Jul 1997 19:40:38   SJ
 * SFR1041: Port zippy to Win16
 *
 *    Rev 1.6   14 Jul 1997 12:47:36   SJ
 * SFR1004: Use new trace groups
 *
 *    Rev 1.5   09 Jul 1997 17:05:00   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ATRCAPI
#define _H_ATRCAPI

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Define the trace level.                                                  */
/*                                                                          */
/* TRC_LEVEL_DBG         : All tracing is enabled                           */
/* TRC_LEVEL_NRM         : Debug level tracing is disabled                  */
/* TRC_LEVEL_ALT         : Normal and debug level tracing is disabled       */
/* TRC_LEVEL_ERR         : Alert, normal and debug level tracing is         */
/*                         disabled                                         */
/* TRC_LEVEL_ASSERT      : Error, alert, normal and debug level tracing     */
/*                         is disabled                                      */
/* TRC_LEVEL_DIS         : All tracing is disabled.                         */
/****************************************************************************/
#define TRC_LEVEL_DBG       0
#define TRC_LEVEL_NRM       1
#define TRC_LEVEL_ALT       2
#define TRC_LEVEL_ERR       3
#define TRC_LEVEL_ASSERT    4
#define TRC_LEVEL_DIS       5

/****************************************************************************/
/* Trace type for profile tracing (function entry / exit)                   */
/****************************************************************************/
#define TRC_PROFILE_TRACE   8

/****************************************************************************/
/* Tracing can be switched off at compile time to allow for 'debug' and     */
/* 'retail' versions of the product.  The following macros disable specific */
/* trace processing.                                                        */
/*                                                                          */
/* TRC_ENABLE_DBG    - Enable debug tracing                                 */
/* TRC_ENABLE_NRM    - Enable normal tracing                                */
/* TRC_ENABLE_ALT    - Enable alert tracing                                 */
/* TRC_ENABLE_ERR    - Enable error tracing                                 */
/* TRC_ENABLE_ASSERT - Enable assert tracing                                */
/* TRC_ENABLE_PRF    - Enable function profile tracing                      */
/****************************************************************************/
#if (TRC_CL == TRC_LEVEL_DBG)
#define TRC_ENABLE_DBG
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_NRM)
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ALT)
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ERR)
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ASSERT)
#define TRC_ENABLE_ASSERT
#endif

#ifdef TRC_CP
#define TRC_ENABLE_PRF
#endif

/****************************************************************************/
/* Component groups.  These are as follows:                                 */
/*                                                                          */
/* Client side:                                                             */
/* TRC_GROUP_NETWORK             : Network layer                            */
/* TRC_GROUP_SECURITY            : Security layer                           */
/* TRC_GROUP_CORE                : The core                                 */
/* TRC_GROUP_UI                  : User Interface                           */
/* TRC_GROUP_UTILITIES           : Utilities                                */
/* TRC_GROUP_UNUSEDx             : UNUSED                                   */
/* TRC_GROUP_TRACE                                                          */
/*                                                                          */
/****************************************************************************/
#define TRC_GROUP_NETWORK                 DCFLAGN(0)
#define TRC_GROUP_SECURITY                DCFLAGN(1)
#define TRC_GROUP_CORE                    DCFLAGN(2)
#define TRC_GROUP_UI                      DCFLAGN(3)
#define TRC_GROUP_UTILITIES               DCFLAGN(4)
#define TRC_GROUP_UNUSED1                 DCFLAGN(5)
#define TRC_GROUP_UNUSED2                 DCFLAGN(6)
#define TRC_GROUP_UNUSED3                 DCFLAGN(7)
#define TRC_GROUP_UNUSED4                 DCFLAGN(8)
#define TRC_GROUP_UNUSED5                 DCFLAGN(9)
#define TRC_GROUP_TRACE                   DCFLAGN(10)

/****************************************************************************/
/* TRC_GROUP must be defined - if it is not defined then display an error.  */
/****************************************************************************/
#ifndef TRC_GROUP
#error  TRC_GROUP must be defined
#endif /* ifndef TRC_GROUP */

/****************************************************************************/
/* Trace option flags.  These set various tracing options as follows:       */
/*                                                                          */
/* TRC_OPT_BREAK_ON_ERROR      : Break to the debugger on an error.         */
/* TRC_OPT_BEEP_ON_ERROR       : Beep on an error.                          */
/* TRC_OPT_FILE_OUTPUT         : Direct trace output to a disk file.        */
/* TRC_OPT_DEBUGGER_OUTPUT     : Direct trace output to the debugger.       */
/* TRC_OPT_FLUSH_ON_TRACE      : Flush each trace line to the disk file.    */
/* TRC_OPT_PROFILE_TRACING     : Enable profile tracing.                    */
/* TRC_OPT_STACK_TRACING       : Enable stack tracing.                      */
/* TRC_OPT_PROCESS_ID          : Display the process ID on every trace line.*/
/* TRC_OPT_THREAD_ID           : Display the thread (Win32 only) on every   */
/*                               trace line.                                */
/* TRC_OPT_TIME_STAMP          : Display the time stamp on every line.      */
/* TRC_OPT_RELATIVE_TIME_STAMP : (Reserved) Display the relative time.      */
/* TRC_OPT_BREAK_ON_ASSERT     : Break to the debugger on ASSERTS           */
/****************************************************************************/
#define TRC_OPT_BREAK_ON_ERROR          DCFLAG32(0)
#define TRC_OPT_BEEP_ON_ERROR           DCFLAG32(1)
#define TRC_OPT_FILE_OUTPUT             DCFLAG32(2)
#define TRC_OPT_DEBUGGER_OUTPUT         DCFLAG32(3)
#define TRC_OPT_FLUSH_ON_TRACE          DCFLAG32(4)
#define TRC_OPT_PROFILE_TRACING         DCFLAG32(5)
#define TRC_OPT_STACK_TRACING           DCFLAG32(6)
#define TRC_OPT_PROCESS_ID              DCFLAG32(7)
#define TRC_OPT_THREAD_ID               DCFLAG32(8)
#define TRC_OPT_TIME_STAMP              DCFLAG32(9)
#define TRC_OPT_RELATIVE_TIME_STAMP     DCFLAG32(10)
#define TRC_OPT_BREAK_ON_ASSERT         DCFLAG32(11)

/****************************************************************************/
/* Character versions of the maximum and minimum trace levels.              */
/****************************************************************************/
#define TRC_LEVEL_MIN_CHAR     '0'
#define TRC_LEVEL_MAX_CHAR     '5'

/****************************************************************************/
/* Character for function entry / exit tracing.                             */
/****************************************************************************/
#define TRC_LEVEL_PRF_CHAR     'P'

/****************************************************************************/
/* The TRC_TEST macro can be compiled in or out.  When compiled in, it is   */
/* equivalent to TRC_DBG.  It is normally compiled out.  To compile it in,  */
/* define TRC_ENABLE_TST.                                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_TST
#define TRC_TST  TRC_DBG
#else
#define TRC_TST(x)
#endif /* TRC_ENABLE_TST */

/****************************************************************************/
/* The trace function naming macro.                                         */
/****************************************************************************/
#if (TRC_CL < TRC_LEVEL_DIS)
#define TRC_FN(A)       static const DCTCHAR __fnname[]  = _T(A);           \
                        PDCTCHAR trc_fn = (PDCTCHAR)__fnname;               \
                        PDCTCHAR trc_file = _file_name_;
#else
#define TRC_FN(A)
#endif

/****************************************************************************/
/* Entry and exit trace macros.                                             */
/****************************************************************************/
#define TRC_ENTRY  TRC_PRF((TB, TEXT("Enter {")));
#define TRC_EXIT   TRC_PRF((TB, TEXT("Exit  }")));

/****************************************************************************/
/* Trace buffer definition.                                                 */
/* see TRCX below                                                           */
/* the second parameter is the length of the output buffer in characters    */
/* (TRC_LINE_BUFFER_SIZE)                                                   */
/****************************************************************************/
#define TB     TRC_GetBuffer(), 255

/****************************************************************************/
/* Internal buffer sizes.                                                   */
/*                                                                          */
/* TRC_PREFIX_LIST_SIZE  : the length of the prefix string                  */
/* TRC_LINE_BUFFER_SIZE  : the length of the raw trace string as output by  */
/*                         an application                                   */
/* TRC_FRMT_BUFFER_SIZE  : the length of the formatted trace string         */
/*                         buffer - this includes the time, process ID,     */
/*                         thread ID and function name - It must be longer  */
/*                         than TRC_LINE_BUFFER_SIZE                        */
/* TRC_FILE_NAME_SIZE    : the maximum length of the fully qualified        */
/*                         trace output file name.                          */
/****************************************************************************/
#define TRC_PREFIX_LIST_SIZE             100
#define TRC_LINE_BUFFER_SIZE             256
#define TRC_FRMT_BUFFER_SIZE             400
#define TRC_FILE_NAME_SIZE       DC_MAX_PATH

/****************************************************************************/
/* The number of trace files.  This must be set to 2 - any other number is  */
/* not supported.                                                           */
/****************************************************************************/
#define TRC_NUM_FILES                      2

/****************************************************************************/
/* The minimum and maximum file sizes.                                      */
/* In Win32, the trace DLL will fail to initialize if the file size is set  */
/* to zero or to too high a value.                                          */
/* Go for 1 Kb to 32 Meg.                                                   */
/****************************************************************************/
#define TRC_MIN_TRC_FILE_SIZE      (0x400)
#define TRC_MAX_TRC_FILE_SIZE  (0x2000000)

/****************************************************************************/
/* Defaults                                                                 */
/****************************************************************************/
/****************************************************************************/
/* This is a copy of the comment in TRCSetDefaults, which should be updated */
/* whenever these defaults change.                                          */
/*                                                                          */
/* We set the following things:                                             */
/*                                                                          */
/* - trace level to Alert.                                                  */
/* - enable all component groups.                                           */
/* - remove all prefixes.                                                   */
/* - set the maximum trace file size to the default value.                  */
/* - set the data truncation size to the default value.                     */
/* - set the function name size to the default value.                       */
/* - enable the beep and file flags.                                        */
/* - set the first trace file name to TRC1.TXT                              */
/* - set the second trace file name to TRC2.TXT                             */
/* In Win32, additionally                                                   */
/* - set time stamp                                                         */
/* - set process ID                                                         */
/* - set thread ID                                                          */
/*                                                                          */
/****************************************************************************/
#define TRC_DEFAULT_MAX_FILE_SIZE    (100000)
#define TRC_DEFAULT_FUNC_NAME_LENGTH (12)
#define TRC_DEFAULT_DATA_TRUNC_SIZE  (64)
#define TRC_DEFAULT_PREFIX_LIST      (0)
#define TRC_DEFAULT_COMPONENTS       (0xFFFFFFFF)
#ifdef OS_WIN32
#ifdef OS_WINCE
#define TRC_DEFAULT_FLAGS            (TRC_OPT_BEEP_ON_ERROR | \
                                      TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_THREAD_ID | \
                                      TRC_OPT_TIME_STAMP  )
#else // OS_WINCE
#define TRC_DEFAULT_FLAGS            (TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_FILE_OUTPUT | \
                                      TRC_OPT_PROCESS_ID | \
                                      TRC_OPT_THREAD_ID | \
                                      TRC_OPT_TIME_STAMP  )
#endif // OS_WINCE
#else ifdef OS_WIN16
#define TRC_DEFAULT_FLAGS            (TRC_OPT_BEEP_ON_ERROR | \
                                      TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_FILE_OUTPUT )
#endif

#define TRC_DEFAULT_TRACE_LEVEL      (TRC_LEVEL_ERR)
#define TRC_DEFAULT_FILE_NAME0       (_T("TRC1.TXT"))
#define TRC_DEFAULT_FILE_NAME1       (_T("TRC2.TXT"))

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_CONFIG                                                               */
/* ==========                                                               */
/* This structure stores information about the current trace configuration. */
/*                                                                          */
/* traceLevel         : the current trace level.                            */
/* components         : currently enabled component groups.                 */
/* maxFileSize        : the maximum trace file size.                        */
/* dataTruncSize      : the amount of data that can be traced at a time.    */
/* flags              : trace flags.                                        */
/* funcNameLength     : number of characters of the function name traced to */
/*                      the output file.                                    */
/* prefixList         : a list of prefixes.                                 */
/* fileNames          : the name of the trace files.                        */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_CONFIG
{
    DCUINT32    traceLevel;
    DCUINT32    dataTruncSize;
    DCUINT32    funcNameLength;
    DCUINT32    components;
    DCUINT32    maxFileSize;
    DCUINT32    flags;
    DCTCHAR     prefixList[TRC_PREFIX_LIST_SIZE];
    DCTCHAR     fileNames[TRC_NUM_FILES][TRC_FILE_NAME_SIZE];
} TRC_CONFIG;

typedef TRC_CONFIG DCPTR PTRC_CONFIG;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* STANDARD TRACING AND ASSERTION MACROS                                    */
/*                                                                          */
/* TRC_ASSERT is for internal assertions and traces an error before popping */
/* up a message box and then terminating.  It is not NLS enabled and should */
/* only be used for calls from one DC component to another.  External APIs  */
/* must not use TRC_ASSERT.                                                 */
/*                                                                          */
/* TRC_ABORT is used on logically unreachable paths (for example            */
/* the default brach of a switch which should cover all cases already).     */
/*                                                                          */
/* A typical trace statement will have the form:                            */
/*                                                                          */
/*    TRC_NRM((TB, _T("Hello world: %hu"), worldNumber));                   */
/*                                                                          */
/* The following macros either expand this to:                              */
/*                                                                          */
/*    TRCX(TRC_LEVEL_NRM, (TB, _T("Hello world: %hu"), worldNumber));       */
/*                                                                          */
/* if normal level tracing is enabled or ignore it if normal level tracing  */
/* is disabled.                                                             */
/*                                                                          */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DBG(string)   TRCX(TRC_LEVEL_DBG, string)
#else
#define TRC_DBG(string)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_NRM(string)   TRCX(TRC_LEVEL_NRM, string)
#else
#define TRC_NRM(string)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_ALT(string)   TRCX(TRC_LEVEL_ALT, string)
#else
#define TRC_ALT(string)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_ERR(string)   TRCX(TRC_LEVEL_ERR, string)
#else
#define TRC_ERR(string)
#endif

#ifdef TRC_ENABLE_ASSERT
#define TRC_ASSERT(condition, string)                                        \
              if (!(condition))   TRCX(TRC_LEVEL_ASSERT, string)
#define TRC_ABORT(string)         TRCX(TRC_LEVEL_ASSERT, string)
#else
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#endif

/****************************************************************************/
/* Function profile (entry/exit) tracing.                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_PRF
#define TRC_PRF(string)   TRCP(string)
#else
#define TRC_PRF(string)
#endif

VOID TRCSaferSprintf(PDCTCHAR outBuf, UINT cchLen, const PDCTCHAR format,...);

/****************************************************************************/
/* Now define the actual tracing macro, TRCX.  This macro compares the      */
/* tracer's level against the global trace level.  If the tracer's level is */
/* the same or higher than the global trace level then we:                  */
/*                                                                          */
/* - print the 'string' which is in the form:                               */
/*   (TB, _T("Hello world %hu"), worldNumber) which expands to              */
/*   (TRC_BufferGet(), "Hello world %hu", worldNumber)                      */
/* - call TRC_BufferTrace to actually trace the line out.                   */
/*                                                                          */
/* Note that TRC_BufferGet() also grabs the mutex to prevent other threads  */
/* from pre-empting us while we are tracing and that TRC_BufferTrace() will */
/* free the mutex for us once the trace line has been written.              */
/****************************************************************************/

/****************************************************************************/
/* Use the comma operator to make sure that TRCX macros to an Lvalue.       */
/* The innermost trc_fn is simply there to ensure that the whole expression */
/* is assignable.  It can be replaced by any other variable, if need be.    */
/****************************************************************************/
#if !defined(TRC_CONVERTOANSI)
#define TRCX(level, string)                                                  \
    (                                                                        \
     (level >= TRC_GetTraceLevel()) ?                                        \
     (                                                                       \
      (TRCSaferSprintf string,                                               \
       TRC_TraceBuffer(level, TRC_GROUP, (DCUINT)__LINE__, trc_fn, trc_file),\
       trc_fn)                                                               \
     )                                                                       \
     :                                                                       \
     0                                                                       \
    )

#define TRCP(string)                                                         \
    {                                                                        \
        if (TRC_ProfileTraceEnabled())                                       \
        {                                                                    \
            TRCSaferSprintf string,                                          \
            TRC_TraceBuffer(TRC_PROFILE_TRACE,                               \
                            TRC_GROUP,                                       \
                            (DCUINT)__LINE__,                                \
                            trc_fn,                                          \
                            trc_file);                                       \
        }                                                                    \
    }
#else
#define TRCX(level, string)                                                  \
    (                                                                        \
     (level >= TRC_GetTraceLevel()) ?                                        \
     (                                                                       \
      (                                                                      \
       TRC_ConvertAndSprintf string,                                         \
       TRC_TraceBuffer(level, TRC_GROUP, (DCUINT)__LINE__, trc_fn, trc_file),\
       trc_fn)                                                               \
     )                                                                       \
     :                                                                       \
     0                                                                       \
    )

#define TRCP(string)                                                         \
    {                                                                        \
        if (TRC_ProfileTraceEnabled())                                       \
        {                                                                    \
            TRC_ConvertAndSprintf string;                                    \
            TRC_TraceBuffer(TRC_PROFILE_TRACE,                               \
                            TRC_GROUP,                                       \
                            (DCUINT)__LINE__,                                \
                            trc_fn,                                          \
                            trc_file);                                       \
        }                                                                    \
    }
#endif

/****************************************************************************/
/* TRACE DATA MACROS                                                        */
/*                                                                          */
/* These are very similar to the standard tracing macros defined above      */
/* except that they do not accept a variable number of parameters.          */
/*                                                                          */
/* A typical ObMan data trace line will have the form:                      */
/*                                                                          */
/*    TRC_DATA_NRM("Some data", pData, sizeof(SOME_DATA));                  */
/*                                                                          */
/* If the appropriate level of tracing is enabled (normal in this case)     */
/* then this line will be expanded by the following macros to:              */
/*                                                                          */
/*    TRCX_DATA(TRC_GROUP_OBMAN, TRC_LEVEL_NRM, "Some data", pData, size);  */
/*                                                                          */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DATA_DBG(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_DBG, _T(string), buffer, length)
#else
#define TRC_DATA_DBG(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NRM(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_NRM, _T(string), buffer, length)
#else
#define TRC_DATA_NRM(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_DATA_ALT(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_ALT, _T(string), buffer, length)
#else
#define TRC_DATA_ALT(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_DATA_ERR(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_ERR, _T(string), buffer, length)
#else
#define TRC_DATA_ERR(string, buffer, length)
#endif

/****************************************************************************/
/* Network, TDD and Obman trace data macros - these are just normal level   */
/* data tracing.                                                            */
/****************************************************************************/
#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NET(string, buffer, length)                                 \
         TRCX_DATA(TRC_GROUP_NETDATA, TRC_LEVEL_NRM, string, buffer, length)
#define TRC_DATA_TDD(string, buffer, length)                                 \
         TRCX_DATA(TRC_GROUP_TDDDATA, TRC_LEVEL_NRM, string, buffer, length)
#define TRC_DATA_OBMAN(string, buffer, length)                               \
         TRCX_DATA(TRC_GROUP_OBMANDATA, TRC_LEVEL_NRM, string, buffer, length)
#else
#define TRC_DATA_NET(string, buffer, length)
#define TRC_DATA_TDD(string, buffer, length)
#define TRC_DATA_OBMAN(string, buffer, length)
#endif

/****************************************************************************/
/* Define the trace data macro.  This is used for tracing data blocks.      */
/****************************************************************************/
#define TRCX_DATA(group, level, string, buffer, length)                      \
    {                                                                        \
        if (level >= TRC_GetTraceLevel())                                    \
        {                                                                    \
            TRCSaferSprintf(TB, string);                                     \
            TRC_TraceData(level,                                             \
                          group,                                             \
                          (DCINT)__LINE__,                                   \
                          trc_fn,                                            \
                          trc_file,                                          \
                          (PDCUINT8)buffer,                                  \
                          length);                                           \
        }                                                                    \
    }

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_Initialize                                                           */
/* TRC_Terminate                                                            */
/* TRC_GetBuffer                                                            */
/* TRC_TraceBuffer                                                          */
/* TRC_GetConfig                                                            */
/* TRC_SetConfig                                                            */
/* TRC_TraceData                                                            */
/* TRC_GetTraceLevel                                                        */
/* TRC_ProfileTraceEnabled                                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* API FUNCTION: TRC_Initialize(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function initializes the tracing for this component.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* initShared    : Boolean indicating whether we should attempt to create   */
/*                 the trace config shared memory or not.                   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0             : success.                                                 */
/* TRC_RC_XXX    : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT32 DCAPI TRC_Initialize(DCBOOL initShared);

/****************************************************************************/
/* API FUNCTION: TRC_Terminate(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function terminates tracing for this component.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* termShared    : Boolean indicating if shared memory should be released   */
/*                 or not.                                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_Terminate(DCBOOL termShared);

/****************************************************************************/
/* API FUNCTION: TRC_GetBuffer(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function grabs the mutex and returns a pointer to the trace         */
/* buffer.                                                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* A pointer to the trace buffer.                                           */
/*                                                                          */
/****************************************************************************/
PDCTCHAR DCAPI TRC_GetBuffer(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_TraceBuffer(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function copies the trace line that is currently in the trace       */
/* buffer into the trace file and / or to the debugger. It assumes that the */
/* mutex has already been acquired before it is called and releases the     */
/* mutex before returning.                                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel     : the requested trace level.                              */
/* traceComponent : the component group that the source file is in.         */
/* lineNumber     : the line number of the source file traced from.         */
/* funcName       : the function name traced from.                          */
/* fileName       : the file name of the module requesting trace.           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_TraceBuffer(DCUINT   traceLevel,
                             DCUINT   traceComponent,
                             DCUINT   lineNumber,
                             PDCTCHAR funcName,
                             PDCTCHAR fileName);

/****************************************************************************/
/* API FUNCTION: TRC_GetConfig(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function copies the current trace settings into the buffer pointed  */
/* to by pTraceConfig.                                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTraceConfig  : a pointer to a TRC_CONFIG structure.                     */
/* length        : the length of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE          : success.                                                 */
/* FALSE         : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_GetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length);

/****************************************************************************/
/* API FUNCTION: TRC_SetConfig(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace configuration to that specified in the      */
/* passed TRC_CONFIG structure.                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTraceConfig  : a pointer to a TRC_CONFIG structure.                     */
/* length        : the length of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE          : success.                                                 */
/* FALSE         : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_SetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length);

/****************************************************************************/
/* API FUNCTION: TRC_TraceData(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel     : the requested trace level.                              */
/* traceComponent : the component group that the source file is in.         */
/* lineNumber     : the line number of the source file traced from.         */
/* funcName       : the function name traced from.                          */
/* fileName       : the file name of the module requesting trace.           */
/* buffer         : the actual data to be traced.                           */
/* bufLength      : the length of the data.                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_TraceData(DCUINT   traceLevel,
                           DCUINT   traceComponent,
                           DCUINT   lineNumber,
                           PDCTCHAR funcName,
                           PDCTCHAR fileName,
                           PDCUINT8 buffer,
                           DCUINT   bufLength);

/****************************************************************************/
/* API FUNCTION: TRC_GetTraceLevel(...)                                     */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function returns the current trace level.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* The current trace level.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT DCAPI TRC_GetTraceLevel(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_ProfileTraceEnabled(...)                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function returns the function entry/exit trace setting.             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE / FALSE - is the profile tracing enabled.                           */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_ProfileTraceEnabled(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_ResetTraceFiles(...)                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function resets the trace files.  After checking that trace is      */
/* initialized it calls the OS specific internal function.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE / FALSE - is the profile tracing enabled.                           */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_ResetTraceFiles(DCVOID);


/****************************************************************************/
/* Before including this file the TRC_FILE macro should be defined.  This   */
/* is much more efficient than relying on __FILE__ to give the correct      */
/* filename since it includes unnecessary path info (and extension info).   */
/* In addition each use of __FILE__ causes a new constant string to be      */
/* placed in the data segment.                                              */
/****************************************************************************/
#if (TRC_CL < TRC_LEVEL_DIS)

    /************************************************************************/
    /* Define another layer for _T() to work around preprocessor problems   */
    /************************************************************************/
#define TRC_T(x) _T(x)

#ifdef TRC_FILE
#define _file_name_ (PDCTCHAR)__filename
static const DCTCHAR __filename[] = TRC_T(TRC_FILE);
#endif /* TRC_FILE */

#endif

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcapi.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _H_ATRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\atrcint.h ===
/**INC+**********************************************************************/
/* Header:    atrcint.h                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions header                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/atrcint.h_v  $
 *
 *    Rev 1.5   10 Jul 1997 18:06:00   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   10 Jul 1997 17:16:14   KH
 * SFR1022: Get 16-bit trace working
**/
/**INC-**********************************************************************/
#ifndef _H_ATRCINT
#define _H_ATRCINT

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Internal trace state flags.  Trace can be in one of three states:        */
/*                                                                          */
/*  TRC_STATE_UNINTIALIZED : trace has been loaded but not been             */
/*                           initialized.  If a call is made to output a    */
/*                           line then trace will automatically intialize   */
/*                           itself and move to TRC_STATE_INITIALIZED.      */
/*                                                                          */
/*  TRC_STATE_INITIALIZED  : this is the normal state - trace is loaded and */
/*                           initialized.  Outputting of trace lines is     */
/*                           permitted in this mode.                        */
/*                                                                          */
/*  TRC_STATE_TERMINATED   : trace has been terminated.  Outputting of      */
/*                           trace lines is no longer allowed and any calls */
/*                           to output a line will be rejected.             */
/*                                                                          */
/****************************************************************************/
#define TRC_STATE_UNINITIALIZED        0
#define TRC_STATE_INITIALIZED          1
#define TRC_STATE_TERMINATED           2

/****************************************************************************/
/* Internal trace status flags.  These are used in the <trcStatus> field of */
/* the TRC_SHARED_DATA structure.                                           */
/*                                                                          */
/* TRC_STATUS_ASSERT_DISPLAYED         : is an assert box displayed?        */
/****************************************************************************/
#define TRC_STATUS_ASSERT_DISPLAYED    DCFLAG32(0)

/****************************************************************************/
/* Trace format definitions.  These are used for printing various parts of  */
/* the trace lines.                                                         */
/*                                                                          */
/* TIME     is the time in the form hours, mins, secs, hundredths.          */
/* DATE     is the date in the form day, month, year.                       */
/* FUNC     is the module function name.  This is of variable size.         */
/* LINE     is the line number within the source file.                      */
/* PROC     is the process identifier.                                      */
/* THRD     is the thread identifier.                                       */
/*                                                                          */
/****************************************************************************/
#define TRC_TIME_FMT                   _T("%02d:%02d:%02d.%02d")
#define TRC_DATE_FMT                   _T("%02d/%02d/%02d")
#define TRC_FUNC_FMT                   _T("%-*.*s")
#define TRC_LINE_FMT                   _T("%04d")
#define TRC_PROC_FMT                   _T("%04.4lx")
#define TRC_THRD_FMT                   _T("%04.4lx")

/****************************************************************************/
/* Assert box title                                                         */
/****************************************************************************/
#define TRC_ASSERT_TITLE     _T("ASSERTion failed")

/****************************************************************************/
/* Internal buffer sizes.                                                   */
/*                                                                          */
/* TRC_NUM_PREFIXES      : the number of prefixes supported.                */
/* TRC_PREFIX_LENGTH     : the length of each prefix string.                */
/* TRC_MAX_SYMNAME_SIZE  : the maximum length of a symbol name.             */
/****************************************************************************/
#define TRC_NUM_PREFIXES               20
#define TRC_PREFIX_LENGTH              8
#define TRC_MAX_SYMNAME_SIZE           1024

/****************************************************************************/
/* Maximum number of functions to write out in a stack trace.               */
/****************************************************************************/
#define TRC_MAX_SIZE_STACK_TRACE       100

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_FILTER                                                               */
/* ==========                                                               */
/* The pointer to the filter definition for internal tracing                */
/*                                                                          */
/* trcStatus         : status flag to prevent multiple assert displays.     */
/* trcPfxNameArray   : prefix name array.                                   */
/* trcPfxLevelArray  : prefix level array.                                  */
/* trcPfxFnLvlArray  : prefix function entry/exit trace flag array.         */
/* trcPfxStartArray  : prefix line number range start                       */
/* trcPfxEndArray    : prefix line number range end                         */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_FILTER
{
    DCUINT32 trcStatus;
    DCTCHAR  trcPfxNameArray[TRC_NUM_PREFIXES][TRC_PREFIX_LENGTH];
    DCUINT32 trcPfxLevelArray[TRC_NUM_PREFIXES];
    DCBOOL32 trcPfxFnLvlArray[TRC_NUM_PREFIXES];
    DCUINT32 trcPfxStartArray[TRC_NUM_PREFIXES];
    DCUINT32 trcPfxEndArray[TRC_NUM_PREFIXES];
} TRC_FILTER;

typedef TRC_FILTER  DCPTR PTRC_FILTER;

/****************************************************************************/
/* TRC_LINE                                                                 */
/* ========                                                                 */
/* The TRC_LINE structure defines the format of a data trace line header.   */
/*                                                                          */
/* address    : the address of the data block.                              */
/* hexData    : the data in hex format.                                     */
/* asciiData  : the data in ascii format.                                   */
/* end        : terminating characters at the end of the line (CR+LF).      */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_LINE
{
    DCTCHAR address[10];
    DCTCHAR hexData[36];
    DCTCHAR asciiData[16];
    DCTCHAR end[3];
} TRC_LINE;

typedef TRC_LINE  DCPTR PTRC_LINE;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRCInternalError                                                         */
/* ================                                                         */
/* This macro outputs an internal error string to the debug console and     */
/* the trace file.                                                          */
/****************************************************************************/
#define TRCInternalError(pText)                                              \
{                                                                            \
    TRCOutput(pText, DC_ASTRLEN(pText), TRC_LEVEL_ALT);                      \
}

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* TRCCheckState                                                            */
/* TRCDumpLine                                                              */
/* TRCInternalTrace                                                         */
/* TRCOutput                                                                */
/* TRCReadFlag                                                              */
/* TRCReadSharedDataConfig                                                  */
/* TRCResetTraceFiles                                                       */
/* TRCSetDefaults                                                           */
/* TRCShouldTraceThis                                                       */
/* TRCSplitPrefixes                                                         */
/* TRCStrnicmp                                                              */
/* TRCWriteFlag                                                             */
/* TRCWriteSharedDataConfig                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL32 DCINTERNAL TRCCheckState(DCVOID);

DCVOID DCINTERNAL TRCDumpLine(PDCUINT8 buffer,
                              DCUINT   length,
                              DCUINT32 offset,
                              DCUINT   traceLevel);

DCVOID DCINTERNAL TRCInternalTrace(DCUINT32 type);

DCVOID DCINTERNAL TRCOutput(PDCTCHAR pText,
                            DCINT    length,
                            DCINT    traceLevel);

DCVOID DCINTERNAL TRCReadFlag(PDCTCHAR  entryName,
                              DCUINT32  flag,
                              PDCUINT32 pSetting);

DCVOID DCINTERNAL TRCReadSharedDataConfig(DCVOID);

DCVOID DCINTERNAL TRCResetTraceFiles(DCVOID);

DCVOID DCINTERNAL TRCSetDefaults(DCVOID);

DCBOOL DCINTERNAL TRCShouldTraceThis(DCUINT32 traceComponent,
                                     DCUINT32 traceLevel,
                                     PDCTCHAR pFileName,
                                     DCUINT32 lineNumber);

DCVOID DCINTERNAL TRCSplitPrefixes(DCVOID);

DCINT32 DCINTERNAL TRCStrnicmp(PDCTCHAR pSource,
                               PDCTCHAR pTarget,
                               DCUINT32 count);

DCVOID DCINTERNAL TRCWriteFlag(PDCTCHAR entryName,
                               DCUINT32 flag,
                               DCUINT32 setting);

DCVOID DCINTERNAL TRCWriteSharedDataConfig(DCVOID);

DCVOID DCINTERNAL TRCNotifyAllTasks(DCVOID);

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcint.h>

#endif /* _H_ATRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ddcgcfnc.h ===
/****************************************************************************/
/*                                                                          */
/* ddcgcfnc.h                                                               */
/*                                                                          */
/* DC-Groupware C runtime functions - Windows 3.1 specific header.          */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/ddcgcfnc.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 15:06:22   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/
#ifndef _H_DDCGCFNC
#define _H_DDCGCFNC



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

#endif /* _H_DDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ddcgctyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ddcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows 3.1 specific header.                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/* $Log:   Y:/logs/h/dcl/ddcgctyp.h_v  $                                                                    */
//
//    Rev 1.6   15 Sep 1997 18:28:26   AK
// SFR1416: Move SD_BOTH definition
//
//    Rev 1.5   14 Aug 1997 14:03:00   KH
// SFR1022: Define (Ext)TextOutX macros
//
//    Rev 1.4   24 Jul 1997 16:54:14   KH
// SFR1033: Add GetLastError
//
//    Rev 1.3   08 Jul 1997 08:46:52   KH
// SFR1022: Add message parameter extraction macros
//
//    Rev 1.2   25 Jun 1997 14:38:12   KH
// Win16Port: 16-bit complex types
//
//    Rev 1.1   19 Jun 1997 15:09:56   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_DDCGCTYP
#define _H_DDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
#include <toolhelp.h>
#include <string.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Message box type flag unsupported on Win 3.x                             */
/****************************************************************************/
#define MB_SETFOREGROUND 0

/****************************************************************************/
/* Registry stuff not defined in standard 16-bit headers.                   */
/****************************************************************************/
/* from winreg.h */
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
/* from ntddk.h */
#define REG_SZ              ( 1 ) /* Unicode nul terminated string          */
#define REG_EXPAND_SZ       ( 2 ) /* Unicode nul terminated string          */
                                  /* (with environment variable references) */
#define REG_BINARY          ( 3 ) /* Free form binary                       */
#define REG_DWORD           ( 4 ) /* 32-bit number                          */

/****************************************************************************/
/* 32-bit scroll bar constants.                                             */
/****************************************************************************/
#define SIF_RANGE           0x0001
#define SIF_PAGE            0x0002
#define SIF_POS             0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS        0x0010
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef MINMAXINFO              DCPTR  LPMINMAXINFO;
typedef struct tagDCLARGEINTEGER
{
    DCUINT32 LowPart;
    DCINT32  HighPart;
} DCLARGEINTEGER;

/****************************************************************************/
/* Scroll bar info used by 32-bit API.                                      */
/****************************************************************************/
typedef struct tagSCROLLINFO
{
    DCUINT cbSize;
    DCUINT fMask;
    DCINT  nMin;
    DCINT  nMax;
    DCUINT nPage;
    DCINT  nPos;
    DCINT  nTrackPos;
}   SCROLLINFO, DCPTR LPSCROLLINFO;

/****************************************************************************/
/* Types which should not feature in a 16-bit build. Define to nonsense so  */
/* any 16-bit useage is caught at compile time.                             */
/****************************************************************************/
#define DCSURFACEID             *** ERROR ***
#define PDCSURFACEID            *** ERROR ***

/****************************************************************************/
/* Types used by DC-Groupware tracing                                       */
/****************************************************************************/
typedef DWORD HKEY;
typedef struct tagDCFILETIME
{
    DCUINT32 dwLowDateTime;
    DCUINT32 dwHighDateTime;
} DCFILETIME;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Unicode support for 16-bit client                                        */
/****************************************************************************/
#define ExtTextOutW(a, b, c, d, e, f, g, h) \
    (ExtTextOut(a, b, c, d, e, f, g, h))
#define ExtTextOutA(a, b, c, d, e, f, g, h) \
    (ExtTextOut(a, b, c, d, e, f, g, h))
#define TextOutW(a, b, c, d, e) (TextOut(a, b, c, d, e))
#define TextOutA(a, b, c, d, e) (TextOut(a, b, c, d, e))

/****************************************************************************/
/* String manipulation                                                      */
/****************************************************************************/
#define DC_CHARNEXT(pCurrentChar) (AnsiNext(pCurrentChar))
#define DC_CHARPREV(pStringStart, pCurrentChar) \
                                       (AnsiPrev(pStringStart, pCurrentChar))
#define DC_CHARLOWER(pString) (AnsiLower(pString))

/****************************************************************************/
/* Memory functions                                                         */
/****************************************************************************/
#define ZeroMemory(A,L) (DC_MEMSET(A,0,L))

/****************************************************************************/
/* Construct a 16-bit value fom two 8-bit values                            */
/****************************************************************************/
#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))

/****************************************************************************/
/* No GetLastError support on win31                                         */
/****************************************************************************/
#define GetLastError() (0)

/****************************************************************************/
/* Message parameter extraction macros.                                     */
/****************************************************************************/
/* WM_COMMAND                                                               */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     command identifier          notification code (HI),           */
/*                                        command identifier (LO)           */
/* lParam     control hwnd (HI),          control hwnd                      */
/*            notification code (LO)                                        */
/****************************************************************************/
#define DC_GET_WM_COMMAND_ID(wParam) (wParam)
#define DC_GET_WM_COMMAND_NOTIFY_CODE(wParam, lParam) (HIWORD(lParam))
#define DC_GET_WM_COMMAND_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/* WM_ACTIVATE                                                              */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     activation flag             minimized flag (HI),              */
/*                                        activation flag (LO)              */
/* lParam     minimized flag (HI),        hwnd                              */
/*            hwnd (LO)                                                     */
/****************************************************************************/
#define DC_GET_WM_ACTIVATE_ACTIVATION(wParam) (wParam)
#define DC_GET_WM_ACTIVATE_MINIMIZED(wParam, lParam) (HIWORD(lParam))
#define DC_GET_WM_ACTIVATE_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/* WM_HSCROLL and WM_VSCROLL                                                */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     scroll code                 position (HI),                    */
/*                                        scroll code (LO)                  */
/* lParam     hwnd (HI),                  hwnd                              */
/*            position (LO)                                                 */
/****************************************************************************/
#define DC_GET_WM_SCROLL_CODE(wParam) (wParam)
#define DC_GET_WM_SCROLL_POSITION(wParam, lParam) (LOWORD(lParam))
#define DC_GET_WM_SCROLL_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
extern DCVOID FAR PASCAL DOS3Call(DCVOID);

#endif /* _H_DDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ddcgmcro.h ===
/****************************************************************************/
/*                                                                          */
/* ddcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows 3.1 specific header.                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/ddcgmcro.h_v  $                                                                   */
// 
//    Rev 1.3   17 Jul 1997 18:22:10   JPB
// SFR1031: Fixed FIELDSIZE macro for Win16
//
//    Rev 1.2   25 Jun 1997 14:43:28   KH
// Win16Port: 16-bit macros
//
//    Rev 1.1   19 Jun 1997 15:15:58   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/
#ifndef _H_DDCGMCRO
#define _H_DDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Fieldsize macro.                                                         */
/****************************************************************************/
#define FIELDSIZE(type, field)   (sizeof(((type NEAR*)1)->field))

#endif /* _H_DDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ddcgperf.h ===
/**INC+**********************************************************************/
/* Header:  ddcgperf.h                                                      */
/*                                                                          */
/* Purpose: Performance monitoring - Windows 3.1 dummy header.              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ddcgperf.h_v  $
 * 
 *    Rev 1.1   15 Jul 1997 15:31:52   MD
 * SFR1029: Create performance build
**/
/**INC-**********************************************************************/
#ifndef _H_DDCGPERF
#define _H_DDCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* We don't have any support for performance monitoring on Win3.1 so define */
/* all the macros to null.                                                  */
/****************************************************************************/
#define PRF_INC_COUNTER(x)
#define PRF_ADD_COUNTER(x,n)
#define PRF_SET_RAWCOUNT(x,n)
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#endif /* _H_DDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\dtrcctl.h ===
/****************************************************************************/
/* NTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control file                                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/dtrcctl.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 15:21:46   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Win16 always includes all functions.                                     */
/****************************************************************************/
#define INC_TRC_ResetTraceFiles
#define INC_TRCOutput
#define INC_TRCReadFlag
#define INC_TRCSetDefaults
#define INC_TRCReadSharedDataConfig
#define INC_TRCWriteFlag
#define INC_TRCWriteSharedDataConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\mcskernl.h ===
/* (C) 1996-1999 Microsoft Corp.
 *
 * file   : MCSKernl.h
 * author : Erik Mavrinac
 *
 * description: Kernel mode MCS initialization and user attachment interface
 *   definitions which supplement common definitions of MCSCommn.h.
 */

#ifndef __MCSKERNL_H
#define __MCSKERNL_H


#include "MCSCommn.h"
#include "MCSIoctl.h"


/*
 * Defines
 */

// Required prefix bytes when allocating a user mode buffer or
//   kernel mode OutBuf when making a send-data request. Allows reuse
//   of the buffer for local indications and constructing PDUs.
// Must be the greater of 16 bytes or sizeof(MCSSendDataIndicationIoctl).
#define SendDataReqPrefixBytes sizeof(SendDataIndicationIoctl)

// Used when allocating memory for send-data request, allows ASN.1
//   segmentation while copying the least amount of data.
#define SendDataReqSuffixBytes 2



/*
 * API prototypes.
 */

#ifdef __cplusplus
extern "C" {
#endif


// Prototypes for functons dealing with ICA stack ioctls downward and TD
//   data coming upward.
NTSTATUS MCSIcaChannelInput(void *, CHANNELCLASS,
        VIRTUALCHANNELCLASS, PINBUF, BYTE *, ULONG);
NTSTATUS MCSIcaRawInput(void *, PINBUF, BYTE *, ULONG);
NTSTATUS MCSIcaVirtualQueryBindings(DomainHandle, PSD_VCBIND *, unsigned *);
NTSTATUS MCSIcaT120Request(DomainHandle, PSD_IOCTL);
void     MCSIcaStackCancelIo(DomainHandle);



// Kernel-specific prototypes.

MCSError MCSInitialize(PSDCONTEXT, PSD_OPEN, DomainHandle *, void *);

MCSError APIENTRY MCSSetShadowChannel(
        DomainHandle hDomain,
        ChannelID    shadowChannel);

MCSError APIENTRY MCSGetDefaultDomain(PSDCONTEXT        pContext,
                                      PDomainParameters pDomParams,
                                      unsigned          *MaxSendSize,
                                      unsigned          *MaxX224DataSize,
                                      unsigned          *X224SourcePort);

MCSError APIENTRY MCSCreateDefaultDomain(PSDCONTEXT        pContext,
                                         DomainHandle      hDomain);
            
MCSError APIENTRY MCSGetDomainInfo(
                     DomainHandle      hDomain,
                     PDomainParameters pDomParams, // client's domain params
                     unsigned          *MaxSendSize, // client max PDU size
                     unsigned          *MaxX224DataSize, // client X.224
                     unsigned          *X224SourcePort); // client X.224

MCSError MCSCleanup(DomainHandle *phDomain);

UserID APIENTRY MCSGetUserIDFromHandle(UserHandle hUser);

ChannelID APIENTRY MCSGetChannelIDFromHandle(ChannelHandle hChannel);

MCSError __fastcall MCSSendDataRequest(
        UserHandle      hUser,
        ChannelHandle   hChannel,
        DataRequestType RequestType,
        ChannelID       ChannelID,
        MCSPriority     Priority,
        Segmentation    Segmentation,
        POUTBUF         pOutBuf);

void APIENTRY MCSProtocolErrorEvent(PSDCONTEXT, PPROTOCOLSTATUS, unsigned,
        BYTE *, unsigned);

BOOLEAN __fastcall DecodeLengthDeterminantPER(BYTE *, unsigned, BOOLEAN *,
        unsigned *, unsigned *);

#ifdef __cplusplus
}
#endif



#endif  // !defined(__MCSKERNL_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\mcsioctl.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : MCSIOCTL.h
 * author : Erik Mavrinac
 *
 * description: Definitions for the interface between MCSMUX and PDMCS.
 */

#ifndef __MCSIOCTL_H
#define __MCSIOCTL_H


/*
 * Defines
 */

// From uportmsg.h in NetMeeting project (defined there as
//   MAXIMUM_DOMAIN_SELECTOR).
#define MaxDomainSelectorLength 32

// Max allowable GCC data for connect-initial and connect-response PDUs.
// Used to reduce memory allocations for handling these PDUs -- if too large
//   we will send a bad response PDU and/or disconnect.
#define MaxGCCConnectDataLength 1024



/*
 * T.120 IOCTLs.
 */

#define IOCTL_T120_BASE (0x500)

// Used by MCSMUX to signal on a stack IOCTL that the included data is an MCS
//   request/response. An MCSXxxYyyIoctl struct is expected as the
//   pSdIoctl->InputBuffer; the Header.Type value in the struct will be used
//   to determine the type of the request.
#define IOCTL_T120_REQUEST _ICA_CTL_CODE (IOCTL_T120_BASE, METHOD_NEITHER)



/*
 * Used as the header of all data passed via IOCTL_T120_REQUEST or channel
 *   input.
 */

typedef struct {
    UserHandle hUser;  // PDMCS-supplied handle (NULL for node controller).
    int Type;  // MCS request/indication type.
} IoctlHeader;



/*
 * Connect provider (node controller only). These are special in that they
 *   only come from user mode and so the assoicated user data (if any)
 *   will always be packed at the end of the struct by MCSMUX.
 */

// Passed in by node controller. Confirm is defined next.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_REQUEST.
    unsigned char    CallingDomain[MaxDomainSelectorLength];
    unsigned         CallingDomainLength;
    unsigned char    CalledDomain[MaxDomainSelectorLength];
    unsigned         CalledDomainLength;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    unsigned         UserDataLength;
    BYTE             UserData[MaxGCCConnectDataLength];
    
} ConnectProviderRequestIoctl;

typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_CONFIRM.
    ConnectionHandle hConn;
    DomainParameters DomainParams;
    MCSResult        Result;
} ConnectProviderConfirmIoctl;

// Asynchronous indication triggered when another node connects.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_INDICATION.
    ConnectionHandle hConn;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    unsigned         UserDataLength;
    BYTE             UserData[MaxGCCConnectDataLength];
} ConnectProviderIndicationIoctl;

// Reply to connect-provider indication.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_RESPONSE.
    ConnectionHandle hConn;
    MCSResult        Result;
    unsigned         UserDataLength;
    BYTE *           pUserData;
} ConnectProviderResponseIoctl;



/*
 * Disconnect provider (node controller only).
 */

// Passed in by node controller. There is no confirm.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_DISCONNECT_PROVIDER_REQUEST/INDICATION.
    ConnectionHandle hConn;
    MCSReason        Reason;
} DisconnectProviderRequestIoctl;

// Asynchronous indication.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_DISCONNECT_PROVIDER_REQUEST/INDICATION.
    ConnectionHandle hConn;
    MCSReason        Reason;
} DisconnectProviderIndicationIoctl;


/*
 * Attach user
 */

// Chosen domain is implicit since each PDMCS instance is a domain.
// Header.hUser is filled in during call to contain the user handle.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_ATTACH_USER_REQUEST.
    void        *UserDefined;
} AttachUserRequestIoctl;

typedef struct {
    UserHandle hUser;
    UserID     UserID;  // Valid only if bCompleted is TRUE.
    unsigned   MaxSendSize;
    MCSError   MCSErr;
    BOOLEAN    bCompleted;
} AttachUserReturnIoctl;

// Used only in the case where an attach-user request was sent across the net
//   to the top provider. Hydra 4.0 is always top provider so this is not used.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_ATTACH_USER_CONFIRM.
    UserHandle  hUser;
    void        *UserDefined;  // As passed into attach-user request.
    MCSResult   Result;
} AttachUserConfirmIoctl;



/*
 * Detach user
 */

// Passed in by application. This is synchronous -- no confirm is issued.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_DETACH_USER_REQUEST and the hUser.
} DetachUserRequestIoctl;

// Asynchronous indication triggered when another user detaches.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_DETACH_USER_INDICATION.
    void        *UserDefined;  // As passed into attach-user request.
    DetachUserIndication DUin;
} DetachUserIndicationIoctl;



/*
 * Channel join
 */

// Passed in by application. Confirm is defined next.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_CHANNEL_JOIN_REQUEST.
    ChannelID   ChannelID;
} ChannelJoinRequestIoctl;

typedef struct
{
    ChannelHandle hChannel;
    ChannelID     ChannelID;  // Valid only if bCompleted is TRUE.
    MCSError      MCSErr;
    BOOLEAN       bCompleted;
} ChannelJoinReturnIoctl;

// Used in the case where a channel-join request is sent across the net to
//   the top provider. Should not be used in Hydra 4.0 -- we are always TP.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_CHANNEL_JOIN_CONFIRM.
    void        *UserDefined;  // As passed into attach-user request.
    MCSResult   Result;
    ChannelID   ChannelID;
} ChannelJoinConfirmIoctl;



/*
 * Channel leave
 */

// Passed in by application. This is synchronous -- no confirm is issued.
typedef struct
{
    IoctlHeader   Header;  // Contains MCS_CHANNEL_LEAVE_REQUEST.
    ChannelHandle hChannel;
} ChannelLeaveRequestIoctl;



/*
 * (Uniform) send data
 */

// Asynchronous indication triggered when data arrives. Used by both
//   send-data and uniform-send-data indications.
// Data is packed right after this struct.

typedef struct
{
    IoctlHeader   Header;  // Contains (UNIFORM)SEND_DATA_INDICATION.
    void          *UserDefined;  // As passed into attach-user request.
    ChannelHandle hChannel;
    UserID        SenderID;
    MCSPriority   Priority;
    Segmentation  Segmentation;
    unsigned      DataLength;
} SendDataIndicationIoctl;

// Passed in by application. This is synchronous -- no confirm is issued.
// This struct is used both for send-data and uniform-send-data requests.
typedef struct
{
    IoctlHeader     Header;  // Contains (UNIFORM_)MCS_SEND_DATA_REQUEST.
    DataRequestType RequestType;  // Redundant but useful info.
    ChannelHandle   hChannel;  // Kernel-mode hChannel.
    ChannelID       ChannelID;  // If hChn==NULL, unjoined chn to send to.
    MCSPriority     Priority;
    Segmentation    Segmentation;
    unsigned        DataLength;
} SendDataRequestIoctl;



/*
 * Request and response types for use in differentiating requests.
 */

// User attachment requests.
// These values must be contiguously numbered, since a dispatch table is used
//   to quickly call handler functions.
#define MCS_ATTACH_USER_REQUEST       0
#define MCS_DETACH_USER_REQUEST       1
#define MCS_CHANNEL_JOIN_REQUEST      2
#define MCS_CHANNEL_LEAVE_REQUEST     3
#define MCS_SEND_DATA_REQUEST         4
#define MCS_UNIFORM_SEND_DATA_REQUEST 5
#define MCS_CHANNEL_CONVENE_REQUEST   6
#define MCS_CHANNEL_DISBAND_REQUEST   7
#define MCS_CHANNEL_ADMIT_REQUEST     8
#define MCS_CHANNEL_EXPEL_REQUEST     9
#define MCS_TOKEN_GRAB_REQUEST        10
#define MCS_TOKEN_INHIBIT_REQUEST     11
#define MCS_TOKEN_GIVE_REQUEST        12
#define MCS_TOKEN_GIVE_RESPONSE       13
#define MCS_TOKEN_PLEASE_REQUEST      14
#define MCS_TOKEN_RELEASE_REQUEST     15
#define MCS_TOKEN_TEST_REQUEST        16

// NC-only requests.
#define MCS_CONNECT_PROVIDER_REQUEST    17
#define MCS_CONNECT_PROVIDER_RESPONSE   18
#define MCS_DISCONNECT_PROVIDER_REQUEST 19

// Startup synchonization trigger. This message is sent when the rest of the
//   system is ready for MCS to start processing inputs.
#define MCS_T120_START 20



/*
 * ICA virtual channel definitions for the T.120 input channel.
 */

#define Virtual_T120 "MS_T120"
#define Virtual_T120ChannelNum 31



#endif  // !defined(__MCSIOCTL_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgbtyp.h ===
/**INC+**********************************************************************/
/* Header:    ndcgbtyp.h                                                    */
/*                                                                          */
/* Purpose:   Basic types - Win32 specific header                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/inc/dcl/ndcgbtyp.h_v  $
 *
 *    Rev 1.13   24 Sep 1997 10:34:42   AK
 * SFR1424: Disable warning 4702 for old compiler
 *
 *    Rev 1.12   22 Aug 1997 13:21:12   TH
 * SFR1133: Initial DD code drop
 *
 *    Rev 1.11   15 Aug 1997 17:06:28   mr
 * SFR1133: Tidy up CA further
 *
 *    Rev 1.10   07 Aug 1997 14:33:50   MR
 * SFR1133: Persuade Wd to compile under C++
 *
 *    Rev 1.9   05 Aug 1997 14:09:22   MR
 * SFR1133: Changes for Citrix build environment
 *
 *    Rev 1.8   04 Aug 1997 14:56:50   KH
 * SFR1022: Move DCCALLBACK to wdcgbtyp, add LOADDS
 *
 *    Rev 1.7   23 Jul 1997 10:47:56   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.6   10 Jul 1997 17:23:12   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.5   09 Jul 1997 17:08:38   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   16 Jul 1997 13:57:56   MR
 * SFR1080: Added PPDCACHAR
 *
 *    Rev 1.2   14 Jul 1997 17:15:48   OBK
 * SFR1080: Define DCACHAR and PDCACHAR
 *
 *    Rev 1.1   19 Jun 1997 21:50:30   OBK
 * SFR0000: Start of RNS codebase
**/
/**INC-**********************************************************************/
#ifndef _H_NDCGBTYP
#define _H_NDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Check whether we should include the system headers.                      */
/****************************************************************************/
#ifndef DC_NO_SYSTEM_HEADERS

#if defined(DLL_DISP) || defined(DLL_WD)

/****************************************************************************/
/* winsta.h defines BYTE as unsigned char; later, windef.h typedefs it.     */
/* This ends up as 'typedef unsigned char unsigned char' which doesn't      */
/* compile too well...                                                      */
/*                                                                          */
/* This is my attempt to avoid it                                           */
/****************************************************************************/
#ifdef BYTE
#undef BYTE
#endif

#define BYTE BYTE

/****************************************************************************/
/* Windows NT DDK include files (used to replace standard windows.h)        */
/*                                                                          */
/* The display driver runs in the Kernel space and so MUST NOT access any   */
/* Win32 functions or data.  Instead we can only use the Win32k functions   */
/* as described in the DDK.                                                 */
/****************************************************************************/
#include <stddef.h>
#include <stdarg.h>
#include <ntddk.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef struct  _FILETIME       /* from wtypes.h */
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;

#else

/****************************************************************************/
/* Standard USER space windows header files.                                */
/*                                                                          */
/* Force strict type checking.                                              */
/****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/****************************************************************************/
/* Disable the following warnings for the Windows headers:                  */
/*                                                                          */
/* 4115: named type definition in parentheses                               */
/* 4201: nonstandard extension used : nameless struct/union                 */
/* 4214: nonstandard extension used : bit field types other than int        */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4115)
#pragma warning (disable: 4201)
#pragma warning (disable: 4214)

/****************************************************************************/
/* Include the system headers.                                              */
/****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#ifdef OS_WINCE
#include <wince.h>
#endif

#pragma warning (default: 4115)
#pragma warning (default: 4201)
#pragma warning (default: 4214)

#endif /* defined(DLL_DISP) || defined(DLL_WD) */

#endif /* DCS_NO_SYSTEM_HEADERS */

/****************************************************************************/
/* Disable the following warnings for our code:                             */
/*                                                                          */
/* 4102: "Unreferenced label" warnings so that DC_EXIT_POINT can be placed  */
/*       in each function if there aren't (yet) any DC_QUITs.               */
/* 4514: unreferenced inline function has been removed                      */
/* 4057: slightly different types for L"string" and (wchar_t *)             */
/* 4702: unreachable code (retail VC++4.2 only)                             */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4102)
#pragma warning (disable: 4514)
#pragma warning (disable: 4057)
#ifndef DC_DEBUG
#pragma warning (disable: 4702)
#endif

/****************************************************************************/
/* Promote the following warnings to errors:                                */
/*                                                                          */
/* 4706 - "Assignment in conditional expression"                            */
/* 4013 - "'FunctionName' undefined; assuming extern returning int"         */
/*                                                                          */
/* Promote the following warnings to level 3:                               */
/*                                                                          */
/* 4100 - "unreferenced formal parameter"                                   */
/* 4701 - "Local variable may be used before being initialized".            */
/* 4244 - "conversion from 'int ' to 'short ', possible loss of data        */
/* 4127 - "conditional expression is constant                               */
/*                                                                          */
/****************************************************************************/
// #pragma warning (error: 4706)
// #pragma warning (error: 4013)
// #pragma warning (3    : 4100)
// #pragma warning (3    : 4701)
// #pragma warning (3    : 4244)
// #pragma warning (3    : 4127)


/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DCPTR is used when declaring pointers to variables.  Use it to get the   */
/* correct pointer types for your memory model/compiler.                    */
/****************************************************************************/
#define DCPTR               *

/****************************************************************************/
/* DCUNALIGNED is used to define pointers to values which are not aligned   */
/* on the correct boundary.  e.g.  a DCUINT32 which does not start on a 4   */
/* byte boundary.                                                           */
/****************************************************************************/
#define DCUNALIGNED         UNALIGNED

/****************************************************************************/
/* Define function calling conventions.  Note that PDCAPI should be used to */
/* declare a pointer to a function.                                         */
/****************************************************************************/
#define DCEXPORT
#define DCLOADDS
#ifndef OS_WINCE
#define DCAPI              _stdcall
#define DCINTERNAL         _stdcall
#else	//no _stdcall support on CE.
#define DCAPI              __cdecl
#define DCINTERNAL         __cdecl
#define _stdcall           __cdecl
#define __stdcall          __cdecl
#endif

#define PDCAPI              DCAPI      DCPTR
#define PDCCALLBACK         DCCALLBACK DCPTR
#define PDCINTERNAL         DCINTERNAL DCPTR

/****************************************************************************/
/* Define DCHPTR.                                                           */
/****************************************************************************/
#define DCHPTR                         *

#endif /* _H_NDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\license.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       license.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-03-97   FredCh   Created
//              12-16-97   v-sbhatt  Modified
//              12-22-97   HueiWang Add Extension OID
//              12-23-97   HueiWang Use structure instead of multiple OID
//
//----------------------------------------------------------------------------

#ifndef _LICENSE_H_
#define _LICENSE_H_

#include "platform.h"

#if defined(_WIN64)
#define UNALIGNED __unaligned
#define UNALIGNED64 __unaligned
#elif !defined (OS_WINCE)
#define UNALIGNED
#define UNALIGNED64
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Random number length
//

#define     LICENSE_RANDOM              32
#define     LICENSE_PRE_MASTER_SECRET   48
#define     LICENSE_MAC_WRITE_KEY       16
#define     LICENSE_SESSION_KEY         16
#define     LICENSE_MAC_DATA            16
#define     LICENSE_HWID_LENGTH         20


//////////////////////////////////////////////////////////////////////////////
// Licensing protocol versions
//
#ifndef OS_WIN16
#ifndef OS_WINCE
#define CALL_TYPE   _stdcall
#else
#define CALL_TYPE
#endif
#else
#define CALL_TYPE
#endif  //CALL_TYPE


//-----------------------------------------------------------------------------
//
// Licensing protocol version
//
// The lowest byte of the version DWORD will be the preamble version.
//
//-----------------------------------------------------------------------------

#define LICENSE_PROTOCOL_VERSION_1_0    0x00010000
#define LICENSE_PROTOCOL_VERSION_2_0    0x00020000

//
//  INT CompareTLSVersions(VERSION a, VERSION b);
//

#define CompareTLSVersions(a, b) \
    (HIWORD(a) == HIWORD(b) ? LOWORD(a) - LOWORD(b) : \
     HIWORD(a) - HIWORD(b))


#define PREAMBLE_VERSION_1_0            0x01
#define PREAMBLE_VERSION_2_0            0x02
#define PREAMBLE_VERSION_3_0            0x03

#define LICENSE_CURRENT_PREAMBLE_VERSION    PREAMBLE_VERSION_3_0

#define LICENSE_TS_40_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | PREAMBLE_VERSION_2_0
#define LICENSE_TS_50_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | PREAMBLE_VERSION_3_0
#define LICENSE_TS_51_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_2_0 | PREAMBLE_VERSION_3_0

#define LICENSE_HYDRA_40_PROTOCOL_VERSION LICENSE_TS_40_PROTOCOL_VERSION

#if 1
#define LICENSE_HIGHEST_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | LICENSE_CURRENT_PREAMBLE_VERSION
#else
#define LICENSE_HIGHEST_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_2_0 | LICENSE_CURRENT_PREAMBLE_VERSION
#endif

#define GET_PREAMBLE_VERSION( _Version ) ( BYTE )( _Version & 0x000000FF )

//-----------------------------------------------------------------------------
//
// Context flags used by the client and server licensing protocol APIs:
//
// LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION
//
//      Do not authenticate the server.  Server authentication is done through
//      validating the server's certificate.
//
// LICENSE_CONTEXT_USE_PROPRIETORY_CERT
//
//      Use in conjunction with the LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION 
//      flag to let that server know that a proprietory certificate has
//      been transmitted to the client.
//
// LICENSE_CONTEXT_USE_X509_CERT
//
//      Use in conjunction with the LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION 
//      flag to let that server know that an X509 certificate has
//      been transmitted to the client.
//
//-----------------------------------------------------------------------------

#define LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION    0x00000001
#define LICENSE_CONTEXT_USE_PROPRIETORY_CERT        0x00000002
#define LICENSE_CONTEXT_USE_X509_CERT               0x00000004


//////////////////////////////////////////////////////////////////////////////
//
// Hydra subtree Specific OID
//
#define szOID_PKIX_HYDRA_CERT_ROOT    "1.3.6.1.4.1.311.18"


/////////////////////////////////////////////////////////////////////////////
//
// License Info root at 1.3.6.1.4.1.311.18.1
//
// Reserved
//
#define szOID_PKIX_LICENSE_INFO         "1.3.6.1.4.1.311.18.1"

//
// structure for License Info
//

typedef struct __LicenseInfo {

    DWORD   dwVersion;
    DWORD   dwQuantity;
    WORD    wSerialNumberOffset;
    WORD    wSerialNumberSize;
    WORD    wScopeOffset;
    WORD    wScopeSize;
    WORD    wIssuerOffset;
    WORD    wIssuerSize;
    BYTE    bVariableDataStart[1];

} CERT_LICENSE_INFO;

#ifdef OS_WIN16
typedef CERT_LICENSE_INFO FAR * LPCERT_LICENSE_INFO;
#else
typedef CERT_LICENSE_INFO *LPCERT_LICENSE_INFO;
#endif  //OS_WIN16

/////////////////////////////////////////////////////////////////////////////
// Manufacturer value 1.3.6.1.4.1.311.18.2
// DWORD for manufacturer data
//
#define szOID_PKIX_MANUFACTURER         "1.3.6.1.4.1.311.18.2"

/////////////////////////////////////////////////////////////////////////////
//
// Manufacturer Specfic Data
//
// Reserved
// 
#define szOID_PKIX_MANUFACTURER_MS_SPECIFIC "1.3.6.1.4.1.311.18.3"

// structure for MS manufacturer specific data
typedef struct __MSManufacturerData {
    DWORD   dwVersion;      // bit 31 - 1 Temp. License.
    DWORD   dwPlatformID;
    DWORD   dwLanguageID;
    WORD    dwMajorVersion;
    WORD    dwMinorVersion;
    WORD    wProductIDOffset;
    WORD    wProductIDSize;
    BYTE    bVariableDataStart[1];
} MSMANUFACTURER_DATA;

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//
// OID for Certificate Version Stamp
//
// Reserved.
//
#define szOID_PKIX_HYDRA_CERT_VERSION       szOID_PKIX_HYDRA_CERT_ROOT ".4"

#define TERMSERV_CERT_VERSION_UNKNOWN  0xFFFFFFFF
#define TERMSERV_CERT_VERSION_BETA     0x00000000   // Beta2 license
#define TERMSERV_CERT_VERSION_NO_CERT  0x00010000   // New License without
                                                    // license server's
                                                    // certificate
#define TERMSERV_CERT_VERSION_RC1      0x00010001   // New license with
                                                    // license server's
                                                    // certificate

//
// We don't support this certificate format.
//
//#define HYDRA_CERT_VERSION_CURRENT  0x00020001  // License issued by 
//                                                // enforce version of
//                                                // license server

#define TERMSERV_CERT_VERSION_MAJOR(x)  HIWORD(x)
#define TERMSERV_CERT_VERSION_MINOR(x)  LOWORD(x)
#define TERMSERV_CERT_VERSION_CURRENT   0x00050001  

//-------------------------------------------------------------------------
//
// OID for License Server to identify licensed product.
//
#define szOID_PKIX_LICENSED_PRODUCT_INFO szOID_PKIX_HYDRA_CERT_ROOT ".5"

//
// dwFlags in LICENSED_VERSION_INFO
//
// Bit 31 - 1 if temporary license, 0 if perm. license
// Bit 24 to 30 - Any flag specific to temporary license, currently, there is none.
// Bit 23 - 1 if RTM License, 0 if beta license.
// Bit 16 to 22 - License server version.
// Bit 20 to 22 - Major version.
// Bit 16 to 19 - Minor version.
// Bit 15 - Enforce license server.
// Bit 0 to 3 is reserved by license server for internal use.
// Other bits are not use.
//
#define LICENSED_VERSION_TEMPORARY  0x80000000
#define LICENSED_VERSION_RTM        0x00800000
#define LICENSE_ISSUER_ENFORCE_TYPE 0x00008000

#define GET_LICENSE_ISSUER_VERSION(dwVersion) \
    (((dwVersion) & 0x007F0000) >> 16)    

#define GET_LICENSE_ISSUER_MAJORVERSION(dwVersion) \
    (((dwVersion) & 0x00700000) >> 20)

#define GET_LICENSE_ISSUER_MINORVERSION(dwVersion) \
    (((dwVersion) & 0x000F0000) >> 16)

#define IS_LICENSE_ISSUER_ENFORCE(dwVersion) \
    (((dwVersion) & LICENSE_ISSUER_ENFORCE_TYPE) > 0)

#define IS_LICENSE_ISSUER_RTM(dwVersion) \
    (((dwVersion) & LICENSED_VERSION_RTM) > 0)


typedef struct _LicensedVersionInfo {
    WORD    wMajorVersion;          // Product Major Version
    WORD    wMinorVersion;          // Product Minor Version
    DWORD   dwFlags;                // Product version specific flags
} LICENSED_VERSION_INFO;

#define LICENSED_PRODUCT_INFO_VERSION       0x0003000

typedef struct _LicensedProductInfo {
    DWORD   dwVersion;              // structure version identifier
    DWORD   dwQuantity;             // number of licenses
    DWORD   dwPlatformID;           // Client platform ID
    DWORD   dwLanguageID;           // Licensed Language ID

    WORD    wOrgProductIDOffset;    // Offset to original licensed Product ID
    WORD    wOrgProductIDSize;      // Size of original licensed product ID

    WORD    wAdjustedProductIdOffset;   // Policy modified licensed product Id
    WORD    wAdjustedProductIdSize;     // size of Policy modified licensed Id.

    WORD    wVersionInfoOffset;     // Offset to array of LicensedVersionInfo
    WORD    wNumberOfVersionInfo;   // Number of VersionInfo entries
    BYTE    bVariableDataStart[1];  // Variable data start.
} LICENSED_PRODUCT_INFO;

//
// OID for License Server specific info.
//
#define szOID_PKIX_MS_LICENSE_SERVER_INFO   szOID_PKIX_HYDRA_CERT_ROOT ".6"
#define MS_LICENSE_SERVER_INFO_VERSION1     0x0001000
#define MS_LICENSE_SERVER_INFO_VERSION2     0x0003000

//
// Version 1 structure
//
typedef struct _MsLicenseServerInfo10 {
    DWORD   dwVersion;
    WORD    wIssuerOffset;          // Offset to issuer
    WORD    wScopeOffset;           // Offset to scope
    BYTE    bVariableDataStart[1];
} MS_LICENSE_SERVER_INFO10;

typedef struct _MsLicenseServerInfo {
    DWORD   dwVersion;
    WORD    wIssuerOffset;          // Offset to issuer
    WORD    wIssuerIdOffset;        // offset to issuer's setup ID
    WORD    wScopeOffset;           // Offset to scope
    BYTE    bVariableDataStart[1];
} MS_LICENSE_SERVER_INFO;


//---------------------------------------------------------------------------
//
// Extension OID reserved for product policy module - only one is allowed.
//
#define szOID_PKIS_PRODUCT_SPECIFIC_OID     szOID_PKIX_HYDRA_CERT_ROOT ".7"

//
//
//
#define szOID_PKIS_TLSERVER_SPK_OID         szOID_PKIX_HYDRA_CERT_ROOT ".8"

//
// Save certificate chain into memory
// This flag is passed into CertSaveStore() dwSaveAs parameter
// Open should use same to open the store.

#define szLICENSE_BLOB_SAVEAS_TYPE   sz_CERT_STORE_PROV_PKCS7
#define LICENSE_BLOB_SAVEAS_TYPE    CERT_STORE_SAVE_AS_PKCS7

#define OID_ISSUER_LICENSE_SERVER_NAME  szOID_COMMON_NAME
#define OID_ISSUER_LICENSE_SERVER_SCOPE szOID_LOCALITY_NAME
 
#define OID_SUBJECT_CLIENT_COMPUTERNAME szOID_COMMON_NAME
#define OID_SUBJECT_CLIENT_USERNAME     szOID_LOCALITY_NAME
#define OID_SUBJECT_CLIENT_HWID         szOID_DEVICE_SERIAL_NUMBER


#ifdef OS_WIN16
typedef MSMANUFACTURER_DATA FAR *LPMSMANUFACTURER_DATA;
#else
typedef MSMANUFACTURER_DATA *LPMSMANUFACTURER_DATA;
#endif //OS_WIN16

///////////////////////////////////////////////////////////////////////////////
// 
#define LICENSE_GRACE_PERIOD    60


///////////////////////////////////////////////////////////////////////////////
// Product Info for Hydra
//

#define PRODUCT_INFO_COMPANY_NAME   L"Microsoft Corporation"


///////////////////////////////////////////////////////////////////////////////
// The Product SKU is made up of the following fields:
// x-y-z where x is the product identifer, y is the version
// and z and the type.
//

#define PRODUCT_INFO_SKU_PRODUCT_ID                 L"A02"
#define PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID        L"B96"
#define PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID      L"C50"      // not the same as what marketing uses, but that's okay

///////////////////////////////////////////////////////////////////////////////
//
// Microsoft Windows Terminal Server version definition.
//

#define MICROSOFT_WINDOWS_TERMINAL_SERVER_4_0       0x00040000
#define MICROSOFT_WINDOWS_TERMINAL_SERVER_5_0       0x00050000
#define MICROSOFT_WINDOWS_TERMINAL_SERVER_5_1       0x00050001
#define MICROSOFT_WINDOWS_TERMINAL_SERVER_5_2       0x00050002

#define CURRENT_TERMINAL_SERVER_VERSION             MICROSOFT_WINDOWS_TERMINAL_SERVER_5_0


#define TERMSRV_OS_INDEX_WINNT_5_0                  0x00000000
#define TERMSRV_OS_INDEX_WINNT_5_1                  0x00000001
#define TERMSRV_OS_INDEX_WINNT_5_2	                0x00000002
#define TERMSRV_OS_INDEX_WINNT_POST_5_2	            0x00000003

///////////////////////////////////////////////////////////////////////////////
//
// Scope name
//
#ifndef OS_WINCE //SCOPE_NAME is being defined by iprtrmib.h which is included by iphlpapi.h
#define SCOPE_NAME                  "microsoft.com"
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Maximum product info string length in bytes
//

#define MAX_PRODUCT_INFO_STRING_LENGTH      255


///////////////////////////////////////////////////////////////////////////////
// Different crypt algid definitions
// We are keeping an option open to generatize it in future 
//

///////////////////////////////////////////////////////////////////////////////
//
// Key exchange algorithms
//

#define KEY_EXCHANGE_ALG_RSA    1
#define KEY_EXCHANGE_ALG_DH     2


///////////////////////////////////////////////////////////////////////////////
//
// Certificate Signature Algorithms
//

#define SIGNATURE_ALG_RSA       1
#define SIGNATURE_ALG_DSS       2

///////////////////////////////////////////////////////////////////////////////
//
// Symmetric cryptographic algorithms
//

#define BASIC_RC4_128           1

///////////////////////////////////////////////////////////////////////////////
//
// MAC generation algorithms
//

#define MAC_MD5_SHA             1

///////////////////////////////////////////////////////////////////////////////
//
// hydra client to hydra server message types
//

#define HC_LICENSE_INFO                         0x12
#define HC_NEW_LICENSE_REQUEST                  0x13
#define HC_PLATFORM_INFO                        0x14
#define HC_PLATFORM_CHALENGE_RESPONSE           0x15


///////////////////////////////////////////////////////////////////////////////
//
// hydra server to hydra client message types
//

#define HS_LICENSE_REQUEST                      0x01
#define HS_PLATFORM_CHALLENGE                   0x02
#define HS_NEW_LICENSE                          0x03
#define HS_UPGRADE_LICENSE                      0x04

#define LICENSE_VERSION_1                       0x01


#define GM_ERROR_ALERT                          0xFF


///////////////////////////////////////////////////////////////////////////////
//
// Error and alert codes
//

#define GM_HC_ERR_INVALID_SERVER_CERTIFICATE    0x00000001
#define GM_HC_ERR_NO_LICENSE                    0x00000002
#define GM_HC_ERR_INVALID_MAC                   0x00000003
#define GM_HS_ERR_INVALID_SCOPE                 0x00000004
#define GM_HS_ERR_INVALID_MAC                   0x00000005
#define GM_HS_ERR_NO_LICENSE_SERVER             0x00000006
#define GM_HS_ERR_VALID_CLIENT                  0x00000007
#define GM_HS_ERR_INVALID_CLIENT                0x00000008                  
#define GM_HS_ERR_LICENSE_UPGRADE               0x00000009
#define GM_HS_ERR_EXPIRED_LICENSE               0x0000000A
#define GM_HS_ERR_INVALID_PRODUCTID             0x0000000B
#define GM_HS_ERR_INVALID_MESSAGE_LEN           0x0000000C


///////////////////////////////////////////////////////////////////////////////
//
// License status and status codes
//

typedef DWORD   LICENSE_STATUS;

#define LICENSE_STATUS_OK                                       0x00000000
#define LICENSE_STATUS_OUT_OF_MEMORY                            0x00000001
#define LICENSE_STATUS_INSUFFICIENT_BUFFER                      0x00000002
#define LICENSE_STATUS_INVALID_INPUT                            0x00000003
#define LICENSE_STATUS_INVALID_CLIENT_CONTEXT                   0x00000004
#define LICENSE_STATUS_INITIALIZATION_FAILED                    0x00000005
#define LICENSE_STATUS_INVALID_SIGNATURE                        0x00000006
#define LICENSE_STATUS_INVALID_CRYPT_STATE                      0x00000007
#define LICENSE_STATUS_CONTINUE                                 0x00000008
#define LICENSE_STATUS_ISSUED_LICENSE                           0x00000009
#define LICENSE_STATUS_CLIENT_ABORT                             0x0000000A
#define LICENSE_STATUS_SERVER_ABORT                             0x0000000B
#define LICENSE_STATUS_NO_CERTIFICATE                           0x0000000C
#define LICENSE_STATUS_NO_PRIVATE_KEY                           0x0000000D
#define LICENSE_STATUS_SEND_ERROR                               0x0000000E
#define LICENSE_STATUS_INVALID_RESPONSE                         0x0000000F
#define LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR             0x00000010
#define LICENSE_STATUS_NO_MESSAGE                               0x00000011
#define LICENSE_STATUS_INVALID_CLIENT_STATE                     0x00000012
#define LICENSE_STATUS_OPEN_STORE_ERROR                         0x00000013
#define LICENSE_STATUS_CLOSE_STORE_ERROR                        0x00000014
#define LICENSE_STATUS_WRITE_STORE_ERROR                        0x00000015
#define LICENSE_STATUS_INVALID_STORE_HANDLE                     0x00000016
#define LICENSE_STATUS_DUPLICATE_LICENSE_ERROR                  0x00000017
#define LICENSE_STATUS_INVALID_MAC_DATA                         0x00000018
#define LICENSE_STATUS_INCOMPLETE_MESSAGE                       0x00000019
#define LICENSE_STATUS_RESTART_NEGOTIATION                      0x0000001A
#define LICENSE_STATUS_NO_LICENSE_SERVER                        0x0000001B
#define LICENSE_STATUS_NO_PLATFORM_CHALLENGE                    0x0000001C
#define LICENSE_STATUS_NO_LICENSE_SERVER_SECRET_KEY             0x0000001D
#define LICENSE_STATUS_INVALID_SERVER_CONTEXT                   0x0000001E
#define LICENSE_STATUS_CANNOT_DECODE_LICENSE                    0x0000001F
#define LICENSE_STATUS_INVALID_LICENSE                          0x00000020
#define LICENSE_STATUS_CANNOT_VERIFY_HWID                       0x00000021
#define LICENSE_STATUS_NO_LICENSE_ERROR                         0x00000022
#define LICENSE_STATUS_EXPIRED_LICENSE                          0x00000023
#define LICENSE_STATUS_MUST_UPGRADE_LICENSE                     0x00000024
#define LICENSE_STATUS_UNSPECIFIED_ERROR                        0x00000025
#define LICENSE_STATUS_INVALID_PLATFORM_CHALLENGE_RESPONSE      0x00000026
#define LICENSE_STATUS_SHOULD_UPGRADE_LICENSE                   0x00000027
#define LICENSE_STATUS_CANNOT_UPGRADE_LICENSE                   0x00000028
#define LICENSE_STATUS_CANNOT_FIND_CLIENT_IMAGE                 0x00000029
#define LICENSE_STATUS_CANNOT_READ_CLIENT_IMAGE                 0x0000002A
#define LICENSE_STATUS_CANNOT_WRITE_CLIENT_IMAGE                0x0000002B
#define LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT                  0x0000002C
#define LICENSE_STATUS_NOT_HYDRA                                0x0000002D
#define LICENSE_STATUS_INVALID_X509_NAME                        0x0000002E
#define LICENSE_STATUS_NOT_SUPPORTED                            0x0000002F
#define LICENSE_STATUS_INVALID_CERTIFICATE                      0x00000030
#define LICENSE_STATUS_NO_ATTRIBUTES                            0x00000031
#define LICENSE_STATUS_NO_EXTENSION                             0x00000032
#define LICENSE_STATUS_ASN_ERROR                                0x00000033
#define LICENSE_STATUS_INVALID_HANDLE                           0x00000034
#define LICENSE_STATUS_CANNOT_MAKE_KEY_PAIR                     0x00000035
#define LICENSE_STATUS_AUTHENTICATION_ERROR                     0x00000036
#define LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR                0x00000037
#define LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE                 0x00000038
#define LICENSE_STATUS_CANNOT_STORE_SECRET                      0x00000039
#define LICENSE_STATUS_CANNOT_RETRIEVE_SECRET                   0x0000003A
#define LICENSE_STATUS_UNSUPPORTED_VERSION                      0x0000003B
#define LICENSE_STATUS_NO_INTERNET_LICENSE_INSTALLED            0x0000003C

///////////////////////////////////////////////////////////////////////////////
// State transitions
//

#define ST_TOTAL_ABORT                          0x00000001
#define ST_NO_TRANSITION                        0x00000002
#define ST_RESET_PHASE_TO_START                 0x00000003
#define ST_RESEND_LAST_MESSAGE                  0x00000004


#define PLATFORM_WINNT_40                           0x00040000
#define PLATFORM_WINCE_20                           0x00020001          

///////////////////////////////////////////////////////////////////////////////
// message exchange supporting structures
//

typedef struct _Product_Info
{
    DWORD   dwVersion;
    DWORD   cbCompanyName;
    PBYTE   pbCompanyName;
    DWORD   cbProductID;
    PBYTE   pbProductID;
} Product_Info;

#ifdef OS_WIN16
typedef Product_Info FAR *PProduct_Info;
#else
typedef Product_Info *PProduct_Info;
#endif //OS_WIN16



typedef struct _Duration
{
    FILETIME        NotBefore;
    FILETIME        NotAfter;

} Duration;

#ifdef OS_WIN16
typedef Duration FAR * PDuration;
#else
typedef Duration *PDuration;
#endif  //OS_WIN16


typedef struct _New_License_Info
{
    DWORD       dwVersion;  //Added -Shubho
    DWORD       cbScope;
    PBYTE       pbScope;
    DWORD       cbCompanyName;
    PBYTE       pbCompanyName;
    DWORD       cbProductID;
    PBYTE       pbProductID;
    DWORD       cbLicenseInfo;
    PBYTE       pbLicenseInfo;

}New_License_Info;

#ifdef OS_WIN16
typedef New_License_Info FAR * PNew_License_Info;
#else
typedef New_License_Info *PNew_License_Info;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// binary blob format to support expanded message format
//

typedef struct _Binary_Blob
{
    WORD            wBlobType;
    WORD            wBlobLen;
    PBYTE           pBlob;

} Binary_Blob;

#ifdef OS_WIN16
typedef Binary_Blob FAR * PBinary_Blob;
#else
typedef Binary_Blob UNALIGNED* PBinary_Blob;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// Binary Blob Data Types
//

#define BB_DATA_BLOB                    0x0001
#define BB_RANDOM_BLOB                  0x0002
#define BB_CERTIFICATE_BLOB             0x0003
#define BB_ERROR_BLOB                   0x0004
#define BB_DH_KEY_BLOB                  0x0005
#define BB_RSA_KEY_BLOB                 0x0006
#define BB_DSS_SIGNATURE_BLOB           0x0007
#define BB_RSA_SIGNATURE_BLOB           0x0008
#define BB_ENCRYPTED_DATA_BLOB          0x0009
#define BB_MAC_DATA_BLOB                0x000A
#define BB_INTEGER_BLOB                 0x000B
#define BB_NAME_BLOB                    0x000C
#define BB_KEY_EXCHG_ALG_BLOB           0x000D
#define BB_SCOPE_BLOB                   0x000E
#define BB_CLIENT_USER_NAME_BLOB        0x000F
#define BB_CLIENT_MACHINE_NAME_BLOB     0x0010

///////////////////////////////////////////////////////////////////////////////
// Binary Blob Data Version Numbers
//

#define BB_ERROR_BLOB_VERSION            0x0001

///////////////////////////////////////////////////////////////////////////////
// message exchange structures for licensing protocol
//

typedef struct _Preamble
{
    BYTE    bMsgType;       // Contains the type of message
    BYTE    bVersion;       // Contains the version no. info.
    WORD    wMsgSize;        // Length of the whole message including PREAMBLE

} Preamble;

#ifdef OS_WIN16
typedef Preamble FAR * PPreamble;
#else
typedef Preamble * PPreamble;
#endif  //OS_WIN16


typedef struct  _Scope_List
{
    DWORD           dwScopeCount;
    PBinary_Blob    Scopes;

} Scope_List;

#ifdef OS_WIN16
typedef Scope_List FAR * PScope_List;
#else
typedef Scope_List * PScope_List;
#endif  //OS_WIN16


typedef struct _License_Error_Message
{
    DWORD       dwErrorCode;
    DWORD       dwStateTransition;
    Binary_Blob bbErrorInfo;

} License_Error_Message;

#ifdef OS_WIN16
typedef License_Error_Message FAR * PLicense_Error_Message;
#else
typedef License_Error_Message * PLicense_Error_Message;
#endif  //OS_WIN16


typedef struct _Hydra_Client_License_Info
{
    DWORD           dwPrefKeyExchangeAlg;
    DWORD           dwPlatformID;
    BYTE            ClientRandom[LICENSE_RANDOM];
    Binary_Blob     EncryptedPreMasterSecret;
    Binary_Blob     LicenseInfo;
    Binary_Blob     EncryptedHWID;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Client_License_Info;

#ifdef OS_WIN16
typedef Hydra_Client_License_Info FAR * PHydra_Client_License_Info;
#else
typedef Hydra_Client_License_Info * PHydra_Client_License_Info;
#endif  //OS_WIN16


typedef struct _Hydra_Client_New_License_Request
{
    DWORD           dwPrefKeyExchangeAlg;
    DWORD           dwPlatformID;
    BYTE            ClientRandom[LICENSE_RANDOM];
    Binary_Blob     EncryptedPreMasterSecret;
    Binary_Blob     ClientUserName;
    Binary_Blob     ClientMachineName;

} Hydra_Client_New_License_Request;

#ifdef OS_WIN16
typedef Hydra_Client_New_License_Request FAR * PHydra_Client_New_License_Request;
#else
typedef Hydra_Client_New_License_Request * PHydra_Client_New_License_Request;
#endif  //OS_WIN16


//
// High Byte - Major version, Low Byte - Minor version
// 
#define PLATFORMCHALLENGE_VERSION           0x0100

#define CURRENT_PLATFORMCHALLENGE_VERSION   PLATFORMCHALLENGE_VERSION

//
// Client Platform Challenge Type
//
#define WIN32_PLATFORMCHALLENGE_TYPE    0x0100
#define WIN16_PLATFORMCHALLENGE_TYPE    0x0200
#define WINCE_PLATFORMCHALLENGE_TYPE    0x0300
#define OTHER_PLATFORMCHALLENGE_TYPE    0xFF00


//
// Client License Detail level - 
//
//  This should be in LicenseRequest but
//  1) Require changes to RPC interface.
//  2) Nothing in structure for us to identify version.
//  3) Current licensing protocol, no way to tell actual client type
//

//
// client license + license server's self signed
//
#define LICENSE_DETAIL_SIMPLE           0x0001  

//
// license chain up to issuer of license server's certificate
//
#define LICENSE_DETAIL_MODERATE         0x0002  

// 
// Detail client license chain up to root.
//
#define LICENSE_DETAIL_DETAIL           0x0003

typedef struct __PlatformChallengeResponseData
{
    WORD  wVersion;         // structure version
    WORD  wClientType;      // client type
    WORD  wLicenseDetailLevel;  // license detail, TS will re-modify this value    
    WORD  cbChallenge;      // size of client challenge response data
    BYTE  pbChallenge[1];   // start of variable length data
} PlatformChallengeResponseData;

#ifdef OS_WIN16
typedef PlatformChallengeResponseData FAR * PPlatformChallengeResponseData;
#else
typedef PlatformChallengeResponseData * PPlatformChallengeResponseData;
#endif  //OS_WIN16

#define PLATFORM_CHALLENGE_LENGTH       64

typedef struct _Hydra_Client_Platform_Challenge_Response
{
    Binary_Blob     EncryptedChallengeResponse;
    Binary_Blob     EncryptedHWID;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Client_Platform_Challenge_Response;

#ifdef OS_WIN16
typedef Hydra_Client_Platform_Challenge_Response FAR * PHydra_Client_Platform_Challenge_Response;
#else
typedef Hydra_Client_Platform_Challenge_Response * PHydra_Client_Platform_Challenge_Response;
#endif  //OS_WIN16


typedef struct _Hydra_Server_License_Request
{
    BYTE                    ServerRandom[LICENSE_RANDOM];
    Product_Info            ProductInfo;
    Binary_Blob             KeyExchngList;
    Binary_Blob             ServerCert;
    Scope_List              ScopeList;

} Hydra_Server_License_Request;

#ifdef OS_WIN16
typedef Hydra_Server_License_Request FAR * PHydra_Server_License_Request;
#else
typedef Hydra_Server_License_Request * PHydra_Server_License_Request;
#endif  //OS_WIN16


typedef struct _Hydra_Server_Platform_Challenge
{
    DWORD           dwConnectFlags;
    Binary_Blob     EncryptedPlatformChallenge;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Server_Platform_Challenge;

#ifdef OS_WIN16
typedef Hydra_Server_Platform_Challenge FAR * PHydra_Server_Platform_Challenge;
#else
typedef Hydra_Server_Platform_Challenge * PHydra_Server_Platform_Challenge;
#endif  //OS_WIN16


typedef struct _Hydra_Server_New_License
{
    Binary_Blob     EncryptedNewLicenseInfo;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Server_New_License;

#ifdef OS_WIN16
typedef Hydra_Server_New_License FAR * PHydra_Server_New_License;
#else
typedef Hydra_Server_New_License * PHydra_Server_New_License;
#endif  //OS_WIN16

typedef Hydra_Server_New_License    Hydra_Server_Upgrade_License;
typedef PHydra_Server_New_License   PHydra_Server_Upgrade_License;

///////////////////////////////////////////////////////////////////////////////
// Hydra Server Authentication Certificate structures;
// Here we assume that before Licensing module comes into play
// the client will somehow notify the Server about the supported
// Provider and the Hydra Server will accordingly provide 
// appropriate certificate
//

typedef struct _Hydra_Server_Cert
{
    DWORD           dwVersion;
    DWORD           dwSigAlgID;
    DWORD           dwKeyAlgID;
    Binary_Blob     PublicKeyData;
    Binary_Blob     SignatureBlob;

} Hydra_Server_Cert;

#ifdef OS_WIN16
typedef Hydra_Server_Cert FAR * PHydra_Server_Cert;
#else
typedef Hydra_Server_Cert * PHydra_Server_Cert;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// Hydra Client HWID structure 
// Note : We have to finalize on this structure and generation algorithm.
// Currently we have hardcoded these values in Cryptkey.c. - Shubho

typedef struct  _HWID
{
    DWORD       dwPlatformID;
    DWORD       Data1;
    DWORD       Data2;
    DWORD       Data3;
    DWORD       Data4;

} HWID;

#ifdef OS_WIN16
typedef HWID FAR * PHWID;
#else
typedef HWID * PHWID;
#endif //OS_WIN16

typedef struct _LicenseRequest
{
    PBYTE           pbEncryptedHwid;
    DWORD           cbEncryptedHwid;
    DWORD           dwLanguageID;
    DWORD           dwPlatformID;
    PProduct_Info   pProductInfo;

} LICENSEREQUEST;

#ifdef OS_WIN16
typedef LICENSEREQUEST FAR * PLICENSEREQUEST;
#else
typedef LICENSEREQUEST * PLICENSEREQUEST;
#endif  //OS_WIN16

//
// dwLicenseVersion Value
//
// HYDRA_CERT_VERSION_BETA     Beta2 client license
// HYDRA_CERT_VERSION_NO_CERT  Post Beta2 license without certificate chain
// HYDRA_CERT_VERSION_CURRENT  Post Beta2 license with certificate chain
//
typedef struct _LicensedProduct
{
    DWORD                  dwLicenseVersion;   
    DWORD                  dwQuantity;

    PBYTE                  pbOrgProductID;      // original license request product Id
    DWORD                  cbOrgProductID;      // size of original license request product Id

    LICENSEREQUEST         LicensedProduct;     // licensed product
    LICENSED_VERSION_INFO* pLicensedVersion;    // licensed product version    
    DWORD                  dwNumLicensedVersion; // number of licensed product version

    LPTSTR                 szIssuer;
    LPTSTR                 szIssuerId;          // license server setup ID
    LPTSTR                 szIssuerScope;
    LPTSTR                 szLicensedClient;
    LPTSTR                 szLicensedUser;
    LPTSTR                 szIssuerDnsName;

    HWID                   Hwid;

    FILETIME               NotBefore;           // license's validity
    FILETIME               NotAfter;

    PBYTE                  pbPolicyData;       // Policy specfic extension
    DWORD                  cbPolicyData;       // size of policy specific extension
    ULARGE_INTEGER         ulSerialNumber;     // Client license's serial number
} LICENSEDPRODUCT;

#ifdef OS_WIN16
typedef LICENSEDPRODUCT FAR * PLICENSEDPRODUCT;
#else
typedef  LICENSEDPRODUCT *PLICENSEDPRODUCT;
#endif  //OS_WIN16

//-----------------------------------------------------------------------------
//
// Types of certificate used by the server to authenticate itself to the clients
//
// CERT_TYPE_PROPRIETORY
//      Proprietory format certificate
//
// CERT_TYPE_X509
//      X509 format certificate
//
//-----------------------------------------------------------------------------

typedef enum
{
    CERT_TYPE_INVALID       = 0,
    CERT_TYPE_PROPRIETORY   = 1,
    CERT_TYPE_X509          = 2

} CERT_TYPE;


//+----------------------------------------------------------------------------
//
// Ceritificate Blob.  Each blob contains an X509 certificate
//
//+----------------------------------------------------------------------------

typedef struct _Cert_Blob
{
    DWORD   cbCert;     // size of this certificate blob
    BYTE    abCert[1];    // beginning byte of this certificate

} Cert_Blob;

#ifdef OS_WIN16
typedef Cert_Blob FAR * PCert_Blob;
#else
typedef  Cert_Blob * PCert_Blob;
#endif  //OS_WIN16

//+----------------------------------------------------------------------------
//
// Certificate chain with a number of certificate blobs
//
// The most significant bit denotes whether the certificate that has been 
// issued is temporary.  The license server will issue a temporary certificate 
// if it has not yet obtained a certificate from the clearing house.
//
// We also assume that the chain is in the order such that each subsequent 
// certificate belongs to the issuer of the previous certificate.
//
//+----------------------------------------------------------------------------

typedef struct _Cert_Chain
{
    DWORD       dwVersion;          // version of this structure
    DWORD       dwNumCertBlobs;     // Number of certificate blobs
    Cert_Blob   CertBlob[1];        // First certificate blob

} Cert_Chain;

#ifdef OS_WIN16
typedef Cert_Chain FAR * PCert_Chain;
#else
typedef  Cert_Chain * PCert_Chain;
#endif  //OS_WIN16

#define CERT_CHAIN_VERSION_1            0x00000001
#define CERT_CHAIN_VERSION_2            0x00000002
#define MAX_CERT_CHAIN_VERSION          CERT_CHAIN_VERSION_2

#define GET_CERTIFICATE_VERSION( x )    ( 0x0FFFFFFF & x )
#define IS_TEMP_CERTIFICATE( x )        ( 0xF0000000 & x )


//-----------------------------------------------------------------------------
//
// LICENSE_CAPABILITIES
//
// Data structure used to initialize a licensing context.
//
// KeyExchangeAlg - The key exchange algorithm: RSA or Diffie Helman
// ProtocolVer - The supported licensing protocol
// fAuthenticateServer - Whether the client is going to authenticate the server
// CertType - Indicate the type of certificate that has already been transmitted
// to the client.
//
//-----------------------------------------------------------------------------

typedef struct _LICENSE_CAPABILITIES
{
    DWORD       KeyExchangeAlg;
    DWORD       ProtocolVer;    
    BOOL        fAuthenticateServer;
    CERT_TYPE   CertType;
    DWORD       cbClientName;
    PBYTE       pbClientName;

} LICENSE_CAPABILITIES;

#ifdef OS_WIN16
typedef LICENSE_CAPABILITIES FAR * PLICENSE_CAPABILITIES;
#else
typedef LICENSE_CAPABILITIES * PLICENSE_CAPABILITIES;
#endif  //OS_WIN16
typedef PLICENSE_CAPABILITIES LPLICENSE_CAPABILITIES;


//-----------------------------------------------------------------------------
//
// Client licensing info retrievable by terminal server
//
//-----------------------------------------------------------------------------

typedef struct _TS_LICENSE_INFO
{
    ULARGE_INTEGER  ulSerialNumber;     // Client license's serial number
    
    DWORD           dwProductVersion;
    PBYTE           pbOrgProductID;      // original license request product Id
    DWORD           cbOrgProductID;      // size of original license request product Id

    BOOL            fTempLicense;
    
    LPTSTR          szIssuer;
    LPTSTR          szIssuerId;          // license server setup ID

    FILETIME        NotBefore;           // license's validity
    FILETIME        NotAfter;

    LPTSTR          szLicensedClient;       // client's machine name
    LPTSTR          szLicensedUser;         // client's user name
    
    PBYTE           pbRawLicense;       // storage for marking it later
    DWORD           cbRawLicense;

    DWORD           dwSupportFlags;
    
} TS_LICENSE_INFO;

#ifdef OS_WIN16
typedef TS_LICENSE_INFO FAR * PTS_LICENSE_INFO;
#else
typedef TS_LICENSE_INFO * PTS_LICENSE_INFO;
#endif  //OS_WIN16
typedef PTS_LICENSE_INFO LPTS_LICENSE_INFO;

// Support Flags: which DCRs are supported
#define SUPPORT_PER_SEAT_REISSUANCE     0x1
#define SUPPORT_PER_SEAT_POST_LOGON     0x2
#define SUPPORT_CONCURRENT              0x4
#define SUPPORT_WHISTLER_CAL            0x8
#define SUPPORT_WHISTLER_52_CAL         0x16

#define ALL_KNOWN_SUPPORT_FLAGS (SUPPORT_PER_SEAT_REISSUANCE|SUPPORT_PER_SEAT_POST_LOGON|SUPPORT_CONCURRENT|SUPPORT_WHISTLER_CAL| SUPPORT_WHISTLER_52_CAL)

// Mark Flags: bits marking the license

#define MARK_FLAG_USER_AUTHENTICATED 0x1


#endif  //_LICENSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\mcscommn.h ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * file   : MCSCommn.h
 * author : Erik Mavrinac
 *
 * description: Common definitions for MCS.
 */

#ifndef __MCSCOMMN_H
#define __MCSCOMMN_H



/*
 * MCSError return codes from MCS entry points. These are distinct from
 * T.125 Result, Diagnostic, and Reason codes which are defined below.
 *
 * MCS_NO_ERROR
 *     Success. This does not imply that the requested function is complete if
 *     the requested service is asynchronous -- the result code in a callback
 *     gives this information. This value should also be returned when handling
 *     an MCS callback and the callback has been processed.
 *
 * MCS_COMMAND_NOT_SUPPORTED
 *     The called entry point is not yet implemented.
 *
 * MCS_NOT_INITIALIZED
 *     The application has attempted to use MCS services before MCS has been
 *     initialized.  It is necessary for the node controller (or whatever
 *     application is serving as the node controller), to initialize MCS
 *     before it is called upon to perform any services.
 *
 * MCS_ALREADY_INITIALIZED
 *     The application has attempted to initialize MCS when it is already
 *     initialized.
 *
 * MCS_DOMAIN_ALREADY_EXISTS
 *     The application has attempted to create a domain that already exists.
 *
 * MCS_USER_NOT_ATTACHED
 *     This indicates that the application has issued an MCSAttachUserRequest,
 *     and then tried to use the returned handle before receiving an
 *     MCS_ATTACH_USER_CONFIRM (which essentially validates the handle).
 *
 * MCS_NO_SUCH_USER
 *     An unknown user handle was used during an MCS call.
 *
 * MCS_TRANSMIT_BUFFER_FULL
 *     This indicates that the call failed due to an MCS resource shortage.
 *     This will typically occur when there is a LOT of traffic through the
 *     MCS layer. It simply means that MCS could not process the request at
 *     this time. It is the responsibility of the application to retry at a
 *     later time.
 *
 * MCS_NO_SUCH_CONNECTION
 *     An unknown connection handle was used during an MCS call.
 *
 * MCS_NO_SUCH_DOMAIN
 *     The DomainHandle used was not valid.
 *
 * MCS_DOMAIN_NOT_HIERARCHICAL
 *     An attempt has been made to create an upward connection from a local
 *     domain that already has an upward connection.
 *
 * MCS_ALLOCATION_FAILURE
 *     The request could not be successfully invoked due to a resource
 *     allocation failure.
 *
 * MCS_INVALID_PARAMETER
 *     One of the parameters to an MCS call is invalid.
 */

typedef enum
{
    MCS_NO_ERROR,
    MCS_COMMAND_NOT_SUPPORTED,
    MCS_NOT_INITIALIZED,
    MCS_ALREADY_INITIALIZED,
    MCS_DOMAIN_ALREADY_EXISTS,
    MCS_NO_SUCH_DOMAIN,
    MCS_USER_NOT_ATTACHED,
    MCS_NO_SUCH_USER,
    MCS_NO_SUCH_CONNECTION,
    MCS_NO_SUCH_CHANNEL,
    MCS_DOMAIN_NOT_HIERARCHICAL,
    MCS_ALLOCATION_FAILURE,
    MCS_INVALID_PARAMETER,
    MCS_CALLBACK_NOT_PROCESSED,
    MCS_TOO_MANY_USERS,
    MCS_TOO_MANY_CHANNELS,
    MCS_CANT_JOIN_OTHER_USER_CHANNEL,
    MCS_USER_NOT_JOINED,
    MCS_SEND_SIZE_TOO_LARGE,
    MCS_SEND_SIZE_TOO_SMALL,
    MCS_NETWORK_ERROR,
    MCS_DUPLICATE_CHANNEL
} MCSError;
typedef MCSError *PMCSError;



/*
 * MCS types
 *
 * DomainHandle: Identifies a unique domain.
 *
 * ConnectionHandle: Identifies a distinct connection between two nodes in
 *     an MCS domain.
 *
 * UserHandle: Identifies a unique local user attachment.
 *
 * ChannelHandle: Identifies a unique channel that has been joined locally.
 *     Different from a ChannelID -- a ChannelID corresponds to a T.125
 *     ChannelID whereas a ChannelHandle is a local handle only.
 *
 * ChannelID: Identifies an MCS channel.  There are four different
 *     types of channels that are part of this type: user ID, static, private,
 *     and assigned.
 *
 * UserID: This is a special channel that identifies a particular user in an
 *     MCS domain.  Only that user can join the channel, so this is referred
 *     to as a single-cast channel.  All other channels are multi-cast,
 *     meaning that any number of users can join them at once.
 *
 * TokenID: A token is an MCS object that is used to resolve resource conflicts.
 *     If an application has a particular resource or service that can only
 *     be used by one user at a time, that user can request exclusive
 *     ownership of a token.
 *
 * DomainParameters: The set of negotiated characteristics of an MCS domain.
 *     These are negotiated by the first two nodes in a domain, after which
 *     they are set for all members.
 *
 * MCSPriority: Identifiers for the four data send priorities allowed in MCS.
 *
 * Segmentation: Flag field for use during data sends, specifies how the data
 *     are broken up between sends. SEGMENTATION_BEGIN implies that this is the
 *     first block in a sequence; SEGMETNATION_END means this is the last block.
 *     A singleton block would specify both flags.
 *
 * TokenStatus: States of a token. Corresponds to the TokenStatus enumeration
 *     values defined in T.125.
 *
 * MCSReason, MCSResult: Correspond to the values defined for the Reason and
 *     Result enumerations defined in the T.125 spec.
 */

typedef HANDLE DomainHandle;
typedef DomainHandle *PDomainHandle;
typedef HANDLE ConnectionHandle;
typedef ConnectionHandle *PConnectionHandle;
typedef HANDLE UserHandle;
typedef UserHandle *PUserHandle;
typedef HANDLE ChannelHandle;
typedef ChannelHandle *PChannelHandle;

typedef unsigned char *DomainSelector;

typedef unsigned ChannelID;
typedef ChannelID *PChannelID;

typedef ChannelID UserID;
typedef UserID *PUserID;

typedef ChannelID TokenID;
typedef TokenID *PTokenID;

typedef struct
{
    unsigned MaxChannels;
    unsigned MaxUsers;
    unsigned MaxTokens;
    unsigned NumPriorities;
    unsigned MinThroughput;
    unsigned MaxDomainHeight;
    unsigned MaxPDUSize;
    unsigned ProtocolVersion;
} DomainParameters, *PDomainParameters;

typedef enum
{
    MCS_TOP_PRIORITY    = 0,
    MCS_HIGH_PRIORITY   = 1,
    MCS_MEDIUM_PRIORITY = 2,
    MCS_LOW_PRIORITY    = 3
} MCSPriority;
typedef MCSPriority *PMCSPriority;

// Segmentation type and flags. The flag values correspond to bit locations
//   in PER-encoded PDUs for faster PDU creation.
typedef unsigned Segmentation;
typedef Segmentation *PSegmentation;
#define SEGMENTATION_BEGIN 0x20
#define SEGMENTATION_END   0x10

// Not used in this implementation, this comes from the NetMeeting user-mode
//   MCS implementation.
#if 0
// SegmentationFlag: Alternate specification of segmentation type that defines
//   how the buffers that are given to SendDataRequest() are divided in packets.
typedef enum {
    SEGMENTATION_ONE_PACKET,       // All the buffers make up one packet
    SEGMENTATION_MANY_PACKETS,     // Each buffer makes up one packet
    SEGMENTATION_PACKET_START,     // The first buffers of one packet
    SEGMENTATION_PACKET_CONTINUE,  // Middle buffers of a packet that was started earlier
    SEGMENTATION_PACKET_END        // The ending buffers of a packet which started earlier
} SegmentationFlag, *PSegmentationFlag;
#endif

typedef enum
{
    TOKEN_NOT_IN_USE      = 0,
    TOKEN_SELF_GRABBED    = 1,
    TOKEN_OTHER_GRABBED   = 2,
    TOKEN_SELF_INHIBITED  = 3,
    TOKEN_OTHER_INHIBITED = 4,
    TOKEN_SELF_RECIPIENT  = 5,
    TOKEN_SELF_GIVING     = 6,
    TOKEN_OTHER_GIVING    = 7
} TokenStatus;
typedef TokenStatus *PTokenStatus;

typedef enum
{
    REASON_DOMAIN_DISCONNECTED = 0,
    REASON_PROVIDER_INITIATED  = 1,
    REASON_TOKEN_PURGED        = 2,
    REASON_USER_REQUESTED      = 3,
    REASON_CHANNEL_PURGED      = 4
} MCSReason, *PMCSReason;

typedef enum
{
    RESULT_SUCCESSFUL              = 0,
    RESULT_DOMAIN_MERGING          = 1,
    RESULT_DOMAIN_NOT_HIERARCHICAL = 2,
    RESULT_NO_SUCH_CHANNEL         = 3,
    RESULT_NO_SUCH_DOMAIN          = 4,
    RESULT_NO_SUCH_USER            = 5,
    RESULT_NOT_ADMITTED            = 6,
    RESULT_OTHER_USER_ID           = 7,
    RESULT_PARAMETERS_UNACCEPTABLE = 8,
    RESULT_TOKEN_NOT_AVAILABLE     = 9,
    RESULT_TOKEN_NOT_POSSESSED     = 10,
    RESULT_TOO_MANY_CHANNELS       = 11,
    RESULT_TOO_MANY_TOKENS         = 12,
    RESULT_TOO_MANY_USERS          = 13,
    RESULT_UNSPECIFIED_FAILURE     = 14,
    RESULT_USER_REJECTED           = 15
} MCSResult, *PMCSResult;

// The following defines the DataRequestType type that defines whether a
//   SendDataRequest is a normal send or a uniform send.
typedef enum {
    NORMAL_SEND_DATA,
    UNIFORM_SEND_DATA,
} DataRequestType, *PDataRequestType;



/*
 * MCS callback definitions. The Params value is dependent on Message value
 *   being received, and should be cast to the right type before use.
 */

// MCS node controller callback.
typedef void (__stdcall *MCSNodeControllerCallback) (DomainHandle hDomain,
        unsigned Message, void *Params, void *UserDefined);

// MCS user callback.
typedef void (__stdcall *MCSUserCallback) (UserHandle hUser, unsigned Message,
        void *Params, void *UserDefined);

// MCS send-data indication callback.
typedef BOOLEAN (__fastcall *MCSSendDataCallback) (BYTE *pData, unsigned DataLength,
        void *UserDefined, UserHandle hUser, BOOLEAN bUniform,
        ChannelHandle hChannel, MCSPriority Priority, UserID SenderID,
        Segmentation Segmentation);



// Callback parameter types. Pointers to these structs are passed to the
//   callback in the Params value of the callback.

typedef struct
{
    ConnectionHandle hConnection;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    BYTE             *pUserData;
    unsigned         UserDataLength;
} ConnectProviderIndication, *PConnectProviderIndication;

typedef struct
{
    DomainHandle     hDomain;
    ConnectionHandle hConnection;
    DomainParameters DomainParams;
    MCSResult        Result;
    BYTE             *pUserData;
    unsigned         UserDataLength;
} ConnectProviderConfirm, *PConnectProviderConfirm;

typedef struct
{
    DomainHandle     hDomain;
    ConnectionHandle hConnection;
    MCSReason        Reason;
} DisconnectProviderIndication, *PDisconnectProviderIndication;

typedef struct
{
    UserID    UserID;
    BOOLEAN   bSelf;
    MCSReason Reason;
} DetachUserIndication, *PDetachUserIndication;

typedef struct
{
    ChannelHandle hChannel;
    MCSError      ErrResult;
} ChannelJoinConfirm, *PChannelJoinConfirm;



/*
 * Callback values.
 */

#define MCS_CONNECT_PROVIDER_INDICATION     0
#define MCS_CONNECT_PROVIDER_CONFIRM        1
#define MCS_DISCONNECT_PROVIDER_INDICATION  2
#define MCS_ATTACH_USER_CONFIRM             3
#define MCS_DETACH_USER_INDICATION          4
#define MCS_CHANNEL_JOIN_CONFIRM            5
#define MCS_CHANNEL_CONVENE_CONFIRM         6
#define MCS_CHANNEL_DISBAND_INDICATION      7
#define MCS_CHANNEL_ADMIT_INDICATION        8
#define MCS_CHANNEL_EXPEL_INDICATION        9
#define MCS_SEND_DATA_INDICATION            10
#define MCS_UNIFORM_SEND_DATA_INDICATION    11
#define MCS_TOKEN_GRAB_CONFIRM              12
#define MCS_TOKEN_INHIBIT_CONFIRM           13
#define MCS_TOKEN_GIVE_INDICATION           14
#define MCS_TOKEN_GIVE_CONFIRM              15
#define MCS_TOKEN_PLEASE_INDICATION         16
#define MCS_TOKEN_RELEASE_CONFIRM           17
#define MCS_TOKEN_TEST_CONFIRM              18
#define MCS_TOKEN_RELEASE_INDICATION        19



/*
 * API function prototypes common to user and kernel mode implementations.
 */

#ifdef __cplusplus
extern "C" {
#endif



#ifndef APIENTRY
#define APIENTRY __stdcall
#endif



MCSError APIENTRY MCSAttachUserRequest(
        DomainHandle        hDomain,
        MCSUserCallback     UserCallback,
        MCSSendDataCallback SDCallback,
        void                *UserDefined,
        UserHandle          *phUser,
        unsigned            *pMaxSendSize,
        BOOLEAN             *pbCompleted);

UserID APIENTRY MCSGetUserIDFromHandle(UserHandle hUser);

MCSError APIENTRY MCSDetachUserRequest(
        UserHandle hUser);

MCSError APIENTRY MCSChannelJoinRequest(
        UserHandle    hUser,
        ChannelID     ChannelID,
        ChannelHandle *phChannel,
        BOOLEAN       *pbCompleted);

ChannelID APIENTRY MCSGetChannelIDFromHandle(ChannelHandle hChannel);

MCSError APIENTRY MCSChannelLeaveRequest(
        UserHandle    hUser,
        ChannelHandle hChannel);



#ifdef __cplusplus
}
#endif



#endif  // !defined(__MCSCOMMN_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgcfnc.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgcfnc.h                                                               */
/*                                                                          */
/* DC-Groupware C runtime functions - Windows NT specific header.           */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/ndcgcfnc.h_v  $
// 
//    Rev 1.4   06 Aug 1997 14:32:58   AK
// SFR1016: Apply Markups
//
//    Rev 1.3   06 Aug 1997 10:41:24   AK
// SFR1016: Complete removal of DCCHAR etc
//
//    Rev 1.2   23 Jul 1997 10:47:58   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:51:10   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCFNC
#define _H_NDCGCFNC

#endif /* _H_NDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgctyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows NT specific header.                 */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/NDCGCTYP.H_v  $
// 
//    Rev 1.5   23 Jul 1997 10:48:00   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:52:26   OBK
// SFR0000: Start of RNS codebase
//
//    Rev 1.4   08 Jul 1997 08:49:36   KH
// SFR1022: Add message parameter extraction macros
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCTYP
#define _H_NDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef DCUINT32                       DCSURFACEID;
typedef DCSURFACEID          DCPTR     PDCSURFACEID;
typedef FILETIME                       DCFILETIME;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* String manipulation                                                      */
/****************************************************************************/
#define DC_CHARNEXT(pCurrentChar) (CharNext(pCurrentChar))
#define DC_CHARPREV(pStringStart, pCurrentChar) \
                                       (CharPrev(pStringStart, pCurrentChar))
#define DC_CHARLOWER(pString) (CharLower(pString))

/****************************************************************************/
/* Message parameter extraction macros.                                     */
/****************************************************************************/
/* WM_COMMAND                                                               */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     command identifier          notification code (HI),           */
/*                                        command identifier (LO)           */
/* lParam     control hwnd (HI),          control hwnd                      */
/*            notification code (LO)                                        */
/****************************************************************************/
#define DC_GET_WM_COMMAND_ID(wParam) (LOWORD(wParam))
#define DC_GET_WM_COMMAND_NOTIFY_CODE(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_COMMAND_HWND(lParam) ((HWND)(lParam))

/****************************************************************************/
/* WM_ACTIVATE                                                              */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     activation flag             minimized flag (HI),              */
/*                                        activation flag (LO)              */
/* lParam     minimized flag (HI),        hwnd                              */
/*            hwnd (LO)                                                     */
/****************************************************************************/
#define DC_GET_WM_ACTIVATE_ACTIVATION(wParam) (LOWORD(wParam))
#define DC_GET_WM_ACTIVATE_MINIMIZED(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_ACTIVATE_HWND(lParam) ((HWND)(lParam))

/****************************************************************************/
/* WM_HSCROLL and WM_VSCROLL                                                */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     scroll code                 position (HI),                    */
/*                                        scroll code (LO)                  */
/* lParam     hwnd (HI),                  hwnd                              */
/*            position (LO)                                                 */
/****************************************************************************/
#define DC_GET_WM_SCROLL_CODE(wParam) (LOWORD(wParam))
#define DC_GET_WM_SCROLL_POSITION(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_SCROLL_HWND(lParam) ((HWND)(lParam))

#endif /* _H_NDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgmcro.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows NT specific header.                 */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/NDCGMCRO.H_v  $
// 
//    Rev 1.4   23 Jul 1997 10:48:02   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:53:36   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGMCRO
#define _H_NDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* FIELDSIZE macro.                                                         */
/****************************************************************************/
#define FIELDSIZE(type, field)   (sizeof(((type *)1)->field))

/****************************************************************************/
/* FIELDOFFSET macro.                                                       */
/****************************************************************************/
#define FIELDOFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif /* _H_NDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\nprfincl.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
/* nprfincl.h - auto-generated header file */

#define DCGOBJ                           0
#define PERF_BYTES_RECV                  2
#define PERF_BYTES_SENT                  4
#define PERF_PKTS_RECV                   6
#define PERF_PKTS_SENT                   8
#define PERF_WINSOCK_RECV_FAIL           10
#define PERF_WINSOCK_SEND_FAIL           12
#define PERF_PKTS_ALLOCATED              14
#define PERF_PKTS_FREED                  16

#define DCPRF_USER_COUNTERS   8
#define DCPRF_KERN_COUNTERS   0

#define DCPRF_COUNTER_TYPES \
{           \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    (DWORD)-1 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgperf.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgperf.h                                                               */
/*                                                                          */
/* DC-Groupware performance monitoring - Windows NT specific header.        */
/*                                                                          */
/* Copyright(c) Microsoft 1996-7                                            */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  10Sep96 AK  SFR0569     Created for performance monitoring              */
/*  22Jan97 AK  SFR1165     Add PRF_SET_RAWCOUNT                            */
/*  05Feb97 TH  SFR1373     Get C++ build working                           */
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGPERF
#define _H_NDCGPERF

#ifdef VER_CPP
extern "C" {
#endif /* VER_CPP */

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Include the auto-generated header file containing constant definitions   */
/****************************************************************************/
#include <nprfincl.h>

#define DC_NO_PERFORMANCE_MONITOR

/****************************************************************************/
/* Import the shared data segment from the Performance DLL                  */
/****************************************************************************/
__declspec(dllimport) DWORD prfSharedDataBlock[1024];

/****************************************************************************/
/* Define the Performance Monitoring macros.                                */
/* Note that the constants are defined in nprfincl.h as 2, 4, 6, ...        */
/* The offsets into the shared data are 0, 8, 16, etc                       */
/****************************************************************************/
#ifndef DC_NO_PERFORMANCE_MONITOR

#define PRF_INC_COUNTER(x)                                                   \
      (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))++;

#define PRF_ADD_COUNTER(x,n)                                                 \
   (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))+=(n);

#define PRF_SET_RAWCOUNT(x,n)                                                \
   (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))=(n);

/****************************************************************************/
/* Timers currently not implemented.                                        */
/****************************************************************************/
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#else /* ..DC_NO_PERFORMANCE_MONITOR.. */

#define PRF_INC_COUNTER(x)
#define PRF_ADD_COUNTER(x,n)
#define PRF_SET_RAWCOUNT(x,n)
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#endif /* DC_NO_PERFORMANCE_MONITOR  */

#ifdef VER_CPP
}
#endif  /* VER_CPP */
#endif /* _H_NDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ndcgcnst.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - Windows NT specific header.              */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/ndcgcnst.h_v  $
//
//    Rev 1.4   27 Aug 1997 16:28:08   enh
// SFR1189: Added command line registry session
//
//    Rev 1.3   22 Aug 1997 10:23:06   SJ
// SFR1316: Trace options in wrong place in the registry.
//
//    Rev 1.2   23 Jul 1997 10:47:58   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:51:52   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCNST
#define _H_NDCGCNST

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Mutex and shared memory object names.                                    */
/****************************************************************************/
#define TRC_MUTEX_NAME                 _T("TRCMutex")
#define TRC_SHARED_DATA_NAME           _T("TRCSharedDataName")
#define TRC_TRACE_FILE_NAME            _T("TRCTraceFileName")

/****************************************************************************/
/* Server registry prefix.                                                  */
/****************************************************************************/
#define DC_REG_PREFIX             _T("SOFTWARE\\Microsoft\\Conferencing\\DCG\\")

/****************************************************************************/
/* ULS registry entry - for Microsoft's User Location Service               */
/****************************************************************************/
#define REGKEY_ULS_USERDETAILS  \
                      "Software\\Microsoft\\User Location Service\\Client"

#define REGVAL_ULS_NAME  "User Name"

/****************************************************************************/
/* Location of comupter name in registry (used by TDD)                      */
/****************************************************************************/
#define REGVAL_COMPUTERNAME "ComputerName"
#define REGKEY_COMPUTERNAME \
              "System\\CurrentControlSet\\control\\ComputerName\\ComputerName"

/****************************************************************************/
/* Registry keys for Modem TDD.                                             */
/****************************************************************************/
#define REGKEY_CONF         "SOFTWARE\\Microsoft\\Conferencing"
#define REGVAL_USE_R11      "R11 Compatibility"
#define REGVAL_AUTO_ANSWER  "AutoAnswer"
#define REGVAL_N_RINGS      "nPickupRings"

#define REGKEY_PSTN      "SOFTWARE\\Microsoft\\Conferencing\\Transports\\PSTN"
#define REGVAL_PROVNAME  "Provider Name"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_DCSURFACEID               ((DCSURFACEID)0)
#define NULL_SYSBITMAP                 NULL

/****************************************************************************/
/* Performance monitoring file and application names                        */
/****************************************************************************/
#define PERF_APP_NAME "DCG"
#define DCG_PERF_INI_FILE "nprfini.ini"
#define DCG_PERF_HDR_FILE "nprfincl.h"

#endif /* _H_NDCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ntrcapi.h ===
/****************************************************************************/
/*                                                                          */
/* ntrcapi.h                                                                */
/*                                                                          */
/* DC-Groupware tracing API header - Windows NT specifc                     */
/*                                                                          */
/* Copyright(c) Microsoft 1996                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  07Oct96 PAB Created     Millennium codebase.                            */
/*  22Oct96 PAB SFR0534     Mark ups from display driver review             */
/*  23Oct96 PAB SFR0730     Merged shared memory changes                    */
/*  17Dec96 PAB SFR0646     Use DLL_DISP to identify display driver code    */
/*                                                                          */
/****************************************************************************/
#ifndef _H_NTRCAPI
#define _H_NTRCAPI


#ifdef DLL_DISP
/****************************************************************************/
/* API FUNCTION: TRC_DDSetTrace(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes the new trace settings from the OSI request and sets */
/* the trace configuration accordingly.                                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to new trace request block                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_DDSetTrace(DCUINT32 cjIn, PDCVOID pvIn);


/****************************************************************************/
/* API FUNCTION: TRC_DDGetTraceOutput(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function passes back any accumulated kernel mode tracing back to    */
/* the user mode task that requested the data.                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to request block                                          */
/* cjOut: Size of output block                                              */
/* pvOut: Pointer to output block                                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_DDGetTraceOutput(DCUINT32 cjIn,
                                           PDCVOID  pvIn,
                                           DCUINT32 cjOut,
                                           PDCVOID  pvOut);


/****************************************************************************/
/* API FUNCTION: TRC_DDProcessRequest(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function processes tracing specific requests received on the        */
/* display driver side of the OSI.                                          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to new trace request block                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
ULONG DCAPI TRC_DDProcessRequest(SURFOBJ* pso,
                                          DCUINT32 cjIn,
                                          PDCVOID  pvIn,
                                          DCUINT32 cjOut,
                                          PDCVOID  pvOut);
#endif
#endif /* _H_NTRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\ntrcctl.h ===
/****************************************************************************/
/* NTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control file                                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  26Sep96 PAB Created     Millennium code base                            */
/*  22Oct96 PAB SFR0534     Mark ups from display driver review             */
/*  17Dec96 PAB SFR0646     Use DLL_DISP to identify display driver code    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Functions to be included in both user and kernel space                   */
/****************************************************************************/
#define INC_TRC_GetBuffer
#define INC_TRC_TraceBuffer
#define INC_TRC_GetConfig
#define INC_TRC_SetConfig
#define INC_TRC_TraceData
#define INC_TRC_GetTraceLevel
#define INC_TRC_ProfileTraceEnabled

#define INC_TRCCheckState
#define INC_TRCDumpLine
#define INC_TRCShouldTraceThis
#define INC_TRCSplitPrefixes


/****************************************************************************/
/* User space only functions.                                               */
/****************************************************************************/
#ifndef DLL_DISP
#define INC_TRC_ResetTraceFiles

#define INC_TRCOutput
#define INC_TRCReadFlag
#define INC_TRCSetDefaults
#define INC_TRCReadSharedDataConfig
#define INC_TRCWriteFlag
#define INC_TRCWriteSharedDataConfig
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       platform.h
//
//  Contents:   Platform Challenge data structures and functions.
//
//  History:    02-19-98   FredCh   Created
//
//----------------------------------------------------------------------------

#ifndef _PLATFORM_H_
#define _PLATFORM_H_

///////////////////////////////////////////////////////////////////////////////
//
// Definition of the platform ID.
//
// The platform ID is made up of portions:
// The most significant BYTE is used for identifying the OS platform which the
// client is running and the second most significant BYTE is used for identifying 
// the ISV that has provided the client image.  The last 2 bytes are used by 
// the ISV to specify the build of the client image.
//
// When supplying the platform ID for platform challenge, the client will use
// the logical OR value of the OS and IMAGE identifiers.  For example, a 
// Microsoft win32 build 356 client running on WINNT 4.0 will give the platform 
// value of:
// 
// CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT | 0x00000164
//

#define CLIENT_OS_ID_WINNT_351                          0x01000000
#define CLIENT_OS_ID_WINNT_40                           0x02000000
#define CLIENT_OS_ID_WINNT_50                           0x03000000
#define CLIENT_OS_ID_MINOR_WINNT_51                     0x00000001
#define CLIENT_OS_ID_MINOR_WINNT_52                     0x00000002
#define CLIENT_OS_ID_WINNT_POST_52                      0x04000000
#define CLIENT_OS_ID_OTHER                              0xFF000000
#define CLIENT_OS_INDEX_OTHER                           0x00000000
#define CLIENT_OS_INDEX_WINNT_50                        0x00000001
#define CLIENT_OS_INDEX_WINNT_51                        0x00000002
#define CLIENT_OS_INDEX_WINNT_52                        0x00000003
#define CLIENT_OS_INDEX_WINNT_POST_52                   0x00000004


#define CLIENT_IMAGE_ID_MICROSOFT                       0x00010000
#define CLIENT_IMAGE_ID_CITRIX                          0x00020000


///////////////////////////////////////////////////////////////////////////////
//
// Macros for getting the individual component of the platform ID
//

#define GetOSId( _PlatformId ) \
    _PlatformId & 0xFF000000

#define GetImageId( _PlatformId ) \
    _PlatformId & 0x00FF0000

#define GetImageRevision( _PlatformId ) \
    _PlatformId & 0x0000FFFF


///////////////////////////////////////////////////////////////////////////////
//
// platform challenge is 128 bits random number
//

#define PLATFORM_CHALLENGE_SIZE                 16      
#define PLATFORM_CHALLENGE_IMAGE_FILE_SIZE      16384


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\pclip.h ===
/**INC+**********************************************************************/
/* Header:    pclip.h                                                       */
/*                                                                          */
/* Purpose:   Clip Redirector Addin protocol header                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/

#ifndef _H_PCLIP
#define _H_PCLIP

/****************************************************************************/
/* Name of the Clip virtual channel                                         */
/****************************************************************************/
#define CLIP_CHANNEL "CLIPRDR"

/****************************************************************************/
/* Structure: TS_CLIP_PDU                                                   */
/*                                                                          */
/* Name of PDU: ClipPDU              (a T.128 extension)                    */
/****************************************************************************/
typedef struct tagTS_CLIP_PDU
{
    TSUINT16                 msgType;

#define TS_CB_MONITOR_READY             1
#define TS_CB_FORMAT_LIST               2
#define TS_CB_FORMAT_LIST_RESPONSE      3
#define TS_CB_FORMAT_DATA_REQUEST       4
#define TS_CB_FORMAT_DATA_RESPONSE      5
#define TS_CB_TEMP_DIRECTORY            6

    TSUINT16                 msgFlags;

#define TS_CB_RESPONSE_OK               0x01
#define TS_CB_RESPONSE_FAIL             0x02
#define TS_CB_ASCII_NAMES               0x04

    TSUINT32                 dataLen;
    TSUINT8                  data[1];

} TS_CLIP_PDU;
typedef TS_CLIP_PDU UNALIGNED FAR *PTS_CLIP_PDU;


/****************************************************************************/
/* Structure: TS_CLIP_FORMAT                                                */
/*                                                                          */
/* Clipboard format information                                             */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      format id                                                           */
/*      format name                                                         */
/*                                                                          */
/****************************************************************************/
#define TS_FORMAT_NAME_LEN  32

typedef struct tagTS_CLIP_FORMAT
{
    TSUINT32                formatID;

#define TS_FORMAT_NAME_LEN 32
    TSUINT8                formatName[TS_FORMAT_NAME_LEN];
} TS_CLIP_FORMAT;
typedef TS_CLIP_FORMAT UNALIGNED FAR * PTS_CLIP_FORMAT;


/****************************************************************************/
/* Structure: TS_CLIP_MFPICT                                                */
/*                                                                          */
/* Metafile information                                                     */
/*                                                                          */
/****************************************************************************/
typedef struct tagTS_CLIP_MFPICT
{
    TSUINT32    mm;
    TSUINT32    xExt;
    TSUINT32    yExt;
} TS_CLIP_MFPICT;
typedef TS_CLIP_MFPICT UNALIGNED FAR *PTS_CLIP_MFPICT;



#endif /* _H_PCLIP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\rdperr.h ===
/****************************************************************************/
// logerr.h
//
// Error logging constants and descriptions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

// Specific components are declared here divided into ranges in the unsigned
// space. Note that the ordering here is important since we use these ranges
// to determine a facility name in MCSProtocolErrorEvent().
#define Log_Null_Base    0
#define Log_X224_Base    1
#define Log_MCS_Base     100
#define Log_RDP_Base     200
#define Log_RDP_ENC_Base 400


/*
 * Null
 */

// "Null event log error"
#define Log_Null Log_Null_Base



/*
 * X.224
 */

// "Overall X.224 Disconnect Request header length given in a "
// "packet was not 11 as expected, or the Length Indicator was not 6."
#define Log_X224_DisconnectHeaderLenNotRequiredSize       Log_X224_Base

// "An X.224 Disconnect Request was received without first receving an X.224 "
// "connect"
#define Log_X224_DisconnectWithoutConnection              (Log_X224_Base + 2)

// "An X.224 packet was received with the wrong X.224 version prefix "
// "(expected 0x03 0x00)."
#define Log_X224_RFC1006HeaderVersionNotCorrect           (Log_X224_Base + 3)

// "An X.224 Data packet was received before the connectioon sequence was "
// "completed."
#define Log_X224_ReceivedDataBeforeConnected              (Log_X224_Base + 4)

// "An X.224 packet was received with a packet length indicator less "
// "than the minimum for its headers."
#define Log_X224_PacketLengthLessThanHeader               (Log_X224_Base + 5)

// "An X.224 Data packet was received whose Length Indicator was not 2 as "
// "expected."
#define Log_X224_DataLenIndNotRequiredSize                (Log_X224_Base + 6)

// "An X.224 Data packet did not have the EOT bit set; this is not supported "
// "in this implementation."
#define Log_X224_DataFalseEOTNotSupported                 (Log_X224_Base + 7)

// "An X.224 Data packet was received which did not contain a complete MCS "
// "PDU. This is not supported in this implementation."
#define Log_X224_DataIncompleteMCSPacketNotSupported      (Log_X224_Base + 8)

// "An X.224 Data packet was received containing more than one MCS PDU. This "
// "is not supported in this implementation."
#define Log_X224_DataMultipleMCSPDUsNotSupported          (Log_X224_Base + 9)

// "An X.224 packet was received with an unknown TPDU type."
#define Log_X224_UnknownPacketType                        (Log_X224_Base + 10)

// "An X.224 Connect packet was received when already connected."
#define Log_X224_ConnectReceivedAfterConnected            (Log_X224_Base + 11)

// "An X.224 Connect packet was received containing a total packet length "
// "field that was not at least 11 bytes, or a Lengh Indicator not at least "
// "6 bytes."
#define Log_X224_ConnectHeaderLenNotRequiredSize          (Log_X224_Base + 12)

// "An X.224 Connect packet was received which specified a connection level "
// "other than class 0."
#define Log_X224_ConnectNotClassZero                      (Log_X224_Base + 14)

// "An X.224 Connect packet was received containing a TPDU_SIZE field whose "
// "length field was not 1."
#define Log_X224_ConnectTPDU_SIZELengthFieldIllegalValue  (Log_X224_Base + 15)

// "An X.224 Connect packet was received containing a TPDU_SIZE block size "
// "outside range of 7..11."
#define Log_X224_ConnectTPDU_SIZENotLegalRange            (Log_X224_Base + 16)

// "An X.224 Connect packet was received containing a Length Indicator that "
// "does not match the packet length specified in the header."
#define Log_X224_ConnectLenIndNotMatchingPacketLen        (Log_X224_Base + 17)

// "An X.224 Disconnect packet was received containing a Length Indicator "
// "that does not match the packet length specified in the header."
#define Log_X224_DisconnectLenIndNotMatchingPacketLen     (Log_X224_Base + 18)

// "An X.224 Data packet was received after an X.224 Disconnect or MCS DPum."
#define Log_X224_ReceivedDataAfterRemoteDisconnect        (Log_X224_Base + 19)



/*
 * MCS
 */

// "An MCS connect PDU was received containing a poorly formatted or "
// "unsupported ASN.1 BER encoding."
#define Log_MCS_ConnectPDUBadPEREncoding                  Log_MCS_Base

// "An MCS connect PDU was received which is not supported under this "
// "MCS implementation."
#define Log_MCS_UnsupportedConnectPDU                     (Log_MCS_Base + 1)

// "An MCS merge-domain PDU was received. Merging domains is not supported "
// "in this implementation."
#define Log_MCS_UnsupportedMergeDomainPDU                 (Log_MCS_Base + 2)

// "MCS failed to successfully negotiate domain parameters with a remote "
// "connection."
#define Log_MCS_UnnegotiableDomainParams                  (Log_MCS_Base + 3)

// "MCS received a connect PDU enumeration value outside the allowed range."
#define Log_MCS_BadConnectPDUType                         (Log_MCS_Base + 4)

// "MCS received a domain PDU enumeration value outside the allowed range."
#define Log_MCS_BadDomainPDUType                          (Log_MCS_Base + 5)

// "MCS received an unexpected Connect-Initial PDU."
#define Log_MCS_UnexpectedConnectInitialPDU               (Log_MCS_Base + 6)



/*
 * RDP (The protocol formerly known as TShare)
 */

// "A packet with an unknown PDUType2 has been received."
#define Log_RDP_UnknownPDUType2                           (Log_RDP_Base + 1)

// "A packet with an unknown PDUType has been received."
#define Log_RDP_UnknownPDUType                            (Log_RDP_Base + 2)

// "A data packet has been received out of sequence."
#define Log_RDP_DataPDUSequence                           (Log_RDP_Base + 3)

// "An unknown Flow PDU has been received."
#define Log_RDP_UnknownFlowPDU                            (Log_RDP_Base + 4)

// "A control packet has been received out of sequence."
#define Log_RDP_ControlPDUSequence                        (Log_RDP_Base + 5)

// "A ControlPDU has been received with an invalid action."
#define Log_RDP_InvalidControlPDUAction                   (Log_RDP_Base + 6)

// "An InputPDU has been received with an invalid messageType."
#define Log_RDP_InvalidInputPDUType                       (Log_RDP_Base + 7)

// "An InputPDU has been received with invalid mouse flags."
#define Log_RDP_InvalidInputPDUMouse                      (Log_RDP_Base + 8)

// "An invalid RefreshRectPDU has been received."
#define Log_RDP_InvalidRefreshRectPDU                     (Log_RDP_Base + 9)

// "An error occurred creating Server-Client user data."
#define Log_RDP_CreateUserDataFailed                      (Log_RDP_Base + 10)

// "Failed to connect to Client."
#define Log_RDP_ConnectFailed                             (Log_RDP_Base + 11)

// "A ConfirmActivePDU was received from the Client with the wrong ShareID."
#define Log_RDP_ConfirmActiveWrongShareID                 (Log_RDP_Base + 12)

// "A ConfirmActivePDU was received from the Client with the wrong "
// "originatorID."
#define Log_RDP_ConfirmActiveWrongOriginator              (Log_RDP_Base + 13)

// "A PersistentListPDU was received of insufficient length."
#define Log_RDP_PersistentKeyPDUBadLength        (Log_RDP_Base + 18)

// "A PersistentListPDU was received marked FIRST when a FIRST PDU was "
// "previously received."
#define Log_RDP_PersistentKeyPDUIllegalFIRST     (Log_RDP_Base + 19)

// "A PersistentListPDU was received which specified more keys than the "
// "protocol allows."
#define Log_RDP_PersistentKeyPDUTooManyTotalKeys (Log_RDP_Base + 20)

// "A PersistentListPDU was received which contained more than the "
// "specified number of keys for the cache."
#define Log_RDP_PersistentKeyPDUTooManyCacheKeys (Log_RDP_Base + 21)

// "An InputPDU was received of insufficient length."
#define Log_RDP_InputPDUBadLength                (Log_RDP_Base + 22)

// "A BitmapCacheErrorPDU was received of bad length."
#define Log_RDP_BitmapCacheErrorPDUBadLength     (Log_RDP_Base + 23)

// "A packet was received at the security layer that was too short for "
// "the required security data."
#define Log_RDP_SecurityDataTooShort             (Log_RDP_Base + 24)

// "A virtual channel packet was received that was too short for "
// "required header data."
#define Log_RDP_VChannelDataTooShort             (Log_RDP_Base + 25)

// "Share core data was received that was too short for required "
// "header data."
#define Log_RDP_ShareDataTooShort                (Log_RDP_Base + 26)

// "A bad SuppressOutputPDU was received - either too short or too many "
// "rectangles."
#define Log_RDP_BadSupressOutputPDU              (Log_RDP_Base + 27)

// "A ClipPDU was received that was too short for its header or data."
#define Log_RDP_ClipPDUTooShort                  (Log_RDP_Base + 28)

// "A ConfirmActivePDU was received that was too short for its header or data."
#define Log_RDP_ConfirmActivePDUTooShort         (Log_RDP_Base + 29)

// "A FlowPDU was received that was too short."
#define Log_RDP_FlowPDUTooShort                  (Log_RDP_Base + 30)

// "A capability set has been received with a length less than the length of "
// "a capability set header."
#define Log_RDP_CapabilitySetTooSmall            (Log_RDP_Base + 31)

// "A capability set has been received with a length greater than the "
// "total length of data received."
#define Log_RDP_CapabilitySetTooLarge            (Log_RDP_Base + 32)

// "The negotiated cursor cache size = zero."
#define Log_RDP_NoCursorCache                    (Log_RDP_Base + 33)

// "The client capabilities received were unacceptable."
#define Log_RDP_BadCapabilities                  (Log_RDP_Base + 34)

// "The client GCC user data was malformed."
#define Log_RDP_BadUserData                      (Log_RDP_Base + 35)

// "Virtual channel decompression error."
#define Log_RDP_VirtualChannelDecompressionErr   (Log_RDP_Base + 36)

// "Invalid VC compression format specified"
#define Log_RDP_InvalidVCCompressionType         (Log_RDP_Base + 37)

// "Can't allocate out buffer"
#define Log_RDP_AllocOutBuf                      (Log_RDP_Base + 38)

// "Invalid channel ID"
#define Log_RDP_InvalidChannelID                 (Log_RDP_Base + 39)

// "Too many channels to join in NM_Connect"
#define Log_RDP_VChannelsTooMany                 (Log_RDP_Base + 40)

// "The shadow data is too short
#define Log_RDP_ShadowDataTooShort               (Log_RDP_Base + 41)

// "The server certificate PDU is too short
#define Log_RDP_BadServerCertificateData         (Log_RDP_Base + 42)

//
// RDP_ failed to update the encryption session key.
//

#define Log_RDP_ENC_UpdateSessionKeyFailed      (Log_RDP_ENC_Base + 1)

//
// RDP failed to decrypt protocol data.
//

#define Log_RDP_ENC_DecryptFailed               (Log_RDP_ENC_Base + 2)

//
// RDP failed to encrypt protocol data.
//

#define Log_RDP_ENC_EncryptFailed               (Log_RDP_ENC_Base + 3)

//
// RDP Data Encryption Package mismatch.
//

#define Log_RDP_ENC_EncPkgMismatch              (Log_RDP_ENC_Base + 4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\t120.h ===
/*
 *      t120.h
 *
 *      Abstract:
 *              This is the interface file for the communications infrastructure of
 *              T120.
 *
 *              Note that this is a "C" language interface in order to prevent any "C++"
 *              naming conflicts between different compiler manufacturers.  Therefore,
 *              if this file is included in a module that is being compiled with a "C++"
 *              compiler, it is necessary to use the following syntax:
 *
 *              extern "C"
 *              {
 *                      #include "t120.h"
 *              }
 *
 *              This disables C++ name mangling on the API entry points defined within
 *              this file.
 *
 *      Author:
 *              blp
 *
 *      Caveats:
 *              none
 */
#ifndef _T120_
#define _T120_


/*
 *      This is the GCCBoolean type used throughout MCS.
 */
typedef int                     T120Boolean;

/*
 *      These macros are used to resolve far references in the Windows world.
 *      When not operating in the Windows world, they are simply NULL.
 */
#ifdef _WINDOWS
#       ifndef  FAR
#               ifdef   WIN32
#                       define  FAR
#               else
#                       define  FAR                             _far
#               endif
#       endif
#       ifndef  CALLBACK
#               ifdef   WIN32
#                       define  CALLBACK                __stdcall
#               else
#                       define  CALLBACK                _far _pascal
#               endif
#       endif
#       ifndef  APIENTRY
#               ifdef   WIN32
#                       define  APIENTRY                __stdcall
#               else
#                       define  APIENTRY                _far _pascal _export
#               endif
#       endif
#else
#       ifndef FAR
#               define  FAR
#       endif
#       ifndef CALLBACK
#               define  CALLBACK
#       endif
#       ifndef APIENTRY
#               define  APIENTRY
#       endif
#endif

#define FALSE           0
#define TRUE            1

/*
 *      These macros are used to pack 2 16-bit values into a 32-bit variable, and
 *      get them out again.
 */
#ifndef LOWUSHORT
	#define LOWUSHORT(ul)   ((unsigned short) (ul))
#endif

#ifndef HIGHUSHORT
	#define HIGHUSHORT(ul)  ((unsigned short) ((unsigned long) (ul) >> 16))
#endif

#include "mcscommn.h"
#include "tgcc.h"   // tiny gcc

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\rdpsndp.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     rdpsndp.h
//
//      Purpose:    Sound redirection protocol description
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#ifndef _VCSND_H
#define _VCSND_H

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#define RDPSND_PROTOCOL_VERSION     0x0005

#define _SNDVC_NAME     "RDPSND"

#define DEFAULT_VC_TIMEOUT  30000

//  Device capabilities
//
#define TSSNDCAPS_ALIVE     1
#define TSSNDCAPS_VOLUME    2
#define TSSNDCAPS_PITCH     4
#define TSSNDCAPS_INITIALIZED 0x40000000
#define TSSNDCAPS_TERMINATED 0x80000000

//  the block size must be bigger than the biggest
//  aligned block after acm conversion
//  for example, Mobile Voice (WAVE_FORMAT_CU_CODEC) format 
//  requres more than 4096
//  samples per block
//
#define TSSND_BLOCKSIZE         ( 8192 * TSSND_NATIVE_BLOCKALIGN )
#define TSSND_BLOCKSONTHENET    4

#define TSSND_NATIVE_BITSPERSAMPLE  16
#define TSSND_NATIVE_CHANNELS       2
#define TSSND_NATIVE_SAMPLERATE     22050
#define TSSND_NATIVE_BLOCKALIGN     ((TSSND_NATIVE_BITSPERSAMPLE * \
                                    TSSND_NATIVE_CHANNELS) / 8)
#define TSSND_NATIVE_AVGBYTESPERSEC (TSSND_NATIVE_BLOCKALIGN * \
                                    TSSND_NATIVE_SAMPLERATE)

#define RANDOM_KEY_LENGTH           32
#define RDPSND_SIGNATURE_SIZE       8

#define IsDGramWaveSigned( _version_ )  ( _version_ >= 3 )
#define CanUDPFragment( _version_ )     ( _version_ >= 4 )
#define IsDGramWaveAudioSigned( _version_ ) ( _version_ >= 5 )

//  Commands/Responses
//
enum {
    SNDC_NONE,
    SNDC_CLOSE, 
    SNDC_WAVE, 
    SNDC_SETVOLUME, 
    SNDC_SETPITCH,
    SNDC_WAVECONFIRM,
    SNDC_TRAINING,
    SNDC_FORMATS,
    SNDC_CRYPTKEY,
    SNDC_WAVEENCRYPT,
    SNDC_UDPWAVE,
    SNDC_UDPWAVELAST
    };

typedef struct {
    BYTE        Type;
    BYTE        bPad;
    UINT16      BodySize;
//  BYTE        Body[0];
} SNDPROLOG, *PSNDPROLOG;

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwVolume;
} SNDSETVOLUME, *PSNDSETVOLUME;

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwPitch;
} SNDSETPITCH, *PSNDSETPITCH;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wFormatNo;
    union {
    BYTE        cBlockNo;
    DWORD       dwBlockNo;
    };
//  BYTE        Wave[0];
} SNDWAVE, *PSNDWAVE;

#define RDPSND_FRAGNO_EXT       0x80
#define RDPSND_MIN_FRAG_SIZE    0x80
typedef struct {
    BYTE        Type;
    BYTE        cBlockNo;
    BYTE        cFragNo;
//
//  if RDPSND_FRAGNO_EXT is set
//  there will be another byte for the low bits of the frag no
//  BYTE        Wave[0];
} SNDUDPWAVE, *PSNDUDPWAVE;

typedef struct {
    BYTE        Type;
    UINT16      wTotalSize;
    UINT16      wTimeStamp;
    UINT16      wFormatNo;
    union {
    BYTE        cBlockNo;
    DWORD       dwBlockNo;
    };
//  BYTE        Wave[0];
} SNDUDPWAVELAST, *PSNDUDPWAVELAST;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    BYTE        cConfirmedBlockNo;
    BYTE        bPad;
} SNDWAVECONFIRM, *PSNDWAVECONFIRM;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wPackSize;
} SNDTRAINING, *PSNDTRAINING;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wVersion;
} SNDVERSION, *PSNDVERSION;

typedef struct {
    UINT16      wFormatTag;
    UINT16      nChannels;
    UINT32      nSamplesPerSec;
    UINT32      nAvgBytesPerSec;
    UINT16      nBlockAlign;
    UINT16      wBitsPerSample;
    UINT16      cbSize;
//
// extra fomat info
//
} SNDFORMATITEM, *PSNDFORMATITEM; 

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwFlags;
    UINT32      dwVolume;
    UINT32      dwPitch;
    UINT16      wDGramPort;
    UINT16      wNumberOfFormats;
    BYTE        cLastBlockConfirmed;
    UINT16      wVersion;
    BYTE        bPad;
//  SNDFORMATITEM   pSndFmt[0];
} SNDFORMATMSG, *PSNDFORMATMSG;

typedef struct {
    SNDPROLOG   Prolog;
    DWORD       Reserved;
    BYTE        Seed[RANDOM_KEY_LENGTH];
} SNDCRYPTKEY, *PSNDCRYPTKEY;

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  // !_VCSND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tgcc.h ===
/****************************************************************************/
// tgcc.h
//
// TS GCC layer include file.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _GCC_H_
#define _GCC_H_


//---------------------------------------------------------------------------
// Defines
//---------------------------------------------------------------------------

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C        extern "C"
#else
    #define EXTERN_C        extern
#endif
#endif


//---------------------------------------------------------------------------
// Typedefs
//---------------------------------------------------------------------------

/*
** Typedefs that used to be defined in MCS but are no longer used there.
*/
typedef unsigned char *TransportAddress;
typedef HANDLE PhysicalHandle;


/*
** Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, single byte character strings.
** A single character in this string is constrained to numeric values
** ranging from "0" to "9".
*/
typedef unsigned char GCCNumericCharacter;
typedef GCCNumericCharacter *GCCNumericString;


/*
** Typedef for a GCC Unicode string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, wide character strings.
*/
typedef unsigned short GCCUnicodeCharacter;
typedef GCCUnicodeCharacter FAR *GCCUnicodeString;


/*
** GCCConferenceName
** This structure defines the conference name.  In a create request, the
** conference name can include an optional unicode string but it must
** always include the simple numeric string.  In a join request, either
** one can be specified.
*/
typedef struct
{
    GCCNumericString numeric_string;
    GCCUnicodeString text_string;  /* optional */
} GCCConferenceName;


/*
** GCCConferenceID
** Locally allocated identifier of a created conference.  All subsequent
** references to the conference are made using the ConferenceID as a unique
** identifier. The ConferenceID shall be identical to the MCS domain
** selector used locally to identify the MCS domain associated with the
** conference.
*/
typedef unsigned long GCCConferenceID;


/*
** GCCPassword
** This is the unique password specified by the convenor of the
** conference that is used by the node controller to insure conference
** security. This is also a unicode string.
*/
typedef struct
{
    GCCNumericString numeric_string;
    GCCUnicodeString text_string;  /* optional */
} GCCPassword;


/*
** GCCTerminationMethod
** The termination method is used by GCC to determine
** what action to take when all participants of a conference have
** disconnected.  The conference can either be manually terminated
** by the node controller or it can terminate itself automatically when
** all the participants have left the conference.
*/
typedef enum
{
    GCC_AUTOMATIC_TERMINATION_METHOD = 0,
    GCC_MANUAL_TERMINATION_METHOD = 1
} GCCTerminationMethod;


/*
** ConferencePrivileges
** This structure defines the list of privileges that can be assigned to
** a particular conference.
*/
typedef struct
{
    T120Boolean terminate_is_allowed;
    T120Boolean eject_user_is_allowed;
    T120Boolean add_is_allowed;
    T120Boolean lock_unlock_is_allowed;
    T120Boolean transfer_is_allowed;
} GCCConferencePrivileges;


/*
** Typedef for a GCC octet string.  This typedef is used throughout GCC for
** storing variable length single byte character strings with embedded NULLs.
*/
typedef struct
{
    unsigned short octet_string_length;
    unsigned char FAR *octet_string;
} GCCOctetString;


/*
** Typedef for a GCC long string.  This typedef is used in GCC for
** storing variable length strings of longs with embedded NULLs.
*/
typedef struct
{
    unsigned short long_string_length;
    unsigned long FAR *long_string;
} GCCLongString;


/*
** The following enum structure typedefs are used to define the GCC Object Key.
** The GCC Object Key is used throughout GCC for things like the Application
** keys and Capability IDs.
*/
typedef enum
{
    GCC_OBJECT_KEY = 1,
    GCC_H221_NONSTANDARD_KEY = 2
} GCCObjectKeyType;

typedef struct
{
    GCCObjectKeyType key_type;
    union
    {
        GCCLongString object_id;
        GCCOctetString h221_non_standard_id;
    } u;
} GCCObjectKey;


/*
** GCCUserData
** This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
    GCCObjectKey key;
    GCCOctetString FAR UNALIGNED *octet_string;  /* optional */
} GCCUserData;


typedef enum
{
    GCC_STATUS_PACKET_RESOURCE_FAILURE   = 0,
    GCC_STATUS_PACKET_LENGTH_EXCEEDED    = 1,
    GCC_STATUS_CTL_SAP_RESOURCE_ERROR    = 2,
    GCC_STATUS_APP_SAP_RESOURCE_ERROR    = 3, /* parameter = Sap Handle */
    GCC_STATUS_CONF_RESOURCE_ERROR       = 4, /* parameter = Conference ID */
    GCC_STATUS_INCOMPATIBLE_PROTOCOL     = 5, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME = 6, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONVENER  = 7, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_LOCKED        = 8  /* parameter = Physical Handle */
} GCCStatusMessageType;


/*
** GCCReason
** When GCC issues an indication to a user application, it often includes a
** reason parameter informing the user of why the activity is occurring.
*/
typedef enum
{
    GCC_REASON_USER_INITIATED = 0,
    GCC_REASON_UNKNOWN = 1,
    GCC_REASON_NORMAL_TERMINATION = 2,
    GCC_REASON_TIMED_TERMINATION = 3,
    GCC_REASON_NO_MORE_PARTICIPANTS = 4,
    GCC_REASON_ERROR_TERMINATION = 5,
    GCC_REASON_ERROR_LOW_RESOURCES = 6,
    GCC_REASON_MCS_RESOURCE_FAILURE = 7,
    GCC_REASON_PARENT_DISCONNECTED = 8,
    GCC_REASON_CONDUCTOR_RELEASE = 9,
    GCC_REASON_SYSTEM_RELEASE = 10,
    GCC_REASON_NODE_EJECTED = 11,
    GCC_REASON_HIGHER_NODE_DISCONNECTED = 12,
    GCC_REASON_HIGHER_NODE_EJECTED = 13,
    GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE = 14,
    GCC_REASON_SERVER_INITIATED = 15,
    LAST_GCC_REASON = GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE
} GCCReason;


/*
** GCCResult
**  When a user makes a request of GCC, GCC often responds with a result,
**  letting the user know whether or not the request succeeded.
*/
typedef enum
{
    GCC_RESULT_SUCCESSFUL         = 0,
    GCC_RESULT_RESOURCES_UNAVAILABLE      = 1,
    GCC_RESULT_INVALID_CONFERENCE       = 2,
    GCC_RESULT_INVALID_PASSWORD        = 3,
    GCC_RESULT_INVALID_CONVENER_PASSWORD  = 4,
    GCC_RESULT_SYMMETRY_BROKEN        = 5,
    GCC_RESULT_UNSPECIFIED_FAILURE       = 6,
    GCC_RESULT_NOT_CONVENER_NODE       = 7,
    GCC_RESULT_REGISTRY_FULL        = 8,
    GCC_RESULT_INDEX_ALREADY_OWNED        = 9,
    GCC_RESULT_INCONSISTENT_TYPE        = 10,
    GCC_RESULT_NO_HANDLES_AVAILABLE       = 11,
    GCC_RESULT_CONNECT_PROVIDER_FAILED    = 12,
    GCC_RESULT_CONFERENCE_NOT_READY       = 13,
    GCC_RESULT_USER_REJECTED        = 14,
    GCC_RESULT_ENTRY_DOES_NOT_EXIST       = 15,
    GCC_RESULT_NOT_CONDUCTIBLE           = 16,
    GCC_RESULT_NOT_THE_CONDUCTOR       = 17,
    GCC_RESULT_NOT_IN_CONDUCTED_MODE      = 18,
    GCC_RESULT_IN_CONDUCTED_MODE       = 19,
    GCC_RESULT_ALREADY_CONDUCTOR       = 20,
    GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED  = 21,
    GCC_RESULT_INVALID_CHALLENGE_RESPONSE  = 22,
    GCC_RESULT_INVALID_REQUESTER    = 23,
    GCC_RESULT_ENTRY_ALREADY_EXISTS    = 24, 
    GCC_RESULT_INVALID_NODE      = 25,
    GCC_RESULT_INVALID_SESSION_KEY    = 26,
    GCC_RESULT_INVALID_CAPABILITY_ID   = 27,
    GCC_RESULT_INVALID_NUMBER_OF_HANDLES  = 28, 
    GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING  = 29,
    GCC_RESULT_INCOMPATIBLE_PROTOCOL   = 30,
    GCC_RESULT_CONFERENCE_ALREADY_LOCKED  = 31,
    GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED  = 32,
    GCC_RESULT_INVALID_NETWORK_TYPE    = 33,
    GCC_RESULT_INVALID_NETWORK_ADDRESS   = 34,
    GCC_RESULT_ADDED_NODE_BUSY     = 35,
    GCC_RESULT_NETWORK_BUSY      = 36,
    GCC_RESULT_NO_PORTS_AVAILABLE    = 37,
    GCC_RESULT_CONNECTION_UNSUCCESSFUL   = 38,
    GCC_RESULT_LOCKED_NOT_SUPPORTED       = 39,
    GCC_RESULT_UNLOCK_NOT_SUPPORTED    = 40,
    GCC_RESULT_ADD_NOT_SUPPORTED    = 41,
    GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE = 42,
    LAST_CGG_RESULT = GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE
} GCCResult;


/*
** GCCMessageType
**  This section defines the messages that can be sent to the application
**  through the callback facility.  These messages correspond to the
**  indications and confirms that are defined within T.124.
*/
typedef enum
{
    /******************* NODE CONTROLLER CALLBACKS ***********************/
 
    /* Conference Create, Terminate related calls */
    GCC_CREATE_INDICATION     = 0,
    GCC_CREATE_CONFIRM      = 1,
    GCC_QUERY_INDICATION     = 2,
    GCC_QUERY_CONFIRM      = 3,
    GCC_JOIN_INDICATION      = 4,
    GCC_JOIN_CONFIRM      = 5,
    GCC_INVITE_INDICATION     = 6,
    GCC_INVITE_CONFIRM      = 7,
    GCC_ADD_INDICATION      = 8,
    GCC_ADD_CONFIRM       = 9,
    GCC_LOCK_INDICATION      = 10,
    GCC_LOCK_CONFIRM      = 11,
    GCC_UNLOCK_INDICATION     = 12,
    GCC_UNLOCK_CONFIRM      = 13,
    GCC_LOCK_REPORT_INDICATION    = 14,
    GCC_DISCONNECT_INDICATION    = 15,
    GCC_DISCONNECT_CONFIRM     = 16,
    GCC_TERMINATE_INDICATION    = 17,
    GCC_TERMINATE_CONFIRM     = 18,
    GCC_EJECT_USER_INDICATION    = 19,
    GCC_EJECT_USER_CONFIRM     = 20,
    GCC_TRANSFER_INDICATION     = 21,
    GCC_TRANSFER_CONFIRM     = 22,
    GCC_APPLICATION_INVOKE_INDICATION  = 23,  /* SHARED CALLBACK */
    GCC_APPLICATION_INVOKE_CONFIRM   = 24,  /* SHARED CALLBACK */
    GCC_SUB_INITIALIZED_INDICATION   = 25,

    /* Conference Roster related callbacks */
    GCC_ANNOUNCE_PRESENCE_CONFIRM   = 26,
    GCC_ROSTER_REPORT_INDICATION   = 27,  /* SHARED CALLBACK */
    GCC_ROSTER_INQUIRE_CONFIRM    = 28,  /* SHARED CALLBACK */

    /* Conductorship related callbacks */
    GCC_CONDUCT_ASSIGN_INDICATION   = 29,  /* SHARED CALLBACK */
    GCC_CONDUCT_ASSIGN_CONFIRM    = 30,
    GCC_CONDUCT_RELEASE_INDICATION   = 31,  /* SHARED CALLBACK */
    GCC_CONDUCT_RELEASE_CONFIRM    = 32,
    GCC_CONDUCT_PLEASE_INDICATION   = 33,
    GCC_CONDUCT_PLEASE_CONFIRM    = 34,
    GCC_CONDUCT_GIVE_INDICATION    = 35,
    GCC_CONDUCT_GIVE_CONFIRM    = 36,
    GCC_CONDUCT_INQUIRE_CONFIRM    = 37,  /* SHARED CALLBACK */
    GCC_CONDUCT_ASK_INDICATION    = 38,
    GCC_CONDUCT_ASK_CONFIRM     = 39,
    GCC_CONDUCT_GRANT_INDICATION   = 40,  /* SHARED CALLBACK */
    GCC_CONDUCT_GRANT_CONFIRM    = 41,

    /* Miscellaneous Node Controller callbacks */
    GCC_TIME_REMAINING_INDICATION   = 42,
    GCC_TIME_REMAINING_CONFIRM    = 43,
    GCC_TIME_INQUIRE_INDICATION    = 44,
    GCC_TIME_INQUIRE_CONFIRM    = 45,
    GCC_CONFERENCE_EXTEND_INDICATION  = 46,
    GCC_CONFERENCE_EXTEND_CONFIRM   = 47,
    GCC_ASSISTANCE_INDICATION    = 48,
    GCC_ASSISTANCE_CONFIRM     = 49,
    GCC_TEXT_MESSAGE_INDICATION    = 50,
    GCC_TEXT_MESSAGE_CONFIRM    = 51,

    /***************** USER APPLICATION CALLBACKS *******************/

    /* Application Roster related callbacks */
    GCC_PERMIT_TO_ENROLL_INDICATION   = 52,
    GCC_ENROLL_CONFIRM      = 53,
    GCC_APP_ROSTER_REPORT_INDICATION  = 54,  /* SHARED CALLBACK */
    GCC_APP_ROSTER_INQUIRE_CONFIRM   = 55,  /* SHARED CALLBACK */

    /* Application Registry related callbacks */
    GCC_REGISTER_CHANNEL_CONFIRM   = 56,
    GCC_ASSIGN_TOKEN_CONFIRM    = 57,
    GCC_RETRIEVE_ENTRY_CONFIRM    = 58,
    GCC_DELETE_ENTRY_CONFIRM    = 59,
    GCC_SET_PARAMETER_CONFIRM    = 60,
    GCC_MONITOR_INDICATION     = 61,
    GCC_MONITOR_CONFIRM      = 62,
    GCC_ALLOCATE_HANDLE_CONFIRM    = 63,


    /****************** NON-Standard Primitives **********************/
    GCC_PERMIT_TO_ANNOUNCE_PRESENCE = 100,  /* Node Controller Callback */
    GCC_CONNECTION_BROKEN_INDICATION = 101,  /* Node Controller Callback */
    GCC_FATAL_ERROR_SAP_REMOVED = 102,  /* Application Callback */
    GCC_STATUS_INDICATION = 103,  /* Node Controller Callback */
    GCC_TRANSPORT_STATUS_INDICATION = 104  /* Node Controller Callback */
} GCCMessageType;


/*
 * These structures are used to hold the information included for the
 * various callback messages.  In the case where these structures are used for
 * callbacks, the address of the structure is passed as the only parameter.
 */

/*
 * GCC_CREATE_INDICATION
 *
 * Union Choice:
 * CreateIndicationMessage
 *   This is a pointer to a structure that contains all necessary
 *   information about the new conference that is about to be created.
 */
typedef struct
{
    GCCConferenceName conference_name;
    GCCConferenceID conference_id;
    GCCPassword FAR *convener_password;  /* optional */
    GCCPassword FAR *password;  /* optional */
    T120Boolean conference_is_locked;
    T120Boolean conference_is_listed;
    T120Boolean conference_is_conductible;
    GCCTerminationMethod termination_method;
    GCCConferencePrivileges FAR *conductor_privilege_list;   /* optional */
    GCCConferencePrivileges FAR *conducted_mode_privilege_list;/* optional */
    GCCConferencePrivileges FAR *non_conducted_privilege_list; /* optional */
    GCCUnicodeString conference_descriptor;  /* optional */
    GCCUnicodeString caller_identifier;  /* optional */
    TransportAddress calling_address;  /* optional */
    TransportAddress called_address;  /* optional */
    DomainParameters FAR *domain_parameters;  /* optional */
    unsigned short number_of_user_data_members;
    GCCUserData FAR * FAR *user_data_list;  /* optional */
    ConnectionHandle connection_handle;
    PhysicalHandle physical_handle;
} CreateIndicationMessage;


/*
 * GCC_DISCONNECT_INDICATION
 *
 * Union Choice:
 * DisconnectIndicationMessage
 */
typedef struct
{
    GCCConferenceID conference_id;
    GCCReason reason;
    UserID disconnected_node_id;
} DisconnectIndicationMessage;


/*
 * GCC_TERMINATE_INDICATION
 *
 * Union Choice:
 * TerminateIndicationMessage
 */
typedef struct
{
    GCCConferenceID conference_id;
    UserID requesting_node_id;
    GCCReason reason;
} TerminateIndicationMessage;


/*
 * GCCMessage
 * This structure defines the message that is passed from GCC to either
 * the node controller or a user application when an indication or
 * confirm occurs.
 */
typedef struct
{
    GCCMessageType message_type;
    void FAR *user_defined;

    union {
        CreateIndicationMessage create_indication;
        DisconnectIndicationMessage disconnect_indication;
        TerminateIndicationMessage terminate_indication;
    } u;
} GCCMessage;


/*
 * This is the definition for the GCC callback function. Applications
 * writing callback routines should NOT use the typedef to define their
 * functions.  These should be explicitly defined the way that the
 * typedef is defined.
 */

#define GCC_CALLBACK_NOT_PROCESSED 0
#define GCC_CALLBACK_PROCESSED 1

typedef T120Boolean (CALLBACK *GCCCallBack) (GCCMessage FAR *gcc_message);


/*
** Typedef for a GCC Character string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, single byte character strings.
*/
typedef unsigned char GCCCharacter;
typedef GCCCharacter FAR *GCCCharacterString;


/*
** Typdef for GCC version which is used when registering the node controller
** or an application.
*/
typedef struct
{
    unsigned short major_version;
    unsigned short minor_version;
} GCCVersion;


/*
** GCCNonStandardParameter
** This structure is used within the NetworkAddress typedef and
** the NetworkService typedef defined below.
*/
typedef struct
{
    GCCObjectKey object_key;
    GCCOctetString parameter_data;
} GCCNonStandardParameter;


/*
** GCCNetworkAddress
** The following block of structures defines the Network Address as defined
** by T.124.  Most of these structures were taken almost verbatim from the
** ASN.1 interface file.  Since I'm not really sure what most of this stuff
** is for I really didn't know how to simplify it.
*/
typedef struct
{
    T120Boolean         speech;
    T120Boolean         voice_band;
    T120Boolean         digital_56k;
    T120Boolean         digital_64k;
    T120Boolean         digital_128k;
    T120Boolean         digital_192k;
    T120Boolean         digital_256k;
    T120Boolean         digital_320k;
    T120Boolean         digital_384k;
    T120Boolean         digital_512k;
    T120Boolean         digital_768k;
    T120Boolean         digital_1152k;
    T120Boolean         digital_1472k;
    T120Boolean         digital_1536k;
    T120Boolean         digital_1920k;
    T120Boolean         packet_mode;
    T120Boolean         frame_mode;
    T120Boolean         atm;
} GCCTransferModes;

#define MAXIMUM_DIAL_STRING_LENGTH 17
typedef char GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct
{
    unsigned short length;
    unsigned short FAR *value;
} GCCExtraDialingString;

typedef struct
{
    T120Boolean         telephony3kHz;
    T120Boolean         telephony7kHz;
    T120Boolean         videotelephony;
    T120Boolean         videoconference;
    T120Boolean         audiographic;
    T120Boolean         audiovisual;
    T120Boolean         multimedia;
} GCCHighLayerCompatibility;

typedef struct
{
    GCCTransferModes transfer_modes;
    GCCDialingString international_number;
    GCCCharacterString sub_address_string;  /* optional */
    GCCExtraDialingString FAR *extra_dialing_string;  /* optional */
    GCCHighLayerCompatibility FAR *high_layer_compatibility; /* optional */
} GCCAggregatedChannelAddress;

#define MAXIMUM_NSAP_ADDRESS_SIZE 20
typedef struct
{
    struct
    {
        unsigned short  length;
        unsigned char   value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;

    GCCOctetString FAR *transport_selector;  /* optional */
} GCCTransportConnectionAddress;

typedef enum
{
    GCC_AGGREGATED_CHANNEL_ADDRESS = 1,
    GCC_TRANSPORT_CONNECTION_ADDRESS = 2,
    GCC_NONSTANDARD_NETWORK_ADDRESS = 3
} GCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    union
    {
        GCCAggregatedChannelAddress aggregated_channel_address;
        GCCTransportConnectionAddress transport_connection_address;
        GCCNonStandardParameter non_standard_network_address;
    } u;
} GCCNetworkAddress;


/*
 * This section defines the valid return values from GCC function calls.  Do
 * not confuse this return value with the Result and Reason values defined
 * by T.124 (which are discussed later).  These values are returned directly
 * from the call to the API entry point, letting you know whether or not the
 * request for service was successfully invoked.  The Result and Reason
 * codes are issued as part of an indication or confirm which occurs
 * asynchronously to the call that causes it.
 */
typedef enum
{
    GCC_NO_ERROR = 0,
    GCC_NOT_INITIALIZED = 1,
    GCC_ALREADY_INITIALIZED = 2,
    GCC_ALLOCATION_FAILURE = 3,
    GCC_NO_SUCH_APPLICATION = 4,
    GCC_INVALID_CONFERENCE = 5,
    GCC_CONFERENCE_ALREADY_EXISTS = 6,
    GCC_NO_TRANSPORT_STACKS = 7,
    GCC_INVALID_ADDRESS_PREFIX = 8,
    GCC_INVALID_TRANSPORT = 9,
    GCC_FAILURE_CREATING_PACKET = 10,
    GCC_QUERY_REQUEST_OUTSTANDING = 11,
    GCC_INVALID_QUERY_TAG = 12,
    GCC_FAILURE_CREATING_DOMAIN = 13,
    GCC_CONFERENCE_NOT_ESTABLISHED = 14,
    GCC_INVALID_PASSWORD = 15,
    GCC_INVALID_MCS_USER_ID = 16,
    GCC_INVALID_JOIN_RESPONSE_TAG = 17,
    GCC_TRANSPORT_ALREADY_LOADED = 18,
    GCC_TRANSPORT_BUSY = 19,
    GCC_TRANSPORT_NOT_READY = 20,
    GCC_DOMAIN_PARAMETERS_UNACCEPTABLE = 21,
    GCC_APP_NOT_ENROLLED = 22,
    GCC_NO_GIVE_RESPONSE_PENDING = 23,
    GCC_BAD_NETWORK_ADDRESS_TYPE = 24,
    GCC_BAD_OBJECT_KEY = 25,
    GCC_INVALID_CONFERENCE_NAME = 26,
    GCC_INVALID_CONFERENCE_MODIFIER = 27,
    GCC_BAD_SESSION_KEY = 28,
    GCC_BAD_CAPABILITY_ID = 29,
    GCC_BAD_REGISTRY_KEY = 30,
    GCC_BAD_NUMBER_OF_APES = 31,
    GCC_BAD_NUMBER_OF_HANDLES = 32,
    GCC_ALREADY_REGISTERED = 33,
    GCC_APPLICATION_NOT_REGISTERED = 34,
    GCC_BAD_CONNECTION_HANDLE_POINTER = 35,
    GCC_INVALID_NODE_TYPE = 36,
    GCC_INVALID_ASYMMETRY_INDICATOR = 37,
    GCC_INVALID_NODE_PROPERTIES = 38,
    GCC_BAD_USER_DATA = 39,
    GCC_BAD_NETWORK_ADDRESS = 40,
    GCC_INVALID_ADD_RESPONSE_TAG = 41,
    GCC_BAD_ADDING_NODE = 42,
    GCC_FAILURE_ATTACHING_TO_MCS = 43,
    GCC_INVALID_TRANSPORT_ADDRESS = 44,
    GCC_INVALID_PARAMETER = 45,
    GCC_COMMAND_NOT_SUPPORTED = 46,
    GCC_UNSUPPORTED_ERROR = 47,
    GCC_TRANSMIT_BUFFER_FULL = 48,
    GCC_INVALID_CHANNEL = 49,
    GCC_INVALID_MODIFICATION_RIGHTS = 50,
    GCC_INVALID_REGISTRY_ITEM = 51,
    GCC_INVALID_NODE_NAME = 52,
    GCC_INVALID_PARTICIPANT_NAME = 53,
    GCC_INVALID_SITE_INFORMATION = 54,
    GCC_INVALID_NON_COLLAPSED_CAP = 55,
    GCC_INVALID_ALTERNATIVE_NODE_ID = 56,
    LAST_GCC_ERROR = GCC_INVALID_ALTERNATIVE_NODE_ID
} GCCError, *PGCCError;


#if DBG

// Debug print levels

typedef enum
{
    DBNONE,
    DBERROR,
    DBWARN,
    DBNORMAL,
    DBDEBUG,
    DbDETAIL,
    DBFLOW,
    DBALL
} DBPRINTLEVEL;

#endif // Typedefs



//---------------------------------------------------------------------------
// Prototypes
//---------------------------------------------------------------------------

GCCError
APIENTRY
GCCRegisterNodeControllerApplication (
        GCCCallBack control_sap_callback,
        void FAR *user_defined,
        GCCVersion gcc_version_requested,
        unsigned short FAR *initialization_flags,
        unsigned long FAR *application_id,
        unsigned short FAR *capabilities_mask,
        GCCVersion FAR *gcc_high_version,
        GCCVersion FAR *gcc_version);


GCCError
APIENTRY
GCCCleanup(ULONG application_id);


GCCError
APIENTRY
GCCLoadTransport(
                char FAR *transport_identifier,
                char FAR *transport_file_name);

GCCError
APIENTRY 
GCCConferenceCreateResponse(
                GCCNumericString        conference_modifier,
                DomainHandle            hDomain,
                T120Boolean             use_password_in_the_clear,
                DomainParameters FAR *  domain_parameters,
                unsigned short          number_of_network_addresses,
                GCCNetworkAddress FAR * FAR *local_network_address_list,
                unsigned short          number_of_user_data_members,
                GCCUserData FAR * FAR * user_data_list,
                GCCResult               result);

GCCError
APIENTRY
GCCConferenceInit(
                HANDLE        hIca,
                HANDLE        hStack,
                PVOID         pvContext,
                DomainHandle  *phDomain);

GCCError
APIENTRY
GCCConferenceTerminateRequest(
                HANDLE           hIca,
                DomainHandle     hDomain,
                ConnectionHandle hConnection,
                GCCReason        reason);


#if DBG
EXTERN_C VOID   GCCSetPrintLevel(IN DBPRINTLEVEL DbPrintLevel);

#else
#define GCCSetPrintLevel(_x_)

#endif


#endif // _GCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tsremdsk.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    tsremdsk.h

Abstract:

    Prototype for Salem related encryption function

Author:

    HueiWang    4/26/2000

--*/
#ifndef __TSREMDSK_H__
#define __TSREMDSK_H__

//
// Delay time to start or shutdown Salem binaries when RA group 
// policy changed.
//
#define DELAY_STARTUP_SALEM_TIME        30 * 1000
#define DELAY_SHUTDOWN_SALEM_TIME       30 * 1000

#define SALEMHELPASSISTANTACCOUNT_PASSWORDKEY  \
    L"L$0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantAccount"

#define REG_CONTROL_REMDSK				        L"Software\\Microsoft\\Remote Desktop"
#define REG_CONTROL_HELPSESSIONENTRY            L"Pending Help Session"
#define REG_VALUE_SYSTEMRESTORE			        L"SystemRestore"
#define REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY	L"SystemRestore_KEY"
#define REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP	L"SystemRestore_AllowToGetHelp"
#define REG_VALUE_SYSTEMRESTORE_INHELPMODE	    L"SystemRestore" L"_" REG_MACHINE_IN_HELP_MODE

#define SALEMHELPASSISTANTACCOUNT_SIDKEY \
    L"L$0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantSID"

#define SALEMHELPASSISTANTACCOUNT_NAME \
    L"HelpAssistant"

#define SALEMRDSADDINNAME \
    L"%WINDIR%\\SYSTEM32\\RDSADDIN.EXE"

#define SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY \
    L"L$c261dd33-c55b-4a37-924b-746bbf3569ad-RemoteDesktopHelpAssistantEncrypt"

#define SALEMHELPASSISTANTACCOUNT_ENCRYPTMUTEX \
    L"746bbf3569adEncrypt"


#define HELPASSISTANT_CRYPT_CONTAINER   L"HelpAssisantContainer"
#define ENCRYPT_ALGORITHM               CALG_RC4 
#define ENCRYPT_BLOCK_SIZE              8 

#define TERMSRV_TCPPORT                 3389

//
// Event Log ID, TermSrv and Rdshost at various inform
// sessmgr to log an event, this event log is re-mapping
// to actual event code in sessmgr.
// 
#define REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET    0x1
#define REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT   0x2

#ifdef __cplusplus
extern "C"{
#endif

DWORD
TSHelpAssistantBeginEncryptionCycle();

DWORD
TSHelpAssisantEndEncryptionCycle();

BOOL
TSHelpAssistantInEncryptionCycle();

VOID
TSHelpAssistantEndEncryptionLib();

DWORD
TSHelpAssistantInitializeEncryptionLib();

DWORD
TSHelpAssistantEncryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
);

DWORD
TSHelpAssistantDecryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
);

DWORD
TSGetHelpAssistantAccountName(
    OUT LPWSTR* ppszAccDomain,
    OUT LPWSTR* ppszAcctName
);    

DWORD
TSGetHelpAssistantAccountPassword(
    OUT LPWSTR* ppszAcctPwd
);

BOOL
TSIsMachineInHelpMode();

BOOL
TSIsMachinePolicyAllowHelp();

BOOL
TSIsMachineInSystemRestore();

DWORD
TSSystemRestoreCacheValues();

DWORD
TSSystemRestoreResetValues();

BOOL 
TSIsFireWallPortsOpen();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tsutilnt.h ===
/*
 *  TSUtil.h
 *
 *  General purpose utilities library. The entry points listed in this header
 *  conform to the NT API style.
 */

#ifndef __TERMSRV_INC_TSUTILNT_H__
#define __TERMSRV_INC_TSUTILNT_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  ACL Utilities
 */

#ifdef _NTSEAPI_

NTSTATUS NTAPI
NtConvertAbsoluteToSelfRelative(
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    IN PSECURITY_DESCRIPTOR pAbsoluteSd,
    IN PULONG pcbSelfRelativeSd OPTIONAL
    );

NTSTATUS NTAPI
NtConvertSelfRelativeToAbsolute(
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd
    );

NTSTATUS NTAPI
NtDestroySecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd
    );

NTSTATUS NTAPI
NtIsSecurityDescriptorAbsolute(
    IN PSECURITY_DESCRIPTOR pSd,
    OUT PBOOLEAN pfAbsolute
    );

#endif

/*
 *  String Utilities
 */

NTSTATUS NTAPI
NtAllocateAndCopyStringA(
    PSTR *ppDestination,
    PCSTR pString
    );

NTSTATUS NTAPI
NtAllocateAndCopyStringW(
    PWSTR *ppDestination,
    PCWSTR pString
    );

NTSTATUS NTAPI
NtConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    );

NTSTATUS NTAPI
NtConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    );

/*
 *  User Utilities
 */

#ifdef _NTSEAPI_

NTSTATUS NTAPI
NtCreateAdminSid(
    OUT PSID *ppAdminSid
    );

NTSTATUS NTAPI
NtCreateSystemSid(
    OUT PSID *ppSystemSid
    );

NTSTATUS NTAPI
NtCreateAnonymousSid(
    PSID *ppAnonymousSid
    );

#endif

/*
 *  LSA Utilities
 */

#ifdef _NTLSA_

VOID NTAPI
InitLsaString(
    IN PLSA_UNICODE_STRING pLsaString,
    IN PCWSTR pString
    );

#endif

/*
 *  Miscellaneous Utilities
 */

#ifndef __TERMSRV_INC_TSUTIL_H__
#define GetCurrentConsoleId() (USER_SHARED_DATA->ActiveConsoleId)
#define GetCurrentLogonId() (NtCurrentPeb()->LogonId)
#endif

#ifdef __cplusplus
}
#endif

#endif // __TERMSRV_INC_TSUTILNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tsrvexp.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvExp.h
//
//  Contents:   TShareSRV public export include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    7-JUL-97    BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVEXP_H_
#define _TSRVEXP_H_

#include <t120.h>
#include <at128.h>
#include <license.h>
#include <tssec.h>
#include <at120ex.h>

/****************************************************************************/
/* Defines                                                                  */
/****************************************************************************/

#define NET_MAX_SIZE_SEND_PKT           32000

/****************************************************************************/
/* IOCTL definitions                                                        */
/****************************************************************************/

#define IOCTL_TSHARE_CONF_CONNECT       _ICA_CTL_CODE(0x900, METHOD_NEITHER)
#define IOCTL_TSHARE_CONF_DISCONNECT    _ICA_CTL_CODE(0x901, METHOD_NEITHER)
#define IOCTL_TSHARE_USER_LOGON         _ICA_CTL_CODE(0x903, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_SEC_DATA       _ICA_CTL_CODE(0x904, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_SEC_DATA       _ICA_CTL_CODE(0x905, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_NO_ENCRYPT     _ICA_CTL_CODE(0x906, METHOD_NEITHER)
#define IOCTL_TSHARE_QUERY_CHANNELS     _ICA_CTL_CODE(0x907, METHOD_NEITHER)
#define IOCTL_TSHARE_CONSOLE_CONNECT    _ICA_CTL_CODE(0x908, METHOD_NEITHER)

#define IOCTL_TSHARE_SEND_CERT_DATA     _ICA_CTL_CODE(0x909, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_CERT_DATA      _ICA_CTL_CODE(0x90A, METHOD_NEITHER)
#define IOCTL_TSHARE_SEND_CLIENT_RANDOM _ICA_CTL_CODE(0x90B, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_CLIENT_RANDOM  _ICA_CTL_CODE(0x90C, METHOD_NEITHER)
#define IOCTL_TSHARE_SHADOW_CONNECT     _ICA_CTL_CODE(0x90D, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_ERROR_INFO     _ICA_CTL_CODE(0x90E, METHOD_NEITHER)
#define IOCTL_TSHARE_SEND_ARC_STATUS    _ICA_CTL_CODE(0x90F, METHOD_NEITHER)

//***************************************************************************
// Typedefs
//***************************************************************************

//***************************************************************************
// User data info
//***************************************************************************

typedef struct _USERDATAINFO
{
    ULONG           cbSize;                 // Structure size (incl data)

    TSUINT32        version;                // The client version
    HANDLE          hDomain;                // Domain handle
    ULONG           ulUserDataMembers;      // Number of UserData members
    GCCUserData     rgUserData[1];          // User data

} USERDATAINFO, *PUSERDATAINFO;


//***************************************************************************
// Logon Info
//***************************************************************************

typedef struct _LOGONINFO
{
#define LI_USE_AUTORECONNECT    0x0001
    TSUINT32        Flags;
    TSUINT8         Domain[TS_MAX_DOMAIN_LENGTH];
    TSUINT8         UserName[TS_MAX_USERNAME_LENGTH];
    TSUINT32        SessionId;
} LOGONINFO, *PLOGONINFO;

//***************************************************************************
// Security Info used with the IOCTL_TSHARE_SET_SEC_DATA ioctl
//***************************************************************************

typedef struct _SECINFO
{
    CERT_TYPE           CertType;   // certificate type that was transmitted to the client
    RANDOM_KEYS_PAIR    KeyPair;    // generated key pair

} SECINFO, *PSECINFO;

typedef struct _SHADOWCERT
{
    ULONG pad1;             // This needs to be sizeof(RNS_UD_HEADER)
    ULONG encryptionMethod;
    ULONG encryptionLevel;
    ULONG shadowRandomLen;
    ULONG shadowCertLen;

    // shadow random and certificate follow
    BYTE  data[1];
} SHADOWCERT, *PSHADOWCERT;

typedef struct _CLIENTRANDOM
{
    ULONG clientRandomLen;

    // client random follows
    BYTE  data[1];
} CLIENTRANDOM, *PCLIENTRANDOM;

typedef struct _SECURITYTIMEOUT
{
    LONG ulTimeout;
} SECURITYTIMEOUT, *PSECURITYTIMEOUT;

// Winstation Driver data for shadowing.  This information is passed to the
// shadow stack's WD.  Include all data required to validate the shadow request
// such that the shadow can be rejected at this point if required.
//
typedef struct tagTSHARE_MODULE_DATA {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V0 clientCoreData;
    RNS_UD_CS_SEC_V0  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;

    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
    
    // Although we repeat some fields below, we have to keep the previous
    // junk around for backwards compatibility with B3.  The only new data
    // added to this structure should be in the form of GCC user data so we
    // don't get alignment issues in the future
    UINT32        ulVersion;
    UINT32        reserved[8]; // for future extension

    // Start of pre-parsed variable user data
    ULONG         userDataLen;
    RNS_UD_HEADER userData;
} TSHARE_MODULE_DATA, *PTSHARE_MODULE_DATA;


// Winstation Driver data for shadowing at Win2000 B3
typedef struct tagTSHARE_MODULE_DATA_B3 {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V0 clientCoreData;
    RNS_UD_CS_SEC_V0  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;
    
    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
} TSHARE_MODULE_DATA_B3, *PTSHARE_MODULE_DATA_B3;


// Winstation Driver data for shadowing at Win2000 B3 + Ooops!
typedef struct tagTSHARE_MODULE_DATA_B3_OOPS {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V1 clientCoreData;
    RNS_UD_CS_SEC_V1  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;
    
    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
} TSHARE_MODULE_DATA_B3_OOPS, *PTSHARE_MODULE_DATA_B3_OOPS;


#endif // _TSRVEXP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tsgdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.h
*
* Abstract:
*
*   GDI+ Enumeration Types
*
\**************************************************************************/

#define GDIPLUS_TS_QUERYVER 4122
#define GDIPLUS_TS_RECORD 4123

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,
    ObjectTypeGraphics,

    ObjectTypeMax = ObjectTypeGraphics,
    ObjectTypeMin = ObjectTypeBrush
};

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

enum EmfPlusRecordType;

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects

    EmfPlusRecordTypeObject,

    // Drawing Records

    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records

    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,

    EmfPlusRecordTypeStrokeFillPath,
    EmfPlusRecordTypeSerializableObject,
    EmfPlusRecordTypeSetTSGraphics,              // For private use by TS
    EmfPlusRecordTypeSetTSClip,                  // For private use by TS

    // NOTE: New records *must* be added immediately before this line.

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tssec.h ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    tssec.h

Abstract:

    contains data definitions required for tshare data encryption.

Author:

    Madan Appiah (madana)  30-Dec-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _TSSEC_H_
#define _TSSEC_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef OS_WIN16

#define RSA32API

typedef unsigned long       ULONG;
typedef ULONG FAR*          LPULONG;

#define UNALIGNED

#endif // OS_WIN16


#include <rc4.h>

#define RANDOM_KEY_LENGTH           32  // size of a client/server random key
#define MAX_SESSION_KEY_SIZE        16  // max size of a session key
#define PRE_MASTER_SECRET_LEN       48  // size of a pre-master key
#define SEC_MAX_USERNAME            256 // size of username

#define MAX_SIGNKEY_SIZE            20  // maximum size of a signing key
#define MAX_FIPS_SESSION_KEY_SIZE   24  // maximum size of a session key
#define	MAX_SIGN_SIZE               8  // maximum size of signed data
#define DES3_KEYLEN                 21  // size of 3des key
#define FIPS_BLOCK_LEN              8   // block size for FIPS 

#define CLIENT_RANDOM_MAX_SIZE      512


#define UPDATE_SESSION_KEY_COUNT    (1024 * 4)
    // update session key after this many encryptions.

#define DATA_SIGNATURE_SIZE         8
    // size of the data signature that sent accross.

/****************************************************************************/
/* Encryption levels - bit field.                                           */
/****************************************************************************/
#define SM_40BIT_ENCRYPTION_FLAG        0x01
#define SM_128BIT_ENCRYPTION_FLAG       0x02
#define SM_56BIT_ENCRYPTION_FLAG        0x08
#define SM_FIPS_ENCRYPTION_FLAG         0x10


typedef struct _RANDOM_KEYS_PAIR {
    BYTE clientRandom[RANDOM_KEY_LENGTH];
    BYTE serverRandom[RANDOM_KEY_LENGTH];
} RANDOM_KEYS_PAIR, FAR *LPRANDOM_KEYS_PAIR;

typedef enum _CryptMethod {
    Encrypt,
    Decrypt
} CryptMethod;

//
// Autoreconnection specific security structures
// These are defined here because they are not necessarily RDP
// specific. Although the PDU's wrapping these packets will
// be protocol specific.
//

// Server to client ARC packet
#define ARC_SC_SECURITY_TOKEN_LEN 16
typedef struct _ARC_SC_PRIVATE_PACKET {
    ULONG cbLen;
    ULONG Version;
    ULONG LogonId;
    BYTE  ArcRandomBits[ARC_SC_SECURITY_TOKEN_LEN];
} ARC_SC_PRIVATE_PACKET, *PARC_SC_PRIVATE_PACKET;

#define ARC_CS_SECURITY_TOKEN_LEN 16
typedef struct _ARC_CS_PRIVATE_PACKET {
    ULONG cbLen;
    ULONG Version;
    ULONG LogonId;
    BYTE  SecurityVerifier[ARC_CS_SECURITY_TOKEN_LEN];
} ARC_CS_PRIVATE_PACKET, *PARC_CS_PRIVATE_PACKET;



BOOL
MakeSessionKeys(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbEncryptKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    LPBYTE pbDecryptKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    LPBYTE pbMACSaltKey,
    DWORD dwKeyStrength,
    LPDWORD pdwKeyLength,
    DWORD dwEncryptionLevel
    );

BOOL
UpdateSessionKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyStrength,
    DWORD dwKeyLength,
    struct RC4_KEYSTRUCT FAR *prc4Key,
    DWORD dwEncryptionLevel
    );

BOOL
EncryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fCheckSumEncryptedData,
    DWORD  dwEncryptionCount
    );

BOOL
DecryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fCheckSumCipherText,
    DWORD  dwDecryptionCount
    );

//
// RNG init/term functions for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//
VOID
TSRNG_Initialize(
    );
VOID
TSRNG_Shutdown(
    );

//
// RNG bit gathering function i.e all the work happens here
//
// Params:
//  pbRandomKey - where to place the random bits
//  dwRandomKeyLen - size in bytes of pbRandomKey
//
// Returns
//  Success flag
//
BOOL
TSRNG_GenerateRandomBits(
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen
    );

#ifndef NO_INCLUDE_LICENSING
BOOL
GetServerCert(
    LPBYTE FAR *ppServerCertBlob,
    LPDWORD pdwServerCertLen
    );

BOOL
UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert
    );

BOOL
ValidateServerCert(
    PHydra_Server_Cert pServerCert
    );

#endif // NO_INCLUDE_LICENSING

BOOL
EncryptClientRandom(
    LPBYTE pbSrvPublicKey,
    DWORD dwSrvPublicKey,
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen,
    LPBYTE pbEncRandomKey,
    LPDWORD pdwEncRandomKey
    );

BOOL
DecryptClientRandom(
    LPBYTE pbEncRandomKey,
    DWORD dwEncRandomKeyLen,
    LPBYTE pbRandomKey,
    LPDWORD pdwRandomKeyLen
    );

BOOL EncryptDecryptLocalData(
    LPBYTE pbData,
    DWORD dwDataLen
    );

BOOL EncryptDecryptLocalData50(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbSalt,
    DWORD dwSaltLen
    );

BOOL
TSCAPI_GenerateRandomBits(
    LPBYTE pbRandomBits,
    DWORD cbLen
    );


//
// remove (or comment) the following definition to disable the MSRC4.
//

// #define USE_MSRC4

#ifdef USE_MSRC4

VOID
msrc4_key(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbKey);

VOID
msrc4(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbuf);

#else // USE_MSRC4

#define msrc4_key   rc4_key
#define msrc4       rc4

#endif // USE_MSRC4

BOOL
FindIsFrenchSystem(
    VOID
    );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // _TSSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgcfnc.h ===
/**INC+**********************************************************************/
/* Header:    wdcgcfnc.h                                                    */
/*                                                                          */
/* Purpose:   C runtime functions - Windows specific header                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgcfnc.h_v  $
 *
 *    Rev 1.6   22 Aug 1997 15:10:48   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.5   06 Aug 1997 14:33:10   AK
 * SFR1016: Apply Markups
 *
 *    Rev 1.4   06 Aug 1997 10:41:14   AK
 * SFR1016: Complete removal of DCCHAR etc
 *
 *    Rev 1.3   15 Jul 1997 15:41:48   AK
 * SFR1016: Add Unicode support
 *
 *    Rev 1.2   09 Jul 1997 17:12:02   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.1   19 Jun 1997 14:26:36   ENH
 * Win16Port: Make compatible with 16 bit build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGCFNC
#define _H_WDCGCFNC

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Huge memory functions (based on those from windows.h)                    */
/* =====================                                                    */
/* In these definitions:                                                    */
/*    'S' and 'T' are of type HPDCVOID.                                     */
/*    'CS' and 'CT' are of type (constant) HPDCVOID.                        */
/*    'N' is of type DCINT32.                                               */
/****************************************************************************/
/****************************************************************************/
/* This function returns a PDCVOID (WIN32) or DCVOID (WIN16).               */
/****************************************************************************/
#define DC_HMEMCPY(S, CT, N)           hmemcpy(S, CT, N)

#ifdef OS_WIN16
#include <ddcgcfnc.h>
#else
#include <ndcgcfnc.h>
#endif

/****************************************************************************/
/* String handling functions                                                */
/****************************************************************************/
#define DC_ASTRLEN(S)                   strlen(S)
#define DC_WSTRLEN(S)                   wcslen(S)
#define DC_TSTRLEN(S)                   _tcslen(S)

#define DC_ASTRCPY(S, T)                strcpy(S, T)
#define DC_WSTRCPY(S, T)                wcscpy(S, T)
#define DC_TSTRCPY(S, T)                _tcscpy(S, T)

#define DC_ASTRNCPY(S, CT, N)           strncpy(S, CT, N)
#define DC_WSTRNCPY(S, CT, N)           wcsncpy(S, CT, N)
#define DC_TSTRNCPY(S, CT, N)           _tcsncpy(S, CT, N)

#define DC_ASTRCAT(S, T)                strcat(S, T)
#define DC_WSTRCAT(S, T)                wcscat(S, T)
#define DC_TSTRCAT(S, T)                _tcscat(S, T)

#define DC_ASTRCMP(S, T)                strcmp(S, T)
#define DC_WSTRCMP(S, T)                wcscmp(S, T)
#define DC_TSTRCMP(S, T)                _tcscmp(S, T)

#define DC_ASPRINTF                     sprintf
#define DC_WSPRINTF                     swprintf
#define DC_TSPRINTF                     _stprintf
#define DC_TNSPRINTF                    _sntprintf

#define DC_ASTRCHR(S, C)                strchr(S, C)
#define DC_WSTRCHR(S, C)                wcschr(S, C)
#define DC_TSTRCHR(S, C)                _tcschr(S, C)

#define DC_ASTRTOK(S, T)                strtok(S, T)
#define DC_WSTRTOK(S, T)                wcstok(S, T)
#define DC_TSTRTOK(S, T)                _tcstok(S, T)

#define DC_ASTRICMP(S, T)               _stricmp(S, T)
#define DC_WSTRICMP(S, T)               wcsicmp(S, T)
#define DC_TSTRICMP(S, T)               _tcsicmp(S, T)

#define DC_ASTRNCMP(S, T, N)            strncmp(S, T, N)
#define DC_WSTRNCMP(S, T, N)            wcsncmp(S, T, N)
#define DC_TSTRNCMP(S, T, N)            _tcsncmp(S, T, N)

#define DC_ASTRNICMP(S, T, N)           _strnicmp(S, T, N)

#define DC_ASSCANF                      sscanf
#define DC_WSSCANF                      swscanf
#define DC_TSSCANF                      _stscanf

#define DC_ACSLWR                       _strlwr
#define DC_TCSLWR                       _tcslwr

/****************************************************************************/
/* Space required to hold null-terminated string.                           */
/****************************************************************************/
#define DC_ASTRBYTELEN(S)   (DC_ASTRLEN(S) + 1)
#define DC_WSTRBYTELEN(S)   ((DC_WSTRLEN(S) + 1) * sizeof(DCWCHAR))
#define DC_TSTRBYTELEN(S)   ((DC_TSTRLEN(S) + 1) * sizeof(DCTCHAR))

/****************************************************************************/
/* ATOI and ITOA functions                                                  */
/****************************************************************************/
#define DC_ULTOA(N, S, M)               _ultoa(N, S, M)
#define DC_ITOA(N, S, M)                _itoa(N, S, M)
#define DC_ITOW(N, S, M)                _itow(N, S, M)
#define DC_ITOT(N, S, M)                _itot(N, S, M)

#define DC_ASTRTOUL(CS, ENDPTR, BASE)   strtoul(CS, ENDPTR, BASE)
#define DC_ATOI(CS)                     atoi(CS)
#define DC_WTOI(CS)                     _wtoi(CS)
#define DC_TTOI(CS)                     _ttoi(CS)

#endif /* _H_WDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgbtyp.h ===
/**INC+**********************************************************************/
/* Header:    wdcgbtyp.h                                                    */
/*                                                                          */
/* Purpose:   Basic types - Windows specific header                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgbtyp.h_v  $
 *
 *    Rev 1.4   04 Aug 1997 14:58:38   KH
 * SFR1022: Move DCCALLBACK from n/ddcgbtyp
 *
 *    Rev 1.3   23 Jul 1997 10:48:04   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.2   09 Jul 1997 17:11:24   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.1   19 Jun 1997 14:22:20   ENH
 * Win16Port: Make compatible with 16 bit build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGBTYP
#define _H_WDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgbtyp.h                                                 */
/* Windows NT  : ndcgbtyp.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgbtyp.h>
#elif defined( OS_WIN32 )
#include <ndcgbtyp.h>
#endif

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Support ASCII (A), Wide (W) = Unicode, and Mixed (T) character sets.     */
/****************************************************************************/
typedef char                           DCACHAR;
typedef wchar_t                        DCWCHAR;
typedef TCHAR                          DCTCHAR;

typedef DCACHAR              DCPTR     PDCACHAR;
typedef DCWCHAR              DCPTR     PDCWCHAR;
typedef DCTCHAR              DCPTR     PDCTCHAR;

typedef PDCACHAR             DCPTR     PPDCACHAR;
typedef PDCWCHAR             DCPTR     PPDCWCHAR;
typedef PDCTCHAR             DCPTR     PPDCTCHAR;

/****************************************************************************/
/* Basic types abstracted from compiler built ins.                          */
/****************************************************************************/
typedef short                          DCINT16;
typedef unsigned short                 DCUINT16;

/****************************************************************************/
/* Define function calling conventions.                                     */
/****************************************************************************/
#define DCCALLBACK         CALLBACK

/****************************************************************************/
/* Windows specific definitions.                                            */
/****************************************************************************/
typedef HRGN                           DCREGIONID;
typedef HINSTANCE                      DCINSTANCE;

#endif /* _H_WDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\tsutil.h ===
/*
 *  TSUtil.h
 *
 *  General purpose utilities library. The entry points listed in this header
 *  conform to the Win32 API style.
 */

#ifndef __TERMSRV_INC_TSUTIL_H__
#define __TERMSRV_INC_TSUTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Terminal Services Utilities
 */

BOOL WINAPI
IsFullTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsPersonalTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsPersonalWorkstation(
    VOID
);

BOOL WINAPI
IsAdvancedServer(
    VOID
);

/*
 *  ACL Utilities
 */

#if defined(__ACCESS_CONTROL__) && (defined(_WINNT_) || defined(_NTDEF_))

BOOL WINAPI
AddSidToObjectsSecurityDescriptor(
    IN HANDLE hObject,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSID pSid,
    IN DWORD dwNewAccess,
    IN ACCESS_MODE AccessMode,
    IN DWORD dwInheritance
    );

BOOL WINAPI
AddSidToSecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd,
    IN PSID pSid,
    IN DWORD dwNewAccess,
    IN ACCESS_MODE AccessMode,
    IN DWORD dwInheritance
    );

BOOL WINAPI
ConvertAbsoluteToSelfRelative(
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    IN PSECURITY_DESCRIPTOR pAbsoluteSd,
    IN PDWORD pcbSelfRelativeSd OPTIONAL
    );

BOOL WINAPI
ConvertSelfRelativeToAbsolute(
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd
    );

BOOL WINAPI
DestroySecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd
    );

BOOL WINAPI
IsSecurityDescriptorAbsolute(
    IN PSECURITY_DESCRIPTOR pSd
    );

#endif

/*
 *  String Utilities
 */

PSTR WINAPI
AllocateAndCopyStringA(
    IN PCSTR pString
    );

PWSTR WINAPI
AllocateAndCopyStringW(
    IN PCWSTR pString
    );

BOOL WINAPI
ConvertAnsiToUnicode(
    OUT PWSTR *ppUnicodeString,
    IN PCSTR pAnsiString
    );

BOOL WINAPI
ConvertUnicodeToAnsi(
    OUT PSTR *ppAnsiString,
    IN PCWSTR pUnicodeString
    );

/*
 *  User Utilities
 */

#ifdef _WINNT_

BOOL WINAPI
CreateAdminSid(
    OUT PSID *ppAdminSid
    );

BOOL WINAPI
CreateSystemSid(
    OUT PSID *ppSystemSid
    );

BOOL WINAPI
IsUserMember(
    IN PSID pSid
    );

#endif

/*
 *  Miscellaneous Utilities
 */

#ifndef __TERMSRV_INC_TSUTILNT_H__
#define GetCurrentConsoleId() (USER_SHARED_DATA->ActiveConsoleId)
#define GetCurrentLogonId() (NtCurrentPeb()->LogonId)
#endif

BOOL WINAPI
LoadStringResourceW(
    IN HMODULE hModule,
    IN UINT uiResourceId,
    OUT PWSTR *ppString,
    OUT PDWORD pcchString OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // __TERMSRV_INC_TSUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgcnst.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - Windows NT specific header.              */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/* $Log:   Y:/logs/h/dcl/wdcgcnst.h_v  $                                                                    */
//
//    Rev 1.1   19 Jun 1997 14:29:30   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGCNST
#define _H_WDCGCNST



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Mutex and shared memory object names.                                    */
/****************************************************************************/
#define TRC_MUTEX_NAME                 _T("TRCMutex")
#define TRC_SHARED_DATA_NAME           _T("TRCSharedDataName")
#define TRC_TRACE_FILE_NAME            _T("TRCTraceFileName")

/****************************************************************************/
/* Registry prefix.                                                         */
/****************************************************************************/
#define DC_REG_PREFIX             _T("SOFTWARE\\Microsoft\\Conferencing\\DCG\\")

/****************************************************************************/
/* ULS registry entry - for Microsoft's User Location Service               */
/****************************************************************************/
#define REGKEY_ULS_USERDETAILS  \
                      "Software\\Microsoft\\User Location Service\\Client"

#define REGVAL_ULS_NAME  "User Name"

/****************************************************************************/
/* Location of comupter name in registry (used by TDD)                      */
/****************************************************************************/
#define REGVAL_COMPUTERNAME "ComputerName"
#define REGKEY_COMPUTERNAME \
              "System\\CurrentControlSet\\control\\ComputerName\\ComputerName"

/****************************************************************************/
/* Registry keys for Modem TDD.                                             */
/****************************************************************************/
#define REGKEY_CONF         "SOFTWARE\\Microsoft\\Conferencing"
#define REGVAL_USE_R11      "R11 Compatibility"
#define REGVAL_AUTO_ANSWER  "AutoAnswer"
#define REGVAL_N_RINGS      "nPickupRings"

#define REGKEY_PSTN      "SOFTWARE\\Microsoft\\Conferencing\\Transports\\PSTN"
#define REGVAL_PROVNAME  "Provider Name"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_SYSBITMAP                 NULL

/****************************************************************************/
/* Performance monitoring file and application names                        */
/****************************************************************************/
#define PERF_APP_NAME "DCG"
#define DCG_PERF_INI_FILE "nprfini.ini"
#define DCG_PERF_HDR_FILE "nprfincl.h"

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN32
#include <ndcgcnst.h>
#endif

#endif /* _H_WDCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgperf.h ===
/**INC+**********************************************************************/
/* Header:    wdcgperf.h                                                    */
/*                                                                          */
/* Purpose:   Performance Monitoring - portable include file                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgperf.h_v  $
 *
 *    Rev 1.1   15 Jul 1997 15:31:34   MD
 * SFR1029: Create performance build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGPERF
#define _H_WDCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgperf.h                                                 */
/* Windows NT  : ndcgperf.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgperf.h>
#elif defined( OS_WIN32 )
#include <ndcgperf.h>
#endif

#endif /* _H_WDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgmcro.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows specific header.                    */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wdcgmcro.h_v  $                                                                   */
// 
//    Rev 1.2   17 Jul 1997 18:23:06   JPB
// SFR1031: Fixed FIELDSIZE macro for Win16
//
//    Rev 1.1   19 Jun 1997 14:40:00   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGMCRO
#define _H_WDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Byte swapping macros for different endian architectures.                 */
/****************************************************************************/
#define DCWIRETONATIVE16(A)
#define DCWIRETONATIVE32(A)
#define DCNATIVETOWIRE16(A)
#define DCNATIVETOWIRE32(A)

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard app ID and an OS-specific  */
/* task/process handle.                                                     */
/****************************************************************************/
#define CO_TO_DCAPPID(htask)    ((DCAPPID)(htask))
#define CO_FROM_DCAPPID(appid)  ((DWORD)(appid))

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard handles and OS-specific    */
/* handles.                                                                 */
/****************************************************************************/
#define CO_TO_DCWINID(hwnd)            ((DCWINID)(hwnd))
#define CO_TO_DCINSTANCE(hinst)        ((DCINSTANCE)(hinst))
#define CO_TO_DCREGIONID(region)       ((DCREGIONID)(region))
#define CO_TO_DCSURFACEID(surface)     ((DCSURFACEID)(surface))
#define CO_TO_DCPALID(palette)         ((DCPALID)(palette))

#define CO_FROM_DCWINID(winid)         ((HWND)(winid))
#define CO_FROM_DCINSTANCE(instance)   ((HINSTANCE)(instance))
#define CO_FROM_DCREGIONID(dcregion)   ((HRGN)(dcregion))
#define CO_FROM_DCSURFACEID(dcsurface) ((HDC)(dcsurface))
#define CO_FROM_DCPALID(dcpalid)       ((HPALETTE)(dcpalid))

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard cursor ID and an           */
/* OS-specific cursor handle.                                               */
/****************************************************************************/
#define CO_TO_DCCURSORID(hcursor)      ((DCCURSORID)((DCUINT32)(hcursor)))
#define CO_FROM_DCCURSORID(cursorid)   ((HCURSOR)((DCUINT32)(cursorid)))

/****************************************************************************/
/* Macro to return the current tick count.                                  */
/****************************************************************************/
#define CO_GET_TICK_COUNT() GetTickCount()

/****************************************************************************/
/* Macros to Post / Send messages                                           */
/****************************************************************************/
#define CO_POST_MSG(a,b,c,d) \
            PostMessage(CO_FROM_DCWINID(a),(b),(WPARAM)(c),(LPARAM)(d))
#define CO_SEND_MSG(a,b,c,d) \
            SendMessage(CO_FROM_DCWINID(a),(b),(WPARAM)(c),(LPARAM)(d))
#define CO_POST_QUIT_MSG(a) PostQuitMessage(a)

/****************************************************************************/
/* Check if a pointer is valid                                              */
/****************************************************************************/
#define DC_IS_VALID_PTR(PTR, SIZE)    (!IsBadWritePtr((PTR), (SIZE)))

/****************************************************************************/
/* Include platform specific stuff.                                         */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgmcro.h>
#else
#include <ndcgmcro.h>
#endif

#endif /* _H_WDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wtrcapi.h ===
/**INC+**********************************************************************/
/* Header:    wtrcapi.h                                                     */
/*                                                                          */
/* Purpose:   Tracing API header - Windows specific                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wtrcapi.h_v  $
 *
 *    Rev 1.3   29 Aug 1997 09:23:14   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.2   09 Jul 1997 18:08:08   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_WTRCAPI
#define _H_WTRCAPI

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* The return code passed from ExitThread after an assert.                  */
/****************************************************************************/
#define TRC_THREAD_EXIT          10

/****************************************************************************/
/* The size of buffer maintained for kernel mode tracing.                   */
/****************************************************************************/
#define TRC_KRNL_BUFFER_SIZE          0x8000

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/* A macro to get the last system error and trace it out as an alert level  */
/* trace.                                                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_ALT
#define TRC_SYSTEM_ERROR(string)                                             \
{                                                                            \
    if (TRC_LEVEL_ALT >= TRC_GetTraceLevel())                                \
    {                                                                        \
        TRC_SystemError(TRC_GROUP,                                           \
                        __LINE__,                                            \
                        trc_fn,                                              \
                        trc_file,                                            \
                        _T(string));                                         \
    }                                                                        \
}
#else
#define TRC_SYSTEM_ERROR(string)
#endif

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_SystemError                                                          */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* API FUNCTION: TRC_SystemError(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function traces out the last system error as an alert level trace.  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : trace component name.                                   */
/* lineNumber     : line number.                                            */
/* funcName       : function name.                                          */
/* fileName       : file name.                                              */
/* string         : name of failed function                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_SystemError(DCUINT   traceComponent,
                             DCUINT   lineNumber,
                             PDCTCHAR funcName,
                             PDCTCHAR fileName,
                             PDCTCHAR string);

#if defined(TRC_CONVERTOANSI)
/****************************************************************************/
/* See wtrcapi.c for details.                                               */
/****************************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(PDCTCHAR, const PDCACHAR, ...);
#endif

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN32
#include <ntrcapi.h>
#endif

#endif /* _H_WTRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wdcgctyp.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows specific header.                    */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wdcgctyp.h_v  $                                                                   */
//
//    Rev 1.3   15 Sep 1997 18:27:18   AK
// SFR1416: Move SD_BOTH definition
//
//    Rev 1.2   26 Jun 1997 09:54:04   KH
// Win16Port: Move some common definitions from n/d files
//
//    Rev 1.1   19 Jun 1997 14:33:02   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGCTYP
#define _H_WDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include appropriate header files.                                        */
/****************************************************************************/
#ifndef OS_WINCE
#include <sys\timeb.h>
#endif // OS_WINCE
/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgctyp.h                                                 */
/* Windows NT  : ndcgctyp.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgctyp.h>
#elif defined( OS_WIN32 )
#include <ndcgctyp.h>
#endif

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef HPALETTE                       DCPALID;
typedef HCURSOR                        DCCURSORID;
typedef HTASK                          SYSAPPID;
typedef HWND                           SYSWINID;
typedef HFILE                          DCHFILE;
typedef RECT                           SYSRECT;
typedef PALETTEENTRY                   DCPALETTEENTRY;
typedef DCPALETTEENTRY          DCPTR  PDCPALETTEENTRY;

/****************************************************************************/
/* A few useful drawing and bitmap types.                                   */
/****************************************************************************/
typedef HBITMAP                        SYSBITMAP;
typedef BITMAPINFOHEADER               SYSBMIHEADER;
typedef BITMAPINFO                     SYSBMI;

typedef RGBTRIPLE               DCPTR  PRGBTRIPLE;
typedef RGBQUAD                 DCPTR  PRGBQUAD;

/****************************************************************************/
/* Fields for Bmp info structure.                                           */
/****************************************************************************/
#define BMISIZE                        biSize
#define BMIWIDTH                       biWidth
#define BMIHEIGHT                      biHeight
#define BMIPLANES                      biPlanes
#define BMIBITCOUNT                    biBitCount
#define BMICOMPRESSION                 biCompression
#define BMISIZEIMAGE                   biSizeImage
#define BMIXPELSPERMETER               biXPelsPerMeter
#define BMIYPELSPERMETER               biYPelsPerMeter
#define BMICLRUSED                     biClrUsed
#define BMICLRIMPORTANT                biClrImportant

/****************************************************************************/
/* Compression options.                                                     */
/****************************************************************************/
#define BMCRGB                         BI_RGB
#define BMCRLE8                        BI_RLE8
#define BMCRLE4                        BI_RLE4

typedef POINT                          SYSPOINT;

/****************************************************************************/
/* Fields for sysrect structure.                                            */
/****************************************************************************/
#define SRXMIN                         left
#define SRXMAX                         right
#define SRYMIN                         top
#define SRYMAX                         bottom

/****************************************************************************/
/* For fonts...                                                             */
/****************************************************************************/
typedef TEXTMETRIC                     DCTEXTMETRIC;
typedef PTEXTMETRIC                    PDCTEXTMETRIC;
typedef HFONT                          DCHFONT;

/****************************************************************************/
/* Time typedefs.                                                           */
/****************************************************************************/
typedef struct _timeb                  DC_TIMEB;

/****************************************************************************/
/* Mutex handle                                                             */
/****************************************************************************/
typedef HANDLE      DCMUTEX;

/****************************************************************************/
/* Window enumeration handle                                                */
/****************************************************************************/
typedef DCUINT32                       DCENUMWNDHANDLE;
typedef DCENUMWNDHANDLE DCPTR          PDCENUMWNDHANDLE;

/****************************************************************************/
/* Macros for Window and Dialog procedures.                                 */
/****************************************************************************/
#define DCRESULT             LRESULT
#define DCWNDPROC            LRESULT   CALLBACK
#define DCDLGPROC            BOOL      CALLBACK

/****************************************************************************/
/* The following constants are available in WinSock 1.1 and 2.0 but not     */
/* given names in WinSock 1.1.                                              */
/****************************************************************************/
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02

#endif /* _H_WDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wtrcctl.h ===
/****************************************************************************/
/* WTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control switch file - Windows specific            */
/*                                                                          */
/* Copyright(c) Microsoft, Data Connection 1997                             */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wtrcctl.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 14:46:36   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/

#ifndef _H_WTRCCTL
#define _H_WTRCCTL

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Functions to be included in both user and kernel space                   */
/****************************************************************************/
#define INC_TRC_GetBuffer
#define INC_TRC_TraceBuffer
#define INC_TRC_GetConfig
#define INC_TRC_SetConfig
#define INC_TRC_TraceData
#define INC_TRC_GetTraceLevel
#define INC_TRC_ProfileTraceEnabled

#define INC_TRCCheckState
#define INC_TRCDumpLine
#define INC_TRCShouldTraceThis
#define INC_TRCSplitPrefixes

/****************************************************************************/
/* Determine our target OS and include the appropriate header file.         */
/* Currently we support:                                                    */
/****************************************************************************/
#ifdef OS_WIN16
#include <dtrcctl.h>
#else
#include <ntrcctl.h>
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\inc\wtrcint.h ===
/**INC+**********************************************************************/
/* Header:    wtrcint.h                                                     */
/*                                                                          */
/* Purpose:   Interal tracing functions header - Windows specific           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wtrcint.h_v  $
 *
 *    Rev 1.8   29 Aug 1997 09:22:56   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.7   22 Aug 1997 15:11:18   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.6   10 Jul 1997 18:09:44   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.5   10 Jul 1997 17:26:14   KH
 * SFR1022: Get 16-bit trace working
**/
/**INC-**********************************************************************/
#ifndef _H_WTRCINT
#define _H_WTRCINT

#ifdef VER_HOST
#include <wosiapi.h>
#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Notification constants.                                                  */
/****************************************************************************/
#define TRC_TRACE_DLL_INITIALIZE       0
#define TRC_TRACE_DLL_TERMINATE        1
#define TRC_PROCESS_ATTACH_NOTIFY      2
#define TRC_PROCESS_DETACH_NOTIFY      3
#define TRC_THREAD_ATTACH_NOTIFY       4
#define TRC_THREAD_DETACH_NOTIFY       5
#define TRC_SYMBOLS_LOADING_NOTIFY     6
#define TRC_SYMBOLS_LOADED_NOTIFY      7
#define TRC_SYMBOLS_UNLOAD_NOTIFY      8
#define TRC_FILES_RESET                9

/****************************************************************************/
/* Trace internal error return values.                                      */
/****************************************************************************/
#define TRC_RC(N)                      ((DCUINT16)N + TRC_BASE_RC)

#define TRC_RC_CREATE_MAPPING_FAILED   TRC_RC(  1)
#define TRC_RC_MAP_VIEW_FAILED         TRC_RC(  2)
#define TRC_RC_CREATE_FILE_FAILED      TRC_RC(  3)
#define TRC_RC_IO_ERROR                TRC_RC(  4)
#define TRC_RC_CREATE_MUTEX_FAILED     TRC_RC(  5)
#define TRC_RC_SYMBOL_LOAD_FAILED      TRC_RC(  6)
#define TRC_RC_SYMBOL_UNLOAD_FAILED    TRC_RC(  7)
#define TRC_RC_SET_SEC_INFO_FAILED     TRC_RC(  8)

/****************************************************************************/
/* Assert box text                                                          */
/****************************************************************************/
#define TRC_ASSERT_TEXT   _T("%s\n\nFunction %s in file %s at line %d.\n")

#define TRC_ASSERT_TEXT2  _T("\n(Press Retry to debug the application)")

/****************************************************************************/
/* Registry buffer constants.                                               */
/****************************************************************************/
#define TRC_MAX_SUBKEY                 256

/****************************************************************************/
/* Internal trace status flags.  These are maintained on a per process      */
/* basis and are stored in the <trcProcessStatus> field.                    */
/*                                                                          */
/* TRC_STATUS_SYMBOLS_LOADED           : are the debug symbols loaded.      */
/****************************************************************************/
#define TRC_STATUS_SYMBOLS_LOADED      DCFLAG32(1)

/****************************************************************************/
/* Carriage return and line feed pair.                                      */
/****************************************************************************/
#define TRC_CRLF                       _T("\r\n")

/****************************************************************************/
/* Trace format definitions.  These are used for printing various parts of  */
/* the trace lines.                                                         */
/*                                                                          */
/* MODL     is the module name.                                             */
/* STCK     is the stack format (offset, bp, parm1-4).                      */
/*                                                                          */
/****************************************************************************/
#define TRC_MODL_FMT                  _T("%8.8s")
#define TRC_STCK_FMT                  _T("%08x %08x %08x %08x %08x %08x %08x")

#ifdef VER_HOST
/****************************************************************************/
/* Specific values for trace escape codes                                   */
/****************************************************************************/
#define TRC_ESC(code)           (OSI_TRC_ESC_FIRST + code)

#define TRC_ESC_SET_TRACE       TRC_ESC(0)  /* Set new trace level & filter */

#define TRC_ESC_GET_TRACE       TRC_ESC(1)  /* Get latest kernel trace data */

#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_SHARED_DATA                                                          */
/* ===============                                                          */
/* The pointer to the start of the shared data memory mapped file is cast   */
/* as a PTRC_SHARED_DATA.                                                   */
/*                                                                          */
/*                                                                          */
/* trcConfig          - a trace configuration structure which contains the  */
/*                      trace level, prefix list etc.                       */
/* trcIndicator       - which trace MMF is in use.                          */
/* trcOffset          - the current offset from the start of the trace      */
/*                      file.                                               */
/* trcpOutputBuffer   - the trace output buffer.                            */
/* trcpModuleFileName - the module file name of the trace DLL.              */
/* trcpStorageBuffer  - the kernel mode trace output buffer.                */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_SHARED_DATA
{
    TRC_CONFIG     trcConfig;
    TRC_FILTER     trcFilter;
    DCUINT         trcIndicator;
    DCUINT32       trcOffset;
    DCTCHAR        trcpOutputBuffer[TRC_LINE_BUFFER_SIZE];
    DCTCHAR        trcpModuleFileName[TRC_FILE_NAME_SIZE];
    DCTCHAR        trcpStorageBuffer[TRC_KRNL_BUFFER_SIZE];
} TRC_SHARED_DATA;

typedef TRC_SHARED_DATA  DCPTR PTRC_SHARED_DATA;

#ifdef VER_HOST
/**STRUCT+*******************************************************************/
/* STRUCTURE: TRC_CHANGE_CONFIG                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/*                                                                          */
/* This structure is used to pass the new trace settings to the OSI task.   */
/****************************************************************************/
typedef struct tagTRC_CHANGE_CONFIG
{
    OSI_ESCAPE_HEADER header;           /* Common escape header             */

    TRC_CONFIG        config;           /* New tracing configuration        */

    TRC_FILTER        filter;           /* New filter configuration         */

} TRC_CHANGE_CONFIG, DCPTR PTRC_CHANGE_CONFIG;
/**STRUCT-*******************************************************************/


/**STRUCT+*******************************************************************/
/* STRUCTURE: TRC_GET_OUTPUT                                                */
/*                                                                          */
/* DESCRIPTION:                                                             */
/*                                                                          */
/* This structure is used to pass the latest kernel mode tracing to user    */
/* space.                                                                   */
/****************************************************************************/
typedef struct tagTRC_GET_OUTPUT
{
    OSI_ESCAPE_HEADER header;           /* Common escape header             */

    PDCTCHAR          buffer;           /* Latest buffer of trace output    */

    DCUINT32          length;           /* Length of data in the buffer     */

    DCUINT32          linesLost;        /* Lines lost from kernel trace     */

} TRC_GET_OUTPUT, DCPTR PTRC_GET_OUTPUT;
/**STRUCT-*******************************************************************/
#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* TRCBlankFile                                                             */
/* TRCCloseAllFiles                                                         */
/* TRCCloseSharedData                                                       */
/* TRCCloseSingleFile                                                       */
/* TRCDetermineIndicator                                                    */
/* TRCDetermineOffset                                                       */
/* TRCDisplayAssertBox                                                      */
/* TRCGetCurrentDate                                                        */
/* TRCGetCurrentTime                                                        */
/* TRCGetFileTime                                                           */
/* TRCSystemError                                                           */
/* TRCOpenAllFiles                                                          */
/* TRCOpenSharedData                                                        */
/* TRCOpenSingleFile                                                        */
/* TRCOutputToFile                                                          */
/* TRCReadEntry                                                             */
/* TRCReadProfInt                                                           */
/* TRCReadProfString                                                        */
/* TRCStackTrace                                                            */
/* TRCSymbolsLoad                                                           */
/* TRCSymbolsUnload                                                         */
/* TRCWriteEntry                                                            */
/* TRCWriteProfInt                                                          */
/* TRCWriteProfString                                                       */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCMaybeSwapFile(DCUINT length);

DCVOID DCINTERNAL TRCExitProcess(DCUINT32 exitCode);

DCVOID DCINTERNAL TRCBlankFile(DCUINT fileNumber);

DCVOID DCINTERNAL TRCCloseAllFiles(DCVOID);

DCVOID DCINTERNAL TRCCloseSharedData(DCVOID);

DCVOID DCINTERNAL TRCCloseSingleFile(DCUINT fileNumber, DCUINT seconds);

DCVOID DCINTERNAL TRCDetermineIndicator(DCVOID);

DCUINT32 DCINTERNAL TRCDetermineOffset(DCUINT32 fileNum);

DCVOID DCINTERNAL TRCDisplayAssertBox(PDCTCHAR pText);

DCVOID DCINTERNAL TRCGetCurrentDate(PDC_DATE pDate);

DCVOID DCINTERNAL TRCGetCurrentTime(PDC_TIME pTime);

DCVOID DCINTERNAL TRCGetKernelTrace(DCVOID);

#ifndef DLL_DISP
DCBOOL DCINTERNAL TRCGetFileTime(DCUINT      fileNumber,
                                 PDCFILETIME pFileTime);

DCUINT DCINTERNAL TRCReadEntry(HKEY     topLevelKey,
                               PDCTCHAR pEntry,
                               PDCVOID  pBuffer,
                               DCINT    bufferSize,
                               DCINT32  expectedDataType);

DCUINT DCINTERNAL TRCWriteEntry(HKEY     topLevelKey,
                                PDCTCHAR pEntry,
                                PDCTCHAR pData,
                                DCINT    dataSize,
                                DCINT32  dataType);

#endif

DCVOID DCINTERNAL TRCSystemError(DCUINT   traceComponent,
                                 DCUINT   lineNumber,
                                 PDCTCHAR funcName,
                                 PDCTCHAR fileName,
                                 PDCTCHAR string);

DCUINT DCINTERNAL TRCOpenAllFiles(DCVOID);

DCUINT DCINTERNAL TRCOpenSharedData(DCVOID);

DCUINT DCINTERNAL TRCOpenSingleFile(DCUINT fileNumber);

DCVOID DCINTERNAL TRCOutputToFile(PDCTCHAR pText,
                                  DCUINT   length,
                                  DCUINT   traceLevel);

DCVOID DCINTERNAL TRCOutputToUser(PDCTCHAR pText,
                                  DCUINT32 length,
                                  DCUINT32 traceLevel);

DCUINT DCINTERNAL TRCReadProfInt(PDCTCHAR pEntry,
                                 PDCUINT32   pValue);

DCUINT DCINTERNAL TRCReadProfString(PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT16  bufferSize);

DCVOID DCINTERNAL TRCStackTrace(DCUINT traceLevel);

DCUINT DCINTERNAL TRCSymbolsLoad(DCVOID);

DCUINT DCINTERNAL TRCSymbolsUnload(DCVOID);

DCUINT DCINTERNAL TRCWriteProfInt(PDCTCHAR  pEntry,
                                  PDCUINT32 pValue);

DCUINT DCINTERNAL TRCWriteProfString(PDCTCHAR pEntry,
                                     PDCTCHAR pBuffer);

DCUINT DCINTERNAL TRCGetModuleFileName(PDCTCHAR pModuleName,
                                       UINT cchModuleName);

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN16
#include <dtrcint.h>
#else
#include <ntrcint.h>
#endif

#endif /* _H_WTRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\clrhouse\keypklib\keypack.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        keypack.c
//
// Contents:    Keypack encoding/decoding library
//
// History:     
//
//---------------------------------------------------------------------------
#include "precomp.h"
#include <stddef.h>
#include "md5.h"
#include "rc4.h"

#ifdef IGNORE_EXPIRATION
#define LICENSE_EXPIRATION_IGNORE L"SOFTWARE\\Microsoft\\TermServLicensing\\IgnoreLicenseExpiration"
#endif

typedef struct _Enveloped_Data
{
    DWORD   cbEncryptedKey;
    PBYTE   pbEncryptedKey;
    DWORD   cbEncryptedData;
    PBYTE   pbEncryptedData;
} Enveloped_Data, * PEnveloped_Data;


///////////////////////////////////////////////////////////////////////////////
//
// Internal functions
//

DWORD WINAPI
VerifyAndGetLicenseKeyPack(
    HCRYPTPROV          hCryptProv,
    PLicense_KeyPack    pLicenseKeyPack,
    DWORD               cbSignerCert, 
    PBYTE               pbSignerCert,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate,
    DWORD               cbSignedBlob, 
    PBYTE               pbSignedBlob 
);

DWORD WINAPI
GetCertificate(
    DWORD               cbCertificateBlob,
    PBYTE               pbCertificateBlob,
    HCRYPTPROV          hCryptProv,
    PCCERT_CONTEXT    * ppCertContext,
    HCERTSTORE        * phCertStore 
);

DWORD WINAPI
VerifyCertificateChain( 
    HCERTSTORE          hCertStore, 
    PCCERT_CONTEXT      pCertContext,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate 
);

DWORD WINAPI
GetCertVerificationResult(
    DWORD dwFlags 
);

DWORD WINAPI
UnpackEnvelopedData( 
    IN OUT PEnveloped_Data pEnvelopedData, 
    IN DWORD cbPackedData, 
    IN PBYTE pbPackedData 
);

DWORD WINAPI
GetEnvelopedData( 
    IN DWORD dwEncyptType,
    IN HCRYPTPROV hCryptProv, 
    IN PEnveloped_Data pEnvelopedData,
    OUT PDWORD pcbData,
    OUT PBYTE *ppbData 
);

/////////////////////////////////////////////////////////

DWORD WINAPI
LicensePackEncryptDecryptData(
    IN PBYTE pbParm,
    IN DWORD cbParm,
    IN OUT PBYTE pbData,
    IN DWORD cbData
    )
/*++

Abstract:

    Internal routine to encrypt/decrypt a blob of data

Parameter:

    pbParm : binary blob to generate encrypt/decrypt key.
    cbParm : size of binary blob.
    pbData : data to be encrypt/decrypt.
    cbData : size of data to be encrypt/decrypt.

Returns:

    ERROR_SUCCESS or error code.

Remark:


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    MD5_CTX md5Ctx;
    RC4_KEYSTRUCT rc4KS;
    BYTE key[16];
    int i;

    if(NULL == pbParm || 0 == cbParm)
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }

    MD5Init(&md5Ctx);
    MD5Update(
            &md5Ctx,
            pbParm,
            cbParm
        );

    MD5Final(&md5Ctx);

    memset(key, 0, sizeof(key));

    for(i=0; i < 5; i++)
    {
        key[i] = md5Ctx.digest[i];
    }        

    //
    // Call RC4 to encrypt/decrypt data
    //
    rc4_key(
            &rc4KS, 
            sizeof(key), 
            key 
        );

    rc4(
        &rc4KS, 
        cbData, 
        pbData
    );

	return dwRetCode;
}

static BYTE rgbPubKeyWithExponentOfOne[] =
{
0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00,

0xab, 0xef, 0xfa, 0xc6, 0x7d, 0xe8, 0xde, 0xfb,
0x68, 0x38, 0x09, 0x92, 0xd9, 0x42, 0x7e, 0x6b,
0x89, 0x9e, 0x21, 0xd7, 0x52, 0x1c, 0x99, 0x3c,
0x17, 0x48, 0x4e, 0x3a, 0x44, 0x02, 0xf2, 0xfa,
0x74, 0x57, 0xda, 0xe4, 0xd3, 0xc0, 0x35, 0x67,
0xfa, 0x6e, 0xdf, 0x78, 0x4c, 0x75, 0x35, 0x1c,
0xa0, 0x74, 0x49, 0xe3, 0x20, 0x13, 0x71, 0x35,
0x65, 0xdf, 0x12, 0x20, 0xf5, 0xf5, 0xf5, 0xc1
};

//---------------------------------------------------------------

BOOL WINAPI 
GetPlaintextKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSymKey,
    OUT BYTE *pbPlainKey   // this must be a 16 byte buffer
    )
/*++

part of Jeff Spelman's code

--*/
{
    HCRYPTKEY   hPubKey = 0;
    BYTE        rgbSimpleBlob[128];
    DWORD       cbSimpleBlob;
    BYTE        *pb;
    DWORD       i;
    BOOL        fRet = FALSE;

    memset(rgbSimpleBlob, 0, sizeof(rgbSimpleBlob));

    if (!CryptImportKey(hProv,
                        rgbPubKeyWithExponentOfOne,
                        sizeof(rgbPubKeyWithExponentOfOne),
                        0,
                        0,
                        &hPubKey))
    {
        goto Ret;
    }

    cbSimpleBlob = sizeof(rgbSimpleBlob);
    if (!CryptExportKey(hSymKey,
                        hPubKey,
                        SIMPLEBLOB,
                        0,
                        rgbSimpleBlob,
                        &cbSimpleBlob))
    {
        goto Ret;
    }

    memset(pbPlainKey, 0, 16);
    pb = rgbSimpleBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID);
    // byte reverse the key
    for (i = 0; i < 5; i++)
    {
        pbPlainKey[i] = pb[5 - (i + 1)];
    }

    fRet = TRUE;

Ret:
    if (hPubKey)
    {
        CryptDestroyKey(hPubKey);
    }

    return fRet;
}

//--------------------------------------------------------------------

DWORD WINAPI
KeyPackDecryptData(
    IN DWORD dwEncryptType,
    IN HCRYPTPROV hCryptProv,
    IN BYTE* pbEncryptKey,
    IN DWORD cbEncryptKey,
    IN BYTE* pbEncryptData,
    IN DWORD cbEncryptData,
    OUT PBYTE* ppbDecryptData,
    OUT PDWORD pcbDecryptData
    )
/*++

Abstract:

    Decrypt a blob of data

Parameters:

    bForceCrypto : TRUE if always use Crypto. API, FALSE otherwise.
    hCryptProv :
    pbEncryptKey :
    cbEncryptKey :
    pbEncryptData :
    cbEncryptData :
    ppbDecryptData :
    pcbDecryptData :

Returns:

    ERROR_SUCCESS or error code.

Remark:

--*/
{
    HCRYPTKEY hSymKey = 0;
    DWORD dwErrCode = ERROR_SUCCESS;
    BYTE rgbPlainKey[16];
    RC4_KEYSTRUCT KeyStruct;
    BOOL  bFrenchLocale;
    

    bFrenchLocale = (MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH) == GetSystemDefaultLangID());

    if( (HCRYPTPROV)NULL == hCryptProv || NULL == pbEncryptKey || 0 == cbEncryptKey ||
        NULL == pbEncryptData || 0 == cbEncryptData )
    {
        SetLastError(dwErrCode = ERROR_INVALID_PARAMETER);
        return dwErrCode;
    }

    if( NULL == ppbDecryptData || NULL == pcbDecryptData )
    {
        SetLastError(dwErrCode = ERROR_INVALID_PARAMETER);
        return dwErrCode;
    }

    *pcbDecryptData = 0;
    *ppbDecryptData = NULL;

    if(!CryptImportKey(
                    hCryptProv,
                    pbEncryptKey,
                    cbEncryptKey,
                    0,
                    CRYPT_EXPORTABLE,
                    &hSymKey
                ))
    {
        dwErrCode = GetLastError();
        goto cleanup;
    }

    *pcbDecryptData = cbEncryptData;
    *ppbDecryptData = (PBYTE) LocalAlloc(LPTR, cbEncryptData);
    if(NULL == *ppbDecryptData)
    {
        dwErrCode = GetLastError();
        goto cleanup;
    }

    memcpy(
            *ppbDecryptData,
            pbEncryptData,
            *pcbDecryptData
        );

    if(bFrenchLocale && LICENSE_KEYPACK_ENCRYPT_CRYPTO == dwEncryptType)
    {
        if(!GetPlaintextKey(
                        hCryptProv,
                        hSymKey,
                        rgbPlainKey))
        {
            dwErrCode = GetLastError();
            goto cleanup;
        }

        //
        // RC4 - input buffer size = output buffer size
        //
        rc4_key(&KeyStruct, sizeof(rgbPlainKey), rgbPlainKey);
        rc4(&KeyStruct, *pcbDecryptData, *ppbDecryptData);

        dwErrCode = ERROR_SUCCESS;
    }
    else
    {
        if(!CryptDecrypt(hSymKey, 0, TRUE, 0, *ppbDecryptData, pcbDecryptData))
        {
            dwErrCode = GetLastError();
            if(NTE_BAD_LEN == dwErrCode)
            {
                PBYTE pbNew;
                //
                // output buffer is too small, re-allocate
                //
                pbNew = (PBYTE) LocalReAlloc(
                                            *ppbDecryptData, 
                                            *pcbDecryptData, 
                                            LMEM_ZEROINIT
                                        );
                if(NULL == pbNew)
                {
                    dwErrCode = GetLastError();
                    goto cleanup;
                }

                *ppbDecryptData = pbNew;
            }

            memcpy(
                    *ppbDecryptData,
                    pbEncryptData,
                    cbEncryptData
                );

            if(!CryptDecrypt(hSymKey, 0, TRUE, 0, *ppbDecryptData, pcbDecryptData))
            {
                dwErrCode = GetLastError();
            }
        }
    }
        
cleanup:

    if (hSymKey)
    {
        CryptDestroyKey(hSymKey);
    }
 
    if(dwErrCode != ERROR_SUCCESS)
    {
        if(*ppbDecryptData != NULL)
        {
            LocalFree(*ppbDecryptData);
        }

        *ppbDecryptData = NULL;
        *pcbDecryptData = 0;
    }

    return dwErrCode;   
}    

///////////////////////////////////////////////////////////////////////////////
//
// decode the encrypted license key pack blob with the license server's private 
// key.
//
// hCryptProv is opened with the key container that contains the key exchange
// private key.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
DecodeLicenseKeyPackEx(
    OUT PLicense_KeyPack pLicenseKeyPack,
    IN PLicensePackDecodeParm pDecodeParm,
    IN DWORD cbKeyPackBlob,
    IN PBYTE pbKeyPackBlob 
    )
/*++

Abstract:

    Decode the encrypted license key pack blob.

Parameters:

    pLicenseKeyPack : Decoded license key pack.
    hCryptProv : 


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD cbSignedBlob, cbSignature;
    PBYTE pbSignedBlob = NULL, pcbSignature = NULL;
    Enveloped_Data EnvelopedData;
    PEncodedLicenseKeyPack pEncodedLicensePack;

    if( NULL == pLicenseKeyPack || NULL == pDecodeParm ||
        NULL == pbKeyPackBlob || 0 == cbKeyPackBlob )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if( (HCRYPTPROV)NULL == pDecodeParm->hCryptProv )
    {
        return ERROR_INVALID_PARAMETER;
    }


    pEncodedLicensePack = (PEncodedLicenseKeyPack)pbKeyPackBlob;
    
    if(pEncodedLicensePack->dwSignature != LICENSEPACKENCODE_SIGNATURE)
    {
        // 
        // EncodedLicenseKeyPack() puts size of encryption key as first DWORD
        //
        dwRetCode = DecodeLicenseKeyPack(
                                    pLicenseKeyPack,
                                    pDecodeParm->hCryptProv,
                                    pDecodeParm->cbClearingHouseCert,
                                    pDecodeParm->pbClearingHouseCert,
                                    pDecodeParm->cbRootCertificate,
                                    pDecodeParm->pbRootCertificate,
                                    cbKeyPackBlob,
                                    pbKeyPackBlob
                                );

        return dwRetCode;
    }

    if(pEncodedLicensePack->dwStructVersion > LICENSEPACKENCODE_CURRENTVERSION)
    {
        return ERROR_INVALID_DATA;
    }

    if( pEncodedLicensePack->dwEncodeType > LICENSE_KEYPACK_ENCRYPT_MAX )
    {
        return ERROR_INVALID_DATA;
    }

    if( cbKeyPackBlob != offsetof(EncodedLicenseKeyPack, pbData) + pEncodedLicensePack->cbData )   
    {
        return ERROR_INVALID_DATA;
    }
    
    //
    // check input parameters
    //

    if( 0 == pDecodeParm->cbClearingHouseCert ||
        NULL == pDecodeParm->pbClearingHouseCert ||
        0 == pDecodeParm->cbRootCertificate ||
        NULL == pDecodeParm->pbRootCertificate )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the enveloped data
    //
    memset( 
            &EnvelopedData, 
            0, 
            sizeof( Enveloped_Data ) 
        );

    dwRetCode = UnpackEnvelopedData( 
                                &EnvelopedData, 
                                pEncodedLicensePack->cbData,
                                &(pEncodedLicensePack->pbData[0])
                            );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    switch( pEncodedLicensePack->dwEncodeType )
    {
        case LICENSE_KEYPACK_ENCRYPT_CRYPTO:
        case LICENSE_KEYPACK_ENCRYPT_ALWAYSCRYPTO:

            //
            // unpack the enveloped data to get the signed keypack blob
            //
            dwRetCode = GetEnvelopedData( 
                                    pEncodedLicensePack->dwEncodeType,
                                    pDecodeParm->hCryptProv, 
                                    &EnvelopedData, 
                                    &cbSignedBlob, 
                                    &pbSignedBlob 
                                );

            break;

        default:

            // impossible to come here
            dwRetCode = ERROR_INVALID_DATA;
    }

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }
    
    //
    // Get the license keypack from the signed blob.  We also provide the
    // clearing house certificate to verify the authenticity of the keypack.
    //

    dwRetCode = VerifyAndGetLicenseKeyPack( 
                                    pDecodeParm->hCryptProv, 
                                    pLicenseKeyPack, 
                                    pDecodeParm->cbClearingHouseCert, 
                                    pDecodeParm->pbClearingHouseCert,
                                    pDecodeParm->cbRootCertificate, 
                                    pDecodeParm->pbRootCertificate,
                                    cbSignedBlob, 
                                    pbSignedBlob 
                                );

done:

    if( EnvelopedData.pbEncryptedKey )
    {
        LocalFree( EnvelopedData.pbEncryptedKey );
    }

    if( EnvelopedData.pbEncryptedData )
    {
        LocalFree( EnvelopedData.pbEncryptedData );
    }

    if( pbSignedBlob )
    {
        LocalFree( pbSignedBlob );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
GetEnvelopedData( 
    IN DWORD dwEncryptType,
    IN HCRYPTPROV hCryptProv, 
    IN PEnveloped_Data pEnvelopedData,
    OUT PDWORD pcbData,
    OUT PBYTE *ppbData 
    )
/*++


--*/
{
    HCRYPTKEY hPrivateKey = 0;
    DWORD dwRetCode = ERROR_SUCCESS;

    
    if( (HCRYPTPROV)NULL == hCryptProv || pEnvelopedData == NULL || 
        ppbData == NULL || pcbData == NULL )
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }


    //
    // Make sure we have a exchange key to decrypt session key.
    // 
   
    if( !CryptGetUserKey( hCryptProv, AT_KEYEXCHANGE, &hPrivateKey ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // decrypt the data, KeyPackDecryptData() handle
    // memory freeing in case of error.
    //

    dwRetCode = KeyPackDecryptData(
                                dwEncryptType,
                                hCryptProv,
                                pEnvelopedData->pbEncryptedKey,
                                pEnvelopedData->cbEncryptedKey,
                                pEnvelopedData->pbEncryptedData,
                                pEnvelopedData->cbEncryptedData,
                                ppbData,
                                pcbData
                            );
    
done:

    if( hPrivateKey )
    {
        CryptDestroyKey( hPrivateKey );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
UnpackEnvelopedData( 
    IN OUT PEnveloped_Data pEnvelopedData, 
    IN DWORD cbPackedData, 
    IN PBYTE pbPackedData 
    )
/*++

Abstract:

    Unpack an encrypted license pack blob.

Parameters:

    pEnvelopedData :
    cbPackedData :
    pbPackedData :

Returns:
    

--*/
{
    PBYTE pbCopyPos = pbPackedData;
    DWORD cbDataToUnpack = cbPackedData;

    //
    // ensure that the data is of minimum length
    //
    if( ( ( sizeof( DWORD ) * 2 ) > cbPackedData ) ||
        ( NULL == pbPackedData ) ||
        ( NULL == pEnvelopedData ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // read a DWORD to get the encrypted key length
    //

    memcpy( &pEnvelopedData->cbEncryptedKey, pbCopyPos, sizeof( DWORD ) );

    pbCopyPos += sizeof( DWORD );
    cbDataToUnpack -= sizeof( DWORD );
    
    if( cbDataToUnpack < pEnvelopedData->cbEncryptedKey )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    // Allocate memory to unpack the encrypted key
    //
    if(pEnvelopedData->cbEncryptedKey > 0)
    {
        pEnvelopedData->pbEncryptedKey = LocalAlloc( GPTR, pEnvelopedData->cbEncryptedKey );

        if( NULL == pEnvelopedData->pbEncryptedKey )
        {
            return( GetLastError() );
        }

        memcpy( pEnvelopedData->pbEncryptedKey, pbCopyPos, pEnvelopedData->cbEncryptedKey );
    }
    
    pbCopyPos += pEnvelopedData->cbEncryptedKey;
    cbDataToUnpack -= pEnvelopedData->cbEncryptedKey;

    //
    // expecting to read a DWORD for the encrypted data length
    //

    if( sizeof( DWORD ) > cbDataToUnpack )
    {
        return( ERROR_INVALID_DATA );
    }

    memcpy( &pEnvelopedData->cbEncryptedData, pbCopyPos, sizeof( DWORD ) );

    pbCopyPos += sizeof( DWORD );
    cbDataToUnpack -= sizeof( DWORD );

    if( cbDataToUnpack < pEnvelopedData->cbEncryptedData )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    // allocate memory for the encrypted data
    //

    pEnvelopedData->pbEncryptedData = LocalAlloc( GPTR, pEnvelopedData->cbEncryptedData );

    if( NULL == pEnvelopedData->pbEncryptedData )
    {
        return( GetLastError() );
    }

    memcpy( pEnvelopedData->pbEncryptedData, pbCopyPos, pEnvelopedData->cbEncryptedData );

    return( ERROR_SUCCESS );
}


///////////////////////////////////////////////////////////////////////////////
//
// decode the encrypted license key pack blob with the license server's private 
// key.
//
// hCryptProv is opened with the key container that contains the key exchange
// private key.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
DecodeLicenseKeyPack(
    PLicense_KeyPack        pLicenseKeyPack,
    HCRYPTPROV              hCryptProv,
    DWORD                   cbClearingHouseCert,
    PBYTE                   pbClearingHouseCert,
    DWORD                   cbRootCertificate,
    PBYTE                   pbRootCertificate,
    DWORD                   cbKeyPackBlob,
    PBYTE                   pbKeyPackBlob )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD cbSignedBlob, cbSignature;
    PBYTE pbSignedBlob = NULL, pcbSignature = NULL;
    Enveloped_Data EnvelopedData;

    if( 0 == hCryptProv )
    {
        return( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the enveloped data
    //

    memset( &EnvelopedData, 0, sizeof( Enveloped_Data ) );

    dwRetCode = UnpackEnvelopedData( &EnvelopedData, cbKeyPackBlob, pbKeyPackBlob );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    //
    // unpack the enveloped data to get the signed keypack blob
    //

    dwRetCode = GetEnvelopedData( 
                            LICENSE_KEYPACK_ENCRYPT_CRYPTO,
                            hCryptProv, 
                            &EnvelopedData, 
                            &cbSignedBlob, 
                            &pbSignedBlob 
                        );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }
    
    //
    // Get the license keypack from the signed blob.  We also provide the
    // clearing house certificate to verify the authenticity of the keypack.
    //

    dwRetCode = VerifyAndGetLicenseKeyPack( hCryptProv, pLicenseKeyPack, 
                                            cbClearingHouseCert, pbClearingHouseCert,
                                            cbRootCertificate, pbRootCertificate,
                                            cbSignedBlob, pbSignedBlob );

done:

    if( EnvelopedData.pbEncryptedKey )
    {
        LocalFree( EnvelopedData.pbEncryptedKey );
    }

    if( EnvelopedData.pbEncryptedData )
    {
        LocalFree( EnvelopedData.pbEncryptedData );
    }

    if( pbSignedBlob )
    {
        LocalFree( pbSignedBlob );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
VerifyAndGetLicenseKeyPack(
    HCRYPTPROV          hCryptProv, 
    PLicense_KeyPack    pLicenseKeyPack,
    DWORD               cbSignerCert, 
    PBYTE               pbSignerCert,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate,
    DWORD               cbSignedBlob, 
    PBYTE               pbSignedBlob )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = 0;
    HCERTSTORE hCertStore = 0;
    HCRYPTHASH hCryptHash = 0;
    HCRYPTKEY hPubKey = 0;
    PBYTE pbCopyPos = pbSignedBlob, pbSignedHash;
    PKeyPack_Description pKpDesc;
    DWORD i, cbSignedHash, cbRequired = 0;
    
    SetLastError(ERROR_SUCCESS);

    //
    // make sure that the signed key blob is of the minimum size
    //

    cbRequired = ( 10 * sizeof( DWORD ) ) + ( 3 * sizeof( FILETIME ) ) + 
                   sizeof( GUID ) ;

    if( cbSignedBlob < cbRequired )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // get a certificate context for the signer's certificate
    //

    dwRetCode = GetCertificate( cbSignerCert,
                                pbSignerCert,
                                hCryptProv,
                                &pCertContext,
                                &hCertStore );

    if( ERROR_SUCCESS != dwRetCode )
    {
        SetLastError(dwRetCode);
        goto ErrorReturn;
    }
    
    //
    // Verify the signer's certificate and the certificate chain that issued the
    // certificate.
    //

    dwRetCode = VerifyCertificateChain( hCertStore, pCertContext, 
                                        cbRootCertificate, pbRootCertificate );

    if( ERROR_SUCCESS != dwRetCode )
    {
        SetLastError(dwRetCode);
        goto ErrorReturn;
    }

    //
    // unpack the signed blob
    //
    memcpy( &pLicenseKeyPack->dwVersion, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->dwKeypackType, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->dwDistChannel, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->KeypackSerialNum, pbCopyPos, sizeof( GUID ) );
    pbCopyPos += sizeof( GUID );
    
    memcpy( &pLicenseKeyPack->IssueDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->ActiveDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->ExpireDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->dwBeginSerialNum, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwQuantity, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->cbProductId, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbProductId )
    {
        cbRequired += pLicenseKeyPack->cbProductId;

        if( cbSignedBlob < cbRequired )
        {
            SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
            goto ErrorReturn;
        }

        pLicenseKeyPack->pbProductId = LocalAlloc( GPTR, pLicenseKeyPack->cbProductId );

        if( NULL == pLicenseKeyPack->pbProductId )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbProductId, pbCopyPos, pLicenseKeyPack->cbProductId );
        pbCopyPos += pLicenseKeyPack->cbProductId;
    }

    memcpy( &pLicenseKeyPack->dwProductVersion, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwPlatformId, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwLicenseType, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwDescriptionCount, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->dwDescriptionCount )
    {
        //
        // allocate memory for the keypack descriptions structure
        //

        pLicenseKeyPack->pDescription = LocalAlloc( GPTR, ( sizeof( KeyPack_Description ) * 
                                        pLicenseKeyPack->dwDescriptionCount ) );

        if( NULL == pLicenseKeyPack->pDescription )
        {
            goto ErrorReturn;
        }
        
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription; 
             i < pLicenseKeyPack->dwDescriptionCount; 
             i++, pKpDesc++ )
        {
            cbRequired += ( sizeof( LCID ) + 2* (sizeof( DWORD ) ));

            if( cbSignedBlob < cbRequired)
            {
                SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
                goto ErrorReturn;

            }

            memcpy( &pKpDesc->Locale, pbCopyPos, sizeof( LCID ) );
            pbCopyPos += sizeof( LCID );

            memcpy( &pKpDesc->cbProductName, pbCopyPos, sizeof( DWORD ) );
            pbCopyPos += sizeof( DWORD );

            if( pKpDesc->cbProductName )
            {
                //
                // allocate memory for product name
                //
                
                cbRequired += (pKpDesc->cbProductName);

                if( cbSignedBlob < cbRequired)
                {
                    SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
                    goto ErrorReturn;

                }

                pKpDesc->pbProductName = LocalAlloc( GPTR, pKpDesc->cbProductName );

                if( NULL == pKpDesc->pbProductName )
                {
                    goto ErrorReturn;
                }

                //
                // copy the product name
                //

                memcpy( pKpDesc->pbProductName, pbCopyPos, pKpDesc->cbProductName );
                pbCopyPos += pKpDesc->cbProductName;
            }

            memcpy( &pKpDesc->cbDescription, pbCopyPos, sizeof( DWORD ) );
            pbCopyPos += sizeof( DWORD );

            if( pKpDesc->cbDescription )
            {
                //
                // allocate memory for the keypack description
                //
                cbRequired += (pKpDesc->cbDescription);

                if( cbSignedBlob < cbRequired)
                {
                    SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
                    goto ErrorReturn;
                }

                pKpDesc->pDescription = LocalAlloc( GPTR, pKpDesc->cbDescription );

                if( NULL == pKpDesc->pDescription )
                {
                    goto ErrorReturn;
                }

                //
                // copy the key pack description
                //

                memcpy( pKpDesc->pDescription, pbCopyPos, pKpDesc->cbDescription );
                pbCopyPos += pKpDesc->cbDescription;
            }
        }
    }

    cbRequired += ( 3 * sizeof( DWORD ));

    if( cbSignedBlob < cbRequired)
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        goto ErrorReturn;
    }

    memcpy( &pLicenseKeyPack->cbManufacturer, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbManufacturer )
    {
        cbRequired += (pLicenseKeyPack->cbManufacturer);

        if( cbSignedBlob < cbRequired)
        {
            SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
            goto ErrorReturn;

        }
        pLicenseKeyPack->pbManufacturer = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturer );

        if( NULL == pLicenseKeyPack->pbManufacturer )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbManufacturer, pbCopyPos, pLicenseKeyPack->cbManufacturer );
        pbCopyPos += pLicenseKeyPack->cbManufacturer;
    }

    memcpy( &pLicenseKeyPack->cbManufacturerData, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbManufacturerData )
    {
        cbRequired += (pLicenseKeyPack->cbManufacturerData);

        if( cbSignedBlob < cbRequired)
        {
            SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
            goto ErrorReturn;

        }

        pLicenseKeyPack->pbManufacturerData = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturerData );

        if( NULL == pLicenseKeyPack->pbManufacturerData )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbManufacturerData, pbCopyPos, pLicenseKeyPack->cbManufacturerData );
        pbCopyPos += pLicenseKeyPack->cbManufacturerData;
    }

    //
    // get the size and the pointer of the signed hash.
    //

    memcpy( &cbSignedHash, pbCopyPos, sizeof( DWORD ) );
    
    pbSignedHash = pbCopyPos + sizeof( DWORD );

    //
    // compute the hash
    //

    if( !CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &hCryptHash ) )
    {
        goto ErrorReturn;
    }

    
    if( !CryptHashData( hCryptHash, pbSignedBlob, (DWORD)(pbCopyPos - pbSignedBlob), 0 ) )
    {
        goto ErrorReturn;
    }

    //
    // import the public key
    //

    if( !CryptImportPublicKeyInfoEx( hCryptProv, X509_ASN_ENCODING, 
                                     &pCertContext->pCertInfo->SubjectPublicKeyInfo, 
                                     CALG_RSA_SIGN, 0, NULL, &hPubKey ) )
    {
        goto ErrorReturn;
    }
    
    //
    // use the public key to verify the signed hash
    //

    if( !CryptVerifySignature( hCryptHash, pbSignedHash, cbSignedHash, hPubKey, 
                               NULL, 0) )
    {
        goto ErrorReturn;
    }    
    
ErrorReturn:

    dwRetCode = GetLastError();

    if( hCryptHash )
    {
        CryptDestroyHash( hCryptHash );
    }

    if( hPubKey )
    {
        CryptDestroyKey( hPubKey );
    }

    if( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );
    }

    if( hCertStore )
    {
        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );        
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
//
// GetCertificate
//
// Get the first certificate from the certificate blob.  The certificate blob
// is in fact a certificate store that may contain a chain of certificates.
// This function also return handles to the crypto provider and the certificate
// store.
//
///////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
GetCertificate(
    DWORD               cbCertificateBlob,
    PBYTE               pbCertificateBlob,
    HCRYPTPROV          hCryptProv,
    PCCERT_CONTEXT    * ppCertContext,
    HCERTSTORE        * phCertStore )
{
    CRYPT_DATA_BLOB CertBlob;
    DWORD dwRetCode = ERROR_SUCCESS;
    
    //
    // Open the PKCS7 certificate store
    //
    
    CertBlob.cbData = cbCertificateBlob;
    CertBlob.pbData = pbCertificateBlob;

    *phCertStore = CertOpenStore( sz_CERT_STORE_PROV_PKCS7,
                                  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                  hCryptProv,
                                  CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                  &CertBlob );

    if( NULL == ( *phCertStore ) )
    {
        return( GetLastError() );
    }

    //
    // get the first certificate from the store
    //

    *ppCertContext = CertEnumCertificatesInStore( *phCertStore, NULL );
    
    if( NULL == ( *ppCertContext ) )
    {
        return( GetLastError() );
    }
                    
    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
//
// VerifyCertificateChain
//
// Verify the certificate represented by the cert context against the 
// issuers in the certificate store.  The caller may provide a root
// certificate so that all issuers are eventually verified against this
// root certificate.  If no root certificate is provided, then the last
// issuer in the chain must be a self-signing issuer.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
VerifyCertificateChain( 
    HCERTSTORE          hCertStore, 
    PCCERT_CONTEXT      pCertContext,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate )
{
    DWORD dwRetCode = ERROR_SUCCESS, dwFlags;
    PCCERT_CONTEXT pRootCertCtx = NULL;
    PCCERT_CONTEXT pIssuerCertCtx = NULL;
    PCCERT_CONTEXT pCurrentContext = NULL;
#ifdef IGNORE_EXPIRATION
    LONG lRet;
    HKEY hKey = NULL;
#endif

    if( ( 0 != cbRootCertificate ) && ( NULL != pbRootCertificate ) )
    {
        //
        // Get a certificate context for the root certificate
        //

        pRootCertCtx = CertCreateCertificateContext( X509_ASN_ENCODING, 
                                                     pbRootCertificate,
                                                     cbRootCertificate );

        if( NULL == pRootCertCtx )
        {
            dwRetCode = GetLastError();
            goto done;
        }
    }

    //
    // Verify the certificate chain.  The time, signature and validity of
    // the subject certificate is verified.  Only the signatures are verified
    // for the certificates in the issuer chain.
    //
#ifdef IGNORE_EXPIRATION
    //Verify if registry key exists and ignore time check

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        LICENSE_EXPIRATION_IGNORE ,
                        0,
                        KEY_READ ,
                        &hKey );    

    if( ERROR_SUCCESS == lRet )
    { 

        dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG;
    }
    else
    {
#endif
           dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG |
                  CERT_STORE_TIME_VALIDITY_FLAG;
#ifdef IGNORE_EXPIRATION
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }
#endif

    pCurrentContext = CertDuplicateCertificateContext( pCertContext );

    if (NULL == pCurrentContext)
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    do
    {   
        pIssuerCertCtx = NULL;
     
        pIssuerCertCtx = CertGetIssuerCertificateFromStore( hCertStore,
                                                            pCurrentContext,
                                                            pIssuerCertCtx,
                                                            &dwFlags );
        if( pIssuerCertCtx )
        {            
            //
            // Found the issuer, verify that the checks went OK
            //

            dwRetCode = GetCertVerificationResult( dwFlags );

            if( ERROR_SUCCESS != dwRetCode )
            {
                break;
            }
            
            //
            // only verify the signature for subsequent issuer certificates
            //

            dwFlags = CERT_STORE_SIGNATURE_FLAG;

            //
            // free the current certificate context and make the current issuer certificate
            // the subject certificate for the next iteration.
            //

            CertFreeCertificateContext( pCurrentContext );
            
            pCurrentContext = pIssuerCertCtx;
            
        }
        
    } while( pIssuerCertCtx );


    if( ERROR_SUCCESS != dwRetCode )
    {
        //
        // encountered some error while verifying the certificate
        //

        goto done;
    }

    //
    // we got here because we have walked through the chain of issuers in the
    // store.  The last issuer in the chain may or may not be a self signing root.
    //

    if( pRootCertCtx )
    {
        //
        // The caller has specified a root certificate that must be used.  Verify the
        // last issuer against this root certificate regardless of whether it is a
        // self signing root.
        //

        dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG  |
                  CERT_STORE_TIME_VALIDITY_FLAG;

        if( ( NULL == pCurrentContext ) || 
            ( !CertVerifySubjectCertificateContext( pCurrentContext, pRootCertCtx, &dwFlags ) ) )
        {
            dwRetCode = GetLastError();
            goto done;
        }

        //
        // get the certificate verification result
        //

        dwRetCode = GetCertVerificationResult( dwFlags );
    }
    else
    {
        //
        // if the caller did not specify a CA root certificate, make sure that the root
        // issuer of the certificate is a self-signed root.  Otherwise, return an error
        //

        if( CRYPT_E_SELF_SIGNED != GetLastError() )
        {
            dwRetCode = GetLastError();
        }
    }

done:
    
    if( pRootCertCtx )
    {
        CertFreeCertificateContext( pRootCertCtx );
    }

    if( pCurrentContext )
    {
        CertFreeCertificateContext( pCurrentContext );
    }

    if( pIssuerCertCtx )
    {
        CertFreeCertificateContext( pIssuerCertCtx );
    }

    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
GetCertVerificationResult(
    DWORD dwFlags )
{
    if( dwFlags & CERT_STORE_SIGNATURE_FLAG )
    {
        //
        // The certificate signature did not verify
        //

        return( (DWORD )NTE_BAD_SIGNATURE );

    }
            
    if( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
    {
        //
        // The certificate has expired
        //

        return( ( DWORD )CERT_E_EXPIRED );
    }

    //
    // check if the cert has been revoked
    //

    if( dwFlags & CERT_STORE_REVOCATION_FLAG ) 
    {            
        if( !( dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            //
            // The certificate has been revoked
            //
                    
            return( ( DWORD )CERT_E_REVOKED );
        }
    }

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\inc\licemem.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997 - 1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef _LICEMEM_H_
#define _LICEMEM_H_

///////////////////////////////////////////////////////////////////////////////
// Memory API
//

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS 
LicenseMemoryAllocate( 
    ULONG Len, 
    PVOID UNALIGNED * ppMem );


VOID     
LicenseMemoryFree( 
    PVOID UNALIGNED * ppMem );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\clrhouse\keypklib\precomp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        precomp.h
//
// Contents:    precompile header file
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>
#include <mbstring.h>

#include "licekpak.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\inc\sysapi.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        sysapi.h
//
// Contents:    Support APIs used by licensing code
//
// History:     01-10-98    FredCh  Created
//
//-----------------------------------------------------------------------------


#ifndef _SYSAPI_H_
#define _SYSAPI_H_

#include "protect.h"
#include "licemem.h"

///////////////////////////////////////////////////////////////////////////////
// Binary blob API
//

VOID
CopyBinaryBlob(
    PBYTE           pbBuffer, 
    PBinary_Blob    pbbBlob, 
    DWORD *         pdwCount );


LICENSE_STATUS
GetBinaryBlob(
    PBinary_Blob    pBBlob,
    DWORD           dwMsgSize,
    PBYTE           pMessage,
    PDWORD          pcbProcessed );


VOID
FreeBinaryBlob(
    PBinary_Blob pBlob );


#define GetBinaryBlobSize( _Blob ) sizeof( WORD ) + sizeof( WORD ) + _Blob.wBlobLen


#define InitBinaryBlob( _pBlob )    \
    ( _pBlob )->pBlob = NULL;       \
    ( _pBlob )->wBlobLen = 0;       


///////////////////////////////////////////////////////////////////////////////
// Hydra server certificate, public and private key API
//

LICENSE_STATUS
GetServerCertificate(
    CERT_TYPE       CertType,
    PBinary_Blob    pCertBlob,
    DWORD           dwKeyAlg );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\decode.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        decode.h
//
// Contents:    License decoding API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#ifndef _DECODE_H_
#define _DECODE_H_

LICENSE_STATUS
DecodeLicense(
    PLicense_Verification_Data    pDecodedData,
    DWORD                         cbLicense,
    PBYTE                         pLicense );


LICENSE_STATUS
DecodeLicenseObject(
    LPCSTR          lpszStructType,
    const BYTE   *  pbEncoded,
    DWORD           cbEncoded,
    PVOID *         ppObject );


LICENSE_STATUS
DecodeSubjectField(
    BYTE *                      pbEncoded, 
    DWORD                       cbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeLicenseExtension( 
    DWORD               cExt, 
    PCERT_EXTENSION     pExt,
    PBYTE *             ppExtensionData,
    LPSTR               pszExtensionOID );


LICENSE_STATUS
DecodeSignedContent(
    BYTE *                      pbEncoded,
    DWORD                       cbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeLicenseInfo( 
    PCERT_INFO                  pInfo,
    DWORD                       cbEncoded,
    PBYTE                       pbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
PrintLicenseInfo( 
    PCERT_INFO                  pInfo,
    DWORD                       cbEncoded,
    PBYTE                       pbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeName(
    BYTE *pbEncoded, 
    DWORD cbEncoded );


void 
PrintBytes(
    LPCSTR  pszHdr, 
    BYTE    *pb, 
    DWORD   cbSize );


LPCSTR 
FileTimeText( 
    FILETIME *pft );


void 
PrintExtensions(
    DWORD           cExt, 
    PCERT_EXTENSION pExt);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\hspack.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "precomp.h"

#define EXTENDED_ERROR_CAPABILITY 0x80


///////////////////////////////////////////////////////////////////////////////
VOID
CopyBinaryBlob(
    PBYTE           pbBuffer, 
    PBinary_Blob    pbbBlob, 
    DWORD *         pdwCount )
{
    *pdwCount = 0;

    //
    // First copy the wBlobType data;
    //

    memcpy( pbBuffer, &pbbBlob->wBlobType, sizeof( WORD ) );
    pbBuffer += sizeof( WORD );
    *pdwCount += sizeof( WORD );

    //
    // Copy the wBlobLen data
    //

    memcpy( pbBuffer, &pbbBlob->wBlobLen, sizeof( WORD ) );
    pbBuffer += sizeof( WORD );
    *pdwCount += sizeof( WORD );

    if( 0 == pbbBlob->wBlobLen )
    {
        return;
    }

    //
    // Copy the actual data
    //

    memcpy( pbBuffer, pbbBlob->pBlob, pbbBlob->wBlobLen );
    *pdwCount += pbbBlob->wBlobLen;

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetBinaryBlob(
    PBinary_Blob    pBBlob,
    DWORD           dwMsgSize,
    PBYTE           pMessage,
    PDWORD          pcbProcessed )
{
    PBinary_Blob    pBB;
    LICENSE_STATUS  Status;

    if(dwMsgSize < 2 * sizeof(WORD))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    pBB = ( PBinary_Blob )pMessage;
    
    pBBlob->wBlobType = pBB->wBlobType;
    pBBlob->wBlobLen = pBB->wBlobLen;
    pBBlob->pBlob = NULL;

    *pcbProcessed = 2 * ( sizeof( WORD ) );
        
    if( 0 == pBBlob->wBlobLen )
    {
        return( LICENSE_STATUS_OK );
    }

    if(dwMsgSize < (2 * sizeof(WORD)) + pBB->wBlobLen)
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Check that strings are NULL terminated
    //
    switch (pBB->wBlobType)
    {
        case BB_CLIENT_USER_NAME_BLOB:
        case BB_CLIENT_MACHINE_NAME_BLOB:
            if ('\0' != pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 1])
            {
                __try
                {
                    //
                    // Handle bug in old client, where length is off by one
                    //
                    if ('\0' == pMessage[(2 * sizeof(WORD)) + pBB->wBlobLen])
                    {
                        pBBlob->wBlobLen++;
                        break;
                    }
                }
                __except( EXCEPTION_EXECUTE_HANDLER )
                {
                    return( LICENSE_STATUS_INVALID_INPUT );
                }

                //
                // Handle WTB client bug - send wrong data size.
                // At this stage of licensing, we don't really care about
                // client's machine and user name
                //
                pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 1] = '\0';
                if(!(pBB->wBlobLen & 0x01))
                {
                    //
                    // Even length, assuming UNICODE, wBlobLen must > 1 to
                    // come to here
                    //
                    pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 2] = '\0';
                }
                
                //return( LICENSE_STATUS_INVALID_INPUT );
            }
            break;
    }

    //
    // allocate memory for and copy the actual data
    //
    if( BB_CLIENT_USER_NAME_BLOB == pBB->wBlobType || 
        BB_CLIENT_MACHINE_NAME_BLOB == pBB->wBlobType )
    {
        // WINCE client sends UNICODE, add extra NULL at the end
        Status = LicenseMemoryAllocate( ( DWORD )pBBlob->wBlobLen + sizeof(WCHAR), &(pBBlob->pBlob) );
    }
    else
    {
        Status = LicenseMemoryAllocate( ( DWORD )pBBlob->wBlobLen, &(pBBlob->pBlob) );
    }

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }
    
    __try
    {
        memcpy( pBBlob->pBlob, pMessage + ( 2 * sizeof( WORD ) ), pBBlob->wBlobLen );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        LicenseMemoryFree( &pBBlob->pBlob );

        return( LICENSE_STATUS_INVALID_INPUT );
    }


    *pcbProcessed += ( DWORD )pBBlob->wBlobLen;

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
VOID
FreeBinaryBlob(
    PBinary_Blob pBlob )
{
    if( pBlob->pBlob )
    {
        LicenseMemoryFree( &pBlob->pBlob );
        pBlob->wBlobLen = 0;
    }

    return;
}


    
///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerLicenseRequest(
    DWORD                           dwProtocolVersion,
    PHydra_Server_License_Request   pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble        Header;
    DWORD           i, cbCopied;
    PBinary_Blob    pBlob;
    LICENSE_STATUS  Status = LICENSE_STATUS_OK;
    PBYTE           pNetworkBuf;    

    ASSERT( pCanonical );
    
    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );        
    }

    //
    // calculate the size needed for network format
    //

    Header.wMsgSize = (WORD)(sizeof( Preamble ) + 
                      LICENSE_RANDOM +
                      sizeof( DWORD ) + 
                      sizeof( DWORD ) + pCanonical->ProductInfo.cbCompanyName +
                      sizeof( DWORD ) + pCanonical->ProductInfo.cbProductID +
                      GetBinaryBlobSize( pCanonical->KeyExchngList ) +
                      GetBinaryBlobSize( pCanonical->ServerCert ) +
                      sizeof( DWORD ) +
                      ( pCanonical->ScopeList.dwScopeCount * ( sizeof( WORD ) + sizeof( WORD ) ) ) );

    for( i = 0, pBlob = pCanonical->ScopeList.Scopes; 
         i < pCanonical->ScopeList.dwScopeCount; 
         i++ )
    {
        Header.wMsgSize += pBlob->wBlobLen;
        pBlob++;
    }

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_LICENSE_REQUEST;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the server random number
    //

    memcpy( pNetworkBuf, pCanonical->ServerRandom, LICENSE_RANDOM );
    pNetworkBuf += LICENSE_RANDOM;

    //
    // copy the product info
    //

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.dwVersion, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.cbCompanyName, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->ProductInfo.pbCompanyName, 
            pCanonical->ProductInfo.cbCompanyName );
    pNetworkBuf += pCanonical->ProductInfo.cbCompanyName;

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.cbProductID, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->ProductInfo.pbProductID, 
            pCanonical->ProductInfo.cbProductID );
    pNetworkBuf += pCanonical->ProductInfo.cbProductID;

    //
    // copy the key exchange list
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->KeyExchngList, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the hydra server certificate
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->ServerCert, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the scope list
    //

    memcpy( pNetworkBuf, &pCanonical->ScopeList.dwScopeCount, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    for( i = 0, pBlob = pCanonical->ScopeList.Scopes; 
         i < pCanonical->ScopeList.dwScopeCount; 
         i++ )
    {
        CopyBinaryBlob( pNetworkBuf, pBlob, &cbCopied );
        pNetworkBuf += cbCopied;
        pBlob++;
    }
    
PackError:

    return( Status );

}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerPlatformChallenge(
    DWORD                               dwProtocolVersion,
    PHydra_Server_Platform_Challenge    pCanonical,
    PBYTE*                              ppNetwork,
    DWORD*                              pcbNetwork )
{
    Preamble        Header;
    DWORD           cbCopied;
    PBinary_Blob    pBlob;
    LICENSE_STATUS  Status = LICENSE_STATUS_OK;
    PBYTE           pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );        
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      sizeof( DWORD ) +
                      GetBinaryBlobSize( pCanonical->EncryptedPlatformChallenge ) +
                      LICENSE_MAC_DATA; 

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_PLATFORM_CHALLENGE;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the connect flag
    //

    memcpy( pNetworkBuf, &pCanonical->dwConnectFlags, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    //
    // copy the encrypted platform challenge
    //
    
    CopyBinaryBlob( pNetworkBuf, &pCanonical->EncryptedPlatformChallenge, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the MAC
    //

    memcpy( pNetworkBuf, pCanonical->MACData, LICENSE_MAC_DATA );

    
PackError:

    return( Status );    
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerNewLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_New_License       pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble Header;
    DWORD cbCopied;
    PBinary_Blob pBlob;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PBYTE pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      GetBinaryBlobSize( pCanonical->EncryptedNewLicenseInfo ) +
                      LICENSE_MAC_DATA;

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_NEW_LICENSE;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the encrypted new license info
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->EncryptedNewLicenseInfo, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the MAC
    //

    memcpy( pNetworkBuf, pCanonical->MACData, LICENSE_MAC_DATA );
    
PackError:

    return( Status );    

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerUpgradeLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_Upgrade_License   pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    LICENSE_STATUS Status;
    PPreamble pHeader;

    Status = PackHydraServerNewLicense( dwProtocolVersion, pCanonical, ppNetwork, pcbNetwork );

    if( LICENSE_STATUS_OK == Status )
    {
        //
        // make this an upgrade license message
        //

        pHeader = ( PPreamble )*ppNetwork;
        pHeader->bMsgType = HS_UPGRADE_LICENSE;
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerErrorMessage(
    DWORD                           dwProtocolVersion,
    PLicense_Error_Message          pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble Header;
    DWORD cbCopied;
    PBinary_Blob pBlob;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PBYTE pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      sizeof( DWORD ) +
                      sizeof( DWORD ) +
                      GetBinaryBlobSize( pCanonical->bbErrorInfo );

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // set up preamble
    //

    Header.bMsgType = GM_ERROR_ALERT; 
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the error code, state transition and error info
    //

    memcpy( pNetworkBuf, &pCanonical->dwErrorCode, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->dwStateTransition, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    CopyBinaryBlob( pNetworkBuf, &pCanonical->bbErrorInfo, &cbCopied );
    
PackError:

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackNewLicenseInfo( 
    PNew_License_Info               pCanonical,
    PBYTE*                          ppNetwork, 
    DWORD*                          pcbNetwork )
{
    DWORD cbBufNeeded;
    PBYTE pNetworkBuf;    
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed and check that the output
    // buffer is large enough
    //

    cbBufNeeded = 5 * sizeof( DWORD ) +
                  pCanonical->cbScope +
                  pCanonical->cbCompanyName +
                  pCanonical->cbProductID +
                  pCanonical->cbLicenseInfo;

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( cbBufNeeded, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    *pcbNetwork = cbBufNeeded;
    
    pNetworkBuf = *ppNetwork;

    //
    // start copying the data
    //

    memcpy( pNetworkBuf, &pCanonical->dwVersion, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->cbScope, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbScope, pCanonical->cbScope );
    pNetworkBuf += pCanonical->cbScope;

    memcpy( pNetworkBuf, &pCanonical->cbCompanyName, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbCompanyName, pCanonical->cbCompanyName );
    pNetworkBuf += pCanonical->cbCompanyName;

    memcpy( pNetworkBuf, &pCanonical->cbProductID, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbProductID, pCanonical->cbProductID );
    pNetworkBuf += pCanonical->cbProductID;

    memcpy( pNetworkBuf, &pCanonical->cbLicenseInfo, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbLicenseInfo, pCanonical->cbLicenseInfo );
    pNetworkBuf += pCanonical->cbLicenseInfo;

done:

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackExtendedErrorInfo( 
                   UINT32       uiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo)
{
    WORD cbBufNeeded;
    PBYTE pbNetworkBuf;
    WORD wBlobVersion = BB_ERROR_BLOB_VERSION;
    WORD wBlobReserved = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    if (NULL == pbbErrorInfo)
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize in case of errors
    //

    pbbErrorInfo->wBlobLen = 0;

    //
    // calculate the buffer size needed
    //

    cbBufNeeded = sizeof(WORD) + sizeof(WORD) + sizeof(UINT32);

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( cbBufNeeded, &(pbbErrorInfo->pBlob) );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    pbbErrorInfo->wBlobLen = cbBufNeeded;

    pbNetworkBuf = pbbErrorInfo->pBlob;

    //
    // start copying the data
    //

    memcpy( pbNetworkBuf, &wBlobVersion, sizeof( WORD ) );
    pbNetworkBuf += sizeof( WORD );

    memcpy( pbNetworkBuf, &wBlobReserved, sizeof( WORD ) );
    pbNetworkBuf += sizeof( WORD );

    memcpy( pbNetworkBuf, &uiExtendedErrorInfo, sizeof( UINT32 ) );

done:

    return ( Status );
}

///////////////////////////////////////////////////////////////////////////////
// Functions for unpacking different Hydra Client Messages from 
// simple binary blobs to corresponding structure
//

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientErrorMessage(
    PBYTE                           pbMessage,
    DWORD                           cbMessage,
    PLicense_Error_Message          pCanonical,
    BOOL*                           pfExtendedError)
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0, cbRemainder;    

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );
    ASSERT( NULL != pfExtendedError );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) ||
        ( pfExtendedError == NULL))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *pfExtendedError = FALSE;

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( GM_ERROR_ALERT != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientErrorMessage: received unexpected message type %c\n", pHeader->bMsgType );        
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }
    if(pHeader->bVersion & EXTENDED_ERROR_CAPABILITY)
    {
        *pfExtendedError = TRUE;
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 2 * sizeof( DWORD );


    if( cbMessage < ( WORD )cbUnpacked )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    cbRemainder = cbMessage - cbUnpacked;

    //
    // get the license error structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwErrorCode, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );
    
    memcpy( &pCanonical->dwStateTransition, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    Status = GetBinaryBlob( &( pCanonical->bbErrorInfo ), cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }
    
    cbUnpacked += cbProcessed;

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientLicenseInfo(
    PBYTE                           pbMessage,
    DWORD                           cbMessage, 
    PHydra_Client_License_Info      pCanonical,
    BOOL*                           pfExtendedError)
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0, cbRemainder = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );
    ASSERT( NULL != pfExtendedError );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) ||
        ( NULL == pfExtendedError))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *pfExtendedError = FALSE;
    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( HC_LICENSE_INFO != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientLicenseInfo: received unexpected message type %c\n", pHeader->bMsgType );        
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    if(pHeader->bVersion & EXTENDED_ERROR_CAPABILITY)
    {
        *pfExtendedError = TRUE;
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 2 * sizeof( DWORD ) +
                 LICENSE_RANDOM +
                 LICENSE_MAC_DATA;

    cbRemainder = cbMessage - cbUnpacked;

    if( cbMessage < ( WORD )cbUnpacked )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // get the license info structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwPrefKeyExchangeAlg, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->dwPlatformID, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->ClientRandom, pNetwork, LICENSE_RANDOM );
    pNetwork += LICENSE_RANDOM;

    Status = GetBinaryBlob( &pCanonical->EncryptedPreMasterSecret, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    cbRemainder = cbMessage - cbUnpacked;

    Status = GetBinaryBlob( &pCanonical->LicenseInfo, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }
    
    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    cbRemainder = cbMessage- cbUnpacked;

    Status = GetBinaryBlob( &pCanonical->EncryptedHWID, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }
    
    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    memcpy( pCanonical->MACData, pNetwork, LICENSE_MAC_DATA );

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientNewLicenseRequest(
    PBYTE                               pbMessage,
    DWORD                               cbMessage,
    PHydra_Client_New_License_Request   pCanonical,
    BOOL*                               pfExtendedError)
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0, cbRemainder = 0;    

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );
    ASSERT( NULL != pfExtendedError );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) ||
        ( NULL == pfExtendedError))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *pfExtendedError = FALSE;

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;    

    if( HC_NEW_LICENSE_REQUEST != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientNewLicenseRequest: received unexpected message type %c\n", pHeader->bMsgType );
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    if(pHeader->bVersion & EXTENDED_ERROR_CAPABILITY)
    {
        *pfExtendedError = TRUE;
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 2 * sizeof( DWORD ) +
                 LICENSE_RANDOM;

    cbRemainder = cbMessage - cbUnpacked;

    if( cbMessage < ( WORD )cbUnpacked )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // get the new license request structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwPrefKeyExchangeAlg, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->dwPlatformID, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->ClientRandom, pNetwork, LICENSE_RANDOM );
    pNetwork += LICENSE_RANDOM;

    Status = GetBinaryBlob( &pCanonical->EncryptedPreMasterSecret, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;
    pNetwork += cbProcessed;

    cbRemainder = cbMessage - cbUnpacked;

    //
    // we changed the licensing protocol to include the client user and machine
    // name.  So to prevent an older client that does not have the user and machine
    // name binary blobs from crashing the server, we add this check for the
    // message length.
    //

    if( pHeader->wMsgSize <= cbUnpacked )
    {
#if DBG
        DbgPrint( "UnPackHydraClientNewLicenseRequest: old licensing protocol\n" );
#endif
        pCanonical->ClientUserName.pBlob = NULL;
        pCanonical->ClientMachineName.pBlob = NULL;

        //
        // make these 2 fields optional for now.
        //

        return( Status );
    }
        
    Status = GetBinaryBlob( &pCanonical->ClientUserName, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;
    pNetwork += cbProcessed;

    cbRemainder = cbMessage - cbUnpacked;

    Status = GetBinaryBlob( &pCanonical->ClientMachineName, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientPlatformChallengeResponse(
    PBYTE                                       pbMessage,
    DWORD                                       cbMessage,
    PHydra_Client_Platform_Challenge_Response   pCanonical,
    BOOL*                                       pfExtendedError)
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0, cbRemainder = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );
    ASSERT( NULL != pfExtendedError );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) ||
        ( NULL == pfExtendedError ))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *pfExtendedError = FALSE;
    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( HC_PLATFORM_CHALENGE_RESPONSE != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientPlatformChallengeResponse: received unexpected message type %c\n", pHeader->bMsgType );
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }
    if(pHeader->bVersion & EXTENDED_ERROR_CAPABILITY)
    {
        *pfExtendedError = TRUE;
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 LICENSE_MAC_DATA;

    cbRemainder = cbMessage - cbUnpacked;

    if( cbMessage < ( WORD )cbUnpacked )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // get the platform challenge response structure
    //

    pNetwork = pbMessage + sizeof( Preamble );

    Status = GetBinaryBlob( &pCanonical->EncryptedChallengeResponse, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    cbRemainder = cbMessage - cbUnpacked;

    Status = GetBinaryBlob( &pCanonical->EncryptedHWID, cbRemainder, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    memcpy( pCanonical->MACData, pNetwork, LICENSE_MAC_DATA );

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\inc\protect.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef _PROTECT_H_
#define _PROTECT_H_

//////////////////////////////////////////////////////////////////////////////
//  Citrical section macros
//

#define INITLOCK( _sem ) \
{ \
    InitializeCriticalSection( _sem ); \
}

#define DELETELOCK( _sem ) \
{ \
    DeleteCriticalSection( _sem ); \
}

#define LOCK( _sem ) \
{ \
    EnterCriticalSection( _sem ); \
}

#define UNLOCK( _sem ) \
{ \
    LeaveCriticalSection( _sem ); \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\inc\licemem.inc ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
LicenseMemoryAllocate( ULONG Length, PVOID UNALIGNED * ppMemory )
{    
    if( 0 == Length )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppMemory = LocalAlloc( LMEM_ZEROINIT, Length );

    if( NULL == *ppMemory )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
VOID
LicenseMemoryFree( PVOID UNALIGNED * ppMemory )
{
    if( NULL == *ppMemory )
    {
        return;
    }

    LocalFree( *ppMemory );
    *ppMemory = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\licprot.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licprot.c
//
// Contents:    Implementation of Hydra Server License Protocol API
//
// History:     02-08-00    RobLeit  Created
//
//-----------------------------------------------------------------------------

#include "precomp.h"
#include <rpcnterr.h>
#include <lmapibuf.h>

#include "licemem.inc"
#include <srvdef.h>
#include <tserrs.h>
#include <locale.h>
BOOL g_fSetLocale = FALSE;
VOID 
LogLicensingTimeBombExpirationEvent();

void
ThrottleLicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings );

LICENSE_STATUS
LsStatusToLicenseStatus(
    DWORD       LsStatus,
    DWORD       LsStatusDefault
);

#define LS_DISCOVERY_TIMEOUT (1*1000)

// Copied from tlserver\server\srvdef.h
#define PERMANENT_LICENSE_EXPIRE_DATE   INT_MAX

#define SECONDS_IN_A_DAY                86400   // number of seconds in a day

#define TERMINAL_SERVICE_EVENT_LOG      L"TermService"

#define HARDCODED_CHALLENGE_DATA        _TEXT("TEST")

///////////////////////////////////////////////////////////////////////////////
//
// Global variables
//

HANDLE g_hEventLog = NULL;
BOOL g_fEventLogOpen = FALSE;
CRITICAL_SECTION g_EventLogCritSec;
DWORD g_dwLicenseExpirationLeeway = PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY;
DWORD g_dwTerminalServerVersion;

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
InitializeProtocolLib()
{
    LICENSE_STATUS lsStatus;    

    //
    // initialize the cert util library
    //

    if (LSInitCertutilLib( 0 ))
    {
        __try
        {
            INITLOCK( &g_EventLogCritSec );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {

            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        g_hEventLog = RegisterEventSource( NULL, TERMINAL_SERVICE_EVENT_LOG );

        if (NULL != g_hEventLog)
        {
            g_fEventLogOpen = TRUE;
        }
    }
    else
    {
        return LICENSE_STATUS_SERVER_ABORT;
    }

    lsStatus = InitializeLicensingTimeBomb();

    if (lsStatus == LICENSE_STATUS_OK)
    {
        DWORD dwStatus;      
        HKEY hKey = NULL;

        DWORD dwOSVersion = GetVersion();
        g_dwTerminalServerVersion = (DWORD)(HIBYTE(LOWORD(dwOSVersion)));
        g_dwTerminalServerVersion |= (DWORD)(LOBYTE(LOWORD(dwOSVersion)) << 16);

        dwStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE, HYDRA_SERVER_PARAM, 0,
                NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey,
                NULL);

        if (dwStatus == ERROR_SUCCESS)
        {
            DWORD dwBuffer;
            DWORD cbBuffer = sizeof(DWORD);

            dwStatus = RegQueryValueEx(hKey, PERSEAT_LEEWAY_VALUE, NULL, NULL,
                    (LPBYTE)&dwBuffer, &cbBuffer);

            if (dwStatus == ERROR_SUCCESS)
            {
                g_dwLicenseExpirationLeeway = min(dwBuffer,
                        PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY);
            }
        }

        TSRNG_Initialize();

        if(hKey)
        RegCloseKey(hKey);
    }    

    return lsStatus;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ShutdownProtocolLib()
{
    //
    // shut down cert util library
    //

    g_fEventLogOpen = FALSE;

    DeregisterEventSource( g_hEventLog );

    g_hEventLog = NULL;

    DELETELOCK(&g_EventLogCritSec);

    LSShutdownCertutilLib();

    TSRNG_Shutdown();

    return( LICENSE_STATUS_OK );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CreateProtocolContext(
    IN  LPLICENSE_CAPABILITIES  pLicenseCap,
    OUT HANDLE *    phContext)
{
    LICENSE_STATUS Status;
    PHS_Protocol_Context pLicenseContext = NULL;

    //
    // allocate the protocol context
    //

    Status = LicenseMemoryAllocate( sizeof( HS_Protocol_Context ), &pLicenseContext );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    //
    // Note: InitializeCriticalSection could throw an exception during
    // low memory conditions.
    //

    __try
    {
        INITLOCK( &pLicenseContext->CritSec );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {

#if DBG
        DbgPrint( "LICPROT: CreateLicenseContext: InitializeCriticalSection exception: 0x%x\n",
                  GetExceptionCode() );
#endif

        Status = LICENSE_STATUS_OUT_OF_MEMORY;

        if( pLicenseContext )
        {           
           LicenseMemoryFree( &pLicenseContext );       
        }  
        return( Status );                
    }

    pLicenseContext->hLSHandle = NULL;
    pLicenseContext->State = INIT;
    pLicenseContext->dwProtocolVersion = LICENSE_HIGHEST_PROTOCOL_VERSION;
    pLicenseContext->fAuthenticateServer = TRUE;
    pLicenseContext->CertTypeUsed = CERT_TYPE_INVALID;
    pLicenseContext->dwKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;
    pLicenseContext->fLoggedProtocolError = FALSE;

    //
    // Initialize the crypto context parameters
    //

    pLicenseContext->CryptoContext.dwCryptState    = CRYPT_SYSTEM_STATE_INITIALIZED;
    pLicenseContext->CryptoContext.dwSessKeyAlg    = BASIC_RC4_128;
    pLicenseContext->CryptoContext.dwMACAlg        = MAC_MD5_SHA;



    if (NULL != pLicenseCap)
    {
        //
        // initialize the license context with the incoming data.
        //

        pLicenseContext->fAuthenticateServer = pLicenseCap->fAuthenticateServer;
        pLicenseContext->dwProtocolVersion = pLicenseCap->ProtocolVer;
    
        //
        // If the client is not authenticating the server, this means that
        // the client already has our certificate.  But we need to know which
        // certificate the client has.
        //

        if( FALSE == pLicenseContext->fAuthenticateServer )
        {
            pLicenseContext->CertTypeUsed = pLicenseCap->CertType;
        }

        //
        // remember the client's machine name
        //
        
        if( pLicenseCap->pbClientName )
        {
            Status = LicenseMemoryAllocate( 
                                           pLicenseCap->cbClientName,
                                           &pLicenseContext->ptszClientMachineName );
            
            if( LICENSE_STATUS_OK == Status )
            {
                //
                // copy the client machine name
                //
                
                memcpy( pLicenseContext->ptszClientMachineName, 
                        pLicenseCap->pbClientName,
                        pLicenseCap->cbClientName );
            }
            else
            {
                goto error;
            }
        }
    }
    else
    {
        pLicenseContext->ptszClientMachineName = NULL;
    }

    *phContext = ( HANDLE )pLicenseContext;

    return( Status );

error:

    //
    // encountered error creating context, free allocated memory before
    // returning
    //

    
    if( pLicenseContext )
    {
        DELETELOCK( &pLicenseContext->CritSec );

        if (pLicenseContext->ptszClientMachineName)
        {
            LicenseMemoryFree(&pLicenseContext->ptszClientMachineName);
        }

       LicenseMemoryFree( &pLicenseContext );
       
    }    

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
DeleteProtocolContext(
    HANDLE hContext )
{
    PHS_Protocol_Context pLicenseContext = ( PHS_Protocol_Context )hContext;

    if( NULL == pLicenseContext )
    {
        return( LICENSE_STATUS_INVALID_SERVER_CONTEXT );
    }

    LOCK( &pLicenseContext->CritSec );

    if (pLicenseContext->hLSHandle != NULL)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

    if( pLicenseContext->ProductInfo.pbCompanyName )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbCompanyName );
    }

    if( pLicenseContext->ProductInfo.pbProductID )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbProductID );
    }

    if( pLicenseContext->ptszClientUserName )
    {
        LicenseMemoryFree( &pLicenseContext->ptszClientUserName );
    }

    if( pLicenseContext->ptszClientMachineName )
    {
        LicenseMemoryFree( &pLicenseContext->ptszClientMachineName );
    }

    if( pLicenseContext->pbOldLicense )
    {
        LicenseMemoryFree( &pLicenseContext->pbOldLicense );
    }
    
    //
    // Free the license info that's being cached
    //

    if( pLicenseContext->pTsLicenseInfo )
    {
        FreeLicenseInfo( pLicenseContext->pTsLicenseInfo );

        LicenseMemoryFree( &pLicenseContext->pTsLicenseInfo );
    }

    UNLOCK( &pLicenseContext->CritSec );
 
    DELETELOCK( &pLicenseContext->CritSec );
    
    LicenseMemoryFree( &pLicenseContext );
        
    return( LICENSE_STATUS_OK );

}

///////////////////////////////////////////////////////////////////////////////
void
HandleErrorCondition( 
    PHS_Protocol_Context   pLicenseContext,
    PDWORD                      pcbOutBuf, 
    PBYTE *                     ppOutBuf, 
    LICENSE_STATUS *            pStatus )
{
    License_Error_Message ErrorMsg;
    LICENSE_STATUS licenseStatus;

    //
    // returns the correct error code based on the error condition
    //

    switch( *pStatus )
    {
    case( LICENSE_STATUS_NO_LICENSE_SERVER ):

        ErrorMsg.dwErrorCode            = GM_HS_ERR_NO_LICENSE_SERVER;
        ErrorMsg.dwStateTransition      = ST_NO_TRANSITION;
        
        break;

    case( LICENSE_STATUS_INVALID_MAC_DATA ):

        ErrorMsg.dwErrorCode            = GM_HC_ERR_INVALID_MAC;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;
        
        break;

    //
    // Handle all other error conditions as invalid client
    //

    case( LICENSE_STATUS_INVALID_RESPONSE ):        
    default:
        
        ErrorMsg.dwErrorCode            = GM_HS_ERR_INVALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;        
        
        break;
    }

    //
    // for now, we are not sending any error string
    //

    ErrorMsg.bbErrorInfo.wBlobType  = BB_ERROR_BLOB;
    ErrorMsg.bbErrorInfo.wBlobLen   = 0;
    ErrorMsg.bbErrorInfo.pBlob      = NULL;

    //
    // pack the error message
    //

    licenseStatus = PackHydraServerErrorMessage( 
                        pLicenseContext->dwProtocolVersion, 
                        &ErrorMsg, 
                        ppOutBuf, 
                        pcbOutBuf );

    if( LICENSE_STATUS_OK != licenseStatus )
    {
#if DBG
        DbgPrint( "HandleErrorConditions: cannot pack error message: 0x%x\n", *pStatus );
#endif
        *pStatus = LICENSE_STATUS_SERVER_ABORT;
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CreateHydraServerHello( 
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    Hydra_Server_License_Request LicenseRequest;
    LICENSE_STATUS Status;
    Binary_Blob ScopeBlob;
    CHAR szScope[] = SCOPE_NAME;
    DWORD dwCertSize;

    //
    // generate a server random number
    //

    if(!TSRNG_GenerateRandomBits( LicenseRequest.ServerRandom, LICENSE_RANDOM ))
    {
        Status =  LICENSE_STATUS_OUT_OF_MEMORY;
        goto no_request;
    }

    memcpy( pLicenseContext->CryptoContext.rgbServerRandom, 
            LicenseRequest.ServerRandom, 
            LICENSE_RANDOM );

    //
    // fill in the product info.  Allocate memory for and initialize the
    // license context copy of the product info and then just copy the
    // same product info to the license request.
    // NOTE: This info should probably be passed in in the future
    //

    Status = InitProductInfo( 
                        &( pLicenseContext->ProductInfo ), 
                        PRODUCT_INFO_SKU_PRODUCT_ID );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "CreateHydraServerHello: cannot init product info: 0x%x\n", Status );
#endif
        goto no_request;
    }


    memcpy( &LicenseRequest.ProductInfo, 
            &pLicenseContext->ProductInfo, 
            sizeof( Product_Info ) );    
    
    //
    // get the hydra server certificate and fill in the key exchange list
    //

    LicenseRequest.KeyExchngList.wBlobType    = BB_KEY_EXCHG_ALG_BLOB;
    LicenseRequest.KeyExchngList.wBlobLen     = sizeof( DWORD );
    LicenseRequest.KeyExchngList.pBlob        = ( PBYTE )&pLicenseContext->dwKeyExchangeAlg;

    LicenseRequest.ServerCert.pBlob = NULL;
    LicenseRequest.ServerCert.wBlobLen = 0;

    //
    // We may or may not have to send the client the certificate depending on whether the
    // client is authenticating the server.
    //

    if( TRUE == pLicenseContext->fAuthenticateServer )
    {
        //
        // decide on what kind of certificate to get depending on the client's version.
        // Pre-Hydra 5.0 clients only knows how to decode proprietory certificate.
        // Use X509 certificate for all other clients.
        //

        if( CERT_TYPE_INVALID == pLicenseContext->CertTypeUsed )
        {
            if( PREAMBLE_VERSION_3_0 > GET_PREAMBLE_VERSION( pLicenseContext->dwProtocolVersion ) )
            {
                pLicenseContext->CertTypeUsed = CERT_TYPE_PROPRIETORY;
            }
            else
            {
                pLicenseContext->CertTypeUsed = CERT_TYPE_X509;
            }
        }

        Status = TLSGetTSCertificate( 
                        pLicenseContext->CertTypeUsed,
                        &LicenseRequest.ServerCert.pBlob, 
                        &dwCertSize);

        LicenseRequest.ServerCert.wBlobLen = LOWORD(dwCertSize);
        LicenseRequest.ServerCert.wBlobType = BB_CERTIFICATE_BLOB;

        if( ( LICENSE_STATUS_OK != Status ) &&
            ( CERT_TYPE_X509 == pLicenseContext->CertTypeUsed ) )
        {
            //
            // if we cannot get the X509 certificate chain, use the proprietory
            // certificate.
            //

            pLicenseContext->CertTypeUsed = CERT_TYPE_PROPRIETORY;

            Status = TLSGetTSCertificate( 
                        pLicenseContext->CertTypeUsed,
                        &LicenseRequest.ServerCert.pBlob, 
                        &dwCertSize);

            LicenseRequest.ServerCert.wBlobLen = LOWORD(dwCertSize);
            LicenseRequest.ServerCert.wBlobType = BB_CERTIFICATE_BLOB;

        }

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: cannot get server certificate: %x\n", Status );
#endif
            goto no_request;
        }
    }

    //
    // fill in the scope info.  This info may be passed in in the future.
    //

    LicenseRequest.ScopeList.dwScopeCount       = 1;
    LicenseRequest.ScopeList.Scopes             = &ScopeBlob;

    ScopeBlob.wBlobType  = BB_SCOPE_BLOB;
    ScopeBlob.pBlob      = szScope;
    ScopeBlob.wBlobLen   = strlen( ScopeBlob.pBlob ) + 1;    

    strcpy( pLicenseContext->Scope, ScopeBlob.pBlob );

    //
    // Pack the server hello message into network format
    //

    Status = PackHydraServerLicenseRequest( 
                    pLicenseContext->dwProtocolVersion, 
                    &LicenseRequest, 
                    ppOutBuf, 
                    pcbOutBuf );

    //
    // free the memory containing the server certificate
    //

    if( LicenseRequest.ServerCert.pBlob )
    {
        TLSFreeTSCertificate( LicenseRequest.ServerCert.pBlob );
        LicenseRequest.ServerCert.pBlob = NULL;
    }
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto no_request;        
    }

    Status = LICENSE_STATUS_CONTINUE;

    //
    // change the state of the context
    //

    pLicenseContext->State = SENT_SERVER_HELLO;

    return( Status );

    //=========================================================================
    // Error return
    //=========================================================================

no_request:

    //
    // free memory and handles
    //

    if( pLicenseContext->ProductInfo.pbCompanyName )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbCompanyName );
    }

    if( pLicenseContext->ProductInfo.pbProductID )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbProductID );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleHelloResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    BOOL*   pfExtendedError)
{
    PPreamble pPreamble;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > sizeof( Preamble ) );

    if( ( NULL == pInBuf ) || ( sizeof( Preamble ) > cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the message preamble to determine how to unpack the message
    //

    pPreamble = ( PPreamble )pInBuf;

    if( HC_LICENSE_INFO == pPreamble->bMsgType )
    {
        //
        // Client has sent us its license
        //

        return( HandleClientLicense( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf, pfExtendedError ) );

    }
    else if( HC_NEW_LICENSE_REQUEST == pPreamble->bMsgType )
    {
        //
        // Client has requested for a new license
        //

        return( HandleNewLicenseRequest( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf, pfExtendedError ) );

    } 
    else if( GM_ERROR_ALERT == pPreamble->bMsgType )
    {
        //
        // Client has encountered an error
        //

        return( HandleClientError( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf, pfExtendedError ) );
    }

    //
    // The client response is invalid for the current server state
    //

    return( LICENSE_STATUS_INVALID_RESPONSE );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ChooseLicense( 
    PValidation_Info    pValidationInfo,
    DWORD               dwNumLicenses, 
    LICENSEDPRODUCT *   pLicenseInfo, 
    LPDWORD             pdwLicenseIndex,
    BOOL                fMatchingVersion )
{
    DWORD
        dwCurrentLicense,
        dwProductVersion;
    LICENSEDPRODUCT *
        pCurrentLicense = pLicenseInfo;
    BOOL
        fFoundLicense = FALSE;

    if( ( 0 >= dwNumLicenses ) || ( NULL == pLicenseInfo ) || ( NULL == pdwLicenseIndex ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Find a license with the license array that matches the criteria.
    // The caller may be looking for a license that matches the current product
    // version, or for a license that is later than the current product version.
    //
    
    for( dwCurrentLicense = 0; dwCurrentLicense < dwNumLicenses; dwCurrentLicense++ )
    {
        if( TERMSERV_CERT_VERSION_BETA == pCurrentLicense->dwLicenseVersion )
        {
            continue;
        }

        dwProductVersion = pCurrentLicense->pLicensedVersion->wMajorVersion;
        dwProductVersion <<= 16;
        dwProductVersion |= pCurrentLicense->pLicensedVersion->wMinorVersion;

        if( fMatchingVersion )
        {
            //
            // we should be looking for a license with a matching version
            //

            if( dwProductVersion == pValidationInfo->pProductInfo->dwVersion )
            {
                fFoundLicense = TRUE;
                break;
            }
        }
        else
        {
            //
            // Looking for a license that is later than the current product
            // version.
            //
            
            if( dwProductVersion > pValidationInfo->pProductInfo->dwVersion )
            {
                fFoundLicense = TRUE;
                break;
            }
        }

        //
        // continue looking for the license
        //
        
        pCurrentLicense++;                
    }

    if( FALSE == fFoundLicense )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    *pdwLicenseIndex = dwCurrentLicense;

    return( LICENSE_STATUS_OK );

}

///////////////////////////////////////////////////////////////////////////////
VOID
UpdateVerifyResult(
    LICENSE_STATUS * pCurrentStatus,
    LICENSE_STATUS   NewStatus )
{
    //
    // Update the current status with the best result so far.
    // The ratings of the license verification result are as follows:
    //
    // (1) LICENSE_STATUS_OK
    // (2) LICENSE_STATUS_SHOULD_UPGRADE_LICENSE
    // (3) LICENSE_STATUS_MUST_UPGRADE_LICENSE
    // (4) Other LICENSE_STATUS_xxx
    //

    if( LICENSE_STATUS_OK == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_OK == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }
    
    if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }

    if( LICENSE_STATUS_MUST_UPGRADE_LICENSE == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_MUST_UPGRADE_LICENSE == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }

    *pCurrentStatus = NewStatus;
    return;    
}

/*++

Function:

    FreeTsLicenseInfo

Description:

    Release all the memory used in the given TS_LICENSE_INFO structure

Parameter:

    pTsLicenseInfo - Pointer to a TS_LICENSE_INFO structure

Return:

    Nothing.

--*/

VOID
FreeTsLicenseInfo(
    PTS_LICENSE_INFO    pTsLicenseInfo )
{
    if( NULL == pTsLicenseInfo )
    {
        return;
    }

    if( pTsLicenseInfo->pbRawLicense )
    {
        LicenseMemoryFree( &pTsLicenseInfo->pbRawLicense );
    }

    //
    // release all memory within the structure
    //

    memset( pTsLicenseInfo, 0, sizeof( TS_LICENSE_INFO ) );

    return;
}

/*++

Function:

    CacheLicenseInfo

Description:

    Cache the client licensing info

Parameters:

    pLicenseContext - Pointer to license protocol context
    pCurrentLicense - Pointer to the license info to cache

Returns:

    nothing.

--*/
    
VOID
CacheLicenseInfo(
    PHS_Protocol_Context    pLicenseContext,
    PLICENSEDPRODUCT        pCurrentLicense )
{
    LICENSE_STATUS
        Status;
    
    //
    // free the old information in the cache
    //

    if( pLicenseContext->pTsLicenseInfo )
    {
        FreeTsLicenseInfo( pLicenseContext->pTsLicenseInfo );
    }
    else
    {
        Status = LicenseMemoryAllocate( sizeof( TS_LICENSE_INFO ), &pLicenseContext->pTsLicenseInfo );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICEMGR: CacheLicenseInfo: cannot allocate memory for license info cache\n" );
#endif
            return;
        }
    }

    //
    // decide if the license is temporary
    //

    if( pCurrentLicense->pLicensedVersion->dwFlags & 0x80000000 )
    {
        pLicenseContext->pTsLicenseInfo->fTempLicense = TRUE;
    }
    else
    {
        pLicenseContext->pTsLicenseInfo->fTempLicense = FALSE;
    }

    //
    // cache license validity dates
    //

    pLicenseContext->pTsLicenseInfo->NotAfter = pCurrentLicense->NotAfter;

    return;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ValidateHydraLicense( 
    PHS_Protocol_Context        pLicenseContext, 
    PValidation_Info            pValidationInfo,
    DWORD                       dwNumLicenses,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    LICENSE_STATUS 
        Status = LICENSE_STATUS_INVALID_LICENSE,
        CurrentStatus;
    DWORD
        dwLicenseIndex = 0,
        dwCurrentLicense = 0;
    PLICENSEDPRODUCT
        pCurrentLicense;
    BOOL
        fFoundMatchingVersion = FALSE;

    //
    // The client could have given us multiple licenses.  Pick the right
    // license from the array of licenses to validate.  Always try to pick
    // the license that matches the current product version before looking
    // for a license that is for a later version.
    //

    CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses, 
                            pLicenseInfo, 
                            &dwLicenseIndex,
                            TRUE );

    if( LICENSE_STATUS_OK == CurrentStatus )
    {
        //
        // Verify the license that is the same version as the current product
        // version

        // initialize the license state
        //

        LicenseInitState( *pdwLicenseState );
        pCurrentLicense = pLicenseInfo + dwLicenseIndex;
        fFoundMatchingVersion = TRUE;

        //
        // verify HWID
        //

        CurrentStatus = VerifyClientHwid( pLicenseContext, pValidationInfo, pCurrentLicense );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        //
        // verify product info.  Also verifies the product version.
        // The product version determines if the license needs to be
        // upgraded or not.
        //

        CurrentStatus = VerifyLicenseProductInfo( 
                                    pLicenseContext, 
                                    pValidationInfo, 
                                    pCurrentLicense, 
                                    pdwLicenseState );

        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        //
        // verify license valid date and time.
        //

        CurrentStatus = VerifyLicenseDateAndTime( pCurrentLicense, pdwLicenseState );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        CurrentStatus = GetVerifyResult( *pdwLicenseState );
        UpdateVerifyResult( &Status, CurrentStatus );

        //
        // cache the license we tried to validate
        //
        
        CacheLicenseInfo( pLicenseContext, pCurrentLicense );

        //
        // If the current license is OK, then we're done verifying
        //

        if( LICENSE_STATUS_OK == Status )
        {
            return( Status );
        }
    }

verify_later_license:
           
    //
    // Cannot find or did not sucessfully verify a license that matches the
    // current product version.  The following code finds and verifies
    // licenses that are later than the current product version.
    //

    CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses, 
                            pLicenseInfo, 
                            &dwLicenseIndex,
                            FALSE );

    if( LICENSE_STATUS_OK != CurrentStatus )
    {
        
        if( FALSE == fFoundMatchingVersion )
        {
            //
            // cannot find a license that is the same or later than the current
            // product version  ==> this license must be upgraded.
            //

            LicenseSetState( *pdwLicenseState, LICENSE_STATE_OLD_VERSION );

            //
            // Cache the existing license regardless, so we know what type
            // it is
            //

            CacheLicenseInfo( pLicenseContext, pLicenseInfo );


            return( GetVerifyResult( *pdwLicenseState ) );
        }
        else
        {
            return( Status );
        }
    }
    
    pCurrentLicense = pLicenseInfo + dwLicenseIndex;
    dwCurrentLicense = dwLicenseIndex;

    while(  dwCurrentLicense < dwNumLicenses )
    {        
        //
        // initialize the license state
        //

        LicenseInitState( *pdwLicenseState );

        //
        // verify HWID
        //

        CurrentStatus = VerifyClientHwid( pLicenseContext, pValidationInfo, pCurrentLicense );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        //
        // verify product info.  Also verifies the product version.
        // The product version determines if the license needs to be
        // upgraded or not.
        //

        CurrentStatus = VerifyLicenseProductInfo( 
                                    pLicenseContext, 
                                    pValidationInfo, 
                                    pCurrentLicense, 
                                    pdwLicenseState );

        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        //
        // verify license valid date and time.
        //

        CurrentStatus = VerifyLicenseDateAndTime( pCurrentLicense, pdwLicenseState );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        CurrentStatus = GetVerifyResult( *pdwLicenseState );

        UpdateVerifyResult( &Status, CurrentStatus );

        //
        // cache the info of the license we had just try to validate
        //

        CacheLicenseInfo( pLicenseContext, pCurrentLicense );

        if( LICENSE_STATUS_OK == Status )
        {
            //
            // if the license is OK, then we can stop the verification process
            //

            break;
        }

next_license:

        //
        // Get the next license that is later than the current product version.
        //

        if( dwNumLicenses <= ++dwCurrentLicense )
        {
            break;
        }

        pCurrentLicense++;

        CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses - dwCurrentLicense, 
                            pCurrentLicense, 
                            &dwLicenseIndex,
                            FALSE );
        
        if( LICENSE_STATUS_OK != CurrentStatus )    
        {
            break;
        }

        pCurrentLicense += dwLicenseIndex;
        dwCurrentLicense += dwLicenseIndex;
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ValidateLicense(
    PHS_Protocol_Context pLicenseContext, 
    PValidation_Info     pValidationInfo,
    PDWORD               pdwLicenseState,
    BOOL                 fCheckForPermanent )
{
    LICENSE_STATUS Status;
    DWORD dwNumLicenseInfo = 0;
    LICENSEDPRODUCT * pLicenseInfo = NULL;
    static DWORD    cchComputerName;
    static TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbSecretKey = 0;
    PBYTE pbSecretKey = NULL;
    BOOL fDifferent = FALSE;

    if( NULL == pLicenseContext )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Get the secret key that is used to encrypt the HWID
    //

    LicenseGetSecretKey( &cbSecretKey, NULL );

    Status = LicenseMemoryAllocate( cbSecretKey, &pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // decode license issued by hydra license server certificate engine.
    // Decoding the license will also get us back the decrypted HWID.
    //

    __try
    {
        Status = LSVerifyDecodeClientLicense( 
                            pValidationInfo->pLicense,
                            pValidationInfo->cbLicense,                                          
                            pbSecretKey,
                            cbSecretKey,
                            &dwNumLicenseInfo,
                            NULL );                            

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        Status = LicenseMemoryAllocate( 
                        sizeof( LICENSEDPRODUCT ) * dwNumLicenseInfo, 
                        &pLicenseInfo );

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        Status = LSVerifyDecodeClientLicense( 
                            pValidationInfo->pLicense,
                            pValidationInfo->cbLicense,                                          
                            pbSecretKey,
                            cbSecretKey,
                            &dwNumLicenseInfo,
                            pLicenseInfo );
                            
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DWORD dwExceptionCode = GetExceptionCode();
        Status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
    }

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICEMGR: cannot decode license: 0x%x\n", Status );
#endif
        goto done;
    }

    //
    // now validate the license
    //

    Status = ValidateHydraLicense( 
                        pLicenseContext, 
                        pValidationInfo, 
                        dwNumLicenseInfo, 
                        pLicenseInfo,                         
                        pdwLicenseState );


    if (fCheckForPermanent
        && LICENSE_STATUS_OK == Status
        && !pLicenseContext->pTsLicenseInfo->fTempLicense
        && pLicenseContext->ProductInfo.cbProductID >= sizeof(TERMSERV_FREE_TYPE))
    {
        int i;
        TCHAR *pszT;

        for (i = 0, pszT = (TCHAR *)(pLicenseContext->ProductInfo.pbProductID + pLicenseContext->ProductInfo.cbProductID - sizeof(TERMSERV_FREE_TYPE)); i < sizeof(TERMSERV_FREE_TYPE); i++)
        {
            if (TERMSERV_FREE_TYPE[i] != pszT[i])
            {
                fDifferent = TRUE;
                break;
            }
        }

        if (fDifferent)
            ReceivedPermanentLicense();
    }
    
done:

    if( pbSecretKey )
    {
        LicenseMemoryFree( &pbSecretKey );
    }

    //
    // Free the array of licensed product info
    //
        
    if( pLicenseInfo )
    {
        while( dwNumLicenseInfo-- )
        {
            LSFreeLicensedProduct( pLicenseInfo + dwNumLicenseInfo );
        }

        LicenseMemoryFree( &pLicenseInfo );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleClientLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL   pfExtendedError)
{
    LICENSE_STATUS Status, UpgradeStatus;
    Hydra_Client_License_Info LicenseInfo;
    PBYTE pPreMasterSecret = NULL;
    DWORD dwPreMasterSecretLen = 0;
    HWID Hwid;
    Validation_Info ValidationInfo;
    License_Error_Message ErrorMsg;
    DWORD dwLicenseState = 0;
    BYTE MacData[LICENSE_MAC_DATA];
    DWORD CertType;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );    

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Unpack the client license info message
    //

    InitBinaryBlob( &LicenseInfo.EncryptedPreMasterSecret );
    InitBinaryBlob( &LicenseInfo.LicenseInfo );
    InitBinaryBlob( &LicenseInfo.EncryptedHWID );

    Status = UnPackHydraClientLicenseInfo( pInBuf, cbInBuf, &LicenseInfo, pfExtendedError );

    if( LICENSE_STATUS_CANNOT_DECODE_LICENSE == Status ||
        LICENSE_STATUS_INVALID_LICENSE == Status )
    {
        goto license_bad;
    }

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }

    //
    // Initialize the crypto context with the key exchange info and build the pre-master
    // secret.  We need the server and client random numbers and the pre-master secret
    // to build the pre-master secret.
    //

    memcpy( pLicenseContext->CryptoContext.rgbClientRandom,
            LicenseInfo.ClientRandom,
            LICENSE_RANDOM );
    
    pLicenseContext->CryptoContext.dwKeyExchAlg = LicenseInfo.dwPrefKeyExchangeAlg;

    dwPreMasterSecretLen = LICENSE_PRE_MASTER_SECRET;

    Status = GetEnvelopedData( pLicenseContext->CertTypeUsed,
                               LicenseInfo.EncryptedPreMasterSecret.pBlob,
                               ( DWORD )LicenseInfo.EncryptedPreMasterSecret.wBlobLen,
                               &pPreMasterSecret,
                               &dwPreMasterSecretLen );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        goto construct_return_msg;
    }

    //
    // Set the pre-master secret and generate the master secret
    //

    Status = LicenseSetPreMasterSecret( &pLicenseContext->CryptoContext, pPreMasterSecret );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }
    
    Status = LicenseBuildMasterSecret( &pLicenseContext->CryptoContext );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }

    //
    // Derive the session key from the key exchange info
    //

    Status = LicenseMakeSessionKeys( &pLicenseContext->CryptoContext, 0 );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }    

    //
    // Use the session key to decrypt the HWID
    //

    if( LicenseInfo.EncryptedHWID.wBlobLen > sizeof(Hwid) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto construct_return_msg;
    }

    memcpy( &Hwid, 
            LicenseInfo.EncryptedHWID.pBlob, 
            LicenseInfo.EncryptedHWID.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ( PBYTE )&Hwid,
                                        ( DWORD )LicenseInfo.EncryptedHWID.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }    

    //
    // Calculate the MAC on the HWID.
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext, 
                                 ( PBYTE )&Hwid, 
                                 sizeof( HWID ), 
                                 MacData);
    
    if( LICENSE_STATUS_OK != Status )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto construct_return_msg;
    }

    //
    // now verify the MAC data
    //

    if( 0 != memcmp( MacData, LicenseInfo.MACData, LICENSE_MAC_DATA ) )
    {
        Status = LICENSE_STATUS_INVALID_LICENSE;
        goto license_bad;
    }

    //
    // keep track of the client platform ID
    //

    pLicenseContext->dwClientPlatformID = LicenseInfo.dwPlatformID;

    //
    // call the license manager to validate the license.
    // For now, we don't have to fill in the product info fields
    //

    ValidationInfo.pValidationData = ( PBYTE )&Hwid;
    ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
    ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
    ValidationInfo.pLicense = LicenseInfo.LicenseInfo.pBlob;
    ValidationInfo.cbLicense = ( DWORD )LicenseInfo.LicenseInfo.wBlobLen;

    Status = ValidateLicense( pLicenseContext, 
                              &ValidationInfo, 
                              &dwLicenseState,
                              FALSE     // fCheckForPermanent
                              );

license_bad:

    //
    // If the license cannot be decoded, then it is time to issue a new license
    // for the client.
    //

    if( LICENSE_STATUS_CANNOT_DECODE_LICENSE == Status ||
        LICENSE_STATUS_INVALID_LICENSE == Status )
    {
        LICENSE_STATUS StatusT = IssuePlatformChallenge( pLicenseContext, pcbOutBuf, ppOutBuf );

        if( LICENSE_STATUS_OK != StatusT )
        {
            //
            // cannot obtain a platform challenge for the client
            //

#if DBG
            DbgPrint( "LICPROT: cannot issue platform challenge: 0x%x\n", Status );
#endif
            goto construct_return_msg;
        }
        
        pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;
        Status = LICENSE_STATUS_CONTINUE;
        goto done;
    }

#ifdef UPGRADE_LICENSE

    //
    // check if the license needs to be upgraded.
    //
     
    if( ( LICENSE_STATUS_MUST_UPGRADE_LICENSE == Status ) ||
        ( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status ) )
    {
        //
        // issue the platform challenge for upgrading a license
        //

        UpgradeStatus = IssuePlatformChallenge( 
                                        pLicenseContext,
                                        pcbOutBuf, 
                                        ppOutBuf );

        if( LICENSE_STATUS_OK == UpgradeStatus )
        {
            //
            // keep track of the old license and continue with the licensing
            // protocol.  We will upgrade the old license when the client
            // returns with the platform challenge.
            //

            if( pLicenseContext->pbOldLicense )
            {
                LicenseMemoryFree( &pLicenseContext->pbOldLicense );
            }

            pLicenseContext->pbOldLicense = LicenseInfo.LicenseInfo.pBlob;
            pLicenseContext->cbOldLicense = LicenseInfo.LicenseInfo.wBlobLen;
            
            pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;
            Status = LICENSE_STATUS_CONTINUE;

            goto done;
        }
        else if(  LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status ) 
        {    
            //
            // Let the client go through if we cannot issue a platform
            // challenge to upgrade a valid license now.
            //

            Status = LICENSE_STATUS_OK;
            goto construct_return_msg;
        }
        else
        {
            // LICENSE_STATUS_MUST_UPGRADE_LICENSE: send back the real error

            Status = UpgradeStatus;
        }

        //
        // cannot issue platform challenge to upgrade a license that is
        // not good any more.
        //

#if DBG
        DbgPrint( "LICPROT: cannot issue platform challenge to upgrade license: 0x%x\n", Status );
#endif
        
    }

#else

    //
    // we are ignoring license upgrade
    //

    if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status )
    {
        //
        // change the status to OK
        //

        Status = LICENSE_STATUS_OK;
    }

#endif

    //
    // now construct the message to return to the client, based on the current
    // status code
    //

construct_return_msg:

    if( LICENSE_STATUS_OK != Status )
    {
        //
        // The current status states that the client could not be validated
        // due to some error
        //

#if DBG
        DbgPrint( "HandleClientLicense: constructing error message: 0x%x\n", Status );
#endif

        //
        // handle the error condition and update our state
        //

        HandleErrorCondition( pLicenseContext, pcbOutBuf, ppOutBuf, &Status );

        pLicenseContext->State = VALIDATION_ERROR;
    
        if( (LICENSE_STATUS_INVALID_RESPONSE == Status)
            || (LICENSE_STATUS_INVALID_MAC_DATA == Status)
            || (LICENSE_STATUS_CANNOT_DECODE_LICENSE == Status)
            || (LICENSE_STATUS_INVALID_LICENSE == Status) )
        {
            WORD wLogString = 0;
            LPTSTR ptszLogString[1] = { NULL };

            //
            // Log the failure
            //
            
            if( pLicenseContext->ptszClientMachineName )
            {
                wLogString = 1;
                ptszLogString[0] = pLicenseContext->ptszClientMachineName;
            }

            LicenseLogEvent( EVENTLOG_INFORMATION_TYPE, 
                             EVENT_INVALID_LICENSE, 
                             wLogString, ptszLogString );

            pLicenseContext->fLoggedProtocolError = TRUE;

        }
        else if ((NULL != pLicenseContext->pTsLicenseInfo)
                 && (!pLicenseContext->fLoggedProtocolError))
        {
            LPTSTR ptszLogString[1] = { NULL };

            if( pLicenseContext->ptszClientMachineName )
            {
                ptszLogString[0] = pLicenseContext->ptszClientMachineName;
            }

            // Couldn't renew/upgrade license

            pLicenseContext->fLoggedProtocolError = TRUE;

            if(IsLicensingTimeBombExpired())
            {

                if (pLicenseContext->pTsLicenseInfo->fTempLicense)
                {
                    // The expired temporary license could not be upgraded
                    LicenseLogEvent(
                                    EVENTLOG_INFORMATION_TYPE,
                                    EVENT_EXPIRED_TEMPORARY_LICENSE,
                                    1,
                                    ptszLogString
                                    );
                }
                else
                {
                    // The expired permanent license could not be renewed
                    LicenseLogEvent(
                                    EVENTLOG_INFORMATION_TYPE,
                                    EVENT_EXPIRED_PERMANENT_LICENSE,
                                    1,
                                    ptszLogString
                                    );
                }
            }
        }

        goto done;
    }

    //
    // The license has been validated successfully, generate the message to 
    // return to the client
    //

    Status = ConstructServerResponse( pLicenseContext->dwProtocolVersion,
                                      LICENSE_RESPONSE_VALID_CLIENT,
                                      TS_ERRINFO_NOERROR,
                                      pcbOutBuf,
                                      ppOutBuf,
                                      *pfExtendedError);
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "HandleClientLicense: cannot pack error message: 0x%x\n", Status );
#endif
        pLicenseContext->State = ABORTED; 
        Status = LICENSE_STATUS_SERVER_ABORT;
    }
    else
    {            
        pLicenseContext->State = VALIDATED_LICENSE_COMPLETE;
    }    

done:

    //
    // free the memory used in the license info structure
    //

    FreeBinaryBlob( &LicenseInfo.EncryptedPreMasterSecret );
    FreeBinaryBlob( &LicenseInfo.EncryptedHWID );
    
    if( pLicenseContext->pbOldLicense != LicenseInfo.LicenseInfo.pBlob )
    {
        FreeBinaryBlob( &LicenseInfo.LicenseInfo );
    }
    
    if( pPreMasterSecret )
    {
        LicenseMemoryFree( &pPreMasterSecret );
    }

    return( Status);

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleNewLicenseRequest(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL   pfExtendedError)
{
    LICENSE_STATUS  Status;
    Hydra_Client_New_License_Request    NewLicenseRequest;
    PBYTE   pPreMasterSecret = NULL;
    DWORD   dwPreMasterSecretLen = 0;
    DWORD   dwChallengeLen = 0;
    DWORD   CertType;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    InitBinaryBlob( &NewLicenseRequest.EncryptedPreMasterSecret );
        
    //
    // Unpack the new license request
    //

    Status = UnPackHydraClientNewLicenseRequest( pInBuf, cbInBuf, &NewLicenseRequest, pfExtendedError );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot unpack client request: 0x%x\n", Status );
#endif
        return( Status );
    }

    //
    // save the client user and machine name
    //
    
#ifdef UNICODE

    //
    // convert the client's user and machine name to unicode
    //

    if( ( NewLicenseRequest.ClientUserName.pBlob ) && 
        ( NULL == pLicenseContext->ptszClientUserName ) )
    {
        Status = Ascii2Wchar( NewLicenseRequest.ClientUserName.pBlob, 
                              &pLicenseContext->ptszClientUserName );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot convert client user name: %s to wide char: 0x%x\n",
                      NewLicenseRequest.ClientUserName.pBlob, Status );
#endif
        }        
    }

    if( ( NewLicenseRequest.ClientMachineName.pBlob ) &&
        ( NULL == pLicenseContext->ptszClientMachineName ) )
    {
        Status = Ascii2Wchar( NewLicenseRequest.ClientMachineName.pBlob, 
                              &pLicenseContext->ptszClientMachineName );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot convert client machine name %s to wide char: 0x%x\n", 
                      NewLicenseRequest.ClientMachineName.pBlob, Status );
#endif
        }
    }

#else // non-UNICODE

    //
    // save the client's user and machine name
    //

    if( ( NewLicenseRequest.ClientUserName.pBlob ) && 
        ( NULL == pLicenseContext->ptszClientUserName ) )
    {
        Status = LicenseMemoryAllocate( 
                        NewLicenseRequest.ClientUserName.wBlobLen,
                        &pLicenseContext->ptszClientUserName );
                        
        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot allocate memory for client's user name: 0x%x\n", 
                       Status );
#endif
        }
        else
        {
            memcpy( pLicenseContext->ptszClientUserName, 
                    NewLicenseRequest.ClientUserName.pBlob, 
                    NewLicenseRequest.ClientUserName.wBlobLen );
        }
    }

    if( ( NewLicenseRequest.ClientMachineName.pBlob ) &&
        ( NULL == pLicenseContext->ptszClientMachineName ) )
    {
        Status = LicenseMemoryAllocate( 
                        NewLicenseRequest.ClientMachineName.wBlobLen,
                        &pLicenseContext->ptszClientMachineName );
                        
        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot allocate memory for client's machine name: 0x%x\n", 
                       Status );
#endif
        }
        else
        {
            memcpy( pLicenseContext->ptszClientMachineName, 
                    NewLicenseRequest.ClientMachineName.pBlob, 
                    NewLicenseRequest.ClientMachineName.wBlobLen );
        }
    }

#endif // UNICODE

    //
    // Initialize the crypto context with the key exchange info and build the pre-master
    // secret.  We need the server and client random numbers and the pre-master secret
    // to build the pre-master secret.
    //

    memcpy( pLicenseContext->CryptoContext.rgbClientRandom,
            NewLicenseRequest.ClientRandom,
            LICENSE_RANDOM );
    
    pLicenseContext->CryptoContext.dwKeyExchAlg = NewLicenseRequest.dwPrefKeyExchangeAlg;

    //
    // Get the pre-master secret from the enveloped data
    //
        
    Status = GetEnvelopedData( pLicenseContext->CertTypeUsed,
                               NewLicenseRequest.EncryptedPreMasterSecret.pBlob,
                               ( DWORD )NewLicenseRequest.EncryptedPreMasterSecret.wBlobLen,
                               &pPreMasterSecret,
                               &dwPreMasterSecretLen );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot get enveloped data: 0x%x", Status );
#endif
        goto done;
    }    

    //
    // set the premaster secret and generate the master secret
    //

    Status = LicenseSetPreMasterSecret(  &pLicenseContext->CryptoContext, pPreMasterSecret );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseBuildMasterSecret( &pLicenseContext->CryptoContext );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // Derive the session key from the key exchange info
    //

    Status = LicenseMakeSessionKeys( &pLicenseContext->CryptoContext, 0 );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }    

    //
    // record the client platform ID and issue the platform challenge
    //

    pLicenseContext->dwClientPlatformID = NewLicenseRequest.dwPlatformID;

    Status = IssuePlatformChallenge( pLicenseContext, pcbOutBuf, ppOutBuf );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // update our state
    //

    pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;

    Status = LICENSE_STATUS_CONTINUE;


done:

    FreeBinaryBlob( &NewLicenseRequest.EncryptedPreMasterSecret );
    FreeBinaryBlob( &NewLicenseRequest.ClientUserName );
    FreeBinaryBlob( &NewLicenseRequest.ClientMachineName );

    if( pPreMasterSecret )
    {
        LicenseMemoryFree( &pPreMasterSecret );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleClientError(
PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL pfExtendedError )
{
    LICENSE_STATUS Status;
    License_Error_Message ClientError;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );
    ASSERT( NULL != pfExtendedError);

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    InitBinaryBlob( &ClientError.bbErrorInfo );

    //
    // unpack the client error
    //

    Status = UnPackHydraClientErrorMessage( pInBuf, cbInBuf, &ClientError, pfExtendedError );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    //
    // Process the client error code, the possible errors are:
    // (1) Error processing the hydra server certificate
    // (2) Client has no license and does not want one
    //
    // For now, just record the client error and abort the operation
    //

    pLicenseContext->dwClientError = ClientError.dwErrorCode;
    pLicenseContext->State = ABORTED;

    FreeBinaryBlob( &ClientError.bbErrorInfo );

    return( LICENSE_STATUS_CLIENT_ABORT );
}

LICENSE_STATUS
AuthWithLicenseServer(
    PHS_Protocol_Context     pLicenseContext )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    LPBYTE lpCert = NULL;
    DWORD dwResult, RpcStatus;
    DWORD dwSize;

    if (pLicenseContext->hLSHandle == NULL)
    {
        return LICENSE_STATUS_INVALID_SERVER_CONTEXT;
    }

    Status = TLSGetTSCertificate(CERT_TYPE_X509, &lpCert, &dwSize);

    if (Status != LICENSE_STATUS_OK)
    {
        Status = TLSGetTSCertificate(CERT_TYPE_PROPRIETORY, &lpCert, &dwSize);
    }

    if (Status != LICENSE_STATUS_OK)
    {
        goto done;
    }

    RpcStatus = TLSSendServerCertificate(
                                         pLicenseContext->hLSHandle,
                                         dwSize,
                                         lpCert,
                                         &dwResult
                                         );

    if( ( RPC_S_OK != RpcStatus ) || ( LSERVER_S_SUCCESS != dwResult ) )
    {
        Status = LICENSE_STATUS_AUTHENTICATION_ERROR;
        goto done;
    }

done:
    if (lpCert)
        TLSFreeTSCertificate(lpCert);

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckConnectLicenseServer(
    PHS_Protocol_Context      pLicenseContext )
{
    LICENSE_STATUS Status = LICENSE_STATUS_NO_LICENSE_SERVER;

    if (pLicenseContext->hLSHandle != NULL)
        return LICENSE_STATUS_OK;

    pLicenseContext->hLSHandle = TLSConnectToAnyLsServer(LS_DISCOVERY_TIMEOUT);

    if (NULL != pLicenseContext->hLSHandle)
    {
        Status = AuthWithLicenseServer(pLicenseContext);
        if (Status == LICENSE_STATUS_OK)
        {
            goto done;
        }
        else if(Status == LICENSE_STATUS_AUTHENTICATION_ERROR)
        {
            BOOL fInDomain;            
            LPWSTR szLSName = NULL;
            DWORD dwErr;

            dwErr = TLSInDomain(&fInDomain, NULL);

            if( (ERROR_SUCCESS == dwErr) && (fInDomain == TRUE))
            {
                DWORD dwErrCode = ERROR_SUCCESS;

                dwErr = TLSGetServerNameFixed(pLicenseContext->hLSHandle,&szLSName,&dwErrCode);

                if(dwErr == RPC_S_OK && dwErrCode == ERROR_SUCCESS && NULL != szLSName)
                {
                    LicenseLogEvent( EVENTLOG_WARNING_TYPE, 
                         EVENT_LICENSE_SERVER_AUTHENTICATION_FAILED,                          
                         1, &szLSName );
                  
                }
                if(NULL != szLSName)
                {
                    MIDL_user_free(szLSName);
                }
            }            
        }
    }
    else
    {
        BOOL fInDomain;
        LPWSTR szDomain = NULL;
        DWORD dwErr;

        dwErr = TLSInDomain(&fInDomain,&szDomain);

        if ((ERROR_SUCCESS == dwErr) && (NULL != szDomain))
        {
            ThrottleLicenseLogEvent( 
                                EVENTLOG_WARNING_TYPE,
                                fInDomain
                                  ? EVENT_NO_LICENSE_SERVER_DOMAIN
                                    : EVENT_NO_LICENSE_SERVER_WORKGROUP,
                                1, 
                                &szDomain );
        }
        else
        {
            ThrottleLicenseLogEvent( 
                                EVENTLOG_WARNING_TYPE,
                                EVENT_NO_LICENSE_SERVER,
                                0, 
                                NULL );
        }

        if (NULL != szDomain)
        {
            NetApiBufferFree(szDomain);
        }
    }

    // error case
    if (NULL != pLicenseContext->hLSHandle)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

done:
    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckConnectNamedLicenseServer(
    PHS_Protocol_Context      pLicenseContext,
    TCHAR                     *tszComputerName)
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    if (pLicenseContext->hLSHandle != NULL)
        return LICENSE_STATUS_OK;

    pLicenseContext->hLSHandle = TLSConnectToLsServer(tszComputerName);

    if (NULL == pLicenseContext->hLSHandle)
    {
        Status = LICENSE_STATUS_NO_LICENSE_SERVER;
        goto done;
    }

    Status = AuthWithLicenseServer(pLicenseContext);
    if (Status != LICENSE_STATUS_OK)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

done:
    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckUpgradeLicense(
    PHS_Protocol_Context      pLicenseContext, 
    PDWORD                    pSupportFlags,
    PLicense_Request          pLicenseRequest,
    DWORD                     cbChallengeResponse,
    PBYTE                     pbChallengeResponse,
    PHWID                     pHwid,
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf )
{
    LICENSE_STATUS 
        Status = LICENSE_STATUS_OK;
    DWORD 
        cbLicense = 0;
    PBYTE 
        pbLicense = NULL;
    Validation_Info 
        ValidationInfo;
    DWORD
        dwLicenseState = 0;
    DWORD
        RpcStatus, LsStatus;
    BOOL
        fRetried = FALSE;

reconnect:    
    Status = CheckConnectLicenseServer(pLicenseContext);
    if( LICENSE_STATUS_OK != Status )
    {
        goto validate_old_one;
    }

    RpcStatus = TLSUpgradeLicenseEx(pLicenseContext->hLSHandle,
                                  pSupportFlags,
                                  pLicenseRequest,
                                  0,       // ChallengeContext unused
                                  cbChallengeResponse,
                                  pbChallengeResponse,
                                  pLicenseContext->cbOldLicense,
                                  pLicenseContext->pbOldLicense,
                                  1,       // dwQuantity
                                  &cbLicense,
                                  &pbLicense,
                                  &LsStatus
                                  );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            Status = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        Status = LsStatusToLicenseStatus(LsStatus,
                                      LICENSE_STATUS_CANNOT_UPGRADE_LICENSE);
    }

validate_old_one:

    ValidationInfo.pValidationData = ( PBYTE )pHwid;
    ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
    ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
        
    //
    // if we cannot upgrade the license, check if the current license is
    // still good.  If it is, return it to the client.
    //

    if( LICENSE_STATUS_OK != Status )
    {
        LICENSE_STATUS
            LicenseStatus;

        ValidationInfo.pLicense = pLicenseContext->pbOldLicense;
        ValidationInfo.cbLicense = pLicenseContext->cbOldLicense;

        LicenseStatus = ValidateLicense( 
                                    pLicenseContext, 
                                    &ValidationInfo, 
                                    &dwLicenseState,
                                    FALSE       // fCheckForPermanent
                                    );

        if( ( LICENSE_STATUS_OK == LicenseStatus ) || 
            ( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == LicenseStatus ) )
        {
            //
            // Store the raw license bits for later use. Ignore failure;
            // that only means that if this is a license that should be
            // marked, termsrv won't be able to.
            //

            CacheRawLicenseData(pLicenseContext,
                    pLicenseContext->pbOldLicense,
                    pLicenseContext->cbOldLicense);

            //
            // The current license is still OK, send it back to the client.
            //

            Status = PackageLicense( 
                            pLicenseContext, 
                            pLicenseContext->cbOldLicense, 
                            pLicenseContext->pbOldLicense, 
                            pcbOutBuf, 
                            ppOutBuf,
                            FALSE );
        
        }
        else
        {
            //
            // The current license is not good any more
            //

#if DBG
            DbgPrint( "UpgradeLicense: cannot upgrade license 0x%x\n", Status );
#endif
            
        }
        
        goto done;
    }

    //
    // the license upgrade was successful.  Now validate the new license so
    // that the new license info will be cached.
    //

    ValidationInfo.pLicense = pbLicense;
    ValidationInfo.cbLicense = cbLicense;

    ValidateLicense( 
            pLicenseContext, 
            &ValidationInfo, 
            &dwLicenseState,
            TRUE        // fCheckForPermanent
            );

    //
    // Store the raw license bits for later use. Ignore failure; that only
    // means that if this is a license that should be marked, termsrv won't be
    // able to.
    //

    CacheRawLicenseData(pLicenseContext,
                        pbLicense,
                        cbLicense);

    //
    // pack up the upgraded license
    //

    Status = PackageLicense( pLicenseContext, 
                             cbLicense,
                             pbLicense, 
                             pcbOutBuf, 
                             ppOutBuf,
                             FALSE );

done:

    if( pbLicense )
    {
        LicenseMemoryFree( &pbLicense );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandlePlatformChallengeResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL  pfExtendedError)
{
    LICENSE_STATUS Status;
    Hydra_Client_Platform_Challenge_Response PlatformChallengeResponse;
    BYTE ChallengeResponse[PLATFORM_CHALLENGE_LENGTH];
    PBYTE pLicense = NULL;
    DWORD cbLicenseSize = 0;
    License_Request LicenseRequest;
    HS_LICENSE_STATE HsState = ABORTED;
    License_Requester_Info  RequesterInfo;
    BYTE bEncryptedHwid[ sizeof( HWID ) ];    
    PBYTE pbSecretKey = NULL;
    DWORD cbMacData = 0, cbSecretKey = 0, cbEncryptedHwid = sizeof( HWID );
    BYTE MacData[ sizeof( HWID ) + PLATFORM_CHALLENGE_LENGTH ];
    BYTE ComputedMac[LICENSE_MAC_DATA];
    HWID Hwid;
    DWORD RpcStatus,LsStatus;
    TCHAR tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR tszUserName[UNLEN + 1];
    DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD dwUserName = UNLEN + 1;
    DWORD dwSupportFlags = ALL_KNOWN_SUPPORT_FLAGS;
    BOOL fRetried = FALSE;    

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }
    
    //
    // unpack the platform challenge response
    //

    InitBinaryBlob( &PlatformChallengeResponse.EncryptedChallengeResponse );
    InitBinaryBlob( &PlatformChallengeResponse.EncryptedHWID );

    Status = UnPackHydraClientPlatformChallengeResponse( pInBuf, cbInBuf, &PlatformChallengeResponse, pfExtendedError );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // decrypt the encrypted challenge response and HWID
    //

    ASSERT(PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen
           <= PLATFORM_CHALLENGE_LENGTH);
    
    if(PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen > PLATFORM_CHALLENGE_LENGTH)
    {
        Status = LICENSE_STATUS_INVALID_INPUT;
        goto done;
    }

    memcpy( ChallengeResponse,
            PlatformChallengeResponse.EncryptedChallengeResponse.pBlob,
            PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ChallengeResponse,
                                        ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }        

    //
    // decrypt the client's HWID
    //

    if( PlatformChallengeResponse.EncryptedHWID.wBlobLen > sizeof(Hwid) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    memcpy( &Hwid, 
            PlatformChallengeResponse.EncryptedHWID.pBlob, 
            PlatformChallengeResponse.EncryptedHWID.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ( PBYTE )&Hwid,
                                        ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen );
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }        
    
    //
    // Verify the MAC data on the decrypted challenge response and the HWID
    //

    cbMacData += ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen;
    
    memcpy( MacData, 
            ChallengeResponse, 
            ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    cbMacData += ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen;
    
    memcpy( MacData + ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
            &Hwid,
            ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen );

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
                                 MacData,
                                 cbMacData,
                                 ComputedMac );

    if( LICENSE_STATUS_OK != Status )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    if( 0 != memcmp( ComputedMac, 
                     PlatformChallengeResponse.MACData,
                     LICENSE_MAC_DATA ) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    //
    // now get the license server's secret key and encrypt the HWID before transmitting it.
    //

    LicenseGetSecretKey( &cbSecretKey, NULL );

    Status = LicenseMemoryAllocate( cbSecretKey, &pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseEncryptHwid( &Hwid, &cbEncryptedHwid, bEncryptedHwid, 
                                 cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    LicenseRequest.cbEncryptedHwid = cbEncryptedHwid;
    LicenseRequest.pbEncryptedHwid = bEncryptedHwid;

    //
    // send the platform challenge response to the license manager and wait for it
    // to issue a new license.
    //

    LicenseRequest.pProductInfo = &pLicenseContext->ProductInfo;
    
    LicenseRequest.dwPlatformID = pLicenseContext->dwClientPlatformID;
    LicenseRequest.dwLanguageID = GetSystemDefaultLCID();

    //
    // if we don't have the client's user and machine name, get it now.
    //

    if( NULL == pLicenseContext->ptszClientMachineName )
    {
        //
        // if we don't have the client machine name, just use the
        // hydra server machine name
        //

        if( !GetComputerName( tszComputerName, &dwComputerName ) )
        {
#if DBG
            DbgPrint( "HandlePlatformChallengeResponse: cannot get computer name: 0x%x\n", GetLastError() );
#endif
            memset( tszComputerName, 0, ( MAX_COMPUTERNAME_LENGTH + 1 ) * sizeof( TCHAR ) );
        }

        RequesterInfo.ptszMachineName = tszComputerName;
    }
    else
    {
        RequesterInfo.ptszMachineName = pLicenseContext->ptszClientMachineName;
    }

    if( NULL == pLicenseContext->ptszClientUserName )
    {
        //
        // if we don't have the client's user name, just use the 
        // hydra server logged on user name.
        //

        if( !GetUserName( tszUserName, &dwUserName ) )
        {
#if DBG
            DbgPrint( "HandlePlatformChallengeResponse: cannot get user name: 0x%x\n", GetLastError() );
#endif
            memset( tszUserName, 0, ( UNLEN + 1 ) * sizeof( TCHAR ) );
        }

        RequesterInfo.ptszUserName = tszUserName;
    }
    else
    {
        RequesterInfo.ptszUserName = pLicenseContext->ptszClientUserName;
    }

    if( pLicenseContext->pbOldLicense )
    {
        //
        // attempt to upgrade an old license
        //
        
        Status = CheckUpgradeLicense(
                                pLicenseContext,
                                &dwSupportFlags,
                                &LicenseRequest,
                                ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
                                ChallengeResponse,
                                &Hwid,
                                pcbOutBuf,
                                ppOutBuf );

        if (LICENSE_STATUS_OK != Status)
        {
            if (NULL != pLicenseContext->pTsLicenseInfo)
            {
                pLicenseContext->fLoggedProtocolError = TRUE;

                if(IsLicensingTimeBombExpired())
                {
                
                    if (pLicenseContext->pTsLicenseInfo->fTempLicense)
                    {				    
                        // The expired temporary license could not be upgraded
                        LicenseLogEvent(
                                    EVENTLOG_INFORMATION_TYPE,
                                    EVENT_EXPIRED_TEMPORARY_LICENSE,
                                    1,
                                    &(RequesterInfo.ptszMachineName)
                                    );
                    }
                    else
                    {
                        // The expired permanent license could not be renewed
                        LicenseLogEvent(
                                    EVENTLOG_INFORMATION_TYPE,
                                    EVENT_EXPIRED_PERMANENT_LICENSE,
                                    1,
                                    &(RequesterInfo.ptszMachineName)
                                    );
                    }
                }
            }
        }

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

    }
    else
    {
reconnect:

        Status = CheckConnectLicenseServer(pLicenseContext);
        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        RpcStatus = TLSIssueNewLicenseEx( 
                                       pLicenseContext->hLSHandle,
                                       &dwSupportFlags,
                                       0,       // ChallengeContext unused
                                       &LicenseRequest,
                                       RequesterInfo.ptszMachineName,
                                       RequesterInfo.ptszUserName,
                                       ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
                                       ChallengeResponse,
                                       TRUE,
                                       1,       // dwQuantity
                                       &cbLicenseSize,
                                       &pLicense,
                                       &LsStatus );

        if ( RPC_S_OK != RpcStatus )
        {
            if (!fRetried)
            {
                fRetried = TRUE;
                pLicenseContext->hLSHandle = NULL;
                goto reconnect;
            }
            else
            {
                Status = LICENSE_STATUS_NO_LICENSE_SERVER;
            }
        }
        else if ( LSERVER_ERROR_BASE <= LsStatus )
        {
            Status = LsStatusToLicenseStatus(LsStatus,
                                         LICENSE_STATUS_NO_LICENSE_ERROR);
        }
        else
        {
            DWORD dwLicenseState;
            Validation_Info ValidationInfo;

            //
            // Validate the license for the sole purpose of caching the
            // information.
            //

            ValidationInfo.pValidationData = ( PBYTE )&Hwid;
            ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
            ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
            ValidationInfo.pLicense = pLicense;
            ValidationInfo.cbLicense = cbLicenseSize;

            ValidateLicense(pLicenseContext,
                            &ValidationInfo,
                            &dwLicenseState,
                            TRUE        // fCheckForPermanent
                            );

            //
            // Store the raw license bits for later use. Ignore failure;
            // that only means that if this is a license that should be
            // marked, termsrv won't be able to.
            //

            CacheRawLicenseData(pLicenseContext, pLicense, cbLicenseSize);
            
            //
            // package up the new license
            //
            
            Status = PackageLicense( pLicenseContext, 
                                     cbLicenseSize, 
                                     pLicense, 
                                     pcbOutBuf, 
                                     ppOutBuf,
                                     TRUE );
        }
    }

    SetExtendedData(pLicenseContext, dwSupportFlags);

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // done with the protocol
    //

    HsState = ISSUED_LICENSE_COMPLETE;
    Status = LICENSE_STATUS_ISSUED_LICENSE;

done:

    //
    // log all issue license failures
    //

    if( (LICENSE_STATUS_ISSUED_LICENSE != Status)
        && (pLicenseContext != NULL)
        && (!pLicenseContext->fLoggedProtocolError) )
    {
        pLicenseContext->fLoggedProtocolError = TRUE;

        LicenseLogEvent( EVENTLOG_INFORMATION_TYPE, 
                         EVENT_CANNOT_ISSUE_LICENSE,                          
                         0, NULL );
    }

    if( pLicense )
    {
        LicenseMemoryFree( &pLicense );
    }

    if( pbSecretKey )
    {
        LicenseMemoryFree( &pbSecretKey );
    }
    
    if( pLicenseContext->pbOldLicense )
    {
        //
        // free the old license
        //

        LicenseMemoryFree( &pLicenseContext->pbOldLicense );
        pLicenseContext->cbOldLicense = 0;
    }

    FreeBinaryBlob( &PlatformChallengeResponse.EncryptedChallengeResponse );
    FreeBinaryBlob( &PlatformChallengeResponse.EncryptedHWID );

    pLicenseContext->State = HsState;

    return( Status );                                    
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
IssuePlatformChallenge(
    PHS_Protocol_Context pLicenseContext, 
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf )
{
    Hydra_Server_Platform_Challenge     
        PlatformChallenge;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;
    CHALLENGE_CONTEXT
        ChallengeContext;

    //
    // generate the platform challenge
    //

    ASSERT( pLicenseContext );

    //
    // Form the platform challenge message
    //

    PlatformChallenge.EncryptedPlatformChallenge.wBlobLen = ( WORD )sizeof(HARDCODED_CHALLENGE_DATA);

    Status = LicenseMemoryAllocate(sizeof(HARDCODED_CHALLENGE_DATA), &(PlatformChallenge.EncryptedPlatformChallenge.pBlob));

    if (LICENSE_STATUS_OK != Status)
    {
#if DBG
        DbgPrint( "LICPROT: cannot generate MAC data for challenge platform: 0x%x\n", Status );
#endif

        goto done;
    }

    memcpy(PlatformChallenge.EncryptedPlatformChallenge.pBlob, HARDCODED_CHALLENGE_DATA, sizeof(HARDCODED_CHALLENGE_DATA));

    //
    // calculate the MAC for the unencrypted platform challenge
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
				                 PlatformChallenge.EncryptedPlatformChallenge.pBlob,
				                 ( DWORD )PlatformChallenge.EncryptedPlatformChallenge.wBlobLen,
				                 PlatformChallenge.MACData );

	if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot generate MAC data for challenge platform: 0x%x\n", Status );
#endif
        goto done;
    }

    //
    // encrypt the platform challenge
    //

    Status = LicenseEncryptSessionData( &pLicenseContext->CryptoContext,
                                        PlatformChallenge.EncryptedPlatformChallenge.pBlob,
                                        PlatformChallenge.EncryptedPlatformChallenge.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot encrypt platform challenge data: 0x%x\n", Status );
#endif
        goto done;
    }
			   
    //
    // pack the platform challenge
    //

    Status = PackHydraServerPlatformChallenge( 
                    pLicenseContext->dwProtocolVersion,
                    &PlatformChallenge, 
                    ppOutBuf, 
                    pcbOutBuf );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot pack platform challenge data: 0x%x\n", Status );
#endif
        goto done;
    }

done:
    if (NULL != PlatformChallenge.EncryptedPlatformChallenge.pBlob)
    {
        LicenseMemoryFree(&PlatformChallenge.EncryptedPlatformChallenge.pBlob);
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackageLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD                     cbLicense,
    PBYTE                     pLicense,
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf,
    BOOL                      fNewLicense )
{
    LICENSE_STATUS Status;
    New_License_Info NewLicenseInfo;
    Hydra_Server_New_License NewLicense;
    DWORD cbEncryptedLicenseInfo = 0;

    if( ( 0 == cbLicense ) || ( NULL == pLicense ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the new license information
    //

    NewLicenseInfo.dwVersion        = pLicenseContext->ProductInfo.dwVersion;

	NewLicenseInfo.cbScope          = strlen( pLicenseContext->Scope ) + 1;
	NewLicenseInfo.pbScope          = pLicenseContext->Scope;

	NewLicenseInfo.cbCompanyName    = pLicenseContext->ProductInfo.cbCompanyName;
	NewLicenseInfo.pbCompanyName    = pLicenseContext->ProductInfo.pbCompanyName;

	NewLicenseInfo.cbProductID      = pLicenseContext->ProductInfo.cbProductID;
	NewLicenseInfo.pbProductID      = pLicenseContext->ProductInfo.pbProductID;

    NewLicenseInfo.cbLicenseInfo    = cbLicense;
	NewLicenseInfo.pbLicenseInfo    = pLicense;
    
    //
    // initialize the blob that will contain the encrypted new license 
    // information
    //

    NewLicense.EncryptedNewLicenseInfo.wBlobLen = 0;
    NewLicense.EncryptedNewLicenseInfo.pBlob = NULL;
    
    //
    // pack the new license information
    //

    Status = PackNewLicenseInfo( &NewLicenseInfo,
                                 &NewLicense.EncryptedNewLicenseInfo.pBlob, 
                                 &cbEncryptedLicenseInfo );

    NewLicense.EncryptedNewLicenseInfo.wBlobLen = ( WORD )cbEncryptedLicenseInfo;

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }                                

    //
    // calculate the mac data
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
                                 NewLicense.EncryptedNewLicenseInfo.pBlob,
                                 ( DWORD )NewLicense.EncryptedNewLicenseInfo.wBlobLen,
                                 NewLicense.MACData );
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }    
                                 
        
    //
    // Encrypt the new license info
    //

    Status = LicenseEncryptSessionData( &pLicenseContext->CryptoContext,
                                        NewLicense.EncryptedNewLicenseInfo.pBlob,
                                        cbEncryptedLicenseInfo );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    //
    // package up the license for the client
    //

    if( fNewLicense )
    {
        Status = PackHydraServerNewLicense( 
                        pLicenseContext->dwProtocolVersion, 
                        &NewLicense, 
                        ppOutBuf, 
                        pcbOutBuf );
    }
    else
    {
        Status = PackHydraServerUpgradeLicense( 
                        pLicenseContext->dwProtocolVersion, 
                        &NewLicense, 
                        ppOutBuf, 
                        pcbOutBuf );
    }
    
done:
    
    if( NewLicense.EncryptedNewLicenseInfo.pBlob )
    {
        LicenseMemoryFree( &NewLicense.EncryptedNewLicenseInfo.pBlob );
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ConstructProtocolResponse(
    HANDLE      hLicense,
    DWORD       dwResponse,
    UINT32      uiExtendedErrorInfo,
    PDWORD      pcbOutBuf,
    PBYTE *     ppOutBuf,
    BOOL        fExtendedError)
{
    PHS_Protocol_Context 
        pLicenseContext;
    LICENSE_STATUS 
        Status;

    pLicenseContext = ( PHS_Protocol_Context )hLicense;

    if (pLicenseContext == NULL)
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    LOCK( &pLicenseContext->CritSec );
    
    //
    // construct the server response.  If this is a per seat license context, use the
    // licensing protocol version specified in the context.  Otherwise, use the
    // protocol version that is compatible with Terminal server 4.0.
    //

    Status = ConstructServerResponse( 
                        pLicenseContext->dwProtocolVersion,
                        dwResponse,
                        uiExtendedErrorInfo,
                        pcbOutBuf, 
                        ppOutBuf,
                        fExtendedError);

    UNLOCK( &pLicenseContext->CritSec );

    return( Status );
}



///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ConstructServerResponse(
    DWORD                           dwProtocolVersion,
    DWORD                           dwResponse,
    UINT32                          uiExtendedErrorInfo,
    PDWORD                          pcbOutBuf,
    PBYTE *                         ppOutBuf,
    BOOL                            fExtendedError)
{
    License_Error_Message ErrorMsg;
    LICENSE_STATUS Status;
    
    if( ( NULL == pcbOutBuf ) || ( NULL == ppOutBuf ))
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( LICENSE_RESPONSE_VALID_CLIENT == dwResponse )
    {
        ErrorMsg.dwErrorCode            = GM_HS_ERR_VALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_NO_TRANSITION;
    }
    else if( LICENSE_RESPONSE_INVALID_CLIENT == dwResponse )
    {
        ErrorMsg.dwErrorCode            = GM_HS_ERR_INVALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;
    }
    else
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    ErrorMsg.bbErrorInfo.wBlobType  = BB_ERROR_BLOB;

    if (uiExtendedErrorInfo == TS_ERRINFO_NOERROR || !(fExtendedError) )
    {
        ErrorMsg.bbErrorInfo.wBlobLen   = 0;
        ErrorMsg.bbErrorInfo.pBlob      = NULL;
    }
    else
    {
        PackExtendedErrorInfo(uiExtendedErrorInfo,&(ErrorMsg.bbErrorInfo));
    }

    Status = PackHydraServerErrorMessage( 
                    dwProtocolVersion, 
                    &ErrorMsg, 
                    ppOutBuf, 
                    pcbOutBuf );
    
    return( Status );
}



///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetEnvelopedData( 
    CERT_TYPE   CertType,
    PBYTE       pEnvelopedData,
    DWORD       dwEnvelopedDataLen,
    PBYTE *     ppData,
    PDWORD      pdwDataLen )
{
    LICENSE_STATUS
        Status;

    LsCsp_DecryptEnvelopedData(
                        CertType,
                        pEnvelopedData,
                        dwEnvelopedDataLen,
                        NULL,
                        pdwDataLen );
    
    Status = LicenseMemoryAllocate( *pdwDataLen, ppData );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    if( !LsCsp_DecryptEnvelopedData(
                        CertType,
                        pEnvelopedData,
                        dwEnvelopedDataLen,
                        *ppData,
                        pdwDataLen ) )
    {
        Status = LICENSE_STATUS_INVALID_INPUT;
    }

done:
    
    return( Status );    
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
InitProductInfo(
    PProduct_Info   pProductInfo,
    LPTSTR          lptszProductSku )
{
    LICENSE_STATUS Status;

    pProductInfo->pbCompanyName = NULL;
    pProductInfo->pbProductID = NULL;   
    
    pProductInfo->dwVersion      = g_dwTerminalServerVersion;    

    pProductInfo->cbCompanyName  = wcslen( PRODUCT_INFO_COMPANY_NAME )  * sizeof( WCHAR )
                                   + sizeof( WCHAR );

    Status = LicenseMemoryAllocate( pProductInfo->cbCompanyName,
                                    &pProductInfo->pbCompanyName );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "InitProductInfo: cannot allocate memory: 0x%x\n", Status );
#endif
        goto error;
    }
    
    wcscpy( ( PWCHAR )pProductInfo->pbCompanyName, PRODUCT_INFO_COMPANY_NAME );

    pProductInfo->cbProductID = _tcslen( lptszProductSku ) * sizeof( TCHAR )
								+ sizeof( TCHAR );

    Status = LicenseMemoryAllocate( pProductInfo->cbProductID,
                                    &pProductInfo->pbProductID );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "InitProductInfo: cannot allocate memory: 0x%x\n", Status );
#endif
        goto error;
    }
    
    _tcscpy( ( PTCHAR )pProductInfo->pbProductID, lptszProductSku );

    return( Status );

error:

    //
    // error return, free allocated resources
    //

    if( pProductInfo->pbCompanyName )
    {
        LicenseMemoryFree( &pProductInfo->pbCompanyName );
    }

    if( pProductInfo->pbProductID )
    {
        LicenseMemoryFree( &pProductInfo->pbProductID );
    }

    return( Status );
}

#define THROTTLE_WRAPAROUND 100

//
// Reduce the frequency of logging
// No need to strictly limit it to once every 100 calls
//

void
ThrottleLicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings )
{
    static LONG lLogged = THROTTLE_WRAPAROUND;
    LONG lResult;

    lResult = InterlockedIncrement(&lLogged);

    if (THROTTLE_WRAPAROUND <= lResult)
    {
        LicenseLogEvent(
                        wEventType,
                        dwEventId,
                        cStrings,
                        apwszStrings );

        lLogged = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
void
LicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings )
{
    if (!g_fEventLogOpen)
    {	
        LOCK(&g_EventLogCritSec);

        if (!g_fEventLogOpen)
        {
            g_hEventLog = RegisterEventSource( NULL,
                                               TERMINAL_SERVICE_EVENT_LOG );

            if (NULL != g_hEventLog)
            {
                g_fEventLogOpen = TRUE;
            }
        }

        UNLOCK(&g_EventLogCritSec);
    }

    if( g_hEventLog )
    {
        WCHAR *wszStringEmpty = L"";

        if (NULL == apwszStrings)
            apwszStrings = &wszStringEmpty;

        if ( !ReportEvent( g_hEventLog, 
                           wEventType,
                           0, 
                           dwEventId,
                           NULL, 
                           cStrings, 
                           0, 
                           apwszStrings, 
                           NULL ) )
        {
#if DBG
            DbgPrint( "LogEvent: could not log event: 0x%x\n", GetLastError() );
#endif
        }
    }

    return;
}

#ifdef UNICODE

/*++

Function:

    Ascii2Wchar

Description:

    Convert an ascii string to a wide character string.  This function is only
    defined if UNICODE is defined.  This function allocates memory for the
    return value of the wide character string.

Arguments:

    lpszAsciiStr - Points to the ascii string
    ppwszWideStr - Points to the pointer to the wide character string.

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code otherwise.

--*/

LICENSE_STATUS
Ascii2Wchar
(
    LPSTR lpszAsciiStr,
    LPWSTR * ppwszWideStr )
{
    LICENSE_STATUS
        Status;

    if( ( NULL == lpszAsciiStr ) || ( NULL == ppwszWideStr ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }
	
    if( !g_fSetLocale )
    {
        setlocale( LC_ALL, "" );
        g_fSetLocale = TRUE;
    }

    //
    // allocate memory for the wide string
    //


    //
    // Allocate extra space for NULL, mbstowcs() does not NULL terminate string
    // 

    Status = LicenseMemoryAllocate( 
                    ( _mbslen( lpszAsciiStr ) + 2 ) * sizeof( WCHAR ), 
                    ppwszWideStr );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( 0 >= mbstowcs( *ppwszWideStr, lpszAsciiStr, _mbslen( lpszAsciiStr ) + 1 ) )
    {
#if DBG
        DbgPrint( "LICPROT: Ascii2Wchar: cannot convert ascii string to wide char\n" );
#endif
        Status = LICENSE_STATUS_INVALID_INPUT;
    }

    return( Status );
}

#endif

/*++

Function:

    QueryLicenseInfo

Description:

    Query the license information provided by the client

Parameters:

    pLicenseContext - License protocol context
    pTsLicenseInfo - Pointer to license information

Return:

    If successful, pTsLicenseInfo will contain the license info and this
    function returns LICENSE_STATUS_SUCCESS.  Otherwise, returns a
    LICENSE_STATUS error.

--*/

LICENSE_STATUS
QueryLicenseInfo(
    HANDLE               hContext,
    PTS_LICENSE_INFO     pTsLicenseInfo )
{
    PHS_Protocol_Context
        pLicenseContext = (PHS_Protocol_Context) hContext;
    LICENSE_STATUS
        Status;

    if( ( NULL == hContext ) || ( NULL == pTsLicenseInfo ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    //
    // indicate if the license is temporary
    //

    pTsLicenseInfo->fTempLicense = pLicenseContext->pTsLicenseInfo->fTempLicense;

    //
    // license validity dates
    //

    pTsLicenseInfo->NotAfter = pLicenseContext->pTsLicenseInfo->NotAfter;

    //
    // raw license data
    //

    if (NULL != pTsLicenseInfo->pbRawLicense)
    {
        LicenseMemoryFree( &pTsLicenseInfo->pbRawLicense );
    }


    Status = LicenseMemoryAllocate(
                       pLicenseContext->pTsLicenseInfo->cbRawLicense,
                       &(pTsLicenseInfo->pbRawLicense));

    if (Status != LICENSE_STATUS_OK)
    {
        return Status;
    }

    memcpy(pTsLicenseInfo->pbRawLicense,
            pLicenseContext->pTsLicenseInfo->pbRawLicense,
            pLicenseContext->pTsLicenseInfo->cbRawLicense);

    pTsLicenseInfo->cbRawLicense
        = pLicenseContext->pTsLicenseInfo->cbRawLicense;

    //
    // flags
    //

    pTsLicenseInfo->dwSupportFlags
        = pLicenseContext->pTsLicenseInfo->dwSupportFlags;

    return( LICENSE_STATUS_OK );
}

/*++

Function:

    FreeLicenseInfo

Description:

    Free the memory allocated for the elements in the TS_LICENSE_INFO structure.

Parameters:

    pTsLicenseInfo - Pointer to a TS_LICENSE_INFO structure

Returns:

    Nothing.

--*/

VOID
FreeLicenseInfo(
    PTS_LICENSE_INFO        pTsLicenseInfo )
{
    FreeTsLicenseInfo( pTsLicenseInfo );
    return;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
AcceptProtocolContext(
    IN HANDLE hContext,
    IN DWORD cbInBuf,
    IN PBYTE pInBuf,
    IN OUT DWORD * pcbOutBuf,
    IN OUT PBYTE * ppOutBuf,
    IN OUT PBOOL pfExtendedError)
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS Status;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

    if (NULL == pLicenseContext)
    {
        return LICENSE_STATUS_INVALID_SERVER_CONTEXT;
    }

	LOCK( &pLicenseContext->CritSec );

    if( INIT == pLicenseContext->State )
    {
        //
        // Generate a hydra server hello message to request for client
        // license
        //

        Status = CreateHydraServerHello(pLicenseContext,
                                        cbInBuf,
                                        pInBuf,
                                        pcbOutBuf,
                                        ppOutBuf);
        goto done;
        
    } 
    else if( SENT_SERVER_HELLO == pLicenseContext->State )
    {
        //
        // Hello response from the client
        //

        Status = HandleHelloResponse(pLicenseContext,
                                     cbInBuf,
                                     pInBuf,
                                     pcbOutBuf,
                                     ppOutBuf,
                                     pfExtendedError);
        goto done;
    }
    else if( ISSUED_PLATFORM_CHALLENGE == pLicenseContext->State )
    {
        //
        // Handle the platform challenge response
        //

        Status = HandlePlatformChallengeResponse(pLicenseContext,
                                                 cbInBuf,
                                                 pInBuf,
                                                 pcbOutBuf,
                                                 ppOutBuf,
                                                 pfExtendedError);
        goto done;
    }
    else
    {
        Status = LICENSE_STATUS_INVALID_SERVER_CONTEXT;
    }

    //
    // check other states to create other messages as required...
    //

done:

    //
    // handle any error before returning.
    //
    // If the current status is LICENSE_STATUS_SERVER_ABORT, it means
    // that we have already tried to handle the error conditions 
    // with no success and the only option is to abort without
    // informing the client licensing protocol.
    //

    if( ( LICENSE_STATUS_OK != Status ) &&
        ( LICENSE_STATUS_CONTINUE != Status ) &&
        ( LICENSE_STATUS_ISSUED_LICENSE != Status ) &&
        ( LICENSE_STATUS_SEND_ERROR != Status ) &&
        ( LICENSE_STATUS_SERVER_ABORT != Status ) &&
        ( LICENSE_STATUS_INVALID_SERVER_CONTEXT != Status ) )
    {
        HandleErrorCondition( pLicenseContext, pcbOutBuf, ppOutBuf, &Status );
    }

    UNLOCK( &pLicenseContext->CritSec );

    return( Status );
}

LICENSE_STATUS
RequestNewLicense(
    IN HANDLE hContext,
    IN TCHAR *tszLicenseServerName,
    IN LICENSEREQUEST *pLicenseRequest,
    IN TCHAR *tszComputerName,
    IN TCHAR *tszUserName,
    IN BOOL fAcceptTempLicense,
    IN BOOL fAcceptFewerLicenses,
    IN DWORD *pdwQuantity,
    OUT DWORD *pcbLicense,
    OUT PBYTE *ppbLicense
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD dwChallengeResponse = 0;
    DWORD RpcStatus;
    DWORD dwSupportFlags = SUPPORT_PER_SEAT_REISSUANCE;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

    LOCK( &pLicenseContext->CritSec );

reconnect:
    if (NULL != tszLicenseServerName)
    {
        LsStatus = CheckConnectNamedLicenseServer(pLicenseContext,
                                                  tszLicenseServerName);
    }
    else
    {
        LsStatus = CheckConnectLicenseServer(pLicenseContext);
    }

    if( LICENSE_STATUS_OK != LsStatus )
    {
        goto done;
    }

    RpcStatus = TLSIssueNewLicenseExEx( 
                        pLicenseContext->hLSHandle,
                        &dwSupportFlags,
                        0,                      // Challenge Context
                        pLicenseRequest,
                        tszComputerName,
                        tszUserName,
                        sizeof(DWORD),          // cbChallengeResponse
                        (PBYTE) &dwChallengeResponse,
                        fAcceptTempLicense,
                        fAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NO_LICENSE_ERROR);
    }
    else
    {
        LsStatus = LICENSE_STATUS_OK;
    }

done:

    UNLOCK( &pLicenseContext->CritSec );

    return LsStatus;
}

// TODO: Generalize this for all license types

LICENSE_STATUS
ReturnInternetLicense(
    IN HANDLE hContext,
    IN TCHAR *tszLicenseServer,
    IN LICENSEREQUEST *pLicenseRequest,
    IN ULARGE_INTEGER ulSerialNumber,
    IN DWORD dwQuantity
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD RpcStatus;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

	LOCK( &pLicenseContext->CritSec );


reconnect:
    if (NULL != tszLicenseServer)
    {
        LsStatus = CheckConnectNamedLicenseServer(pLicenseContext,
                                                  tszLicenseServer);
    }
    else
    {
        LsStatus = CheckConnectLicenseServer(pLicenseContext);
    }

    if (LICENSE_STATUS_OK != LsStatus)
    {
        goto done;
    }

    RpcStatus = TLSReturnInternetLicenseEx(
                         pLicenseContext->hLSHandle,
                         pLicenseRequest,
                         &ulSerialNumber,
                         dwQuantity,
                         &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NOT_SUPPORTED);
    }
    else
    {
        LsStatus = LICENSE_STATUS_OK;
    }

done:

    UNLOCK( &pLicenseContext->CritSec );

    return( LsStatus );
}

/****************************************************************************
 *
 * FileTimeToUnixTime
 *
 *   Convert FILETIME to UNIX time (time_t)
 *
 * ENTRY:
 *   pft (input)
 *     pointer FILETIME structure
 *   t (input/output)
 *     pointer to UNIX time
 *
 * EXIT:
 *   TRUE - Success
 *   FALSE - Failure
 *
 ****************************************************************************/

BOOL
FileTimeToUnixTime(
    LPFILETIME  pft,
    time_t *    t
    )
{
    SYSTEMTIME sysTime;
    struct tm gmTime;

    if( FileTimeToSystemTime( pft, &sysTime ) == FALSE )
    {
        return( FALSE );
    }

    if( sysTime.wYear >= 2038 )
    {
        *t = INT_MAX;
    }
    else
    {
        //
        // Unix time support up to 2038/1/18
        // restrict any expiration data
        //

        memset( &gmTime, 0, sizeof( gmTime ) );
        gmTime.tm_sec = sysTime.wSecond;
        gmTime.tm_min = sysTime.wMinute;
        gmTime.tm_hour = sysTime.wHour;
        gmTime.tm_year = sysTime.wYear - 1900;
        gmTime.tm_mon = sysTime.wMonth - 1;
        gmTime.tm_mday = sysTime.wDay;

        *t = mktime( &gmTime );
    }

    return( *t != ( time_t )-1 );
}

/*++

Function:

    DaysToExpiration

Description:

    Return expiration info from the client license

Parameters:

    hContext - License protocol context
    pdwDaysLeft - Number of days to expiration is returned here.  If the
                        license has already expired, this is 0.  If the
                        license has no expiration date, this is 0xFFFFFFFF
    pfTemporary - Whether the license is temporary is returned here

Return:

    If successful, the output parameters are filled in, and this
    function returns LICENSE_STATUS_SUCCESS.  Otherwise, returns a
    LICENSE_STATUS error.

--*/

LICENSE_STATUS
DaysToExpiration(
    HANDLE               hContext,
    DWORD                *pdwDaysLeft,
    BOOL                 *pfTemporary
    )
{
    PHS_Protocol_Context
        pLicenseContext = (PHS_Protocol_Context) hContext;
    time_t
        Expiration,
        CurrentTime;

    if ( NULL == hContext )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    //
    // indicate if the license is temporary
    //

    if (NULL != pfTemporary)
    {
        *pfTemporary = pLicenseContext->pTsLicenseInfo->fTempLicense;
    }

    //
    // license validity dates
    //

    if (NULL != pdwDaysLeft)
    {
        if ( FALSE == FileTimeToUnixTime( &pLicenseContext->pTsLicenseInfo->NotAfter, &Expiration ) )
        {
            return (LICENSE_STATUS_INVALID_CLIENT_CONTEXT);
        }

        if (PERMANENT_LICENSE_EXPIRE_DATE == Expiration)
        {
            *pdwDaysLeft = 0xFFFFFFFF;
        }
        else
        {
            time( &CurrentTime );

            if( CurrentTime >= Expiration )
            {
                //
                // license already expired
                //

                *pdwDaysLeft = 0;
            }

            //
            // figure out how many more days to go before license expires
            //

            *pdwDaysLeft = (DWORD)(( Expiration - CurrentTime ) / SECONDS_IN_A_DAY);
        }
    }

    return( LICENSE_STATUS_OK );
}


/*++

Function:

    MarkLicenseFlags

Description:

    Marks the license at the license server as being used in a valid logon.

--*/

LICENSE_STATUS
MarkLicenseFlags(
    HANDLE hContext,
    UCHAR ucFlags
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD RpcStatus;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    if (!pLicenseContext->pTsLicenseInfo->fTempLicense)
    {
        return LICENSE_STATUS_OK;
    }

    // TODO: This can be done on a background thread, so that it doesn't
    // block logon

	LOCK( &pLicenseContext->CritSec );

reconnect:
    LsStatus = CheckConnectLicenseServer(pLicenseContext);

    if( LICENSE_STATUS_OK != LsStatus )
    {
        goto done;
    }

    RpcStatus = TLSMarkLicense( 
                        pLicenseContext->hLSHandle,
                        ucFlags,
                        pLicenseContext->pTsLicenseInfo->cbRawLicense,
                        pLicenseContext->pTsLicenseInfo->pbRawLicense,
                        &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NOT_SUPPORTED);
    }
    else
    {
        LsStatus = LICENSE_STATUS_OK;
    }

done:
    UNLOCK( &pLicenseContext->CritSec );

    return LsStatus;
}


/*++

Function:

    CacheRawLicenseData

Description:

    Caches the unpacked license bits in the TS_LICENSE_INFO for later use.
    The TS_LICENSE_INFO struct should already be created.

--*/

LICENSE_STATUS
CacheRawLicenseData(
    PHS_Protocol_Context pLicenseContext,
    PBYTE pbRawLicense,
    DWORD cbRawLicense
    )
{
    LICENSE_STATUS Status;

    if ((pLicenseContext == NULL) || (pLicenseContext->pTsLicenseInfo == NULL))
    {
        return(LICENSE_STATUS_INVALID_INPUT);
    }

    if (pLicenseContext->pTsLicenseInfo->pbRawLicense != NULL)
    {
        LicenseMemoryFree(&(pLicenseContext->pTsLicenseInfo->pbRawLicense));
    }

    Status = LicenseMemoryAllocate(cbRawLicense,
            &(pLicenseContext->pTsLicenseInfo->pbRawLicense));

    if (Status == LICENSE_STATUS_OK)
    {
        memcpy(pLicenseContext->pTsLicenseInfo->pbRawLicense, pbRawLicense,
                cbRawLicense);

        pLicenseContext->pTsLicenseInfo->cbRawLicense = cbRawLicense;
    }

    return(Status);
}

/*++

Function:

    SetExtendedData

Description:

    Sets the new fields in the TsLicenseInfo.

--*/

LICENSE_STATUS
SetExtendedData(
    PHS_Protocol_Context pLicenseContext,
    DWORD dwSupportFlags
    )
{
    if ((pLicenseContext == NULL) || (pLicenseContext->pTsLicenseInfo == NULL))
    {
        return(LICENSE_STATUS_INVALID_INPUT);
    }

    pLicenseContext->pTsLicenseInfo->dwSupportFlags = dwSupportFlags;

    return(LICENSE_STATUS_OK);
}

/*++

Function:

    LsStatusToLicenseStatus

Description:

    Map a license server error code to a LICENSE_STATUS

--*/

LICENSE_STATUS
LsStatusToLicenseStatus(
    DWORD LsStatus,
    DWORD LsStatusDefault
    )
{
    LICENSE_STATUS LicenseStatus;

    switch (LsStatus)
    {
    case LSERVER_S_SUCCESS:
        LicenseStatus = LICENSE_STATUS_OK;
        break;

    case LSERVER_E_OUTOFMEMORY:
        LicenseStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        break;

    case LSERVER_E_INVALID_DATA:
        LicenseStatus = LICENSE_STATUS_INVALID_INPUT;
        break;

    case LSERVER_E_LS_NOTPRESENT:
    case LSERVER_E_LS_NOTRUNNING:
        LicenseStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        break;

    case LSERVER_E_NO_LICENSE:
    case LSERVER_E_NO_PRODUCT:
    case LSERVER_E_NO_CERTIFICATE:      // not activated
        LicenseStatus = LICENSE_STATUS_NO_LICENSE_ERROR;
        break;

    case LSERVER_E_INTERNAL_ERROR:
        LicenseStatus = LICENSE_STATUS_UNSPECIFIED_ERROR;
        break;

    default:
        LicenseStatus = LsStatusDefault;
        break;
    }

    return LicenseStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\hspack.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       HSpack.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//				going out and coming in from the server
//  Classes:
//
//  Functions:
//
//  History:    12-20-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef	_HSPACK_H_
#define _HSPACK_H_

//
// Functions for Packing different Server Messages from the corresponding
// structures to simple binary blob
//

LICENSE_STATUS
PackHydraServerLicenseRequest(
    DWORD                           dwProtocolVersion,
    PHydra_Server_License_Request   pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerPlatformChallenge(
    DWORD                               dwProtocolVersion,
    PHydra_Server_Platform_Challenge    pCanonical,
    PBYTE *                             ppbBuffer,
    DWORD *                             pcbBuffer );

LICENSE_STATUS
PackHydraServerNewLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_New_License       pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerUpgradeLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_Upgrade_License   pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerErrorMessage(
    DWORD                           dwProtocolVersion,
    PLicense_Error_Message          pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );


LICENSE_STATUS
PackNewLicenseInfo(
    PNew_License_Info               pCanonical,
    PBYTE *                         ppNetwork, 
    DWORD *                         pcbNetwork );

LICENSE_STATUS
PackExtendedErrorInfo( 
                   UINT32       uiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo);

//
// Functions for unpacking different Hydra Client Messages from 
// simple binary blobs to corresponding structure
//

				
LICENSE_STATUS
UnPackHydraClientErrorMessage(
    PBYTE                   pbMessage,
    DWORD                   cbMessage,
    PLicense_Error_Message  pCanonical,
    BOOL*                   pfExtendedError);


LICENSE_STATUS
UnPackHydraClientLicenseInfo(
    PBYTE                       pbMessage,
    DWORD                       cbMessage, 
    PHydra_Client_License_Info  pCanonical,
    BOOL*                       pfExtendedError);


LICENSE_STATUS
UnPackHydraClientNewLicenseRequest(
    PBYTE                               pbMessage,
    DWORD                               cbMessage,
    PHydra_Client_New_License_Request   pCanonical,
    BOOL*                               pfExtendedError);


LICENSE_STATUS
UnPackHydraClientPlatformChallengeResponse(
    PBYTE                                       pbMessage,
    DWORD                                       cbMessage,
    PHydra_Client_Platform_Challenge_Response   pCanonical,
    BOOL*                                       pfExtendedError);

#endif	//_HSPACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\licprotp.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licprotp.h
//
// Contents:    Hydra Server License Protocol API private header file
//
// History:     02-08-00    RobLeit  Created
//
//-----------------------------------------------------------------------------


#ifndef _LICPROTP_H_
#define _LICPROTP_H_

//-----------------------------------------------------------------------------
//
// Hydra server licensing-related registry keys and values
//
//-----------------------------------------------------------------------------

#define HYDRA_SERVER_PARAM              L"SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters"
#define PERSEAT_LEEWAY_VALUE            L"PerSeatExpirationLeeway"

//-----------------------------------------------------------------------------
//
// Info of the license requester
//
// pwszMachineName - The name of the machine that the license is installed on.
// pwszUserName - The user name for which the license is issued to.
//
//-----------------------------------------------------------------------------

typedef struct _License_Requester_Info
{
    LPTSTR ptszMachineName;
    LPTSTR ptszUserName;

} License_Requester_Info, * PLicense_Requester_Info;


//-----------------------------------------------------------------------------
//
// The license request structure
//
//-----------------------------------------------------------------------------

typedef LICENSEREQUEST License_Request;
typedef PLICENSEREQUEST PLicense_Request;

//-----------------------------------------------------------------------------
//
// The files containing the hydra server certificates and keys
//
//-----------------------------------------------------------------------------

#define HYDRA_SERVER_RSA_CERTIFICATE_FILE   L"hsrsa.cer"
#define HYDRA_SERVER_PRIVATE_KEY_FILE       L"hskey.prv"

//-----------------------------------------------------------------------------
//
// Registry value to configure number of days prior to grace period expiration
// for event logging.
//
//-----------------------------------------------------------------------------

#define HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS   L"LicensingGracePeriodExpirationWarningDays"

//-----------------------------------------------------------------------------
//
// The license protocol states
//
//-----------------------------------------------------------------------------

typedef enum
{
    INIT = 1,
    SENT_SERVER_HELLO,
    CLIENT_LICENSE_PENDING,
    ISSUED_PLATFORM_CHALLENGE,
    ABORTED,
    ISSUED_LICENSE_COMPLETE,
    VALIDATION_ERROR,
    VALIDATED_LICENSE_COMPLETE

} HS_LICENSE_STATE;

///////////////////////////////////////////////////////////////////////////
// The validation information that needs to be given to validate a license.
//

typedef struct _Validation_Info
{
    Product_Info  * pProductInfo;
    DWORD           cbLicense;
    PBYTE           pLicense;
    DWORD           cbValidationData;
    PBYTE           pValidationData;

} Validation_Info, * PValidation_Info;

//////////////////////////////////////////////////////////////////////////////
// The data used for verifying licenses
//

typedef struct _License_Verification_Data
{
    //
    // encrypted HWID
    //

    PBYTE       pEncryptedHwid;
    DWORD       cbEncryptedHwid;

    //
    // Valid dates
    //

    FILETIME    NotBefore;
    FILETIME    NotAfter;

    //
    // License Info
    //

    LPCERT_LICENSE_INFO pLicenseInfo;

    //
    // Manufacturer
    //

    PBYTE       pManufacturer;
    
    //
    // Manufacturer Data
    //

    LPMSMANUFACTURER_DATA pManufacturerData;
    
    //
    // Add any other fields necessary for verifying a license:
    //
      
} License_Verification_Data, * PLicense_Verification_Data;

//-----------------------------------------------------------------------------
//
// license protocol context
//
//-----------------------------------------------------------------------------

typedef struct _HS_Protocol_Context
{
    CRITICAL_SECTION    CritSec;    
    DWORD               dwProtocolVersion;
    BOOL                fAuthenticateServer;
    Product_Info        ProductInfo;
    HS_LICENSE_STATE    State;
    TLS_HANDLE          hLSHandle;
    DWORD               dwClientPlatformID;
    DWORD               dwClientError;
    PCHALLENGE_CONTEXT  pChallengeContext;
    PTCHAR              ptszClientUserName;
    PTCHAR              ptszClientMachineName;
    CERT_TYPE           CertTypeUsed;
    DWORD               dwKeyExchangeAlg;
    DWORD               cbOldLicense;
    PBYTE               pbOldLicense;
    PTS_LICENSE_INFO    pTsLicenseInfo;
    CryptSystem         CryptoContext;
    BOOL                fLoggedProtocolError;
    BYTE                Scope[MAX_PRODUCT_INFO_STRING_LENGTH];

} HS_Protocol_Context, * PHS_Protocol_Context;

//#define PLATFORM_CHALLENGE_LENGTH       64

//-----------------------------------------------------------------------------
//
// Internal Functions
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
CreateHydraServerHello( 
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


void
HandleErrorCondition( 
    PHS_Protocol_Context        pLicenseContext, 
    PDWORD                      pcbOutBuf, 
    PBYTE          *            ppOutBuf, 
    LICENSE_STATUS *            pStatus );


LICENSE_STATUS
ConstructServerResponse(
    DWORD                           dwProtocolVersion,
    DWORD                           dwResponse,
    UINT32                          uiExtendedErrorInfo,
    PDWORD                          pcbOutBuf,
    PBYTE *                         ppOutBuf,
    BOOL                            fExtendedError);


LICENSE_STATUS
HandleHelloResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL pfExtendedError);


LICENSE_STATUS
HandleClientLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL pfExtendedError);


LICENSE_STATUS
HandleNewLicenseRequest(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL  pfExtendedError);


LICENSE_STATUS
HandleClientError(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL   pfExtendedError);


LICENSE_STATUS
HandlePlatformChallengeResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf,
    PBOOL pfExtendedError);


LICENSE_STATUS
GetEnvelopedData( 
    CERT_TYPE   CertType,
    PBYTE       pEnvelopedData,
    DWORD       dwEnvelopedDataLen,
    PBYTE *     ppData,
    PDWORD      pdwDataLen );


LICENSE_STATUS
InitProductInfo(
    PProduct_Info pProductInfo,
    LPTSTR        lptszProductSku );


LICENSE_STATUS
IssuePlatformChallenge(
    PHS_Protocol_Context      pLicenseContext, 
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf );


LICENSE_STATUS
PackageLicense(
    PHS_Protocol_Context      pLicenseContext, 
    DWORD                     cbLicense,
    PBYTE                     pLicense,
    PDWORD                    pcbOutBuf,
    PBYTE                   * ppOutBuf,
    BOOL                      fNewLicense );


void
LicenseLogEvent(
    WORD wEventType,
    DWORD dwEventId,
    WORD cStrings,
    PWCHAR *apwszStrings );

LICENSE_STATUS
CacheRawLicenseData(
    PHS_Protocol_Context pLicenseContext,
    PBYTE pbRawLicense,
    DWORD cbRawLicense );


LICENSE_STATUS
SetExtendedData(
    PHS_Protocol_Context pLicenseContext,
    DWORD dwSupportFlags );


#ifdef UNICODE

LICENSE_STATUS
Ascii2Wchar(
    LPSTR lpszAsciiStr,
    LPWSTR * ppwszWideStr );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\cmdln.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	cmdln.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrCommandLine class
    (used for CommandLine Processing)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "cmdln.h"
//Change this function to process the commandline differently

void CLicMgrCommandLine::ParseParam(LPCTSTR pszParam, BOOL bFlag, BOOL bLast)
{
   if (!bFlag && m_bFirstParam)
   {
      m_FileName = pszParam;
      m_bFirstParam = FALSE;
   }
}

CLicMgrCommandLine::CLicMgrCommandLine():CCommandLineInfo()
{
    m_bFirstParam = TRUE;
    m_FileName = _T("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\precomp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <lmcons.h>

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>
#include <mbstring.h>
#include <tchar.h>
#include <time.h>
#include <limits.h>

#include "license.h"
#include "lscsp.h"
#include "certutil.h"
#include <tssec.h>

#include "hslice.h"
#include "cryptkey.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "base64.h"
#include "licprotp.h"
#include "verify.h"
#include "hspack.h"
#include "sysapi.h"
#include "icaevent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\verify.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        verify.h
//
// Contents:    Header file for license Verification API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#ifndef _VERIFY_H_
#define _VERIFY_H_

///////////////////////////////////////////////////////////////////////////////
// 
// These is the license upgrade logic
//
//  Action            |   Temp License |     Expired     |   Version < HS
//                    |                |                 |   
//  ---------------------------------------------------------------------------
//  Should Upgrade    |        1       |         0       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         1       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         0       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         1       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         1       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         1       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         0       |       1
//  ---------------------------------------------------------------------------
//  Should Upgrade    |        0       | 0 (past leeway) |       0
//  ---------------------------------------------------------------------------
//  OK                |        0       |         0       |       0
//  ---------------------------------------------------------------------------
//

///////////////////////////////////////////////////////////////////////////////
#define LICENSE_STATE_TEMPORARY         0x00000001
#define LICENSE_STATE_EXPIRED           0x00000002
#define LICENSE_STATE_OLD_VERSION       0x00000004
#define LICENSE_STATE_INVALID_PRODUCT   0x00000008  // TS5 RC1 license server
                                                    //  bug - must upgrade
#define LICENSE_STATE_LEEWAY            0x00000010

#define VERIFY_RESULT_TEMP_0_0          LICENSE_STATE_TEMPORARY
#define VERIFY_RESULT_TEMP_EXPIRED_0    LICENSE_STATE_TEMPORARY | LICENSE_STATE_EXPIRED
#define VERIFY_RESULT_TEMP_0_OLD        LICENSE_STATE_TEMPORARY | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_TEMP_EXPIRED_OLD  LICENSE_STATE_TEMPORARY | LICENSE_STATE_EXPIRED | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_EXPIRED_0       LICENSE_STATE_EXPIRED
#define VERIFY_RESULT_0_EXPIRED_OLD     LICENSE_STATE_EXPIRED | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_LEEWAY_0        LICENSE_STATE_LEEWAY
#define VERIFY_RESULT_0_LEEWAY_OLD      LICENSE_STATE_LEEWAY | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_0_OLD           LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_0_0             0x00000000
#define VERIFY_RESULT_INVALID_PRODUCT   LICENSE_STATE_INVALID_PRODUCT
#define VERIFY_RESULT_BETA_LICENSE      VERIFY_RESULT_TEMP_EXPIRED_0


#define LicenseInitState( _CurrentState ) \
    _CurrentState = 0

#define LicenseSetState( _CurrentState, _State ) \
    _CurrentState |= _State


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyHwid(
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
VerifyLicenseSignature(
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,    
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
VerifyProductInfo(
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLicense_Verification_Data  pDecodedData,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
VerifyDateAndTime(
    PLicense_Verification_Data  pDecodedData,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
GetVerifyResult(
    DWORD   dwLicenseState );


LICENSE_STATUS
VerifyClientHwid( 
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo );


LICENSE_STATUS
VerifyLicenseProductInfo( 
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
VerifyLicenseDateAndTime( 
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\timebomb.cpp ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        timebomb.cpp
//
// Contents:    Implement licensing timebomb-related APIs
//
// History:     08-12-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#include "precomp.h"
#include "tlsapip.h"
#include "time.h"

extern "C" {

//-----------------------------------------------------------------------------
//
// The LSA secret name used to store the licensing timebomb expiration
//
//-----------------------------------------------------------------------------

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define BETA2_LICENSING_TIME_BOMB_5_1 L"BETA2TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

#define HS_PARAM_GRACE_PERIOD_ENDED   L"LicensingGracePeriodEnded"

//-----------------------------------------------------------------------------
//
// The global licensing time bomb value.
//
//-----------------------------------------------------------------------------

FILETIME g_LicenseTimeBomb;

//-----------------------------------------------------------------------------
//
// The number of licensing grace period is 90 days.  By default, we start
// logging events when there are less than 15 days from expiration and the
// terminal server has not registered itself with a license server.
//
//-----------------------------------------------------------------------------

#define GRACE_PERIOD 120
#define GRACE_PERIOD_EXPIRATION_WARNING_DAYS 15


//-----------------------------------------------------------------------------
//
// Only log the grace period warning or error once a day.  
//
//-----------------------------------------------------------------------------

#define GRACE_PERIOD_EVENT_LOG_INTERVAL     (1000*60*60*24)

//-----------------------------------------------------------------------------
//
// Thread used to warn administrator when grace period is about to expire
//
//-----------------------------------------------------------------------------
HANDLE g_GracePeriodThreadExitEvent = NULL;
CRITICAL_SECTION g_EventCritSec;

//-----------------------------------------------------------------------------
//
// Internal functions
//
//-----------------------------------------------------------------------------

BOOL
CalculateTimeBombExpiration(
    FILETIME *  pExpiration );

DWORD
GetExpirationWarningDays();

BOOL
IsLicensingTimeBombExpired();

/*++

Function:

    InitializeLicensingTimeBomb

Description:

    Initialize the licensing time bomb value.

Argument:

    None.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
InitializeLicensingTimeBomb()
{
    LICENSE_STATUS
        Status;
    DWORD
        cbTimeBomb = sizeof( FILETIME );
    NTSTATUS
        NtStatus;

    NtStatus = RtlInitializeCriticalSection(&g_EventCritSec);

    if (STATUS_SUCCESS != NtStatus)
    {
        return LICENSE_STATUS_INITIALIZATION_FAILED;
    }

    Status = LsCsp_RetrieveSecret( 
                        (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                        ( LPBYTE )&g_LicenseTimeBomb,
                        &cbTimeBomb );

    if( LICENSE_STATUS_OK == Status && cbTimeBomb == sizeof(g_LicenseTimeBomb) )
    {
        return( LICENSE_STATUS_OK );
    }

    //
    // Calculate and set the timebomb
    //

    if( FALSE == CalculateTimeBombExpiration( &g_LicenseTimeBomb ) )
    {
#if DBG
        DbgPrint( "CalculateTimeBombExpiration: cannot calculate licensing time bomb expiration.\n" );
#endif
        return( LICENSE_STATUS_INITIALIZATION_FAILED );
    }

    Status = LsCsp_StoreSecret( 
                        (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                        ( LPBYTE )&g_LicenseTimeBomb,
                        sizeof( g_LicenseTimeBomb ) );

    return( Status );
}


/*++

Function:

    IsLicensingTimeBombExpired

Description:

    Check if the licensing time bomb has expired.

Argument:

    None.

Return:

    TRUE if the timebomb has expired or FALSE otherwise.

--*/

BOOL
IsLicensingTimeBombExpired()
{
    SYSTEMTIME
        SysTimeNow;
    FILETIME
        FileTimeNow,
        FileTimeExpiration;

    GetSystemTime( &SysTimeNow );

    SystemTimeToFileTime( &SysTimeNow, &FileTimeNow );
    
    RtlEnterCriticalSection(&g_EventCritSec);

    FileTimeExpiration.dwLowDateTime = g_LicenseTimeBomb.dwLowDateTime;
    FileTimeExpiration.dwHighDateTime = g_LicenseTimeBomb.dwHighDateTime;

    RtlLeaveCriticalSection(&g_EventCritSec);

    if( 0 > CompareFileTime( &FileTimeExpiration, &FileTimeNow ) )
    {
        return( TRUE );
    }
    
    return( FALSE );
}

/*++

Function:

    CalculateTimeBombExpiration

Description:

    Calculate the licensing time bomb expiration.

Argument:

    pExpiration - The timebomb expiration date and time

Return:

    TRUE if the expiration is calculated successfully or FALSE otherwise.

--*/

BOOL
CalculateTimeBombExpiration(
    FILETIME *  pExpiration )
{
    time_t 
        now = time( NULL );
    struct tm *
        GmTime = gmtime( &now );
    SYSTEMTIME
        SysTime;
    
    if(( NULL == pExpiration ) || ( NULL == GmTime ))
    {
        return( FALSE );
    }

    //
    // Add the days of licensing grace period to get the time bomb
    // expiration.
    //

    GmTime->tm_mday += GRACE_PERIOD;
    
    if( ( ( time_t ) -1 ) == mktime( GmTime ) )
    {
        return( FALSE );
    }

    memset( &SysTime, 0, sizeof( SYSTEMTIME ) ); 

    SysTime.wYear            = (WORD) GmTime->tm_year + 1900;
    SysTime.wMonth           = (WORD) GmTime->tm_mon + 1;
    SysTime.wDay             = (WORD) GmTime->tm_mday;
    SysTime.wDayOfWeek       = (WORD) GmTime->tm_wday;
    SysTime.wHour            = (WORD) GmTime->tm_hour;    
    SysTime.wMinute          = (WORD) GmTime->tm_min;    
    SysTime.wSecond          = (WORD) GmTime->tm_sec;    

    return( SystemTimeToFileTime( &SysTime, pExpiration ) );

}

/*++

Function:

    ReceivedPermanentLicense();

Description:

    Store the fact that we've received a permanent license

Argument:

    None.

--*/

VOID
ReceivedPermanentLicense()
{
    static fReceivedPermanent = FALSE;

    if (!fReceivedPermanent)
    {
        RtlEnterCriticalSection(&g_EventCritSec);

        if (IsLicensingTimeBombExpired())
        {
            // We expired at some time in the past (before the last reboot)

            fReceivedPermanent = TRUE;
            HKEY hKey = NULL;
            DWORD dwDisp;
            LONG lReturn;
            lReturn = RegCreateKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        HYDRA_SERVER_PARAM,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisp );

            if( ERROR_SUCCESS == lReturn )
            {
                //
                // setting the LicensingGracePeriodEnded DWORD value, the data of the value is not used
                //
                DWORD dwDays = 0;

                lReturn = RegSetValueEx( 
                                    hKey,
                                    HS_PARAM_GRACE_PERIOD_ENDED,
                                    0,
                                    REG_DWORD,
                                    ( PBYTE )&dwDays,
                                    sizeof( DWORD ) );

            }
            if(hKey)
            {
                RegCloseKey(hKey);
            }     
        }
        else if (!fReceivedPermanent)
        {
            FILETIME ftNow;
            SYSTEMTIME stNow;

            fReceivedPermanent = TRUE;

            GetSystemTime( &stNow );

            SystemTimeToFileTime( &stNow , &ftNow );

            LsCsp_StoreSecret( 
                              (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                              ( LPBYTE ) &ftNow,
                              sizeof( ftNow ) );

            g_LicenseTimeBomb.dwLowDateTime = ftNow.dwLowDateTime;
            g_LicenseTimeBomb.dwHighDateTime = ftNow.dwHighDateTime;
        }


        RtlLeaveCriticalSection(&g_EventCritSec);
    }
}

/*++

Function:

    CheckLicensingTimeBombExpiration();


Description:

    The following events are logged when the terminal server
    has not registered itself with a license server:

    (1) The grace period for registration has expired
    (2) The grace period for registration is about to expire.  By default, 
    the system starts logging this event 15 days prior to the grace period
    expiration.

Argument:

    None.

Return:

    Nothing.

--*/

VOID
CheckLicensingTimeBombExpiration()
{
    SYSTEMTIME
        SysWarning,
        SysExpiration;
    FILETIME
        FileWarning,
        FileExpiration,
        CurrentTime;
    struct tm 
        tmWarning,
        tmExpiration;
    DWORD
        dwWarningDays;

    //
    // if the licensing timebomb has expired, go ahead and log the event now
    //

    if( IsLicensingTimeBombExpired() )
    {
        if( FALSE == RegisteredWithLicenseServer())
        {
            LicenseLogEvent( 
                    EVENTLOG_ERROR_TYPE,
                    EVENT_LICENSING_GRACE_PERIOD_EXPIRED,
                    0, 
                    NULL );
        }

        return;
    }

    //
    // get the timebomb expiration in system time format
    //

    RtlEnterCriticalSection(&g_EventCritSec);

    FileExpiration.dwLowDateTime = g_LicenseTimeBomb.dwLowDateTime;
    FileExpiration.dwHighDateTime = g_LicenseTimeBomb.dwHighDateTime;

    RtlLeaveCriticalSection(&g_EventCritSec);

    if( !FileTimeToSystemTime( &FileExpiration, &SysExpiration ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: FileTimeToSystemTime failed: 0x%x\n", GetLastError() );
#endif
        return;
    }

    //
    // convert the timebomb expiration to tm format
    //

    tmExpiration.tm_year  = SysExpiration.wYear - 1900;
    tmExpiration.tm_mon   = SysExpiration.wMonth - 1;
    tmExpiration.tm_mday  = SysExpiration.wDay;
    tmExpiration.tm_wday  = SysExpiration.wDayOfWeek;
    tmExpiration.tm_hour  = SysExpiration.wHour;
    tmExpiration.tm_min   = SysExpiration.wMinute;
    tmExpiration.tm_sec   = SysExpiration.wSecond; 
    tmExpiration.tm_isdst = -1;

    memcpy( &tmWarning, &tmExpiration, sizeof( tm ) );

    //
    // Get the number of days prior to expiration to start logging event
    //

    dwWarningDays = GetExpirationWarningDays();

    //
    // subtract these number of days from the expiration date
    //

    tmWarning.tm_mday -= dwWarningDays;

    //
    // get the accurate date
    //

    if( ( ( time_t ) -1 ) == mktime( &tmWarning ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: mktime failed\n" );
#endif
        return;
    }

    //
    // convert the date to systemtime format
    //

    memset( &SysWarning, 0, sizeof( SYSTEMTIME ) ); 

    SysWarning.wYear            = (WORD) tmWarning.tm_year + 1900;
    SysWarning.wMonth           = (WORD) tmWarning.tm_mon + 1;
    SysWarning.wDay             = (WORD) tmWarning.tm_mday;
    SysWarning.wDayOfWeek       = (WORD) tmWarning.tm_wday;
    SysWarning.wHour            = (WORD) tmWarning.tm_hour;    
    SysWarning.wMinute          = (WORD) tmWarning.tm_min;    
    SysWarning.wSecond          = (WORD) tmWarning.tm_sec;    

    //
    // convert from systemtime to filetime
    //

    if( !SystemTimeToFileTime( &SysWarning, &FileWarning ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: SystemTimeToFileTime failed: 0x%x\n", GetLastError() );
#endif
        return;
    }

    //
    // get the current time
    //

    GetSystemTimeAsFileTime( &CurrentTime );

    //
    // Log an event if we are within the warning period
    //

    if( 0 > CompareFileTime( &FileWarning, &CurrentTime ) )
    {
        LPTSTR szDate = TEXT("err");
        LPTSTR
            ptszLogString[1];
        int cchDate;
        BOOL fAllocated = FALSE;

        //
        // get the expiration date in string format.
        //
        cchDate = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                LOCALE_NOUSEROVERRIDE,
                                &SysWarning,
                                NULL,
                                NULL,
                                0);

        if (0 != cchDate)
        {
            szDate = (LPTSTR) LocalAlloc(LMEM_FIXED,cchDate * sizeof(TCHAR));

            if (NULL != szDate)
            {
                fAllocated = TRUE;

                if (0 == GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                       LOCALE_NOUSEROVERRIDE,
                                       &SysWarning,
                                       NULL,
                                       szDate,
                                       cchDate))
                {
                    LocalFree(szDate);
                    fAllocated = FALSE;
                    szDate = TEXT("err");
                }
            }
            else
            {
                szDate = TEXT("err");
            }
        }

        //
        // log the event
        //
        
        ptszLogString[0] = szDate;

        LicenseLogEvent( 
                        EVENTLOG_WARNING_TYPE,
                        EVENT_LICENSING_GRACE_PERIOD_ABOUT_TO_EXPIRE,
                        1, 
                        ptszLogString );

        if (fAllocated)
        {
            LocalFree(szDate);
        }
    }

    return;
}


/*++

Function:

    GetExpirationWarningDays

Descriptions:

    Get the number of days prior to grace period expiration to log warning.

Arguments:

    none.

Returns:

    Nothing.

--*/

DWORD
GetExpirationWarningDays()
{
    HKEY
        hKey = NULL;
    DWORD
        dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
        dwValueType,
        dwDisp,
        cbValue = sizeof( DWORD );
    LONG
        lReturn;

    lReturn = RegCreateKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        HYDRA_SERVER_PARAM,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisp );

    if( ERROR_SUCCESS == lReturn )
    {
        //
        // query the number of days prior to expiration to log warnings
        //

        lReturn = RegQueryValueEx( 
                            hKey,
                            HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
                            NULL,
                            &dwValueType,
                            ( LPBYTE )&dwDays,
                            &cbValue );

        if( ERROR_SUCCESS == lReturn )
        {
            //
            // check if the warning days value is within bound
            //

            if( dwDays > GRACE_PERIOD )
            {
                dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS;
            }
        }
        else
        {
            //
            // can't query the value, set the default
            //

            dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS;

            lReturn = RegSetValueEx( 
                            hKey,
                            HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
                            0,
                            REG_DWORD,
                            ( PBYTE )&dwDays,
                            sizeof( DWORD ) );
        }
    }

    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( dwDays );
}

/****************************************************************************
 *
 * _AllowLicensingGracePeriodConnection
 *
 *   Check if the licensing grace period has expired.
 *
 * ENTRY:
 *   Nothing.
 *
 * EXIT:
 *   TRUE           - Allow connection
 *   FALSE          - Disallow connection
 *
 ****************************************************************************/

BOOL
AllowLicensingGracePeriodConnection()
{
    return !IsLicensingTimeBombExpired();
}

DWORD WINAPI
GracePeriodCheckingThread(
                          LPVOID lpParam)
{
    HANDLE hExit = (HANDLE) lpParam;
    DWORD dwWaitStatus;
    DWORD dwWaitInterval = GRACE_PERIOD_EVENT_LOG_INTERVAL;
    HKEY hKey = NULL;

    // Yield our first time slice

    Sleep(0);

    while (1)
    {        
        LONG lReturn;
        DWORD dwDisp,
            dwValueType,
            dwDays, 
            cbValue = sizeof( DWORD );

        lReturn = RegCreateKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        HYDRA_SERVER_PARAM,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisp );

        if( ERROR_SUCCESS == lReturn )
        {
            //
            // query the presence of LicensingGracePeriodEnded value.
            //                

            lReturn = RegQueryValueEx( 
                        hKey,
                        HS_PARAM_GRACE_PERIOD_ENDED,
                        NULL,
                        &dwValueType,
                        ( LPBYTE )&dwDays,
                        &cbValue );

           
        }
        
        if(ERROR_SUCCESS != lReturn)
        {

            CheckLicensingTimeBombExpiration();

            dwWaitStatus = WaitForSingleObject(hExit, dwWaitInterval);

            if (WAIT_OBJECT_0 == dwWaitStatus)
            {
                g_GracePeriodThreadExitEvent = NULL;
                // hExit was signalled
                CloseHandle(hExit);

                goto done;
            }
        }
        else
        {
            g_GracePeriodThreadExitEvent = NULL;

            CloseHandle(hExit);
            goto done;
        }

        if(hKey != NULL)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

done:

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }
    return 1;
}

DWORD
StartCheckingGracePeriod()
{
    HANDLE hThread = NULL;
    DWORD Status = ERROR_SUCCESS;

    if (NULL != g_GracePeriodThreadExitEvent)
    {
        // already started
        return ERROR_SUCCESS;
    }

    RtlEnterCriticalSection(&g_EventCritSec);

    // Check one more time

    if (NULL != g_GracePeriodThreadExitEvent)
    {
        // already started
        goto done;
    }

    //
    // Create the event to signal thread exit
    //
        
    g_GracePeriodThreadExitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( NULL == g_GracePeriodThreadExitEvent )
    {
        Status = GetLastError();
        goto done;
    }

    //
    // Create the caching thread
    //
        
    hThread = CreateThread(
                           NULL,
                           0,
                           GracePeriodCheckingThread,
                           ( LPVOID )g_GracePeriodThreadExitEvent,
                           0,
                           NULL );

    if (hThread == NULL)
    {
        HANDLE hLocal = g_GracePeriodThreadExitEvent;

        g_GracePeriodThreadExitEvent = NULL;
        CloseHandle(hLocal);
        Status = GetLastError();

        goto done;
    }

    CloseHandle(hThread);

done:
    RtlLeaveCriticalSection(&g_EventCritSec);

    return ERROR_SUCCESS;
}

DWORD
StopCheckingGracePeriod()
{
    //
    // Signal the thread to exit
    //

    if (NULL == g_GracePeriodThreadExitEvent)
    {
        // already stopped
        return ERROR_SUCCESS;
    }

    RtlEnterCriticalSection(&g_EventCritSec);

    // Check one more time
    if (NULL == g_GracePeriodThreadExitEvent)
    {
        // already stopped
        goto done;
    }

    HANDLE hLocal = g_GracePeriodThreadExitEvent;

    g_GracePeriodThreadExitEvent = NULL;

    SetEvent( hLocal );


done:
    RtlLeaveCriticalSection(&g_EventCritSec);

    return ERROR_SUCCESS;
}

/*++

Function:

    RegisteredWithLicenseServer

Description:

    Check if this system has been registered with a license server.
    Currently, we determine if the system has been registered by checking if
    it has an X509 certificate.  We may use different checks
    in the future.

Arguments:

    none.

Return:

    TRUE if the system has beem registered or FALSE otherwise.

--*/

BOOL
RegisteredWithLicenseServer()
{
    LICENSE_STATUS
        Status;
    DWORD
        dwSize = 0;

    //
    // check if we have an X509 certificate issued by a license server.
    //

    Status = LsCsp_GetServerData( LsCspInfo_X509Certificate, NULL, &dwSize );
    
    if( LICENSE_STATUS_OK == Status )
    {
        return( TRUE );
    }

    return( FALSE );
}



}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\hserver\licprot\verify.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        verify.c
//
// Contents:    License Verification API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------
#include "precomp.h"
#include "tlsapip.h"

extern DWORD g_dwLicenseExpirationLeeway;

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetVerifyResult(
    DWORD   dwLicenseState )
{
    switch( dwLicenseState )
    {

    //
    // Temporary licenses verification results
    //
    case ( LICENSE_STATE_INVALID_PRODUCT ) :

        // FALL THRU - TS5 RC1 license server bug.

    case( VERIFY_RESULT_TEMP_0_0 ):

        return( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_EXPIRED_0 ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_0_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_EXPIRED_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    //
    // permanent license verification results
    //

    case( VERIFY_RESULT_0_EXPIRED_0 ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_EXPIRED_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_LEEWAY_0 ):

        return( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_LEEWAY_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_0_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_0_0 ):

        return( LICENSE_STATUS_OK );

    default:

        //
        // this case should never happen. For now, if it happens, just
        // let the client go through
        //

        // ASSERT( VERIFY_RESULT_0_EXPIRED_0 );

#if DBG
        DbgPrint( "GetVerifyResult: Invalid verification result: 0x%x\n", dwLicenseState );
#endif

        return( LICENSE_STATUS_INVALID_LICENSE );
        // return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyClientHwid( 
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo )
{
    HWID Hwid;
    LICENSE_STATUS Status;

    //
    // do a memory compare of the HWID
    //

    if( 0 != memcmp( &pLicenseInfo->Hwid, pValidationInfo->pValidationData, 
                     sizeof( HWID ) ) )
    {
        return( LICENSE_STATUS_CANNOT_VERIFY_HWID );
    }                                

    return ( LICENSE_STATUS_OK );

#if 0

#define LICENSE_MIN_MATCH_COUNT 3


    HWID* pHwid;
    DWORD dwMatchCount;

    //
    // liceapi.c, line 1023 set this to HWID
    //
    pHwid = (HWID *)pValidationInfo->pValidationData;

    dwMatchCount = 0;

    dwMatchCount += (pHwid->dwPlatformID == pLicenseInfo->Hwid.dwPlatformID);
    dwMatchCount += (pHwid->Data1 == pLicenseInfo->Hwid.Data1);
    dwMatchCount += (pHwid->Data2 == pLicenseInfo->Hwid.Data2);
    dwMatchCount += (pHwid->Data3 == pLicenseInfo->Hwid.Data3);
    dwMatchCount += (pHwid->Data4 == pLicenseInfo->Hwid.Data4);
 
    return (dwMatchCount >= LICENSE_MIN_MATCH_COUNT) ?
                    LICENSE_STATUS_OK : LICENSE_STATUS_CANNOT_VERIFY_HWID;
#endif
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyLicenseProductInfo( 
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    DWORD
        cbCompanyName = ( wcslen( PRODUCT_INFO_COMPANY_NAME ) + 1 ) * sizeof( TCHAR ),
        cbProductId = ( wcslen( PRODUCT_INFO_SKU_PRODUCT_ID ) + 1 ) * sizeof( TCHAR ); 

    //
    // Verify the company name
    //

    if( pLicenseInfo->LicensedProduct.pProductInfo->cbCompanyName < cbCompanyName )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid company name in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if ( 0 != memcmp( pLicenseInfo->LicensedProduct.pProductInfo->pbCompanyName,
                      PRODUCT_INFO_COMPANY_NAME, cbCompanyName ) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid company name in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    //
    // verify the product ID
    //

    if( pLicenseInfo->cbOrgProductID < cbProductId )
    {
        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if( 0 != memcmp( pLicenseInfo->pbOrgProductID, 
                     PRODUCT_INFO_SKU_PRODUCT_ID, cbProductId ) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid product ID in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    //
    // Check actual licensed product.
    //
    
    if( pLicenseInfo->LicensedProduct.pProductInfo->cbProductID == 0 )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid Product ID in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if( 0 != memcmp(pLicenseInfo->LicensedProduct.pProductInfo->pbProductID,
                    PRODUCT_INFO_SKU_PRODUCT_ID, wcslen(PRODUCT_INFO_SKU_PRODUCT_ID) * sizeof(WCHAR)) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid product ID in client license\n" );
#endif

        if( 0 == memcmp(pLicenseInfo->LicensedProduct.pProductInfo->pbProductID,
                    PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID, wcslen(PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID) * sizeof(WCHAR)) )
        {
            // TS5 beta3 RC1 license server bug, force a upgrade license.
            LicenseSetState( *pdwLicenseState, LICENSE_STATE_INVALID_PRODUCT );
            return( LICENSE_STATUS_OK );
        }

        //
        // Backward compatibility - treat the new product ID as product family and 
        // let client connect
        //
    }


    //
    // check if this is a temporary license
    //
    if( pLicenseInfo->pLicensedVersion->dwFlags & 0x80000000 )
    {
        LicenseSetState( *pdwLicenseState, LICENSE_STATE_TEMPORARY );
    }
    else if(TLSIsBetaNTServer() == FALSE)
    {
        // verify license is issued by RTM license server
        if(IS_LICENSE_ISSUER_RTM(pLicenseInfo->pLicensedVersion->dwFlags) == FALSE)
        {
            //LicenseSetState( *pdwLicenseState, VERIFY_RESULT_BETA_LICENSE );
            return( LICENSE_STATUS_INVALID_LICENSE );
        }
    }

    if(TLSIsLicenseEnforceEnable() == TRUE)
    {
        //
        // W2K beta 3 to RC1 upgrade.
        // Enforce TermSrv will reject any license issued by Beta 3 non-enforce license
        // server.
        //
        if( GET_LICENSE_ISSUER_MAJORVERSION(pLicenseInfo->pLicensedVersion->dwFlags) <= 5 &&
            GET_LICENSE_ISSUER_MINORVERSION(pLicenseInfo->pLicensedVersion->dwFlags) <= 2 )
        {
            //
            // Build 20XX license server has version of 05 03, since we still need to maintain
            // inter-op, we don't want to keep rejecting client holding non-enforce
            // license server, so we check if license issuer is 5.2 or older.
            //
            if( IS_LICENSE_ISSUER_ENFORCE(pLicenseInfo->pLicensedVersion->dwFlags) == FALSE )
            {
        #if DBG
                DbgPrint( "LICPROT: Rejecting license from non-enforce license server\n" );
        #endif

                return( LICENSE_STATUS_INVALID_LICENSE );
            }
        }
    }

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyLicenseDateAndTime( 
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    SYSTEMTIME  CurrentSysTime;
    FILETIME    CurrentFileTime; 
    LONG        lReturn;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullCurrentTime;

    //
    // get the current system time
    //

    GetSystemTime( &CurrentSysTime );

    //
    // convert it to file time
    //

    SystemTimeToFileTime( &CurrentSysTime, &CurrentFileTime );

    //
    // Verify that the license is still valid at this time
    //

    lReturn = CompareFileTime( &pLicenseInfo->NotAfter, &CurrentFileTime );

    if( 1 != lReturn )
    {
        LicenseSetState( *pdwLicenseState, LICENSE_STATE_EXPIRED );            
    }
    else if (!(pLicenseInfo->pLicensedVersion->dwFlags & 0x80000000))
    {
        // permanent license

        ullNotAfterLeeway.LowPart = pLicenseInfo->NotAfter.dwLowDateTime;
        ullNotAfterLeeway.HighPart = pLicenseInfo->NotAfter.dwHighDateTime;
        
        ullNotAfterLeeway.QuadPart -= Int32x32To64(g_dwLicenseExpirationLeeway,10*1000*1000);

        ullCurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
        ullCurrentTime.HighPart = CurrentFileTime.dwHighDateTime;

        if (ullNotAfterLeeway.QuadPart < ullCurrentTime.QuadPart)
        {
            LicenseSetState( *pdwLicenseState, LICENSE_STATE_LEEWAY );
        }
    }

    return( LICENSE_STATUS_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\cntdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	CntDlg.h

Abstract:
    
    This Module defines CConnectDialog class
    (Dialog box for Connecting to Server)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_)
#define AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CConnectDialog dialog

class CConnectDialog : public CDialog
{
// Construction
public:
    CConnectDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConnectDialog)
    enum { IDD = IDD_CONNECT_DIALOG };
    CString    m_Server;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConnectDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConnectDialog)
    afx_msg void OnHelp1();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\defines.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    defines.h

Abstract:
    
    This Module includes the definitions.
   
Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#ifndef _DEFINES_H_
#define _DEFINES_H_

#include <rpc.h>
#include "license.h"
#include "tlsapip.h"
#include <rpcnsi.h>

#define WM_ADD_SERVER       WM_USER + 1
#define WM_SEL_CHANGE       WM_USER + 2
#define WM_ADD_ALL_SERVERS  WM_USER + 3
#define WM_ADD_KEYPACKS     WM_USER + 4
#define WM_ADD_KEYPACK      WM_USER + 5
#define WM_DELETE_SERVER    WM_USER + 6
#define WM_UPDATE_SERVER    WM_USER + 7
#define WM_ENUMERATESERVER  (WM_USER + 8)


enum NODETYPE {
    NODE_ALL_SERVERS,
    NODE_SERVER,
    NODE_KEYPACK,
    NODE_NONE
};

#define LG_BITMAP_WIDTH    32
#define LG_BITMAP_HEIGHT 32
#define SM_BITMAP_WIDTH    16
#define SM_BITMAP_HEIGHT 16

#define MAX_COLUMNS              6
#define NUM_SERVER_COLUMNS       2
#define NUM_KEYPACK_COLUMNS      5
#define NUM_LICENSE_COLUMNS      4
#define MAX_LICENSES             9999

#define NUM_PLATFORM_TYPES      1
#define NUM_KEYPACK_STATUS      7
#define NUM_PURCHASE_CHANNEL    3
#define NUM_LICENSE_STATUS      5
#define NUM_KEYPACK_TYPE        8

#define KEYPACK_DISPNAME_WIDTH  250
#define KEYPACK_OTHERS_WIDTH    100


//Return values. Bound to change

#define ALREADY_EXPANDED    0
#define CONNECTION_FAILED   1
#define ENUM_FAILED         2
#define ADD_KEYPACK_FAILED  4
#define E_DUPLICATE         5
#define ERROR_UNLIMITED_KEYPACK 6

enum SERVER_TYPE
{
	SERVER_TS4,
	SERVER_TS5_ENFORCED,
	SERVER_TS5_NONENFORCED
};

enum VIEW
{
    TREEVIEW,
    LISTVIEW,
    NOVIEW
};

typedef enum 
{
    TLSERVER_UNKNOWN,
    TLSERVER_TS4,
    TLSERVER_UNREGISTER,
    TLSERVER_CH_REGISTERED,
    TLSERVER_PHONE_REGISTERED,
    TLSERVER_TS5_NONENFORCED
} SERVER_REGISTRATION_STATUS;


#define E_NO_SERVER  ((HRESULT)0x80050001L)

#endif //_DEFINES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\cntdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	CntDlg.cpp

Abstract:
    
    This Module contains the implementation of CConnectDialog class
    (Dialog box for Connecting to Server)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "defines.h"
#include "LicMgr.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "CntDlg.h"
#include "htmlhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectDialog dialog


CConnectDialog::CConnectDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CConnectDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConnectDialog)
    m_Server = _T("");
    //}}AFX_DATA_INIT
}


void CConnectDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConnectDialog)
    DDX_Text(pDX, IDC_SERVER, m_Server);
    DDV_MaxChars(pDX, m_Server, 100);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectDialog, CDialog)
    //{{AFX_MSG_MAP(CConnectDialog)
    ON_BN_CLICKED(IDC_HELP1, OnHelp1)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectDialog message handlers

void CConnectDialog::OnHelp1() 
{
    // TODO: Add your control notification handler code here
    TCHAR * pHtml = L"ts_lice_h_040.htm";
    HtmlHelp(AfxGetMainWnd()->m_hWnd, L"tslic.chm", HH_DISPLAY_TOPIC,(DWORD_PTR)pHtml);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\licmgr.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicMgr.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrApp class.
    (The Application class)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "LSMgrDoc.h"
#include "LtView.h"
#include "cmdln.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp

BEGIN_MESSAGE_MAP(CLicMgrApp, CWinApp)
    //{{AFX_MSG_MAP(CLicMgrApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp construction

CLicMgrApp::CLicMgrApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLicMgrApp object

CLicMgrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp initialization

BOOL CLicMgrApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CLicMgrDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CLicMgrLeftView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CLicMgrCommandLine cmdInfo;
    ParseCommandLine(cmdInfo);
    m_Server = cmdInfo.m_FileName;
  //  cmdInfo.m_strFileName = _T("");

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();
    m_pMainWnd->PostMessage(WM_ENUMERATESERVER);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CLicMgrApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\licmgr.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicMgr.cpp

Abstract:
    
    This Module declaration of CLicMgrApp class
    (The Application class.)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols



/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp:
// See LicMgr.cpp for the implementation of this class
//

class CLicMgrApp : public CWinApp
{
public:
    CString m_Server;
    CLicMgrApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CLicMgrApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\lsmgrdoc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LsMgrDoc.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrDoc class
    (The Document class)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "defines.h"
#include "LicMgr.h"
#include "LSMgrDoc.h"
#include "LSServer.h"
#include "MainFrm.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc

IMPLEMENT_DYNCREATE(CLicMgrDoc, CDocument)

BEGIN_MESSAGE_MAP(CLicMgrDoc, CDocument)
    //{{AFX_MSG_MAP(CLicMgrDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc construction/destruction

CLicMgrDoc::CLicMgrDoc()
{
   
    // TODO: add one-time construction code here
    m_NodeType = NODE_NONE;
    m_pAllServers = NULL;
       
}

CLicMgrDoc::~CLicMgrDoc()
{
    if(m_pAllServers)
    {
        delete m_pAllServers;
        m_pAllServers = NULL;
    }
}

BOOL CLicMgrDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc serialization

void CLicMgrDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc diagnostics

#ifdef _DEBUG
void CLicMgrDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CLicMgrDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG


HRESULT CLicMgrDoc::EnumerateKeyPacks(CLicServer *pServer,DWORD dwSearchParm,BOOL bMatchAll)
{
    ASSERT(pServer);
    HRESULT hResult = S_OK;

    if(pServer == NULL)
        return E_FAIL;

    if(TRUE == pServer->IsExpanded())
        return ALREADY_EXPANDED;

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    RPC_STATUS status;
    LSKeyPack keypack;
    DWORD dwErrCode;
     
    CString Server;
    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
            Server = pServer->GetIpAddress();
        else
               Server = pServer->GetName();
        hBinding=TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    memset(&keypack, 0, sizeof(keypack));
    keypack.dwLanguageId = GetUserDefaultUILanguage();
    status = TLSKeyPackEnumBegin(hBinding, dwSearchParm, bMatchAll, &keypack, &dwErrCode);
    if(status != RPC_S_OK  || dwErrCode != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
    else
    {
        do
        {
            status = TLSKeyPackEnumNext(hBinding, &keypack, &dwErrCode);
            if(status == RPC_S_OK  && dwErrCode == ERROR_SUCCESS)
            {
                DBGMSG( L"LICMGR:CLicMgrDoc::EnumerateKeyPacks - TLSKeyPackEnumNext\n" , 0 );

                CKeyPack * pKeyPack = new CKeyPack(keypack);
                if(pKeyPack == NULL)
                {
                    hResult = E_OUTOFMEMORY;
                    goto cleanup;
                }
                pServer->AddKeyPack(pKeyPack);
            }
        } while((status == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS));

        TLSKeyPackEnumEnd(hBinding, &dwErrCode);
        pServer->Expand(TRUE);
    } 

cleanup:
    //put cleanup code here. 
    if(hBinding)
        TLSDisconnectFromServer(&hBinding);
        
    return hResult;



}

HRESULT 
CLicMgrDoc::EnumerateLicenses(
    CKeyPack *pKeyPack,
    DWORD dwSearchParm,
    BOOL bMatchAll
    )
/*++

--*/
{
    ASSERT(pKeyPack);

    if(NULL == pKeyPack)
    {
        return E_FAIL;
    }

    CLicServer *pServer = pKeyPack->GetServer();

    ASSERT(pServer);
    if(NULL == pKeyPack)
    {
        return E_FAIL;
    }

    HRESULT hResult = S_OK;

    if(TRUE == pKeyPack->IsExpanded())
    {
        return ALREADY_EXPANDED;
    }

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    DWORD status = ERROR_SUCCESS;
    LSLicenseEx  sLicense;
    CString Server;
   

    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
        {
            Server = pServer->GetIpAddress();
        }
        else
        {
            Server = pServer->GetName();
        }

        hBinding=TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }
    
    memset(&sLicense, 0, sizeof(LSLicenseEx));
    sLicense.dwKeyPackId = pKeyPack->GetKeyPackStruct().dwKeyPackId;
    TLSLicenseEnumBegin( hBinding, dwSearchParm,bMatchAll ,(LPLSLicenseSearchParm) &sLicense, &status);
    if(status != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
    else
    {
        DWORD TLSLicenseEnumNextResult = ERROR_SUCCESS;
        do {
                memset(&sLicense, 0, sizeof(LSLicenseEx));
                sLicense.dwKeyPackId = pKeyPack->GetKeyPackStruct().dwKeyPackId;
                TLSLicenseEnumNextResult = TLSLicenseEnumNextEx(hBinding,&sLicense,&status);
                if ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK))
                {
                    CLicense * pLicense = new CLicense(sLicense);
                    if(NULL == pLicense)
                    {
                        hResult = E_OUTOFMEMORY;
                        goto cleanup;
                    }
                    
                    pKeyPack->AddIssuedLicense(pLicense);
                }
            } while ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK));

        TLSLicenseEnumEnd(hBinding,&status);

        pKeyPack->Expand(TRUE);
    } 

cleanup:
    //put cleanup code here
    if(hBinding)
    {
        TLSDisconnectFromServer(&hBinding);
    }

    return hResult;

}

    
DWORD
GetPageSize( VOID ) {

    static DWORD dwPageSize = 0;

    if ( !dwPageSize ) {

      SYSTEM_INFO sysInfo = { 0 };
        
      GetSystemInfo( &sysInfo ); // cannot fail.

      dwPageSize = sysInfo.dwPageSize;

    }

    return dwPageSize;

}

/*++**************************************************************
  NAME:      MyVirtualAlloc

  as Malloc, but automatically protects the last page of the 
  allocation.  This simulates pageheap behavior without requiring
  it.

  MODIFIES:  ppvData -- receives memory

  TAKES:     dwSize  -- minimum amount of data to get

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set
  Free with MyVirtualFree

  
 **************************************************************--*/

BOOL
MyVirtualAlloc( IN  DWORD  dwSize,
            OUT PVOID *ppvData )
 {

    PBYTE pbData;
    DWORD dwTotalSize;
    PVOID pvLastPage;

    // ensure that we allocate one extra page

    dwTotalSize = dwSize / GetPageSize();
    if( dwSize % GetPageSize() ) {
        dwTotalSize ++;
    }

    // this is the guard page
    dwTotalSize++;
    dwTotalSize *= GetPageSize();

    // do the alloc

    pbData = (PBYTE) VirtualAlloc( NULL, // don't care where
                                   dwTotalSize,
                                   MEM_COMMIT |
                                   MEM_TOP_DOWN,
                                   PAGE_READWRITE );
    
    if ( pbData ) {

      pbData += dwTotalSize;

      // find the LAST page.

      pbData -= GetPageSize();

      pvLastPage = pbData;

      // now, carve out a chunk for the caller:

      pbData -= dwSize;

      // last, protect the last page:

      if ( VirtualProtect( pvLastPage,
                           1, // protect the page containing the last byte
                           PAGE_NOACCESS,
                           &dwSize ) ) {

        *ppvData = pbData;
        return TRUE;

      } 

      VirtualFree( pbData, 0, MEM_RELEASE );

    }

    return FALSE;

}


VOID
MyVirtualFree( IN PVOID pvData ) 
{

    VirtualFree( pvData, 0, MEM_RELEASE ); 

}


//
// GetProcAddress needed because admin pack can install this binary on an
// XP machine with an old mstlsapi.dll
//

typedef DWORD (WINAPI* PTLSGETSERVERNAMEFIXED) (
                                TLS_HANDLE hHandle,
                                LPTSTR *pszMachineName,
                                PDWORD pdwErrCode
                                );

RPC_STATUS
TryGetServerName(PCONTEXT_HANDLE hBinding,
                 CString &Server)
{
    RPC_STATUS status;
    DWORD      dwErrCode;
    HINSTANCE  hModule = LoadLibrary(L"mstlsapi.dll");

    if (hModule)
    {
        LPTSTR szMachineName = NULL;

        PTLSGETSERVERNAMEFIXED pfnGetServerNameFixed = (PTLSGETSERVERNAMEFIXED) GetProcAddress(hModule,"TLSGetServerNameFixed");

        if (pfnGetServerNameFixed)
        {
            status = pfnGetServerNameFixed(hBinding,&szMachineName,&dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS && szMachineName != NULL)
            {
                Server = szMachineName;
                MIDL_user_free(szMachineName);
                FreeLibrary(hModule);
                return status;
            }
        }

        FreeLibrary(hModule);
    }

    {
        LPTSTR     lpszMachineName = NULL;

        try
        {            
            if ( !MyVirtualAlloc( ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ),
                              (PVOID*) &lpszMachineName ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = MAX_COMPUTERNAME_LENGTH+1 ;

            memset(lpszMachineName, 0, ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ));

            status = TLSGetServerNameEx(hBinding,lpszMachineName,&uSize, &dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS)
            {
                Server = lpszMachineName;
            }
        }
        catch(...)
        {
            status = ERROR_NOACCESS;
        }

        if( lpszMachineName )
            MyVirtualFree(lpszMachineName);
    }

    return status;
}

typedef DWORD (WINAPI* PTLSGETSERVERSCOPEFIXED) (
                                TLS_HANDLE hHandle,
                                LPTSTR *pszScopeName,
                                PDWORD pdwErrCode
                                );

RPC_STATUS
TryGetServerScope(PCONTEXT_HANDLE hBinding,
                  CString &Scope)
{
    RPC_STATUS status;
    DWORD      dwErrCode;
    HINSTANCE  hModule = LoadLibrary(L"mstlsapi.dll");

    if (hModule)
    {
        LPTSTR szServerScope = NULL;
        PTLSGETSERVERSCOPEFIXED pfnGetServerScopeFixed = (PTLSGETSERVERSCOPEFIXED) GetProcAddress(hModule,"TLSGetServerScopeFixed");

        if (pfnGetServerScopeFixed)
        {
            status = pfnGetServerScopeFixed(hBinding,&szServerScope,&dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS && szServerScope != NULL)
            {
                Scope = szServerScope;
                MIDL_user_free(szServerScope);
                FreeLibrary(hModule);
                return status;
            }
        }

        FreeLibrary(hModule);
    }

    {
        LPTSTR     lpszServerScope = NULL;
        try
        {          
            if ( !MyVirtualAlloc( ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ),
                              (PVOID*) &lpszServerScope ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = MAX_COMPUTERNAME_LENGTH+1 ;

            memset(lpszServerScope, 0, ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ));

            status = TLSGetServerScope(hBinding, lpszServerScope, &uSize, &dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS)
            {
                Scope = lpszServerScope;
            }
        }
        catch(...)
        {
            status = ERROR_NOACCESS;
        }

        if(lpszServerScope)
            MyVirtualFree(lpszServerScope);
    }

    return status;
}

HRESULT 
CLicMgrDoc::ConnectToServer(
    CString& Server, 
    CString& Scope, 
    SERVER_TYPE& ServerType    
    )
/*++

--*/
{
    PCONTEXT_HANDLE hBinding = NULL;
    HRESULT hResult = ERROR_SUCCESS;
    RPC_STATUS status;
    LPTSTR     szServerScope = NULL;
    LPTSTR     szMachineName = NULL;

	DWORD dwVersion = 0;
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    DWORD dwErrCode;

    hBinding = TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));
   
    if(hBinding == NULL)
    {
       hResult = E_FAIL;
       goto cleanup;
    }

    TryGetServerName(hBinding,Server);

    Scope.Empty();

    status = TryGetServerScope(hBinding,Scope);
    if(status != RPC_S_OK || Scope.IsEmpty())
    {
        Scope.LoadString(IDS_UNKNOWN);
    }

	//Get whether this is a TS4 server or TS5Enforced or TS5NonEnforced

	status = TLSGetVersion (hBinding, &dwVersion);
	if(status == RPC_S_OK)
	{
		if(dwVersion & 0x40000000)
		{
			ServerType = SERVER_TS5_ENFORCED;

        }
		else
		{
			ServerType = SERVER_TS5_NONENFORCED;
		}
	}
	else if(status  == RPC_S_UNKNOWN_IF)
	{
		ServerType = SERVER_TS4;
		Scope = Server ;       
	}
    else
	{
		hResult = E_FAIL;        
	}

cleanup:

    if(pbData != NULL)
    {
        midl_user_free(pbData);
    }

    if(hBinding)
    {
        TLSDisconnectFromServer(&hBinding);
    }

    return hResult;

}

HRESULT CLicMgrDoc::ConnectWithCurrentParams()
{
    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    CMainFrame * pWnd = (CMainFrame *)pApp->m_pMainWnd ;

    HRESULT hResult = ERROR_SUCCESS;
    CString Scope;
    CString IpAddress;

    CString Server = pApp->m_Server;
    
    if(NULL == m_pAllServers)
         m_pAllServers = new CAllServers(_T(""));

    if(NULL == m_pAllServers)
    {
        hResult = E_OUTOFMEMORY;
        goto cleanup;
    }

    pWnd->SendMessage(WM_ADD_ALL_SERVERS,0,(LPARAM)m_pAllServers);
    
    if(!Server.IsEmpty())
    {
        if(TRUE == IsServerInList(Server))
        {
            hResult = E_DUPLICATE;    
        }

        if( hResult == ERROR_SUCCESS )
        {            
            pWnd->ConnectServer( Server );
        }
        /* Why did we have this here?

        IpAddress = Server;
        hResult = ConnectToServer(
                                Server,
                                Scope,
                                ServerType                           
                            );

        if(ERROR_SUCCESS == hResult)
        {
            CAllServers * pAllServers = m_pAllServers;
            CLicServer *pServer1 = NULL;
            if(IpAddress != Server)
            {
                if(TRUE == IsServerInList(Server))
                {
                    hResult = E_DUPLICATE; 
                    goto cleanup;
                }

                pServer1 = new CLicServer(Server,ServerType,Scope,IpAddress);
            }
            else
            {
                pServer1 = new CLicServer(Server,ServerType,Scope);
            }
            if(pServer1)
            {
                pAllServers->AddLicServer(pServer1);
                pWnd->SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer1);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        */

    }
cleanup:
    //Add any cleanup code required here.
    return hResult;

}

void CLicMgrDoc:: TimeToString(DWORD *ptime, CString& rString)
{
    TCHAR m_szTime[MAX_PATH];
    time_t time;

    rString.Empty();

    ASSERT(ptime);
    if(NULL == ptime)
        return;

    //
    // Times are stored in the ANSI time_t style in the database,
    // however they are type cast to a DWORD (unsigned long). Because
    // time_t is 64 bit on a 64 bit machine, and because it is a signed
    // value, we must be careful here to make sure that the sign of the
    // value is not lost as the value goes from 32 to 64 bit.
    //

    time = (time_t)(LONG)(*ptime);

    LPTSTR lpszTime = NULL;

    //Getting the local time as the time is stored as GMT
    //in the license server database.

    struct tm * pTm = localtime(&time);
    if(NULL == pTm)
        return;

    SYSTEMTIME SystemTime;

    SystemTime.wYear      = (WORD)(pTm->tm_year + 1900);
    SystemTime.wMonth     = (WORD)(pTm->tm_mon  + 1);
    SystemTime.wDayOfWeek = (WORD)pTm->tm_wday;
    SystemTime.wDay       = (WORD)pTm->tm_mday;
    SystemTime.wHour      = (WORD)pTm->tm_hour;
    SystemTime.wMinute    = (WORD)pTm->tm_min;
    SystemTime.wSecond    = (WORD)pTm->tm_sec;
    SystemTime.wMilliseconds = 0;

    int RetLen;
    TCHAR DateFormat[MAX_PATH];
    TCHAR TimeFormat[MAX_PATH];

    RetLen = ::GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_SLONGDATE,
                             DateFormat,
                             sizeof(DateFormat)/sizeof(TCHAR));
    ASSERT(RetLen!=0);

    RetLen = ::GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_STIMEFORMAT,
                             TimeFormat,
                             sizeof(TimeFormat)/sizeof(TCHAR));
    ASSERT(RetLen!=0);

    RetLen = ::GetDateFormat(LOCALE_USER_DEFAULT,
                             0,                      /* dwFlag */
                             &SystemTime,
                             DateFormat,             /* lpFormat */
                             m_szTime,
                             sizeof(m_szTime)/sizeof(TCHAR));
    if (RetLen == 0)
        return;

    _tcscat(m_szTime, _T(" "));  /* Separator of date and time */

    lpszTime = &m_szTime[lstrlen(m_szTime)];
    RetLen = ::GetTimeFormat(LOCALE_USER_DEFAULT,
                             0,                          /* dwFlag */
                             &SystemTime,
                             TimeFormat,                 /* lpFormat */
                             lpszTime,
                             sizeof(m_szTime)/sizeof(TCHAR) - lstrlen(m_szTime));
    if (RetLen == 0)
        return;

    rString = m_szTime;
    return;
}


BOOL CLicMgrDoc::IsServerInList(CString & Server)
{
    ASSERT(m_pAllServers);
    if(NULL == m_pAllServers)
        return FALSE;
    BOOL bServerInList = FALSE;

    LicServerList * pServerList = m_pAllServers->GetLicServerList();
    
    //Assumption: ServerName is unique

    POSITION pos = pServerList->GetHeadPosition();
    while(pos)
    {
        CLicServer *pLicServer = (CLicServer *)pServerList->GetNext(pos);
        ASSERT(pLicServer);
        if(NULL == pLicServer)
            continue;
        
        if((0 == Server.CompareNoCase(pLicServer->GetName())) || (0 == Server.CompareNoCase(pLicServer->GetIpAddress())))
        {
            bServerInList = TRUE;
            break;
        }
     }
    return bServerInList;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\cmdln.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	AddKp.h

Abstract:
    
    This Module defines CLicMgrCommandLine class
    (CommandLine Processing)
   
Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

class CLicMgrCommandLine : public CCommandLineInfo
{
private:
    BOOL m_bFirstParam;
public:
    CString m_FileName;
    CLicMgrCommandLine();
    virtual void ParseParam(LPCTSTR pszParam, BOOL bFlag, BOOL bLast);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\lsmgrdoc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LSMgrDoc.h 

Abstract:
    
      This Module defines the Document class for the License Manager

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#include "LSServer.h"    // Added by ClassView
#include <afxmt.h>
#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

class CAllServers;
class CLicMgrDoc : public CDocument
{
protected: // create from serialization only
    CLicMgrDoc();
    DECLARE_DYNCREATE(CLicMgrDoc)

// Attributes
public:
   
// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    //}}AFX_VIRTUAL

// Implementation
public:

    BOOL 
    IsServerInList(
        CString& Server
    );

    HRESULT 
    ConnectWithCurrentParams();

    HRESULT 
    ConnectToServer(
        CString& Server, 
        CString& Scope, 
        SERVER_TYPE& ServerType
    );

    HRESULT 
    EnumerateKeyPacks(
        CLicServer *pServer,
        DWORD dwSearchParm,
        BOOL bMatchAll
    );

    HRESULT 
    EnumerateLicenses(
        CKeyPack *pKeyPack,
        DWORD dwSearchParm,
        BOOL bMatchAll
    );

    virtual ~CLicMgrDoc();

    NODETYPE 
    GetNodeType()
    { 
        return m_NodeType;
    };

    void 
    SetNodeType(
        NODETYPE nodetype
        )
    {
        m_NodeType=nodetype;
    };

    CAllServers * 
    GetAllServers()
    {
        return m_pAllServers;
    };

    void 
    TimeToString(
        DWORD *ptime, 
        CString& rString
    );

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

private:
    CAllServers * m_pAllServers;
    CWinThread *m_pBackgroundThread;
    CCriticalSection m_AllServersCriticalSection;
    NODETYPE m_NodeType;
protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CLicMgrDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\ltview.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LtView.h 

Abstract:
    
    This Module define the CLicMgrLeftView class( The view class used for the left pane in 
    the splitter window.

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/


#if !defined(AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"

class CLicServer;
class CLicMgrLeftView : public CTreeView
{
protected: // create from serialization only
    CLicMgrLeftView();
    DECLARE_DYNCREATE(CLicMgrLeftView)

// Attributes
public:
    CLicMgrDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrLeftView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
	void SetSelection(LPARAM lParam,NODETYPE NodeType);
    
    CImageList m_ImageList;
    HTREEITEM AddItemToTree(HTREEITEM hParent, CString szText, HTREEITEM hInsAfter, int iImage, LPARAM lParam);
    virtual ~CLicMgrLeftView();
    void AddServerKeyPacks(CLicServer *pServer);
    int AddIconToImageList(int iconID);
    void BuildImageList();
    void UI_initmenu( CMenu *pMenu , NODETYPE nt );

    void OnServerConnect( );
    void OnRefreshAllServers( );
    void OnRefreshServer( );

    void SetRightClickedItem( HTREEITEM ht );

    
    HTREEITEM GetRightClickedItem( )
    {
        return m_ht;
    }

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL );
    
    void OnDownloadKeepPack();
    void OnRegisterServer();
    void OnRepeatLastDownload();
    void OnReactivateServer( );
    void OnDeactivateServer( );

    void OnServerProperties( );
    void OnGeneralHelp( );
    void SetActiveServer( CLicServer * );


#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

private:

    HTREEITEM m_ht;
    
// Generated message map functions
protected:
    //{{AFX_MSG(CLicMgrLeftView)
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDeleteServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnUpdateServer(WPARAM wParam, LPARAM lParam);
    afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnProperties();
    afx_msg LRESULT OnAddAllServers(WPARAM wParam, LPARAM lParam);
    afx_msg void OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAddNewKeyPack();
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
    afx_msg void OnDestroy();
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLeftClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt );
    
    

	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LicMgrLeftView.cpp
inline CLicMgrDoc* CLicMgrLeftView::GetDocument()
   { return (CLicMgrDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\ltview.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    LtView.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrLeftView class
    (The View class used for the Left pane of the splitter)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/
#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSMgrDoc.h"
#include "LtView.h"
#include "TreeNode.h"
#include "LSServer.h"
#include "mainfrm.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView

IMPLEMENT_DYNCREATE(CLicMgrLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLicMgrLeftView, CTreeView)
    //{{AFX_MSG_MAP(CLicMgrLeftView)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemexpanding)
    ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)
    ON_NOTIFY_REFLECT(NM_RCLICK , OnRightClick )
    ON_NOTIFY_REFLECT(NM_CLICK , OnLeftClick )
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CTreeView::OnFilePrintPreview)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_MESSAGE(WM_DELETE_SERVER, OnDeleteServer)
    ON_MESSAGE(WM_UPDATE_SERVER, OnUpdateServer)
    ON_MESSAGE(WM_ADD_ALL_SERVERS, OnAddAllServers)
    
    // all server menus
    ON_WM_CONTEXTMENU( )

    ON_COMMAND( ID_ALLSVR_CONNECT , OnServerConnect )
    ON_COMMAND( ID_ALLSVR_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_ALLSVR_HELP , OnGeneralHelp )
    
    // server menuitems

    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )    
    ON_COMMAND( ID_LPK_DOWNLOADLICENSES , OnDownloadKeepPack )

    ON_COMMAND( ID_SVR_ACTIVATESERVER , OnRegisterServer )
    ON_COMMAND( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LPK_ADVANCED_REACTIVATESERVER , OnReactivateServer )
    ON_COMMAND( ID_LPK_ADVANCED_DEACTIVATESERVER , OnDeactivateServer )    
    ON_COMMAND( ID_LPK_PROPERTIES , OnServerProperties )
    ON_COMMAND( ID_LPK_HELP , OnGeneralHelp )

    // license pak items

    // ON_COMMAND( ID_LICPAK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LICPAK_REFRESH , OnRefreshServer )
    // ON_COMMAND( ID_LICPAK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LICPAK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LICPAK_REPEATDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LICPAK_HELP , OnGeneralHelp )    


    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView construction/destruction

CLicMgrLeftView::CLicMgrLeftView()
{
    // TODO: add construction code here
   
    m_ht = ( HTREEITEM )NULL;
}

CLicMgrLeftView::~CLicMgrLeftView()
{
 }

BOOL CLicMgrLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView drawing

void CLicMgrLeftView::OnDraw(CDC* pDC)
{
    CLicMgrDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
}

void CLicMgrLeftView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();
    GetTreeCtrl().ModifyStyle(0,TVS_HASLINES|TVS_LINESATROOT|TVS_HASBUTTONS|TVS_SHOWSELALWAYS);
    BuildImageList();
       
    // TODO: You may populate your TreeView with items by directly accessing
    //  its tree control through a call to GetTreeCtrl().
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView printing

BOOL CLicMgrLeftView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CLicMgrLeftView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CLicMgrLeftView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView diagnostics

#ifdef _DEBUG
void CLicMgrLeftView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CLicMgrLeftView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CLicMgrDoc* CLicMgrLeftView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CLicMgrDoc)));
    return (CLicMgrDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView message handlers

HTREEITEM CLicMgrLeftView::AddItemToTree(HTREEITEM hParent, CString Text, HTREEITEM hInsAfter, int iImage, LPARAM lParam)
{
    HTREEITEM hItem = NULL;
    TV_ITEM tvItem = {0};
    TV_INSERTSTRUCT tvInsert;

    ASSERT(lParam);
    if(NULL == lParam)
        return hItem;

    tvItem.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvItem.pszText        = Text.GetBuffer(Text.GetLength());
    tvItem.cchTextMax     = Text.GetLength();
    tvItem.iImage         = iImage;
    tvItem.iSelectedImage = iImage;
    tvItem.lParam          = lParam;

    tvInsert.item         = tvItem;
    tvInsert.hInsertAfter = hInsAfter;
    tvInsert.hParent      = hParent;

    hItem = GetTreeCtrl().InsertItem(&tvInsert);

   // GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
    return hItem;


}

LRESULT CLicMgrLeftView::OnAddServer(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

    HTREEITEM hServer = NULL;
    HTREEITEM hItem = NULL;
    CTreeNode* pNode = NULL;

    HTREEITEM hRoot = GetTreeCtrl().GetRootItem();
    if(!hRoot)
        goto cleanup;

    // First make sure the server isn't already in the tree
    // Get the first server under the domain
    hItem = GetTreeCtrl().GetNextItem(hRoot, TVGN_CHILD);
    while(hItem) {
        // Get the data attached to the tree item
        CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hItem);
        if(node) {
            // Is this the server we want to add
            CLicServer *pServer = (CLicServer*)node->GetTreeObject();
            if(pServer == (CLicServer*)lParam) return 0;
        }
        hItem = GetTreeCtrl().GetNextItem(hItem, TVGN_NEXT);
    }

    // Add the server to the tree
    // Create a CTreeNode object with info about this tree node
    pNode = new CTreeNode(NODE_SERVER, pServer);
    if(pNode) 
    {
        int iImage = 0;

        if( pServer->GetServerType()  == SERVER_TS5_ENFORCED )
        {
            DWORD dwStatus = pServer->GetServerRegistrationStatus();
        
            if( dwStatus == LSERVERSTATUS_REGISTER_INTERNET || dwStatus == LSERVERSTATUS_REGISTER_OTHER )
            {
                iImage = 3;
            }
            else if( dwStatus == LSERVERSTATUS_WAITFORPIN )
            { 
                iImage = 4;
            }
            else if( dwStatus == LSERVERSTATUS_UNREGISTER ) 
            {
                iImage = 5;
            }
            else
            {
                iImage = 6;
            }
        }
        
        hServer = AddItemToTree(hRoot, pServer->GetDisplayName(), TVI_SORT,  iImage , (LPARAM)pNode);
        if(!hServer) delete pNode;
        // The server wants to know his tree item handle
        pServer->SetTreeItem(hServer);
    }

cleanup:
    return lResult;                                                                  
                                                                               
} // OnAddServer


LRESULT CLicMgrLeftView::OnAddKeyPack(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer *pServer = (CLicServer*)wParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

    CKeyPack *pKeyPack = (CKeyPack*)lParam;
    ASSERT(pKeyPack);
    if(NULL == pKeyPack)
        return lResult;

    HTREEITEM hKeyPackItem = NULL;
    TV_ITEM Item;
    memset((void *)&Item,0,sizeof(Item));

    Item.mask = TVIF_HANDLE;
    HTREEITEM hServer = pServer->GetTreeItem();
    if(NULL == hServer)
        return lResult;
    Item.hItem = hServer;



    if(FALSE == GetTreeCtrl().GetItem(&Item))
        return lResult;

    if(Item.state & TVIS_EXPANDED)
    {
        CTreeNode *pNode = new CTreeNode(NODE_KEYPACK, pKeyPack);
        if(pNode)
        {
            hKeyPackItem = AddItemToTree(hServer, (LPCTSTR)pKeyPack->GetDisplayName(), hServer, 2, (LPARAM)pNode);
            if(!hKeyPackItem)
                delete pNode;
        }
        pKeyPack->SetTreeItem(hKeyPackItem);
    }
    
    return lResult;                                                                  
                                                                               
} // OnAddKeyPack




LRESULT CLicMgrLeftView::OnAddAllServers(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    HTREEITEM hItem = NULL;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CTreeNode* pNode = NULL;
    CAllServers *pAllServer = (CAllServers*)lParam;
    if(!pAllServer) 
        goto cleanup ;
   
    hItem = pAllServer->GetTreeItem();
    if(NULL != hItem)
        goto cleanup;

       
    // Create a CTreeNode object with info about this tree node
    pNode = new CTreeNode(NODE_ALL_SERVERS, pAllServer);
    if(pNode) 
    {
        HTREEITEM hAllServers = AddItemToTree(NULL, pAllServer->GetName(), TVI_SORT,0 , (LPARAM)pNode);
        if(!hAllServers) delete pNode;
        // The server wants to know his tree item handle
        pAllServer->SetTreeItem(hAllServers);
        //Set the Selection to this item
        GetTreeCtrl().SelectItem(hAllServers);
    }

    
    GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
cleanup:
    return lResult ;                                                                  
                                                                               
} // OnAddAllServers


void CLicMgrLeftView::AddServerKeyPacks(CLicServer *pServer)
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;
    POSITION pos;
    KeyPackList *pKeyPackList = NULL;
    HTREEITEM hLastNode = NULL;

   ASSERT(pServer);
   if(NULL == pServer)
      return;
   HTREEITEM hServer = pServer->GetTreeItem();
   if(NULL == hServer)
       goto cleanup;          //Server Not in the Tree.

   hLastNode= hServer;

   // Get a pointer to the server's list of installed KeyPacks
   pKeyPackList = pServer->GetKeyPackList();
   // Iterate through the KeyPack list
   pos = pKeyPackList->GetHeadPosition();
   while(pos)
   {
        CKeyPack *pKeyPack = (CKeyPack *)pKeyPackList->GetNext(pos);
        CTreeNode *pNode = new CTreeNode(NODE_KEYPACK, pKeyPack);
        if(pNode)
        {
            hLastNode = AddItemToTree(hServer, (LPCTSTR)pKeyPack->GetDisplayName(), hLastNode, 2, (LPARAM)pNode);
            if(!hLastNode)
                delete pNode;
        }
        pKeyPack->SetTreeItem(hLastNode);
   }
cleanup:
   return;

}  // end AddKeyPacks

void CLicMgrLeftView::BuildImageList()
{
    m_ImageList.Create(16, 16, TRUE, 18, 0);
    AddIconToImageList(IDI_ALL_SERVERS);
    AddIconToImageList(IDI_SERVER);
    AddIconToImageList(IDI_KEYPACK);
    AddIconToImageList(IDI_SERVERREG );
    AddIconToImageList(IDI_SERVERM );
    AddIconToImageList(IDI_SERVERX );
    AddIconToImageList(IDI_SERVERQ );

    GetTreeCtrl().SetImageList(&m_ImageList, TVSIL_NORMAL);

}  // end BuildImageList

int CLicMgrLeftView::AddIconToImageList(int iconID)
{
    HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
       return m_ImageList.Add(hIcon);
   

}  

void CLicMgrLeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // TODO: Add your control notification handler code here

    //Check if the node selected is All-Servers,Server or the KeyPack.
    //Accordingly change the right pane view.
    CTreeCtrl& TreeCtrl = GetTreeCtrl();
    HTREEITEM hCurr = TreeCtrl.GetSelectedItem();
    if(NULL == hCurr)
    {
        return;
    }
    CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hCurr);
    if(NULL == pNode)
    {
        return;
    }
    CLicServer *pLicServer = NULL;
    CKeyPack * pKeyPack = NULL;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    switch(pNode->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_ALL_SERVERS,NULL);
            break;
        case NODE_SERVER:
            pLicServer = (CLicServer *)pNode->GetTreeObject();
            if(NULL == pLicServer)
                break;
            if(FALSE == pLicServer->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateKeyPacks(pLicServer,LSKEYPACK_SEARCH_LANGID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pLicServer);
                    if(pLicServer && pLicServer->GetTreeItem())
                    {
                        TreeCtrl.SelectItem(TreeCtrl.GetParentItem(pLicServer->GetTreeItem()));
                    }
                    break;
                }
                AddServerKeyPacks(pLicServer);
               
            }
            else
            {
                if(!pLicServer->GetKeyPackList()->IsEmpty())
                {
                    if(!TreeCtrl.ItemHasChildren(hCurr))
                        AddServerKeyPacks(pLicServer);
                }

            }
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_SERVER,(LPARAM)pLicServer);
            break;
        case NODE_KEYPACK:
            pKeyPack = (CKeyPack *)pNode->GetTreeObject();
            ASSERT(pKeyPack);
            if(NULL == pKeyPack)
                break;
            if(FALSE == pKeyPack->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateLicenses(pKeyPack,LSLICENSE_SEARCH_KEYPACKID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pKeyPack->GetServer());
                    if(pKeyPack && pKeyPack->GetTreeItem())
                    {
                        TreeCtrl.SelectItem(TreeCtrl.GetParentItem(pKeyPack->GetTreeItem()));
                    }
                    break;
                }
                          
            }
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_KEYPACK,(LPARAM)pNode->GetTreeObject());
            break;
    }
    *pResult = 0;
}

void CLicMgrLeftView::OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // TODO: Add your control notification handler code here
    
    *pResult = 0;
}

void CLicMgrLeftView::OnDestroy() 
{
    //Get the Root Item
    HTREEITEM hRoot = GetTreeCtrl().GetRootItem();
    if(!hRoot)
        return;
    HTREEITEM hServerItem = GetTreeCtrl().GetNextItem(hRoot,TVGN_CHILD);
    while(hServerItem)
    {
        // Get the data attached to the tree item 
        CTreeNode *pServerNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServerItem);
        if(pServerNode)
        {
            // Is this the server we want to add
            HTREEITEM hKeyPackItem = GetTreeCtrl().GetNextItem(hServerItem,TVGN_CHILD);
            while(hKeyPackItem)
            {
                CTreeNode *pKeyPackNode = (CTreeNode*)GetTreeCtrl().GetItemData(hKeyPackItem);
                if(pKeyPackNode)
                    delete pKeyPackNode;
                hKeyPackItem = GetTreeCtrl().GetNextItem(hKeyPackItem,TVGN_NEXT);
            }
            delete pServerNode;
           
        }
        hServerItem = GetTreeCtrl().GetNextItem(hServerItem, TVGN_NEXT);
    }
    CTreeNode * pRootNode = (CTreeNode*)GetTreeCtrl().GetItemData(hRoot);
    if(pRootNode)
        delete pRootNode;

    return;
}

LRESULT CLicMgrLeftView::OnDeleteServer(WPARAM wParam, LPARAM lParam)
{   
    
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

   
    HTREEITEM hServer = pServer->GetTreeItem();

    DBGMSG( L"CLicMgrLeftView_OnDeleteServer GetTreeItem ret 0x%x\n" , hServer );

    if(hServer == NULL)
        return lResult;

    CTreeNode *pNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);

    DBGMSG( L"CLicMgrLeftView_OnDeleteServer GetItemData ret 0x%x\n" , pNode );
    
    if(pNode)
        delete pNode;   

    GetTreeCtrl().DeleteItem(hServer);    
    

    return lResult;                                                                  
                                                                               
} // OnDeleteServer

LRESULT CLicMgrLeftView::OnUpdateServer(WPARAM wParam, LPARAM lParam)
{   
    
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    BOOL bIsExpanded = FALSE;
    BOOL bIsSelected = FALSE;
    BOOL bIsChild = FALSE;
    HTREEITEM hSelectedItem = NULL;
    CKeyPack * pSelectedPack = NULL;

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

   
    HTREEITEM hServer = pServer->GetTreeItem();
    if(hServer == NULL)
        return lResult;

    // check to see if we need to remove any keypacks
    // Get a pointer to the server's list of installed KeyPacks
    // Get the data attached to the tree item 
    CTreeNode *pServerNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);

    if( pServerNode != NULL )
    {        
        HTREEITEM hKeyPackItem = GetTreeCtrl().GetNextItem(hServer,TVGN_CHILD);
        while( hKeyPackItem != NULL )
        {
            CTreeNode *pKeyPackNode = (CTreeNode*)GetTreeCtrl().GetItemData(hKeyPackItem);

            if( pKeyPackNode != NULL )
            {
                DBGMSG( L"CLicMgrLeftView!OnUpdateServer removing a licpak\n" , 0 );
                delete pKeyPackNode;
            }

            hKeyPackItem = GetTreeCtrl().GetNextItem(hKeyPackItem,TVGN_NEXT);
        }

        delete pServerNode;
    }

    TV_ITEM Item;
    memset((void *)&Item,0,sizeof(Item));

    Item.mask = TVIF_HANDLE | TVIF_STATE;
    Item.hItem = hServer;

    if(FALSE == GetTreeCtrl().GetItem(&Item))
        return lResult;

    if(Item.state & TVIS_EXPANDED)
        bIsExpanded = TRUE;

    if(Item.state & TVIS_SELECTED)
        bIsSelected = TRUE;
    else
        hSelectedItem = GetTreeCtrl().GetSelectedItem();
    if(hSelectedItem)
    {
        if(hServer == GetTreeCtrl().GetParentItem(hSelectedItem))
        {
            CString ProdDesc = GetTreeCtrl().GetItemText(hSelectedItem);
            KeyPackList * pkeyPackList = pServer->GetKeyPackList();
            POSITION pos = pkeyPackList->GetHeadPosition();
            while(pos)
            {
                CKeyPack * pKeyPack = (CKeyPack *)pkeyPackList->GetNext(pos);
                if(NULL == pKeyPack)
                {
                   continue;
                }
                LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();
        
                if(0 == ProdDesc.CompareNoCase(sKeyPack.szProductDesc))
                {
                   pSelectedPack = pKeyPack;
                   break;
                }
            }
           bIsChild = TRUE;
        }
    }

    GetTreeCtrl().DeleteItem(hServer);
    SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer);
    AddServerKeyPacks(pServer);

    hServer = pServer->GetTreeItem();

    if(bIsExpanded)
        GetTreeCtrl().Expand(hServer, TVE_EXPAND);
    if(bIsSelected)
        GetTreeCtrl().SelectItem(hServer);
    else
    {
        //Not good, find an alternative for this....
        if(bIsChild)
        {
            if(pSelectedPack)
                GetTreeCtrl().SelectItem(pSelectedPack->GetTreeItem());
            else
            {
                hSelectedItem = GetTreeCtrl().GetChildItem(hServer);
                if(hSelectedItem)
                    GetTreeCtrl().SelectItem(hSelectedItem);
            }            
        }
    }

    return lResult;                                                                  
                                                                               
} // OnUpdateServer






void CLicMgrLeftView::SetSelection(LPARAM lParam,NODETYPE NodeType)
{
    if(NULL == lParam)
        return;
   
    HTREEITEM hItem = NULL;


    if(NODE_ALL_SERVERS == NodeType)
        hItem = ((CAllServers *)lParam)->GetTreeItem();
    else if(NODE_SERVER == NodeType)
        hItem = ((CLicServer *)lParam)->GetTreeItem();
    else if(NODE_KEYPACK == NodeType)
        hItem = ((CKeyPack *)lParam)->GetTreeItem();

    if(hItem)
            GetTreeCtrl().SelectItem(hItem);

    return;

}

void CLicMgrLeftView::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_KEYDOWN* pLVKeyDown = (LV_KEYDOWN*)pNMHDR;
    // TODO: Add your control notification handler code here
    if(pLVKeyDown->wVKey == VK_TAB)
    {
        CMainFrame * pMainFrame  = ((CMainFrame *)AfxGetMainWnd());
        pMainFrame->SelectView(LISTVIEW);
    }

    
    *pResult = 0;
}


//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnLeftClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint pt;
    
    GetCursorPos( &pt );

    ScreenToClient( &pt );

    DBGMSG( L"LICMGR@CLicMgrLeftView::OnLeftClick\n" , 0 );

    HTREEITEM hTreeItem = GetTreeCtrl( ).GetSelectedItem( ); //GetTreeCtrl().HitTest( pt , &flag ); 

    if( hTreeItem != NULL )
    { 
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hTreeItem);       
        
        if(NULL == pNode)
        {
            return;
        }

        ClientToScreen( &pt );

        NODETYPE nt = pNode->GetNodeType();

        if(NODE_SERVER == nt )
        {
            DBGMSG( L"\tServer Node selected\n", 0  );

            SetActiveServer( static_cast< CLicServer * >( pNode->GetTreeObject() ) );

        }
        else if( nt == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                SetActiveServer( pKeyPack->GetServer( ) );
            }
        }        
        else
        {
#ifdef DBG
            if( NODE_ALL_SERVERS == nt )
            {
                DBGMSG( L"\tAll servers selected\n" , 0 );    
            }
#endif
            
            SetActiveServer( NULL );
        }
    }
    else
    {
        DBGMSG( L"\tTreeview item returned NULL\n" , 0 );

        SetActiveServer( NULL );
    }


}

//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnContextMenu( CWnd* pWnd, CPoint pt )
{
    CMenu menu;

    CMenu *pContextmenu = NULL;
        
    DBGMSG( L"LICMGR@CLicMgrLeftView::OnContextMenu\n" , 0 );
        
    DBGMSG( L"\tpoint x = %d " , pt.x );
    
    DBGMSG( L"y = %d\n" , pt.y );

    UINT flag;    

    HTREEITEM hTreeItem;
    
    CTreeCtrl& treectrl = GetTreeCtrl();

    // maybe keyboard selected this item

    if(pt.x == -1 && pt.y == -1)
    {   
        hTreeItem = treectrl.GetSelectedItem( );

        if( hTreeItem != NULL )
        {
            RECT rect;

            treectrl.GetItemRect( hTreeItem , &rect , FALSE );

		    pt.x = rect.left + (rect.right - rect.left)/2;
		    
            pt.y = rect.top + (rect.bottom - rect.top)/2;
	   }
    }
    else
    {
        // otherwise we're invoked by the mouse
        ScreenToClient( &pt );

        hTreeItem = treectrl.HitTest( pt , &flag );
    }

    if( hTreeItem != NULL )
    { 
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hTreeItem);
        
        if(NULL == pNode)
        {
            return;
        }

        SetRightClickedItem( hTreeItem );

        ClientToScreen( &pt );

        // GetTreeCtrl().SelectItem( hTreeItem );

        NODETYPE nt = pNode->GetNodeType();

        if(NODE_SERVER == nt )
        {
            DBGMSG( L"\tServer Node selected\n", 0  );
          
            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 0 );
            
        }
        else if( NODE_KEYPACK == nt )
        {
            DBGMSG( L"\tLicense pack selected\n" , 0 );

            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 1 );
         
        }
        else if( NODE_ALL_SERVERS == nt )
        {
            DBGMSG( L"\tAll servers selected\n" , 0 );
            
            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 3 );
                     
        }
        else
        {
            DBGMSG( L"\tIn left pane no item selected\n" , 0 );

            return;
        }


        UI_initmenu( pContextmenu , nt );


        if( pContextmenu != NULL )
        {
            pContextmenu->TrackPopupMenu( TPM_LEFTALIGN , pt.x , pt.y , this );
        }

    }
    else
    {
        hTreeItem = GetTreeCtrl( ).GetSelectedItem( );

        SetRightClickedItem( hTreeItem );
    }

}


//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnRightClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint pt;

    CMenu menu;

    CMenu *pContextmenu = NULL;

    GetCursorPos( &pt );

    OnContextMenu( NULL , pt );

    return;
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->UI_initmenu( pMenu , nt );
    }
   
}

//-----------------------------------------------------------------------------------------       
void CLicMgrLeftView::OnServerConnect( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->ConnectServer( );
    }

}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRefreshAllServers( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->OnRefresh( );
    }
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRefreshServer( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

   CLicServer *pServer = NULL;

    if( pMainFrame != NULL )
    {
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData( GetRightClickedItem() );

        if( pNode == NULL )
        {
            return;
        }

        if( pNode->GetNodeType() == NODE_SERVER )
        {
            pServer = static_cast< CLicServer * >( pNode->GetTreeObject() );
        }
        else if( pNode->GetNodeType() == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                pServer = pKeyPack->GetServer( );
            }
        }

        if( pServer != NULL )
        {
            pMainFrame->RefreshServer( pServer );
        }        
    }

}
    
//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnDownloadKeepPack()
{
    BOOL bRefresh = FALSE;    

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bRefresh );
    
    //This call to RefreshServer causes problems because it tries to use
    //a pointer to the selected node on the right side. Of course, the
    //focus is on the left so there's nothing selected on the right...
    //if( bRefresh )
    //{
        // need to review this

    //    OnRefreshServer( );
    //}
  
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnDownloadKeepPack StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRegisterServer()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnRegisterServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRepeatLastDownload()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnRepeatLastDownload StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnReactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnReactivateServer StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnDeactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnDeactivateServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnServerProperties( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnServerProperties StartWizard returned 0x%x\n" , dwStatus );    
    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnGeneralHelp( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );
    
    if( pMainFrame != NULL )
    {
        pMainFrame->OnHelp( );
    }
}

//-----------------------------------------------------------------------------------------
DWORD CLicMgrLeftView::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        return pMainFrame->WizardActionOnServer( wa , pbRefresh , TREEVIEW );
    }

    return ERROR_INVALID_PARAMETER;
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::SetActiveServer( CLicServer *pServer )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

#ifdef DBG

    if( pServer != NULL )
    {
        DBGMSG( L"CLicMgrLeftView::SetActiveServer %s\n" , (LPCTSTR)pServer->GetName( ) );
    }

#endif

    if( pMainFrame != NULL )
    {
        pMainFrame->SetActiveServer( pServer );
    }
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::SetRightClickedItem( HTREEITEM ht )
{
    m_ht = ht;
    
    CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(ht);       
    
    if(NULL == pNode)
    {
        SetActiveServer( NULL );

        return;
    }

    NODETYPE nt = pNode->GetNodeType();

    
    if(NODE_SERVER == nt )
    {    
        SetActiveServer( static_cast< CLicServer * >( pNode->GetTreeObject() ) );

    }
    else if( nt == NODE_KEYPACK )
    {
        CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

        if( pKeyPack != NULL )
        {
            SetActiveServer( pKeyPack->GetServer( ) );
        }
    }
    else
    {
        SetActiveServer( NULL );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\lsprop.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_LICENSEPROPERTYPAGE_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_)
#define AFX_LICENSEPROPERTYPAGE_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// LSProp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLicensePropertypage dialog

class CLicensePropertypage : public CPropertyPage
{
    DECLARE_DYNCREATE(CLicensePropertypage)

// Construction
public:
    CLicensePropertypage();
    ~CLicensePropertypage();

// Dialog Data
    //{{AFX_DATA(CLicensePropertypage)
    enum { IDD = IDD_LICENSE_PROPERTYPAGE };
    CString    m_ExpiryDate;
    CString    m_IssueDate;
    CString    m_LicenseStatus;
    CString    m_MachineName;
    CString    m_UserName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLicensePropertypage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLicensePropertypage)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLicensePropertypage_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\lsserver.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LsServer.cpp

Abstract:
    
    This Module contains the implementation of CKeyPack, CLicense,
    CLicServer, CAllServers classes

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include <stdafx.h>
#include "resource.h"
#include "defines.h"
#include "LSServer.h"

///////////////////////////////////////////////////////////
int GetStatusPosition( CLicense *pLic );


CKeyPack::CKeyPack(
    LSKeyPack &KeyPack
    )
/*++


--*/
{
    m_hTreeItem = NULL;
    m_bIsExpanded = FALSE;
    m_pLicServer = NULL;
    m_KeyPack = KeyPack;
    return;
}

//---------------------------------------------------------
CKeyPack::~CKeyPack()
{
    PurgeCache();
}

//---------------------------------------------------------
void 
CKeyPack::AddIssuedLicense(
    CLicense * pIssuedLicense
    )
/*++

--*/
{
    if(NULL == pIssuedLicense)
    {
        return;
    }

    CString MachineName = pIssuedLicense->GetLicenseStruct().szMachineName;
    if(MachineName.IsEmpty())
    {
        MachineName.LoadString(IDS_UNKNOWN);
        lstrcpy(pIssuedLicense->GetLicenseStruct().szMachineName,(LPCTSTR)MachineName);
    }

    pIssuedLicense->SetKeyPack(this);
    m_IssuedLicenseList.AddTail(pIssuedLicense);

    return;
}

//---------------------------------------------------------
void
CKeyPack::PurgeCache()
{
    CLicense *pLicense = NULL;

    POSITION pos = m_IssuedLicenseList.GetHeadPosition();
    while(pos)
    {
        pLicense = (CLicense *)m_IssuedLicenseList.GetNext(pos);
        ASSERT(pLicense);
        if(pLicense)
        {
            delete pLicense;
            pLicense = NULL;
        }
    }

    m_IssuedLicenseList.RemoveAll();

    m_bIsExpanded = FALSE;
}

//---------------------------------------------------------
HRESULT
CKeyPack::RefreshIssuedLicenses(
    LSLicense* pLicenses, /* = NULL */
    DWORD dwFreshParm,  /* = 0 */
    BOOL bMatchAll /* = FALSE */
    )
/*++

    None of the parameter is supported yet.

--*/
{
    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    DWORD status = ERROR_SUCCESS;
    LSLicenseEx  sLicense;
    CString Server;
    CLicServer *pServer = GetServer();
    HRESULT hResult = S_OK;
    DWORD dwErrCode;

    ASSERT(pServer);
    if(NULL == pServer)
    {
        return E_FAIL;
    }

    PurgeCache();
   
    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
        {
            Server = pServer->GetIpAddress();
        }
        else
        {
            Server = pServer->GetName();
        }

        hBinding = TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    status = TLSKeyPackEnumBegin(
                            hBinding,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            FALSE,
                            &m_KeyPack,
                            &dwErrCode
                        );

    if(status != RPC_S_OK  || dwErrCode != ERROR_SUCCESS)
    {
        hResult = status;
        goto cleanup;
    }

    status = TLSKeyPackEnumNext(
                            hBinding,
                            &m_KeyPack,
                            &dwErrCode
                        );

    TLSKeyPackEnumEnd(hBinding, &dwErrCode);

    if(status != RPC_S_OK  || dwErrCode != ERROR_SUCCESS)
    {
        hResult = status;
        goto cleanup;
    }    
   
    memset(&sLicense, 0, sizeof(LSLicenseEx));

    sLicense.dwKeyPackId = m_KeyPack.dwKeyPackId;
    TLSLicenseEnumBegin( 
                            hBinding, 
                            LSLICENSE_SEARCH_KEYPACKID,
                            FALSE,
                            (LPLSLicenseSearchParm)&sLicense,
                            &status
                        );

    if(status != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
         
    DWORD TLSLicenseEnumNextResult = ERROR_SUCCESS;
    do {
        memset(&sLicense, 0, sizeof(LSLicenseEx));
        TLSLicenseEnumNextResult = TLSLicenseEnumNextEx(hBinding, &sLicense, &status);

        if ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK))
        {    
            CLicense * pLicense = new CLicense(sLicense);
            if(NULL == pLicense)
            {
                hResult = E_OUTOFMEMORY;
                goto cleanup;
            }
    
            AddIssuedLicense(pLicense);
        }
    } while ((status == ERROR_SUCCESS) && (TLSLicenseEnumNextResult == RPC_S_OK));

    TLSLicenseEnumEnd(hBinding, &status);
    
    m_bIsExpanded = TRUE;

cleanup:

    //put cleanup code here
    if(hBinding)
    {
        TLSDisconnectFromServer(&hBinding);
    }

    return hResult;
}

////////////////////////////////////////////////////////////

void 
CLicServer::AddKeyPack(
    CKeyPack* pKeyPack
    )
/*++

--*/
{
    if(NULL == pKeyPack)
        return;
    CString DisplayName;
  //  CString For;
 //   CString Platform;
    LSKeyPack &sKeypack = pKeyPack->GetKeyPackStruct();
  /*  if(LSKEYPACKTYPE_TEMPORARY == sKeypack.ucKeyPackType)
        DisplayName.LoadString(IDS_TEMPORARY);
    else*/
    DisplayName = sKeypack.szProductDesc;   
  //  For.LoadString(IDS_FOR);
   // Platform.LoadString(IDS_PLATFORM1 + sKeypack.dwPlatformType - PLATFORM_WINNT_40);
  //  DisplayName = DisplayName + _T(" ");
  //  DisplayName = DisplayName + For;
  //  DisplayName = DisplayName + _T(" ");
  //  DisplayName = DisplayName + Platform;
    pKeyPack->SetDisplayName(DisplayName);
    m_KeyPackList.AddTail(pKeyPack);
    pKeyPack->SetServer(this);
    return;
}

///////////////////////////////////////////////////////////
CLicense::CLicense(LSLicenseEx &License)
{
    m_pKeyPack = NULL;
    m_License = License;
    return;
}

//---------------------------------------------------------
CLicense::~CLicense()
{
}

///////////////////////////////////////////////////////////
CLicServer::CLicServer(
    CString& Name,
    SERVER_TYPE ServerType, 
    CString& Scope,
    CString& IpAddress,
    PCONTEXT_HANDLE hBinding
    )
/*++


--*/
{
    m_ServerName = Name;
    m_ServerScope = Scope;
    m_IpAddress = IpAddress;

    if(!m_IpAddress.IsEmpty())
    {
        m_bUseIpAddress = TRUE;
    }
    else
    {
        m_bUseIpAddress = FALSE;
    }

	m_ServerType = ServerType;
	if(ServerType == SERVER_TS4)
	{
	   CString Temp;
	   Temp.LoadString(IDS_TS4);
	   m_DisplayName = m_ServerName + L" (" + Temp + L") ";
	}
	else
	{
		m_DisplayName = m_ServerName;
	}

    m_hTreeItem = NULL;
    m_hContext = hBinding;
    m_bIsExpanded = FALSE;
    m_dwRegStatus = ( DWORD )-1;

    m_bAdmin = FALSE;
    m_fDownloadedLicenses = FALSE;

    m_wizcon = ( WIZCONNECTION )-1;
}    

///////////////////////////////////////////////////////////
void 
CAllServers::AddLicServer(
    CLicServer* pLicServer
    )
/*++

--*/
{
    if(NULL == pLicServer)
    {
        return;
    }

    m_LicServerList.AddTail(pLicServer);

    return;
}

//---------------------------------------------------------
CAllServers::CAllServers(
    CString Name
    )
/*++

--*/
{
    m_hTreeItem = NULL;
    if(Name.IsEmpty())
        m_Name.LoadString(IDS_TREEROOT);
    else
        m_Name = Name;
    return;
};

CAllServers::~CAllServers()
{
   CLicServer *pServer = NULL;
   POSITION pos = m_LicServerList.GetHeadPosition();
   while(pos)
   {
        pServer = (CLicServer *)m_LicServerList.GetNext(pos);
        ASSERT(pServer);
        if(pServer)
        {
            delete pServer;
            pServer = NULL;
        }
    }
   m_LicServerList.RemoveAll();
}

PCONTEXT_HANDLE CLicServer::GetContext()
{
    return m_hContext;

}

void CLicServer::SetContext(PCONTEXT_HANDLE hContext)
{
    m_hContext = hContext;
}


CLicServer::~CLicServer()
{
    PurgeCache();
}


void
CLicServer::PurgeCache()
{
    CKeyPack *pKeyPack = NULL;
    POSITION pos = m_KeyPackList.GetHeadPosition();
    while(pos)
    {
        pKeyPack = (CKeyPack *)m_KeyPackList.GetNext(pos);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            delete pKeyPack;
            pKeyPack = NULL;
        }
   
    }

    m_KeyPackList.RemoveAll();
    m_bIsExpanded = FALSE;
}

//-------------------------------------------------------------
HRESULT
CLicServer::RefreshCachedKeyPack()
/*++


--*/    
{
    HRESULT hResult = S_OK;

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    POSITION pos;
    CKeyPack *pKeyPack;
     
    CString Server;
    hBinding = GetContext();

    if(NULL == hBinding)
    {
        if(UseIpAddress())
        {
            Server = GetIpAddress();
        }
        else
        {
            Server = GetName();
        }

        hBinding = TLSConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    //
    // Code has too many other dependencies so 
    // we only refresh licenses issued
    //
    pKeyPack = NULL;
    pos = m_KeyPackList.GetHeadPosition();

    while(pos)
    {
        pKeyPack = (CKeyPack *)m_KeyPackList.GetNext(pos);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            pKeyPack->RefreshIssuedLicenses();
        }
    }

cleanup:

    //put cleanup code here. 
    if(hBinding)
    {
        TLSDisconnectFromServer(&hBinding);
    }
        
    return hResult;
}


//-----------------------------------------------------------------------------------------
// returns the license status position.
// used for sorting licenses by status.
//-----------------------------------------------------------------------------------------
int GetStatusPosition( CLicense *pLic )
{
    int val;

    ASSERT( pLic != NULL );

    switch( pLic->GetLicenseStruct().ucLicenseStatus )
    {
        case LSLICENSE_STATUS_ACTIVE:
        //case LSLICENSE_STATUS_PENDING_ACTIVE:
        case LSLICENSE_STATUS_CONCURRENT:
            
            val = 0;
            
            break;

        //case LSLICENSE_STATUS_REVOKE:
        //case LSLICENSE_STATUS_REVOKE_PENDING:
            
        //    val = 1;
            
        //    break;

        case LSLICENSE_STATUS_TEMPORARY:
            
            val = 2;

            break;

        case LSLICENSE_STATUS_UNKNOWN:

            val = 3;

            break;

        case LSLICENSE_STATUS_UPGRADED:

            val = 4;
    }

    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\lsserver.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LSServer.h 

Abstract:
    
    This Module defines the CKeyPack, CLicense, CLicServer and CAllServers classes for the License Manager

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#ifndef _LICSERVER_H_
#define _LICSERVER_H_

#include <afxtempl.h> 

#include <lrwizapi.h>
//struct LSLicens

class CLicServer;
class CLicense;

typedef CList<CLicense *,CLicense *> IssuedLicenseList;

////////////////////////////////////////////////////////////

class CKeyPack: public CObject
{
private:

    HTREEITEM m_hTreeItem;
    BOOL m_bIsExpanded;
    CString m_DisplayName; //Have added this field as the KeyPackId 
                           //does not make much sense to the user.
    LSKeyPack m_KeyPack;
    CLicServer *m_pLicServer;
    IssuedLicenseList m_IssuedLicenseList;

public:
    void
    PurgeCache();

    void 
    SetTreeItem(
        HTREEITEM hTreeItem
        ) 
    {
        m_hTreeItem = hTreeItem;
    };

    HTREEITEM 
    GetTreeItem()
    {
        return m_hTreeItem;
    };

    ~CKeyPack();
    CKeyPack(LSKeyPack &KeyPack);

    LSKeyPack& 
    GetKeyPackStruct()
    {
        return m_KeyPack;
    };

    IssuedLicenseList *
    GetIssuedLicenseList()
    {
        return &m_IssuedLicenseList;
    };

    HRESULT
    RefreshIssuedLicenses(
        LSLicense* pLicenses = NULL,
        DWORD dwFreshParm = 0,
        BOOL bMatchAll = FALSE
    );

    void 
    AddIssuedLicense(
        CLicense * pIssuedLicense
    );

    CLicServer *
    GetServer()
    {
        return m_pLicServer;
    };

    void 
    SetServer(
        CLicServer *pLicServer
        )
    {
        m_pLicServer = pLicServer;
    };

    BOOL 
    IsExpanded ()
    {
        return m_bIsExpanded;
    };

    void 
    Expand(BOOL bExpand)
    { 
        m_bIsExpanded = bExpand;
    };

    CString 
    GetDisplayName()
    {
        return m_DisplayName;
    };

    void 
    SetDisplayName(
        CString DisplayName
        )
    { 
        m_DisplayName = DisplayName;
    };
};

typedef CKeyPack * PKEYPACK;


class CLicense: public CObject
{
private:
    LSLicenseEx m_License;
    CKeyPack *m_pKeyPack;

public:


    ~CLicense();
    CLicense(LSLicenseEx& License);

    LSLicenseEx& 
    GetLicenseStruct()
    {
        return m_License;
    };

    CKeyPack *
    GetKeyPack()
    {
        return m_pKeyPack;
    };

    void 
    SetKeyPack(
        CKeyPack *pKeyPack
        )
    {
        m_pKeyPack = pKeyPack;
    };
};

typedef CLicense * PLICENSE;

typedef CList<CKeyPack *,CKeyPack *> KeyPackList;

////////////////////////////////////////////////////////////

class CLicServer : public CObject
{
private:
    CString m_ServerName;
    CString m_ServerScope;
    CString m_IpAddress;
	SERVER_TYPE m_ServerType;
	CString m_DisplayName;
    HTREEITEM m_hTreeItem;
    KeyPackList m_KeyPackList;
    BOOL m_bIsExpanded;
    BOOL m_bUseIpAddress;
    PCONTEXT_HANDLE m_hContext;
    DWORD m_dwRegStatus;
    BOOL m_fDownloadedLicenses;
    BOOL m_bAdmin;
    WIZCONNECTION m_wizcon;


public:

    void 
    SetContext(
        PCONTEXT_HANDLE hContext
    );

    PCONTEXT_HANDLE 
    GetContext();

    CLicServer(
        CString& Name, 
        SERVER_TYPE ServerType,
        CString& Scope = (CString)_T(""),
        CString& IpAddress = (CString)_T(""),
        PCONTEXT_HANDLE hBinding = NULL
    );

    // destructor
    ~CLicServer();

    
    DWORD GetServerRegistrationStatus()
    {
        return m_dwRegStatus;
    }

    void
    SetServerRegistrationStatus(
        DWORD  dwStatus
        )
    /*++

    --*/
    {
        m_dwRegStatus = dwStatus;
    }
    
    HTREEITEM 
    GetTreeItem() 
    { 
        return m_hTreeItem; 
    }

    // Sets the tree item handle
    void 
    SetTreeItem(
        HTREEITEM handle
        ) 
    { 
        m_hTreeItem = handle; 
    }

    CString& 
    GetName() 
    { 
        return m_ServerName;
    };

	CString& 
    GetDisplayName()
    {
        return m_DisplayName;
    };

    CString& 
    GetIpAddress()
    {
        return m_IpAddress;
    };

	SERVER_TYPE 
    GetServerType()
    {
        return m_ServerType;
    };

    KeyPackList * 
    GetKeyPackList()
    {
        return &m_KeyPackList;
    };

    void 
    AddKeyPack(
        CKeyPack * pKeyPack
    );

    BOOL 
    IsExpanded ()
    {
        return m_bIsExpanded;
    };

    BOOL 
    UseIpAddress()
    {
        return m_bUseIpAddress;
    };

    void 
    Expand (
        BOOL bExpand
        )
    { 
        m_bIsExpanded = bExpand;
    };

    CString& 
    GetScope() 
    { 
        return m_ServerScope;
    };

    HRESULT
    RefreshCachedKeyPack();

    void
    PurgeCache();

    void SetDownLoadLics( BOOL bF )
    {
        m_fDownloadedLicenses = bF;
    }

    void SetConType( WIZCONNECTION x )
    {
        m_wizcon = x ;
    }

    WIZCONNECTION GetConType( ) const
    {
        return m_wizcon;
    }


    BOOL IsLicsDownloaded( void )
    {
        return m_fDownloadedLicenses;
    }

    void SetAdmin( BOOL  b )
    {
        m_bAdmin = b;
    }

    BOOL IsUserAdmin( )
    {
        return m_bAdmin;
    }
};


typedef CLicServer * PLICSERVER;

typedef CList<CLicServer *,CLicServer *> LicServerList;

////////////////////////////////////////////////////////////
class CAllServers : public CObject
{
private:

    HTREEITEM m_hTreeItem;
    LicServerList m_LicServerList;
    CString m_Name;

public:
    
    CAllServers(CString Name);   

    // destructor
    ~CAllServers();
    
    HTREEITEM 
    GetTreeItem() 
    {   
        return m_hTreeItem; 
    }

    // Sets the tree item handle
    void 
    SetTreeItem(
        HTREEITEM handle
        ) 
    /*++

    --*/
    { 
        m_hTreeItem = handle; 
    }

    LicServerList *
    GetLicServerList()
    {
        return &m_LicServerList;
    };

    void 
    AddLicServer(CLicServer * pLicServer);

    CString& 
    GetName() 
    { 
        return m_Name;
    };
};


#endif //_LICSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\mainfrm.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:    

    MainFrm.h 

Abstract:
    
    This Module defines the CMainFrame(The Frame Window of the application) class

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"
class CLicServer;
class CKeyPack;
class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
public:
    void 
    EnumFailed(
        HRESULT reason, 
        CLicServer * pLicServer
    );

    BOOL 
    IsUserAdmin(
        CString& Server
    );

    void 
    SetTreeViewSel(
        LPARAM lParam,
        NODETYPE NodeType
    );

    void 
    DeleteServer(
        LicServerList * pLicServerList,
        POSITION TempPos, 
        CLicServer * pLicServer
    );

    HRESULT 
    AddLicensestoList(
        CKeyPack * pKeyPack,
        CListCtrl * pListCtrl, 
        BOOL bRefresh
    );

    HRESULT 
    AddKeyPackDialog(
        CLicServer * pServer
    );

    HRESULT 
    GetLicServer(
        CString * pLicServer
    );

    void 
    PressButton(
        UINT uId, 
        BOOL bPress
    );

    HRESULT 
    GetActiveServer(
        CLicServer ** ppServer
        )
    {
        *ppServer = m_pServer;

        if( m_pServer == NULL )
        {
            return E_FAIL;
        }

        return S_OK;
    }

    BOOL IsDownLoadedPacks( CLicServer *pServer );

    HRESULT 
    RefreshServer(
        CLicServer * pLicServer
    );

    void SelectView(VIEW);

    void ConnectAndDisplay();

    CSplitterWnd m_SplitterWnd;

    BOOL 
    ConnectServer(
        LPCTSTR pszServer=NULL
    );

    BOOL IsServerRegistered( 
        HRESULT *phrStatus
    );

    
    BOOL IsLicensesDownLoaded( );
    

    void UI_initmenu( CMenu *pMenu , NODETYPE nt );

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh , VIEW );
    
    DWORD StartWizardEx(HWND hWndParent, 
                        WIZACTION WizAction, 
                        LPCTSTR pszLSName, 
                        PBOOL pbRefresh);

    void OnRefresh();
    void OnHelp( );
    void OnRefreshServer( );

    void OnDownLoadLicenses( );
    void OnRepeatLastDownLoad( );
    void OnReRegisterServer( );
    void OnUnRegisterServer( );

    void SetActiveServer( CLicServer *pServer )
    {
        m_pServer = pServer;        
    }

private:

    CLicServer *m_pServer;
    // BOOL m_fDownloadedLicenses;    

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    CView * m_pRightView;
    CView * m_pLeftView;
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT OnSelChange(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddAllServers(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
    afx_msg void OnLargeIcons();
    afx_msg void OnSmallIcons();
    afx_msg void OnList();
    afx_msg void OnDetails();
    afx_msg void OnExit();
    afx_msg void OnAppAbout();
    afx_msg void OnConnectServer();
    afx_msg void OnRegistration();    
    afx_msg void OnProperties( );
    afx_msg LRESULT OnEnumerateServer(WPARAM wParam, LPARAM lParam);       
    afx_msg void OnUpdateDownloadlicenses( CCmdUI * pCmdUI );
    afx_msg void OnUpdateRepeatLastDownload( CCmdUI * pCmdUI ); 
    afx_msg void OnUpdateReregisterserver( CCmdUI * pCmdUI );
    afx_msg void OnUpdateUnregisterserver( CCmdUI * pCmdUI );
    afx_msg void OnUpdateRefresh( CCmdUI *pCmdUI );
    afx_msg void OnUpdateProperties( CCmdUI *pCmdUI );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};    

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\mainfrm.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    MainFrm.cpp

Abstract:
    
    This Module contains the implementation of CMainFrame class
    (The Frame Window of the application)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include <lm.h>
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "RtList.h"
#include "lSmgrdoc.h"
#include "LtView.h"
#include "cntdlg.h"
#include "treenode.h"
#include "ntsecapi.h"
#include "TlsHunt.h"
#include "htmlhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define TRUSTED_ACTIVATION_SITE_REGPATH L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap\\escDomains\\microsoft.com\\*.activate"
#define TRUSTED_ACTIVATION_REG_VALUE_NAME L"https"
#define TRUSTED_ACTIVATION_REG_VALUE 2

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_MESSAGE(WM_ENUMERATESERVER, OnEnumerateServer)
    ON_MESSAGE(WM_SEL_CHANGE, OnSelChange)
    ON_MESSAGE(WM_ADD_ALL_SERVERS, OnAddAllServers)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_COMMAND(ID_LARGE_ICONS, OnLargeIcons)
    ON_COMMAND(ID_SMALL_ICONS, OnSmallIcons)
    ON_COMMAND(ID_LIST, OnList)
    ON_COMMAND(ID_DETAILS, OnDetails)
    ON_COMMAND(ID_EXIT, OnExit)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_HELP_FINDER, OnHelp)
    ON_COMMAND(ID_CONNECT_SERVER, OnConnectServer)
    ON_COMMAND(ID_REGISTRATION, OnRegistration)
    ON_COMMAND(ID_KEY_HELP , OnHelp )
    ON_UPDATE_COMMAND_UI( ID_ACTION_DOWNLOADLICENSES, OnUpdateDownloadlicenses )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD , OnUpdateRepeatLastDownload )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_REREGISTERSERVER , OnUpdateReregisterserver )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_UNREGISTERSERVER , OnUpdateUnregisterserver )
    ON_UPDATE_COMMAND_UI( ID_VIEW_PROPERTIES , OnUpdateProperties )

    ON_COMMAND( ID_REFRESH, OnRefreshServer )
    ON_COMMAND( ID_VIEW_REFRESHALL , OnRefresh )
    ON_UPDATE_COMMAND_UI( ID_REFRESH , OnUpdateRefresh )

    ON_COMMAND( ID_ACTION_DOWNLOADLICENSES , OnDownLoadLicenses )    
    ON_COMMAND( ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownLoad )
    ON_COMMAND( ID_ACTION_ADVANCED_REREGISTERSERVER ,  OnReRegisterServer )
    ON_COMMAND( ID_ACTION_ADVANCED_UNREGISTERSERVER , OnUnRegisterServer )

    ON_COMMAND( ID_VIEW_PROPERTIES , OnProperties )

    //}}AFX_MSG_MAP
    

END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_pRightView= NULL;
    m_pLeftView = NULL;
    m_pServer = NULL;
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

#if 0
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

#endif

    // Remove this if you don't want tool tips or a resizeable toolbar
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    // Delete these three lines if you don't want the toolbar to be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);
    return 0;
}
void CMainFrame::OnHelp()
{
    TCHAR * pHtml = L"ts_lice_topnode.htm";
    HtmlHelp(AfxGetMainWnd()->m_hWnd, L"tslic.chm", HH_DISPLAY_TOPIC,(DWORD_PTR)pHtml);
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style &= ~FWS_ADDTOTITLE;
    return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
    m_SplitterWnd.CreateStatic(this,1,2); //1 row, 2 columns
    m_SplitterWnd.CreateView(0,0,(CRuntimeClass *)pContext->m_pNewViewClass,CSize(150,150),pContext);
    m_SplitterWnd.CreateView(0,1,RUNTIME_CLASS(CRightList),CSize(0,0),pContext);
    m_pRightView = (CView *)m_SplitterWnd.GetPane(0, 1);
    m_pLeftView = (CLicMgrLeftView *)m_SplitterWnd.GetPane(0, 0);
    
    return TRUE;
}

LRESULT CMainFrame::OnSelChange(WPARAM wParam, LPARAM lParam)
{
   LRESULT lResult = 0;
   m_pRightView->SendMessage(WM_SEL_CHANGE,wParam,lParam);
   return lResult;
   
}



void CMainFrame::OnLargeIcons() 
{
    PressButton(ID_LARGE_ICONS,TRUE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_LARGE_ICONS,0);

    
}

void CMainFrame::OnSmallIcons() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,TRUE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_SMALL_ICONS,0);
    
}

void CMainFrame::OnList() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,TRUE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_LIST,0);
    
}

void CMainFrame::OnDetails() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,TRUE);
    m_pRightView->SendMessage(WM_COMMAND,ID_DETAILS,0);
    
}

void CMainFrame::OnExit() 
{
    SendMessage(WM_CLOSE,0,0);    
}


LRESULT CMainFrame::OnAddAllServers(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    m_pLeftView->SendMessage(WM_ADD_ALL_SERVERS,wParam,lParam);
    return lResult;
}
LRESULT CMainFrame::OnAddServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT  lResult = 0;
    m_pLeftView->SendMessage(WM_ADD_SERVER,wParam,lParam);
    m_pRightView->SendMessage(WM_ADD_SERVER,wParam,lParam);
    return lResult;
}

void CMainFrame::OnAppAbout() 
{
    CString AppName;
    AppName.LoadString(IDS_APP_NAME);
    ::ShellAbout((HWND)m_hWnd,(LPCTSTR)AppName,
                 NULL,NULL); 

    
}

void CMainFrame::OnRegistration()
{
    CWnd* cWnd = AfxGetMainWnd();
    HWND hWnd=cWnd->GetSafeHwnd();
    DWORD status;
    CString TempString;
    CString Server;
    CLicServer* pServer = NULL;
    WCHAR szServer[MAX_COMPUTERNAME_LENGTH + 1];

    BOOL bRefresh;



    try
    {
        if(ERROR_SUCCESS != GetActiveServer(&pServer))
        {
            DBGMSG( L"LICMGR : OnRegistration no active servers\n",0 );

            return;
        }

    	if(SERVER_TS5_ENFORCED == pServer->GetServerType())
    	{
            DBGMSG( L"LICMGR : OnRegistration on enforced server\n",0 );

            if( !pServer->IsUserAdmin( ) )
            {
                AfxMessageBox( IDS_E_ACCESSDENIED );
                // ::MessageBox( GetSafeHwnd( ) , L"Unable to perform operation: Access denied" , L"Terminal Services Licensing" , MB_OK|MB_ICONINFORMATION );

                return;
            }

    		if(pServer->UseIpAddress())
            {
    			Server = pServer->GetIpAddress();
            }
    		else
            {
    			Server = pServer->GetName();
            }

    		lstrcpy(szServer, (LPCTSTR)Server);

            DWORD dwStatus = pServer->GetServerRegistrationStatus( );

            DBGMSG( L"LICMGR:CMainFrame::OnRegistration calling StartWizard\n", 0 );
            
            StartWizardEx( hWnd , WIZACTION_REGISTERLS , szServer , &bRefresh );

            //DBGMSG( L"LICMGR:CMainFrame::OnRegistration - StartWizard returned 0x%x\n" , status );    		           

            if( IsLicenseServerRegistered( hWnd , szServer , &status ) == ERROR_SUCCESS )
            {
                pServer->SetServerRegistrationStatus( status );
            }
            
            if( dwStatus != status )
            {
                RefreshServer(pServer);               
            }
    		

  		UpdateWindow();

    	}
    	else
    	{
            DBGMSG( L"LICMGR : OnRegistration on non-enforced server\n",0 );
            
    	}

    } 
    catch (...)
    {
    	// validation failed - user already alerted, fall through
    
    	// Note: DELETE_EXCEPTION_(e) not required
    }
}

//////////////////////////////////////////////////////////////////////////////

BOOL
CMainFrame::ConnectServer(
    LPCTSTR pszServer
    )
/*++


++*/
{
    CConnectDialog ConnectDialog;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
        return FALSE;

    HRESULT hResult = ERROR_SUCCESS;
    SERVER_TYPE ServerType;

    CString Scope;    

    if(pszServer == NULL)
    {
        if(ConnectDialog.DoModal() != IDOK)
        {
            return FALSE;
        }

        //
        // Empty string - local machine
        //
        if(ConnectDialog.m_Server.IsEmpty())
        {
            TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;
            memset(szComputerName, 0, sizeof(szComputerName));

            GetComputerName(szComputerName, &dwBufSize);
            ConnectDialog.m_Server = szComputerName;
        }
    }
    else
    {
        //
        // Minimize code change
        //
        ConnectDialog.m_Server = pszServer;
    }

    SetCursor(LoadCursor(NULL,IDC_WAIT));
    if(TRUE == pDoc->IsServerInList(ConnectDialog.m_Server))
    {
        //AfxMessageBox(IDS_DUPLICATE_SERVER);
        return FALSE;
    }    

//HUEIHUEI - Check if server is registered


    //
    // Do a NT4 RPC connect to make sure the license server
    // can accept our calls.
    //
    CString IpAddress(ConnectDialog.m_Server);     

    hResult = pDoc->ConnectToServer(
                                ConnectDialog.m_Server, 
                                Scope,
                                ServerType                                                                
                            );

    if(ERROR_SUCCESS != hResult)
    {
        CDialog ErrorDialog(IDD_CONNECT_ERROR,this);
        ErrorDialog.DoModal();
    
    }
    else
    {
        CAllServers * pAllServers = pDoc->GetAllServers();
        CLicServer *pServer1 = NULL;
        if(IpAddress != ConnectDialog.m_Server)
        {
            if(TRUE == pDoc->IsServerInList(ConnectDialog.m_Server))
            {
                return TRUE;
            }
            pServer1 = new CLicServer(
                                    ConnectDialog.
                                    m_Server,
                                    ServerType,
                                    Scope,
                                    IpAddress
                                );
        }
        else
        {
            pServer1= new CLicServer(
                                    ConnectDialog.
                                    m_Server,
                                    ServerType,
                                    Scope
                                );

        }
        if(pServer1)
        {
            DWORD dwStatus;

            // check for admin
            
            pServer1->SetAdmin( IsUserAdmin( pServer1->GetName() ) );                                
            

            if( pServer1->IsUserAdmin( ) )
            {
                if( IsLicenseServerRegistered( GetSafeHwnd() , ( LPCTSTR )pServer1->GetName() , &dwStatus ) == ERROR_SUCCESS )
                {
                    pServer1->SetServerRegistrationStatus( dwStatus );
                }
            }


            CLicMgrDoc * pDoc = (CLicMgrDoc *)(GetActiveView()->GetDocument());

            pDoc->EnumerateKeyPacks( pServer1 , LSKEYPACK_SEARCH_LANGID , TRUE );

            WIZCONNECTION WizConType;

            if( GetConnectionType( GetSafeHwnd() , pServer1->GetName() , &WizConType ) == ERROR_SUCCESS )
            {
                DBGMSG( L"ConnectServer - GetConnectionType obtained %d" , WizConType );               

                pServer1->SetConType( WizConType );
            }
            
            pAllServers->AddLicServer(pServer1);

            SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer1);

            // after the send message is called all servers will have their keypacks cached.
            
            pServer1->SetDownLoadLics( IsDownLoadedPacks( pServer1 ) );

        }
        else
        {
            return FALSE;
        }
    }    

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

void 
CMainFrame::OnConnectServer()
{
    ConnectServer();
}

HRESULT 
CMainFrame::AddLicensestoList(
    CKeyPack * pKeyPack, 
    CListCtrl * pListCtrl,
    BOOL bRefresh
    )
/*++

--*/
 {
    CLicServer *pServer = NULL;
    CString Error;
    HRESULT hr;


    ASSERT(pKeyPack);
    ASSERT(pListCtrl);
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);

    if(NULL == pKeyPack || NULL == pListCtrl || NULL == pDoc)
    {
        return E_FAIL;
    }

    if(TRUE == bRefresh)
    {
        if((hr = pKeyPack->RefreshIssuedLicenses()) != S_OK)
        {
            EnumFailed(hr,pKeyPack->GetServer());

            return E_FAIL;
        }
    }

    IssuedLicenseList * pIssuedLicenseList = pKeyPack->GetIssuedLicenseList();
    ASSERT(pIssuedLicenseList);
    if(NULL == pIssuedLicenseList)
    {
        return E_FAIL;
    }

    LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();

    int nIndex = 0;
    int nSubitemIndex = 1;
    CString TempString;
    POSITION pos;

    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iSubItem = 0; 
    lvI.iImage = 2;  
    
    pos = pIssuedLicenseList->GetHeadPosition();
    while(pos)
    {

        lvI.iItem = nIndex;
        nSubitemIndex = 1;
        CLicense  * pLicense = pIssuedLicenseList->GetNext(pos);
        ASSERT(pLicense);
        if(NULL == pLicense)
        {
            continue;
        }

        LSLicenseEx sLicense = pLicense->GetLicenseStruct();
        lvI.lParam = (LPARAM)pLicense;
        TempString = sLicense.szMachineName;
        lvI.pszText = TempString.GetBuffer(TempString.GetLength());
        lvI.cchTextMax =lstrlen(lvI.pszText + 1);
        nIndex = pListCtrl->InsertItem(&lvI);
        
        //Set the Issue date.

        pDoc->TimeToString(&sLicense.ftIssueDate, TempString);
        if(TempString.IsEmpty())
        {
            TempString.LoadString(IDS_UNKNOWN);
        }

        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);
        nSubitemIndex++;


        //Set the expiry date.

        if(0x7FFFFFFF != sLicense.ftExpireDate)
        {
            TempString.LoadString(IDS_DASH);
            pDoc->TimeToString(&sLicense.ftExpireDate, TempString);
            if(TempString.IsEmpty())
            {
                TempString.LoadString(IDS_UNKNOWN);
            }
        }
        else
        {
            TempString.LoadString(IDS_DASH);
        }
       
        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);

        nSubitemIndex++;

        // adding status text to license's status column

        /*switch( sLicense.ucLicenseStatus )
        {
            case LSLICENSE_STATUS_UNKNOWN:
                TempString.LoadString( IDS_LICENSESTATUS_UNKNOWN );
                break;

            case LSLICENSE_STATUS_TEMPORARY:
                TempString.LoadString( IDS_LICENSESTATUS_TEMPORARY );
                break;

            case LSLICENSE_STATUS_ACTIVE:
            //case LSLICENSE_STATUS_PENDING_ACTIVE:
            case LSLICENSE_STATUS_CONCURRENT:
                TempString.LoadString( IDS_LICENSESTATUS_ACTIVE );
                break;

            case LSLICENSE_STATUS_UPGRADED:
                TempString.LoadString( IDS_LICENSESTATUS_UPGRADED );
                break;

            //case LSLICENSE_STATUS_REVOKE:
            //case LSLICENSE_STATUS_REVOKE_PENDING:
            //    TempString.LoadString( IDS_LICENSESTATUS_REVOKE );
                    
        }

        if( TempString.IsEmpty() )
        {
            TempString.LoadString(IDS_UNKNOWN);
        }
       
        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);*/

        // adding quantity

        TCHAR sQuantity[12]; //long enough to handle any DWORD
        _ltow(sLicense.dwQuantity, sQuantity, 10);
        pListCtrl->SetItemText(nIndex, nSubitemIndex, sQuantity);

        nIndex ++;

    }

    return S_OK;

}

void CMainFrame :: PressButton(UINT uId, BOOL bPress)
{
    CToolBarCtrl& ToolBarCtrl = m_wndToolBar.GetToolBarCtrl();
    ToolBarCtrl.PressButton(uId,bPress);
}

/////////////////////////////////////////////////////////////////////
LRESULT
CMainFrame::OnEnumerateServer(WPARAM wParam, LPARAM lParam)
{
    CTlsHunt huntDlg;

    huntDlg.DoModal();

    if( wParam == 0 && 
        huntDlg.IsUserCancel() == FALSE && 
        huntDlg.GetNumServerFound() == 0 )
    {
        AfxMessageBox(IDS_NOSERVERINDOMAIN);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////

void 
CMainFrame :: ConnectAndDisplay()
{
    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    ASSERT(pApp);
    CLicMgrDoc *pDoc = (CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pApp || NULL == pDoc)
        return;

    HRESULT hResult = ERROR_SUCCESS;

    CString LicServer;
    CString Server = pApp->m_Server;
    if(!Server.IsEmpty())
    {
        //Server Specified in the command line. Connect to it.        
        hResult = pDoc->ConnectWithCurrentParams();
    }
    else
    {
        ActivateFrame();
        //
        // Save a copy of what we have.
        //
        LicServer = pApp->m_Server;
        pApp->m_Server = _TEXT("");

        hResult = pDoc->ConnectWithCurrentParams();

        pApp->m_Server = LicServer;
        hResult = ERROR_SUCCESS;
    }

    switch(hResult)
    {
    case E_FAIL:
        AfxMessageBox(IDS_CONNECT_SERVER_FAILED);
        break;
    case E_OUTOFMEMORY:
        AfxMessageBox(IDS_NO_MEMORY);
        SendMessage(WM_CLOSE,0,0);
        break;
    case E_DUPLICATE:
        AfxMessageBox(IDS_DUPLICATE_SERVER);
        break;
    }
    return;
   
}

void CMainFrame::OnRefresh() 
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }

    HRESULT hResult = ERROR_SUCCESS;
    
    CWaitCursor Wait;

    CAllServers *pAllServers = pDoc->GetAllServers();
    ASSERT(pAllServers);
    if(NULL == pAllServers)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }

    LicServerList * pLicServerList = pAllServers->GetLicServerList();
    ASSERT(pLicServerList);
    if(NULL == pLicServerList)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }

    POSITION pos = pLicServerList->GetHeadPosition();

    OnEnumerateServer((pos == NULL) ? 0 : 1, 0); // show error dialog if nothing in the list

    Wait.Restore();

    while(pos)
    {
        // Connect to each server and check if the information in the cache is current. If not update the information.
        // If the connection to the server cannot be establised,add them to the list to display to the user.
        POSITION TempPos = pos;
        CLicServer * pLicServer = pLicServerList->GetNext(pos);
        ASSERT(pLicServer);
        if(NULL == pLicServer)
            continue;

        //Call Refresh Server
        hResult = RefreshServer(pLicServer);
    }

    return;
}

void CMainFrame::DeleteServer(LicServerList * pLicServerList, POSITION TempPos, CLicServer * pLicServer)
{
    if(NULL == pLicServerList || NULL == pLicServer)
        return;

    m_pLeftView->SendMessage(WM_DELETE_SERVER,0,(LPARAM)pLicServer);
    m_pRightView->SendMessage(WM_DELETE_SERVER,0,(LPARAM)pLicServer);
    
    pLicServerList->RemoveAt(TempPos);
    delete pLicServer;
    pLicServer = NULL;

}

void CMainFrame::SetTreeViewSel(LPARAM lParam, NODETYPE NodeType)
{
  if(NULL == lParam || NULL == m_pLeftView)
      return;
  ((CLicMgrLeftView *)m_pLeftView)->SetSelection(lParam, NodeType);
  SetActiveView(m_pLeftView);
  return;
}

void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String ) 
{ 
    DWORD StringLength; 
 
    if (String == NULL)
    { 
        LsaString->Buffer = NULL; 
        LsaString->Length = 0; 
        LsaString->MaximumLength = 0; 
        return; 
    } 
 
    StringLength = lstrlen(String); 
    LsaString->Buffer = String; 
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR); 
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR); 
} 


NTSTATUS 
OpenPolicy(
    LPWSTR ServerName, 
    DWORD DesiredAccess, 
    PLSA_HANDLE PolicyHandle 
    ) 
/*++


--*/
{ 
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    PLSA_UNICODE_STRING Server = NULL; 
 
   
    // Always initialize the object attributes to all zeroes. 
    
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
 
    if (ServerName != NULL) 
    { 
       // Make a LSA_UNICODE_STRING out of the LPWSTR passed in 
        InitLsaString(&ServerString, ServerName); 
        Server = &ServerString; 
    } 
 
    
    // Attempt to open the policy. 
   
    return LsaOpenPolicy(Server, &ObjectAttributes, DesiredAccess, PolicyHandle ); 
} 

BOOL CMainFrame::IsUserAdmin(CString& Server)
{
    BOOL IsUserAdmin = FALSE;
    LSA_HANDLE PolicyHandle = NULL;
    NTSTATUS Status;

    Status = OpenPolicy(Server.GetBuffer(Server.GetLength()),POLICY_SERVER_ADMIN,&PolicyHandle);

    DBGMSG( L"LICMGR@CMainFrame::IsUserAdmin OpenPolicy returned 0x%x\n" , Status );

    if(Status == 0)
        IsUserAdmin = TRUE;

    if(PolicyHandle)
        LsaClose(PolicyHandle);
    return IsUserAdmin;
}

void CMainFrame::EnumFailed(HRESULT reason, CLicServer * pLicServer)
{
    DBGMSG( L"CMainFrame_EnumFailed\n" , 0 );

    ASSERT(pLicServer);
    if(NULL == pLicServer)
        return;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    CString Error;
    CString Server;
    POSITION pos;
    BOOL bFoundServer = FALSE;

    LicServerList * pLicServerList = NULL;
    POSITION temppos = NULL;

    switch(reason)
    {
    case CONNECTION_FAILED:

        DBGMSG( L"\tCONNECTION_FAILED\n" , 0 );
        
        Server = pLicServer->GetName();
        Error.Format(IDS_CONNECT_ERROR,Server);
        AfxMessageBox(Error);

        pLicServerList = (pDoc->GetAllServers())->GetLicServerList();
        if(NULL == pLicServerList)
            break;
        //Find the position of the server in the List;
        pos = pLicServerList->GetHeadPosition();
        while(pos)
        {
            temppos = pos;
            CLicServer *pServer = (CLicServer *)pLicServerList->GetNext(pos);
            ASSERT(pServer);
            if(NULL == pServer)
                continue;
        
            if((0 == Server.CompareNoCase(pServer->GetName())) || (0 == Server.CompareNoCase(pServer->GetIpAddress())))
            {
                bFoundServer = TRUE;
                break;
            }
        }
        if(bFoundServer)
            DeleteServer(pLicServerList,temppos,pLicServer);
        break;

    case LSERVER_E_SERVER_BUSY:
        DBGMSG( L"\tLSERVER_E_SERVER_BUSY\n" , 0 );
        AfxMessageBox(IDS_SERVER_BUSY);
        break;

    case LSERVER_E_OUTOFMEMORY:
        DBGMSG( L"\tLSERVER_E_OUTOFMEMORY\n" , 0 );
        AfxMessageBox(IDS_SERVER_OUTOFMEMORY);
        break;

    case LSERVER_E_INTERNAL_ERROR:
        DBGMSG( L"\tLSERVER_E_INTERNAL_ERROR\n" , 0 );
        AfxMessageBox(IDS_SERVER_INTERNAL_ERROR);
        pLicServerList = (pDoc->GetAllServers())->GetLicServerList();
        if(NULL == pLicServerList)
            break;
        //Find the position of the server in the List;
        pos = pLicServerList->GetHeadPosition();
        while(pos)
        {
            temppos = pos;
            CLicServer *pServer = (CLicServer *)pLicServerList->GetNext(pos);
            ASSERT(pServer);
            if(NULL == pServer)
                continue;
        
            if((0 == Server.CompareNoCase(pServer->GetName())) || (0 == Server.CompareNoCase(pServer->GetIpAddress())))
            {
                bFoundServer = TRUE;
                break;
            }
        }
        if(bFoundServer)
            DeleteServer(pLicServerList,temppos,pLicServer);
        break;

    case E_OUTOFMEMORY:
        DBGMSG( L"\tE_OUTOFMEMORY\n" , 0 );
        AfxMessageBox(IDS_NO_MEMORY);
        break;
    default:
        break;


    }

}

void CMainFrame::SelectView(VIEW view)
{
    if(view == TREEVIEW)
    {
        SetActiveView(m_pLeftView);
    }
    else 
    {
        SetActiveView(m_pRightView);
    }

}


HRESULT CMainFrame::RefreshServer(CLicServer * pLicServer)
{
    DWORD dwStatus = 0;
    HRESULT hResult = E_FAIL;
    CWaitCursor Wait;
        
    if(NULL == pLicServer)
        return E_INVALIDARG;

    DBGMSG( L"LICMGR : CMainFrame::RefreshServer %s\n" , (LPCTSTR) pLicServer->GetName( ) );

    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
        return ERROR_INTERNAL_ERROR;

    CString Server;
    if(pLicServer->UseIpAddress())
        Server = pLicServer->GetIpAddress();
    else
        Server = pLicServer->GetName();

    WIZCONNECTION WizConType;

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer setting ConnectionType\n" , 0 );

    hResult = GetConnectionType(GetSafeHwnd(), Server, &WizConType);

    //This will be returned if we couldn't connect to the remote registry
    if (hResult == ERROR_BAD_NETPATH) 
    {
        EnumFailed(CONNECTION_FAILED, pLicServer);
        return hResult;
    }

    pLicServer->SetConType( WizConType );

    // check for admin

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer setting admin priv\n" , 0 );
    pLicServer->SetAdmin( IsUserAdmin( Server ) );
    if( pLicServer->IsUserAdmin( ) )
    {
        DBGMSG( L"LICMGR:CMainFrame::RefreshServer updating server status\n" , 0 );

        if( IsLicenseServerRegistered( GetSafeHwnd( ) , Server , &dwStatus ) == ERROR_SUCCESS )
            pLicServer->SetServerRegistrationStatus( dwStatus );
        else
            pLicServer->SetServerRegistrationStatus( ( DWORD )-1 );
    }

    KeyPackList * pkeypackList = pLicServer->GetKeyPackList();
    if(NULL == pkeypackList)
    {
        DBGMSG( L"LICMGR:RefreshServer no keypacklist\n",0 );
        return E_FAIL;
    }

    POSITION pos1 = pkeypackList->GetHeadPosition();
    CKeyPack *pKeyPack = NULL;

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer removing keypacks\n" , 0 );

    while(pos1)
    {
        pKeyPack = (CKeyPack *)pkeypackList->GetNext(pos1);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            delete pKeyPack;
            pKeyPack = NULL;    
        }
    }


    pkeypackList->RemoveAll();

    pLicServer->Expand(FALSE);
    
    DBGMSG( L"LICMGR:CMainFrame::RefreshServer enumerating keypacks\n" , 0 );

    hResult = pDoc->EnumerateKeyPacks(pLicServer, LSKEYPACK_SEARCH_LANGID, TRUE);
    if(hResult != S_OK)
    {
        EnumFailed( hResult , pLicServer );
        return hResult;
    }

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer checking for keypacks\n" , 0 );

    pLicServer->SetDownLoadLics( IsDownLoadedPacks( pLicServer ) );

    m_pLeftView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pLicServer);
    m_pRightView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pLicServer);

    return hResult;
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateDownloadlicenses( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateDownloadlicenses\n" , 0 );

    CLicServer *pServer = NULL;

    HRESULT hr;

    GetActiveServer( &pServer );
    
    pCmdUI->Enable( FALSE );
    
    if( pServer != NULL )
    {
        if( pServer->GetServerType( ) == SERVER_TS5_ENFORCED )
        {
            pCmdUI->Enable( IsServerRegistered( &hr ) );
        }
        else
        {
            pCmdUI->Enable( TRUE );
        }
    }
    else
    {
        pCmdUI->Enable( FALSE );
    }
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateRepeatLastDownload( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateRepeatLastDownload\n" , 0 );                

    HRESULT hr;

    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
            if( IsServerRegistered( &hr ) )
            {        
                pCmdUI->Enable( IsLicensesDownLoaded() );

                return;
            }
        }
    }

    pCmdUI->Enable( FALSE );
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateReregisterserver( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateReregisterserver\n" , 0 );                

    HRESULT hr;

    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
             pCmdUI->Enable( IsServerRegistered( &hr ) );

             return;
        }
    }

    pCmdUI->Enable( FALSE );

}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateUnregisterserver( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateUnregisterserver\n" , 0 );
    
    HRESULT hr;
    
    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
             pCmdUI->Enable( IsServerRegistered( &hr ) );

             return;
        }
    }

    pCmdUI->Enable( FALSE );
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateRefresh( CCmdUI *pCmdUI )
{
    CLicServer * pLicServer = NULL;

    if( FAILED( GetActiveServer( &pLicServer ) ) )
    {
        pCmdUI->Enable( FALSE );
    }
    else
    {
        pCmdUI->Enable( TRUE );
    }
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateProperties( CCmdUI *pCmdUI )
{    
    CLicServer * pLicServer = NULL;
    
    GetActiveServer( &pLicServer );
    
    pCmdUI->Enable( FALSE );
    
    if( pLicServer != NULL && pLicServer->GetServerType( ) == SERVER_TS5_ENFORCED )
    {
        pCmdUI->Enable( TRUE );
    }    
}

//--------------------------------------------------------------------
void CMainFrame::OnRefreshServer( )
{
    CLicServer * pLicServer = NULL;

    if( FAILED( GetActiveServer( &pLicServer ) ) )
    {
        // nothing to refresh

        return;
    }

    RefreshServer( pLicServer );
}


//--------------------------------------------------------------------
BOOL CMainFrame::IsServerRegistered( HRESULT *phrStatus )
{
    BOOL bEnable = FALSE;

    ASSERT( phrStatus != NULL );

    DWORD dwServerStatus = ERROR_SUCCESS;
    
    CLicServer * pLicServer = NULL;        

    *phrStatus = GetActiveServer( &pLicServer );
    
    if( pLicServer != NULL )
    {   
        if( pLicServer->GetServerType() == SERVER_TS5_ENFORCED )
        {
            dwServerStatus = pLicServer->GetServerRegistrationStatus( );            
        }
        else
        {
            *phrStatus = E_FAIL; // fail all non enforced server 
        }       
        
    }    
    
    if( dwServerStatus == LSERVERSTATUS_REGISTER_INTERNET ||
        dwServerStatus == LSERVERSTATUS_REGISTER_OTHER )
    {
        bEnable = TRUE;
    }
    else
    {
        bEnable = FALSE;
    }

    DBGMSG( L"LICMGR@CMainFrame::IsServerRegistered -- status returned 0x%x\n" , dwServerStatus );            

    return bEnable;
}

//--------------------------------------------------------------------
// used by views
//--------------------------------------------------------------------
void CMainFrame::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    HRESULT hr;

    CLicServer *pServer;
       
    GetActiveServer( &pServer );


    if( pMenu == NULL )
    {
        return;
    }

    UINT uMF = MF_GRAYED | MF_DISABLED;

    if( pServer != NULL )
    {
        if( pServer->GetConType() != CONNECTION_WWW )
        {
            DBGMSG( L"LICMGR:UI_initmenu server contype is not www\n" , 0 );

            uMF = MF_ENABLED;
        }
    }

    BOOL bEnable = IsServerRegistered( &hr );

    if( nt == NODE_SERVER )
    {   
        if( bEnable )
        {
            if( FAILED( hr ) )
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_ENABLED );
            }
            else
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_GRAYED | MF_DISABLED );
            }            

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REACTIVATESERVER , MF_ENABLED );

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_DEACTIVATESERVER , uMF );

            pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_ENABLED );

            if( IsLicensesDownLoaded() )
            {
                pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , uMF );
            }
            else
            {
                pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , MF_GRAYED | MF_DISABLED  );
            }

        }
        else 
        {
            if( SUCCEEDED( hr ) )
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_ENABLED );
            }
            else
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_DISABLED | MF_GRAYED );
            }

            if( pServer != NULL )
            {
                if( pServer->GetServerType( ) == SERVER_TS5_ENFORCED )
                {
                    pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED  );

                    pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_ENABLED );
                    
                }
                else
                {
                    pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                    pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_GRAYED | MF_DISABLED );
                }
            }

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , MF_GRAYED | MF_DISABLED  );    
            
            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REACTIVATESERVER , MF_GRAYED | MF_DISABLED );

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_DEACTIVATESERVER , MF_GRAYED | MF_DISABLED );

            
        }
        
    }
    else if( nt == NODE_KEYPACK )
    {

        if( bEnable )
        {
            if( IsLicensesDownLoaded() )
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED );
                pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , uMF );
            }
            else
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED );
                pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , MF_GRAYED | MF_DISABLED  );
            }
        }
        else 
        {
            if( pServer != NULL && pServer->GetServerType() == SERVER_TS5_ENFORCED )
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED  );                
            }
            else
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED  );                
            }

            pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , MF_GRAYED | MF_DISABLED  );            
        }
        
    }
    else if( nt == NODE_ALL_SERVERS )
    {
        pMenu->EnableMenuItem( ID_ALLSVR_REFRESHALL , MF_ENABLED );
        
    }
    /*
    else if( nt == NODE_NONE )
    {
        // this can only mean licenses
        
        if( !IsLicensesDownLoaded( ) )
        {
        pMenu->EnableMenuItem( ID_LIC_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED );
        }
    }
    */

}

//------------------------------------------------------------------------------------
void CMainFrame::OnDownLoadLicenses( )
{
    BOOL bF;

    CLicServer *pLicServer = NULL;

    GetActiveServer( &pLicServer );

    if( pLicServer != NULL )
    {
        if( pLicServer->GetServerType() == SERVER_TS5_ENFORCED )
        {
            DWORD dw = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bF , NOVIEW );

            DBGMSG( L"LICMGR : OnDownLoadLicenses returned 0x%x\n " , dw );
        }
    }
    
}

//------------------------------------------------------------------------------------
void CMainFrame::OnRepeatLastDownLoad( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnRepeatLastDownLoad returned 0x%x\n " , dw );
}
   
//------------------------------------------------------------------------------------
void CMainFrame::OnReRegisterServer( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_REREGISTERLS , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnReRegisterServer returned 0x%x\n " , dw );
}

//------------------------------------------------------------------------------------
void CMainFrame::OnUnRegisterServer( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnUnRegisterServer returned 0x%x\n " , dw );

}

//------------------------------------------------------------------------------------
void CMainFrame::OnProperties( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bF , NOVIEW );

    DBGMSG( L"LICMGR : CMainFrame -- OnProperties returned 0x%x\n", dw );
}

//------------------------------------------------------------------------------------
BOOL CMainFrame::IsLicensesDownLoaded( )
{
    CLicServer * pLicServer = NULL;
    
    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer != NULL )
        {
            if( pLicServer->GetConType( ) != CONNECTION_PHONE )
            {
                DBGMSG( L"Licmgr CMainFrame::IsLicensesDownLoaded GetConnectionType internet - www base\n" , 0 );
                
                return pLicServer->IsLicsDownloaded( );
            }
            else
            {
                return FALSE;
            }            
        }
    }

    return FALSE;
}

//------------------------------------------------------------------------------------
DWORD CMainFrame::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh , VIEW vt )
{
    CLicMgrLeftView * pLeftView = (CLicMgrLeftView *)m_pLeftView;

    CTreeCtrl& TreeCtrl = pLeftView->GetTreeCtrl();

    CRightList * pRightView = (CRightList *)m_pRightView;

    CLicServer *pServer = NULL;

    if( vt == TREEVIEW )
    {

        CTreeNode *pNode = (CTreeNode *)TreeCtrl.GetItemData( pLeftView->GetRightClickedItem() );

        if( pNode->GetNodeType() == NODE_SERVER )
        {
            pServer = static_cast< CLicServer * >( pNode->GetTreeObject() );
        }
        else if( pNode->GetNodeType( ) == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                pServer = pKeyPack->GetServer( );
            }
        }
    }
    else if( vt == LISTVIEW )
    {
        CListCtrl& listctrl = pRightView->GetListCtrl();
        
        CLicMgrDoc * pDoc = ( CLicMgrDoc * )( GetActiveView()->GetDocument( ) );
        
        ASSERT(pDoc);
        
        if(NULL == pDoc)
        {
            return ERROR_INVALID_PARAMETER;
        }
       
        int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);

        if( -1 != nSelected)
        {
            DWORD_PTR dCurrSel = listctrl.GetItemData( nSelected );

            if( NODE_ALL_SERVERS == pDoc->GetNodeType() )
            {  
                pServer = reinterpret_cast< CLicServer * >( dCurrSel );
            }        
            else if( pDoc->GetNodeType() == NODE_SERVER )
            {
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack *>( dCurrSel );

                if( pKeyPack != NULL )
                {
                    pServer = pKeyPack->GetServer( );
                }
            }
            else if( pDoc->GetNodeType( ) == NODE_KEYPACK )
            {
                CLicense * pLicense = reinterpret_cast< CLicense * >( dCurrSel );

                pServer = ( pLicense->GetKeyPack() )->GetServer( );
            }
        }
    }
    else if( vt == NOVIEW )
    {
        CLicServer * pLicServer = NULL;
        
        if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
        {
            pServer = pLicServer;
        }
    }


    if( pServer != NULL )
    {            
        DWORD dw = ERROR_SUCCESS;
        
        // check for admin 
        if( !pServer->IsUserAdmin( ) )
        {
            AfxMessageBox( IDS_E_ACCESSDENIED );
            //::MessageBox( GetSafeHwnd( ) , L"Unable to perform operation: Access denied" , L"Terminal Services Licensing" , MB_OK|MB_ICONINFORMATION );

            return ERROR_ACCESS_DENIED;
        }



        if( wa != WIZACTION_REGISTERLS )
        {
            if( pServer->GetServerType() == SERVER_TS5_ENFORCED )
            {
                DBGMSG( L"LICMGR:CMainFrame::WizardActionOnServer calling StartWizard\n", 0 );

                dw = StartWizardEx( GetSafeHwnd( ) , wa , (LPCTSTR)pServer->GetName( ) , pbRefresh );

                DBGMSG( L"StartWizard ( central call ) returned 0x%x\n", dw );

                DBGMSG( L"StartWizard ( central call ) refresh = %s\n", *pbRefresh ? L"true" : L"false" );

                if( *pbRefresh )
                {
                    RefreshServer( pServer );
                }
            }
        }

        
        switch( wa  )
        {           

        case WIZACTION_REGISTERLS:
            // this handles non-enforced as well.
            OnRegistration( );
            break;

        case WIZACTION_UNREGISTERLS : 
            
            if( dw == ERROR_SUCCESS )
            {
                pServer->SetDownLoadLics( FALSE );
            }

            // FALL THROUGH

        case WIZACTION_REREGISTERLS :
            {
                DWORD dwStatus;

                if( IsLicenseServerRegistered( GetSafeHwnd( ) , (LPCTSTR)pServer->GetName( ) , &dwStatus ) == ERROR_SUCCESS )
                {
                    pServer->SetServerRegistrationStatus( dwStatus );
                }
            }
            break;
        }

        return dw;            
    }

    return ERROR_INVALID_PARAMETER;
}

// IE hardening bug, we need to add the activation site to the IE
// trusted sites list, after wizard is done, we'll remove
// So we'll wrap startwizard call
DWORD CMainFrame::StartWizardEx(HWND hWndParent, 
                                WIZACTION WizAction,
                                LPCTSTR pszLSName, 
                                PBOOL pbRefresh)
{
    
    HKEY hKey = NULL;
    
    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                        TRUSTED_ACTIVATION_SITE_REGPATH,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL) == ERROR_SUCCESS)
    {

        DWORD dwValue = TRUSTED_ACTIVATION_REG_VALUE;

        // Create the key value
        LONG lResult = RegSetValueEx(hKey,
                                        TRUSTED_ACTIVATION_REG_VALUE_NAME,
                                        0,
                                        REG_DWORD,
                                        (LPBYTE)&dwValue,
                                        sizeof(DWORD));
    }

    DWORD dw = StartWizard(hWndParent ,WizAction ,pszLSName ,pbRefresh);
    
    // Delete key we created above
    RegDeleteKey(HKEY_CURRENT_USER, TRUSTED_ACTIVATION_SITE_REGPATH);
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return dw;
}

//------------------------------------------------------------------------------------    
BOOL CMainFrame::IsDownLoadedPacks( CLicServer *pServer )
{
    UINT counter = 0;

    if( pServer != NULL )
    {
        KeyPackList *pKeyPackList = pServer->GetKeyPackList( );

        if( pKeyPackList != NULL )
        {
            POSITION pos = pKeyPackList->GetHeadPosition();
            
            while(pos)
            {
                CKeyPack *pKeyPack = (CKeyPack *)pKeyPackList->GetNext(pos);

                if( pKeyPack != NULL )
                {
                    if( pKeyPack->GetKeyPackStruct().ucKeyPackType != LSKEYPACKTYPE_TEMPORARY &&
                        pKeyPack->GetKeyPackStruct().ucKeyPackType != LSKEYPACKTYPE_FREE )
                    {
                        counter++;

                        DBGMSG( L"LICMGR:CMainFrame found %d keypack(s)\n" , counter );
                    }
                }
            }

            if( counter >= 1 )
            {
                DBGMSG( L"LICMGR : CMainFrame IsDownLoadedPacks returns true\n" ,0 );
                return TRUE;
            }
        }
    }

    DBGMSG( L"LICMGR : CMainFrame IsDownLoadedPacks returns false \n" ,0 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\rtlist.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    RtList.cpp

Abstract:
    
    This Module contains the implementation of CRightList class
    (The View class used for the Right pane of the splitter)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "RtList.h"
#include "Mainfrm.h"



#include "LSmgrdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern int GetStatusPosition( CLicense *pLic );
/////////////////////////////////////////////////////////////////////////////
// CRightList

IMPLEMENT_DYNCREATE(CRightList, CListView)

CRightList::CRightList()
{

}

CRightList::~CRightList()
{
   m_ImageListLarge.DeleteImageList();
   m_ImageListSmall.DeleteImageList();
}


BEGIN_MESSAGE_MAP(CRightList, CListView)
    //{{AFX_MSG_MAP(CRightList)
    ON_MESSAGE(WM_SEL_CHANGE, OnSelChange)
    ON_COMMAND(ID_LARGE_ICONS, OnLargeIcons)
    ON_COMMAND(ID_SMALL_ICONS, OnSmallIcons)
    ON_COMMAND(ID_LIST, OnList)
    ON_COMMAND(ID_DETAILS, OnDetails)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_MESSAGE(WM_DELETE_SERVER, OnDeleteServer)
    ON_MESSAGE(WM_UPDATE_SERVER, OnUpdateServer)
    ON_MESSAGE(WM_ADD_KEYPACK, OnAddKeyPack)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
    ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_NOTIFY_REFLECT(NM_CLICK , OnLeftClick )

    
    // server menuitems
        
    // all server menus
    ON_WM_CONTEXTMENU()
    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )
   
    // server menuitems

    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LPK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_SVR_ACTIVATESERVER , OnRegisterServer )
    ON_COMMAND( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LPK_ADVANCED_REACTIVATESERVER , OnReactivateServer )
    ON_COMMAND( ID_LPK_ADVANCED_DEACTIVATESERVER , OnDeactivateServer )
    ON_COMMAND( ID_LPK_PROPERTIES , OnServerProperties )
    ON_COMMAND( ID_LPK_HELP , OnGeneralHelp )

    // license pak items

    // ON_COMMAND( ID_LICPAK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LICPAK_REFRESH , OnRefreshServer )
    // ON_COMMAND( ID_LICPAK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LICPAK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LICPAK_REPEATDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LICPAK_HELP , OnGeneralHelp )

    

    // license pak items
    
    // license items

    /*  removed from spec
    
    ON_COMMAND( ID_LIC_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LIC_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LIC_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LIC_HELP , OnGeneralHelp )

    */
     
        
    //}}AFX_MSG_MAP
    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRightList drawing

void CRightList::OnDraw(CDC* pDC)
{
    CDocument* pDoc = GetDocument();
    // TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CRightList diagnostics

#ifdef _DEBUG
void CRightList::AssertValid() const
{
    CListView::AssertValid();
}

void CRightList::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRightList message handlers

LRESULT CRightList::OnSelChange(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    BOOL bChangeColumns = FALSE;

    CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer * pLicServer = NULL;
    CKeyPack * pKeyPack = NULL;
        
    CListCtrl& ListCtrl = GetListCtrl();
    ListCtrl.DeleteAllItems();
    NODETYPE CurNodeType = ((CLicMgrDoc *)GetDocument())->GetNodeType();

     if(CurNodeType != (NODETYPE)wParam)
     {
          bChangeColumns = TRUE;
          pDoc->SetNodeType((NODETYPE)wParam);
     }

     switch(wParam)
     {
        case NODE_ALL_SERVERS:
            if(bChangeColumns)
                SetServerColumns();
            AddServerstoList();

            SetActiveServer( NULL );
            
            break;

        case NODE_SERVER:
            pLicServer = (CLicServer *)lParam;
            ASSERT(pLicServer);
            if(NULL == pLicServer)
                break;
            if(bChangeColumns)
                SetKeyPackColumns();
         /*   if(FALSE == pLicServer->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateKeyPacks(pLicServer,LSKEYPACK_SEARCH_LANGID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pLicServer);
                    break;
                }
            
            }*/
            SetActiveServer( pLicServer );

            AddKeyPackstoList((CLicServer *)lParam);
            SetCursor(LoadCursor(NULL,IDC_ARROW));
            break;

         case NODE_KEYPACK:
            pKeyPack = (CKeyPack *)lParam;
            ASSERT(pKeyPack);
            if(NULL == pKeyPack)
                break;
            if(bChangeColumns)
                SetLicenseColumns();
            /*if(FALSE == pKeyPack->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateLicenses(pKeyPack,LSLICENSE_SEARCH_KEYPACKID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pKeyPack->GetServer());
                    break;
                }
            
            }*/

            SetActiveServer( pKeyPack->GetServer( ) );

            ((CMainFrame *)AfxGetMainWnd())->AddLicensestoList(
                                                        (CKeyPack *)lParam,
                                                        &ListCtrl, 
                                                        FALSE
                                                    );
            SetCursor(LoadCursor(NULL,IDC_ARROW));
            break;
        }

    return lResult;
}


HRESULT CRightList::AddServerstoList()
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();

    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return E_FAIL;
    }


    //Get the List Control
    CListCtrl& ListCtrl = GetListCtrl();

    CString TempString;
    CString StatusString;

    LicServerList * licserverlist = NULL;
    int nIndex = 0;

    CAllServers *pAllServer = pDoc->GetAllServers();
    if(NULL == pAllServer)
    {
        goto cleanup;
    }

    licserverlist =  pAllServer->GetLicServerList();

    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    // lvI.iImage = 0;

    POSITION pos;
    pos = licserverlist->GetHeadPosition();
    while(pos)
    {
        //Display the Server Name

        DWORD dwServerStatus;

        lvI.iItem = nIndex;
        lvI.iSubItem = 0;
        CLicServer * pLicServer = licserverlist->GetNext(pos);
        lvI.lParam = (LPARAM)pLicServer;
        TempString = pLicServer->GetName();
        lvI.pszText = TempString.GetBuffer(TempString.GetLength());
        lvI.cchTextMax =lstrlen(lvI.pszText + 1);

        dwServerStatus = pLicServer->GetServerRegistrationStatus();
            

        if(pLicServer->GetServerType() == SERVER_TS5_ENFORCED)
        {
            if( dwServerStatus == LSERVERSTATUS_REGISTER_INTERNET 
                ||
               dwServerStatus == LSERVERSTATUS_REGISTER_OTHER  )
            {
                StatusString.LoadString(IDS_SERVER_REGISTERED);

                lvI.iImage = 3;
            }
            else if( dwServerStatus == LSERVERSTATUS_WAITFORPIN )
            {
                StatusString.LoadString(IDS_SERVER_WAITFORPIN);

                lvI.iImage = 4;
            }
            else if( dwServerStatus == LSERVERSTATUS_UNREGISTER )
            {
                lvI.iImage = 5;

                StatusString.LoadString(IDS_SERVER_UNREGISTER);
            }
            else
            {
                lvI.iImage = 6;

                StatusString.LoadString( IDS_UNKNOWN );
            }

        }
        else
        {
            StatusString.LoadString(IDS_SERVER_NOTREQUIRE);
            
            lvI.iImage = 0;            
        }

        //
        // Display registration status
        //

        nIndex = ListCtrl.InsertItem(&lvI);

        // ListCtrl.SetItemText(nIndex,1,(LPCTSTR)pLicServer->GetScope());
        ListCtrl.SetItemText(nIndex, 1, (LPCTSTR)StatusString);
        nIndex ++;
    }

    ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);

cleanup:
    return S_OK;

}

//----------------------------------------------------------------------
HRESULT 
CRightList::AddKeyPackstoList(
    CLicServer * pServer,
    BOOL bRefresh
    )
/*++

Abstract:


Parameter:

    bRefresh : TRUE if refresh licenses, FALSE otherwise.

--*/
{
    ASSERT(pServer);
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);

    if(NULL == pDoc || NULL == pServer)
    {
        return E_FAIL;
    }

    CListCtrl& ListCtrl = GetListCtrl();
    ULONG nIndex = 0;
    POSITION pos;
    int nSubItemIndex = 1;
    CString TempString;
    DWORD dwLicenses = 0;
    
    if(bRefresh == TRUE)
    {
        if(pServer->RefreshCachedKeyPack() != S_OK)
        {
            return E_FAIL;
        }
    }

    KeyPackList * keypacklist = pServer->GetKeyPackList();

    ULONG nNumKeyPacks = (ULONG)keypacklist->GetCount();

    if(0 == nNumKeyPacks)
    {
       goto cleanup;
    }

    pos = keypacklist->GetHeadPosition();

    for(nIndex = 0; nIndex < nNumKeyPacks; nIndex++)
    {
        CKeyPack * pKeyPack = keypacklist->GetNext(pos);
        if(NULL == pKeyPack)
        {
            continue;
        }

        AddKeyPack(ListCtrl, nIndex, pKeyPack);
    }

    ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);

cleanup:

    return S_OK;
}

HRESULT CRightList::SetServerColumns()
{
     CListCtrl& ListCtrl = GetListCtrl();
     for(int index = 0; index < MAX_COLUMNS; index++)
     {
      ListCtrl.DeleteColumn(0);
     }
    LV_COLUMN lvC;
    CString ColumnText;
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = 125;
    for(index = 0; index < NUM_SERVER_COLUMNS; index ++)
    {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_SERVER_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        GetListCtrl().InsertColumn(index, &lvC);
    }

 return S_OK;
}


HRESULT CRightList::SetKeyPackColumns()
{
     CListCtrl& ListCtrl = GetListCtrl();
     for(int index = 0; index < MAX_COLUMNS; index++)
     {
      ListCtrl.DeleteColumn(0);
     }
     LV_COLUMN lvC;
     CString ColumnText;
     lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
     lvC.fmt = LVCFMT_LEFT;
     lvC.cx = KEYPACK_DISPNAME_WIDTH;     
     for(index = 0; index < NUM_KEYPACK_COLUMNS; index ++)
     {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_KEYPACK_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        ListCtrl.InsertColumn(index, &lvC);
        lvC.cx = KEYPACK_OTHERS_WIDTH;
     }

     return S_OK;
}

HRESULT CRightList::SetLicenseColumns()
{
    CListCtrl& ListCtrl = GetListCtrl();
    for(int index = 0; index < MAX_COLUMNS; index++)
    {
        ListCtrl.DeleteColumn(0);
    }
    LV_COLUMN lvC;
    CString ColumnText;
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = 125;
    for(index = 0; index < NUM_LICENSE_COLUMNS; index ++)
    {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_LICENSE_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        ListCtrl.InsertColumn(index, &lvC);

    }

 return S_OK;
}



void CRightList::OnInitialUpdate() 
{
    CListView::OnInitialUpdate();

    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;

    //Create and set the image lists
     m_ImageListSmall.Create( SM_BITMAP_WIDTH,SM_BITMAP_HEIGHT,TRUE, 7, 7);

     m_ImageListLarge.Create( LG_BITMAP_WIDTH,LG_BITMAP_HEIGHT,TRUE, 7, 7);

     HICON hIcon = NULL;

     DWORD rgdwIDs[] = { IDI_SERVER , IDI_KEYPACK , IDI_LICENSE , IDI_SERVERREG , IDI_SERVERM , IDI_SERVERX , IDI_SERVERQ , (DWORD)-1 };

     int index = 0;

     while( rgdwIDs[ index ] != ( DWORD )-1 )
     {
         hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE( rgdwIDs[ index ] ) );

         if (NULL == hIcon)
         {
             ASSERT(!"LoadIcon Failed");
             continue;
         }

         m_ImageListSmall.Add(hIcon);
         m_ImageListLarge.Add(hIcon);
         
         /*
         if ((m_ImageListSmall.Add(hIcon) == -1) || (m_ImageListLarge.Add(hIcon) == -1))
             {
                 continue;    
             }
         }
         */

         ++index;
     }

     GetListCtrl().SetImageList(&m_ImageListSmall,LVSIL_SMALL);
     GetListCtrl().SetImageList(&m_ImageListLarge,LVSIL_NORMAL);  

     //Set the style
     GetListCtrl().ModifyStyle(0,LVS_REPORT | LVS_AUTOARRANGE | LVS_SINGLESEL | LVS_SORTASCENDING,0);

     GetListCtrl().SendMessage( LVM_SETEXTENDEDLISTVIEWSTYLE , LVS_EX_FULLROWSELECT , LVS_EX_FULLROWSELECT  );

     //Select details view by default
     CMenu *pMenu = pMainFrame->GetMenu();
     if(pMenu)
        pMenu->CheckMenuRadioItem(ID_DETAILS,ID_LIST, ID_DETAILS,MF_BYCOMMAND);
     pMainFrame->PressButton(ID_DETAILS,TRUE);

     //Display the server
     pMainFrame->ConnectAndDisplay();

}

void CRightList::OnLargeIcons() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_REPORT | LVS_SMALLICON,LVS_ICON,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_LARGE_ICONS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,TRUE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
 
    
}

void CRightList::OnSmallIcons() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_ICON | LVS_REPORT,LVS_SMALLICON,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_SMALL_ICONS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,TRUE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
   
    
}

void CRightList::OnList() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_REPORT|LVS_ICON | LVS_SMALLICON,LVS_LIST,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_LIST,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,TRUE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
}

void CRightList::OnDetails() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_ICON | LVS_SMALLICON,LVS_REPORT,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_DETAILS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,TRUE);
    return;
}

LRESULT CRightList::OnAddServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return lResult;
    }

    if(NODE_ALL_SERVERS != pDoc->GetNodeType())
    {
        return lResult;
    }

    CListCtrl& ListCtrl = GetListCtrl();

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
    {
        return lResult;
    }

    LV_ITEM lvI;
    
    lvI.iImage = 0;

    if( pServer->GetServerType() == SERVER_TS5_ENFORCED )
    {

        DWORD dwStatus = pServer->GetServerRegistrationStatus( );

        if( dwStatus == LSERVERSTATUS_REGISTER_INTERNET || dwStatus == LSERVERSTATUS_REGISTER_OTHER )
        {
            lvI.iImage = 3;
        }
        else if( dwStatus == LSERVERSTATUS_WAITFORPIN )
        { 
            lvI.iImage = 4;
        }
        else if( dwStatus == LSERVERSTATUS_UNREGISTER )
        {
            lvI.iImage = 5;
        }
        else
        {
            lvI.iImage = 6;
        }
    }
    
    

    CString Name;
    int nIndex = GetListCtrl().GetItemCount();

    // Insert Server Name;
    
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iSubItem = 0;
    //lvI.iImage = 0;
    lvI.iItem = nIndex;
    lvI.lParam = (LPARAM)pServer;
    Name = pServer->GetName();
    lvI.pszText = Name.GetBuffer(Name.GetLength());
    lvI.cchTextMax =lstrlen(lvI.pszText + 1);
    nIndex = ListCtrl.InsertItem(&lvI);

    //Insert Server Scope

    //ListCtrl.SetItemText(nIndex,1,pServer->GetScope());

    CString TempString;

    if(pServer->GetServerType() == SERVER_TS5_ENFORCED)
    {
        if(pServer->GetServerRegistrationStatus() ==  LSERVERSTATUS_REGISTER_INTERNET 
            ||
           pServer->GetServerRegistrationStatus() == LSERVERSTATUS_REGISTER_OTHER  )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_REGISTERED) == TRUE);
        }
        else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_WAITFORPIN )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_WAITFORPIN) == TRUE);
        }
        else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_UNREGISTER )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_UNREGISTER) == TRUE);
        }
        else
        {
            VERIFY(TempString.LoadString(IDS_UNKNOWN ) == TRUE);
        }

    }
    else
    {
        VERIFY(TempString.LoadString(IDS_SERVER_NOTREQUIRE) == TRUE);
    }

    ListCtrl.SetItemText(nIndex, 1, (LPCTSTR)TempString);

    if(nIndex == 0)
    {
        ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);
    }

    return lResult;
} // OnAddServer

LRESULT CRightList::OnAddKeyPack(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    if(NODE_SERVER != pDoc->GetNodeType())
         return lResult;
    

    CListCtrl& ListCtrl = GetListCtrl();
    int nIndex = ListCtrl.GetItemCount();

    CKeyPack *pKeyPack = (CKeyPack*)lParam;
    ASSERT(pKeyPack);
    if(NULL == pKeyPack)
        return lResult;

    AddKeyPack(ListCtrl,nIndex,pKeyPack);
    if(nIndex == 0)
        ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);


    return lResult;
 
} // OnAddKeyPack


void CRightList::AddKeyPack(CListCtrl& ListCtrl,int nIndex, CKeyPack * pKeyPack)
{
    if(NULL == pKeyPack)
    {
        return;
    }

    LSKeyPack sKeyPack;
    int nSubItemIndex = 1;
    DWORD dwLicenses = 0;

    CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return;
    }

    CString TempString;
    DWORD dwIssuedLicenses = 0;
    
    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iItem = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 1;
    lvI.iItem = nIndex;
    lvI.lParam = (LPARAM)pKeyPack;

    TempString = pKeyPack->GetDisplayName();
    lvI.pszText = TempString.GetBuffer(TempString.GetLength());
    lvI.cchTextMax =lstrlen(lvI.pszText + 1);
    nIndex = ListCtrl.InsertItem(&lvI);

    sKeyPack = pKeyPack->GetKeyPackStruct();

    //Set the KeyPack Type.

    if(NUM_KEYPACK_TYPE <= sKeyPack.ucKeyPackType)
    {
         TempString.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN );
    }
    else
    {
        if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_LSKEYPACKTYPE_FREE );
        }
        else
        {
            TempString.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN+ sKeyPack.ucKeyPackType);
        }
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);
    nSubItemIndex++;

    //Set the Activation date, Now called Registered on

#ifdef SPANISH
        
    if(LSKEYPACKTYPE_TEMPORARY != sKeyPack.ucKeyPackType)
    {
        TempString = pDoc->TimeToString(&sKeyPack.dwActivateDate);
        if(TempString.IsEmpty())
        {
            TempString.LoadString(IDS_UNKNOWN);
        }
    }
    else
    {
        TempString.LoadString(IDS_DASH);
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);
    nSubItemIndex++;
#endif

      //Set Total licenses.

//
// HueiWang 7/7/98 - per marketing request
//
    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType)
    {
        TempString.LoadString(IDS_DASH);
    }
    else 
    {
        if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_UNLIMITED);
        }
        else
        {
            TempString.Format(_T("%d"),sKeyPack.dwTotalLicenseInKeyPack); 
        }
    }
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    //Set Available licenses.

    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType)
    {
        TempString.LoadString(IDS_DASH);
    }
    else
    {
        if( LSKEYPACKSTATUS_RETURNED == sKeyPack.ucKeyPackStatus ||
            LSKEYPACKSTATUS_REVOKED == sKeyPack.ucKeyPackStatus )
        {
            TempString.Format(_T("%d"), 0);
        }
        else if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_UNLIMITED);
        }
        else
        {
            TempString.Format(_T("%d"),sKeyPack.dwNumberOfLicenses); 
        }
    }
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    //Set Issued licenses.

    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType ||
       LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType )
    {
        dwLicenses = sKeyPack.dwNumberOfLicenses;
    }
    else
    {
        dwLicenses = sKeyPack.dwTotalLicenseInKeyPack - sKeyPack.dwNumberOfLicenses;
    }

    TempString.Format(_T("%d"),dwLicenses);
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    TempString.Empty( );

    switch( sKeyPack.ucKeyPackStatus )
    {
        case LSKEYPACKSTATUS_UNKNOWN:
            TempString.LoadString( IDS_KEYPACKSTATUS_UNKNOWN );
            break;

        case LSKEYPACKSTATUS_TEMPORARY:
            TempString.LoadString( IDS_KEYPACKSTATUS_TEMPORARY );
            break;

        case LSKEYPACKSTATUS_ACTIVE:
        case LSKEYPACKSTATUS_PENDING:
        //case LSKEYPACKSTATUS_RESTORE:
            TempString.LoadString( IDS_KEYPACKSTATUS_ACTIVE );
            break;

        case LSKEYPACKSTATUS_RETURNED:
            TempString.LoadString( IDS_KEYPACKSTATUS_RETURNED );
            break;

        case LSKEYPACKSTATUS_REVOKED:
            TempString.LoadString( IDS_KEYPACKSTATUS_REVOKED );
            break;
    }

    if( TempString.IsEmpty() )
    {
        TempString.LoadString(IDS_UNKNOWN);
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    return;
}


LRESULT CRightList::OnDeleteServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    DBGMSG( L"CRightList_OnDeleteServer\n" , 0 );

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;
    CListCtrl& ListCtrl = GetListCtrl();
    if(0 == ListCtrl.GetItemCount())
        return lResult;

    
    int nIndex = 0;        
    CKeyPack * pKeyPack = NULL;
    LV_ITEM Item;
    ZeroMemory((LPVOID)&Item,sizeof(Item));
    
    switch(pDoc->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            DBGMSG( L"\tNODE_ALL_SERVERS\n",0 );
            LV_FINDINFO FindInfo;
            FindInfo.flags = LVFI_PARAM;
            FindInfo.psz = NULL;
            FindInfo.lParam = (LPARAM)pServer;

            nIndex = ListCtrl.FindItem(&FindInfo);
            if(-1 == nIndex)
                return lResult;

            ListCtrl.DeleteItem(nIndex);
            break;
        case NODE_SERVER:
            DBGMSG( L"\tNODE_SERVER\n",0 );
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
                break;
            pKeyPack = (CKeyPack *)Item.lParam;
            if(NULL == pKeyPack)
                break;
            if(pServer == pKeyPack->GetServer())
                ListCtrl.DeleteAllItems();

            break;
        case NODE_KEYPACK:
            DBGMSG( L"\tNODE_KEYPACK\n",0 );
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
                break;
            CLicense * pLicense = (CLicense *)Item.lParam;
            if(NULL == pLicense)
                break;
            pKeyPack = pLicense->GetKeyPack();
            if(NULL == pKeyPack)
                break;
            if(pServer == pKeyPack->GetServer())
                ListCtrl.DeleteAllItems();

            break;

    }

    
    return lResult;
 
} // OnDeleteServer

LRESULT CRightList::OnUpdateServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    int item;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return lResult;
    }

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
    {
        return lResult;
    }

    CListCtrl& ListCtrl = GetListCtrl();
    if(0 == ListCtrl.GetItemCount())
    {
        return lResult;
    }
    
    int nIndex = 0;
    CKeyPack * pKeyPack = NULL;
    LV_ITEM Item;
    ZeroMemory((LPVOID)&Item,sizeof(Item));

    Item.mask = LVIF_IMAGE;

    CString sServerName;
    if(pServer->UseIpAddress())
        sServerName = pServer->GetIpAddress();
    else
        sServerName = pServer->GetName();

    switch(pDoc->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            for( item = 0; item < ListCtrl.GetItemCount( ); ++item )
            {
                CString sItemName = ListCtrl.GetItemText(item, 0);

                //We'll only refresh the server we were asked to refresh
                if(sServerName != sItemName) 
                    continue;
            
                // update status of registration
                
                CString TempString;

                if(pServer->GetServerType() == SERVER_TS5_ENFORCED)
                {
                    if(pServer->GetServerRegistrationStatus() ==  LSERVERSTATUS_REGISTER_INTERNET 
                        ||
                       pServer->GetServerRegistrationStatus() == LSERVERSTATUS_REGISTER_OTHER  )
                    {
                        TempString.LoadString(IDS_SERVER_REGISTERED);
                        Item.iImage = 3;
                    }
                    else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_WAITFORPIN )
                    {
                        TempString.LoadString( IDS_SERVER_WAITFORPIN );
                        Item.iImage = 4;
                    }
                    else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_UNREGISTER ) 
                    {
                        TempString.LoadString(IDS_SERVER_UNREGISTER);
                        Item.iImage = 5;
                    }
                    else
                    {                        
                        TempString.LoadString(IDS_UNKNOWN);
                        Item.iImage = 6;
                    }

                }
                else
                {
                    TempString.LoadString(IDS_SERVER_NOTREQUIRE);
                }

                Item.iItem = item;

                ListCtrl.SetItem( &Item );

                ListCtrl.SetItemText(item, 1, (LPCTSTR)TempString);
            }

            break;

        case NODE_SERVER:
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
            {
                break;
            }

            pKeyPack = (CKeyPack *)Item.lParam;
            if(NULL == pKeyPack)
            {
                break;
            }

            if(pServer == pKeyPack->GetServer())
            {
                ListCtrl.DeleteAllItems();
                AddKeyPackstoList(pServer, TRUE);
            }
            break;

        case NODE_KEYPACK:
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
            {
                break;
            }

            CLicense * pLicense = (CLicense *)Item.lParam;
            if(NULL == pLicense)
            {
                break;
            }

            pKeyPack = pLicense->GetKeyPack();
            if(NULL == pKeyPack)
            {
                break;
            }

            if(pServer == pKeyPack->GetServer())
            {
                ListCtrl.DeleteAllItems();
                ((CMainFrame *)AfxGetMainWnd())->AddLicensestoList(pKeyPack, &ListCtrl, TRUE);
            }

            break;

    }

    return lResult;
} // OnUpdateServer

//-----------------------------------------------------------------------------------------------------
void CRightList::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // TODO: Add your control notification handler code here
     // TODO: Add your control notification handler code here
    CListCtrl& listctrl = GetListCtrl();

    //Get the selected item
    int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);
    if(-1 == nSelected)
        return;

    //Get the Data associated with the item.
    #ifdef _WIN64
    DWORD_PTR dCurrSel;
    #else
    DWORD dCurrSel;
    #endif

    dCurrSel = listctrl.GetItemData(nSelected);
    if(LB_ERR == dCurrSel)
        return;

    switch(((CLicMgrDoc *)GetDocument())->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            ((CMainFrame *)AfxGetMainWnd())->SetTreeViewSel(dCurrSel,NODE_SERVER);
            break;
        case NODE_SERVER:
            ((CMainFrame *)AfxGetMainWnd())->SetTreeViewSel(dCurrSel,NODE_KEYPACK);
            break;
     }
    
    *pResult = 0;
}

//-----------------------------------------------------------------------------------------------------
void CRightList::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
    // TODO: Add your control notification handler code here
    CMainFrame * pMainFrame  = ((CMainFrame *)AfxGetMainWnd());
    if(pLVKeyDow->wVKey == VK_RETURN)
    {
        OnDblclk(pNMHDR,pResult);
        pMainFrame->SelectView(LISTVIEW);
    }
    if(pLVKeyDow->wVKey == VK_TAB)
    {
        pMainFrame->SelectView(TREEVIEW);
    }

    
    *pResult = 0;
}

/*
 *  Column Sorting.
 */

BOOL    fColSortDir[MAX_COLUMNS * NODE_NONE];

int CALLBACK CompareAllServers(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareServer(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareKeyPack(LPARAM, LPARAM, LPARAM);

VOID
CRightList::OnColumnClick(
    NMHDR*      pNMHDR,
    LRESULT*    pResult
    )
{
    NM_LISTVIEW*    pnmlv = (NM_LISTVIEW*)pNMHDR;
    NODETYPE        curType = ((CLicMgrDoc*)GetDocument())->GetNodeType();

    switch(curType) {
    case NODE_ALL_SERVERS:
        GetListCtrl().SortItems(CompareAllServers, pnmlv->iSubItem);
        break;

    case NODE_SERVER:
        GetListCtrl().SortItems(CompareServer, pnmlv->iSubItem);
        break;

    case NODE_KEYPACK:
        GetListCtrl().SortItems(CompareKeyPack, pnmlv->iSubItem);
        break;
    }

    fColSortDir[curType * MAX_COLUMNS + pnmlv->iSubItem] = 
        !fColSortDir[curType * MAX_COLUMNS + pnmlv->iSubItem];
}

/*
 *  Compare Functions.
 */


int CALLBACK
CompareAllServers(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CLicServer* pItem1  = (CLicServer*)lParam1;
    CLicServer* pItem2  = (CLicServer*)lParam2;
    int         retVal  = 0;
    int         iCol    = (NODE_ALL_SERVERS * MAX_COLUMNS) + (int)lParamSort;
    int         dir;

    switch(lParamSort) {

    case 0:
    case 1:
        retVal = pItem1->GetName().CompareNoCase(pItem2->GetName());
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

int CALLBACK
CompareServer(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CKeyPack*   pItem1  = (CKeyPack*)lParam1;
    CKeyPack*   pItem2  = (CKeyPack*)lParam2;
    CString     szTemp1;
    CString     szTemp2;
    int         retVal  = 0;
    int         iCol    = (NODE_SERVER * MAX_COLUMNS) + (int)lParamSort;
    int         dir;
    int         tmp1, tmp2;

    switch(lParamSort) {

    case 0:
        retVal = _tcsicmp(pItem1->GetDisplayName(), pItem2->GetDisplayName());
        break;

    case 1:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 >= NUM_KEYPACK_TYPE) {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN);
        } else if(tmp1 == LSKEYPACKTYPE_FREE) {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_FREE);
        } else {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN + tmp1);
        }

        if (tmp2 >= NUM_KEYPACK_TYPE) {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN);
        } else if(tmp2 == LSKEYPACKTYPE_FREE) {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_FREE);
        } else {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN + tmp2);
        }

        retVal = _tcsicmp(szTemp1, szTemp2);
        break;

    case 2:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 == LSKEYPACKTYPE_FREE) {
            retVal = 1;
        } else if (tmp1 == LSKEYPACKTYPE_TEMPORARY) {
            retVal = -1;
        } else {
            if (tmp2 == LSKEYPACKTYPE_FREE) {
                retVal = -1;
            } else if (tmp2 == LSKEYPACKTYPE_TEMPORARY) {
                retVal = 1;
            } else {
                retVal = pItem1->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                         pItem2->GetKeyPackStruct().dwTotalLicenseInKeyPack;
            }
        }
        break;

    case 3:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 == LSKEYPACKTYPE_FREE) {
            retVal = 1;
        } else if (tmp1 == LSKEYPACKTYPE_TEMPORARY) {
            retVal = -1;
        } else {
            if (tmp2 == LSKEYPACKTYPE_FREE) {
                retVal = -1;
            } else if (tmp2 == LSKEYPACKTYPE_TEMPORARY) {
                retVal = 1;
            } else {
                retVal = pItem1->GetKeyPackStruct().dwNumberOfLicenses -
                         pItem2->GetKeyPackStruct().dwNumberOfLicenses;
            }
        }
        break;

    case 4:
        DWORD   sort1, sort2;

        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if ((tmp1 == LSKEYPACKTYPE_TEMPORARY) || (tmp1 == LSKEYPACKTYPE_FREE)) {
            sort1 = pItem1->GetKeyPackStruct().dwNumberOfLicenses;
        } else {
            sort1 = pItem1->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                    pItem1->GetKeyPackStruct().dwNumberOfLicenses;
        }

        if ((tmp2 == LSKEYPACKTYPE_TEMPORARY) || (tmp2 == LSKEYPACKTYPE_FREE)) {
            sort2 = pItem2->GetKeyPackStruct().dwNumberOfLicenses;
        } else {
            sort2 = pItem2->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                    pItem2->GetKeyPackStruct().dwNumberOfLicenses;
        }

        retVal = sort1 - sort2;
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

int CALLBACK
CompareKeyPack(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CLicense*   pItem1  = (CLicense*)lParam1;
    CLicense*   pItem2  = (CLicense*)lParam2;
    int         retVal  = 0;
    int         iCol    = (NODE_KEYPACK * MAX_COLUMNS) + (int)lParamSort;
    int         dir;

    switch(lParamSort) {

    case 0:
        retVal = _tcsicmp(pItem1->GetLicenseStruct().szMachineName,
                          pItem2->GetLicenseStruct().szMachineName);
        break;

    case 1:
        retVal = pItem1->GetLicenseStruct().ftIssueDate -
                 pItem2->GetLicenseStruct().ftIssueDate;
        break;

    case 2:
        retVal = pItem1->GetLicenseStruct().ftExpireDate -
                 pItem2->GetLicenseStruct().ftExpireDate;
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

afx_msg void CRightList::OnLeftClick( NMHDR* pNMHDR, LRESULT* pResult )
{
    CPoint pt;

    DWORD_PTR itemData;   

    GetCursorPos( &pt );

    ScreenToClient( &pt );
    UINT flag;

    CListCtrl& listctrl = GetListCtrl();

    int iItem = listctrl.HitTest( pt , &flag );

    itemData = listctrl.GetItemData( iItem );

    if( itemData == LB_ERR )
    {        
        int iItem = listctrl.GetNextItem(-1, LVNI_SELECTED | LVNI_FOCUSED );

        if( iItem != LB_ERR )
        {
            itemData = listctrl.GetItemData( iItem );
        }
        else
        {
            DBGMSG( L"\tno item selected\n", 0  );
            
            return;
        }
    }

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
            
    if(NULL == pDoc)
    {
        return;
    }
    
    NODETYPE nt = pDoc->GetNodeType();

    switch( nt )
    {
        case NODE_ALL_SERVERS:
            {                
                CLicServer *pServer = reinterpret_cast< CLicServer* >( itemData );

                SetActiveServer( pServer );

                if( NULL == pServer )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tServer item selected\n", 0  );                
            }
            break;

        case NODE_SERVER:
            {   
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack * >( itemData );

                if(NULL == pKeyPack)
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    SetActiveServer( NULL );

                    break;
                }

                SetActiveServer( pKeyPack->GetServer( ) );

                DBGMSG( L"\tLicense pak item selected\n", 0  );
            }

            break;        

        case NODE_KEYPACK:
            {   
                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense != NULL )
                {
                    CKeyPack *pKeyPack = pLicense->GetKeyPack( );

                    if( pKeyPack != NULL )
                    {
                        SetActiveServer( pKeyPack->GetServer( ) );                

                        break;
                    }
                }

                SetActiveServer( NULL );


            }
            
            break;    
    }
}

//------------------------------------------------------------------------
afx_msg void CRightList::OnContextMenu( CWnd* pWnd, CPoint pt ) 
{
    CMenu menu;

    CMenu *pContextMenu = NULL;
    
    DWORD_PTR itemData;   

    DBGMSG( L"LICMGR @ CRightList::OnContextMenu\n" , 0 );
        
    DBGMSG( L"\tpoint x = %d " , pt.x );
    
    DBGMSG( L"y = %d\n" , pt.y );

    UINT flag;
    
    int nItem = -1;

    CListCtrl& listctrl = GetListCtrl();

    // maybe keyboard selected this item

    if(pt.x == -1 && pt.y == -1)
    {   
        if( listctrl.GetSelectedCount( ) > 0 )
        {
            RECT rect;

            nItem = listctrl.GetNextItem( nItem , LVNI_SELECTED );

            if( nItem != ( int )LB_ERR )
            {
                listctrl.GetItemRect( nItem , &rect , LVIR_BOUNDS );

		        pt.x = rect.left + (rect.right - rect.left)/2;
		        
                pt.y = rect.top + (rect.bottom - rect.top)/2;
		        
            }
        }
    }
    else
    {
        // otherwise we're invoked by the mouse
        ScreenToClient( &pt );

        nItem = listctrl.HitTest( pt , &flag );
    }
    
    itemData = listctrl.GetItemData( nItem );


    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
            
    if(NULL == pDoc)
    {
        return;
    }

    ClientToScreen( &pt );

    NODETYPE nt = pDoc->GetNodeType();

    switch( nt )
    {
        case NODE_ALL_SERVERS:
            {                
                CLicServer *pServer = reinterpret_cast< CLicServer* >( itemData );

                SetActiveServer( pServer );

                if( NULL == pServer )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tServer item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 0 );

                nt = NODE_SERVER;
 
            }
            break;

        case NODE_SERVER:
            {                
                nt = NODE_KEYPACK;

                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack * >( itemData );

                if(NULL == pKeyPack)
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    // SetActiveServer( NULL );

                    break;
                }

                SetActiveServer( pKeyPack->GetServer( ) );

                DBGMSG( L"\tLicense pak item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 1 );
                
            }

            break;

        

        case NODE_KEYPACK:
            {   
                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense == NULL )
                {
                    DBGMSG( L"\tno item selected\n", 0  );
                    
                    // SetActiveServer( NULL  );

                    break;
                }


                CKeyPack *pKeyPack = pLicense->GetKeyPack( );

                if( pKeyPack != NULL )
                {
                    SetActiveServer( pKeyPack->GetServer( ) );
                }
                else
                {
                    // impossible! a license with out a home
                    ASSERT( 0 );
                }

                /*
                nt = NODE_NONE; // its safe

                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense == NULL )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tLicense item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 2 );

                */
                
            }
            
            break;
        
    }


    UI_initmenu( pContextMenu , nt );

    if( pContextMenu != NULL )
    {
        pContextMenu->TrackPopupMenu( TPM_LEFTALIGN , pt.x , pt.y , this );
    }

}
          
//----------------------------------------------------------------------------
void CRightList::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->UI_initmenu( pMenu , nt );
    }
   
}

//----------------------------------------------------------------------------
DWORD CRightList::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        return pMainFrame->WizardActionOnServer( wa , pbRefresh , LISTVIEW );
    }

    return ERROR_INVALID_PARAMETER;
}


//-----------------------------------------------------------------------------------------       
void CRightList::OnServerConnect( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->ConnectServer( );
    }

}

//-----------------------------------------------------------------------------------------
void CRightList::OnRefreshAllServers( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->OnRefresh( );
    }
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRefreshServer( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

   CLicServer *pServer = NULL;

    if( pMainFrame != NULL )
    {
        CListCtrl& listctrl = GetListCtrl();
        
        CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
        
        ASSERT(pDoc);
        
        if(NULL == pDoc)
        {
            return;
        }
       
        int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);

        if( -1 != nSelected)
        {
            DWORD_PTR dCurrSel = listctrl.GetItemData( nSelected );

            if( NODE_ALL_SERVERS == pDoc->GetNodeType() )
            {  
                pServer = reinterpret_cast< CLicServer * >( dCurrSel );
            }        
            else if( pDoc->GetNodeType() == NODE_SERVER )
            {
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack *>( dCurrSel );

                if( pKeyPack != NULL )
                {
                    pServer = pKeyPack->GetServer( );
                }
            }
            else if( pDoc->GetNodeType( ) == NODE_KEYPACK )
            {
                CLicense * pLicense = reinterpret_cast< CLicense * >( dCurrSel );

                pServer = ( pLicense->GetKeyPack() )->GetServer( );
            }
        }


        if( pServer != NULL )
        {
            pMainFrame->RefreshServer( pServer );
        }        
    }

}
    
//-----------------------------------------------------------------------------------------
void CRightList::OnDownloadKeepPack()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bRefresh );
  
    DBGMSG( L"LICMGR : CRightList::OnDownloadKeepPack StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRegisterServer()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnRegisterServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnRepeatLastDownload()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnRepeatLastDownload StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnReactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnReactivateServer StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CRightList::OnDeactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnDeactivateServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnServerProperties( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bRefresh );
    
    DBGMSG( L"LICMGR : CRightList::OnServerProperties StartWizard returned 0x%x\n" , dwStatus );    
    
}

//-----------------------------------------------------------------------------------------
void CRightList::OnGeneralHelp( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );
    
    if( pMainFrame != NULL )
    {
        pMainFrame->OnHelp( );
    }
}

//-----------------------------------------------------------------------------------------
void CRightList::SetActiveServer( CLicServer *pServer )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pServer != NULL )
    {
        DBGMSG( L"LICMGR : CRightList::SetActiveServer %s\n" , (LPCTSTR)pServer->GetName( ) );
    }


    if( pMainFrame != NULL )
    {
        pMainFrame->SetActiveServer( pServer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\treenode.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	TreeNode.h

Abstract:
    
    This Module contains the CTreeNode class
    (Class used for representing every node in the tree view);

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include <afx.h>


class CTreeNode : public CObject
{
public:
    // constructor
    CTreeNode(NODETYPE NodeType, CObject* pObject) { m_NodeType = NodeType; m_pTreeObject = pObject; }
    // Returns the node type
    NODETYPE GetNodeType() { return m_NodeType; }
    // Returns the object pointed to by this node
    CObject *GetTreeObject() { return m_pTreeObject; }
    // Returns the sort order stored in the object
    ULONG GetSortOrder() { return m_SortOrder; }
    // Sets the sort order stored with the object
    void SetSortOrder(ULONG order) { m_SortOrder = order; }

private:
    NODETYPE m_NodeType;
    CObject* m_pTreeObject;
    ULONG m_SortOrder;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#ifdef DBG

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[250]; \
    wsprintf( tchErr , x , y ); \
    OutputDebugString( tchErr ); \
    }

#else

#define DBGMSG( x , y )

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by licmgr.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_SERVER_PROPERTIES           102
#define IDD_SERVER_PROPERTYPAGE         102
#define IDD_KEYPACK_PROPERTYPAGE        107
#define IDD_PROPPAGE_LARGE1             108
#define IDD_LICENSE_PROPERTYPAGE        108
#define IDR_MAINFRAME                   128
#define IDR_LICMGRTYPE                  129
#define IDI_ALL_SERVERS                 131
#define IDI_SERVER                      132
#define IDI_KEYPACK                     133
#define IDI_LICENSE                     134
#define IDD_CONNECT_DIALOG              137
#define IDD_ADD_KEYPACK                 138
#define IDR_TRACKMENU                   140
#define IDD_TEMP_LICENSES               141
#define IDD_LIC_AGREEMENT               142
#define IDD_ADD_LICENSES                144
#define IDD_REMOVE_LICENSES             146
#define IDD_DISCOVERY                   148
#define IDD_CONNECT_ERROR               149
#define IDR_MENU_LPK                    150
#define IDI_SERVERREG                   151
#define IDI_SERVERM                     152
#define IDI_SERVERX                     153
#define IDI_SERVERQ                     154
#define IDC_STATIC_NAME                 1001
#define IDC_STATIC_KEYPACK              1002
#define IDC_STATIC_KEYPACK2             1003
#define IDC_SERVER_NAME                 1005
#define IDC_SCOPE                       1006
#define IDC_HELP2                       1007
#define IDC_SERVER                      1008
#define IDC_COMPANY_NAME                1010
#define IDC_KEYPACK_ID                  1011
#define IDC_PRODUCT_NAME                1013
#define IDC_LANGUAGE                    1015
#define IDC_EDIT5                       1017
#define IDC_LICENSES                    1017
#define IDC_NUM_LICENSES                1018
#define IDC_KEYPACK_TYPE                1020
#define IDC_PRODUCT_ID                  1031
#define IDC_MAJOR_VERSION               1032
#define IDC_MINOR_VERSION               1033
#define IDC_BEGIN_SERIAL                1034
#define IDC_CHANNEL_OF_PURCHASE         1035
#define IDC_TOTAL_LICENSES              1036
#define IDC_AVAILABLE_LICENSES          1037
#define IDC_ACTIVATION_DATE             1038
#define IDC_EXPIRATION_DATE             1039
#define IDC_KEYPACK_STATUS              1040
#define IDC_MACHINE_NAME                1045
#define IDC_USER_NAME                   1046
#define IDC_ISSUE_DATE                  1047
#define IDC_EXPIRY_DATE                 1048
#define IDC_LICENSE_STATUS              1049
#define IDC_HELP1                       1051
#define IDC_TEMP_LICENSES               1052
#define IDC_LICENSE                     1053
#define IDC_AGREE                       1054
#define IDC_BUTTON1                     1056
#define IDC_HELP4                       1056
#define IDC_SPIN_LICNESES               1058
#define IDC_LICNESE_PACK                1060
#define IDC_REMOVE                      1061
#define IDC_ADD                         1062
#define IDC_HELP3                       1063
#define IDC_TLSERVER_NAME               1064
#define ID_CANCEL_DISCOVERY             1065
#define IDS_SERVER_REGISTERED           1066
#define IDS_SERVER_UNREGISTER           1067
#define IDS_SERVER_NOTREQUIRE           1068
#define ID_LARGE_ICONS                  32771
#define ID_SMALL_ICONS                  32772
#define ID_DETAILS                      32773
#define ID_LIST                         32774
#define ID_PROPERTIES                   32779
#define ID_CONNECT_SERVER               32784
#define ID_ADD_LICENSES                 32785
#define ID_EXIT                         32787
#define ID_HELP_CONTENTS                32788
#define ID_HELP_SEARCH                  32789
#define ID_HELP_HELP                    32790
#define ID_REFRESH                      32791
#define ID_LICENSE_REGISTER             32795
#define ID_REGISTRATION                 32796
#define ID_ACTION_DOWNLOADLICENSES      32797
#define ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD 32799
#define ID_ACTION_ADVANCED_REREGISTERSERVER 32800
#define ID_ACTION_ADVANCED_UNREGISTERSERVER 32801
#define ID_VIEW_REFRESHALL              32802
#define ID_LPK_CONNECT                  32803
#define ID_LPK_REFRESH                  32804
#define ID_LPK_REFRESHALL               32805
#define ID_LPK_DOWNLOADLICENSES         32806
#define ID_LPK_REPEATDOWNLOAD           32807
#define ID_LPK_HELP                     32808
#define ID_LIC_CONNECT                  32809
#define ID_LIC_REFRESH                  32810
#define ID_LIC_DOWNLOADLICENSES         32811
#define ID_LIC_HELP                     32812
#define ID_LPK_PROPERTIES               32813
#define ID_LPK_ADVANCED_REPEATLASTDOWNLOAD 32814
#define ID_LPK_ADVANCED_REACTIVATESERVER 32815
#define ID_LPK_ADVANCED_DEACTIVATESERVER 32816
#define ID_SVR_ACTIVATESERVER           32817
#define ID_LICPAK_REFRESH               32819
#define ID_LICPAK_DOWNLOADLICENSES      32821
#define ID_LICPAK_REPEATDOWNLOAD        32822
#define ID_LICPAK_HELP                  32823
#define ID_ALLSVR_CONNECT               32824
#define ID_ALLSVR_REFRESHALL            32825
#define ID_ALLSVR_HELP                  32826
#define ID_KEY_HELP                     32828
#define ID_VIEW_PROPERTIES              32829
#define IDS_TREEROOT                    61204
#define IDS_SERVER_COLUMN1              61205
#define IDS_SERVER_COLUMN2              61206
#define IDS_SERVER_COLUMN3              61207
#define IDS_KEYPACK_COLUMN1             61208
#define IDS_KEYPACK_COLUMN2             61209
#define IDS_KEYPACK_COLUMN3             61210
#define IDS_KEYPACK_COLUMN4             61211
#define IDS_KEYPACK_COLUMN5             61212
#define IDS_KEYPACK_COLUMN6             61213
#define IDS_LICENSE_COLUMN1             61214
#define IDS_LICENSE_COLUMN2             61215
#define IDS_LICENSE_COLUMN3             61216
#define IDS_LICENSE_COLUMN4             61217
#define IDS_ENUM_FAILED                 61218
#define IDS_CONNECT_SERVER_FAILED       61219
#define IDS_UNKNOWN                     61220
#define IDS_INVALID_FIELDS              61221
#define IDS_ADD_SUCCESS                 61222
#define IDS_LSKEYPACKTYPE_UNKNOWN       61223
#define IDS_LSKEYPACKTYPE_RETAIL        61224
#define IDS_LSKEYPACKTYPE_SELECT        61225
#define IDS_LSKEYPACKTYPE_CONCURRENT    61226
#define IDS_LSKEYPACKTYPE_TEMPORARY     61227
#define IDS_LSKEYPACKTYPE_OPEN          61228
#define IDS_LSKEYPACKTYPE_FREE          61229
#define IDS_PURCHASE_UNKNOWN            61230
#define IDS_PURCHASE_OEM                61231
#define IDS_PURCHASE_RETAIL             61232
#define IDS_LICENSESTATUS_UNKNOWN       61233
#define IDS_LICENSESTATUS_TEMPORARY     61234
#define IDS_LICENSESTATUS_ACTIVE        61235
#define IDS_LICENSESTATUS_UPGRADED      61236
#define IDS_LICENSESTATUS_REVOKE        61237
#define IDS_LICENSE_PROPERTIES          61238
#define IDS_KEYPACK_PROPERTIES          61239
#define IDS_SERVER_PROPERTIES           61240
#define IDS_TEMPORARY                   61241
#define IDS_KEYPACKSTATUS_UNKNOWN       61242
#define IDS_KEYPACKSTATUS_ACTIVE        61243
#define IDS_KEYPACKSTATUS_PENDING       61244
#define IDS_KEYPACKSTATUS_RETURNED      61245
#define IDS_KEYPACKSTATUS_REVOKED       61246
#define IDS_KEYPACKSTATUS_TEMPORARY     61247
#define IDS_KEYPACKSTATUS_OTHERS        61248
#define IDS_APP_NAME                    61249
#define IDS_DUPLICATE_SERVER            61250
#define IDS_NO_KEYPACKS                 61251
#define IDS_NO_TEMP_LIC                 61252
#define IDS_LOCAL_NOLICENSE             61253
#define IDS_NO_MEMORY                   61254
#define IDS_DASH                        61255
#define IDS_FOR                         61256
#define IDS_PLATFORM1                   61257
#define IDS_PLATFORM2                   61258
#define IDS_PLATFORM3                   61259
#define IDS_PLATFORM4                   61260
#define IDS_PLATFORM5                   61261
#define IDS_PLATFORM6                   61262
#define IDS_TERMINAL_SERVER             61263
#define IDS_LIC_AGRMT                   61264
#define IDS_INTERNAL_ERROR              61265
#define IDS_REFRESH_SERVERS_ERROR       61266
#define IDS_UNLIMITED                   61267
#define IDS_SKU1                        61268
#define IDS_SKU2                        61269
#define IDS_SKU3                        61270
#define IDS_REMOVE_WARNING              61271
#define IDS_REMOVE_MORE                 61272
#define IDS_NO_HELP                     61273
#define IDS_CLEARING_HOUSE              61274
#define IDS_NO_ACCESS                   61275
#define IDS_REGISTER_FAILED             61276
#define IDS_TOTAL_CHANGED               61277
#define IDS_REMOVE_TOOMANY              61278
#define IDS_CONNECT_ERROR               61279
#define IDS_SERVER_BUSY                 61280
#define IDS_SERVER_OUTOFMEMORY          61281
#define IDS_SERVER_INTERNAL_ERROR       61282
#define IDS_236_SKU                     61283
#define IDS_NOSERVERINDOMAIN            61284
#define IDS_CREATETHREAD                61285
#define IDS_CANCELDISCOVERY             61286
#define IDS_TRYSERVER                   61287
#define IDS_TS4                         61446
#define IDS_SERVER_WAITFORPIN           61447

#define IDS_E_ACCESSDENIED              61451
#define IDS_LS_MGR_TIP                  61452
#define IDS_LS_MGR_STARTMENU_NAME       61453
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        155
#define _APS_NEXT_COMMAND_VALUE         32830
#define _APS_NEXT_CONTROL_VALUE         1069
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\tlshunt.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// TlsHunt.cpp : implementation file
//

#include "stdafx.h"
#include <lm.h>
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "RtList.h"
#include "lSmgrdoc.h"
#include "LtView.h"
#include "cntdlg.h"
#include "treenode.h"
#include "ntsecapi.h"
#include "lrwizapi.h"
#include "TlsHunt.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt dialog

CTlsHunt::~CTlsHunt()
{
    if(m_hThread != NULL)
        CloseHandle(m_hThread);
}

CTlsHunt::CTlsHunt(CWnd* pParent /*=NULL*/)
    : CDialog(CTlsHunt::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTlsHunt)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hThread = NULL;
    memset(&m_EnumData, 0, sizeof(m_EnumData));
}   

void CTlsHunt::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTlsHunt)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTlsHunt, CDialog)
    //{{AFX_MSG_MAP(CTlsHunt)
    ON_WM_CREATE()
    //ON_MESSAGE(WM_DONEDISCOVERY, OnDoneDiscovery)
    ON_WM_CLOSE()
    ON_WM_CANCELMODE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

RPC_STATUS
TryGetServerName(PCONTEXT_HANDLE hBinding,
                 CString &Server);

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt message handlers

//------------------------------------------------------------------

BOOL 
CTlsHunt::ServerEnumCallBack(
    TLS_HANDLE hHandle,
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

++*/
{
    ServerEnumData* pEnumData = (ServerEnumData *)dwUserData;
    BOOL bCancel;
    DWORD dwSupportFlags = 0;

    bCancel = (InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1);
    if(bCancel == TRUE)
    {
        return TRUE;
    }

    if(pszServerName && pszServerName[0] != _TEXT('\0'))
    {
#if DBG
        OutputDebugString(pszServerName);
        OutputDebugString(L"\n");
#endif

        CString itemTxt;

        itemTxt.Format(IDS_TRYSERVER, pszServerName);

        pEnumData->pWaitDlg->SendDlgItemMessage(
                                        IDC_TLSERVER_NAME, 
                                        WM_SETTEXT, 
                                        0, 
                                        (LPARAM)(LPCTSTR)itemTxt
                                    );
    }

    if(hHandle)
    {
        DWORD dwStatus;

        if(pEnumData == NULL || pEnumData->pMainFrm == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return TRUE;
        }

        dwStatus = TLSGetSupportFlags(
                        hHandle,
                        &dwSupportFlags
                );

	    if ( ((dwStatus == RPC_S_OK) && (dwSupportFlags & SUPPORT_WHISTLER_52_CAL)) || (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE) )
	    {                       
            CString strServerName;

            dwStatus = TryGetServerName(
                                    hHandle,
                                    strServerName
                                    );

            if(dwStatus == ERROR_SUCCESS && !strServerName.IsEmpty())
            {
                pEnumData->pMainFrm->ConnectServer(strServerName);
                pEnumData->dwNumServer++;
            }
        }        
    }
    //
    // Continue enumeration
    //
    return InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1;
}


/////////////////////////////////////////////////////////////////////
DWORD WINAPI
CTlsHunt::DiscoveryThread(
    PVOID ptr
    )
/*++


++*/
{
    DWORD hResult;
    ServerEnumData* pEnumData = (ServerEnumData *)ptr;
    LPWSTR* pszEnterpriseServer = NULL;
    DWORD dwCount;
    DWORD index;
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        TLSInit();
        fInitialized = TRUE;
    }

    //
    // Look for all license server in domain
    //
    hResult = EnumerateTlsServer(
                            CTlsHunt::ServerEnumCallBack,
                            ptr,
                            3 * 1000,
                            FALSE
                        );  


    // Find enterprise server
    if(pEnumData->dwDone == 0)
    {
        hResult = GetAllEnterpriseServers(
                                        &pszEnterpriseServer,
                                        &dwCount
                                    );

        if(hResult == ERROR_SUCCESS && dwCount != 0 && pszEnterpriseServer != NULL)
        {
            TLS_HANDLE TlsHandle = NULL;

            //
            // Inform dialog
            //
            for(index = 0; index < dwCount && pEnumData->dwDone == 0; index++)
            {
                if(pszEnterpriseServer[index] == NULL)
                    continue;

                if(ServerEnumCallBack(
                                NULL, 
                                pszEnterpriseServer[index], 
                                pEnumData
                            ) == TRUE)
                {
                    continue;
                }

                TlsHandle = TLSConnectToLsServer(
                                            pszEnterpriseServer[index]
                                        );

                if(TlsHandle == NULL)
                {
                    continue;
                }


                DWORD dwVersion;
                RPC_STATUS rpcStatus;

                rpcStatus = TLSGetVersion( 
                                        TlsHandle, 
                                        &dwVersion 
                                    );

                if(rpcStatus != RPC_S_OK)
                {
                    continue;
                }

                if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
                {
                    continue;
                }

                ServerEnumCallBack(
                                TlsHandle, 
                                pszEnterpriseServer[index], 
                                pEnumData
                            );

                TLSDisconnectFromServer(TlsHandle);
            }
        } else
        {
            // Failure in GetAllEnterpriseServers

            pszEnterpriseServer = NULL;
            dwCount = 0;
        }
    }

    if(pszEnterpriseServer != NULL)
    {
        for( index = 0; index < dwCount; index ++)
        {
            if(pszEnterpriseServer[index] != NULL)
            {
                LocalFree(pszEnterpriseServer[index]);
            }
        }

        LocalFree(pszEnterpriseServer);
    }                      

    pEnumData->pWaitDlg->PostMessage(WM_DONEDISCOVERY);
    ExitThread(hResult);
    return hResult;
}


BOOL CTlsHunt::OnInitDialog() 
{
    CDialog::OnInitDialog();

    ASSERT(m_hThread != NULL);

    if(m_hThread != NULL)
    {
        ResumeThread(m_hThread);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

int CTlsHunt::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CDialog::OnCreate(lpCreateStruct) == -1)
        return -1;


    m_EnumData.pWaitDlg = this;
    m_EnumData.pMainFrm = (CMainFrame *)GetParentFrame();
    m_EnumData.dwNumServer = 0;
    m_EnumData.dwDone = 0;

    DWORD dwId;

    m_hThread = (HANDLE)CreateThread(
                                NULL, 
                                0, 
                                CTlsHunt::DiscoveryThread, 
                                &m_EnumData, 
                                CREATE_SUSPENDED, // suspended thread
                                &dwId
                            );
    
    if(m_hThread == NULL)
    {
        //
        // Can't create thread.
        //
        AfxMessageBox(IDS_CREATETHREAD);
        return -1;
    }
    
    return 0;
}

void CTlsHunt::OnCancel() 
{
    if( m_hThread != NULL && 
        WaitForSingleObject(m_hThread, 0) == WAIT_TIMEOUT )
    {
        InterlockedExchange(&(m_EnumData.dwDone), 1);

        CString txt;

        txt.LoadString(IDS_CANCELDISCOVERY);

        SendDlgItemMessage(
                        IDC_TLSERVER_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM)(LPCTSTR)txt
                    );
        
        CWnd* btn = GetDlgItem(IDCANCEL);

        ASSERT(btn);

        if(btn != NULL)
        {
            btn->EnableWindow(FALSE);
        }
    }
    else
    {
        CDialog::OnCancel();
    }
}

void CTlsHunt::OnDoneDiscovery()
{
    if(m_hThread != NULL)
    {
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    CDialog::EndDialog(0);
}

void CTlsHunt::OnClose() 
{
    if(m_hThread != NULL)
    {
        InterlockedExchange(&(m_EnumData.dwDone), 1);

        CString txt;

        txt.LoadString(IDS_CANCELDISCOVERY);

        SendDlgItemMessage(
                        IDC_TLSERVER_NAME, 
                        WM_SETTEXT, 
                        0, 
                        (LPARAM)(LPCTSTR)txt
                    );
        
        CWnd* btn = GetDlgItem(IDCANCEL);

        ASSERT(btn);

        if(btn != NULL)
        {
            btn->EnableWindow(FALSE);
        }
    }
    else
    {
        CDialog::OnClose();
    }
}

BOOL CTlsHunt::PreTranslateMessage(MSG* pMsg) 
{
    if(pMsg->message == WM_DONEDISCOVERY)
    {
        OnDoneDiscovery();
        return TRUE;
    }
    
    return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\tlshunt.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_)
#define AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TlsHunt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTlsHunt dialog
class CMainFrame;

typedef struct __ServerEnumData {
    CDialog* pWaitDlg;
    CMainFrame* pMainFrm;
    DWORD dwNumServer;
    long dwDone;
} ServerEnumData;

#define WM_DONEDISCOVERY    (WM_USER+0x666)

class CTlsHunt : public CDialog
{
    static BOOL
    ServerEnumCallBack(
        TLS_HANDLE hHandle,
        LPCTSTR pszServerName,
        HANDLE dwUserData
    );

    static DWORD WINAPI
    DiscoveryThread(PVOID ptr);

    ServerEnumData m_EnumData;
    HANDLE m_hThread;

// Construction
public:

    BOOL
    IsUserCancel() {
        return m_EnumData.dwDone;
    }

    DWORD 
    GetNumServerFound() {
        return m_EnumData.dwNumServer;
    }

	CTlsHunt(CWnd* pParent = NULL);   // standard constructor
    ~CTlsHunt();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTlsHunt)
	enum { IDD = IDD_DISCOVERY };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTlsHunt)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTlsHunt)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual void OnCancel();
	afx_msg void OnDoneDiscovery();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TLSHUNT_H__9C41393C_53C6_11D2_BDDF_00C04FA3080D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\licmgr\rtlist.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LtView.h 

Abstract:
    
    This Module defines the CRightList class (The View class  used for the
    right pane in the splitter window)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"

enum ITEM_TYPE { LICENSE , LICENSE_PACK };

// CRightList view

class CRightList : public CListView
{
protected:
    CRightList();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CRightList)

// Attributes
public:

// Operations
public:
    HRESULT SetLicenseColumns();
    HRESULT SetKeyPackColumns();
    HRESULT SetServerColumns();
    HRESULT AddKeyPackstoList(CLicServer * pServer, BOOL bRefresh = FALSE);
    void AddKeyPack(CListCtrl& ListCtrl, int index, CKeyPack * pKeyPack);
    HRESULT AddServerstoList();

    void UI_initmenu(
        CMenu *pMenu,
        NODETYPE nt
    );

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh );

    void OnServerConnect( );
    void OnRefreshAllServers( );
    void OnRefreshServer( );

    void OnDownloadKeepPack();
    void OnRegisterServer();
    void OnRepeatLastDownload();
    void OnReactivateServer( );
    void OnDeactivateServer( );

    void OnServerProperties( );
    void OnGeneralHelp( );
    void SetActiveServer( CLicServer *pServer );

    //static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, 
    //LPARAM lParamSort);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRightList)
    public:
    virtual void OnInitialUpdate();
    protected:
    virtual void OnDraw(CDC* pDC);      // overridden to draw this view
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CRightList();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
    CImageList m_ImageListLarge;
    CImageList m_ImageListSmall;
    //{{AFX_MSG(CRightList)
    afx_msg LRESULT OnSelChange(WPARAM wParam, LPARAM lParam);
    afx_msg void OnLargeIcons();
    afx_msg void OnSmallIcons();
    afx_msg void OnList();
    afx_msg void OnDetails();
    afx_msg void OnProperties();
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDeleteServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnUpdateServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLeftClick( NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt );
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RIGHTLIST_H__72451C7E_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lkplite\lkplite.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LKPLITE__H__
#define __LKPLITE__H__



//SPK Stuff
#define LKPLITE_SPK_SELECT		1
#define LKPLITE_SPK_BASIC		0
#define LKPLITE_SPK_UNKNOWN		2

#define LKPLITE_SPK_LEN				25
//SPK Masks
#define LKPLITE_SPK_SELECT_MASK		0x0000200000000000
#define LKPLITE_SPK_BASIC_MASK		0x0000000000000000
#define LKPLITE_SPK_PID_MASK		0x00001FFFFFFFFF00
#define LKPLITE_SPK_UNIQUEID_MASK	0xFFFFC00000000000


#define LKPLITE_SPK_INVALID			1
#define LKPLITE_SPK_VALID			2
#define LKPLITE_SPK_INVALID_SIGN	3
#define LKPLITE_INVALID_CONFNUM		4


//LKP Stuff
#define	LKPLITE_PROGRAM_SELECT		0x0
#define	LKPLITE_PROGRAM_MOLP		0x1
#define	LKPLITE_PROGRAM_RETAIL		0x2

#define LKPLITE_LKP_LEN				25
#define LKPLITE_LKP_INVALID			1
#define LKPLITE_LKP_VALID			2
#define LKPLITE_LKP_INVALID_SIGN	3
//LKP Masks
#define LKPLITE_LKP_PRODUCT_MASK	0xFFC0000000000000
#define LKPLITE_LKP_QUANTITY_MASK	0x003FFF0000000000
#define LKPLITE_LKP_SERAIL_NO_MASK	0x000000FFF0000000
#define	LKPLITE_LKP_PROGRAM_MASK	0x000000000C000000
#define LKPLITE_LKP_EXP_DATE_MASK	0x0000000003FC0000
#define LKPLITE_LKP_VERSION_MASK	0x000000000003F800
#define LKPLITE_LKP_UPG_FULL_MASK	0x0000000000000700


//function declarations for SPK portion of the LKPLite
DWORD LKPLiteGenSPK ( 
	LPTSTR   pszPID,			//PID for the product.  Should include the installation number
	DWORD	 dwUniqueId,		//unique Id to be put in the SPK
	short	 nSPKType,			//Can be 1 for select or 0 for BASIC
	LPTSTR * ppszSPK
	);

DWORD LKPLiteVerifySPK (
	LPTSTR	pszPID,			//PID to validate against
	LPTSTR	pszSPK,
	DWORD *	pdwVerifyResult
	);

//function declarations for LKP portion of the LKPLite
DWORD LKPLiteGenLKP (
	LPTSTR		lpszPID,				//used for encrypting the LKPLite structure
	LPTSTR		lpszProductCode,		//Product Code
	DWORD		dwQuantity,				//quantity
	DWORD		dwSerialNum,			//serail number of SPK
	DWORD		dwExpirationMos,		//expiration in number of months from today
	DWORD		dwVersion,				//version number can be upto 99
	DWORD		dwUpgrade,				//upgrade or full license
	DWORD		dwProgramType,			//SELECT,MOLP or RETAIL
	LPTSTR  *	ppszLKPLite
	);

DWORD LKPLiteVerifyLKP (
	LPTSTR		lpszPID,				//PID for verifying the LKP lite blob
	LPTSTR		pszLKPLite,				//B24 encoded LKP
	DWORD *		pdwVerifyResult
);

DWORD LKPLiteCrackLKP (
	LPTSTR		lpszPID,
	LPTSTR		pszLKPLite,
	LPTSTR		lpszProductCode,
	DWORD   *	pdwQuantity,
	DWORD   *	pdwSerialNum,
	DWORD   *	pdwExpitaitonMos,
	DWORD   *	pdwVersion,
	DWORD	*	pdwUpgrade,
	DWORD	*	pdwProgramType
);

DWORD LKPLiteEncryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength);
DWORD LKPLiteDecryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength);
DWORD LKPLiteValConfNumber(LPTSTR	lpszLSID,
						   LPTSTR	lpszPID,
					       LPTSTR	lpszConfirmation);

#endif	//__LKPLITE__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\chltype.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "licensetype.h"
#include "fonts.h"

//
// Choose license type page
//
LRW_DLG_INT CALLBACK
CustInfoLicenseType(
                   IN HWND     hwnd,   
                   IN UINT     uMsg,       
                   IN WPARAM   wParam, 
                   IN LPARAM   lParam  
                   )
{   
    DWORD   dwNextPage = 0;
    BOOL    bStatus = TRUE;
    CString sProgramName;
    int     nItem = 0;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            AddProgramChoices(hwnd, IDC_LICENSE_PROGRAM);

            CString sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;

            int nItem = LICENSE_PROGRAM_LICENSE_PAK;

            if (wcscmp(sProgramName, PROGRAM_LICENSE_PAK) == 0)
                nItem = LICENSE_PROGRAM_LICENSE_PAK;
            else if (wcscmp(sProgramName, PROGRAM_MOLP) == 0)
                nItem = LICENSE_PROGRAM_OPEN_LICENSE;
            else if (wcscmp(sProgramName, PROGRAM_SELECT) == 0)
                nItem = LICENSE_PROGRAM_SELECT;
            else if (wcscmp(sProgramName, PROGRAM_ENTERPRISE) == 0)
                nItem = LICENSE_PROGRAM_ENTERPRISE;
            else if (wcscmp(sProgramName, PROGRAM_CAMPUS_AGREEMENT) == 0)
                nItem = LICENSE_PROGRAM_CAMPUS;
            else if (wcscmp(sProgramName, PROGRAM_SCHOOL_AGREEMENT) == 0)
                nItem = LICENSE_PROGRAM_SCHOOL;
            else if (wcscmp(sProgramName, PROGRAM_APP_SERVICES) == 0)
                nItem = LICENSE_PROGRAM_APP_SERVICES;
            else if (wcscmp(sProgramName, PROGRAM_OTHER) == 0)
                nItem = LICENSE_PROGRAM_OTHER;

            ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_LICENSE_PROGRAM), nItem);

            LICENSE_PROGRAM licProgram;
            licProgram = GetLicenseProgramFromProgramName(sProgramName);
            UpdateProgramControls(hwnd, licProgram);
        }
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == CBN_SELCHANGE) {

            LICENSE_PROGRAM licProgram;
            nItem = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_LICENSE_PROGRAM));
            if (nItem == CB_ERR)
                nItem = LICENSE_PROGRAM_LICENSE_PAK;
            sProgramName = GetProgramNameFromComboIdx(nItem);
            licProgram = GetLicenseProgramFromProgramName(sProgramName);

            UpdateProgramControls(hwnd, licProgram);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch ( pnmh->code ) {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
                nItem = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_LICENSE_PROGRAM));
                if (nItem == CB_ERR)
                    nItem = LICENSE_PROGRAM_LICENSE_PAK;

                sProgramName = GetProgramNameFromComboIdx(nItem);
                GetGlobalContext()->GetContactDataObject()->sProgramName = sProgramName;

                // Check the Certificate is valid for the Selected Program
                if (!CheckProgramValidity(GetGlobalContext()->GetContactDataObject()->sProgramName)) {
                    LRMessageBox(hwnd,IDS_ERR_CERT_NOT_ENOUGH,IDS_WIZARD_MESSAGE_TITLE);
                    dwNextPage = IDD_LICENSETYPE;
                } else {
                    //
                    // Choose the license entry dialog based on the license
                    // type selected
                    //
                    if (sProgramName == PROGRAM_LICENSE_PAK) {
                        dwNextPage = IDD_DLG_RETAILSPK;
                    } else {
                        dwNextPage = IDD_DLG_ENTER_LIC;
                    }
                }

                GetGlobalContext()->SetInRegistry(szOID_BUSINESS_CATEGORY, GetGlobalContext()->GetContactDataObject()->sProgramName);

                LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                bStatus = -1;

                if (dwNextPage != IDD_LICENSETYPE) {
                    LRPush(IDD_LICENSETYPE);
                }

                break;

            case PSN_WIZBACK:
                dwNextPage = LRPop();
                LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

//
// Enter license proc - for select type (one number) and MOLP
//
LRW_DLG_INT CALLBACK
EnterCustomLicenseProc(
                      IN HWND     hwnd,   
                      IN UINT     uMsg,       
                      IN WPARAM   wParam, 
                      IN LPARAM   lParam  
                      )
{   
    DWORD   dwNextPage = 0;
    BOOL    bStatus = TRUE;
    CString sProgramName;
    int     nItem = 0;
    DWORD   dwRetCode;
    LPTSTR  lpVal = NULL;
    CString sLicenseNumber;
    CString sAuthorizationNumber;
    BOOL    fIsMOLP = FALSE;


    switch (uMsg) {
    case WM_INITDIALOG:
        {
            CString sProgramName;
            LICENSE_PROGRAM licProgram;

            sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;
            licProgram = GetLicenseProgramFromProgramName(sProgramName);
            UpdateProgramControls(hwnd, licProgram);
        }
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch ( pnmh->code ) {
            case PSN_SETACTIVE:                
                {
                    TCHAR   szMsg[LR_MAX_MSG_TEXT];
                    DWORD dwStringId;
                    CString sProgramName;

                    sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;
                    dwStringId = GetStringIDFromProgramName(sProgramName);
                    LoadString(GetInstanceHandle(), dwStringId, szMsg, LR_MAX_MSG_TEXT);
                    SetDlgItemText(hwnd, IDC_LICENSE_PROGRAM_STATIC, szMsg);
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);

                    LICENSE_PROGRAM licProgram;
                    licProgram = GetLicenseProgramFromProgramName(sProgramName);
                    UpdateProgramControls(hwnd, licProgram);
                    break;
                }

            case PSN_WIZNEXT:


                // Check the Certificate is valid for the Selected Program
                if (!CheckProgramValidity(GetGlobalContext()->GetContactDataObject()->sProgramName)) {
                    LRMessageBox(hwnd,IDS_ERR_CERT_NOT_ENOUGH,IDS_WIZARD_MESSAGE_TITLE);
                    dwNextPage = IDD_LICENSETYPE;
                    goto NextDone;
                }

                sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;

                fIsMOLP = (sProgramName == PROGRAM_MOLP);

                //
                // FIXFIX do we need these two calls, they didn't appear in CHRegister.
                //
                GetGlobalContext()->SetInRegistry(
                                        szOID_BUSINESS_CATEGORY,
                                        GetGlobalContext()->GetContactDataObject()->sProgramName);
                //There's a lot of overhead in this call, but we need the license type
                //to be written into the global contact info structure
                GetGlobalContext()->InitGlobal();

                //
                // Get the license number
                //
                if (fIsMOLP) {
                    lpVal = sLicenseNumber.GetBuffer(CH_MOLP_AGREEMENT_NUMBER_LEN+1);
                    GetDlgItemText(hwnd,IDC_PROGRAM_LICENSE_NUMBER,lpVal,CH_MOLP_AGREEMENT_NUMBER_LEN+1);
                    sLicenseNumber.ReleaseBuffer(-1);

                    lpVal = sAuthorizationNumber.GetBuffer(CH_MOLP_AUTH_NUMBER_LEN+1);
                    GetDlgItemText(hwnd,IDC_PROGRAM_AUTHORIZATION_NUMBER,lpVal,CH_MOLP_AUTH_NUMBER_LEN+1);
                    sAuthorizationNumber.ReleaseBuffer(-1);
                } else {
                    lpVal = sLicenseNumber.GetBuffer(CH_SELECT_ENROLLMENT_NUMBER_LEN+1);
                    GetDlgItemText(hwnd,IDC_PROGRAM_SINGLE_LICNUMBER,lpVal,CH_SELECT_ENROLLMENT_NUMBER_LEN+1);
                    sLicenseNumber.ReleaseBuffer(-1);
                }

                sLicenseNumber.TrimLeft(); sLicenseNumber.TrimRight();
                sAuthorizationNumber.TrimLeft(); sAuthorizationNumber.TrimRight();

                if (
                   sLicenseNumber.IsEmpty()                                ||
                   (sAuthorizationNumber.IsEmpty() && fIsMOLP)) {
                    LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);    
                    dwNextPage  = IDD_DLG_ENTER_LIC;
                    goto NextDone;
                }

                if (
                   !ValidateLRString(sLicenseNumber)   ||
                   !ValidateLRString(sAuthorizationNumber)
                   ) {
                    LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
                    dwNextPage = IDD_DLG_ENTER_LIC;
                    goto NextDone;
                }

                //
                // All the other fields get filled on the next
                // dlg page (the quantity page)
                //
                if (fIsMOLP) {
                    GetGlobalContext()->GetLicDataObject()->sMOLPAgreementNumber    = sLicenseNumber;
                    GetGlobalContext()->GetLicDataObject()->sMOLPAuthNumber         = sAuthorizationNumber;
                } else {
                    GetGlobalContext()->GetLicDataObject()->sSelEnrollmentNumber    = sLicenseNumber;
                    GetGlobalContext()->GetLicDataObject()->sSelMastAgrNumber       = "";
                }

                dwNextPage = IDD_CH_REGISTER;
                LRPush(IDD_DLG_ENTER_LIC);
                NextDone:
                LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                bStatus = -1;                   
                break;

            case PSN_WIZBACK:
                DWORD dwNextPage;
                dwNextPage = LRPop();
                LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lkplite\lkplite.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-2000 Microsoft Corporation
//
// File:
//
// Contents:
//
// History:
//
//---------------------------------------------------------------------------

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0400
#endif
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "Shortsig.h"
#include "base24.h"
#include "lkplite.h"
#include "rc4.h"
#include "md5.h"

//internal functions
#define LKPLITE_PID_LEN					_tcslen(_TEXT("12345-123-1234567-12345"))

#define SIGNATURE_LEN	104

#define LKPLITE_PID_FIRSTCOPYOFFSET		10
#define LKPLITE_PID_SECONDCOPYOFFSET	18
#define LKPLITE_SPK_BITSTUFF			0x00000000000000FF

#define LKPLITE_RAWDATALEN				20

DWORD	ValidatePID ( LPTSTR lpszPID );
__int64 GetSPKIDFromPID ( LPTSTR lpszPID );


BYTE abLKPPublicKey0[] =
{
	0x6c, 0x01, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xb7, 0x1e, 
	0x79, 0x64, 0xae, 0xdf, 0x30, 0x01, 0x0c, 0x00, 0x00, 0x00, 
	0x23, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0xf1, 0x89, 
	0x3e, 0xb9, 0x7f, 0x5e, 0xc9, 0x40, 0x4f, 0x0d, 0x64, 0x2c, 
	0x9e, 0x1c, 0x5b, 0xd7, 0x43, 0xb3, 0x51, 0x59, 0x27, 0x81, 
	0xfb, 0x16, 0x86, 0xa7, 0xb5, 0x9d, 0x89, 0xdb, 0x52, 0xf6, 
	0x3e, 0x95, 0xc9, 0x4c, 0x7b, 0x34, 0x54, 0x01, 0xab, 0x3c, 
	0x10, 0xb9, 0x35, 0x40, 0x64, 0xba, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x39, 0x4d, 0x13, 0xde, 0xe2, 0xc9, 0x68, 0xb5, 
	0xef, 0x45, 0x67, 0x94, 0xde, 0x01, 0xdd, 0x35, 0x56, 0x30, 
	0x7b, 0xcd, 0xbc, 0xd5, 0x88, 0x77, 0xee, 0xf9, 0x5d, 0xa1, 
	0xaf, 0xab, 0xc2, 0xdf, 0xf8, 0x6c, 0x8c, 0x3d, 0xce, 0x4d, 
	0xab, 0x27, 0x6b, 0xcc, 0x64, 0x77, 0x8b, 0xbd, 0x71, 0x7b, 
	0xdd, 0x93, 0x05, 0xe5, 0xeb, 0xf1, 0xe0, 0x7c, 0xe8, 0x35, 
	0x0d, 0x4e, 0x31, 0x22, 0x23, 0x42, 0xaf, 0x33, 0x9f, 0x72, 
	0xda, 0xc9, 0x77, 0xa6, 0xe9, 0xcf, 0xac, 0x26, 0xe0, 0xb7, 
	0x6e, 0x50, 0xbb, 0x32, 0x71, 0x35, 0x32, 0xc2, 0x41, 0xdf, 
	0x76, 0x24, 0xbe, 0xdf, 0x4a, 0x90, 0xff, 0x2e, 0xdc, 0x16, 
	0x02, 0x6c, 0xd0, 0x85, 0xf5, 0xdd, 0xf0, 0x0d, 0xe6, 0x01, 
	0x75, 0x05, 0x75, 0x87, 0x3b, 0xb6, 0xc8, 0x51, 0x7f, 0x66, 
	0xcd, 0x2b, 0x52, 0x0b, 0x09, 0xec, 0xa5, 0x4a, 0xdf, 0x2b, 
	0xf0, 0xbd, 0x0e, 0x83, 0x2f, 0xa9, 0xbb, 0xde, 0x43, 0x6e, 
	0x4f, 0x38, 0x13, 0xa3, 0x70, 0x2e, 0x5e, 0x7f, 0xf2, 0x84, 
	0xaa, 0xfe, 0x12, 0x7d, 0x4e, 0x17, 0xad, 0x7a, 0x3c, 0x05, 
	0x40, 0x92, 0xf8, 0x34, 0x97, 0x43, 0x88, 0x93, 0xf1, 0x78, 
	0xe4, 0xe9, 0xe6, 0x4c, 0x2d, 0xf9, 0xcf, 0xf8, 0xb5, 0x34, 
	0x8c, 0x98, 0x56, 0x8d, 0x89, 0x9d, 0x34, 0xf5, 0xfa, 0xb6, 
	0x78, 0xfa, 0x5a, 0x85
};



BYTE abLSIDPublicKey0[] =
{
	0x6c,  0x01,  0x00,  0x00,  0x07,  0x00,  0x00,  0x00,  0x83,  0xa1,  
	0xc9,  0xb1,  0xae,  0xdf,  0x30,  0x01,  0x0c,  0x00,  0x00,  0x00,  
	0x23,  0x00,  0x00,  0x00,  0x45,  0x00,  0x00,  0x00,  0x31,  0x07,  
	0xcb,  0x01,  0x1e,  0x92,  0x74,  0x0b,  0x1e,  0x2b,  0x2d,  0x07,  
	0x68,  0xc5,  0xff,  0x21,  0xc5,  0x5c,  0x32,  0xb6,  0x44,  0xdb,  
	0x02,  0x09,  0xde,  0x2e,  0xc6,  0x6d,  0xb5,  0xc4,  0xd4,  0x44,  
	0x6f,  0xc7,  0x0d,  0xba,  0x4e,  0xe5,  0x0b,  0x0f,  0x92,  0xb1,  
	0x22,  0x25,  0xab,  0xdd,  0x86,  0x8d,  0x01,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  
	0x00,  0x00,  0xdb,  0x86,  0x67,  0xfb,  0x5c,  0x8c,  0x53,  0x72,  
	0x0e,  0x49,  0x94,  0x97,  0x94,  0x15,  0xfc,  0x25,  0x0d,  0xdd,  
	0xa1,  0xe4,  0xa0,  0xf0,  0xc3,  0x17,  0xf6,  0x98,  0xce,  0x9c,  
	0x07,  0x31,  0x10,  0xb7,  0x73,  0x16,  0x4f,  0x91,  0xbb,  0xfa,  
	0x01,  0xde,  0x9e,  0x79,  0xf2,  0x66,  0x58,  0xf5,  0x77,  0x45,  
	0x55,  0xf0,  0xa8,  0xb8,  0x0c,  0x2c,  0x0f,  0x15,  0xc7,  0x28,  
	0xce,  0x81,  0x69,  0x4e,  0x55,  0xd5,  0xf3,  0x89,  0xdc,  0x11,  
	0x34,  0x09,  0x40,  0x94,  0x5c,  0xaa,  0xd0,  0x6a,  0x5a,  0x06,  
	0x8e,  0x62,  0x6e,  0x5f,  0x7e,  0x35,  0x44,  0x5f,  0x06,  0xb2,  
	0xa5,  0xe8,  0x3c,  0x1b,  0x4d,  0xb8,  0xc6,  0x5e,  0xe0,  0xe4,  
	0xa6,  0xac,  0x80,  0xef,  0x8c,  0x99,  0x23,  0x06,  0x70,  0xd6,  
	0x6c,  0x62,  0x01,  0xb6,  0xde,  0x3b,  0x0c,  0x5e,  0x2a,  0x96,  
	0x9e,  0x63,  0x58,  0x9f,  0xdf,  0xf1,  0xaf,  0x5d,  0x02,  0xb6,  
	0x84,  0xc1,  0x52,  0x1f,  0xbc,  0xb8,  0x0c,  0x72,  0x3c,  0x1b,  
	0xb4,  0x58,  0x51,  0xab,  0x73,  0x19,  0x65,  0xbb,  0xc6,  0xb4,  
	0xb2,  0x53,  0xeb,  0x17,  0x4c,  0x42,  0xc9,  0xc2,  0xcd,  0x7f,  
	0x88,  0x0f,  0xb8,  0xaa,  0xc4,  0xca,  0xaa,  0xe0,  0xa0,  0xe1,  
	0x5f,  0xdb,  0x6e,  0xb8,  0x26,  0xf9,  0x8d,  0x4a,  0xe7,  0xdb,  
	0x1e,  0xdc,  0xc7,  0xdf,  0xf0,  0x35,  0x88,  0xec,  0x1d,  0xbe,  
	0xab,  0xa4,  0x8d,  0x39  
};


DWORD LKPLiteVerifySPK (
	LPTSTR	pszPID,			//PID to validate against
	LPTSTR	pszSPK,	
	DWORD *	pdwVerifyResult
	)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedSPK = NULL;
	__int64		n64SPK = 0;
	__int64		n64SPKPID =0;
	__int64		n64SPKVerifyPID =0;
	
	//common validations
	if ( NULL == pszPID || NULL == pszSPK || 
		 NULL == pdwVerifyResult )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}

	if ((dwRetCode = ValidatePID ( pszPID ))!= ERROR_SUCCESS)
	{
		goto done;
	}

	//now decode the stuff comming in 
	//base24 expects a string so we need to do this conversion

	
	dwRetCode =  B24DecodeMSID(pszSPK , &pbDecodedSPK);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}


	dwRetCode = LKPLiteDecryptUsingPID(pszPID,
									   pbDecodedSPK,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}
	
	//Call function to verify signature on SPK
	dwRetCode = CryptVerifySig(7, pbDecodedSPK, sizeof(abLSIDPublicKey0),
							   abLSIDPublicKey0, SIGNATURE_LEN, pbDecodedSPK+7);
	if (dwRetCode != SS_OK)
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
		goto done;
	}

	
	memcpy ( ((BYTE *) &n64SPK) + 1, pbDecodedSPK, sizeof(n64SPK) -1 );

	//now get the contents of SPK and then see if it matches with
	//the PID passed in
	//extract bits 	20 - 56 and then move them right 8 bits
	n64SPKPID = n64SPK & LKPLITE_SPK_PID_MASK;
	n64SPKPID >>= 8;
	n64SPKVerifyPID = GetSPKIDFromPID ( pszPID );
	if ( n64SPKVerifyPID != n64SPKPID )
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
	}
	else
	{
		*pdwVerifyResult = LKPLITE_SPK_VALID;
	}
	
done:
	if ( pbDecodedSPK )
		HeapFree (GetProcessHeap(),0,pbDecodedSPK );
	return dwRetCode;
}


//This function has to verify the LKP by decrypting it
//and matching the signature
DWORD LKPLiteVerifyLKP (
	LPTSTR		lpszPID,				//PID for verifying the LKP lite blob
	LPTSTR		pszLKPLite,				//B24 encoded LKP
	DWORD *		pdwVerifyResult
)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedLKP = NULL;
	*pdwVerifyResult = LKPLITE_LKP_VALID;

	//decode the SPK here
	dwRetCode =  B24DecodeMSID(pszLKPLite, &pbDecodedLKP);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}

	dwRetCode = LKPLiteDecryptUsingPID(lpszPID,
									   pbDecodedLKP,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//Call function to verify signature on SPK
	dwRetCode = CryptVerifySig(7, pbDecodedLKP, sizeof(abLKPPublicKey0),
							   abLKPPublicKey0, SIGNATURE_LEN, pbDecodedLKP+7);
	if (dwRetCode != SS_OK)
	{
		*pdwVerifyResult = LKPLITE_SPK_INVALID;
	}
	
done:	
	if (pbDecodedLKP != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedLKP);
	}

	return dwRetCode;
}


DWORD LKPLiteCrackLKP (
	LPTSTR		lpszPID,
	LPTSTR		pszLKPLite,
	LPTSTR		lpszProductCode,
	DWORD   *	pdwQuantity,
	DWORD   *	pdwSerialNum,
	DWORD   *	pdwExpirationMos,
	DWORD   *	pdwVersion,
	DWORD	*	pdwUpgrade,
	DWORD	*	pdwProgramType
)
{
	DWORD		dwRetCode = ERROR_SUCCESS;
	PBYTE		pbDecodedLKP = NULL;
	__int64		n64LKPLite = 0;
	__int64		n64ProductCode = 0;
	__int64		n64Qty = 0;
	__int64		n64SerialNo = 0;
	__int64		n64dtOfExp = 0;
	__int64		n64Version = 0;
	__int64		n64Upgrade = 0;
	__int64		n64Program = 0;

	if ( NULL == lpszPID || NULL == pszLKPLite ||
		 NULL == lpszProductCode || NULL == pdwQuantity || 
		 NULL == pdwSerialNum || NULL == pdwExpirationMos || 
		 NULL == pdwVersion || NULL == pdwUpgrade ||
		 NULL == pdwProgramType || NULL == pdwProgramType
	   )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
		goto done;
	}

	//decode and decrypt the lkp here

	dwRetCode =  B24DecodeMSID(pszLKPLite, &pbDecodedLKP);
	if ( ERROR_SUCCESS != dwRetCode )
	{
		goto done;
	}

	dwRetCode = LKPLiteDecryptUsingPID(lpszPID,
									   pbDecodedLKP,
									   LKPLITE_RAWDATALEN);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	//copy all the stuff into int64 type

	memcpy ( ((BYTE *) &n64LKPLite) + 1, pbDecodedLKP, sizeof(n64LKPLite ) - 1 );

	// Decrypt it using the PID
	n64ProductCode = n64LKPLite & LKPLITE_LKP_PRODUCT_MASK;
	n64ProductCode  >>= 54;

	//move the quantity to position 
	n64Qty = n64LKPLite & LKPLITE_LKP_QUANTITY_MASK;
	n64Qty >>= 40;
	
	//move Serial number into position
	n64SerialNo = n64LKPLite & LKPLITE_LKP_SERAIL_NO_MASK;
	n64SerialNo >>= 28;
	
	//move Program Type into position
	n64Program	= n64LKPLite & LKPLITE_LKP_PROGRAM_MASK;
	n64Program	>>= 26;

	//move dt of expitration into position
	n64dtOfExp = n64LKPLite & LKPLITE_LKP_EXP_DATE_MASK;
	n64dtOfExp >>= 18;
	
	//move Version into place
	n64Version = n64LKPLite & LKPLITE_LKP_VERSION_MASK;
	n64Version >>= 11;
	
	//move upgrade in place
	n64Upgrade = n64LKPLite & LKPLITE_LKP_UPG_FULL_MASK;
	n64Upgrade >>= 8;

done:

	if ( ERROR_SUCCESS == dwRetCode )
	{
		_stprintf(lpszProductCode, _T("%03d"), n64ProductCode);
//		_i64tot ( n64ProductCode, lpszProductCode, 10 );
		*pdwQuantity = (DWORD)n64Qty;
		*pdwSerialNum = (DWORD)n64SerialNo;
		*pdwExpirationMos = (DWORD)n64dtOfExp;
		*pdwVersion = (DWORD)n64Version;
		*pdwUpgrade = (DWORD)n64Upgrade;
		*pdwProgramType = (DWORD)n64Program;
	}
	if ( pbDecodedLKP )
		HeapFree ( GetProcessHeap(),0, pbDecodedLKP );

	return dwRetCode;
}



//internal functions
DWORD ValidatePID ( LPTSTR lpszPID )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwPIDLen = _tcslen( lpszPID );
	DWORD	dwCounter =0;

	if (  dwPIDLen != LKPLITE_PID_LEN )
	{
		dwRetCode = ERROR_INVALID_PARAMETER;
	}
	else
	{
		//check for syntax
		for ( dwCounter = 0; dwCounter < dwPIDLen; dwCounter ++ )
		{
			if ( !_istdigit ( *(lpszPID + dwCounter ) ) )
			{
				switch(dwCounter)
				{
				case 5:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 6:
					if (*(lpszPID + dwCounter ) != _T('O') && *(lpszPID + dwCounter ) != _T('o') )					
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 7:
					if (*(lpszPID + dwCounter ) != _T('E') && *(lpszPID + dwCounter ) != _T('e') )					
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 8:
					if (*(lpszPID + dwCounter ) != _T('M') && *(lpszPID + dwCounter ) != _T('m') )					
						dwRetCode = ERROR_INVALID_PARAMETER;												
					break;
				case 9:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				case 17:
					if (*(lpszPID + dwCounter ) != _T('-') )
						dwRetCode = ERROR_INVALID_PARAMETER;
					break;
				default:				
					dwRetCode = ERROR_INVALID_PARAMETER;
				}
			}
            else
            {
                switch(dwCounter)
                {
                    case 5:
                    case 9:
                    case 17:
                        dwRetCode = ERROR_INVALID_PARAMETER;
                        break;
                }
            }
		}
	}
	//can check here for mod 7 thing too but for now assume its OK.
	return dwRetCode;
}

//Assume that the PID comming in has aleady been validated
__int64 GetSPKIDFromPID ( LPTSTR lpszPID )
{
	__int64 n64PID;
	TCHAR	szPID[12] = {0};
	
	memcpy ( szPID, lpszPID + 10, 6 * sizeof(TCHAR));
	memcpy ( szPID + 6, lpszPID+ 18, 5 * sizeof(TCHAR));
	n64PID = _ttoi64(szPID);
	return n64PID;
}


DWORD LKPLiteValConfNumber(LPTSTR	lpszLSID,
					   	   LPTSTR	lpszPID,
					       LPTSTR	lpszConfirmation)
{
	BYTE * pbDecodedLSID = NULL;
	BYTE * pbDecodedConf = NULL;
	DWORD dwRetCode = ERROR_SUCCESS;

	// lpszLSID is base 24 encoded, so decode it first
	dwRetCode = B24DecodeMSID(lpszLSID, &pbDecodedLSID);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Decode Confirmation Number
	dwRetCode = B24DecodeCNumber(lpszConfirmation, &pbDecodedConf);
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	// Decrypt the leading 4 bytes 
	dwRetCode = LKPLiteDecryptUsingPID(lpszPID, pbDecodedConf, sizeof(DWORD));
	if (dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}


	if (memcmp(pbDecodedLSID, pbDecodedConf, sizeof(DWORD)) != 0)
	{
		// does not match
		dwRetCode = LKPLITE_INVALID_CONFNUM;
	}
	
done:
	if (pbDecodedLSID)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedLSID);
	}

	if (pbDecodedConf)
	{
		HeapFree(GetProcessHeap(), 0, pbDecodedConf);
	}

	return dwRetCode;
}


/////////////////////////////////////////////////////////

DWORD WINAPI
EncryptDecryptData(
    IN PBYTE pbParm,
    IN DWORD cbParm,
    IN OUT PBYTE pbData,
    IN DWORD cbData
    )
/*++

Abstract:

    Internal routine to encrypt/decrypt a blob of data

Parameter:

    pbParm : binary blob to generate encrypt/decrypt key.
    cbParm : size of binary blob.
    pbData : data to be encrypt/decrypt.
    cbData : size of data to be encrypt/decrypt.

Returns:

    ERROR_SUCCESS or error code.

Remark:


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    MD5_CTX md5Ctx;
    RC4_KEYSTRUCT rc4KS;
    BYTE key[16];
    int i;

    if(NULL == pbParm || 0 == cbParm)
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }

    MD5Init(&md5Ctx);
    MD5Update(
            &md5Ctx,
            pbParm,
            cbParm
        );

    MD5Final(&md5Ctx);

    memset(key, 0, sizeof(key));

    for(i=0; i < 5; i++)
    {
        key[i] = md5Ctx.digest[i];
    }        

    //
    // Call RC4 to encrypt/decrypt data
    //
    rc4_key(
            &rc4KS, 
            sizeof(key), 
            key 
        );

    rc4(&rc4KS, cbData, pbData);

	return dwRetCode;
}

DWORD LKPLiteEncryptUsingPID(LPTSTR lpszPID,
							 BYTE * pbBufferToEncrypt,
							 DWORD dwLength)
{
	DWORD dwRetCode = ERROR_SUCCESS;

#if 1

    dwRetCode = EncryptDecryptData(
                                (PBYTE) lpszPID,
                                lstrlen(lpszPID)*sizeof(TCHAR),
                                pbBufferToEncrypt,
                                dwLength
                            );


#else

	BOOL bRet;
	HCRYPTPROV hProv = NULL;
	HCRYPTKEY hCKey = NULL;
	HCRYPTHASH hHash = NULL;

	bRet = CryptAcquireContext(&hProv,
							   NULL,
							   NULL,
							   PROV_RSA_FULL,
							   CRYPT_VERIFYCONTEXT);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}


	bRet = CryptCreateHash(hProv,
						   CALG_MD5,
						   0,
						   0,
						   &hHash);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptHashData(hHash,
						 (BYTE *) lpszPID,
						 lstrlen(lpszPID)*sizeof(TCHAR),
						 0);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDeriveKey(hProv,
						  CALG_RC4,
						  hHash,
						  0,
						  &hCKey);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptEncrypt(hCKey,
						0,
						TRUE,
						0,
						pbBufferToEncrypt,
						&dwLength,
						dwLength);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

done:
	if (hCKey != NULL)
	{
		bRet = CryptDestroyKey(hCKey);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hHash != NULL)
	{
		bRet = CryptDestroyHash(hHash);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hProv != NULL)
	{
		bRet = CryptReleaseContext( hProv, 0 );

		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

#endif

	return dwRetCode;
}





DWORD LKPLiteDecryptUsingPID(LPTSTR lpszPID,
				 			 BYTE * pbBufferToDecrypt,
							 DWORD dwLength)
{
	DWORD dwRetCode = ERROR_SUCCESS;

#if 1

    dwRetCode = EncryptDecryptData(
                                (PBYTE) lpszPID,
                                lstrlen(lpszPID)*sizeof(TCHAR),
                                pbBufferToDecrypt,
                                dwLength
                            );
#else

	BOOL bRet;
	HCRYPTPROV hProv = NULL;
	HCRYPTKEY hCKey = NULL;
	HCRYPTHASH hHash = NULL;

	bRet = CryptAcquireContext(&hProv,
							   NULL,
							   NULL,
							   PROV_RSA_FULL,
							   CRYPT_VERIFYCONTEXT);

	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}


	bRet = CryptCreateHash(hProv,
						   CALG_MD5,
						   0,
						   0,
						   &hHash);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptHashData(hHash,
						 (BYTE *) lpszPID,
						 lstrlen(lpszPID)*sizeof(TCHAR),
						 0);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDeriveKey(hProv,
						  CALG_RC4,
						  hHash,
						  0,
						  &hCKey);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

	bRet = CryptDecrypt(hCKey,
						0,
						TRUE,
						0,
						(BYTE *) pbBufferToDecrypt,
						&dwLength);
	if (!bRet)
	{
		dwRetCode = GetLastError();
		goto done;
	}

done:
	if (hCKey != NULL)
	{
		bRet = CryptDestroyKey(hCKey);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hHash != NULL)
	{
		bRet = CryptDestroyHash(hHash);
		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

	if (hProv != NULL)
	{
		bRet = CryptReleaseContext( hProv, 0 );

		if (!bRet)
		{
			dwRetCode = GetLastError();
		}
	}

#endif

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lkplite\base24.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef _BASE24_H_
#define _BASE24_H_

#include <windows.h>

extern DWORD B24EncodeMSID(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeMSID(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);


extern DWORD B24EncodeCNumber(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeCNumber(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);


extern DWORD B24EncodeSPK(LPBYTE pbDataToEncode, TCHAR **pbEncodedData);
extern DWORD B24DecodeSPK(TCHAR * pbEncodedData, LPBYTE * pbDecodedData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\chmolp.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"

LRW_DLG_INT CALLBACK
CHRegisterMOLPDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage(hwnd, IDC_TXT_AUTH_NUMBER,		EM_SETLIMITTEXT, CH_MOLP_AUTH_NUMBER_LEN	,0);		
		SendDlgItemMessage(hwnd, IDC_TXT_AGREEMENT_NUMBER,	EM_SETLIMITTEXT, CH_MOLP_AGREEMENT_NUMBER_LEN,0);
		SendDlgItemMessage(hwnd, IDC_TXT_QUANTITY,			EM_SETLIMITTEXT, CH_QTY_LEN,0);
		
		//
		//Set the properties of the up-down control
		//
		SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETBUDDY, (WPARAM)(HWND)GetDlgItem(hwnd,IDC_TXT_QUANTITY),(LPARAM)0);
		SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0,(LPARAM) MAKELONG (9999, 1));
		

		PopulateProductComboBox(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), PRODUCT_VERSION_UNDEFINED);
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString sProductCode;
					CString sProduct;
					CString sAgreementNumber;
					CString sAuthNo;
					CString sQuantity;
					LPTSTR  lpVal = NULL;
					TCHAR   lpBuffer[ 128];
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sAgreementNumber.GetBuffer(CH_MOLP_AGREEMENT_NUMBER_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_AGREEMENT_NUMBER,lpVal,CH_MOLP_AGREEMENT_NUMBER_LEN+1);
					sAgreementNumber.ReleaseBuffer(-1);

					lpVal = sAuthNo.GetBuffer(CH_MOLP_AUTH_NUMBER_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_AUTH_NUMBER,lpVal,CH_MOLP_AUTH_NUMBER_LEN+1);
					sAuthNo.ReleaseBuffer(-1);
					
					lpVal = sQuantity.GetBuffer(CH_QTY_LEN+2);
					GetDlgItemText(hwnd,IDC_TXT_QUANTITY, lpBuffer,CH_QTY_LEN+2);
					TCHAR *lpStart = lpBuffer;
					do 
					{
						if (*lpStart != (TCHAR) ',')
						{
							*lpVal++ = *lpStart;
						}
					} while ( *lpStart++ );

					sQuantity.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));

					lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), nCurSel, lpVal);
					sProduct.ReleaseBuffer(-1);

					// Send Product Code instead of Desc -- 01/08/99
					lpVal = sProductCode.GetBuffer(16);
					GetProductCode(sProduct,lpVal);
					sProductCode.ReleaseBuffer(-1);

					sProductCode.TrimLeft();		sProductCode.TrimRight();
					sAgreementNumber.TrimLeft();	sAgreementNumber.TrimRight();
					sAuthNo.TrimLeft();				sAuthNo.TrimRight();
					sQuantity.TrimLeft();			sQuantity.TrimRight();					
					

					if(
						sProduct.IsEmpty()			||
						sAgreementNumber.IsEmpty()	||
						sAuthNo.IsEmpty()			||
						sQuantity.IsEmpty()									
					   )
					{
                        LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage	= IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					if(
						!ValidateLRString(sProduct)			||
						!ValidateLRString(sAgreementNumber)	||
						!ValidateLRString(sAuthNo)
					  )
						
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					if(_wtoi(sQuantity) < 1)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_QTY,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage	= IDD_CH_REGISTER_MOLP;
						goto NextDone;
					}

					GetGlobalContext()->GetLicDataObject()->sMOLPProductType		= sProductCode; //sProduct;
					GetGlobalContext()->GetLicDataObject()->sMOLPProductDesc		= sProduct;
					GetGlobalContext()->GetLicDataObject()->sMOLPAgreementNumber	= sAgreementNumber;
					GetGlobalContext()->GetLicDataObject()->sMOLPAuthNumber			= sAuthNo;
					GetGlobalContext()->GetLicDataObject()->sMOLPQty				= sQuantity;

//					dwNextPage = IDD_PROCESSING;
                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_CH_REGISTER_MOLP);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\chregister.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
// chregister.cpp:
//  Enter product version/type and license quantity wizard page
//

#include "precomp.h"
#include "licensetype.h"
#include "fonts.h"

#define MAX_PRODUCT_VERSION_LENGTH 64

BOOL IsMOLPSelected(HWND hDialog)
{
    BOOL bMOLPSelected = FALSE;

    TCHAR sLicenseType[64];
    TCHAR sMOLPLicenseType[128];
    GetWindowText(GetDlgItem(hDialog, IDC_CH_LICENSE_TYPE), sLicenseType, sizeof(sLicenseType)/sizeof(TCHAR));
	LoadString(GetInstanceHandle(),IDS_PROGRAM_OPEN_LICENSE,sMOLPLicenseType,sizeof(sMOLPLicenseType)/sizeof(TCHAR));
    bMOLPSelected = (wcscmp(sLicenseType, sMOLPLicenseType) == 0);

    return bMOLPSelected;
}

void SetProductTypeExplanationText(HWND hDialog)
{
	LPTSTR  lpVal = NULL;					

    int nCurSel = 0;
	nCurSel = ComboBox_GetCurSel(GetDlgItem(hDialog,IDC_CH_PRODUCT_TYPE));

    CString sProduct;
    lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
	ComboBox_GetLBText(GetDlgItem(hDialog,IDC_CH_PRODUCT_TYPE), nCurSel, lpVal);
	sProduct.ReleaseBuffer(-1);

    DWORD dwProductExpID = 0;
    TCHAR sResourceProductText[128];
	LPTSTR	szDelimiter = (LPTSTR)L":";
    LoadString(GetInstanceHandle(), IDS_PRODUCT_W2K_CLIENT_ACCESS, sResourceProductText, 128);
    if (wcscmp(_tcstok(sResourceProductText,szDelimiter), sProduct) == 0)
            dwProductExpID = IDS_PRODUCT_TYPE_EXP_W2K_CLIENT;
    LoadString(GetInstanceHandle(), IDS_PRODUCT_W2K_INTERNET_CONNECTOR, sResourceProductText, 128);
    if (wcscmp(_tcstok(sResourceProductText,szDelimiter), sProduct) == 0)
            dwProductExpID = IDS_PRODUCT_TYPE_EXP_W2K_IC;
    LoadString(GetInstanceHandle(), IDS_PRODUCT_WHISTLER_PER_SEAT, sResourceProductText, 128);
    if (wcscmp(_tcstok(sResourceProductText,szDelimiter), sProduct) == 0)
            dwProductExpID = IDS_PRODUCT_TYPE_EXP_WHISTLER_PER_SEAT;
    LoadString(GetInstanceHandle(), IDS_PRODUCT_WHISTLER_PER_USER, sResourceProductText, 128);
    if (wcscmp(_tcstok(sResourceProductText,szDelimiter), sProduct) == 0)
            dwProductExpID = IDS_PRODUCT_TYPE_EXP_WHISTLER_PER_USER;

    if (dwProductExpID)
    {
        TCHAR sProductTypeExpText[256];
        memset(sProductTypeExpText, 0, sizeof(sProductTypeExpText)/sizeof(TCHAR));
	    LoadString(GetInstanceHandle(),dwProductExpID,sProductTypeExpText,sizeof(sProductTypeExpText)/sizeof(TCHAR));
        SetWindowText(GetDlgItem(hDialog, IDC_PRODUCT_TYPE_EXP), sProductTypeExpText);
    }
    else
        SetWindowText(GetDlgItem(hDialog, IDC_PRODUCT_TYPE_EXP), L"");
}


void ModifyLicenseTypeDependentFields(HWND hDialog)
{
    HWND hLicenseNumberLabel = GetDlgItem(hDialog, IDC_CH_LICENSE_NUMBER_LABEL);
    HWND hSelectLicenseNumber = GetDlgItem(hDialog, IDC_CH_SELECT_LICENSE_NUMBER);
    HWND hSelectLicenseNumberExp = GetDlgItem(hDialog, IDC_CH_SELECT_LICENSE_NUMBER_EXP);
    HWND hMolpAgreementNumber = GetDlgItem(hDialog, IDC_CH_MOLP_AGREEMENT_NUMBER);
    HWND hMolpAgreementNumberExp = GetDlgItem(hDialog, IDC_CH_MOLP_AGREEMENT_NUMBER_EXP);
    HWND hMOLPAuthorizationNumber = GetDlgItem(hDialog, IDC_CH_MOLP_AUTHORIZATION_NUMBER);
    HWND hMOLPAuthorizationNumberExp = GetDlgItem(hDialog, IDC_CH_MOLP_AUTHORIZATION_NUMBER_EXP);
    HWND hLicenseNumberLocation = GetDlgItem(hDialog, IDC_LICENSE_NUMBER_LOCATION);

    BOOL bMOLPLicenseType = IsMOLPSelected(hDialog);

    //Now show fields based on whether it is
    ShowWindow(hSelectLicenseNumber, !bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hSelectLicenseNumberExp, !bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hMolpAgreementNumber, bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hMolpAgreementNumberExp, bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hMOLPAuthorizationNumber, bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hMOLPAuthorizationNumberExp, bMOLPLicenseType ? SW_SHOW : SW_HIDE);
    ShowWindow(hLicenseNumberLocation, bMOLPLicenseType ? SW_SHOW : SW_HIDE);

    //Determine the plurality of license(s) based on whether MOLP is selected
    TCHAR sLicenseNumber[64];
    memset(sLicenseNumber, 0, sizeof(sLicenseNumber)/sizeof(TCHAR));
    if (bMOLPLicenseType)
	    LoadString(GetInstanceHandle(),IDS_CH_LICENSE_NUMBERS,sLicenseNumber,sizeof(sLicenseNumber)/sizeof(TCHAR));
    else
        LoadString(GetInstanceHandle(),IDS_CH_LICENSE_NUMBER,sLicenseNumber,sizeof(sLicenseNumber)/sizeof(TCHAR));

    if (sLicenseNumber)
        SetWindowText(hLicenseNumberLabel, sLicenseNumber);
}

void RemoveLicensePakFromComboBox(HWND hDialog)
{
    TCHAR sLicensePak[64];
	LoadString(GetInstanceHandle(),IDS_PROGRAM_LICENSE_PAK,sLicensePak,sizeof(sLicensePak)/sizeof(TCHAR));

    int nIndex = ComboBox_FindStringExact(hDialog, CB_ERR, sLicensePak);
    ASSERT(nIndex != CB_ERR);
    ComboBox_DeleteString(GetDlgItem(hDialog, IDC_CH_LICENSE_TYPE), nIndex);
}

//We're setting the combo selection with an offset of 1 since LICENSE_PROGRAM_LICENSE_PAK
//will have been removed from the first position in the list
void SelectProgramChoice(HWND hDialog)
{
    CString sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;

    int nItem = LICENSE_PROGRAM_SELECT - 1;

    if (wcscmp(sProgramName, PROGRAM_MOLP) == 0)
        nItem = LICENSE_PROGRAM_OPEN_LICENSE - 1;
    else if (wcscmp(sProgramName, PROGRAM_SELECT) == 0)
        nItem = LICENSE_PROGRAM_SELECT - 1;
    else if (wcscmp(sProgramName, PROGRAM_ENTERPRISE) == 0)
        nItem = LICENSE_PROGRAM_ENTERPRISE - 1;
    else if (wcscmp(sProgramName, PROGRAM_CAMPUS_AGREEMENT) == 0)
        nItem = LICENSE_PROGRAM_CAMPUS - 1;
    else if (wcscmp(sProgramName, PROGRAM_SCHOOL_AGREEMENT) == 0)
        nItem = LICENSE_PROGRAM_SCHOOL - 1;
    else if (wcscmp(sProgramName, PROGRAM_APP_SERVICES) == 0)
        nItem = LICENSE_PROGRAM_APP_SERVICES - 1;
    else if (wcscmp(sProgramName, PROGRAM_OTHER) == 0)
        nItem = LICENSE_PROGRAM_OTHER - 1;

    ComboBox_SetCurSel(GetDlgItem(hDialog, IDC_CH_LICENSE_TYPE), nItem);
}

void PopulateProductVersionComboBox(HWND hDialog)
{
    if (!hDialog)
        return;

    TCHAR lpBuffer[MAX_PRODUCT_VERSION_LENGTH];

    memset(lpBuffer,0,sizeof(lpBuffer));		
	if (LoadString(GetInstanceHandle(), IDS_PRODUCT_VERSION_W2K, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR)))
        ComboBox_AddString(GetDlgItem(hDialog, IDC_CH_PRODUCT_VERSION), lpBuffer);

    memset(lpBuffer,0,sizeof(lpBuffer));		
	if (LoadString(GetInstanceHandle(), IDS_PRODUCT_VERSION_WHISTLER, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR)))
        ComboBox_AddString(GetDlgItem(hDialog, IDC_CH_PRODUCT_VERSION), lpBuffer);
}

void RepopulateProductComboBox(HWND hDialog)
{
    TCHAR lpVersion[MAX_PRODUCT_VERSION_LENGTH];
    TCHAR lpBuffer[MAX_PRODUCT_VERSION_LENGTH];

    ComboBox_GetText(GetDlgItem(hDialog, IDC_CH_PRODUCT_VERSION), lpVersion, MAX_PRODUCT_VERSION_LENGTH);
    
    memset(lpBuffer,0,sizeof(lpBuffer));		
	if (LoadString(GetInstanceHandle(), IDS_PRODUCT_VERSION_W2K, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR)))
    {
        if (wcscmp(lpBuffer, lpVersion) == 0)
        {
            PopulateProductComboBox(GetDlgItem(hDialog, IDC_CH_PRODUCT_TYPE), PRODUCT_VERSION_W2K);
            return;
        }
    }
    
    memset(lpBuffer,0,sizeof(lpBuffer));		
	if (LoadString(GetInstanceHandle(), IDS_PRODUCT_VERSION_WHISTLER, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR)))
    {
        if (wcscmp(lpBuffer, lpVersion) == 0)
        {
            PopulateProductComboBox(GetDlgItem(hDialog, IDC_CH_PRODUCT_TYPE), PRODUCT_VERSION_WHISTLER);
            return;
        }
    }

    PopulateProductComboBox(GetDlgItem(hDialog, IDC_CH_PRODUCT_TYPE), PRODUCT_VERSION_UNDEFINED);
}

LRW_DLG_INT CALLBACK
CHRegisterDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    TCHAR   szMsg[LR_MAX_MSG_TEXT];
    DWORD   dwStringId;
    CString sProgramName;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        {
            SendDlgItemMessage(hwnd, IDC_CH_SELECT_LICENSE_NUMBER, EM_SETLIMITTEXT, CH_SELECT_ENROLLMENT_NUMBER_LEN, 0);
            SendDlgItemMessage(hwnd, IDC_CH_MOLP_AGREEMENT_NUMBER, EM_SETLIMITTEXT, CH_MOLP_AGREEMENT_NUMBER_LEN, 0);
            SendDlgItemMessage(hwnd, IDC_CH_MOLP_AUTHORIZATION_NUMBER, EM_SETLIMITTEXT, CH_MOLP_AUTH_NUMBER_LEN, 0);		
            SendDlgItemMessage(hwnd, IDC_CH_QUANTITY, EM_SETLIMITTEXT, CH_QTY_LEN, 0);

            AddProgramChoices(hwnd, IDC_CH_LICENSE_TYPE);
            RemoveLicensePakFromComboBox(hwnd);
            SelectProgramChoice(hwnd);

            PopulateProductVersionComboBox(hwnd);
            ModifyLicenseTypeDependentFields(hwnd);
        }		
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            if (LOWORD(wParam) == IDC_CH_PRODUCT_VERSION)
                RepopulateProductComboBox(hwnd);

            ModifyLicenseTypeDependentFields(hwnd); 
            SetProductTypeExplanationText(hwnd);
        }
        break;
    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
                sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;
                dwStringId = GetStringIDFromProgramName(sProgramName);
                LoadString(GetInstanceHandle(), dwStringId, szMsg, LR_MAX_MSG_TEXT);
                SetDlgItemText(hwnd, IDC_LICENSE_PROGRAM_STATIC, szMsg);

                LICENSE_PROGRAM licProgram;
                licProgram = GetLicenseProgramFromProgramName(sProgramName);

                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
                    CString sLicenseType;
                    CString sProductCode;
					CString sProduct;
					CString sQuantity;
					LPTSTR  lpVal = NULL;					
					TCHAR   lpBuffer[ 128];
					DWORD   dwRetCode = 0;
					int		nCurSel = -1;
                    BOOL    fIsMOLP = FALSE;

                    
                    sProgramName = GetGlobalContext()->GetContactDataObject()->sProgramName;
                    fIsMOLP = (sProgramName == PROGRAM_MOLP);

                    sLicenseType = sProgramName;

					//Read all the fields
                    

					lpVal = sQuantity.GetBuffer(CH_QTY_LEN+2);
					GetDlgItemText(hwnd,IDC_CH_QUANTITY, lpBuffer,CH_QTY_LEN+2);
					TCHAR *lpStart = lpBuffer;
					do 
					{
						if ((*lpStart >= L'0') && (*lpStart <= L'9'))
							*lpVal++ = *lpStart;
					}
                    while ( *lpStart++ );
                    *lpVal = NULL;
					sQuantity.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_CH_PRODUCT_TYPE));

					lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_CH_PRODUCT_TYPE), nCurSel, lpVal);
					sProduct.ReleaseBuffer(-1);

					// Send Product Code instead of Desc -- 01/08/99
					lpVal = sProductCode.GetBuffer(16);
					GetProductCode(sProduct,lpVal);
					sProductCode.ReleaseBuffer(-1);

					sProductCode.TrimLeft(); sProductCode.TrimRight();
					sQuantity.TrimLeft(); sQuantity.TrimRight();

					if(
                        sLicenseType.IsEmpty()                                  ||
						sProduct.IsEmpty()			                            ||
						sQuantity.IsEmpty()
					   )
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage	= IDD_CH_REGISTER;
						goto NextDone;
					}

					if(!ValidateLRString(sProduct))
						
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_CH_REGISTER;
						goto NextDone;
					}
					
					if(_wtoi(sQuantity) < 1)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_QTY,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage	= IDD_CH_REGISTER;
						goto NextDone;
					}

					if (fIsMOLP)
                    {
					    GetGlobalContext()->GetLicDataObject()->sMOLPProductType		= sProductCode;
					    GetGlobalContext()->GetLicDataObject()->sMOLPProductDesc		= sProduct;
					    GetGlobalContext()->GetLicDataObject()->sMOLPQty				= sQuantity;
                    }
                    else
                    {
                        GetGlobalContext()->GetLicDataObject()->sSelProductType		    = sProductCode;
					    GetGlobalContext()->GetLicDataObject()->sSelProductDesc		    = sProduct;
					    GetGlobalContext()->GetLicDataObject()->sSelMastAgrNumber	    = "";
					    GetGlobalContext()->GetLicDataObject()->sSelQty				    = sQuantity;
                    }

                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, IDS_CALWIZ_TITLE, 0, 0);
                    GetGlobalContext()->SetWizType(WIZTYPE_CAL);

					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_CH_REGISTER);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lkplite\base24.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include <math.h>


class CDataCoding {
private:
	DWORD m_dwBaseDigits;

	DWORD m_dwEncodedLength;
	DWORD m_dwInputDataBits;
	DWORD m_dwInputDataBytes;

	DWORD m_dwDecodedLength;
	DWORD m_dwInputEncDataBytes;
	DWORD m_dwDecodedBits;

	TCHAR * m_tpBaseDigits;
	
public:
	CDataCoding(TCHAR * tpBaseDigits = NULL);

	void SetInputDataBitLen(DWORD dwBits);
	void SetInputEncDataLen(DWORD dwChars);
	DWORD SetBaseDigits(TCHAR * tpBaseDigits);
	DWORD EncodeData(LPBYTE pbSource,  //[IN]  Stream of Bytes to be encoded
					 TCHAR **pbEncodedData); //[OUT] Pointer to a string containing the encoded data
	DWORD DecodeData(TCHAR * pbEncodedData,
					 LPBYTE * pbDecodedData);

	~CDataCoding();
};


class CBase24Coding : public CDataCoding {
public:
	CBase24Coding(void) : CDataCoding(L"BCDFGHJKMPQRTVWXY2346789")
	{
		return;
	}
};







static CBase24Coding b24Global; 


// **************************************************************
DWORD B24EncodeMSID(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(160);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ***************************************************************
DWORD B24DecodeMSID(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(35);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}




// ***********************************************************
DWORD B24EncodeCNumber(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(32);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ******************************************************************
DWORD B24DecodeCNumber(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(7);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}




// *******************************************************
DWORD B24EncodeSPK(LPBYTE pbSource, TCHAR **pbEncodedData)
{
	b24Global.SetInputDataBitLen(114);

	return b24Global.EncodeData(pbSource, pbEncodedData);
}


// ******************************************************************
DWORD B24DecodeSPK(TCHAR * pbEncodedData, LPBYTE * pbDecodedData)
{
	b24Global.SetInputEncDataLen(25);

	return b24Global.DecodeData(pbEncodedData, pbDecodedData);
}



// *****************************************
CDataCoding::CDataCoding(TCHAR * tpBaseDigits)
{
	m_tpBaseDigits = NULL;
	m_dwBaseDigits = 0;
	m_dwEncodedLength = 0;
	m_dwInputDataBits = 0;
	m_dwInputDataBytes = 0;
	SetBaseDigits(tpBaseDigits);
}



// ********************************************
void CDataCoding::SetInputDataBitLen(DWORD dwBits)
{
	assert(dwBits > 0);
	assert(log(m_dwBaseDigits) > 0);

	// Determine How many Characters would be required to encode the data
	// What we have is a dwDataLength of Binary Data stream.
	// So, we can represent 2^(dwDataLength*8) amount of information using these bits
	// Assuming that our set of digits (which form the base for encoding) is X,
	// the above number should then equal X^(NumberofEncoded Digits)
	// So,
	double dLength = ((double) dwBits*log10(2)) /
					 ((double) log10(m_dwBaseDigits));

	// Now round - up
	m_dwEncodedLength = (DWORD) dLength;

	if ((double) m_dwEncodedLength < dLength)
	{
		// There was a decimal part
		m_dwEncodedLength++;
	}
	m_dwInputDataBits = dwBits;
	m_dwInputDataBytes = (dwBits / 8) + (dwBits % 8 ? 1 : 0);

	return;
}





// ***********************************************
void CDataCoding::SetInputEncDataLen(DWORD dwBytes)
{
	assert(dwBytes > 0);
	assert(log(m_dwBaseDigits) > 0);

	m_dwInputEncDataBytes = dwBytes;
	// Determine How many bits would be required to decode this data
	// So,

	double dLength = ((double) dwBytes*log10(m_dwBaseDigits))/
					 ((double) log10(2));

	// Now round - up
	m_dwDecodedBits = (DWORD) dLength;

	if ((double) m_dwDecodedBits < dLength)
	{
		// There was a decimal part
		m_dwDecodedBits++;
	}

	m_dwDecodedLength = (m_dwDecodedBits / 8) + (m_dwDecodedBits % 8 ? 1 : 0);

	return;
}




// **************************************************
DWORD CDataCoding::SetBaseDigits(TCHAR * tpBaseDigits)
{
	DWORD dwReturn = ERROR_SUCCESS;

	if (tpBaseDigits != NULL)
	{
		DWORD dwLen = wcslen(tpBaseDigits);
		assert(dwLen > 0);
		m_tpBaseDigits = (TCHAR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (dwLen+1)*sizeof(TCHAR));
		if (m_tpBaseDigits == NULL)
		{
			dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		}
		else
		{
			memcpy(m_tpBaseDigits, tpBaseDigits, (dwLen+1)*sizeof(TCHAR));
			m_dwBaseDigits = dwLen;
		}
	}
	else
	{
		if (m_tpBaseDigits != NULL)
		{
			HeapFree(GetProcessHeap(), 0, m_tpBaseDigits);
			m_tpBaseDigits = NULL;
			m_dwBaseDigits = 0;
		}
		assert(m_tpBaseDigits == NULL && m_dwBaseDigits == 0);
	}

	return dwReturn;
}







// ************************************************
DWORD CDataCoding::EncodeData(LPBYTE pbSource,  //[IN]  Stream of Bytes to be encoded
		 					  TCHAR **pbEncodedData)	 //[OUT] Pointer to a string containing the encoded data
// I allocate the Buffer, you should free it
{
	assert(m_dwInputDataBits > 0);
	assert(m_dwInputDataBytes > 0);
	assert(m_dwEncodedLength > 0);
	assert(m_tpBaseDigits != NULL);

	DWORD dwReturn = ERROR_SUCCESS;
	int nStartIndex = m_dwEncodedLength;
	*pbEncodedData = NULL;
	BYTE * pbDataToEncode = NULL;
	TCHAR * pbEncodeBuffer = NULL;

    if (NULL == pbEncodedData)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto done;
    }

    *pbEncodedData = NULL;

    pbEncodeBuffer = (TCHAR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
										(m_dwEncodedLength+1)*sizeof(TCHAR));
	if (pbEncodeBuffer == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}

	// Now need to make a copy of the incoming data, so we can run the algorithm below
	pbDataToEncode = (BYTE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwInputDataBytes);
	if (pbDataToEncode == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}
	memcpy(pbDataToEncode, pbSource, m_dwInputDataBytes);
	

	// Let us get rid of the simple stuff
	pbEncodeBuffer[ nStartIndex--] = 0;

    for (; nStartIndex >= 0; --nStartIndex)
    {
        unsigned int i = 0;

        for (int nIndex = m_dwInputDataBytes-1; 0 <= nIndex; --nIndex)
        {
            i = (i * 256) + pbDataToEncode[nIndex];
            pbDataToEncode[ nIndex] = (BYTE)(i / m_dwBaseDigits);
            i %= m_dwBaseDigits;
        }
	
        // i now contains the remainder, which is the current digit
        pbEncodeBuffer[ nStartIndex] = m_tpBaseDigits[ i];
    }
	
	assert(dwReturn == ERROR_SUCCESS);
	*pbEncodedData = pbEncodeBuffer;

done:
	if (pbDataToEncode != NULL)
	{
		HeapFree(GetProcessHeap(), 0, pbDataToEncode);
	}

	if (dwReturn != ERROR_SUCCESS)
	{
		// There was an error, so free the memory that you allocated
		if (pbEncodeBuffer != NULL)
		{
			HeapFree(GetProcessHeap(), 0, pbEncodeBuffer);
		}
	}
	return dwReturn;
}





// *************************************************
DWORD CDataCoding::DecodeData(TCHAR * pbEncodedData,
							 LPBYTE * pbDecodedData)
// Again, I allocate the Buffer, you release it
{
	assert(m_dwDecodedBits > 0);
	assert(m_dwDecodedLength > 0);
	assert(m_tpBaseDigits != NULL);
	assert((DWORD) lstrlen(pbEncodedData) == m_dwInputEncDataBytes);

	DWORD dwReturn = ERROR_SUCCESS;
	TCHAR * tpTemp;
	DWORD dwDigit;
	unsigned int i;
	unsigned int nDecodedBytes, nDecodedBytesMax = 0;
	BYTE * pbDecodeBuffer = NULL;

    if (NULL == pbDecodedData)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto done;
    }

	*pbDecodedData = NULL;

    pbDecodeBuffer = (BYTE *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwDecodedLength);
	if ( pbDecodeBuffer == NULL)
	{
		dwReturn = ERROR_NOT_ENOUGH_MEMORY;
		goto done;
	}
	
	memset(pbDecodeBuffer, 0, m_dwDecodedLength);

	while (*pbEncodedData)
	{
		// First Find the position of this character in the Base Encoding Character Set
		tpTemp = wcschr(m_tpBaseDigits, *pbEncodedData);
		if (tpTemp == NULL)
		{
			// Found a character which is not in base character set
			// ERROR ERROR
			dwReturn = ERROR_INVALID_DATA;
			goto done;
		}
		dwDigit = (DWORD)(tpTemp - m_tpBaseDigits);

        nDecodedBytes = 0;
        i = (unsigned int) dwDigit;

        while (nDecodedBytes <= nDecodedBytesMax)
        {
            i += m_dwBaseDigits * pbDecodeBuffer[ nDecodedBytes];
            pbDecodeBuffer[ nDecodedBytes] = (unsigned char)i;
            i /= 256;
            ++nDecodedBytes;
        }

        if (i != 0)
        {
			assert(nDecodedBytes < m_dwDecodedLength);

            pbDecodeBuffer[ nDecodedBytes] = (unsigned char)i;
            nDecodedBytesMax = nDecodedBytes;
        }

		pbEncodedData++;
	}

	assert(dwReturn == ERROR_SUCCESS);
	*pbDecodedData = pbDecodeBuffer;
	
done:
	if (dwReturn != ERROR_SUCCESS)
	{
		// There was an error, so free the memory that you allocated
		if (pbDecodeBuffer != NULL)
		{
			HeapFree(GetProcessHeap(), 0, pbDecodeBuffer);
		}
	}

	return dwReturn;
}






// **********************
CDataCoding::~CDataCoding()
{
	if (m_tpBaseDigits != NULL)
	{
		HeapFree(GetProcessHeap(), 0, m_tpBaseDigits);
		m_tpBaseDigits = NULL;
		m_dwBaseDigits = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\chselect.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"


LRW_DLG_INT CALLBACK
CHRegisterSelectDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			CString sProductType;

			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );
			
			SendDlgItemMessage(hwnd, IDC_TXT_ENROLLMENT_NUMBER,	EM_SETLIMITTEXT, CH_SELECT_ENROLLMENT_NUMBER_LEN,0);
			SendDlgItemMessage(hwnd, IDC_TXT_QUANTITY,			EM_SETLIMITTEXT, CH_QTY_LEN,0);

			PopulateProductComboBox(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), PRODUCT_VERSION_UNDEFINED);

			//
			//Set the properties of the up-down control
			//
			SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETBUDDY, (WPARAM)(HWND)GetDlgItem(hwnd,IDC_TXT_QUANTITY),(LPARAM)0);
			SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0,(LPARAM) MAKELONG (9999, 1));

		}		
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString sProductCode;
					CString sProduct;
					CString sAgreementNumber;
					CString sEnrollmentNumber;
					CString sQuantity;
					LPTSTR  lpVal = NULL;					
					TCHAR   lpBuffer[ 128];
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//
					//Read all the fields
					//
					lpVal = sEnrollmentNumber.GetBuffer(CH_SELECT_ENROLLMENT_NUMBER_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ENROLLMENT_NUMBER,lpVal,CH_SELECT_ENROLLMENT_NUMBER_LEN+1);
					sEnrollmentNumber.ReleaseBuffer(-1);
					
					lpVal = sQuantity.GetBuffer(CH_QTY_LEN+2);
					GetDlgItemText(hwnd,IDC_TXT_QUANTITY, lpBuffer,CH_QTY_LEN+2);
					TCHAR *lpStart = lpBuffer;
					do 
					{
						if (*lpStart != (TCHAR) ',')
						{
							*lpVal++ = *lpStart;
						}
					} while ( *lpStart++ );
					sQuantity.ReleaseBuffer(-1);

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE));

					lpVal = sProduct.GetBuffer(LR_PRODUCT_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_CMD_PRODUCT_TYPE), nCurSel, lpVal);
					sProduct.ReleaseBuffer(-1);

					// Send Product Code instead of Desc -- 01/08/99
					lpVal = sProductCode.GetBuffer(16);
					GetProductCode(sProduct,lpVal);
					sProductCode.ReleaseBuffer(-1);

					sProductCode.TrimLeft(); sProductCode.TrimRight();
					sEnrollmentNumber.TrimLeft();sEnrollmentNumber.TrimRight();
					sQuantity.TrimLeft(); sQuantity.TrimRight();
					
					if(
						sProduct.IsEmpty()			||
						sEnrollmentNumber.IsEmpty()	||
						sQuantity.IsEmpty()
					   )
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage	= IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}

					if(
						!ValidateLRString(sProduct)			||
						!ValidateLRString(sAgreementNumber)	||
						!ValidateLRString(sEnrollmentNumber)
					  )
						
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}
					
					if(_wtoi(sQuantity) < 1)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_QTY,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage	= IDD_CH_REGISTER_SELECT;
						goto NextDone;
					}

					GetGlobalContext()->GetLicDataObject()->sSelProductType		= sProductCode; //sProduct;
					GetGlobalContext()->GetLicDataObject()->sSelProductDesc		= sProduct;
					GetGlobalContext()->GetLicDataObject()->sSelMastAgrNumber	= sAgreementNumber;
					GetGlobalContext()->GetLicDataObject()->sSelEnrollmentNumber = sEnrollmentNumber;
					GetGlobalContext()->GetLicDataObject()->sSelQty				= sQuantity;

//					dwNextPage = IDD_PROCESSING;

                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_CH_REGISTER_SELECT);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\fancypasting.h ===
//Copyright (c) 2001 Microsoft Corporation
#ifndef _FANCYPASTING_H_
#define _FANCYPASTING_H_

#include "precomp.h"

void InsertClipboardDataIntoIDFields(HWND hDialog, int nFirstControl, int nLastControl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\fonts.h ===
//Copyright (c) 2001 Microsoft Corporation
#ifndef _FONTS_H_
#define _FONTS_H_

#include "precomp.h"

#include "lrwizapi.h"

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId
    );

VOID 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    );

VOID
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\dlgproc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DLGPROC_H_
#define _DLGPROC_H_
LRW_DLG_INT CALLBACK
CustInfoLicenseType(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
EnterCustomLicenseProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
CHRegisterDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ContactInfo1DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ContactInfo2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
ContinueRegFax(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
PINDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
ContinueReg(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
FaxLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
FaxRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
GetModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CountryRegionProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
CertLogProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
ConfRevokeProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
TelReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
WWWReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
ProgressDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
Progress2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
RetailSPKProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK 
EditRetailSPKDlgProc(  
	IN HWND hwndDlg,
	IN UINT uMsg,   
	IN WPARAM wParam,
	IN LPARAM lParam 
 );

LRW_DLG_INT CALLBACK
TelLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
TelRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
SimpleWelcomeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
ComplexWelcomeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );
LRW_DLG_INT CALLBACK
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\fonts.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "fonts.h"

VOID
SetControlFont(
    IN HFONT    hFont, 
    IN HWND     hwnd, 
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}

VOID 
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        FontSize = 12;
    }

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}

VOID 
DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\custcont.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"

LRW_DLG_INT CALLBACK ConfirmEMailDlgProc(IN HWND hwndDlg,  // handle to dialog box
										 IN UINT uMsg,     // message  
										 IN WPARAM wParam, // first message parameter
										 IN LPARAM lParam  // second message parameter
										)
{
	BOOL	bRetCode = FALSE;
	LPTSTR	lpVal = NULL;
	CString	sEmailConf;
	switch ( uMsg )
	{
	case WM_INITDIALOG:
		bRetCode = TRUE;
		break;
	case WM_COMMAND:
		switch ( LOWORD(wParam) )		//from which control
		{
		case IDOK:
			//Get the ITem text and store it in the global structure
			lpVal = sEmailConf.GetBuffer(CA_EMAIL_LEN+1);
			GetDlgItemText(hwndDlg,IDC_TXT_CONF_EMAIL,lpVal,CA_EMAIL_LEN+1);
			sEmailConf.ReleaseBuffer(-1);
			sEmailConf.TrimLeft(); sEmailConf.TrimRight();
			GetGlobalContext()->GetContactDataObject()->sEmailAddressConf =  sEmailConf;
			EndDialog(hwndDlg, IDOK);
			bRetCode = TRUE;
			break;
		default:
			break;
		}
		break;
	default:
		break;

	}
	return bRetCode;
}

LRW_DLG_INT CALLBACK
ContactInfo1DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    CString sCountryDesc;
    CString sProgramName;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		SendDlgItemMessage (hwnd , IDC_TXT_COMPANYNAME,	EM_SETLIMITTEXT, CA_COMPANY_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_LNAME,		EM_SETLIMITTEXT, CA_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FNAME,		EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
		

		//Populate the values which were read from the Registry during Global Init
		SetDlgItemText(hwnd,IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
		SetDlgItemText(hwnd,IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
		SetDlgItemText(hwnd,IDC_TXT_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);

        //Set up the country/region combo box
		PopulateCountryComboBox(GetDlgItem(hwnd,IDC_COUNTRY_REGION));
        
        GetCountryDesc(GetGlobalContext()->GetContactDataObject()->sCountryCode,
            sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1));
        sCountryDesc.ReleaseBuffer();

		ComboBox_SetCurSel(GetDlgItem(hwnd,IDC_COUNTRY_REGION), 
            ComboBox_FindStringExact(GetDlgItem(hwnd, IDC_COUNTRY_REGION), 0, sCountryDesc));

        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
                DisplayPrivacyHelp();
                break;

            case PSN_SETACTIVE:
				{
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );

                    AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
				}

                break;

            case PSN_WIZNEXT:
				{
					CString sCompanyName;
					CString sLastName;
					CString sFirstName;
					CString sCountryDesc;
                    CString sCountryCode;
					LPTSTR  lpVal = NULL;					

					//Read all the fields
					lpVal = sCompanyName.GetBuffer(CA_COMPANY_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_COMPANYNAME,lpVal,CA_COMPANY_NAME_LEN+1);
					sCompanyName.ReleaseBuffer(-1);

					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
	 				GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

					int nCurSel = -1;
                    nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_COUNTRY_REGION));

					lpVal = sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd, IDC_COUNTRY_REGION), nCurSel, lpVal);
					sCountryDesc.ReleaseBuffer(-1);

                    sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sCompanyName.TrimLeft(); sCompanyName.TrimRight();
					sCountryDesc.TrimLeft();sCountryDesc.TrimRight();

					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || sCompanyName.IsEmpty())
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage	= IDD_CONTACTINFO1;
						goto NextDone;
					}
					
					// Check for the Invalid Characters
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sCountryDesc)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_CONTACTINFO1;
						goto NextDone;
					}					
					
					dwNextPage = IDD_CONTACTINFO2;

                    //Check for unselected country/region
                    if(sCountryDesc.IsEmpty())
                    {
                        LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage	= IDD_CONTACTINFO1;
						goto NextDone;
					}

                    //Get the country code assicated with the selected country
					lpVal = sCountryCode.GetBuffer(LR_COUNTRY_CODE_LEN+1);
					if (sCountryDesc.IsEmpty())
						lstrcpy(lpVal, _TEXT(""));
					else
						GetCountryCode(sCountryDesc,lpVal);
					sCountryCode.ReleaseBuffer(-1);

					//Finally update CHData object
					GetGlobalContext()->GetContactDataObject()->sContactFName = sFirstName;
					GetGlobalContext()->GetContactDataObject()->sContactLName = sLastName;
					GetGlobalContext()->GetContactDataObject()->sCompanyName = sCompanyName;			
					GetGlobalContext()->GetContactDataObject()->sCountryDesc = sCountryDesc;
					GetGlobalContext()->GetContactDataObject()->sCountryCode = sCountryCode;

                    //
                    // IMPORTANT:
                    // The activation wizard flow used to ask for license type.
                    // It doesn't anymore but to minimize changes we pre-select a program
                    // type. The user gets to change it when they run the CAL wizard
                    //
                    //
                    sProgramName = PROGRAM_LICENSE_PAK;
                    GetGlobalContext()->GetContactDataObject()->sProgramName = sProgramName;
                    GetGlobalContext()->SetInRegistry(szOID_BUSINESS_CATEGORY,
                                                      GetGlobalContext()->GetContactDataObject()->sProgramName);


					// Put into regsitery too
					GetGlobalContext()->SetInRegistry(szOID_COMMON_NAME, sFirstName);
					GetGlobalContext()->SetInRegistry(szOID_SUR_NAME, sLastName);
					GetGlobalContext()->SetInRegistry(szOID_ORGANIZATION_NAME, sCompanyName);
					GetGlobalContext()->SetInRegistry(szOID_COUNTRY_NAME, sCountryDesc);
                    GetGlobalContext()->SetInRegistry(szOID_DESCRIPTION, sCountryCode);
                    
					//If no Error , go to the next page
					LRPush(IDD_CONTACTINFO1);
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}



LRW_DLG_INT CALLBACK
ContactInfo2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    //CString sCountryDesc;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,		EM_SETLIMITTEXT, CA_EMAIL_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ADDRESS1,	EM_SETLIMITTEXT, CA_ADDRESS_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_CITY,		EM_SETLIMITTEXT, CA_CITY_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_STATE,		EM_SETLIMITTEXT, CA_STATE_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_ZIP,			EM_SETLIMITTEXT, CA_ZIP_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_COMPANY_DIV,     EM_SETLIMITTEXT, CA_ORG_UNIT_LEN,0);
		
		
		//Populate the values which were read from the Registry during Global Init
        SetDlgItemText(hwnd,IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);
		SetDlgItemText(hwnd,IDC_TXT_ADDRESS1, GetGlobalContext()->GetContactDataObject()->sContactAddress);
		SetDlgItemText(hwnd,IDC_TXT_CITY	, GetGlobalContext()->GetContactDataObject()->sCity);
		SetDlgItemText(hwnd,IDC_TXT_STATE	, GetGlobalContext()->GetContactDataObject()->sState);
		SetDlgItemText(hwnd,IDC_TXT_ZIP		, GetGlobalContext()->GetContactDataObject()->sZip);
		SetDlgItemText(hwnd,IDC_COMPANY_DIV , GetGlobalContext()->GetContactDataObject()->sOrgUnit);

        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
                DisplayPrivacyHelp();
                break;

            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
                break;

            case PSN_WIZNEXT:
				{
                    CString sEmail;
					CString sAddress1;
					CString sCity;
					CString sState;
					LPTSTR  lpVal = NULL;
					CString sZip;
					CString sOrgUnit;
					DWORD   dwRetCode;
					int		nCurSel = -1;

					//Read all the fields
					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);


					lpVal = sAddress1.GetBuffer(CA_ADDRESS_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ADDRESS1,lpVal,CA_ADDRESS_LEN+1);
					sAddress1.ReleaseBuffer(-1);
					
					lpVal = sCity.GetBuffer(CA_CITY_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_CITY,lpVal,CA_CITY_LEN+1);
					sCity.ReleaseBuffer(-1);

					lpVal = sState.GetBuffer(CA_STATE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_STATE,lpVal,CA_STATE_LEN+1);
					sState.ReleaseBuffer(-1);

					lpVal = sZip.GetBuffer(CA_ZIP_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ZIP,lpVal,CA_ZIP_LEN+1);
					sZip.ReleaseBuffer(-1);

			
					lpVal = sOrgUnit.GetBuffer(CA_ORG_UNIT_LEN+1);
					GetDlgItemText(hwnd,IDC_COMPANY_DIV,lpVal,CA_ORG_UNIT_LEN+1);
					sOrgUnit.ReleaseBuffer(-1);

                    sEmail.TrimLeft();	 sEmail.TrimRight();
					sAddress1.TrimLeft(); sAddress1.TrimRight();
					sCity.TrimLeft(); sCity.TrimRight();
					sState.TrimLeft(); sState.TrimRight();
					sZip.TrimLeft(); sZip.TrimRight();
					sOrgUnit.TrimLeft(); sOrgUnit.TrimRight();

					if(
					   !ValidateLRString(sAddress1)	||
					   !ValidateLRString(sCity)		||
					   !ValidateLRString(sState)	||
					   !ValidateLRString(sZip)		||
					   !ValidateLRString(sOrgUnit)  ||
                       !ValidateLRString(sEmail)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						dwNextPage = IDD_CONTACTINFO2;
						goto NextDone;
					}

                    // Validate email address if not empty
					if(!sEmail.IsEmpty())
					{
						if(!ValidateEmailId(sEmail))
						{
							LRMessageBox(hwnd,IDS_ERR_INVALID_EMAIL,IDS_WIZARD_MESSAGE_TITLE);
							dwNextPage = IDD_CONTACTINFO2;
							goto NextDone;
						}
					}

					//Finally update CHData object
                    GetGlobalContext()->GetContactDataObject()->sContactEmail   = sEmail;
					GetGlobalContext()->GetContactDataObject()->sCity			= sCity;
					GetGlobalContext()->GetContactDataObject()->sContactAddress	= sAddress1;
					GetGlobalContext()->GetContactDataObject()->sZip            = sZip;
					GetGlobalContext()->GetContactDataObject()->sState			= sState;					
					GetGlobalContext()->GetContactDataObject()->sOrgUnit        = sOrgUnit;			

                    GetGlobalContext()->SetInRegistry(szOID_RSA_emailAddr, (LPCTSTR) sEmail);
					GetGlobalContext()->SetInRegistry(szOID_LOCALITY_NAME, sCity);
					GetGlobalContext()->SetInRegistry(szOID_STREET_ADDRESS, sAddress1);
					GetGlobalContext()->SetInRegistry(szOID_POSTAL_CODE, sZip);
					GetGlobalContext()->SetInRegistry(szOID_STATE_OR_PROVINCE_NAME, sState);
					GetGlobalContext()->SetInRegistry(szOID_ORGANIZATIONAL_UNIT_NAME, sOrgUnit);

                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

                    if (dwRetCode != ERROR_SUCCESS)
                    {
                        LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);
                        dwNextPage = IDD_CONTACTINFO2;
                    }
                    else
                    {
                        LRPush(IDD_WELCOME_CLIENT_LICENSING);
                        dwNextPage = IDD_PROGRESS;
                    }

NextDone:	
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;				
					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\fancypasting.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "fancypasting.h"


BOOL IsValidAlphanumericCharacter(TCHAR cElement)
{
    BOOL bValid = FALSE;

    if (((cElement >= L'A') && (cElement <= L'Z')) ||    
        ((cElement >= L'a') && (cElement <= L'z')) ||    
        ((cElement >= L'0') && (cElement <= L'9')))    
        bValid = TRUE;
    else
        bValid = FALSE;

    return bValid;
}

int GetNumCharsBeforeDelimiter(CString &sDelimited)
{
    int nIndex = 0;

    for (nIndex = 0; nIndex < sDelimited.GetLength(); nIndex++)
    {
        if (!IsValidAlphanumericCharacter(sDelimited[nIndex]))
            break;
    }

    return nIndex;
}

//Removes all delimiting (non-alphanumeric) characters
//from the left of the string
void StripDelimitingCharacters(CString &sUnstripped)
{
    while (!sUnstripped.IsEmpty())
    {
        if (GetNumCharsBeforeDelimiter(sUnstripped) == 0)
            sUnstripped = sUnstripped.Right(sUnstripped.GetLength() - 1);
        else
            break;
    }
}

//This will remove the substring on the left (the string
//beginning with the first alphanumeric character and
//up to the first delimiting character) from the input
//string and will then return that substring
CString StripLeftSubString(CString &sUnstripped)
{
    CString sSubString;
    sSubString.Empty();

    //First make sure the 1st character will be the 
    //legitimate beginning of the substring
    //(the first group of alphanumeric characters
    //up until the first delimiting character)
    StripDelimitingCharacters(sUnstripped);

    if (!sUnstripped.IsEmpty())
    {
        int nNumCharsBeforeDelimiter = GetNumCharsBeforeDelimiter(sUnstripped);
    
        sSubString = sUnstripped.Left(nNumCharsBeforeDelimiter);
    
        //Now remove the substring from the one passed in
        sUnstripped = sUnstripped.Right(sUnstripped.GetLength() - nNumCharsBeforeDelimiter);
    }

    return sSubString;
}

//This relies on the controls having contiguous resource IDs
void InsertClipboardDataIntoIDFields(HWND hDialog, int nFirstControl, int nLastControl)
{
    //First read the data from the clipboard
    #ifdef _UNICODE
	    HANDLE hString = GetClipboardData(CF_UNICODETEXT);
    #else
	    HANDLE hString = GetClipboardData(CF_TEXT);
    #endif
    CString strNewData = (LPTSTR)(hString);

    //Now write each valid substring from that into the control fields
    for (int nControlIndex = nFirstControl; nControlIndex <= nLastControl; nControlIndex++)
    {
        if (strNewData.IsEmpty())
            break;

        //Now remove the substring and write it into the appropriate control
        CString sFieldString = StripLeftSubString(strNewData);
        if ((!sFieldString.IsEmpty()) && (sFieldString.GetLength() <= 5))
            SetDlgItemText(hDialog, nControlIndex, sFieldString);
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\def.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DEF_H_
#define _DEF_H_

#define NO_OF_PAGES					24

#define	PG_NDX_WELCOME          		0
#define	PG_NDX_GETREGMODE				1
#define	PG_NDX_CONTACTINFO1				2
#define	PG_NDX_CONTACTINFO2				3
#define PG_NDX_CONTINUEREG				4
#define	PG_NDX_PROGRESS					5
#define	PG_NDX_PROGRESS2				6
#define	PG_NDX_DLG_PIN					7
//#define	PG_NDX_CH_REGISTER_SELECT		7
//#define	PG_NDX_CH_REGISTER_MOLP			8
#define PG_NDX_CH_REGISTER              8
#define	PG_NDX_COUNTRYREGION			9
#define	PG_NDX_CH_REGISTER_1			10
#define	PG_NDX_RETAILSPK				11
#define	PG_NDX_TELREG					12
#define	PG_NDX_TELLKP					13
#define	PG_NDX_CONFREVOKE				14
#define	PG_NDX_TELREG_REISSUE			15
#define	PG_NDX_WWWREG_REISSUE			16
#define	PG_NDX_CERTLOG					17
#define	PG_NDX_WWWREG					18
#define	PG_NDX_WWWLKP					19

//These aren't tied to specific dialog boxes, because the order
//will change depending on the Wizard Action
#define	PG_NDX_WELCOME_1          		20 
#define	PG_NDX_WELCOME_2          		21
#define	PG_NDX_WELCOME_3          		22
#define PG_NDX_ENTERLICENSE             23

//
// Dlgs for LS Properties 
//
#define PG_NDX_PROP_MODE		0
#define PG_NDX_PROP_CUSTINFO_a	1
#define PG_NDX_PROP_CUSTINFO_b	2

#define NO_OF_PROP_PAGES	3


// Various Request Types
#define REQUEST_NULL					0
#define REQUEST_CH_PING					1
#define REQUEST_CA_CERTREQUEST			2
#define REQUEST_CA_CERTDOWNLOAD			3
#define REQUEST_CA_CERTSIGNONLY			4
#define REQUEST_CA_REVOKECERT			5
#define REQUEST_CA_UPGRADECERT			6
#define REQUEST_CA_REISSUECERT			7
#define REQUEST_CH_AUTHENTICATE			8
#define REQUEST_CH_LKPREQUEST			9
#define REQUEST_CH_LKPACK				10
#define REQUEST_CH_RETURNLKP			11
#define REQUEST_CH_REISSUELKP			12


//
//LS Registration Modes
//
// Note : LRMODE_CA_ONLINE_REQUEST & LRMODE_REG_REQUEST are both Registration Request
// Online is for Internet and Reg_request is for Telephone/WWW
#define	LRMODE_CH_REQUEST				1
#define	LRMODE_CA_ONLINE_REQUEST		2
#define	LRMODE_CA_ONLINE_DOWNLOAD		3
#define LRMODE_CH_REISSUE_LASTREQUEST	4
#define LRMODE_CA_REVOKECERT			5
#define LRMODE_CA_REISSUECERT			6
#define	LRMODE_REG_REQUEST				7  


//
// Fax Request Types
//
#define FAX_REQUEST_BOTH		0
#define FAX_REQUEST_REG_ONLY	1
#define FAX_REQUEST_LKP_ONLY	2


#define LR_REGISTRATIONID_LEN		35
#define LR_LICENSESERVERID_LEN		23
#define LR_RETAILSPK_LEN			25
#define LR_CONFIRMATION_LEN			 7

#define MAX_RETAILSPKS_IN_BATCH		10


#define BASE24_CHARACTERS	_TEXT("BCDFGHJKMPQRTVWXY2346789")



//
//LRWiz States. CR - Certificate Request & LR - LKP Request/LKP Response
// 1 is used to determine whether to display PIN dlg in Online Mode
// 2 & 3 are used to determine which files to expect on the disk in Install from Disk mode
// LRSTATE_NEUTRAL means , end to end cycle is completed
// Like , Online CR created - Cert Downloaded & installed etc.
//
#define	LRSTATE_NEUTRAL						0
#define	LRSTATE_ONLINE_CR_CREATED			1
#define LRSTATE_FAX_ONE_REQUEST_CREATED		2
#define LRSTATE_FAX_BOTH_REQUEST_CREATED	3

//REG_KEYS
#define REG_LRWIZ_PARAMS			L"SOFTWARE\\MICROSOFT\\TermServLicensing\\LrWiz\\Params"
#define REG_LRWIZ_CSNUMBERS			L"SOFTWARE\\MICROSOFT\\TermServLicensing\\LrWiz\\CSNumbers"
#define REG_LRWIZ_CSPHONEREGION		"CSRPhoneRegion"
#define REG_LRWIZ_STATE				L"State"
#define REG_ROOT_CERT				L"Param0"
#define REG_EXCHG_CERT				L"Param1"
#define REG_SIGN_CERT				L"Param2"
#define REG_CH_SERVER				L"CH_SERVER"
#define REG_CH_EXTENSION			L"CH_EXTENSION"
#define	REG_LR_COUNT				L"LKPRC"
#define REG_WWW_SITE				L"WWW"

//General
#define	LR_MAX_MSG_TEXT			1024
#define	LR_MAX_MSG_CAPTION		64

#define LR_FIELD_DELIMITER		"~"
#define LS_SERVICE_NAME			L"TermServLicensing"
#define	LS_CRYPT_KEY_CONTAINER	L"tmpHydraLSKeyContainer"
#define szOID_NULL_EXT			"1.3.6.1.4.1.311.18"
//#define	szOID_NULL_EXT			"1.3.6.1.5.5.7.1.1"
#define MAX_NUM_EXTENSION		4

//Certificate Types
#define CA_CERT_TYPE_SELECT		"SELECT"
#define CA_CERT_TYPE_OTHER		"BASIC"

//Program names
#define PROGRAM_LICENSE_PAK		    _TEXT("OTHER")
#define PROGRAM_MOLP			    _TEXT("MOLP")
#define PROGRAM_SELECT			    _TEXT("SELECT")
#define PROGRAM_ENTERPRISE		    _TEXT("ENTERPRISE")
#define PROGRAM_CAMPUS_AGREEMENT    _TEXT("CAMPUS_AGREEMENT")
#define PROGRAM_SCHOOL_AGREEMENT    _TEXT("SCHOOL_AGREEMENT")
#define PROGRAM_APP_SERVICES	    _TEXT("APP_SERVICES")
#define PROGRAM_OTHER			    _TEXT("REAL_OTHER")
#define PROGRAM_NAME_MAX_LENGTH     16 //Remember to update this if a longer name is added

//Internal properties
#define _CERTBLOBTAG			_TEXT("CERTBLOB")
#define _MFGINFOTAG				_TEXT("MFGINFOTAG")

//program tags
#define _PROGRAMNAMETAG				_TEXT("REGPROGRAMNAME")

//Contact Information Tags

#define _CONTACTLNAMETAG			_TEXT("CONTACTLNAME")
#define _CONTACTFNAMETAG			_TEXT("CONTACTFNAME")
#define _CONTACTADDRESSTAG			_TEXT("CONTACTADDRESS")
#define _CONTACTPHONETAG			_TEXT("CONTACTPHONE")
#define _CONTACTFAXTAG				_TEXT("CONTACTFAX")
#define _CONTACTEMAILTAG			_TEXT("CONTACTEMAIL")
#define _CONTACTCITYTAG				_TEXT("CONTACTCITY")
#define _CONTACTCOUNTRYTAG			_TEXT("CONTACTCOUNTRY")
#define _CONTACTSTATE				_TEXT("CONTACTSTATE")
#define _CONTACTZIP					_TEXT("CONTACTZIP")


//Customer Information Tags
#define _CUSTOMERNAMETAG			_TEXT("CUSTOMERNAME")

//Select Information TAGS
#define _SELMASTERAGRNUMBERTAG		_TEXT("SELMASTERAGRNUMBERTAG")
#define _SELENROLLNUMBERTAG			_TEXT("SELENROLLNUMBER")
#define _SELPRODUCTTYPETAG			_TEXT("SELPRODUCTTYPE")
#define _SELQTYTAG					_TEXT("SELQTY")

//MOLP information
#define _MOLPAUTHNUMBERTAG			_TEXT("MOLPAUTHNUMBER")
#define _MOLPAGREEMENTNUMBERTAG		_TEXT("MOLPAGREEMENTNUMBER")
#define _MOLPPRODUCTTYPETAG			_TEXT("MOLPPRODUCTTYPE")
#define _MOLPQTYTAG					_TEXT("MOLPQTY")

//other (Retail) information
#define _OTHARBLOBTAG				_TEXT("OTHARBLOB")
//shipping information  - this will be required in case the
//user has not opted to use the same information as 
//shown in step 2 of registration.
#define _SHIPINFOPRESENT			_TEXT("SHIPINFOPRESENT")
#define _SHIPCONTACTLNAMETAG		_TEXT("SHIPCONTACTLNAME")
#define _SHIPCONTACTFNAMETAG		_TEXT("SHIPCONTACTFNAME")
#define _SHIPCONTACTADDRESSTAG		_TEXT("SHIPCONTACTADDRESS")
#define _SHIPCONTACTADDRESS1TAG		_TEXT("SHIPCONTACTADDRESS1")
#define _SHIPCONTACTADDRESS2TAG		_TEXT("SHIPCONTACTADDRESS2")
#define _SHIPCONTACTPHONETAG		_TEXT("SHIPCONTACTPHONE")
#define _SHIPCONTACTEMAILTAG		_TEXT("SHIPCONTACTEMAIL")
#define _SHIPCONTACTCITYTAG			_TEXT("SHIPCONTACTCITY")
#define _SHIPCONTACTCOUNTRYTAG		_TEXT("SHIPCONTACTCOUNTRY")
#define _SHIPCONTACTSTATE			_TEXT("SHIPCONTACTSTATE")
#define _SHIPCONTACTZIP				_TEXT("SHIPCONTACTZIP")
#define	_SHIPLSNAMETAG				_TEXT("SHIPLSNAME")

//Misc Property TAG
#define _OFFLINEREGFILENAMETAG		_TEXT("OFFLINEREGFILENAME")
#define _OFFLINESHIPFILENAMETAG		_TEXT("OFFLINESHIPFILENAME")

//Field lengths
#define CA_COMPANY_NAME_LEN			60
#define CA_ORG_UNIT_LEN				60
#define CA_ADDRESS_LEN				200
#define CA_CITY_LEN					30 
#define CA_STATE_LEN				30
#define CA_COUNTRY_LEN				2
#define CA_ZIP_LEN					16 
#define CA_NAME_LEN					30
#define CA_PHONE_LEN				64
#define CA_EMAIL_LEN				64
#define CA_FAX_LEN					64

#define	CA_PIN_LEN					42

//CH Field Lengths
#define CH_LICENSE_TYPE_LENGTH          64

#define CH_MOLP_AUTH_NUMBER_LEN			    128
#define CH_MOLP_AGREEMENT_NUMBER_LEN	    128
#define CH_SELECT_ENROLLMENT_NUMBER_LEN		128

#define CH_QTY_LEN						4

/*
#define CH_CONTACT_NAME_LEN				64
#define CH_ADDRESS_LEN					64
#define CH_PHONE_LEN					32
#define CH_EMAIL_LEN					64
#define CH_CITY_LEN						64
#define CH_COUNTRY_LEN					32
#define CH_STATE_LEN					32
#define CH_POSTAL_CODE_LEN				32
#define CH_CUSTOMER_NAME_LEN			64
*/

#define	LR_DRIVE_LEN					5

#define	LR_SHIPINFO_LEN					1024


//File Names
#define MFG_FILENAME			"mfr.bin"
#define CA_EXCHG_REQ_FILENAME	"exchgcert.req"		
#define CA_SIG_REQ_FILENAME		"sigcert.req"		
#define CA_EXCHG_RES_FILENAME	"exchgcert.rsp"		
#define CA_SIG_RES_FILENAME		"sigcert.rsp"		
#define CA_ROOT_RES_FILENAME	"lsroot.rsp"

#define CH_ROOT_CERT_FILENAME	"chroot.crt"
#define CH_EXCHG_CERT_FILENAME	"chexchg.crt"
#define CH_SIG_CERT_FILENAME	"chsig.crt"


#define CH_LKP_REQ_FILENAME		"newlkp.req"
#define CH_LKP_RES_FILENAME		"newlkp.rsp"


#define SHIP_INFO_FILENAME		"ship.inf"

// LKP ACK statuse
#define LKP_ACK					'2'
#define LKP_NACK				'3'

//
// Resource Ids for Country Code & Desc
//
// *** Important ***
// These number corresond to lrwizdll.rc2 country resources.
// If any new countries are added/removed don't forget to update
// these values

#define	IDS_COUNTRY_START		500
#define	IDS_COUNTRY_END			745


//
// Resource Ids for Product Code & Desc
//
#define	IDS_PRODUCT_START                   200

//The beginning and ending values mark the first and last
//product code for each product version. This must be kept
//in sync with changes to the list of products in the rc2 file

#define IDS_PRODUCT_W2K_BEGIN               001 
#define IDS_PRODUCT_W2K_CLIENT_ACCESS       200
#define IDS_PRODUCT_W2K_INTERNET_CONNECTOR  201
#define IDS_PRODUCT_W2K_END                 002

#define IDS_PRODUCT_WHISTLER_BEGIN          003
#define IDS_PRODUCT_WHISTLER_PER_USER    202
#define IDS_PRODUCT_WHISTLER_PER_SEAT       203
#define IDS_PRODUCT_WHISTLER_END            004

#define	IDS_PRODUCT_IC                      201
#define	IDS_PRODUCT_CONCURRENT              202
#define IDS_PRODUCT_WHISTLER                203

#define	IDS_PRODUCT_END                     204

#define	LR_COUNTRY_CODE_LEN		2
#define	LR_COUNTRY_DESC_LEN		64


#define IDS_REACT_REASONS_START		100
#define IDS_REACT_REASONS_END		104

#define IDS_DEACT_REASONS_START		150
#define IDS_DEACT_REASONS_END		151

#define CODE_TYPE_REACT				1
#define CODE_TYPE_DEACT				2


#define LR_REASON_CODE_LEN		2
#define LR_REASON_DESC_LEN		128


#define	LR_PRODUCT_CODE_LEN		3
#define	LR_PRODUCT_DESC_LEN		64

#define MAX_COUNTRY_NAME_LENGTH         128
#define MAX_COUNTRY_NUMBER_LENGTH       128
//
// Some constants used for progress bar
//
#define	PROGRESS_MAX_VAL		100			
#define	PROGRESS_STEP_VAL		1			
#define PROGRESS_WAIT_TIME		100			

//
// Constants required for Email validation
//
#define	EMAIL_MIN_LEN			6
#define	EMAIL_AT_CHAR			'@'
#define	EMAIL_DOT_CHAR			'.'
#define	EMAIL_SPACE_CHAR		' '
#define EMAIL_AT_DOT_STR		L"@."
#define	EMAIL_DOT_AT_STR		L".@"

#define	LR_SINGLE_QUOTE			'\''

#define LR_INVALID_CHARS		"\"~|"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\chstruct.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _CHSTRUCT_H_
#define _CHSTRUCT_H_

#include "winsock2.h"
#include "httpext.h"
#include "assert.h"
#pragma warning(disable:4200)

//
// Version Number for the CH Structs. (Build Number) 
//
#define CH_STRUCTS_VERSION_RC1		11
#define	CH_STRUCTS_CURRENT_VERSION	37


#define MAX_RETAILSPKCOUNT			20
#define LSSPK_LEN					96
#define PIN_LEN						96
#define REQUEST_ID_LEN				64
#define CA_CUSTMER_NAME_LEN			60
#define CA_COUNTRY_LEN				2
#define CA_PHONE_LEN				64
#define CA_FAX_LEN					64
#define CA_REVOKE_REASONCODE_LEN	4
#define CA_LSERVERID_LEN			32
#define PROGRAM_NAME_LEN			64
#define MAX_CERTTYPE_LEN			32

//Retail SPK Return Values
#define RETAIL_SPK_NULL						((TCHAR)'0')	
#define RETAIL_SPK_OK						((TCHAR)'1')
#define RETAIL_SPK_INVALID_SIGNATURE		((TCHAR)'2')
#define RETAIL_SPK_INVALID_PRODUCT_TYPE		((TCHAR)'3')
#define RETAIL_SPK_INVALID_SERIAL_NUMBER	((TCHAR)'4')
#define RETAIL_SPK_ALREADY_REGISTERED		((TCHAR)'5')
#define RETAIL_MAX_LENGTH					25			//25 TCHARS

//Select/Open override
#define OVERRIDE_MAX_SIZE                   10

typedef struct _CERTCUSTINFO_TAG_
{
	TCHAR	OrgName[CA_CUSTMER_NAME_LEN+1];
	TCHAR	OrgUnit[CA_ORG_UNIT_LEN+1];
	TCHAR	Address[CA_ADDRESS_LEN+1];
	TCHAR	City[CA_CITY_LEN+1];
	TCHAR	State[CA_STATE_LEN+1];
	TCHAR	Country[CA_COUNTRY_LEN+1];
	TCHAR	Zip[CA_ZIP_LEN+1];
	TCHAR	LName[CA_NAME_LEN+1];
	TCHAR	FName[CA_NAME_LEN+1];
	TCHAR	Phone[CA_PHONE_LEN+1];
	TCHAR   Fax[CA_FAX_LEN+1]; 
	TCHAR	Email[CA_EMAIL_LEN+1];
	TCHAR	LSID[CA_LSERVERID_LEN+1];
	TCHAR	ProgramName[PROGRAM_NAME_LEN];
} CERTCUSTINFO, * PCERTCUSTINFO;

#define HydraContent "application/octet-stream"
/*********************************************************************************************************
 * Hydra request header definitions                                                                      *
 *********************************************************************************************************/
enum RequestTypes
{
	PingRequest = 1,					//ping upto isapi extension
	CertificateRequest,					//New Certificate request
	CertificateDownload,				//certificate download request
	CertificateSignOnly,				//convert from SPK to certificate
	CertificateRevoke,					//Revoke current certificate
	CertificateReissue,					//Reissue the certificate
	CertificateDownloadAck,				//Certificate download ack request
	ValidateCert,						//Validate Certificate Request
	NewLicenseRequest,					//new license request
	ReturnLicenseRequest,				//return license request
	ReissueLicenseRequest,				//reissue last license key pack
	LKPDownloadAckRequest,				//acknowledgement 	
	NoOperation							//unknown operation
};


enum ResponseTypes
{
	Response_Invalid_Response = 0,
	Response_Success,
	Response_Failure,
	Response_InvalidData,
	Response_ServerError,
	Response_NotYetImplemented,
	Response_VersionMismatch,
	Response_Reg_Bad_SPK,
	Response_Reg_Bad_Cert,
	Response_Reg_Expired,
	Response_Reg_Revoked,
	Response_TDO_TDN_Failed,
	Response_License_Info_Failed,
	Response_Invalid_Conf_Num,
	Response_Conf_Num_Already_Used,
    Response_SelectMloLicense_NotValid,
    Response_NotASupervisor_NotValid,
	Response_Invalid_Transfer,
	Response_Denied_Other_Program_Id,
	Response_Invalid_Other_Program_Qty
};

enum TransactionStates
{
	Void	= 0,
	NotValidated,
	Validated,
	LicenceRequestPending,
	LicenceRequestGranted,
	UpgradeRequestPending
// ...
};

enum RegistrationMethods
{
	Reg_Internet = 0,
	Reg_Telephone,
	Reg_Fax
};

enum TransportTypes
{
	Transport_Internet =1,			//will be supported
	Transport_Disk,					
	Transport_Modem,
	Transport_FaxModem,
	Transport_Other				//unknown transport yet!
};

typedef struct TCB_DISK_PARAM_TAG
{
	char	*	pszFileName;
	char	*	pPostData;
	DWORD		dwPostDataLen;
}TCB_DISK_PARAM, * PTCB_DISK_PARAM;

typedef struct TCB_INTERNET_PARAM_TAG
{
	char *	pURL;
	char *	pPostData;
	DWORD	dwPostDataLen;
}TCB_INTERNET_PARAM, *PTCB_INTERNET_PARAM;


/*
 * This is the transport control block which is filled in prior to calling the
 * Send Request routine.
 *
 */
typedef struct TCB_TAG_
{
	RequestTypes	RequestType;			//request identifier
	TransportTypes	TransportType;			//transport identifier
	void *			pvParam;				//parameters based on the Transport Type
	void *			pvReserved;				//should be set to null at request time and then left alone.
	void *			pvResponse;				//void pointer to response
	DWORD			dwResponseLen;			//response length
	DWORD			dwRetCode;				//Return code from wait operation
}TCB, * PTCB;

/*
 * This is the generic structure of the request header that goes on the wire
 */
class RequestHeader
{
public:
	RequestHeader()	
		{	SetRequestType(NoOperation);
			SetResponseType(Response_Invalid_Response); 
			m_dwLanguageID	=	0;
			SetVersion(CH_STRUCTS_CURRENT_VERSION);
			SetRegistrationMethod(Reg_Internet);
		};


	void SetRequestType (enum RequestTypes Req) 
	{ 
		m_Request = (enum RequestTypes)htonl(Req); 
	};

	enum RequestTypes GetRequestType() 
	{ 
		return (enum RequestTypes) ntohl(m_Request); 
	};

	void SetResponseType (enum ResponseTypes eResp)
	{ 
		m_Response = (enum ResponseTypes)htonl(eResp); 
	};
	enum ResponseTypes GetResponseType() 
	{ 
		return (enum ResponseTypes) ntohl(m_Response); 
	};


	void SetRegistrationMethod (enum RegistrationMethods eRegM)
	{ 
		m_RegistrationMethod = (enum RegistrationMethods)htonl(eRegM); 
	};
	
	enum RegistrationMethods GetRegistrationMethod() 
	{ 
		return (enum RegistrationMethods) ntohl(m_RegistrationMethod); 
	};

	void SetLanguageId(DWORD dwLanguagwId) 
	{
		m_dwLanguageID = htonl(dwLanguagwId);
	};

	DWORD GetLanguageId()
	{
		return ntohl(m_dwLanguageID);
	};	

	void SetVersion(DWORD dwVersion)
	{
		m_dwVersion = htonl(dwVersion);
	};

	DWORD GetVersion()
	{
		return ntohl(m_dwVersion);
	}

private:
	enum RequestTypes			m_Request;								//Request Interaction Code
	enum ResponseTypes			m_Response;								//Response Type		
	enum RegistrationMethods	m_RegistrationMethod;					//Registration Method
	DWORD						m_dwLanguageID;							//languageId
	DWORD						m_dwVersion;							// Version for the Request Header
};

/*
 * Validation request header
 */
class Validate_Request
{
public:
	Validate_Request() 
	{	
		RequestHeader.SetRequestType(ValidateCert); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
	};

	~Validate_Request() {};
	
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
        if (pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetCertBlobLen (DWORD dwCertBlobLen)
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ()
	{
		return (ntohl(m_dwCertBlobLen));
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	DWORD			m_dwCertBlobLen;
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data part
	//CErt Blob follows here
};
/*
 * Validation response header
 */
class Validate_Response
{
public:
	Validate_Response() 
	{ 
		RequestHeader.SetRequestType(ValidateCert); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset(m_szCertType,0,sizeof(m_szCertType));
	};
	
	inline void SetCHExchCertLen (DWORD dwCertLen) 
	{
		m_dwCHExchCertLen = htonl(dwCertLen);
	};

	inline DWORD GetCHExchCertLen () 
	{ 
		return ntohl(m_dwCHExchCertLen); 
	};

	inline void SetCHSignCertLen (DWORD dwCertLen) 
	{
		m_dwCHSignCertLen = htonl(dwCertLen);
	};

	inline DWORD GetCHSignCertLen () 
	{ 
		return ntohl(m_dwCHSignCertLen); 
	};

	inline void SetCHRootCertLen(DWORD dwRootCertLen) 
	{
		m_dwCHRootCertLen = htonl(dwRootCertLen);
	};

	inline DWORD GetCHRootCertLen () 
	{ 
		return ntohl(m_dwCHRootCertLen); 
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	void SetRetCode (DWORD dwRetCode )
	{
		m_dwRetCode = htonl(dwRetCode);
	}
	DWORD GetRetCode ()
	{
		return ntohl(m_dwRetCode);
	}
	void SetCertType(PBYTE pbCertType, DWORD dwCertTypeLen )
	{
		memcpy (m_szCertType, pbCertType, dwCertTypeLen );
	}
	LPTSTR GetCertType()
	{
		return ((LPTSTR)m_szCertType);
	}
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwRetCode;
	DWORD			m_dwCHRootCertLen;
	DWORD			m_dwCHExchCertLen;
	DWORD			m_dwCHSignCertLen;
	TCHAR			m_szCertType[MAX_CERTTYPE_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length response
	//1.CH Root Cert
	//2.CH Exch cert
	//3.CH Sign Cert
};

//Send the old certificate and SPK with this request and
//then get the response back
class CertRevoke_Request
{
public:
	CertRevoke_Request() 
	{ 
		RequestHeader.SetRequestType(CertificateRevoke); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szSPK,0,sizeof(m_szSPK));
		memset (m_LName, 0, sizeof(m_LName));
		memset (m_FName,0,sizeof(m_FName));
		memset (m_Phone, 0, sizeof(m_Phone));
		memset (m_FAX, 0, sizeof(m_FAX));
		memset (m_EMail,0,sizeof(m_EMail));
		memset (m_ReasonCode,0,sizeof(m_ReasonCode));
		m_dwExchgCertLen = 0;
		m_dwSignCertLen = 0;
		
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
        if (pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetExchgCertLen (DWORD dwExchgCertLen)
	{
		m_dwExchgCertLen = htonl(dwExchgCertLen);
	};

	DWORD GetExchgCertLen ()
	{
		return (ntohl(m_dwExchgCertLen));
	};

	void SetSignCertLen (DWORD dwSignCertLen)
	{
		m_dwSignCertLen = htonl(dwSignCertLen);
	};

	DWORD GetSignCertLen ()
	{
		return (ntohl(m_dwSignCertLen));
	};

	void SetLName ( PBYTE pbLName, DWORD dwLNameLen )
	{
		memcpy ( m_LName, pbLName, dwLNameLen );
	};
	LPTSTR GetLName ()
	{
		return ((LPTSTR)m_LName);
	};

	void SetFName ( PBYTE pbFName, DWORD dwFNameLen )
	{
		memcpy ( m_FName, pbFName, dwFNameLen );
	};
	LPTSTR GetFName ()
	{
		return ((LPTSTR)m_FName);
	};

	void SetPhone ( PBYTE pbPhone, DWORD dwPhoneLen )
	{
		memcpy ( m_Phone, pbPhone, dwPhoneLen );
	};
	LPTSTR GetPhone ()
	{
		return ((LPTSTR)m_Phone);
	};

	void SetFax ( PBYTE pbFAX, DWORD dwFAXLen )
	{
		memcpy ( m_FAX, pbFAX, dwFAXLen );
	};
	LPTSTR GetFax ()
	{
		return ((LPTSTR)m_FAX);
	};

	void SetEMail ( PBYTE pbEMail, DWORD dwEMailLen )
	{
		memcpy ( m_EMail, pbEMail, dwEMailLen);
	};
	LPTSTR GetEMail ()
	{
		return ((LPTSTR)m_EMail);
	};

	void SetReasonCode( PBYTE pbReasonCode, DWORD dwReasonCodeLen )
	{
		memcpy ( m_ReasonCode, pbReasonCode, dwReasonCodeLen );
	};
	LPTSTR GetReasonCode ()
	{
		return ((LPTSTR)m_ReasonCode);
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwExchgCertLen;
	DWORD			m_dwSignCertLen;
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_LName[CA_NAME_LEN+1];			//LName of the revoker
	TCHAR			m_FName[CA_NAME_LEN+1];			//FName of the revoker
	TCHAR			m_Phone[CA_PHONE_LEN+1];			//phone 
	TCHAR			m_FAX[CA_FAX_LEN+1];			//FAX 
	TCHAR			m_EMail[CA_EMAIL_LEN+1];			//email - optional of the revoker
	TCHAR			m_ReasonCode[CA_REVOKE_REASONCODE_LEN+1];	//reason for revokation
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length data
	//1.Exchange Cert Blob
	//2.Signature cert blob
};


//nothing to send back.  Either the operation succeeds or fails.
class CertRevoke_Response
{
public:
	CertRevoke_Response() 
	{ 
		RequestHeader.SetRequestType(CertificateRevoke); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
	}
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwDataLen;				//Length of the Body
};

//reissue the certificate
//This is an online request.  We dont go thru' the e-mail loop etc. 
//This request accepts the old SPK and send the new SPK back.
//Then when the authenticate comes across, we do a signonly 
//of this cert and deposit the new cert into the system
class CertReissue_Request
{
public:
	CertReissue_Request() 
	{ 
		RequestHeader.SetRequestType(CertificateReissue); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szSPK,0,sizeof(m_szSPK));
		memset (m_LName,0,sizeof(m_LName));
		memset (m_FName,0,sizeof(m_FName));
		memset (m_Phone,0,sizeof(m_Phone));
		memset (m_FAX,0,sizeof(m_FAX));
		memset (m_EMail,0,sizeof(m_EMail));
		memset (m_ReasonCode,0,sizeof(m_ReasonCode));
		m_dwDataLen = 0;
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetLName ( PBYTE pbLName, DWORD dwLNameLen )
	{
		memcpy ( m_LName, pbLName, dwLNameLen );
	};
	LPTSTR GetLName ()
	{
		return ((LPTSTR)m_LName);
	};

	void SetFName ( PBYTE pbFName, DWORD dwFNameLen )
	{
		memcpy ( m_FName, pbFName, dwFNameLen );
	};
	LPTSTR GetFName ()
	{
		return ((LPTSTR)m_FName);
	};

	void SetPhone ( PBYTE pbPhone, DWORD dwPhoneLen )
	{
		memcpy ( m_Phone, pbPhone, dwPhoneLen );
	};
	LPTSTR GetPhone ()
	{
		return ((LPTSTR)m_Phone);
	};

	void SetFax ( PBYTE pbFAX, DWORD dwFAXLen )
	{
		memcpy ( m_FAX, pbFAX, dwFAXLen );
	};
	LPTSTR GetFax ()
	{
		return ((LPTSTR)m_FAX);
	};

	void SetEMail ( PBYTE pbEMail, DWORD dwEMailLen )
	{
		memcpy ( m_EMail, pbEMail, dwEMailLen);
	};
	LPTSTR GetEMail ()
	{
		return ((LPTSTR)m_EMail);
	};

	void SetReasonCode( PBYTE pbReasonCode, DWORD dwReasonCodeLen )
	{
		memcpy ( m_ReasonCode, pbReasonCode, dwReasonCodeLen );
	};
	LPTSTR GetReasonCode ()
	{
		return ((LPTSTR)m_ReasonCode);
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;					//Request Header
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_LName[CA_NAME_LEN+1];			//LName of the reissuer
	TCHAR			m_FName[CA_NAME_LEN+1];			//FName of the reissuer
	TCHAR			m_Phone[CA_PHONE_LEN+1];			//phone 
	TCHAR			m_FAX[CA_FAX_LEN+1];			//FAX
	TCHAR			m_EMail[CA_EMAIL_LEN+1];			//email - optional of the reissuer
	TCHAR			m_ReasonCode[CA_REVOKE_REASONCODE_LEN+1];	//reason for reissue
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable portion of this request
	//no variable portion here
};




class CertReissue_Response
{
public:
	CertReissue_Response() 
	{ 
		RequestHeader.SetRequestType(CertificateReissue); 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szSPK,0,sizeof(m_szSPK));
		m_dwDataLen = 0;
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
    		memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];	//Registration Request Id
	TCHAR			m_szSPK[LSSPK_LEN];					//new SPK
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable Portion of the response
	//no variable portion here
};

/*
 * NewLicense KeyPack Requests
 */
class ReissueLKP_Request
{
public:
	ReissueLKP_Request()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(ReissueLicenseRequest);
		memset (m_szSPK,0,sizeof(m_szSPK));
	};
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};
	void SetCertBlobLen (DWORD dwCertBlobLen)
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ()
	{
		return (ntohl(m_dwCertBlobLen));
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	TCHAR			m_szSPK[LSSPK_LEN];			//SPK
	DWORD			m_dwCertBlobLen;			//certificate length
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable portion of the request
	//1.Cert Blob 
};

class ReissueLKP_Response
{
public:
	ReissueLKP_Response()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(ReissueLicenseRequest);

	}
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetLKPLength(DWORD dwLKPLen)
	{
		m_dwLKPLen = htonl(dwLKPLen);
	};

	DWORD GetLKPLength()
	{
		return ( ntohl(m_dwLKPLen));
	};


	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };
	RequestHeader	RequestHeader;
	DWORD			m_dwLKPLen;
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable part of the request
	//1. Last LKP issued

};

class NewLKP_Request
{
public:
	NewLKP_Request () 
	{ 
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(NewLicenseRequest);
		memset (m_szSPK,0,sizeof(m_szSPK));
		m_dwRetailSPKCount = 0;
		m_dwCertBlobLen = 0;
		m_dwNewLKPRequestLen = 0;

	};

	~NewLKP_Request () {};	

	void SetCertBlobLen ( DWORD dwCertBlobLen )
	{
		m_dwCertBlobLen = htonl(dwCertBlobLen);
	};

	DWORD GetCertBlobLen ( )
	{
		return( ntohl(m_dwCertBlobLen));
	};

	void SetNewLKPRequestLen ( DWORD dwNewLKPRequestLen )
	{
		m_dwNewLKPRequestLen = htonl(dwNewLKPRequestLen);
	};

	DWORD GetNewLKPRequestLen ( )
	{
		return( ntohl(m_dwNewLKPRequestLen ));
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};

	void SetRetailSPKCount (DWORD dwRetailSPKCount)
	{
		assert(dwRetailSPKCount <= MAX_RETAILSPKCOUNT );
		m_dwRetailSPKCount = htonl(dwRetailSPKCount);
	};

	DWORD GetRetailSPKCount()
	{
		return ntohl(m_dwRetailSPKCount);
	};


	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwCertBlobLen;
	DWORD			m_dwNewLKPRequestLen;
	DWORD			m_dwRetailSPKCount;
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	DWORD			m_dwDataLen;				//Length of the Body
	//Variable length data here
	//1.Cert Blob
	//2. New LKP Request Blob
	//3. As many 25 character Retail SPK items as specified in count above
};

class NewLKP_Response
{
public:
	NewLKP_Response() 
	{ 	
		RequestHeader.SetRequestType(NewLicenseRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset ( m_szLicenseReqId,0,sizeof(m_szLicenseReqId));
		memset ( m_dwRetailSPKStatus, 0, sizeof(m_dwRetailSPKStatus));
	};
	
	void SetLKPLength(DWORD dwLKPLen)
	{
		m_dwLKPLen = htonl(dwLKPLen);
	};

	DWORD GetLKPLength()
	{
		return ( ntohl(m_dwLKPLen));
	};

	void SetRegRequestId (PBYTE pbRegReqId, DWORD dwRegReqIdLen)
	{
        if( pbRegReqId != NULL )
        {
		    memcpy (m_szRegRequestId, pbRegReqId, dwRegReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetLicenseReqId (PBYTE pbLicenseReqId, DWORD dwLicenseReqIdLen)
	{
		memcpy (m_szLicenseReqId, pbLicenseReqId, dwLicenseReqIdLen);
	};

	LPTSTR GetLicenseReqId  ()
	{
		return ((LPTSTR)m_szLicenseReqId);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	void SetRetailSPKStatus ( DWORD dwIndex, TCHAR dwStatus )
	{
		assert ( dwIndex < MAX_RETAILSPKCOUNT );
		m_dwRetailSPKStatus[dwIndex] = dwStatus;
	};
	TCHAR GetRetailSPKStatus(DWORD dwIndex )
	{
		assert ( dwIndex < MAX_RETAILSPKCOUNT );
		return m_dwRetailSPKStatus[dwIndex];
	};

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwLKPLen;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szLicenseReqId[REQUEST_ID_LEN];	
	TCHAR			m_dwRetailSPKStatus[MAX_RETAILSPKCOUNT];
	DWORD			m_dwDataLen;				//Length of the Body	
	//LKP here

};

class NewLKP_AckRequest
{
public:
	NewLKP_AckRequest()
	{
		RequestHeader.SetRequestType(LKPDownloadAckRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset ( m_szLicenseReqId,0,sizeof(m_szLicenseReqId));
		m_bAckType = 0;
		m_dwDataLen = 0;
	};

	void SetRegRequestId (PBYTE pbReqId, DWORD dwReqIdLen)
	{
        if(pbReqId != NULL)
        {
		    memcpy ( m_szRegRequestId, pbReqId, dwReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ( (LPTSTR)m_szRegRequestId);
	};

	void SetAckType ( BYTE bAckType )
	{
		m_bAckType = bAckType;
	};

	BYTE GetAckType ()
	{
		return m_bAckType;
	};

	void SetLicenseReqId (PBYTE pbLicenseReqId, DWORD dwLicenseReqIdLen)
	{
		memcpy (m_szLicenseReqId, pbLicenseReqId, dwLicenseReqIdLen);
	};

	LPTSTR GetLicenseReqId  ()
	{
		return ((LPTSTR)m_szLicenseReqId);
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;		
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szLicenseReqId[REQUEST_ID_LEN];
	BYTE			m_bAckType;					//1 = success 2 = fail
	DWORD			m_dwDataLen;				//Length of the Body	
};

class NewLKP_AckResponse
{
public:
	NewLKP_AckResponse()
	{
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		RequestHeader.SetRequestType(LKPDownloadAckRequest);
		m_dwDataLen = 0;
	}

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwDataLen;				//Length of the Body		
	//nothing here
};

/*
 * Certificate Acknowledgement Request / Interactions
 */

class Certificate_AckRequest
{
public:
	Certificate_AckRequest () 
	{ 
		RequestHeader.SetRequestType(CertificateDownloadAck);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset (m_szRegRequestId,0,sizeof(m_szRegRequestId));
		m_bAckType = 0;
		m_dwDataLen = 0;
	};

	~Certificate_AckRequest () {};
	
	void SetRegRequestId (PBYTE pbReqId, DWORD dwReqIdLen)
	{
        if(pbReqId != NULL)
        {
		    memcpy ( m_szRegRequestId, pbReqId, dwReqIdLen );
        }
	};

	LPTSTR GetRegRequestId ()
	{
		return ( (LPTSTR)m_szRegRequestId);
	};

	void SetAckType ( BYTE bAckType )
	{
		m_bAckType = bAckType;
	};

	BYTE GetAckType ()
	{
		return m_bAckType;
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	BYTE			m_bAckType;					//1 = success 2 = fail
	DWORD			m_dwDataLen;				//Length of the Body		
	//no variable data
};

class Certificate_AckResponse
{
public:
	Certificate_AckResponse () 
	{ 
		RequestHeader.SetRequestType(CertificateDownloadAck);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
	};

	~Certificate_AckResponse () {};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwDataLen;				//Length of the Body		
	//no variable data
};


//Request for sendind the New CErt 
class NewCert_Request
{

public:
	NewCert_Request () 
	{ 
		RequestHeader.SetRequestType(CertificateRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
	};

	~NewCert_Request () {};

	DWORD GetExchgPKCS10Length() 
	{ 
		return ( ntohl(m_dwExchPKCS10Length) ); 
	};

	void SetExchgPKCS10Length(DWORD dwExchPKCS10Length) 
	{ 
		m_dwExchPKCS10Length = htonl(dwExchPKCS10Length); 
	};

	DWORD GetSignPKCS10Length() 
	{ 
		return ( ntohl(m_dwSignPKCS10Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS10Length) 
	{ 
		m_dwSignPKCS10Length = htonl(dwSignPKCS10Length); 
	};	

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetServerName(TCHAR * tc)
	{
		_stprintf(m_szLServerName, _T("%.*s"), MAX_COMPUTERNAME_LENGTH + 4, tc);
	}

	TCHAR * GetServerName(void)
	{
		return m_szLServerName;
	}
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS10Length;
	DWORD			m_dwSignPKCS10Length;
	CERTCUSTINFO	stCertInfo;
	TCHAR			m_szLServerName[MAX_COMPUTERNAME_LENGTH + 5];

	DWORD			m_dwDataLen;				//Length of the Body		
	//Variable data goes here
	//First Exchg PKCS10
	//Second Sign PKCS10
	
};

//New Certificate request response structure
class NewCert_Response
{
public:
	NewCert_Response () 
	{ 
		RequestHeader.SetRequestType(CertificateRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset ( m_szSPK, 0, sizeof(m_szSPK ));
		memset ( m_szRegRequestId, 0, sizeof(m_szRegRequestId) );
	};

	~NewCert_Response () {};

	
	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK ( PBYTE pbSPK, DWORD dwSPKLen)
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ( )
	{
		return ((LPTSTR)m_szSPK);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szSPK[LSSPK_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data part
	//1.Exchange PKCS7
	//2.Signature PKCS7
	//3.Root Cert
};

//Certificate sign only request structure
class CertificateSignOnly_Request
{
public:
	CertificateSignOnly_Request()
	{
		RequestHeader.SetRequestType(CertificateSignOnly);
		memset (m_szSPK,0,sizeof(m_szSPK));
	};

	~CertificateSignOnly_Request(){};	

	DWORD GetExchgPKCS10Length() 
	{ 
		return ( ntohl(m_dwExchPKCS10Length) ); 
	};

	void SetExchgPKCS10Length(DWORD dwExchPKCS10Length) 
	{ 
		m_dwExchPKCS10Length = htonl(dwExchPKCS10Length); 
	};

	DWORD GetSignPKCS10Length() 
	{ 
		return ( ntohl(m_dwSignPKCS10Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS10Length) 
	{ 
		m_dwSignPKCS10Length = htonl(dwSignPKCS10Length); 
	};


	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};

	void SetSPK (PBYTE pbSPK, DWORD dwSPKLen )
	{
		memcpy ( m_szSPK, pbSPK, dwSPKLen );
	};

	LPTSTR GetSPK ()
	{
		return ( (LPTSTR) m_szSPK );
	};
	void SetServerName(TCHAR * tc)
	{
		_stprintf(m_szLServerName, _T("%.*s"), MAX_COMPUTERNAME_LENGTH + 4, tc);
	}

	TCHAR * GetServerName(void)
	{
		return m_szLServerName;
	}

	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS10Length;
	DWORD			m_dwSignPKCS10Length;	
	TCHAR			m_szSPK[LSSPK_LEN];				//SPK
	TCHAR			m_szLServerName[MAX_COMPUTERNAME_LENGTH + 5];
	DWORD			m_dwDataLen;				//Length of the Body
	//variable data goes here
	//First Exchg PKCS10
	//Second Sign PKCS10
	

};
//Certificate sign only response structure
class CertificateSignOnly_Response
{
public:
	CertificateSignOnly_Response()
	{
		memset(m_szRegRequestId,0,sizeof(m_szRegRequestId));
		RequestHeader.SetRequestType(CertificateSignOnly);
	};

	~CertificateSignOnly_Response(){};
	
	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS7Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	DWORD			m_dwDataLen;				//Length of the Body				
	//Variable data
	//first ExchgPKCS7
	//Second SignPKCS7
	//third Root CErt
};

class CertificateDownload_Request
{
public:
	CertificateDownload_Request () 
	{ 
		RequestHeader.SetRequestType(CertificateDownload);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
		memset ( m_szPIN,0,sizeof(m_szPIN));
	};

	~CertificateDownload_Request  () {};
	
	void SetPIN ( PBYTE pbPIN, DWORD dwPINLen )
	{
        if( pbPIN != NULL )
        {
		    memcpy ( m_szPIN, pbPIN, dwPINLen );
        }
	};

	LPTSTR GetPIN ( )
	{
		return ((LPTSTR)m_szPIN);
	};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			m_szPIN[PIN_LEN];
	DWORD			m_dwDataLen;				//Length of the Body
	//no variable data part!!
};


class CertificateDownload_Response
{
public:
	CertificateDownload_Response () 
	{ 
		RequestHeader.SetRequestType(CertificateDownload);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		memset(m_szRegRequestId,0,sizeof(m_szRegRequestId));
		memset(m_szSPK,0,sizeof(m_szSPK));
	};

	~CertificateDownload_Response  () {};	

	DWORD GetExchgPKCS7Length() 
	{ 
		return ( ntohl(m_dwExchPKCS7Length) ); 
	};

	void SetExchgPKCS7Length(DWORD dwExchPKCS7Length) 
	{ 
		m_dwExchPKCS7Length = htonl(dwExchPKCS7Length); 
	};

	DWORD GetSignPKCS7Length() 
	{ 
		return ( ntohl(m_dwSignPKCS7Length) ); 
	};

	void SetSignPKCS10Length(DWORD dwSignPKCS7Length) 
	{ 
		m_dwSignPKCS7Length = htonl(dwSignPKCS7Length); 
	};
	
	DWORD GetRootCertLength() 
	{ 
		return ( ntohl(m_dwRootCertLength) ); 
	};

	void SetRootCertLength(DWORD dwRootCertLength) 
	{ 
		m_dwRootCertLength = htonl(dwRootCertLength); 
	};

	void SetRegRequestId ( PBYTE pbRegRequestId, DWORD dwRegRequestIdLen )
	{
        if( pbRegRequestId != NULL )
        {
		    memcpy ( m_szRegRequestId, pbRegRequestId, dwRegRequestIdLen );
        }
	};

	LPTSTR GetRegRequestId ( )
	{
		return ((LPTSTR)m_szRegRequestId);
	};

	void SetSPK ( PBYTE pbSPK, DWORD dwSPKLen)
	{
        if(pbSPK != NULL)
        {
		    memcpy ( m_szSPK, pbSPK, dwSPKLen );
        }
	};

	LPTSTR GetSPK ( )
	{
		return ((LPTSTR)m_szSPK);
	};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;	
	DWORD			m_dwExchPKCS7Length;
	DWORD			m_dwSignPKCS7Length;
	DWORD			m_dwRootCertLength;
	TCHAR			m_szRegRequestId[REQUEST_ID_LEN];
	TCHAR			m_szSPK[LSSPK_LEN];	
	DWORD			m_dwDataLen;				//Length of the Body					
	//variable data part
	//1.Exchange PKCS7
	//2.Signature PKCS7
	//3.Root Cert
};

//ping request and response class
class Ping_Request
{
public:
	Ping_Request () 
	{ 
		RequestHeader.SetRequestType(PingRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		m_dwDataLen = 0;
		_tcscpy ( tszPingReqData, _TEXT("Houston we have a problem"));
	};

	~Ping_Request () {};

	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)	
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			tszPingReqData[32];			//32 characters
	DWORD			m_dwDataLen;				//Length of the Body
};

class Ping_Response
{
public:
	Ping_Response()
	{
		RequestHeader.SetRequestType(PingRequest);
		RequestHeader.SetLanguageId(GetSystemDefaultLangID());
		_tcscpy ( tszPingResponse, _TEXT("Beam'er up Scottie!"));
	}

	~Ping_Response() {};
	
	DWORD GetDataLen()				
	{ 
		return ntohl(m_dwDataLen); 
	};

	void SetDataLen(DWORD dwDataLen)
	{ 
		m_dwDataLen = htonl(dwDataLen); 
	};
	
	BYTE *data()			{ return (BYTE *)(&m_dwDataLen+1); };

	RequestHeader	RequestHeader;
	TCHAR			tszPingResponse[32];
	DWORD			m_dwDataLen;				//Length of the Body
};


//stream header declarations
#define BLOCK_TYPE_NAME			1
#define BLOCK_TYPE_VALUE		2
#define BLOCK_TYPE_PROP_PAIR	3


typedef struct
{
	long		m_wType;
	long		m_lNameSize;
	long		m_lValueSize;

	void SetType (long lType) {m_wType = htonl(lType);};
	long GetType (){return  ntohl(m_wType);};
	void SetNameSize(long lNameSize) {m_lNameSize = htonl(lNameSize);};
	long GetNameSize(){return (ntohl(m_lNameSize));};
	void SetValueSize(long lValueSize){m_lValueSize = htonl(lValueSize);};
	long GetValueSize(){return (ntohl(m_lValueSize));};
} BLOCK_HDR;

#define STREAM_HDR_TITLE		_TEXT("ICB")			//header title
#define STREAM_HDR_TYPE			1						//header type

typedef struct
{
	TCHAR		m_szTitle[4];			//will be ICB for now 
	DWORD		m_wHeader;				//reserved for now will be implemented later
										//set it to 0x0000
	DWORD		m_itemCount;			//number of items in the stream!

	void SetHeader ( DWORD wHeader ) {m_wHeader = htonl(wHeader);};
	DWORD GetHeader (){return ntohl(m_wHeader);};
	void SetItemCount ( DWORD ItemCount ) { m_itemCount = htonl(ItemCount);};
	DWORD GetItemCount (){return ntohl(m_itemCount);};

} STREAM_HDR;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\getmode.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>
#include "mode.h"
#include "fonts.h"

static DWORD	g_dwAuthRetCode	= ERROR_SUCCESS;

static WIZCONNECTION g_enumPrevMethod = CONNECTION_DEFAULT;

DWORD WINAPI PingThread(void *pData)
{
	g_dwAuthRetCode = PingCH();	
	ExitThread(0);
	return 0;
}


LRW_DLG_INT CALLBACK 
GetModeDlgProc(IN HWND     hwnd,	
			   IN UINT     uMsg,		
			   IN WPARAM   wParam,	
			   IN LPARAM   lParam)
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hwndComboBox;
	TCHAR   lpBuffer[ 512];
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );  

		hwndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
		assert(hwndComboBox != NULL); // Somebody has messed with the Res. Files.
		
		// Let user choose the mode of registration with Internet being default
		memset(lpBuffer,0,sizeof(lpBuffer));
		dwRetCode = LoadString(GetInstanceHandle(), IDS_INTERNETMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));        
		assert(dwRetCode != 0);        
		ComboBox_AddString(hwndComboBox,lpBuffer);		

		memset(lpBuffer,0,sizeof(lpBuffer));		
		dwRetCode = LoadString(GetInstanceHandle(), IDS_WWWMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
		assert(dwRetCode != 0);
		ComboBox_AddString(hwndComboBox,lpBuffer);

		memset(lpBuffer,0,sizeof(lpBuffer));
		dwRetCode = LoadString(GetInstanceHandle(), IDS_TELEPHONEMODE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
		assert(dwRetCode != 0);
		ComboBox_AddString(hwndComboBox,lpBuffer);
		

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
		   GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT) //Partially fix bug # 577
    			ComboBox_SetCurSel(hwndComboBox, 0);			

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW )
    			ComboBox_SetCurSel(hwndComboBox, 1);

		if(GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE )
    			ComboBox_SetCurSel(hwndComboBox, 2);

        SetConnectionMethodText(hwnd);

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if(HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_MODEOFREG)
            SetConnectionMethodText(hwnd);

		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
			hwndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
			assert(hwndComboBox != NULL); // Somebody has messed with the Res. Files.

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );                
                break;

            case PSN_WIZNEXT:
				// What did the user choose ??
				dwRetCode = ComboBox_GetCurSel(hwndComboBox);
				assert(dwRetCode >= 0 && dwRetCode <= 2);

				switch(dwRetCode)
				{
				case 0:
					// Only applicable for Registration, so the Ping Goes Thru'
					dwRetCode = ShowProgressBox(hwnd, PingThread, 0, 0, 0);
					if(g_dwAuthRetCode == ERROR_SUCCESS)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_INTERNET);
						dwNextPage = GetGlobalContext()->GetEntryPoint();
					}
					else
					{
						LRMessageBox(hwnd,g_dwAuthRetCode,IDS_WIZARD_MESSAGE_TITLE,LRGetLastError());
						dwNextPage = IDD_DLG_GETREGMODE;
					}
					break;

				case 1:
					GetGlobalContext()->SetActivationMethod(CONNECTION_WWW);
					dwNextPage = IDD_DLG_WWWREG;
					break;

				case 2:
					GetGlobalContext()->SetActivationMethod(CONNECTION_PHONE);
					//Check if the Required Registry key is ok or not
					dwRetCode = GetGlobalContext()->CheckRegistryForPhoneNumbers();
					if(dwRetCode != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd,dwRetCode,NULL,LRGetLastError());
						dwNextPage = IDD_DLG_GETREGMODE;
					}
					else
						dwNextPage = IDD_DLG_COUNTRYREGION;

					break;

				default:
					GetGlobalContext()->SetActivationMethod(CONNECTION_DEFAULT);
					dwNextPage = IDD_DLG_GETREGMODE;
					break;
				}
				
		
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;

				if (dwNextPage != IDD_DLG_GETREGMODE)
				{
					LRPush(IDD_DLG_GETREGMODE);
				}

                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}






LRW_DLG_INT CALLBACK 
CountryRegionProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hWndCSR = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION );

	LVFINDINFO	lvFindInfo;
	int			nItem = 0;
	HWND	hWndListBox = 0 ;
	

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) 
    {	
    case WM_INITDIALOG:		

		pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
		LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		hWndListBox = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION );		

		//Setup columns in list view
		{
			LV_COLUMN	lvColumn;
			TCHAR		lpszHeader[ 128];
			lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			lvColumn.fmt = LVCFMT_LEFT;
			lvColumn.cx  = 250;

			LoadString(GetInstanceHandle(), IDS_COUNTRYREGION_HEADER, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndCSR, 0, &lvColumn);

			lvColumn.pszText = _TEXT("");
			lvColumn.cx = 0;
			ListView_InsertColumn(hWndCSR, 1, &lvColumn);            
		}					

		g_enumPrevMethod = GetGlobalContext()->GetActivationMethod();

		if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
		{
			dwRetCode = PopulateCountryRegionListBox(hWndCSR);
			//fix bug 575 BEGIN
			memset(&lvFindInfo,0,sizeof(lvFindInfo));
			lvFindInfo.flags = LVFI_STRING;
			lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;
			nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);				

				
			ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
			ListView_SetSelectionMark(hWndListBox,nItem);
			ListView_SetSelectionMark(hWndListBox,nItem);
			//fix bug 575 END
		}
	
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
	
				//
				// If the PrevMethod and The Current method don't match
				// then Country/Region list box must be reloaded
				//
				hWndListBox = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION );		
				if( GetGlobalContext()->GetActivationMethod()  != g_enumPrevMethod )
				{
					if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
					{
						dwRetCode = PopulateCountryRegionListBox(hWndCSR);
					}
					
					g_enumPrevMethod = GetGlobalContext()->GetActivationMethod();
				}

				nItem = ListView_GetSelectionMark(hWndCSR);
				//Select the previous selected country
				if (nItem ==-1 && GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
				{
					dwRetCode = PopulateCountryRegionListBox(hWndCSR);
					//fix bug 575 BEGIN
					memset(&lvFindInfo,0,sizeof(lvFindInfo));
					lvFindInfo.flags = LVFI_STRING;
					lvFindInfo.psz	 = GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion;

					nItem = ListView_FindItem(hWndListBox,-1,&lvFindInfo);				
						
						
					ListView_SetItemState(hWndListBox,nItem,LVIS_SELECTED,LVIS_SELECTED);
					ListView_SetSelectionMark(hWndListBox,nItem);
					ListView_SetSelectionMark(hWndListBox,nItem);
					//fix bug 575 END
				}

				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
				// What did the user choose ??
				{
					TCHAR lpVal[MAX_COUNTRY_NUMBER_LENGTH + 1];
					TCHAR lpName[MAX_COUNTRY_NAME_LENGTH + 1];
					int nItem = ListView_GetSelectionMark(hWndCSR);

					if (nItem != -1 && nItem != 0)
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 1;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = MAX_COUNTRY_NAME_LENGTH + 1;

						ListView_GetItem(hWndCSR, &lvItem);				

						if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
						{
							GetGlobalContext()->SetCSRNumber(lpVal);

                            ListView_GetItemText(hWndCSR, nItem, 0, lpName, sizeof(lpName)/sizeof(TCHAR));
                            GetGlobalContext()->SetInRegistry(REG_LRWIZ_CSPHONEREGION,lpName);
						}
					}
					else
					{
						LRMessageBox(hwnd, IDS_ERR_NOCOUNTRYSELECTED,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_DLG_COUNTRYREGION;
						bStatus = -1;
						LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
						break;
					}
				}

				if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE)
				{
					dwNextPage = GetGlobalContext()->GetEntryPoint();
				}
				else
				{
					dwNextPage = IDD_CONTACTINFO1;
				}
/*
				dwNextPage = IDD_DLG_COUNTRYREGION;
				switch( GetGlobalContext()->GetWizAction() )
				{
				case WIZACTION_REGISTERLS:
				case WIZACTION_CONTINUEREGISTERLS:
					dwNextPage = IDD_DLG_TELREG;
					break;

				case WIZACTION_REREGISTERLS:
					break;

				case WIZACTION_UNREGISTERLS:
					break;

				case WIZACTION_DOWNLOADLKP:
					break;
				}

*/				bStatus = -1;
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				if (dwNextPage != IDD_DLG_COUNTRYREGION)
				{
					LRPush(IDD_DLG_COUNTRYREGION);
				}

                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensecodelite.h ===
#ifndef _LICENSECODELITE_H_
#define _LICENSECODELITE_H_

#define INVALID_SERIAL_NUMBER		1
#define INVALID_PRODUCT_KEY			2
#define	INVALID_GROUP_ID			3

DWORD GetLCProductType(TCHAR * tcLicenceCode, TCHAR ** tcProductType, DWORD * dwGroupID);

#endif //_LICENSECODELITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\global.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "precomp.h"
#include "afxcoll.h"
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
#include <wincrypt.h>
#include "tlsapip.h"
#include "global.h"
#include "utils.h"
#include "assert.h"
#include "lrwizapi.h"
#include "lmcons.h"
#include "lmerr.h"
#include "lmserver.h"
#include "trust.h"
#include "chstruct.h"
#include "lkplite.h"
#include "licensecodelite.h"
#include <wininet.h>

#define  ACTIVATIONMETHOD_KEY           "ACTIVATIONMETHOD"
#define  CSRNUMBER_KEY                  "CSRNUMBER"
#ifdef IGNORE_EXPIRATION
#define LICENSE_EXPIRATION_IGNORE L"SOFTWARE\\Microsoft\\TermServLicensing\\IgnoreLicenseExpiration"
#endif

CGlobal::CGlobal()
{   

    m_hWndParent        =   NULL;
    m_hInstance         =   NULL;

    m_lpstrLSName       =   NULL;
    m_lpwstrLSName      =   NULL;

    m_lpstrCHServer     =   NULL;
    m_lpstrCHExtension  =   NULL;

    m_dwErrorCode       =   0;

    m_pReqAttr          =   NULL;

    m_dwReqAttrCount    =   0;

    m_pRegAttr          =   NULL;
    m_dwRegAttrCount    =   NULL;
    m_dwLSStatus        =   LSERVERSTATUS_UNREGISTER;

    m_ContactData.Initialize();
    m_LicData.Initialize();
    m_ActivationMethod = CONNECTION_INTERNET;

    m_dwExchangeCertificateLen  = 0;
    m_pbExchangeCertificate     = NULL;

    m_dwSignCertificateLen  = 0;
    m_pbSignCertificate     = NULL;

    m_dwExtenstionValueLen  = 0;
    m_pbExtensionValue      = NULL;

    m_lpstrPIN          = NULL;

    m_dwRequestType = REQUEST_NULL;

    m_WizAction = WIZACTION_REGISTERLS;
    m_hOpenDirect = NULL;
    m_hConnect = NULL;
    m_hRequest = NULL;

    m_phLSContext = NULL;

    m_pRegistrationID[ 0] = m_pLicenseServerID[ 0] = 0;

    m_dwRefresh = 0;

    m_lpCSRNumber[ 0]   = 0;
    m_lpWWWSite[0]      = 0;

    m_pLSLKP[ 0] = m_pLSSPK[ 0] = 0;

    m_dwLastRetCode     = 0;

    m_dwLangId  = 0;

    m_fSupportConcurrent = FALSE;

    m_fSupportWhistlerCAL = FALSE;

    m_WizType = WIZTYPE_ACTIVATION;

    InitSPKList();

    // Initialize the Wizard Page stack
    ClearWizStack();
}



void CGlobal::FreeGlobal()
{
    if (m_pbSignCertificate != NULL)
    {
        LocalFree(m_pbSignCertificate);
        m_pbSignCertificate = NULL;
    }

    if (m_pbExchangeCertificate != NULL)
    {
        LocalFree(m_pbExchangeCertificate);
        m_pbExchangeCertificate = NULL;
    }

    if (m_lpwstrLSName)
    {
        delete m_lpwstrLSName;
        m_lpwstrLSName = NULL;
    }

    if(m_lpstrCHServer)
    {
        delete m_lpstrCHServer;
        m_lpstrCHServer = NULL;
    }

    if (m_lpstrCHExtension)
    {
        delete m_lpstrCHExtension;
        m_lpstrCHExtension = NULL;
    }

    if(m_pbExtensionValue)
    {
        delete m_pbExtensionValue;
        m_pbExtensionValue = NULL;
    }

    if(m_lpstrPIN)
    {
        delete m_lpstrPIN;
        m_lpstrPIN = NULL;
    }

    m_csaCountryDesc.RemoveAll();
    m_csaCountryCode.RemoveAll();

    m_csaProductDesc.RemoveAll();
    m_csaProductCode.RemoveAll();
    
    m_csaDeactReasonCode.RemoveAll();
    m_csaDeactReasonDesc.RemoveAll();

    m_csaReactReasonCode.RemoveAll();
    m_csaReactReasonDesc.RemoveAll();
}


CGlobal::~CGlobal()
{
    FreeGlobal();
}


void CGlobal::ClearWizStack()
{
    DWORD dwIndex;

    m_dwTop     = 0;

    for(dwIndex = 0 ; dwIndex < NO_OF_PAGES ; dwIndex++)
        m_dwWizStack[dwIndex] = 0;
}



PCONTACTINFO CGlobal::GetContactDataObject()
{
    return &m_ContactData;
}


PTSLICINFO CGlobal::GetLicDataObject()
{
    return &m_LicData;
}



DWORD CGlobal::InitGlobal()
{
    DWORD   dwRetCode = ERROR_SUCCESS;

    DWORD   dwDataLen       = 0;
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_SZ;
    HKEY    hKey            = NULL;

    LPTSTR  lpszValue       = NULL;
    LPTSTR  lpszDelimiter   = (LPTSTR)L"~";

    CString sCountryDesc;
    LPTSTR  lpTemp          = NULL;

    TLSPrivateDataUnion     getParm;
    PTLSPrivateDataUnion    pRtn    =   NULL;
    error_status_t          esRPC   =   ERROR_SUCCESS;
    DWORD                   dwRetDataType = 0;
    DWORD                   dwSupportFlags;
    TCHAR   lpBuffer[ 1024];
    

    m_ContactData.Initialize();
    m_LicData.Initialize();

    m_dwLSStatus        =   LSERVERSTATUS_UNREGISTER;
    m_phLSContext = NULL;


    //
    // Load Countries from the String Table
    //
    LoadCountries();


    LoadReasons();

    //
    // Get CH URL from the LS Registry
    //
    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_PARAMS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   

    //
    //LR State
    //
    m_dwLRState = 0;
    dwType      = REG_DWORD;
    dwDataLen   = sizeof(m_dwLRState);
    RegQueryValueEx(hKey,
                    REG_LRWIZ_STATE,
                    0,
                    &dwType,
                    (LPBYTE)&m_dwLRState,
                    &dwDataLen
                    );

    lpBuffer[ 0] = 0;
    GetFromRegistry(ACTIVATIONMETHOD_KEY, lpBuffer, FALSE);
    if (_tcslen(lpBuffer) != 0)
    {
        m_ActivationMethod = (WIZCONNECTION) _ttoi(lpBuffer);
    }
    else
    {
        m_ActivationMethod = CONNECTION_DEFAULT; //Partially fix bug # 577
    }

    if ((m_ActivationMethod != CONNECTION_DEFAULT)
        && (m_ActivationMethod != CONNECTION_INTERNET)
        && (m_ActivationMethod != CONNECTION_WWW)
        && (m_ActivationMethod != CONNECTION_PHONE))
    {
        m_ActivationMethod = CONNECTION_DEFAULT;
    }

    GetFromRegistry(CSRNUMBER_KEY, m_lpCSRNumber, FALSE);


    //
    // LKP Request Count
    //
    m_dwLRCount = 0;
    dwType      = REG_DWORD;
    dwDataLen   = sizeof(m_dwLRCount);
    RegQueryValueEx(hKey,
                    REG_LR_COUNT,
                    0,
                    &dwType,
                    (LPBYTE)&m_dwLRCount,
                    &dwDataLen
                    );


    // dwDataLen includes the null terminating char.
    // So if the key is empty,dwDataLen is 2 bytes, not 0. 
    // See raid bug id : 336.
    //
    //CH URL
    //
    dwType      = REG_SZ;
    dwDataLen   = 0;
    RegQueryValueEx(hKey,
                    REG_CH_SERVER,
                    0,
                    &dwType,
                    NULL,
                    &dwDataLen
                    );

    if(dwDataLen <= sizeof(TCHAR))
    {
        dwRetCode = IDS_ERR_CHURLKEY_EMPTY;
        goto done;
    }

    m_lpstrCHServer = new TCHAR[dwDataLen+1];
    memset(m_lpstrCHServer, 0, (dwDataLen+1)*sizeof(TCHAR) );
    
    RegQueryValueEx(hKey,
                    REG_CH_SERVER,
                    0,
                    &dwType,
                    (LPBYTE)m_lpstrCHServer,
                    &dwDataLen
                    );

    //
    //CH Extension
    //
    dwType      = REG_SZ;
    dwDataLen   = 0;
    RegQueryValueEx(hKey,
                    REG_CH_EXTENSION,
                    0,
                    &dwType,
                    NULL,
                    &dwDataLen
                    );

    if(dwDataLen <= sizeof(TCHAR))
    {
        dwRetCode = IDS_ERR_CHURLKEY_EMPTY;
        goto done;
    }

    m_lpstrCHExtension = new TCHAR[dwDataLen+1];
    memset(m_lpstrCHExtension, 0, (dwDataLen+1)*sizeof(TCHAR) );
    
    RegQueryValueEx(hKey,
                    REG_CH_EXTENSION,
                    0,
                    &dwType,
                    (LPBYTE)m_lpstrCHExtension,
                    &dwDataLen
                    );


    //
    // WWW site address
    //
    dwType      = REG_SZ;
    dwDataLen   = sizeof(m_lpWWWSite);
    dwRetCode = RegQueryValueEx(hKey,
                    REG_WWW_SITE,
                    0,
                    &dwType,
                    (LPBYTE)m_lpWWWSite,
                    &dwDataLen
                    );

    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_CHURLKEY_EMPTY; 
        goto done;
    }

    GetFromRegistry(szOID_STREET_ADDRESS, m_ContactData.sContactAddress.GetBuffer(CA_ADDRESS_LEN + 1), FALSE);
    m_ContactData.sContactAddress.ReleaseBuffer();
    GetFromRegistry(szOID_POSTAL_CODE, m_ContactData.sZip.GetBuffer(CA_ZIP_LEN + 1), FALSE);
    m_ContactData.sZip.ReleaseBuffer();
    GetFromRegistry(szOID_LOCALITY_NAME, m_ContactData.sCity.GetBuffer(CA_CITY_LEN + 1), FALSE);
    m_ContactData.sCity.ReleaseBuffer();
    GetFromRegistry(szOID_DESCRIPTION, m_ContactData.sCountryCode.GetBuffer(LR_COUNTRY_CODE_LEN + 1), FALSE);
    m_ContactData.sCountryCode.ReleaseBuffer();
    GetFromRegistry(szOID_COUNTRY_NAME, m_ContactData.sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN + 1), FALSE);
    m_ContactData.sCountryDesc.ReleaseBuffer();
    GetFromRegistry(szOID_STATE_OR_PROVINCE_NAME, m_ContactData.sState.GetBuffer(CA_STATE_LEN + 1), FALSE);
    m_ContactData.sState.ReleaseBuffer();
    GetFromRegistry(szOID_ORGANIZATION_NAME, m_ContactData.sCompanyName.GetBuffer(CA_COMPANY_NAME_LEN + 1), FALSE);
    m_ContactData.sCompanyName.ReleaseBuffer();
    GetFromRegistry(szOID_ORGANIZATIONAL_UNIT_NAME, m_ContactData.sOrgUnit.GetBuffer(CA_ORG_UNIT_LEN + 1), FALSE);
    m_ContactData.sOrgUnit.ReleaseBuffer();
    GetFromRegistry(szOID_SUR_NAME, m_ContactData.sContactLName.GetBuffer(CA_NAME_LEN + 1), FALSE);
    m_ContactData.sContactLName.ReleaseBuffer();
    GetFromRegistry(szOID_COMMON_NAME, m_ContactData.sContactFName.GetBuffer(CA_NAME_LEN + 1), FALSE);
    m_ContactData.sContactFName.ReleaseBuffer();
    GetFromRegistry(szOID_RSA_emailAddr, m_ContactData.sContactEmail.GetBuffer(CA_EMAIL_LEN + 1), FALSE);
    m_ContactData.sContactEmail.ReleaseBuffer();
    GetFromRegistry(szOID_BUSINESS_CATEGORY, m_ContactData.sProgramName.GetBuffer(PROGRAM_NAME_MAX_LENGTH + 1), FALSE); 
    m_ContactData.sProgramName.ReleaseBuffer();
    GetFromRegistry(REG_LRWIZ_CSPHONEREGION, m_ContactData.sCSRPhoneRegion.GetBuffer(MAX_COUNTRY_NAME_LENGTH + 1), FALSE);
    m_ContactData.sCSRPhoneRegion.ReleaseBuffer();

    //These are no longer being used
    m_ContactData.sContactFax = "";
    m_ContactData.sContactPhone = "";
    m_ContactData.sCSRFaxRegion = "";

    InitSPKList();

    SetLSLangId(GetUserDefaultUILanguage());

    //
    // Get the info for the License Server.
    //
    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    } 
    

    dwRetCode = TLSGetSupportFlags(
                        m_phLSContext,
                        &dwSupportFlags
                );

    if (dwRetCode == RPC_S_OK)
    {
        if ((dwRetCode == RPC_S_OK) && (dwSupportFlags & SUPPORT_CONCURRENT))
        {
                m_fSupportConcurrent = TRUE;
        }
        else
            {
                m_fSupportConcurrent = FALSE;
            }

            if (dwSupportFlags & SUPPORT_WHISTLER_CAL)
            {
                    m_fSupportWhistlerCAL = TRUE;            
            }
            else
            {
                    m_fSupportWhistlerCAL = FALSE;
            }
        }
        else
        {
            m_fSupportConcurrent = FALSE;
            m_fSupportWhistlerCAL = FALSE;
            dwRetCode = RPC_S_OK;   // OK if this fails
        }

    //
    // Load Products from the String Table
    //
    LoadProducts();

done:
    DisconnectLS();

    if(pRtn)
        midl_user_free(pRtn);

    if(hKey)
        RegCloseKey(hKey);

    DisconnectLSRegistry();

    return dwRetCode;
}


DWORD CGlobal::CheckRequieredFields()
{
    DWORD   dwRetCode = ERROR_SUCCESS;
        
    //Validate sProgramName (Partially fix bug # 577)
    if ( (m_ContactData.sProgramName != PROGRAM_LICENSE_PAK &&
          m_ContactData.sProgramName != PROGRAM_MOLP &&
          m_ContactData.sProgramName != PROGRAM_SELECT &&
          m_ContactData.sProgramName != PROGRAM_ENTERPRISE &&
          m_ContactData.sProgramName != PROGRAM_CAMPUS_AGREEMENT &&
          m_ContactData.sProgramName != PROGRAM_SCHOOL_AGREEMENT &&
          m_ContactData.sProgramName != PROGRAM_APP_SERVICES &&
          m_ContactData.sProgramName != PROGRAM_OTHER)    ||

          (m_ContactData.sCompanyName   == "" ||
          m_ContactData.sContactLName   == "" ||
          m_ContactData.sContactFName   == "" ||          
          m_ContactData.sCountryCode    == "" ||
          m_ContactData.sCountryDesc    == "") )
    {           
        dwRetCode = IDS_ERR_REQ_FIELD_EMPTY;    
    }
    
    return dwRetCode;

}

void CGlobal::SetLSStatus(DWORD dwStatus)
{
    m_dwLSStatus = dwStatus;
}

DWORD CGlobal::GetLSStatus(void)
{
    return m_dwLSStatus;
}


void CGlobal::SetInstanceHandle(HINSTANCE hInst)
{
    m_hInstance = hInst;
}

HINSTANCE CGlobal::GetInstanceHandle()
{
    return m_hInstance;
}

void CGlobal::SetLSName(LPCTSTR lpstrLSName)
{   

    if(m_lpwstrLSName)
    {
        delete m_lpwstrLSName;
        m_lpwstrLSName = NULL;
    }

    if (lpstrLSName != NULL)
    {
        m_lpwstrLSName  = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
        wcscpy(m_lpwstrLSName,(LPWSTR)lpstrLSName);

        m_lpstrLSName = (LPTSTR) lpstrLSName;
    }
}


WIZCONNECTION   CGlobal::GetActivationMethod(void)
{
    return m_ActivationMethod;
}

void CGlobal::SetActivationMethod(WIZCONNECTION conn)
{
    TCHAR acBuf[ 32];

    _stprintf(acBuf, _T("%d"), conn);
    SetInRegistry(ACTIVATIONMETHOD_KEY, acBuf);

    m_ActivationMethod = conn;
}


WIZCONNECTION CGlobal::GetLSProp_ActivationMethod(void)
{
    return m_LSProp_ActivationMethod;
}

void CGlobal::SetLSProp_ActivationMethod(WIZCONNECTION conn)
{
    m_LSProp_ActivationMethod = conn;
}


WIZACTION   CGlobal::GetWizAction(void)
{
    return m_WizAction;
}

void CGlobal::SetWizAction(WIZACTION act)
{
    m_WizAction = act;
}


DWORD CGlobal::GetEntryPoint(void)
{
    DWORD dwReturn = 0;

    switch (m_ActivationMethod)
    {
    case CONNECTION_INTERNET:
        switch (m_WizAction)
        {
        case WIZACTION_REGISTERLS:
            dwReturn = IDD_CONTACTINFO1;
            break;

        case WIZACTION_CONTINUEREGISTERLS:
            //This is no longer considered a valid state since
            //PIN numbers aren't emailed anymore
            {
                // Restart
                SetLRState(LRSTATE_NEUTRAL);
                SetLSStatus(LSERVERSTATUS_UNREGISTER);
                SetWizAction(WIZACTION_REGISTERLS);
                ClearWizStack();
                dwReturn = IDD_DLG_GETREGMODE;
            }
            break;

        case WIZACTION_DOWNLOADLKP:
            dwReturn = IDD_LICENSETYPE;

            break;

        case WIZACTION_UNREGISTERLS:
        case WIZACTION_REREGISTERLS:
            dwReturn = IDD_DLG_CERTLOG_INFO;
            break;

        case WIZACTION_SHOWPROPERTIES:
            dwReturn = IDD_WELCOME;
            break;
        }
        break;

    case CONNECTION_PHONE:
        switch (m_WizAction)
        {
        case WIZACTION_REGISTERLS:
        case WIZACTION_CONTINUEREGISTERLS:
            dwReturn = IDD_DLG_TELREG;
            break;

        case WIZACTION_DOWNLOADLASTLKP:
        case WIZACTION_DOWNLOADLKP:
            // Calls Authenticate
            dwReturn = IDD_DLG_TELLKP;
            break;

        case WIZACTION_UNREGISTERLS:
            dwReturn = IDD_DLG_CONFREVOKE;
            break;

        case WIZACTION_REREGISTERLS:
            dwReturn = IDD_DLG_TELREG_REISSUE;
            break;

        case WIZACTION_SHOWPROPERTIES:
            dwReturn = IDD_WELCOME;
            break;
        }
        break;


    case CONNECTION_WWW:
        switch (m_WizAction)
        {
        case WIZACTION_REGISTERLS:
        case WIZACTION_CONTINUEREGISTERLS:
            dwReturn = IDD_DLG_WWWREG;
            break;

        case WIZACTION_DOWNLOADLASTLKP:
        case WIZACTION_DOWNLOADLKP:
            // Calls Authenticate
            dwReturn = IDD_DLG_WWWLKP;
            break;

        case WIZACTION_UNREGISTERLS:
            break;

        case WIZACTION_REREGISTERLS:
            dwReturn = IDD_DLG_WWWREG_REISSUE;
            break;

        case WIZACTION_SHOWPROPERTIES:
            dwReturn = IDD_WELCOME;
            break;
        }
        break;

    default:
        break;
    }

    return dwReturn;
}



DWORD CGlobal::LRGetLastError()
{
    DWORD dwRet;

    dwRet           = m_dwErrorCode;
    m_dwErrorCode   = 0;

    return dwRet;
}

void CGlobal::LRSetLastError(DWORD dwErrorCode)
{
    m_dwErrorCode = dwErrorCode;
}

 int CGlobal::LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwCaptionID /*=0*/,DWORD dwErrorCode /*=0*/)
{
    TCHAR   szBuf[LR_MAX_MSG_TEXT];
    TCHAR   szMsg[LR_MAX_MSG_TEXT];
    TCHAR   szCaption[LR_MAX_MSG_CAPTION];
    
    LoadString(GetInstanceHandle(),dwMsgId,szMsg,LR_MAX_MSG_TEXT);
    if (dwCaptionID == 0)
        LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);
    else
        LoadString(GetInstanceHandle(),dwCaptionID,szCaption,LR_MAX_MSG_CAPTION);
    
    if(dwErrorCode != 0)
    {
        DWORD dwRet = 0;
        LPTSTR lpszTemp = NULL;

        dwRet=FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             NULL,
                             dwErrorCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

        
           
        _stprintf(szBuf,szMsg,dwErrorCode);

        if(dwRet != 0 && lpszTemp != NULL)
        {
            lstrcat(szBuf, _T(", "));
            lstrcat(szBuf, lpszTemp);                
            LocalFree(lpszTemp);
        }
    }
    else
    {
        _tcscpy(szBuf,szMsg);
    }    

    return MessageBox(hWndParent,szBuf,szCaption,MB_OK|MB_ICONSTOP);
}


BOOL CGlobal::IsLSRunning()
{
    DWORD dwRetCode = ERROR_SUCCESS;    
    
    if (ConnectToLS() != ERROR_SUCCESS)
    {
        return FALSE;
    }

    DisconnectLS();

    return TRUE;    
}



DWORD CGlobal::ResetLSSPK(BOOL bGenKey)
{
    DWORD dwRetCode;

    error_status_t      esRPC           = ERROR_SUCCESS;

    dwRetCode = ConnectToLS();

    if(dwRetCode == ERROR_SUCCESS)
    {       
        // Make LS Regen Key call HERE
        dwRetCode = TLSTriggerReGenKey(m_phLSContext, bGenKey, &esRPC);

        if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
        {
            dwRetCode = IDS_ERR_RPC_FAILED;     
        }
        else
        {
            dwRetCode = ERROR_SUCCESS;
        }
    }

    DisconnectLS();
    LRSetLastError(dwRetCode);

    return dwRetCode;
}





DWORD CGlobal::GetLSCertificates(PDWORD pdwServerStatus)
{
    DWORD               dwRetCode       = ERROR_SUCCESS;    
    PCONTEXT_HANDLE     phLSContext     = NULL;
    error_status_t      esRPC           = ERROR_SUCCESS;
    error_status_t      esTemp          = ERROR_SUCCESS;
    PBYTE               pCertBlob       = NULL;
    PBYTE               pSignCertBlob   = NULL;
    DWORD               dwCertBlobLen   = 0;
    DWORD               dwSignCertBlobLen = 0;
    DWORD               dwCertSize      = 0;
    DWORD               dwRegIDLength   = 0;
    DWORD               dwLSIDLen       = 0;
    
    HCRYPTPROV          hCryptProvider  = NULL;
    CRYPT_DATA_BLOB     CertBlob;
    HCERTSTORE          hCertStore      = NULL;
    PCCERT_CONTEXT      pcCertContext   = NULL; 
    PCERT_EXTENSION     pCertExtension  = NULL;
    BYTE * pByte = NULL;

    m_dwExchangeCertificateLen  = 0;
    if (m_pbExchangeCertificate != NULL)
    {
        LocalFree(m_pbExchangeCertificate);
    }
    if (m_pbSignCertificate != NULL)
    {
        LocalFree(m_pbSignCertificate);
    }

    m_pbSignCertificate         = NULL;
    m_pbExchangeCertificate     = NULL;
    *pdwServerStatus            = LSERVERSTATUS_UNREGISTER;
    m_pRegistrationID[0]        = NULL;
    m_pLicenseServerID[0]       = NULL;
    
    dwRetCode = ConnectToLS();
    if (dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }

    // We need the License Server ID
    dwRetCode = TLSGetServerPID( m_phLSContext,
                                 &dwLSIDLen,
                                 &pByte,
                                 &esRPC );
    if (dwRetCode != RPC_S_OK)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }

    if (esRPC == LSERVER_E_DATANOTFOUND || 
        dwLSIDLen != sizeof(TCHAR)*(LR_LICENSESERVERID_LEN+1))
    {
        if (pByte != NULL)
        {
            LocalFree(pByte);
        }

        dwRetCode = IDS_ERR_NOLSID;
        goto done;
    }

    assert(esRPC == ERROR_SUCCESS && pByte != NULL);
    memcpy(m_pLicenseServerID, pByte, sizeof(TCHAR)*(LR_LICENSESERVERID_LEN+1));
    LocalFree(pByte);

    //Try and get the LSServerCertificate first 
    dwRetCode =  TLSGetServerCertificate (  m_phLSContext,
                                            FALSE,
                                            &pCertBlob,
                                            &dwCertBlobLen,
                                            &esRPC );
    if(dwRetCode != RPC_S_OK)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }

    if (esRPC == LSERVER_I_TEMP_SELFSIGN_CERT )
    {
        // Certificate is NOT signed & does not have the SPK
        dwRetCode = ERROR_SUCCESS;
        goto done;
    }
    else 
    {
        // Certificate is either msft signed OR there is an SPK
        // in it.
        pByte = NULL;
        dwRetCode = TLSGetServerSPK( m_phLSContext,
                                     &dwRegIDLength,
                                     &pByte,
                                     &esTemp );

        if (dwRetCode != RPC_S_OK)
        {
            LRSetLastError(dwRetCode);
            dwRetCode = IDS_ERR_RPC_FAILED;     
            goto done;
        }

        if (esTemp == LSERVER_E_DATANOTFOUND)
        {           
            if (pByte != NULL)
            {
                LocalFree(pByte);
            }

            dwRetCode = ERROR_SUCCESS;
            goto done;
        }

        if (esTemp != ERROR_SUCCESS)
        {
            if (pByte != NULL)
            {
                LocalFree(pByte);
            }
            LRSetLastError(dwRetCode);
            dwRetCode = IDS_ERR_RPC_FAILED;     
            goto done;
        }

        if (dwRegIDLength != sizeof(TCHAR)*(LR_REGISTRATIONID_LEN+1))
        {
            // What happened to the SPK's Length ??
            if (pByte != NULL)
            {
                LocalFree(pByte);
            }
            dwRetCode = IDS_ERR_INVALIDLENGTH;      
            LRSetLastError(dwRetCode);
            goto done;
        }

        assert(pByte != NULL);
        memcpy(m_pRegistrationID, pByte, sizeof(TCHAR)*(LR_REGISTRATIONID_LEN+1));
        LocalFree(pByte);
    }


    if(esRPC != LSERVER_I_SELFSIGN_CERTIFICATE && esRPC != ERROR_SUCCESS )
    {
        LRSetLastError(esRPC);
        dwRetCode = IDS_ERR_LS_ERROR;
        goto done;
    }

    m_pbExchangeCertificate     = pCertBlob;
    m_dwExchangeCertificateLen  = dwCertBlobLen;


    // Now that everything has succeded, let us get thesigning cert
    dwRetCode =  TLSGetServerCertificate (  m_phLSContext,
                                            TRUE,
                                            &pSignCertBlob,
                                            &dwSignCertBlobLen,
                                            &esRPC );

    if (dwRetCode == RPC_S_OK && esRPC == LSERVER_S_SUCCESS )
    {
        m_pbSignCertificate     = pSignCertBlob;
        m_dwSignCertificateLen  = dwSignCertBlobLen;
    }
    else
    {
        dwRetCode = ERROR_SUCCESS;  // Ignore this error;
        m_pbSignCertificate = NULL;
        m_dwSignCertificateLen  = 0;
    }
    

    //
    //Get the Extensions from the Certificate
    //  
    if ( esRPC != LSERVER_I_SELFSIGN_CERTIFICATE )
    {
        CertBlob.cbData = m_dwExchangeCertificateLen;
        CertBlob.pbData = m_pbExchangeCertificate;

        //Create the PKCS7 store and get the first cert out of it!
        dwRetCode = GetTempCryptContext(&hCryptProvider);
        if( dwRetCode != ERROR_SUCCESS )
        {
            LRSetLastError(dwRetCode);
            dwRetCode = IDS_ERR_CRYPT_ERROR;
            goto done;
        }

        hCertStore = CertOpenStore(   CERT_STORE_PROV_PKCS7,
                                      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                      hCryptProvider,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      &CertBlob );

        if( NULL == hCertStore )
        {
            LRSetLastError(GetLastError());
            dwRetCode = IDS_ERR_CRYPT_ERROR;
            goto done;
        }
        
        //Get the cert from the store
        pcCertContext = CertEnumCertificatesInStore ( hCertStore, NULL );
        if ( !pcCertContext )
        {
            LRSetLastError(GetLastError());
            dwRetCode = IDS_ERR_CRYPT_ERROR;
            goto done;
        }

        //Get the extension and store the cert type in it
        pCertExtension = CertFindExtension ( szOID_NULL_EXT,
                                             pcCertContext->pCertInfo->cExtension,
                                             pcCertContext->pCertInfo->rgExtension
                                           );
        if ( !pCertExtension )
        {
            LRSetLastError(CRYPT_E_NOT_FOUND);
            dwRetCode = IDS_ERR_CRYPT_ERROR;
            goto done;
        }
                                 
        //Get the value and store it in the member function
        m_dwExtenstionValueLen = pCertExtension->Value.cbData;
        m_pbExtensionValue = new BYTE [m_dwExtenstionValueLen + 1 ];

        memset ( m_pbExtensionValue, 0, m_dwExtenstionValueLen  + 1 );
        memcpy ( m_pbExtensionValue, pCertExtension->Value.pbData, m_dwExtenstionValueLen );

        dwRetCode = ERROR_SUCCESS;
        *pdwServerStatus = LSERVERSTATUS_REGISTER_INTERNET;
    }
    else
    {
        // There is an SPK
        dwRetCode = ERROR_SUCCESS;
        *pdwServerStatus = LSERVERSTATUS_REGISTER_OTHER;
    }
    
done:

    DisconnectLS();
    
    if ( pcCertContext )
    {
        CertFreeCertificateContext ( pcCertContext );
    }

    if ( hCertStore )
    {
        CertCloseStore (hCertStore,CERT_CLOSE_STORE_CHECK_FLAG);
    }

    DoneWithTempCryptContext(hCryptProvider);

    return dwRetCode;
}

DWORD CGlobal::IsLicenseServerRegistered(PDWORD pdwServerStatus)
{
    DWORD               dwRetCode       = ERROR_SUCCESS;    
    PCONTEXT_HANDLE     phLSContext     = NULL;
    error_status_t      esRPC           = ERROR_SUCCESS;    
    PBYTE               pCertBlob       = NULL; 
    DWORD               dwCertBlobLen   = 0;
    
    
    *pdwServerStatus    = LSERVERSTATUS_UNREGISTER;
    
    dwRetCode = ConnectToLS();
    if (dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }
    
    //Try and get the LSServerCertificate first 
    dwRetCode =  TLSGetServerCertificate (  m_phLSContext,
                                            FALSE,
                                            &pCertBlob,
                                            &dwCertBlobLen,
                                            &esRPC );
    if(dwRetCode != RPC_S_OK)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;
        goto done;
    }

    if ( esRPC == ERROR_SUCCESS)
    {
        *pdwServerStatus = LSERVERSTATUS_REGISTER_INTERNET;
    }
    else if ( esRPC == LSERVER_I_SELFSIGN_CERTIFICATE )
    {
        *pdwServerStatus = LSERVERSTATUS_REGISTER_OTHER;
    }
    else if (esRPC == LSERVER_I_TEMP_SELFSIGN_CERT )
    {       
        *pdwServerStatus    = LSERVERSTATUS_UNREGISTER;     
    }
    else
    {
        LRSetLastError(esRPC);
        dwRetCode = IDS_ERR_LS_ERROR;       
    }

done:

    DisconnectLS();
    
    if ( pCertBlob )
    {
        LocalFree(pCertBlob);
    }
    
    return dwRetCode;   
}



DWORD CGlobal::GetTempCryptContext(HCRYPTPROV * phCryptProv)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    *phCryptProv = NULL;
    if(!CryptAcquireContext(  phCryptProv,          // Address for handle to be returned.
                              NULL,                 // Key Container Name.
                              NULL,                 // Provider Name.
                              PROV_RSA_FULL,        // Need to do both encrypt & sign.
                              0
                           ) )
    {
        if (!CryptAcquireContext(   phCryptProv,    // Address for handle to be returned.
                                    NULL,           // Key Container Name.
                                    NULL,           // Provider Name.
                                    PROV_RSA_FULL,  // Need to do both encrypt & sign.
                                    CRYPT_VERIFYCONTEXT 
                                ) )
        {
            dwRetCode = GetLastError();
        }
    }

    return dwRetCode;
}

void CGlobal::DoneWithTempCryptContext(HCRYPTPROV hCryptProv)
{
    if ( hCryptProv )
        CryptReleaseContext ( hCryptProv, 0 );  
}



DWORD CGlobal::GetCHCert( LPTSTR lpstrRegKey , PBYTE * ppCert, DWORD * pdwLen )
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   dwDisposition = 0;
    DWORD   dwType = REG_BINARY;

    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
        goto done;      

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_PARAMS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   
    
    RegQueryValueEx(hKey,  
                    lpstrRegKey,
                    0,
                    &dwType,
                    NULL,
                    pdwLen
                    );

    if(*pdwLen == 0)
    {
        dwRetCode = IDS_ERR_CHCERTKEY_EMPTY;
        goto done;
    }

    *ppCert = new BYTE[*pdwLen];
    memset(*ppCert,0,*pdwLen);
    RegQueryValueEx ( hKey,  
                    lpstrRegKey,
                    0,
                    &dwType,
                    *ppCert,
                    pdwLen
                    );      
    

done:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    DisconnectLSRegistry();
    return dwRetCode;
}

DWORD CGlobal::SetCHCert ( LPTSTR lpstrRegKey, PBYTE pCert, DWORD dwLen )
{
    DWORD   dwRetCode = ERROR_SUCCESS;  
    HKEY    hKey      = NULL;
    DWORD   dwDisposition = 0;
    DWORD   dwDecodedCertLen = 0;
    PBYTE   pDecodedCert = NULL;

    /*
    //base 64 decode the blob
    LSBase64DecodeA( (const char *)pCert,
                     dwLen,
                     NULL,
                     &dwDecodedCertLen);

    pDecodedCert = new BYTE[dwDecodedCertLen];

    LSBase64DecodeA( (const char *)pCert,
                     dwLen,
                     pDecodedCert,
                     &dwDecodedCertLen);

    */

    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_PARAMS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   
    
    RegSetValueEx ( hKey,  
                    lpstrRegKey,
                    0,
                    REG_BINARY,
                    pCert,
                    dwLen
                   );

done :  

    if(pDecodedCert)
        delete pDecodedCert;

    if(hKey)
        RegCloseKey(hKey);
    
    DisconnectLSRegistry();
    return dwRetCode;
}

//
// This functions connects the LS Registry and stores the Reg Handle in 
// in the Member variable.
//
DWORD CGlobal::ConnectToLSRegistry()
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    TCHAR   szMachineName[MAX_COMPUTERNAME_LENGTH + 5];
    
    _tcscpy(szMachineName,L"\\\\");
    _tcscat(szMachineName,m_lpstrLSName);

    m_hLSRegKey = NULL;

    dwRetCode = RegConnectRegistry(szMachineName,HKEY_LOCAL_MACHINE,&m_hLSRegKey);
    if(dwRetCode != ERROR_SUCCESS)
    {       
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCONNECT_FAILD;
    }

    return dwRetCode;
}

void CGlobal::DisconnectLSRegistry()
{
    if(m_hLSRegKey)
        RegCloseKey(m_hLSRegKey);
}

DWORD CGlobal::ConnectToLS()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    error_status_t  esRPC   = ERROR_SUCCESS;

    HCRYPTPROV hCryptProv;

    m_phLSContext = TLSConnectToLsServer((LPTSTR)m_lpwstrLSName);

    if (!m_phLSContext)
    {
        dwRetCode = IDS_ERR_LSCONNECT_FAILED;       
    }
    else
    {
        GetTempCryptContext(&hCryptProv);

        dwRetCode = TLSEstablishTrustWithServer(m_phLSContext, hCryptProv, CLIENT_TYPE_LRWIZ, &esRPC);

        if ( dwRetCode != RPC_S_OK || esRPC != LSERVER_S_SUCCESS)
        {
            dwRetCode = IDS_ERR_LCONNECTTRUST_FAILED; 

            TLSDisconnectFromServer(m_phLSContext);
            m_phLSContext = NULL;
        }
        DoneWithTempCryptContext(hCryptProv);
    }

    return dwRetCode;
}

void CGlobal::DisconnectLS()
{
    if (m_phLSContext)
    {
        TLSDisconnectFromServer(m_phLSContext);
        m_phLSContext = NULL;
    }
}


//
//  bstrPKCS7 is LS Client Auth Cert with BASE64 Encoding whereas
//  bstrRootCert is plain X509_ASN_ENCODING
//
DWORD CGlobal::DepositLSCertificates(PBYTE pbExchangePKCS7, 
                                     DWORD dwExchangePKCS7Len,
                                     PBYTE pbSignaturePKCS7,
                                     DWORD dwSignaturePKCS7Len,
                                     PBYTE pbRootCert,
                                     DWORD dwRootCertLen)
{
    //LS CA Root Certificate BLOB in X509_ASN_ENCODING & BASE 64 Encoded
    PBYTE   pbLSEncodedRootBLOB     = pbRootCert;
    DWORD   dwLSEncodedRootBLOBLen  = dwRootCertLen;

    //LS CA Root Certificate BLOB in X509_ASN_ENCODING & BASE 64 Decoded
    PBYTE   pbLSDecodedRootBLOB     = NULL;         
    DWORD   dwLSDecodedRootBLOBLen  = 0;

    //LS Exchange Certificate BLOB(BASE64 encoded) along with LS CA Non-Root Certificate    
    PBYTE   pbLSEncodedExchgBLOB    = pbExchangePKCS7;
    DWORD   dwLSEncodedExchgBLOBLen = dwExchangePKCS7Len;

    //LS Exchange Certificate BLOB(BASE64 decoded) along with LS CA Non-Root Certificate    
    PBYTE   pbLSDecodedExchgBLOB    = NULL;
    DWORD   dwLSDecodedExchgBLOBLen = 0;
    
    //LS Signature Certificate BLOB(BASE64 encoded) along with LS CA Non-Root Certificate   
    PBYTE   pbLSEncodedSigBLOB      = pbSignaturePKCS7;
    DWORD   dwLSEncodedSigBLOBLen   = dwSignaturePKCS7Len;

    //LS Signature Certificate BLOB(BASE64 decoded) along with LS CA Non-Root Certificate   
    PBYTE   pbLSDecodedSigBLOB      = NULL;
    DWORD   dwLSDecodedSigBLOBLen   = 0;

    //Data blobs Required by CryptoAPIs
    CRYPT_DATA_BLOB LSExchgCertBlob;
    CRYPT_DATA_BLOB LSExchgCertStore;

    CRYPT_DATA_BLOB LSSigCertBlob;
    CRYPT_DATA_BLOB LSSigCertStore; 

    //Crypto Handles
    HCRYPTPROV  hCryptProv      =   NULL;
    HCERTSTORE  hExchgCertStore =   NULL;
    HCERTSTORE  hSigCertStore   =   NULL;

    DWORD   dwRet                = 0;
    PCCERT_CONTEXT  pCertContext =  NULL;   
    
    error_status_t  esRPC;

    //Decode LS Exchange Cert BLOB(BASE64 Encoded)
    LSBase64DecodeA((char *)pbLSEncodedExchgBLOB, dwLSEncodedExchgBLOBLen, NULL, &dwLSDecodedExchgBLOBLen);
    pbLSDecodedExchgBLOB = new BYTE[dwLSDecodedExchgBLOBLen];
    LSBase64DecodeA((char *)pbLSEncodedExchgBLOB, dwLSEncodedExchgBLOBLen, pbLSDecodedExchgBLOB, &dwLSDecodedExchgBLOBLen);

    //Decode LS Signature Cert BLOB(BASE64 Encoded)
    LSBase64DecodeA((char *)pbLSEncodedSigBLOB, dwLSEncodedSigBLOBLen, NULL, &dwLSDecodedSigBLOBLen);
    pbLSDecodedSigBLOB = new BYTE[dwLSDecodedSigBLOBLen];
    LSBase64DecodeA((char *)pbLSEncodedSigBLOB, dwLSEncodedSigBLOBLen, pbLSDecodedSigBLOB, &dwLSDecodedSigBLOBLen);

    //Decode LS Root Cert BLOB(BASE64 Encoded)
    LSBase64DecodeA((char *)pbLSEncodedRootBLOB, dwLSEncodedRootBLOBLen, NULL, &dwLSDecodedRootBLOBLen);
    pbLSDecodedRootBLOB = new BYTE[dwLSDecodedRootBLOBLen];
    LSBase64DecodeA((char *)pbLSEncodedRootBLOB, dwLSEncodedRootBLOBLen, pbLSDecodedRootBLOB, &dwLSDecodedRootBLOBLen);
    
    
    LSExchgCertStore.cbData = 0;
    LSExchgCertStore.pbData = NULL;

    LSSigCertStore.cbData = 0;
    LSSigCertStore.pbData = NULL;

    if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT ) )
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
    
    //Create a new memory store for LS Exchange Certificate Chain
    LSExchgCertBlob.cbData = dwLSDecodedExchgBLOBLen;
    LSExchgCertBlob.pbData = pbLSDecodedExchgBLOB;
    
    hExchgCertStore = CertOpenStore( CERT_STORE_PROV_PKCS7,
                                     PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                     hCryptProv,
                                     CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                     (void *)&LSExchgCertBlob);

    if( hExchgCertStore == NULL )
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }   
    
    //Add Root Certificate to the Store
    if(!CertAddEncodedCertificateToStore( hExchgCertStore,
                                          X509_ASN_ENCODING,            
                                          (const BYTE *)pbLSDecodedRootBLOB,    
                                          dwLSDecodedRootBLOBLen,
                                          CERT_STORE_ADD_REPLACE_EXISTING,
                                          &pCertContext))
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
    


    //Save this store as PKCS7
    
    //Get the Required Length
    CertSaveStore(  hExchgCertStore,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CERT_STORE_SAVE_AS_PKCS7,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &LSExchgCertStore,
                    0);

    LSExchgCertStore.pbData = new BYTE[LSExchgCertStore.cbData];    
    
    //Save the Store
    if(!CertSaveStore(  hExchgCertStore,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        CERT_STORE_SAVE_AS_PKCS7,
                        CERT_STORE_SAVE_TO_MEMORY,
                        &LSExchgCertStore,
                        0)
                      )
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
    
    /******** Do the Same thing for the Signature Certificate ********/

    //Create a new memory store for LS Signature Certificate Chain
    LSSigCertBlob.cbData = dwLSDecodedSigBLOBLen;
    LSSigCertBlob.pbData = pbLSDecodedSigBLOB;
    
    hSigCertStore = CertOpenStore(   CERT_STORE_PROV_PKCS7,
                                     PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                     hCryptProv,
                                     CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                     (void *)&LSSigCertBlob);

    if( hSigCertStore == NULL )
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }   
    //Verify certificate 
    //Add Root Certificate to the Store
    if(!CertAddEncodedCertificateToStore( hSigCertStore,
                                          X509_ASN_ENCODING,            
                                          (const BYTE *)pbLSDecodedRootBLOB,    
                                          dwLSDecodedRootBLOBLen,
                                          CERT_STORE_ADD_REPLACE_EXISTING,
                                          &pCertContext))
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
    
    //Save this store as PKCS7
    
    //Get the Required Length
    CertSaveStore(  hSigCertStore,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CERT_STORE_SAVE_AS_PKCS7,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &LSSigCertStore,
                    0);

    LSSigCertStore.pbData = new BYTE[LSSigCertStore.cbData];    
    
    //Save the Store
    if(!CertSaveStore(  hSigCertStore,  // in
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        CERT_STORE_SAVE_AS_PKCS7,
                        CERT_STORE_SAVE_TO_MEMORY,
                        &LSSigCertStore,
                        0))
    {
        dwRet = GetLastError();
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CRYPT_ERROR;
        goto DepositExit;
    }
    
    //Now verify the certificate chain for both exchange and 
    //signature certificates.

    dwRet = VerifyCertChain (   hCryptProv,
                                hExchgCertStore,
                                pbLSDecodedRootBLOB,    
                                dwLSDecodedRootBLOBLen
                            );

    if ( dwRet != ERROR_SUCCESS )
    {
        LRSetLastError(dwRet);
        goto DepositExit;
    }
                                
    dwRet = VerifyCertChain (   hCryptProv,
                                hSigCertStore,
                                pbLSDecodedRootBLOB,    
                                dwLSDecodedRootBLOBLen
                            );

    if ( dwRet != ERROR_SUCCESS )
    {
        LRSetLastError(dwRet);
        goto DepositExit;
    }

    //Now Send Both Signature & Exchange BLOBs to LS.   
    dwRet = ConnectToLS();
    if(dwRet != ERROR_SUCCESS)
    {
        goto DepositExit;
    }    
    
    dwRet = TLSInstallCertificate( m_phLSContext,
                                  CERTIFICATE_CA_TYPE,
                                  1,
                                  LSSigCertStore.cbData,
                                  LSSigCertStore.pbData,
                                  LSExchgCertStore.cbData,
                                  LSExchgCertStore.pbData,
                                  &esRPC
                                 );

    if(dwRet != RPC_S_OK)
    {
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CERT_DEPOSIT_RPCERROR;
        goto DepositExit;
    }
    else if ( esRPC != ERROR_SUCCESS && ( esRPC < LSERVER_I_NO_MORE_DATA || esRPC > LSERVER_I_TEMP_SELFSIGN_CERT ) )
    {       
        dwRet = esRPC;
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_CERT_DEPOSIT_RPCERROR; //IDS_ERR_CERT_DEPOSIT_LSERROR;
        goto DepositExit;
    }

DepositExit :

    if(hCryptProv != NULL)
        CryptReleaseContext(hCryptProv,0);

    if(hExchgCertStore != NULL)
        CertCloseStore(hExchgCertStore,CERT_CLOSE_STORE_FORCE_FLAG);

    if(hSigCertStore != NULL)
        CertCloseStore(hSigCertStore,CERT_CLOSE_STORE_FORCE_FLAG);

    if(pbLSDecodedRootBLOB != NULL)
        delete[] pbLSDecodedRootBLOB;

    if(pbLSDecodedExchgBLOB != NULL)
        delete[] pbLSDecodedExchgBLOB;

    if(pbLSDecodedSigBLOB != NULL)
        delete[] pbLSDecodedSigBLOB;

    if(LSExchgCertStore.pbData != NULL)
        delete LSExchgCertStore.pbData;

    if(LSSigCertStore.pbData != NULL)
        delete LSSigCertStore.pbData;   
    
    return dwRet;
}


DWORD CGlobal::GetCryptContextWithLSKeys(HCRYPTPROV * lphCryptProv ) 
{
    DWORD       dwRetVal = ERROR_SUCCESS;
    DWORD       esRPC = ERROR_SUCCESS;

    PBYTE       pbExchKey = NULL;
    PBYTE       pbSignKey = NULL;   
    DWORD       cbExchKey = 0;
    DWORD       cbSignKey = 0;

    HCRYPTKEY   hSignKey;
    HCRYPTKEY   hExchKey;
    
    //
    //Create a new temp context
    //
    if (!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET) )
    {
        dwRetVal = GetLastError();

        //If the key container exists , recreate it after deleting the existing one
        if(dwRetVal == NTE_EXISTS)
        {
            // Delete
            if(!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_DELETEKEYSET))
            {
                dwRetVal = GetLastError();
                LRSetLastError(dwRetVal);
                dwRetVal = IDS_ERR_CRYPT_ERROR;
                goto done;      
            }

            // Recreate
            if(!CryptAcquireContext(lphCryptProv, LS_CRYPT_KEY_CONTAINER, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET))
            {
                dwRetVal = GetLastError();
                LRSetLastError(dwRetVal);
                dwRetVal = IDS_ERR_CRYPT_ERROR;
                goto done;      
            }

        }
        else
        {
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            goto done;
        }
    }
    
    dwRetVal = ConnectToLS();
    if(dwRetVal != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    //Now call retrieve keys and import them
    //
    dwRetVal = TLSGetLSPKCS10CertRequest  ( m_phLSContext,
                                            TLSCERT_TYPE_EXCHANGE,
                                            &cbExchKey,
                                            &pbExchKey,
                                            &esRPC 
                                           );

    if ( dwRetVal != RPC_S_OK ) 
    {
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_RPC_ERROR;
        goto done;
    }
    else if ( esRPC != ERROR_SUCCESS && esRPC != LSERVER_I_SELFSIGN_CERTIFICATE &&
              esRPC != LSERVER_I_TEMP_SELFSIGN_CERT )
    {
        dwRetVal = esRPC;
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_LSKEY_IMPORT_FAILED;
        goto done;
    }

    dwRetVal = TLSGetLSPKCS10CertRequest  ( m_phLSContext,
                                            TLSCERT_TYPE_SIGNATURE,
                                            &cbSignKey,
                                            &pbSignKey,
                                            &esRPC 
                                           );

    if ( dwRetVal != RPC_S_OK ) 
    {
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_RPC_ERROR;
        goto done;
    }
    else if ( esRPC != ERROR_SUCCESS && esRPC != LSERVER_I_SELFSIGN_CERTIFICATE &&
              esRPC != LSERVER_I_TEMP_SELFSIGN_CERT )
    {
        dwRetVal = esRPC;
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_LSKEY_IMPORT_FAILED;
        goto done;
    }

    if(!CryptImportKey(*lphCryptProv, pbSignKey, cbSignKey, NULL, 0, &hSignKey))
    {
        dwRetVal = GetLastError();
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;
    }

    if(!CryptImportKey ( *lphCryptProv, pbExchKey, cbExchKey, NULL, 0, &hExchKey))
    {
        dwRetVal = GetLastError();
        LRSetLastError(dwRetVal);
        dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;
    }   

done:
    if ( pbExchKey )
        LocalFree(pbExchKey);

    if ( pbSignKey )
        LocalFree(pbSignKey);

    DisconnectLS();

    return dwRetVal;
}

void CGlobal::DoneWithCryptContextWithLSKeys(HCRYPTPROV hProv)
{
    if(hProv)
    {
        CryptReleaseContext (hProv, 0);     
    }
}


DWORD CGlobal::AskLSToCreatePKCS10(int nType,CHAR **lppszPKCS10)
{
    DWORD               dwRetVal = ERROR_SUCCESS;
    CERT_RDN_ATTR       *prgNameAttr = NULL;
    DWORD               dwErrCode;
    LPBYTE              pbRequest=NULL;
    DWORD               cbRequest=0;
    DWORD               cch=0;

    dwRetVal = ConnectToLS();
    if(dwRetVal != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    prgNameAttr = CreateRDNAttr();

    if(prgNameAttr == NULL)
    {
        dwRetVal = IDS_ERR_OUTOFMEM;
        goto cleanup;
    }

    dwRetVal = TLSGenerateCustomerCert(m_phLSContext,
                                       nType,
                                       m_dwReqAttrCount,
                                       prgNameAttr,
                                       &cbRequest,
                                       &pbRequest,
                                       &dwErrCode);
                                         

    if ((dwRetVal == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS) && (pbRequest != NULL))
    {
        //
        // base64 encoding
        //

        LSBase64EncodeA ( pbRequest, cbRequest, NULL, &cch);

        *lppszPKCS10 = new CHAR [cch+1];
        if(*lppszPKCS10 == NULL)
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            goto cleanup;
        }

        memset ( *lppszPKCS10, 0, (cch+1)*sizeof(CHAR) );
        
        LSBase64EncodeA ( pbRequest, cbRequest, *lppszPKCS10, &cch);       
    }
    else
    {
        dwRetVal = IDS_ERR_CRYPT_ERROR;
    }

cleanup:
    DisconnectLS();

    if (NULL != pbRequest)
    {
        MIDL_user_free(pbRequest);
    }

    if(prgNameAttr != NULL)
        delete prgNameAttr;

    return dwRetVal;
}


DWORD CGlobal::CreateLSPKCS10(HCRYPTPROV hCryptProv,int nType,CHAR **lppszPKCS10)
{
    DWORD dwRetVal = ERROR_SUCCESS;

    CERT_SIGNED_CONTENT_INFO    SignatureInfo;
    CERT_REQUEST_INFO           CertReqInfo;
    //HCRYPTPROV                    hCryptProv=NULL;
    

    CERT_EXTENSION  rgExtension[MAX_NUM_EXTENSION];
    int             iExtCount=0;
    CERT_EXTENSIONS Extensions;

    CRYPT_ATTRIBUTE rgAttribute;
    CRYPT_ATTR_BLOB bAttr;

    CRYPT_BIT_BLOB bbKeyUsage;
    
    CERT_POLICIES_INFO  CertPolicyInfo;
    CERT_POLICY_INFO    CertPolicyOID;

    LPBYTE  pbRequest=NULL;
    DWORD   cbRequest=0;    
    DWORD   cch=0;   

    CERT_RDN_ATTR * prgNameAttr = NULL;

    // clean out the PKCS 10
    memset(rgExtension, 0, sizeof(rgExtension));
    memset(&Extensions, 0, sizeof(CERT_EXTENSIONS));
    memset(&rgAttribute, 0, sizeof(rgAttribute));
    memset(&bbKeyUsage, 0, sizeof(bbKeyUsage));
    memset(&bAttr, 0, sizeof(bAttr));
    memset(&SignatureInfo, 0, sizeof(SignatureInfo));

    memset(&CertPolicyInfo, 0, sizeof(CERT_POLICIES_INFO));
    memset(&CertPolicyOID, 0, sizeof(CERT_POLICY_INFO));

    memset(&CertReqInfo, 0, sizeof(CERT_REQUEST_INFO));
    CertReqInfo.dwVersion = CERT_REQUEST_V1;
    
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo=NULL;
    DWORD cbPubKeyInfo=0;

    do 
    {
        //
        // always strore everything in ANSI
        //
        prgNameAttr = CreateRDNAttr();

        if(prgNameAttr == NULL)
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        CERT_RDN rgRDN[] = {m_dwReqAttrCount, prgNameAttr};
        CERT_NAME_INFO Name = {1, rgRDN};
        
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_NAME,
                               &Name,
                               NULL,
                               &CertReqInfo.Subject.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        CertReqInfo.Subject.pbData=(BYTE *) new BYTE[CertReqInfo.Subject.cbData];
        if (CertReqInfo.Subject.pbData == NULL)
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_NAME,
                               &Name,
                               CertReqInfo.Subject.pbData,
                               &CertReqInfo.Subject.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        // now get the public key out
        if(!CryptExportPublicKeyInfo(hCryptProv, nType, X509_ASN_ENCODING, NULL, &cbPubKeyInfo))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        pPubKeyInfo=(PCERT_PUBLIC_KEY_INFO) new BYTE[cbPubKeyInfo];

        if ( NULL == pPubKeyInfo )
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        if(!CryptExportPublicKeyInfo(hCryptProv, nType,  X509_ASN_ENCODING, pPubKeyInfo, &cbPubKeyInfo))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }    

        CertReqInfo.SubjectPublicKeyInfo = *pPubKeyInfo;

        //no extensions here - we set them on the server side!
        
        //sign cert request !
        
        SignatureInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
        memset(&SignatureInfo.SignatureAlgorithm.Parameters, 0, sizeof(SignatureInfo.SignatureAlgorithm.Parameters));
        if(!CryptEncodeObject(CRYPT_ASN_ENCODING,
                              X509_CERT_REQUEST_TO_BE_SIGNED,
                              &CertReqInfo,
                              NULL,
                              &SignatureInfo.ToBeSigned.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        SignatureInfo.ToBeSigned.pbData = (LPBYTE)new BYTE [SignatureInfo.ToBeSigned.cbData];
        if (NULL == SignatureInfo.ToBeSigned.pbData ) 
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        if(!CryptEncodeObject(CRYPT_ASN_ENCODING,
                              X509_CERT_REQUEST_TO_BE_SIGNED,
                              &CertReqInfo,
                              SignatureInfo.ToBeSigned.pbData,
                              &SignatureInfo.ToBeSigned.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }


        if(!CryptSignCertificate( hCryptProv,
                                  nType,
                                  CRYPT_ASN_ENCODING,
                                  SignatureInfo.ToBeSigned.pbData,
                                  SignatureInfo.ToBeSigned.cbData,
                                  &SignatureInfo.SignatureAlgorithm,
                                  NULL,
                                  NULL,
                                  &SignatureInfo.Signature.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        SignatureInfo.Signature.pbData = new BYTE[SignatureInfo.Signature.cbData];
        if ( NULL == SignatureInfo.Signature.pbData )
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        if(!CryptSignCertificate( hCryptProv,
                                  nType,
                                  CRYPT_ASN_ENCODING,
                                  SignatureInfo.ToBeSigned.pbData,
                                  SignatureInfo.ToBeSigned.cbData,
                                  &SignatureInfo.SignatureAlgorithm,
                                  NULL,
                                  SignatureInfo.Signature.pbData,
                                  &SignatureInfo.Signature.cbData))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        // encode final signed request
        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_CERT,
                               &SignatureInfo,
                               NULL,
                               &cbRequest))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        pbRequest = new BYTE[cbRequest];
        if ( NULL == pbRequest )
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        if(!CryptEncodeObject( CRYPT_ASN_ENCODING,
                               X509_CERT,
                               &SignatureInfo,
                               pbRequest,
                               &cbRequest))
        {
            dwRetVal = GetLastError();
            LRSetLastError(dwRetVal);
            dwRetVal = IDS_ERR_CRYPT_ERROR;
            break;
        }

        //
        // base64 encoding
        //
        LSBase64EncodeA ( pbRequest, cbRequest, NULL, &cch);

        *lppszPKCS10 = new CHAR [cch+1];
        if(*lppszPKCS10 == NULL)
        {
            dwRetVal = IDS_ERR_OUTOFMEM;
            break;
        }

        memset ( *lppszPKCS10, 0, (cch+1)*sizeof(CHAR) );
        
        LSBase64EncodeA ( pbRequest, cbRequest, *lppszPKCS10, &cch);       
        

    } while(FALSE);


    //
    // free up all 
    //
    if(pPubKeyInfo != NULL)
        delete[] pPubKeyInfo;
    
    if(CertReqInfo.Subject.pbData != NULL)
        delete CertReqInfo.Subject.pbData;

    if(rgAttribute.rgValue)
        delete rgAttribute.rgValue[0].pbData;

    if(SignatureInfo.ToBeSigned.pbData != NULL)
        delete SignatureInfo.ToBeSigned.pbData;

    if(SignatureInfo.Signature.pbData != NULL)
        delete SignatureInfo.Signature.pbData;

    if(pbRequest != NULL)
        delete[] pbRequest;

    if(prgNameAttr != NULL)
        delete [] prgNameAttr;

    return dwRetVal;
}

DWORD CGlobal::SetDNAttribute(LPCSTR lpszOID, LPSTR lpszValue)
{
    //store the item in an array here
    //so that it is easy to populate the 
    //cert request later
    //calling CreateLSPKCS10 will clear the array
    DWORD   dwRet = ERROR_SUCCESS;
    
    
    if ( !m_pReqAttr )
    {
        m_pReqAttr = (PREQ_ATTR)malloc (sizeof (REQ_ATTR ) );
    }
    else
    {
        PREQ_ATTR reqAttrTmp;

        reqAttrTmp = (PREQ_ATTR)realloc ( m_pReqAttr, sizeof(REQ_ATTR) * (m_dwReqAttrCount + 1));

        if (NULL != reqAttrTmp)
        {
            m_pReqAttr = reqAttrTmp;
        }
        else
        {
        dwRet = IDS_ERR_OUTOFMEM;
        goto done;
        }
    }

    if ( !m_pReqAttr )
    {
        dwRet = IDS_ERR_OUTOFMEM;
        goto done;
    }
    
    ( m_pReqAttr + m_dwReqAttrCount)->lpszOID   = lpszOID;  

    ( m_pReqAttr + m_dwReqAttrCount)->lpszValue = new CHAR[lstrlenA(lpszValue) + 1];
    lstrcpyA(( m_pReqAttr + m_dwReqAttrCount)->lpszValue,lpszValue);

    
    
    m_dwReqAttrCount++;
    
done:
    return dwRet;
}





DWORD CGlobal::GetFromRegistry(LPCSTR lpszOID, LPTSTR lpszBuffer, BOOL bConnect)
{
    HKEY    hKey = NULL;
    DWORD   dwDisposition;
    DWORD   dwRet = ERROR_SUCCESS;
    DWORD   dwDataLen = 0;
    DWORD   dwType  = REG_SZ;

    _tcscpy(lpszBuffer, _T(""));

    if (bConnect)
    {
        dwRet = ConnectToLSRegistry();
        if(dwRet != ERROR_SUCCESS)
        {
            //This is necessary because ConnectToLSRegistry actually returns the 
            //ID of a resource string, not the return code. Not good for exposed 
            //APIs that make use of this procedure and then pass the result on
            dwRet = LRGetLastError();
            goto done;
        }
    }
    else
        assert(m_hLSRegKey != NULL);

    dwRet = RegCreateKeyEx(m_hLSRegKey, REG_LRWIZ_PARAMS, 0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_READ, NULL, &hKey, &dwDisposition);
    
    if (dwRet != ERROR_SUCCESS)
    {
        LRSetLastError(dwRet);
        goto done;
    }   

    dwRet = RegQueryValueExA(hKey, lpszOID, 0, &dwType, NULL, &dwDataLen);

    if (dwDataLen && (dwRet == ERROR_SUCCESS))
    {
        char* cpBuf = new char[dwDataLen + 2];
        if (!cpBuf)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        memset(cpBuf, 0, dwDataLen + 2);

        dwRet = RegQueryValueExA(hKey, lpszOID, 0, &dwType, (LPBYTE) cpBuf, &dwDataLen);

        if (dwRet == ERROR_SUCCESS)
        {
            LSBase64DecodeA(cpBuf, lstrlenA(cpBuf), (PBYTE)lpszBuffer, &dwDataLen);
            _tcscpy(&lpszBuffer[(dwDataLen / sizeof(TCHAR))], _T(""));
        }

        if (cpBuf)
            delete[] cpBuf;
    }

done:
    if (hKey)
        RegCloseKey(hKey);

    if (bConnect)
        DisconnectLSRegistry();

    return dwRet;
}



DWORD CGlobal::SetInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue)
{
    HKEY    hKey = NULL;
    DWORD   dwDisposition;
    DWORD   dwRet = ERROR_SUCCESS;
    DWORD   dwLen = 0;
    char * cpOut;

    dwRet = ConnectToLSRegistry();
    if(dwRet != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRet = RegCreateKeyEx ( m_hLSRegKey,
                             REG_LRWIZ_PARAMS,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKey,
                             &dwDisposition);
    
    if(dwRet != ERROR_SUCCESS)
    {
        LRSetLastError(dwRet);
        dwRet = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }

    if (_tcslen(lpszValue) != 0)
    {
        LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), NULL, &dwLen);

        cpOut = new char[dwLen+1];
        if (cpOut == NULL)
        {
            dwRet = IDS_ERR_OUTOFMEM;
            goto done;
        }

        memset(cpOut, 0, dwLen+1);
        
        LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), cpOut, &dwLen);
    }
    else
    {
        cpOut = new char[2];
        if (cpOut == NULL)
        {
            dwRet = IDS_ERR_OUTOFMEM;
            goto done;
        }
        memset(cpOut, 0, 2);
    }
    
    RegSetValueExA ( hKey, 
                    lpszOID,
                    0,
                    REG_SZ,
                    (PBYTE) cpOut,
                    dwLen
                   );   
    delete[] cpOut;

done:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }
    DisconnectLSRegistry();

    return dwRet;
}



CERT_RDN_ATTR * CGlobal::CreateRDNAttr()
{
    CERT_RDN_ATTR * prgNameAttr = ( CERT_RDN_ATTR * )new BYTE [sizeof ( CERT_RDN_ATTR ) * m_dwReqAttrCount];
    DWORD dw = 0;

    if ( !prgNameAttr )
        goto done;

    for ( dw = 0; dw < m_dwReqAttrCount; dw ++ )
    {
        ( prgNameAttr + dw )->pszObjId      = (LPSTR)( m_pReqAttr + dw)->lpszOID;
        ( prgNameAttr + dw )->dwValueType   = CERT_RDN_PRINTABLE_STRING;
        ( prgNameAttr + dw )->Value.cbData  = lstrlenA(( m_pReqAttr + dw)->lpszValue);
        ( prgNameAttr + dw )->Value.pbData  = (PBYTE)( m_pReqAttr + dw)->lpszValue;
    }

done:
    return prgNameAttr;
}

TCHAR * CGlobal::GetRegistrationID(void)
{
    return m_pRegistrationID;
}


TCHAR * CGlobal::GetLicenseServerID(void)
{
    return m_pLicenseServerID;
}



DWORD CGlobal::GetRequestType()
{
    return m_dwRequestType;
}



void CGlobal::SetRequestType(DWORD dwMode)
{
    m_dwRequestType = dwMode;
}



BOOL CGlobal::IsOnlineCertRequestCreated()
{
    DWORD   dwRetCode       = ERROR_SUCCESS;
    DWORD   dwLRState       = 0;
    DWORD   dwDataLen       = 0;
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_SZ;
    HKEY    hKey            = NULL;

    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_PARAMS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }   

    
    dwLRState   = 0;
    dwType      = REG_DWORD;
    dwDataLen   = sizeof(dwLRState);
    RegQueryValueEx(hKey,
                    REG_LRWIZ_STATE,
                    0,
                    &dwType,
                    (LPBYTE)&dwLRState,
                    &dwDataLen
                    );

done:

    if(hKey)
        RegCloseKey(hKey);

    DisconnectLSRegistry();

    if(dwRetCode == ERROR_SUCCESS)
        return ( dwLRState == LRSTATE_ONLINE_CR_CREATED ) ? TRUE : FALSE;
    else
        return FALSE;
}

DWORD CGlobal::SetLRState(DWORD dwState)
{
    DWORD   dwRetCode       = ERROR_SUCCESS;
    DWORD   dwDataLen       = sizeof(dwState);
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_DWORD;
    HKEY    hKey            = NULL;

    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_PARAMS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }
    
    //
    // Persist LRCount
    //
    dwType      = REG_DWORD;
    dwDataLen   = sizeof(m_dwLRCount);

    RegSetValueEx ( hKey,  
                    REG_LR_COUNT,
                    0,
                    dwType,
                    (LPBYTE)&m_dwLRCount,
                    dwDataLen
                   );

    //
    // Persist LRState if it is not LRSTATE_OFFLINE_LR_INSTALLED
    //
    dwType      = REG_DWORD;
    dwDataLen   = sizeof(dwState);
    RegSetValueEx ( hKey,  
                    REG_LRWIZ_STATE,
                    0,
                    dwType,
                    (LPBYTE)&dwState,
                    dwDataLen
                   );
    m_dwLRState = dwState;

done:
    if(hKey)
        RegCloseKey(hKey);

    DisconnectLSRegistry();

    return dwRetCode;
}



DWORD CGlobal::ProcessRequest()
{
    DWORD dwRetCode = ERROR_SUCCESS;
 

    //
    // Before the processing the request, make sure LS is running
    //
    if(!IsLSRunning())
    {
        dwRetCode = IDS_ERR_LSCONNECT_FAILED;
        goto done;
    }

    switch(GetActivationMethod())
    {
    case CONNECTION_INTERNET:
        if (GetWizAction() == WIZACTION_REGISTERLS)
        {
            dwRetCode = ProcessIRegRequest();
        }
        else if (GetWizAction() == WIZACTION_CONTINUEREGISTERLS)
        {
            dwRetCode = ProcessCertDownload();
        }
        else if (GetWizAction() == WIZACTION_DOWNLOADLKP)
        {
            dwRetCode = ProcessDownloadLKP();
        }
        else if (GetWizAction() == WIZACTION_UNREGISTERLS)
        {
            dwRetCode = ProcessCHRevokeCert();
        }
        else if (GetWizAction() == WIZACTION_REREGISTERLS)
        {
            dwRetCode = ProcessCHReissueCert();
        }
        else if (GetWizAction() == WIZACTION_DOWNLOADLASTLKP)
        {
            dwRetCode = ProcessCHReissueLKPRequest();
        }
        break;

    case CONNECTION_PHONE:
    case CONNECTION_WWW:
        if (GetWizAction() == WIZACTION_REGISTERLS ||
            GetWizAction() == WIZACTION_REREGISTERLS ||
            GetWizAction() == WIZACTION_CONTINUEREGISTERLS)
        {
            dwRetCode = DepositLSSPK();
            if (dwRetCode != ERROR_SUCCESS)
            {
                dwRetCode = IDS_ERR_DEPOSITSPK;
            }
        }
        else if (GetWizAction() == WIZACTION_DOWNLOADLKP)
        {
            dwRetCode = DepositLSLKP();
        }
        else if (GetWizAction() == WIZACTION_UNREGISTERLS)
        {
            dwRetCode = ResetLSSPK();
        }
        break;
    }

done:

    LRSetLastRetCode(dwRetCode);

    return dwRetCode;
}




DWORD CGlobal::DepositLSSPK()
{
    DWORD               dwRetCode       = ERROR_SUCCESS;    
    error_status_t      esRPC           = ERROR_SUCCESS;
    CERT_EXTENSION      certExtension;
    CRYPT_OBJID_BLOB    oidValue;
    CERT_EXTENSIONS     certExts;
    TCHAR awBuffer[ 1024];

    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }

    swprintf(awBuffer, szCertEXTENSION_VALUE_FMT, L"SELECT" /* "BASIC" */);
    assert(wcslen(awBuffer) < sizeof(awBuffer));

    oidValue.cbData = (wcslen(awBuffer)+1)*sizeof(TCHAR);
    oidValue.pbData = (unsigned char *) awBuffer;

    certExtension.pszObjId  = (char *) szCertEXTENSION_OID;
    certExtension.fCritical = TRUE;
    certExtension.Value     = oidValue;

    certExts.cExtension = 1;
    certExts.rgExtension = &certExtension;
    
    // We need the License Server ID
    dwRetCode = TLSDepositeServerSPK( m_phLSContext,
                                      (wcslen(m_pLSSPK) + 1)*sizeof(TCHAR),
                                      (BYTE *) m_pLSSPK,
                                      &certExts,
                                      &esRPC );
    if(dwRetCode != RPC_S_OK)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }

    if (esRPC != LSERVER_S_SUCCESS)
    {
        // Some error occurred in depositing the SPK
        LRSetLastError(esRPC);
        dwRetCode = IDS_ERR_DEPOSITSPK;
    }
    else
    {
        // Everything suceeded
        memcpy(m_pRegistrationID, m_pLSSPK, (wcslen(m_pLSSPK) + 1)*sizeof(TCHAR));
        if (m_dwLRState == LRSTATE_ONLINE_CR_CREATED)
        {
            SetLRState(LRSTATE_NEUTRAL);
        }
    }


done:
    DisconnectLS();

    return dwRetCode;
}




DWORD CGlobal::SetLSLKP(TCHAR * tcLKP)
{
    if (wcsspn(tcLKP, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
    {
        // Extraneous characters in the SPK string
        return IDS_ERR_INVALIDID;
    }
    lstrcpy(m_pLSLKP, tcLKP);

    return ERROR_SUCCESS;
}



DWORD CGlobal::SetLSSPK(TCHAR * tcLKP)
{
    if (wcsspn(tcLKP, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
    {
        // Extraneous characters in the SPK string
        return IDS_ERR_INVALIDLSID;
    }

    if (lstrcmp(m_pRegistrationID, tcLKP) == 0)
    {
        return IDS_DUPLICATESPK;
    }

    lstrcpy(m_pLSSPK, tcLKP);

    return ERROR_SUCCESS;
}




DWORD CGlobal::DepositLSLKP(void)
{
    DWORD               dwRetCode       = ERROR_SUCCESS;    
    error_status_t      esRPC           = ERROR_SUCCESS;

    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }

    // We need the License Server ID
    dwRetCode = TLSTelephoneRegisterLKP( m_phLSContext,
                                         (wcslen(m_pLSLKP))*sizeof(TCHAR),
                                         (BYTE *) m_pLSLKP,
                                         &esRPC );
    if(dwRetCode != RPC_S_OK)
    {
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }

    if (esRPC != LSERVER_S_SUCCESS)
    {
        // Some error occurred in depositing the SPK
        if (esRPC == LSERVER_E_DUPLICATE)
        {
            dwRetCode = IDS_ERR_DUPLICATE_LKP;
        }
        else
        {
            dwRetCode = IDS_ERR_DEPOSITLKP;
            LRSetLastError(esRPC);
        }
    }

done:
    DisconnectLS();
    
    return dwRetCode;
}







DWORD CGlobal::SetCertificatePIN(LPTSTR lpszPIN)
{
    m_lpstrPIN = new TCHAR[_tcslen(lpszPIN)+1]; 

    if(m_lpstrPIN == NULL)
        return IDS_ERR_OUTOFMEM;

    _tcscpy(m_lpstrPIN,lpszPIN);

    return ERROR_SUCCESS;
}




void CGlobal::ClearCHRequestAttributes()
{
    DWORD   dwIndex = 0;

    if ( m_pRegAttr )
    {
        for(dwIndex=0;dwIndex<m_dwRegAttrCount;dwIndex++)
        {
            if((m_pRegAttr + dwIndex)->lpszAttribute)
                delete (m_pRegAttr + dwIndex)->lpszAttribute;

            if((m_pRegAttr + dwIndex)->lpszValue)
                delete (m_pRegAttr + dwIndex)->lpszValue;
        }

        free( m_pRegAttr );
        m_pRegAttr = NULL;
    }

    m_dwRegAttrCount = 0;
}

void CGlobal::ClearCARequestAttributes()
{
    DWORD dwIndex;

    if ( m_pReqAttr )
    {
        for(dwIndex=0;dwIndex<m_dwReqAttrCount;dwIndex++)
        {           
            if(( m_pReqAttr + dwIndex)->lpszValue)
                delete ( m_pReqAttr + dwIndex)->lpszValue;
        }

        free( m_pReqAttr );
        m_pReqAttr = NULL;
    }

    m_dwReqAttrCount = 0;
}

DWORD CGlobal::SetRegistrationAttribute ( LPWSTR lpszAttribute, LPCWSTR lpszValue, DWORD dwLen )
{
    DWORD dwRet;
    
    if ( !m_pRegAttr )
    {
        m_pRegAttr = (PREG_ATTR)malloc (sizeof (REG_ATTR ) );
    }
    else
    {
        PREG_ATTR regAttrTmp;

        regAttrTmp = (PREG_ATTR)realloc ( m_pRegAttr, sizeof(REG_ATTR) * (m_dwRegAttrCount + 1));

        if (NULL != regAttrTmp)
        {
            m_pRegAttr = regAttrTmp;
        }
        else
        {
            dwRet = IDS_ERR_OUTOFMEM;
            goto done;
        }
    }

    if ( !m_pRegAttr )
    {
        dwRet = IDS_ERR_OUTOFMEM;
        goto done;
    }
    
    ( m_pRegAttr + m_dwRegAttrCount)->lpszAttribute = new WCHAR[lstrlenW(lpszAttribute) + 1];
    lstrcpyW(( m_pRegAttr + m_dwRegAttrCount)->lpszAttribute,lpszAttribute );
    

    
    
    ( m_pRegAttr + m_dwRegAttrCount)->lpszValue     = new WCHAR[dwLen];
    memset(( m_pRegAttr + m_dwRegAttrCount)->lpszValue,0,dwLen * sizeof(WCHAR)); 
    memcpy(( m_pRegAttr + m_dwRegAttrCount)->lpszValue,lpszValue,dwLen * sizeof(WCHAR));

    ( m_pRegAttr + m_dwRegAttrCount)->dwValueLen    = dwLen * sizeof(WCHAR);        //byte length

    m_dwRegAttrCount++;

done:
    
    return dwRet;
}


DWORD CGlobal::DepositLKPResponse(PBYTE pbResponseData, DWORD dwResponseLen)
{   
    DWORD           dwRetCode   = ERROR_SUCCESS;
    DWORD           dwLSRetCode = ERROR_SUCCESS;
    LPBYTE          pCHCertBlob = NULL;
    DWORD           dwCertBlobLen = 0;

    LPBYTE          pCHRootCertBlob = NULL;
    DWORD           dwRootCertBlobLen = 0;

    LPBYTE          lpDecodedKeyPackBlob = NULL;
    DWORD           dwDecodedKeyPackBlob = 0;
    
    LPBYTE          lpKeyPackBlob = NULL;
    DWORD           dwKeyPackBlobLen;   
    

    lpDecodedKeyPackBlob = lpKeyPackBlob        = pbResponseData;
    dwDecodedKeyPackBlob = dwKeyPackBlobLen     = dwResponseLen;
    


/*
    //Base64 decode the LKP!
    LSBase64DecodeA((const char *)lpKeyPackBlob,
                    dwKeyPackBlobLen,
                    NULL,
                    &dwDecodedKeyPackBlob);

    lpDecodedKeyPackBlob = new BYTE[dwDecodedKeyPackBlob];

    if(lpDecodedKeyPackBlob == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    LSBase64DecodeA((const char *)lpKeyPackBlob,
                    dwKeyPackBlobLen,
                    lpDecodedKeyPackBlob,
                    &dwDecodedKeyPackBlob);
    
*/

    //Get the CH Cert BLOB and CH Root Cert BLOB
    dwRetCode = GetCHCert(REG_SIGN_CERT, &pCHCertBlob, &dwCertBlobLen );
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = GetCHCert(REG_ROOT_CERT, &pCHRootCertBlob, &dwRootCertBlobLen );
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode  = TLSRegisterLicenseKeyPack( m_phLSContext,
                                            pCHCertBlob,
                                            dwCertBlobLen,
                                            pCHRootCertBlob,
                                            dwRootCertBlobLen,
                                            lpDecodedKeyPackBlob,
                                            dwDecodedKeyPackBlob,
                                            &dwLSRetCode);

    if(dwRetCode != RPC_S_OK)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_ERROR;
        goto done;
    }

    if(dwLSRetCode != ERROR_SUCCESS )
    {
        LRSetLastError(dwLSRetCode);
        if ( dwLSRetCode != LSERVER_E_DUPLICATE )
        {           
            dwRetCode = IDS_ERR_DEPOSIT_LKP_FAILED;
        }
        else
        {
            dwRetCode = IDS_ERR_DUPLICATE_LKP;
        }
        goto done;
    }   

done:
/*
    if ( lpDecodedKeyPackBlob )
        delete lpDecodedKeyPackBlob;
*/
    if (pCHCertBlob != NULL)
    {
        delete pCHCertBlob;
    }

    if (pCHRootCertBlob != NULL)
    {
        delete pCHRootCertBlob;
    }
    DisconnectLS();

    return dwRetCode;
}

DWORD CGlobal::EnvelopeData(
                            PCCERT_CONTEXT      pCertContext,           //Certificate context to use
                            DWORD               cbMessage,              //BLOB size
                            PBYTE               pbMessage,              //BLOB Pointer
                            PEnvData            pEnvelopedData,         //enveloped data
                            HCRYPTPROV          hCryptProv,             //crypt provider
                            HCERTSTORE          hCertStore              //certificate store
                           )
{

    HCRYPTKEY       hEncryptKey = 0, hPubKey = 0;
    DWORD           dwRetCode = ERROR_SUCCESS;
    DWORD           cbBufSize = 0;
  
    //
    //import public key data from the Certificate Context
    //
    if( !CryptImportPublicKeyInfoEx( hCryptProv, X509_ASN_ENCODING, 
                                     &pCertContext->pCertInfo->SubjectPublicKeyInfo, 
                                     CALG_RSA_KEYX, 0, NULL, &hPubKey ) )
    {
        goto ErrorReturn;
    }

    //
    // Generate a session key to encrypt the message
    //
    if( !CryptGenKey( hCryptProv, CALG_RC4, CRYPT_EXPORTABLE, &hEncryptKey ) )
    {
        goto ErrorReturn;
    }
        
    //
    // allocate enough memory to contain the encrypted data.  
    //
    // Note: 
    //
    // we are using the RC4 stream cipher, so the encrypted output buffer size will be the same
    // as the plaintext input buffer size.  If we change to block encryption algorithm,
    // then we need to determine the output buffer size which may be larger than the
    // input buffer size.
    //

    pEnvelopedData->cbEncryptedData = cbMessage;
    pEnvelopedData->pbEncryptedData = (PBYTE)LocalAlloc( GPTR, pEnvelopedData->cbEncryptedData );

    if( NULL == pEnvelopedData->pbEncryptedData )
    {
        goto ErrorReturn;
    }

    //
    // encrypt the message with the session key
    //

    memcpy( pEnvelopedData->pbEncryptedData, pbMessage, cbMessage );

    if( !CryptEncrypt( hEncryptKey, 0, TRUE, 0, pEnvelopedData->pbEncryptedData, 
                       &pEnvelopedData->cbEncryptedData, cbMessage ) )
    {
        goto ErrorReturn;
    }

    //
    // Determine the size of the buffer that we need to export the 
    // encryption key and then export the key.
    // The exported encryption key is encrypted with the receipient's
    // public key.
    //

    if( !CryptExportKey( hEncryptKey, hPubKey, SIMPLEBLOB, 0, NULL, 
                         &pEnvelopedData->cbEncryptedKey ) )
    {
        goto ErrorReturn;
    }
    
    pEnvelopedData->pbEncryptedKey = (PBYTE)LocalAlloc( GPTR, pEnvelopedData->cbEncryptedKey );
    
    if( NULL == pEnvelopedData->pbEncryptedKey )
    {
        goto ErrorReturn;
    }

    if( !CryptExportKey( hEncryptKey, hPubKey, SIMPLEBLOB, 0, pEnvelopedData->pbEncryptedKey, 
                         &pEnvelopedData->cbEncryptedKey ) )
    {
        goto ErrorReturn;
    }
        
done:

    if( hPubKey )
    {
        CryptDestroyKey( hPubKey );
    }

    if( hEncryptKey )
    {
        CryptDestroyKey( hEncryptKey );
    }

    if( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );
    }
    
    if( hCertStore )
    {
        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );
    }

    if( hCryptProv )
    {
        CryptReleaseContext( hCryptProv, 0 );
    }        
    
    return( dwRetCode );

ErrorReturn:
    dwRetCode = GetLastError();
    goto done;
}

DWORD CGlobal::PackEnvData( 
                            PEnvData     pEnvelopedData, 
                            PDWORD       pcbPacked, 
                            PBYTE        *ppbPacked 
                          )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    PBYTE pCopyPos;

    //
    // determine the size of the buffer to allocate
    //

    *pcbPacked = pEnvelopedData->cbEncryptedData + pEnvelopedData->cbEncryptedKey +
                 ( sizeof( DWORD ) * 2 );

    *ppbPacked = (PBYTE)LocalAlloc( GPTR, *pcbPacked );

    if( NULL == ( *ppbPacked ) )
    {
        goto ErrorReturn;
    }

    pCopyPos = *ppbPacked;

    memcpy( pCopyPos, &pEnvelopedData->cbEncryptedKey, sizeof( DWORD ) );
    pCopyPos += sizeof( DWORD );

    memcpy( pCopyPos, pEnvelopedData->pbEncryptedKey, pEnvelopedData->cbEncryptedKey );
    pCopyPos += pEnvelopedData->cbEncryptedKey;

    memcpy( pCopyPos, &pEnvelopedData->cbEncryptedData, sizeof( DWORD ) );
    pCopyPos += sizeof( DWORD );

    memcpy( pCopyPos, pEnvelopedData->pbEncryptedData, pEnvelopedData->cbEncryptedData );    

done:

    return( dwRetCode );

ErrorReturn:

    dwRetCode = GetLastError();
    goto done;
}


DWORD CGlobal::SetCARequestAttributes()
{       
    //Clear previous data if any
    ClearCARequestAttributes();
   
    LPSTR lpszTemp;

    lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_ContactData.sCompanyName);
    if (lpszTemp != NULL)
    {
        SetDNAttribute(szOID_COMMON_NAME, lpszTemp);
        delete lpszTemp;
    }

    lpszTemp = UnicodeToAnsi((LPTSTR)(LPCTSTR)m_lpstrLSName);
    if (lpszTemp != NULL)
    {
        SetDNAttribute(szOID_SUR_NAME, lpszTemp); 
        delete lpszTemp;
    }

    return ERROR_SUCCESS;
}

DWORD CGlobal::SetCHRequestAttributes()
{

    //Clear previous data if any
    ClearCHRequestAttributes();

    //
    //Program information
    //

    //For these three program types we'll use the actual name
    if ((m_ContactData.sProgramName == PROGRAM_LICENSE_PAK) ||
        (m_ContactData.sProgramName == PROGRAM_MOLP) ||
        (m_ContactData.sProgramName == PROGRAM_SELECT))
    {
        SetRegistrationAttribute ( _PROGRAMNAMETAG, (LPCTSTR)m_ContactData.sProgramName, m_ContactData.sProgramName.GetLength() );
    }
    else //for the rest, we'll send "Select"
    {
        SetRegistrationAttribute ( _PROGRAMNAMETAG, PROGRAM_SELECT, wcslen(PROGRAM_SELECT));
    }


    //
    //Contact information
    //  
    SetRegistrationAttribute ( _CONTACTLNAMETAG,    (LPCTSTR)m_ContactData.sContactLName,   m_ContactData.sContactLName.GetLength());   
    SetRegistrationAttribute ( _CONTACTFNAMETAG,    (LPCTSTR)m_ContactData.sContactFName,   m_ContactData.sContactFName.GetLength());   
    SetRegistrationAttribute ( _CONTACTADDRESSTAG,  (LPCTSTR)m_ContactData.sContactAddress, m_ContactData.sContactAddress.GetLength());     
    SetRegistrationAttribute ( _CONTACTPHONETAG,    (LPCTSTR)m_ContactData.sContactPhone,   m_ContactData.sContactPhone.GetLength());   
    SetRegistrationAttribute ( _CONTACTFAXTAG,      (LPCTSTR)m_ContactData.sContactFax,     m_ContactData.sContactFax.GetLength()); 
    SetRegistrationAttribute ( _CONTACTEMAILTAG,    (LPCTSTR)m_ContactData.sContactEmail,   m_ContactData.sContactEmail.GetLength());   
    SetRegistrationAttribute ( _CONTACTCITYTAG,     (LPCTSTR)m_ContactData.sCity,           m_ContactData.sCity.GetLength());   
    SetRegistrationAttribute ( _CONTACTCOUNTRYTAG,  (LPCTSTR)m_ContactData.sCountryCode,            m_ContactData.sCountryCode.GetLength());    
    SetRegistrationAttribute ( _CONTACTSTATE,       (LPCTSTR)m_ContactData.sState,          m_ContactData.sState.GetLength());  
    SetRegistrationAttribute ( _CONTACTZIP,         (LPCTSTR)m_ContactData.sZip,                m_ContactData.sZip.GetLength());


    //
    //customer information
    //  
    SetRegistrationAttribute ( _CUSTOMERNAMETAG, (LPCTSTR)m_ContactData.sCompanyName, m_ContactData.sCompanyName.GetLength());

    //Program related information
    if ( m_ContactData.sProgramName == PROGRAM_MOLP )
    {
        //MOLP      
        SetRegistrationAttribute ( _MOLPAUTHNUMBERTAG,      (LPCTSTR)m_LicData.sMOLPAuthNumber,     m_LicData.sMOLPAuthNumber.GetLength());     
        SetRegistrationAttribute ( _MOLPAGREEMENTNUMBERTAG, (LPCTSTR)m_LicData.sMOLPAgreementNumber, m_LicData.sMOLPAgreementNumber.GetLength());       
        SetRegistrationAttribute ( _MOLPPRODUCTTYPETAG,     (LPCTSTR)m_LicData.sMOLPProductType,        m_LicData.sMOLPProductType.GetLength());

        SetRegistrationAttribute ( _MOLPQTYTAG,             (LPCTSTR)m_LicData.sMOLPQty,                m_LicData.sMOLPQty.GetLength());
    }
    else if ( m_ContactData.sProgramName != PROGRAM_LICENSE_PAK )
    {
        //Select        
        SetRegistrationAttribute ( _SELMASTERAGRNUMBERTAG,  (LPCTSTR)m_LicData.sSelMastAgrNumber,   m_LicData.sSelMastAgrNumber.GetLength() );      
        SetRegistrationAttribute ( _SELENROLLNUMBERTAG,     (LPCTSTR)m_LicData.sSelEnrollmentNumber, m_LicData.sSelEnrollmentNumber.GetLength());       
        SetRegistrationAttribute ( _SELPRODUCTTYPETAG,      (LPCTSTR)m_LicData.sSelProductType,     m_LicData.sSelProductType.GetLength());
        SetRegistrationAttribute ( _SELQTYTAG,              (LPCTSTR)m_LicData.sSelQty,             m_LicData.sSelQty.GetLength());
    }

    //Shipping address information
    //For Offline , always put the shipping address info
    //for Online , no need to put the shipping address. 
    
    return ERROR_SUCCESS;
}


DWORD CGlobal::LoadCountries()
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sCountry;
    LPTSTR  lpVal       = NULL;
    DWORD   dwSize      = LR_COUNTRY_DESC_LEN + LR_COUNTRY_CODE_LEN + MAX_COUNTRY_NAME_LENGTH;

    LPTSTR  szDelimiter = (LPTSTR)L":";

    m_csaCountryDesc.SetSize(IDS_COUNTRY_END - IDS_COUNTRY_START + 1);
    m_csaCountryCode.SetSize(IDS_COUNTRY_END - IDS_COUNTRY_START + 1);

    for(dwIndex = IDS_COUNTRY_START;dwIndex <= IDS_COUNTRY_END;dwIndex++)
    {
        lpVal = sCountry.GetBuffer(dwSize);

        LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);   

        m_csaCountryDesc[dwIndex-IDS_COUNTRY_START] = _tcstok(lpVal,szDelimiter);
        m_csaCountryCode[dwIndex-IDS_COUNTRY_START] = _tcstok(NULL,szDelimiter);

        sCountry.ReleaseBuffer(-1);
    }

    return dwRetCode;
}

DWORD CGlobal::PopulateCountryComboBox(HWND hWndCmb)
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sDesc;
    LPTSTR  lpVal       = NULL;

    for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
    {
        sDesc = m_csaCountryDesc[dwIndex];

        lpVal = sDesc.GetBuffer(LR_COUNTRY_DESC_LEN + 1);
        ComboBox_AddString(hWndCmb,lpVal);
        sDesc.ReleaseBuffer(-1);
    }
    
    return dwRetCode;
}

DWORD CGlobal::GetCountryCode(CString sDesc,LPTSTR szCode)
{
    DWORD dwRetCode =  ERROR_SUCCESS;
    DWORD dwIndex   =  0;

    for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
    {
        if(m_csaCountryDesc[dwIndex] == sDesc)
            break;
    }

    if(dwIndex > IDS_COUNTRY_END - IDS_COUNTRY_START)
        _tcscpy(szCode,CString(""));    //Not found
    else
        _tcscpy(szCode,m_csaCountryCode[dwIndex]);

    return dwRetCode;
}

DWORD CGlobal::GetCountryDesc(CString sCode,LPTSTR szDesc)
{
    DWORD dwRetCode =  ERROR_SUCCESS;
    DWORD dwIndex   =  0;

    for(dwIndex=0;dwIndex <= IDS_COUNTRY_END - IDS_COUNTRY_START;dwIndex++)
    {
        if(m_csaCountryCode[dwIndex] == sCode)
            break;
    }

    if(dwIndex > IDS_COUNTRY_END - IDS_COUNTRY_START)
        _tcscpy(szDesc,CString(""));  //Not found
    else
        _tcscpy(szDesc,m_csaCountryDesc[dwIndex]);

    return dwRetCode;
}


DWORD CGlobal::LoadProducts()
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sProduct;
    LPTSTR  lpVal       = NULL;
    DWORD   dwSize      = LR_PRODUCT_DESC_LEN + LR_PRODUCT_CODE_LEN;
    BOOL    fWin2000    = !m_fSupportConcurrent;
    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }


    DWORD   dwArray     = 0;

    LPTSTR  szDelimiter = (LPTSTR)L":";

    m_csaProductDesc.SetSize(dwNumProducts);
    m_csaProductCode.SetSize(dwNumProducts);

    for (dwIndex = IDS_PRODUCT_START; dwIndex < (IDS_PRODUCT_START + dwNumProducts); dwIndex++)
    {
        if (!m_fSupportConcurrent && (dwIndex == IDS_PRODUCT_CONCURRENT))
            continue;

        if (!m_fSupportWhistlerCAL && (dwIndex == IDS_PRODUCT_WHISTLER))
            continue;

        lpVal = sProduct.GetBuffer(dwSize);

        LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);   

        m_csaProductDesc[dwArray] = _tcstok(lpVal,szDelimiter);
        m_csaProductCode[dwArray] = _tcstok(NULL,szDelimiter);

        dwArray++;

        sProduct.ReleaseBuffer(-1);
    }

    return dwRetCode;
}



DWORD CGlobal::PopulateProductComboBox(HWND hWndCmb, ProductVersionType VerType)
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sDesc;
    LPTSTR  lpVal       = NULL;
    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }

    ComboBox_ResetContent(hWndCmb);
    
    //We only want to show the product types for the given version, so find
    //out what the product code range for the version is
    int nVersionStart = 0;
    int nVersionEnd = 0;
    switch (VerType)
    {
        case PRODUCT_VERSION_W2K:
            nVersionStart = IDS_PRODUCT_W2K_BEGIN;
            nVersionEnd = IDS_PRODUCT_W2K_END;
            break;
        case PRODUCT_VERSION_WHISTLER:
            nVersionStart = IDS_PRODUCT_WHISTLER_BEGIN;
            nVersionEnd = IDS_PRODUCT_WHISTLER_END;
            break;
        default:
            return dwRetCode;
            break;
    }

    for(dwIndex=0;dwIndex < dwNumProducts ;dwIndex++)
    {
        if ((_wtoi(m_csaProductCode[dwIndex]) >= nVersionStart) &&
            (_wtoi(m_csaProductCode[dwIndex]) <= nVersionEnd))
        {
            sDesc = m_csaProductDesc[dwIndex];
            lpVal = sDesc.GetBuffer(LR_PRODUCT_DESC_LEN);
            ComboBox_AddString(hWndCmb,lpVal);
            sDesc.ReleaseBuffer(-1);
        }
    }

    return dwRetCode;
}


DWORD CGlobal::GetProductCode(CString sDesc,LPTSTR szCode)
{
    DWORD dwRetCode =  ERROR_SUCCESS;
    DWORD dwIndex   =  0;
    DWORD   dwNumProducts = 0;
    
    if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
    { 
        dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
    }
    else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
    }
    else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
    {
        dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;
    }


    for(dwIndex=0;dwIndex < dwNumProducts;dwIndex++)
    {
        if(m_csaProductDesc[dwIndex] == sDesc)
            break;
    }

    if(dwIndex >= dwNumProducts )  
        _tcscpy(szCode,CString(""));        //Not found
    else
        _tcscpy(szCode,m_csaProductCode[dwIndex]);

    return dwRetCode;
}

//Load all react and deact reasons



DWORD CGlobal::LoadReasons()
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sReason;
    LPTSTR  lpVal       = NULL;
    DWORD   dwSize      = LR_REASON_CODE_LEN+LR_REASON_DESC_LEN+128;

    LPTSTR  szDelimiter = (LPTSTR)L":";

    m_csaReactReasonDesc.SetSize(  IDS_REACT_REASONS_END - IDS_REACT_REASONS_START + 1);
    m_csaReactReasonCode.SetSize( IDS_REACT_REASONS_END - IDS_REACT_REASONS_START + 1);
    
    m_csaDeactReasonDesc.SetSize(IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START + 1);
    m_csaDeactReasonCode.SetSize(IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START + 1);

    //load the reacr
    for(dwIndex = IDS_REACT_REASONS_START;dwIndex <= IDS_REACT_REASONS_END; dwIndex++)
    {
        lpVal = sReason.GetBuffer(dwSize);

        
        
        LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);   

        m_csaReactReasonDesc[dwIndex-IDS_REACT_REASONS_START] = _tcstok(lpVal,szDelimiter);
        m_csaReactReasonCode[dwIndex-IDS_REACT_REASONS_START] = _tcstok(NULL,szDelimiter);

        sReason.ReleaseBuffer(-1);
    }

    for ( dwIndex = IDS_DEACT_REASONS_START; dwIndex <= IDS_DEACT_REASONS_END; dwIndex ++ )
    {
        lpVal = sReason.GetBuffer(dwSize);
        
        LoadString(GetInstanceHandle(),dwIndex,lpVal,dwSize);   

        m_csaDeactReasonDesc[dwIndex-IDS_DEACT_REASONS_START] = _tcstok(lpVal,szDelimiter);
        m_csaDeactReasonCode[dwIndex-IDS_DEACT_REASONS_START] = _tcstok(NULL,szDelimiter);
        sReason.ReleaseBuffer(-1);

    }

    return dwRetCode;
}

DWORD CGlobal::PopulateReasonComboBox(HWND hWndCmb, DWORD dwType)
{
    DWORD   dwRetCode   = ERROR_SUCCESS;
    DWORD   dwIndex     = 0;
    CString sDesc;
    LPTSTR  lpVal       = NULL;
    DWORD dwNumItems    = 0;

    //If combo box is already populated,just return success
    if(ComboBox_GetCount(hWndCmb) > 0)
        return dwRetCode;

    ComboBox_ResetContent( hWndCmb);
    if ( dwType == CODE_TYPE_REACT )
    {
        dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
    }
    else if ( dwType == CODE_TYPE_DEACT )
    {
        dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
    }
    else
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }
    for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
    {
        if ( dwType == CODE_TYPE_REACT )
        {
            sDesc = m_csaReactReasonDesc[dwIndex];
        }
        else if ( dwType == CODE_TYPE_DEACT )
        {
            sDesc = m_csaDeactReasonDesc[dwIndex];
        }

        lpVal = sDesc.GetBuffer(LR_REASON_DESC_LEN);
        ComboBox_AddString(hWndCmb,lpVal);
        sDesc.ReleaseBuffer(-1);
    }
done:
    return dwRetCode;
}


DWORD CGlobal::GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType)
{
    DWORD dwRetCode =  ERROR_SUCCESS;
    DWORD dwIndex   =  0;
    DWORD   dwNumItems = 0;

    if ( dwType == CODE_TYPE_REACT )
    {
        dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
    }
    else if ( dwType == CODE_TYPE_DEACT )
    {
        dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
    }

    for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
    {
        if ( dwType == CODE_TYPE_REACT )
        {
            if ( m_csaReactReasonDesc[dwIndex] == sDesc )
                break;
            
        }
        else if ( dwType == CODE_TYPE_DEACT )
        {
            if ( m_csaDeactReasonDesc[dwIndex] == sDesc )
                break;
        }
    }

    if(dwIndex > dwNumItems)
        _tcscpy(szCode,CString(""));    //Not found
    else
    {
        if ( dwType == CODE_TYPE_REACT )
        {
            _tcscpy(szCode,m_csaReactReasonCode[dwIndex]);          
        }
        else if ( dwType == CODE_TYPE_DEACT )
        {
            _tcscpy(szCode,m_csaDeactReasonCode[dwIndex]);          
        }
        
    }


    return dwRetCode;
}

DWORD CGlobal::GetReasonDesc(CString sCode,LPTSTR szDesc, DWORD dwType)
{
    DWORD dwRetCode =  ERROR_SUCCESS;
    DWORD dwIndex   =  0;
    DWORD dwNumItems = 0;
    if ( dwType == CODE_TYPE_REACT )
    {
        dwNumItems = IDS_REACT_REASONS_END - IDS_REACT_REASONS_START ;
    }
    else if ( dwType == CODE_TYPE_DEACT )
    {
        dwNumItems = IDS_DEACT_REASONS_END - IDS_DEACT_REASONS_START ;
    }


    for(dwIndex=0;dwIndex <= dwNumItems;dwIndex++)
    {
        if ( dwType == CODE_TYPE_REACT )
        {
            if ( m_csaReactReasonCode[dwIndex] == sCode )
                break;
            
        }
        else if ( dwType == CODE_TYPE_DEACT )
        {
            if ( m_csaDeactReasonCode[dwIndex] == sCode )
                break;
        }

    }

    if(dwIndex > dwNumItems)
        _tcscpy(szDesc,CString(""));  //Not found
    else
    {
        if ( dwType == CODE_TYPE_REACT )
        {
            _tcscpy(szDesc,m_csaReactReasonDesc[dwIndex]);          
        }
        else if ( dwType == CODE_TYPE_DEACT )
        {
            _tcscpy(szDesc,m_csaDeactReasonDesc[dwIndex]);          
        }
    }

    return dwRetCode;
}

void CGlobal::ReadPhoneNumberFromRegistry(LPCTSTR lpCountry, LPTSTR lpPhoneNumber, DWORD nBufferSize)
{
    HKEY hKey = NULL;
    DWORD dwDisposition = 0;

    // Try to open the required registry key
    if (ConnectToLSRegistry() == ERROR_SUCCESS)
    {
        DWORD dwRetCode = ERROR_SUCCESS;
        dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                    REG_LRWIZ_CSNUMBERS,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    &dwDisposition);
        
        if (dwRetCode == ERROR_SUCCESS)
        {
            DWORD dwIndex = 0;
            DWORD dwType = REG_SZ;
            RegQueryValueEx(hKey, lpCountry, NULL, &dwType, (LPBYTE)lpPhoneNumber, &nBufferSize);
        }   
        else
            LRSetLastError(dwRetCode);

        if (hKey)
            RegCloseKey(hKey);

        DisconnectLSRegistry();
    }
}

DWORD CGlobal::CheckRegistryForPhoneNumbers()
{
    DWORD   dwRetCode       = ERROR_SUCCESS;
    DWORD   dwIndex         = 0;
    HKEY    hKey            = NULL;
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_SZ;
    DWORD   dwValName;
    DWORD   dwCS_Number;
    TCHAR   lpValueName[MAX_COUNTRY_NAME_LENGTH + 1];
    TCHAR   lpCS_Number[MAX_COUNTRY_NUMBER_LENGTH + 1];

    //
    // Try to open the required registry key
    //
    dwRetCode = ConnectToLSRegistry();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_CSNUMBERS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   

    do {
        dwValName       = sizeof(lpValueName)/sizeof(TCHAR);
        dwCS_Number     = sizeof(lpCS_Number);

        dwRetCode = RegEnumValue(hKey,
                                 dwIndex,
                                 lpValueName,
                                 &dwValName,
                                 NULL,
                                 &dwType,
                                 (BYTE *) lpCS_Number,
                                 &dwCS_Number);

        if (dwRetCode == ERROR_NO_MORE_ITEMS)
        {
            dwRetCode = ERROR_SUCCESS;
            break;
        }
        else if (dwRetCode != ERROR_SUCCESS )
        {           
            break;
        }

        if(dwType != REG_SZ)
            continue;

        dwIndex++;      

    } while (1);

    if (dwIndex <= 0)
    {
        dwRetCode = IDS_ERR_REGERROR;
    }

done:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    DisconnectLSRegistry();
    
    return dwRetCode;
}

DWORD CGlobal::PopulateCountryRegionComboBox(HWND hWndCmb)
{
    DWORD   dwRetCode       = ERROR_SUCCESS;
    DWORD   dwIndex         = 0;
    HKEY    hKey            = NULL;
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_SZ;
    DWORD   dwValName;
    DWORD   dwCS_Number;
    LVITEM  lvItem;
    DWORD   nItem;
    TCHAR   lpValueName[MAX_COUNTRY_NAME_LENGTH + 1];
    TCHAR   lpCS_Number[MAX_COUNTRY_NUMBER_LENGTH + 1];


    //
    // Get CSR Numbers from the Reqgistry
    //
    dwRetCode = ConnectToLSRegistry();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_CSNUMBERS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   


    //Clear the List first
    ComboBox_ResetContent(hWndCmb);

    do {
        dwValName       = sizeof(lpValueName)/sizeof(TCHAR);
        dwCS_Number     = sizeof(lpCS_Number);

        dwRetCode = RegEnumValue(hKey,
                                 dwIndex,
                                 lpValueName,
                                 &dwValName,
                                 NULL,
                                 &dwType,
                                 (BYTE *) lpCS_Number,
                                 &dwCS_Number);

        if (dwRetCode == ERROR_NO_MORE_ITEMS)
        {
            dwRetCode = ERROR_SUCCESS;
            break;
        }
        else if (dwRetCode != ERROR_SUCCESS )
        {           
            break;
        }

        dwIndex++;

        if(dwType != REG_SZ)
            continue;

        //lvItem.mask = LVIF_TEXT;
        //lvItem.iItem = 0;
        //lvItem.iSubItem = 0;
        //lvItem.pszText = lpValueName;
        //lvItem.cchTextMax = lstrlen(lpValueName);
        //nItem = ListView_InsertItem(hWndLst, &lvItem);

        //lvItem.iSubItem = 1;
        //lvItem.iItem = nItem;
        //lvItem.pszText = lpCS_Number;
        //lvItem.cchTextMax = lstrlen(lpCS_Number);
        //ListView_SetItem(hWndLst, &lvItem);
        int nItem = CB_ERR;
        nItem = ComboBox_AddString(hWndCmb, lpValueName);
        ComboBox_SetItemData(hWndCmb, nItem, lpCS_Number);

    } while (1);

    if (dwIndex <= 0)
    {
        dwRetCode = IDS_ERR_REGERROR;
    }

done:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    DisconnectLSRegistry();
    
    return dwRetCode;
}

DWORD CGlobal::PopulateCountryRegionListBox(HWND hWndLst)
{
    DWORD   dwRetCode       = ERROR_SUCCESS;
    DWORD   dwIndex         = 0;
    HKEY    hKey            = NULL;
    DWORD   dwDisposition   = 0;
    DWORD   dwType          = REG_SZ;
    DWORD   dwValName;
    DWORD   dwCS_Number;
    LVITEM  lvItem;
    DWORD   nItem;
    TCHAR   lpValueName[MAX_COUNTRY_NAME_LENGTH + 1];
    TCHAR   lpCS_Number[MAX_COUNTRY_NUMBER_LENGTH + 1];


    //
    // Get CSR Numbers from the Reqgistry
    //
    dwRetCode = ConnectToLSRegistry();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx (m_hLSRegKey,
                                REG_LRWIZ_CSNUMBERS,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                &dwDisposition);
    
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   


    //Clear the List first
    ListView_DeleteAllItems(hWndLst);

    do {
        dwValName       = sizeof(lpValueName)/sizeof(TCHAR);
        dwCS_Number     = sizeof(lpCS_Number);

        dwRetCode = RegEnumValue(hKey,
                                 dwIndex,
                                 lpValueName,
                                 &dwValName,
                                 NULL,
                                 &dwType,
                                 (BYTE *) lpCS_Number,
                                 &dwCS_Number);

        if (dwRetCode == ERROR_NO_MORE_ITEMS)
        {
            dwRetCode = ERROR_SUCCESS;
            break;
        }
        else if (dwRetCode != ERROR_SUCCESS )
        {           
            break;
        }

        dwIndex++;

        if(dwType != REG_SZ)
            continue;

        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;
        lvItem.pszText = lpValueName;
        lvItem.cchTextMax = lstrlen(lpValueName);
        nItem = ListView_InsertItem(hWndLst, &lvItem);

        lvItem.iSubItem = 1;
        lvItem.iItem = nItem;
        lvItem.pszText = lpCS_Number;
        lvItem.cchTextMax = lstrlen(lpCS_Number);
        ListView_SetItem(hWndLst, &lvItem);

//      ComboBox_AddString(hWndCmb,lpVal);
    } while (1);

    if (dwIndex <= 0)
    {
        dwRetCode = IDS_ERR_REGERROR;
    }

done:
    if (hKey)
    {
        RegCloseKey(hKey);
    }

    DisconnectLSRegistry();
    
    return dwRetCode;
}

void CGlobal::LRSetLastRetCode(DWORD dwCode)
{
    m_dwLastRetCode = dwCode;
}

DWORD CGlobal::LRGetLastRetCode()
{
    return m_dwLastRetCode;
}

LPWSTR CGlobal::AnsiToUnicode ( LPSTR lpszBuf )
{
    LPWSTR lpwszRetBuf = NULL;
    long lBufLen = ::lstrlenA(lpszBuf) + 1;
    lpwszRetBuf = new WCHAR[ lBufLen ];
    memset ( lpwszRetBuf, 0, lBufLen * sizeof(TCHAR));
    MultiByteToWideChar  ( GetACP(),
                           MB_PRECOMPOSED,
                           lpszBuf,
                           -1,
                           lpwszRetBuf,
                           lBufLen
                           );

    return lpwszRetBuf;
}

LPSTR CGlobal::UnicodeToAnsi( LPWSTR lpwszBuf, DWORD dwLength )
{
    LPSTR lpszRetBuf = NULL;
    DWORD nBufferSize;

    // We need to determine the buffer length first, if we pass in 0 for buffer
    // size it will return the required buffer size in bytes (including null)
    nBufferSize = WideCharToMultiByte(GetACP(),
                                      0,
                                      lpwszBuf,
                                      dwLength,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);

    if (nBufferSize > 0)
    {
        // Add one to the buffer size for null termination
        nBufferSize++;

        lpszRetBuf = new char[nBufferSize];
        if (lpszRetBuf == NULL)
            return NULL;

        memset(lpszRetBuf, 0, nBufferSize);

        WideCharToMultiByte(GetACP(),    // code page
                            0,           // performance and mapping flags
                            lpwszBuf,    // address of wide-character string
                            dwLength,    // number of characters in string
                            lpszRetBuf,  // address of buffer for new string
                            nBufferSize, // size of buffer in bytes                        
                            NULL,        // address of default for unmappable characters
                            NULL         // address of flag set when default char. used
                            );
    }
    
    return lpszRetBuf;
}


LPSTR CGlobal::UnicodeToAnsi(LPWSTR lpwszBuf)
{
    long lBufLen = ::lstrlenW(lpwszBuf);

    return UnicodeToAnsi(lpwszBuf, lBufLen);
}

void CGlobal::LRPush(DWORD dwPageId)
{
    assert(m_dwTop < NO_OF_PAGES - 1);
    m_dwWizStack[m_dwTop++] = dwPageId;     
}

DWORD CGlobal::LRPop()
{
    assert(m_dwTop > 0);
    return m_dwWizStack[--m_dwTop];
}




BOOL CGlobal::ValidateEmailId(CString sEmailId)
{

    BOOL    bValid  = FALSE;
    int     dwLen   = 0;

    dwLen = sEmailId.GetLength();

    do
    {
        // Check the length
        if(dwLen < EMAIL_MIN_LEN)
            break;

        // Make sure it does not have spaces
        if(sEmailId.Find(EMAIL_SPACE_CHAR) != -1)
            break;

        // Make sure it has '@' & '.' in it
        if(sEmailId.Find(EMAIL_AT_CHAR) == -1 || sEmailId.Find(EMAIL_DOT_CHAR) == -1)
            break;

        // Make sure first char is not either EMAIL_AT_CHAR or EMAIL_DOT_CHAR
        if(sEmailId[0] == EMAIL_AT_CHAR || sEmailId[0] == EMAIL_DOT_CHAR)
            break;

        // Make sure last char is not either EMAIL_AT_CHAR or EMAIL_DOT_CHAR
        if(sEmailId[dwLen-1] == EMAIL_AT_CHAR || sEmailId[dwLen-1] == EMAIL_DOT_CHAR)
            break;

        // EMAIL_AT_CHAR should come only once
        if(sEmailId.Find(EMAIL_AT_CHAR) != sEmailId.ReverseFind(EMAIL_AT_CHAR))
            break;
        
        //It should not have these string "@." or ".@"
        if(sEmailId.Find(EMAIL_AT_DOT_STR) != -1 || sEmailId.Find(EMAIL_DOT_AT_STR) != -1)
            break;

        bValid = TRUE;
    }
    while(FALSE);

    return bValid;
}

BOOL  CGlobal::CheckProgramValidity (CString sProgramName )
{
    BOOL bRetCode = FALSE;


//  if(sProgramName == PROGRAM_SELECT)
//  {
//      //select
//      if(strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_SELECT ) )
//      {
//          bRetCode = TRUE;
//      }
//  }
//  else if ( sProgramName == PROGRAM_MOLP || sProgramName == PROGRAM_RETAIL )
//  {
        //retail or MOLP
//      if (strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_SELECT ) ||
//          strstr ( (const char *)m_pbExtensionValue+3, CA_CERT_TYPE_OTHER )
//         )
//      {
            bRetCode = TRUE;
//      }
//  }
//
    return bRetCode;
}

//
// This function searches for Single quote (') and replaces it will two single quotes ('')
// This is because , SQL server gives error if the string contains single quote
//
void CGlobal::PrepareLRString(CString &sStr)
{
    CString sTemp;
    int     nIndex = 0;
    
    for(nIndex=0;nIndex < sStr.GetLength();nIndex++)
    {
        if(sStr[nIndex] == LR_SINGLE_QUOTE)
        {
            sTemp += LR_SINGLE_QUOTE;
            sTemp += LR_SINGLE_QUOTE;
        }
        else
            sTemp += sStr[nIndex];
    }

    sStr = sTemp;
}

//
// This functions checks for any invalid chars in the string
//
BOOL CGlobal::ValidateLRString(CString sStr)
{
    CString sInvalidChars = LR_INVALID_CHARS;

    if(sStr.FindOneOf(sInvalidChars) != -1)
        return FALSE;
    else
        return TRUE;
}

//
//Validate the certificate chain for a given store.  This is an overkill but
//will make it more robust!
//

DWORD CGlobal::VerifyCertChain (    HCRYPTPROV  hCryptProvider,         //handle to crypt prov
                                    HCERTSTORE  hCertStore,             //HAndle to store for verification
                                    PBYTE   pbRootCert,         //Root cert
                                    DWORD   dwcbRootCert
                            )
{
    DWORD               dwRetVal = ERROR_SUCCESS;
    PCCERT_CONTEXT      pRootCertContext = NULL;
    PCCERT_CONTEXT      pCertContext = NULL;
    PCCERT_CONTEXT      pIssuerCertContext = NULL;

    DWORD               dwFlags = CERT_STORE_SIGNATURE_FLAG;

    if ( NULL == hCryptProvider  || NULL == hCertStore || NULL == pbRootCert || dwcbRootCert <= 0  ) 
    {
        LRSetLastError (ERROR_INVALID_PARAMETER);
        dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;      
    }
    //Create a Root certificate context
    pRootCertContext = CertCreateCertificateContext (   X509_ASN_ENCODING,
                                                        pbRootCert,
                                                        dwcbRootCert
                                                    );
    if ( pRootCertContext == NULL )
    {
        LRSetLastError (GetLastError());
        dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;      
    }
    //check to see if there is a certificate with our extension in the store.  Then use that as the 
    //starting point
    dwRetVal = GetCertforExtension (hCryptProvider, hCertStore, szOID_NULL_EXT, &pCertContext);
    if ( dwRetVal != ERROR_SUCCESS )
    {
        LRSetLastError(dwRetVal );
        dwRetVal = IDS_ERR_CRYPT_ERROR;
        goto done;
    }

    //Walk the chain here
    do
    {        

        pIssuerCertContext = CertGetIssuerCertificateFromStore( hCertStore,
                                                                pCertContext,
                                                                NULL, // pIssuerCertContext,
                                                                &dwFlags );
        if ( pIssuerCertContext )
        {

            //check to see the result.
            if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
            {
                LRSetLastError(GetLastError());
                dwRetVal = IDS_ERR_INVALID_CERT_CHAIN;
                break;
            }

            dwFlags = CERT_STORE_SIGNATURE_FLAG;
            CertFreeCertificateContext (pCertContext);
            pCertContext = pIssuerCertContext;
        }
    } while ( pIssuerCertContext );

    if ( dwRetVal != ERROR_SUCCESS )
    {
        goto done;
    }
    //Verify the last issuer against the root passed in
    dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG | CERT_STORE_TIME_VALIDITY_FLAG;
    if ( !CertVerifySubjectCertificateContext( pCertContext, pRootCertContext, &dwFlags ) )
    {
        dwRetVal = GetLastError();
        goto done;
    }
    //check to see the result.
    if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
    {
        LRSetLastError(GetLastError());
        dwRetVal = IDS_ERR_INVALID_CERT_CHAIN;
    }

done:
    if (pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (pRootCertContext != NULL)
    {
        CertFreeCertificateContext(pRootCertContext);
    }

    return dwRetVal;
}


DWORD CGlobal::GetCertforExtension (HCRYPTPROV hCryptProv, HCERTSTORE hCertStore, LPSTR szOID_EXT, PCCERT_CONTEXT * ppCertContext)
{
    DWORD           dwRetVal = ERROR_SUCCESS;
    PCCERT_CONTEXT  pCurrentContext = NULL;
    PCCERT_CONTEXT  pPrevContext = NULL;
    PCERT_EXTENSION     pCertExtension  = NULL;

    if ( hCryptProv == NULL || hCertStore == NULL || ppCertContext == NULL )
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto done;
    }
    *ppCertContext = NULL;

    do
    {
        //Get the cert context
        pCurrentContext = CertEnumCertificatesInStore ( hCertStore, pPrevContext );
        if ( pCurrentContext )
        {
            //Check to see if the Extension is present in the cert context
            pCertExtension = CertFindExtension ( szOID_NULL_EXT,
                                                 pCurrentContext->pCertInfo->cExtension,
                                                 pCurrentContext->pCertInfo->rgExtension
                                                );
            if ( pCertExtension )
            {
                *ppCertContext = pCurrentContext;
                goto done;
            }
            pPrevContext = pCurrentContext;
        }

    } while ( pCurrentContext );

    dwRetVal = CRYPT_E_NOT_FOUND;       //CErt not found

done:
//  if ( pPrevContext )
//  {
//      CertFreeCertificateContext (pPrevContext);
//  }

    if ( !*ppCertContext && pCurrentContext )
    {
        CertFreeCertificateContext (pCurrentContext);
    }

    return dwRetVal;
}




DWORD CGlobal::FetchResponse(BYTE * bpResponse,
                             DWORD dwMaxLength,
                             PDWORD dwpDataLength)
{
    DWORD   dwCHRC          = ERROR_SUCCESS;    
    DWORD   dwBytesRead     = 0;
    BOOL    bRC             = FALSE;
    BYTE *  bpCurrent       = bpResponse;

    *dwpDataLength = 0;

    assert(m_hOpenDirect != NULL);
    assert(m_hRequest != NULL);
    assert(m_hConnect != NULL);

    while ( dwMaxLength > 0 && (bRC = InternetReadFile ( m_hRequest, 
                                                         bpResponse,
                                                         dwMaxLength,
                                                         &dwBytesRead )) && dwBytesRead)
    {
        dwMaxLength -= dwBytesRead;
        (*dwpDataLength) += dwBytesRead;
    }

    if (!bRC)
    {
//      dwCHRC = GetLastError();
        dwCHRC = IDS_ERR_CHFETCHRESPONSE;
    }

    return dwCHRC;
}



DWORD CGlobal::InitCHRequest(void)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    const char  *pszAcceptedTypes[] = {"*/*",NULL};
    LPSTR   lpszCHName = UnicodeToAnsi((LPTSTR)(LPCTSTR) m_lpstrCHServer);
    LPSTR   lpszExtension = UnicodeToAnsi((LPTSTR)(LPCTSTR) m_lpstrCHExtension);
    
    assert(m_hOpenDirect == NULL);
    assert(m_hConnect == NULL);
    assert(m_hRequest == NULL);

    //m_hOpenDirect = InternetOpenA ( "LRWizDLL",  NULL, INTERNET_OPEN_TYPE_PRECONFIG, NULL, 0 ); //Bug # 526
    m_hOpenDirect = InternetOpenA ( "LRWizDLL",  INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
    if (m_hOpenDirect == NULL)
    {
        dwRetCode = GetLastError();
        goto done;
    }

    m_hConnect = InternetConnectA (m_hOpenDirect,
                                   lpszCHName,                                        
                                   INTERNET_DEFAULT_HTTPS_PORT ,
                                   NULL,
                                   NULL,
                                   INTERNET_SERVICE_HTTP,
                                   0,       
                                   0) ;
    if ( !m_hConnect )
    {
        dwRetCode = GetLastError();
        goto done;
    }


    m_hRequest = HttpOpenRequestA ( m_hConnect,
                                    "POST",
                                    lpszExtension,
                                    "HTTP/1.0",
                                    NULL,
                                    pszAcceptedTypes,
                                    INTERNET_FLAG_SECURE |
                                    INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
                                    NULL ); //(DWORD)this);
    if ( !m_hRequest )
    {
        dwRetCode = GetLastError();
        goto done;
    }

done:
    if (lpszCHName)
    {
        delete lpszCHName;
    }

    if (lpszExtension)
    {
        delete lpszExtension;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        CloseCHRequest();
    }

    return dwRetCode;
}



DWORD CGlobal::CloseCHRequest(void)
{
    if (m_hRequest)
    {
        InternetCloseHandle(m_hRequest);
        m_hRequest = NULL;
    }

    if (m_hConnect)
    {
        InternetCloseHandle(m_hConnect);
        m_hConnect = NULL;
    }

    if (m_hOpenDirect)
    {
        InternetCloseHandle(m_hOpenDirect);
        m_hOpenDirect = NULL;
    }

    return ERROR_SUCCESS;
}




DWORD CGlobal::Dispatch(BYTE * bpData,
                        DWORD dwLen)
{
    DWORD   dwCHRC = ERROR_SUCCESS;;

    DWORD       dwPostStatus = 0;
    DWORD       dwPostStatusSize = sizeof(dwPostStatus);
    DWORD       dwFlags;
    DWORD       dwBufLen = sizeof(dwFlags);

#ifdef IGNORE_EXPIRATION
    
    LONG lRet;
    HKEY hKey = NULL;
#endif

    assert(m_hOpenDirect != NULL);
    assert(m_hRequest != NULL);
    assert(m_hConnect != NULL);

    try 
    {
        BOOL bRC = TRUE;
        char    szContentType[] = "Content-Type: application/octet-stream\r\n";

        if ( !HttpAddRequestHeadersA ( m_hRequest, szContentType, -1L, HTTP_ADDREQ_FLAG_ADD|HTTP_ADDREQ_FLAG_REPLACE ) )
        {
            DWORD  dwError = GetLastError();
        }

        bRC = HttpSendRequestA( m_hRequest,
                                NULL,
                                0,
                                bpData, //binary data
                                dwLen       //length of the data
                             );
        if (!bRC)
        {
            DWORD dwRetCode = GetLastError();

            if(dwRetCode == ERROR_INTERNET_INVALID_CA || dwRetCode == ERROR_INTERNET_SEC_CERT_DATE_INVALID
                || dwRetCode == ERROR_INTERNET_SEC_CERT_CN_INVALID)
            {

                InternetQueryOptionA(m_hRequest, INTERNET_OPTION_SECURITY_FLAGS,
                                    (LPVOID) &dwFlags, &dwBufLen);
            
#ifdef IGNORE_EXPIRATION

                lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                LICENSE_EXPIRATION_IGNORE ,
                                0,
                                KEY_READ ,
                                &hKey );    

                if( ERROR_SUCCESS == lRet )
                {
                    dwFlags |= SECURITY_FLAG_IGNORE_UNKNOWN_CA;
                    dwFlags |= SECURITY_FLAG_IGNORE_CERT_DATE_INVALID;
                    dwFlags |= SECURITY_FLAG_IGNORE_CERT_CN_INVALID;
                    dwFlags |= SECURITY_FLAG_IGNORE_REVOCATION;

                    InternetSetOptionA(m_hRequest, INTERNET_OPTION_SECURITY_FLAGS,
                                    (LPVOID) &dwFlags, sizeof(dwFlags));

                    bRC = HttpSendRequestA( m_hRequest,
                                            NULL,
                                            0,
                                            bpData, //binary data
                                            dwLen);     //length of the data
                }
                else
                {
#endif
                    if(dwRetCode == ERROR_INTERNET_INVALID_CA)
                    {
                        dwFlags |=SECURITY_FLAG_IGNORE_UNKNOWN_CA;

                        InternetSetOptionA(m_hRequest, INTERNET_OPTION_SECURITY_FLAGS,
                                    (LPVOID) &dwFlags, sizeof(dwFlags));

                        bRC = HttpSendRequestA( m_hRequest,
                                            NULL,
                                            0,
                                            bpData, //binary data
                                            dwLen);     //length of the data
                    }
#ifdef IGNORE_EXPIRATION
                }
#endif
            }

#ifdef IGNORE_EXPIRATION
            if(hKey)
            {
                RegCloseKey(hKey);
            }
#endif
        }
        if (bRC)
        {       
            if ( HttpQueryInfoA( m_hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, (LPVOID)&dwPostStatus, &dwPostStatusSize, NULL ) )
            {
                if ( dwPostStatus != 200 )
                {
                    dwCHRC = CH_ERROR_HTTPQRY_FAILED;
                    throw dwCHRC;
                }
            }
            else
            {
                dwCHRC = GetLastError();
                throw dwCHRC;           
            }
        }
        else
        {
            dwCHRC = GetLastError();
            dwCHRC = CH_ERROR_SEND_FAILED;
            throw dwCHRC;           
        }
    }

    catch (DWORD dwRC)
    {
        dwCHRC = dwRC;
    }

    catch (...)
    {
        assert("Exception in Dispatch() !");
        dwCHRC = CH_ERROR_EXCEPTION;        
    }

    if (dwCHRC != ERROR_SUCCESS)
    {
        if (!CheckIfICWCompleted())
            dwCHRC = IDS_SEND_FAILED_NO_CONN;
        else
        {
            if (!(GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS))
                dwCHRC = IDS_SEND_FAILED_NO_NIC;
            else
                dwCHRC = IDS_SEND_FAILED_NO_OTHER;
        }
    }

    return dwCHRC;
}   

// Check if ICW has already been run
BOOL CGlobal::CheckIfICWCompleted()
{
    DWORD dwICWCompleted = FALSE;
    DWORD dwSize = sizeof(dwICWCompleted);

    HKEY hConnectionKey = NULL;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_ICW_STATUS_PATH, 0, KEY_READ, &hConnectionKey) == ERROR_SUCCESS)
    {
        DWORD type;
        RegQueryValueEx(hConnectionKey, REG_ICW_COMPLETED, NULL , &type, (BYTE*)&dwICWCompleted, &dwSize);
    }

    RegCloseKey(hConnectionKey);

    return dwICWCompleted;
}


DWORD CGlobal::PingCH(void)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    Ping_Request    pingData;
    Ping_Response   pingResp;
    BYTE bResponse[ 1024];
    DWORD dwDataLength;
    
    //
    // Set Language Id
    //
    pingData.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = Dispatch((BYTE *) &pingData, sizeof(Ping_Request));
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }


    dwRetCode = FetchResponse(bResponse, sizeof(bResponse), &dwDataLength);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    // Now let us ensure that we are getting the expected byte stream back
    // AND if we are, we are good to go.
    memcpy(&pingResp, bResponse, sizeof(Ping_Response));
    if (lstrcmp(pingResp.tszPingResponse, L"Beam'er up Scottie!") != 0)
    {
        // Expected Response    
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

done:
    CloseCHRequest();

    return dwRetCode;
}






DWORD CGlobal::ProcessIRegRequest()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    NewCert_Request certRequest;
    NewCert_Response certResponse;
    Certificate_AckRequest certackRequest;
    Certificate_AckResponse certackResponse;


    HCRYPTPROV  hCryptProv   = NULL;
    LPWSTR  lpwszExchgPKCS10 = NULL;
    LPWSTR  lpwszSignPKCS10  = NULL;
    LPBYTE  lpszReqData      = NULL;
    LPBYTE  lpszNextCopyPos  = NULL;
    LPSTR   lpszExchgPKCS10  = NULL;
    LPSTR   lpszSigPKCS10    = NULL;
    DWORD   dwExchangeLen = 0;
    DWORD   dwSignLen = 0;
    DWORD   dwResponseLength = 0;
    PBYTE lpszResData   = NULL;

    DWORD  dwExchgCertLen   = 0;
    DWORD  dwSigCertLen     = 0;
    DWORD  dwRootCertLen    = 0;

    LPSTR   lpszExchCert = NULL;
    LPSTR   lpszSignCert = NULL;
    LPSTR   lpszRootCert = NULL;
    bool    bToSendAck = false;

    //
    // Set the LangId
    //
    certRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode;
    }

    try
    {
        swprintf(certRequest.stCertInfo.OrgName, L"%.*s", CA_CUSTMER_NAME_LEN, (LPCTSTR) m_ContactData.sCompanyName);
        swprintf(certRequest.stCertInfo.OrgUnit, L"%.*s", CA_ORG_UNIT_LEN, (LPCTSTR) m_ContactData.sOrgUnit);
        swprintf(certRequest.stCertInfo.Address, L"%.*s", CA_ADDRESS_LEN, (LPCTSTR) m_ContactData.sContactAddress);
        swprintf(certRequest.stCertInfo.City, L"%.*s", CA_CITY_LEN, (LPCTSTR) m_ContactData.sCity);
        swprintf(certRequest.stCertInfo.State, L"%.*s", CA_STATE_LEN, (LPCTSTR) m_ContactData.sState);
        swprintf(certRequest.stCertInfo.Country, L"%.*s", CA_COUNTRY_LEN, (LPCTSTR) m_ContactData.sCountryCode);
        swprintf(certRequest.stCertInfo.Zip, L"%.*s", CA_ZIP_LEN, (LPCTSTR) m_ContactData.sZip);
        swprintf(certRequest.stCertInfo.LName, L"%.*s", CA_NAME_LEN, (LPCTSTR) m_ContactData.sContactLName);
        swprintf(certRequest.stCertInfo.FName, L"%.*s", CA_NAME_LEN, (LPCTSTR) m_ContactData.sContactFName);
        swprintf(certRequest.stCertInfo.Phone, L"%.*s", CA_PHONE_LEN, (LPCTSTR) m_ContactData.sContactPhone);
        swprintf(certRequest.stCertInfo.Fax, L"%.*s", CA_FAX_LEN, (LPCTSTR) m_ContactData.sContactFax);
        swprintf(certRequest.stCertInfo.Email, L"%.*s", CA_EMAIL_LEN, (LPCTSTR) m_ContactData.sContactEmail);
        swprintf(certRequest.stCertInfo.LSID, L"%.*s", CA_LSERVERID_LEN, (LPCTSTR) m_pLicenseServerID );
        swprintf(certRequest.stCertInfo.ProgramName, L"%.*s", 63, 
            (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT ? L"SELECT" : L"BASIC"));

        //
        // GetGlobalContext()->GetContactDataObject()->sCertType is not set anywhere but is passed
        // to the back end as part of the PKCS10 Request.Not sure what it is used for in the back end
        // Anyway set it to proper value here. Arvind 06/28/99.
        //
        if(GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_SELECT)
            GetGlobalContext()->GetContactDataObject()->sCertType = CA_CERT_TYPE_SELECT;
        else 
            GetGlobalContext()->GetContactDataObject()->sCertType = CA_CERT_TYPE_OTHER;

        do
        {
            //
            //Set the attributes required for creating PKCS10
            //
            SetCARequestAttributes();


            //
            // This function will call the CryptAcquireContext and import 
            // the LS Keys
            //

            if ((dwRetCode = GetCryptContextWithLSKeys(&hCryptProv)) != ERROR_SUCCESS)
            {
                //
                // Newer LSs don't support this call - use alternate
                //

                dwRetCode = AskLSToCreatePKCS10(AT_KEYEXCHANGE, &lpszExchgPKCS10);
                if(dwRetCode != ERROR_SUCCESS)
                    break;

                dwRetCode = AskLSToCreatePKCS10(AT_SIGNATURE, &lpszSigPKCS10);
                if(dwRetCode != ERROR_SUCCESS)
                    break;
            }
            else
            {
                dwRetCode = CreateLSPKCS10(hCryptProv,AT_KEYEXCHANGE, &lpszExchgPKCS10);
                if(dwRetCode != ERROR_SUCCESS)
                    break;

                dwRetCode = CreateLSPKCS10(hCryptProv,AT_SIGNATURE, &lpszSigPKCS10);
                if(dwRetCode != ERROR_SUCCESS)
                    break;

                // Release the context
                if(hCryptProv)
                {
                    DoneWithCryptContextWithLSKeys ( hCryptProv );
                }
            }
        
            //
            //Certificate Type
            //
            //Convert from multibyte to unicode
            lpwszExchgPKCS10 = AnsiToUnicode(lpszExchgPKCS10);
            lpwszSignPKCS10 = AnsiToUnicode(lpszSigPKCS10);

            dwExchangeLen = lstrlen(lpwszExchgPKCS10) * sizeof(WCHAR);
            dwSignLen = lstrlen(lpwszSignPKCS10) * sizeof(WCHAR);

            certRequest.SetExchgPKCS10Length(dwExchangeLen);
            certRequest.SetSignPKCS10Length(dwSignLen);
            certRequest.SetDataLen(dwExchangeLen+dwSignLen);

            certRequest.SetServerName(m_lpstrLSName);

            //Allocate buffer for the request
            lpszReqData = (LPBYTE) LocalAlloc( GPTR, dwExchangeLen+dwSignLen+sizeof(certRequest) );
            if(lpszReqData == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            lpszNextCopyPos = lpszReqData;
            memcpy(lpszNextCopyPos, &certRequest, sizeof(certRequest));
            lpszNextCopyPos += sizeof(certRequest);

            memcpy ( lpszNextCopyPos, lpwszExchgPKCS10, dwExchangeLen);
            lpszNextCopyPos += dwExchangeLen;

            memcpy ( lpszNextCopyPos, lpwszSignPKCS10, dwSignLen);      



            dwRetCode = Dispatch(lpszReqData, dwExchangeLen+dwSignLen+sizeof(certRequest));
            if ( lpszReqData )
            {
                LocalFree(lpszReqData);
            }
            if (dwRetCode != ERROR_SUCCESS)
            {
                LRSetLastError(dwRetCode);
                break;
            }


            dwRetCode = FetchResponse((BYTE *) &certResponse, sizeof(NewCert_Response), &dwResponseLength);
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }

            if (dwResponseLength != sizeof(NewCert_Response))
            {
                // Got an invalid response back
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            switch(certResponse.RequestHeader.GetResponseType())
            {
            case Response_Success:
                dwRetCode = ERROR_SUCCESS;
                break;

            case Response_Failure:
                dwRetCode = IDS_ERR_CHFAILURE;
                break;

            case Response_InvalidData:
                dwRetCode = IDS_ERR_CHINVALID_DATA;
                break;

            case Response_NotYetImplemented:
                dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
                break;

            case Response_ServerError:
                dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
                break;

            case Response_Invalid_Response:
            default:
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }

            //dwRetCode = SetLRState(LRSTATE_ONLINE_CR_CREATED);

            // OK, allocate enough memory to read the rest fo the data
            lpszResData = (PBYTE) LocalAlloc(GPTR, certResponse.GetDataLen() + 1);
            if(lpszResData == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = FetchResponse(lpszResData, certResponse.GetDataLen() + 1,
                                      &dwResponseLength);
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }
            if (dwResponseLength != certResponse.GetDataLen())
            {
                // Didn't get the expected number of Bytes, also a problem
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            bToSendAck = true;

            dwExchgCertLen = certResponse.GetExchgPKCS7Length();
            dwSigCertLen = certResponse.GetSignPKCS7Length();
            dwRootCertLen = certResponse.GetRootCertLength();
            if(dwRootCertLen == 0 || dwExchgCertLen == 0 || dwSigCertLen == 0 )
            {
                dwRetCode = IDS_ERR_INVALID_PIN;
                break;
            }

            //
            // Exchange Certificate
            //
            lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchgCertLen/sizeof(WCHAR));
            if ( lpszExchCert == NULL )
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }           
            
            //
            // Signature Certificate
            //
            lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchgCertLen), dwSigCertLen/sizeof(WCHAR));
            if(lpszSignCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }


            //
            // Root Certificate
            //
            lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchgCertLen+dwSigCertLen),
                                        dwRootCertLen/sizeof(WCHAR));
            if(lpszRootCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = SetLSSPK(certResponse.GetSPK());
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }


            dwRetCode = DepositLSSPK();
            if (dwRetCode != ERROR_SUCCESS)
            {
                if (dwRetCode == IDS_ERR_DEPOSITSPK)
                {
                    dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
                }
                break;
            }


            //
            //Deposit the Certs
            //
            dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
                                                lstrlenA(lpszExchCert),
                                                (PBYTE)lpszSignCert,
                                                lstrlenA(lpszSignCert),
                                                (PBYTE)lpszRootCert,
                                                lstrlenA(lpszRootCert)
                                              );
            if ( dwRetCode != ERROR_SUCCESS )
            {
                // If this happened and the SPK deposit succeeded, we have an 
                // inconsistent state, now
                DWORD dwReturn;
                DWORD dwOriginal = LRGetLastError();

                dwReturn = ResetLSSPK(FALSE);
                if (dwReturn != ERROR_SUCCESS)
                {
                    // what to do, if even this failed.  OUCH OUCH
                    dwRetCode = dwReturn;
                }
                LRSetLastError(dwOriginal);
                m_pRegistrationID[ 0] = 0;
                break;
            }
            else
            {
                dwRetCode = SetLRState(LRSTATE_NEUTRAL);
            }

            /*
            lpszResData = (PBYTE) LocalAlloc(GPTR, certResponse.GetDataLen() + 1);
            if(lpszResData == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = FetchResponse(lpszResData, certResponse.GetDataLen() + 1,
                                      &dwResponseLength);
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }
            if (dwResponseLength != certResponse.GetDataLen())
            {
                // Didn't get the expected number of Bytes, also a problem
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            bToSendAck = true;


            dwExchgCertLen = certResponse.GetExchgPKCS7Length();
            dwSigCertLen = certResponse.GetSignPKCS7Length();
            dwRootCertLen = certResponse.GetRootCertLength();
            if(dwRootCertLen == 0 || dwExchgCertLen == 0 || dwSigCertLen == 0 )
            {
                dwRetCode = IDS_ERR_CHBAD_DATA; //IDS_ERR_INVALID_PIN;
                break;
            }

            //
            // Exchange Certificate
            //
            lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchgCertLen/sizeof(WCHAR));
            if ( lpszExchCert == NULL )
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }           
            
            //
            // Signature Certificate
            //
            lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchgCertLen), dwSigCertLen/sizeof(WCHAR));
            if(lpszSignCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }


            //
            // Root Certificate
            //
            lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchgCertLen+dwSigCertLen),
                                        dwRootCertLen/sizeof(WCHAR));
            if(lpszRootCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = DepositLSSPK(certResponse.GetSPK());
            if (dwRetCode != ERROR_SUCCESS)
            {
                
                //if (dwRetCode == IDS_ERR_DEPOSITSPK)
                //{
                //  dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
                //}
                
                    break;
            }

            //
            //Deposit the Certs
            //
            dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
                                                lstrlenA(lpszExchCert),
                                                (PBYTE)lpszSignCert,
                                                lstrlenA(lpszSignCert),
                                                (PBYTE)lpszRootCert,
                                                lstrlenA(lpszRootCert)
                                              );
            if ( dwRetCode != ERROR_SUCCESS )
            {
                break;
            }

            //dwRetCode = SetLRState(LRSTATE_NEUTRAL);

            //if the response comming back is SUCCESS, check for certificates
            //in the response structure.  If there is response
            //perform the deposit LS Certificates routine
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }


            //
            // Now save the State in the Registry
            //
            //dwRetCode = SetLRState(LRSTATE_ONLINE_CR_CREATED);
            */
        }
        while(false);

    }
    catch(...)
    {
        dwRetCode = IDS_ERR_EXCEPTION;
    }

    CloseCHRequest();

    if (bToSendAck == true)
    {
        if (InitCHRequest() == ERROR_SUCCESS)
        {
            // Everything deposited OK
            // Time to send the Ack
            certackRequest.SetRegRequestId((BYTE *) certResponse.GetRegRequestId(),
                                       (lstrlen(certResponse.GetRegRequestId())+1)*sizeof(TCHAR));
            certackRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
            Dispatch((BYTE *) &certackRequest, sizeof(certackRequest));
            // Ignore the Return value --- So what if the Ack gets lost

            // Read the response
            FetchResponse((BYTE *) &certackResponse, sizeof(certackResponse),
                                  &dwResponseLength);
            // Ignore the Return value --- So what if the Ack gets lost
            CloseCHRequest();
        }
    }

    //
    //Free up Mem
    //

    ClearCARequestAttributes();

    if(lpszExchgPKCS10)
    {
        delete lpszExchgPKCS10;
    }

    if(lpszSigPKCS10)
    {
        delete lpszSigPKCS10;
    }

    if ( lpwszExchgPKCS10 )
    {
        delete lpwszExchgPKCS10;
    }

    if (lpwszSignPKCS10)
    {
        delete lpwszSignPKCS10;
    }

    if ( lpszExchCert )
    {
        delete lpszExchCert;
    }

    if ( lpszSignCert )
    {
        delete lpszSignCert;
    }

    if ( lpszRootCert )
    {
        delete lpszRootCert;
    }

    if (lpszResData)
    {
        LocalFree(lpszResData);
    }

    return dwRetCode;
}





DWORD CGlobal::ProcessCertDownload()
{
    DWORD dwRetCode = ERROR_SUCCESS;

    CertificateDownload_Request  certdownloadRequest;
    CertificateDownload_Response certdownloadResponse;
    Certificate_AckRequest certackRequest;
    Certificate_AckResponse certackResponse;

    PBYTE lpszResData   = NULL;

    DWORD  dwExchgCertLen   = 0;
    DWORD  dwSigCertLen     = 0;
    DWORD  dwRootCertLen    = 0;

    LPSTR   lpszExchCert = NULL;
    LPSTR   lpszSignCert = NULL;
    LPSTR   lpszRootCert = NULL;
    DWORD   dwResponseLength;
    bool bToSendAck = false;
    
    //
    // Set the Language Id
    //
    certdownloadRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode;
    }

    try
    {
        do
        {
            //
            // Create CHRequest for Certificate Download
            //
            certdownloadRequest.SetPIN((BYTE *) m_lpstrPIN, (lstrlenW(m_lpstrPIN)+1) * sizeof(WCHAR));

            dwRetCode = Dispatch((BYTE *) &certdownloadRequest, sizeof(CertificateDownload_Request));
            if(dwRetCode != ERROR_SUCCESS)
            {
                LRSetLastError(dwRetCode);
                break;
            }

            // Let us first Fetch the certdownloadResponse
            dwRetCode = FetchResponse((BYTE *) &certdownloadResponse,
                                      sizeof(CertificateDownload_Response), &dwResponseLength);
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }
            if (dwResponseLength != sizeof(CertificateDownload_Response))
            {
                // Didn't get the expected number of Bytes, also a problem
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }
            switch(certdownloadResponse.RequestHeader.GetResponseType())
            {
            case Response_Success:
                dwRetCode = ERROR_SUCCESS;
                break;

            case Response_Failure:
//              dwRetCode = IDS_ERR_CHFAILURE;
                //dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
                dwRetCode = IDS_ERR_INVALID_PIN;
                break;

            case Response_InvalidData:
                dwRetCode = IDS_ERR_CHINVALID_DATA;
                break;

            case Response_NotYetImplemented:
                dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
                break;

            case Response_ServerError:
                dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
                break;

            case Response_Invalid_Response:
            default:
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }


            // OK, allocate enough memory to read the rest fo the data
            lpszResData = (PBYTE) LocalAlloc(GPTR, certdownloadResponse.GetDataLen() + 1);
            if(lpszResData == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = FetchResponse(lpszResData, certdownloadResponse.GetDataLen() + 1,
                                      &dwResponseLength);
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }
            if (dwResponseLength != certdownloadResponse.GetDataLen())
            {
                // Didn't get the expected number of Bytes, also a problem
                dwRetCode = IDS_ERR_CHBAD_DATA;
                break;
            }

            bToSendAck = true;

            dwExchgCertLen = certdownloadResponse.GetExchgPKCS7Length();
            dwSigCertLen = certdownloadResponse.GetSignPKCS7Length();
            dwRootCertLen = certdownloadResponse.GetRootCertLength();
            if(dwRootCertLen == 0 || dwExchgCertLen == 0 || dwSigCertLen == 0 )
            {
                dwRetCode = IDS_ERR_INVALID_PIN;
                break;
            }

            //
            // Exchange Certificate
            //
            lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchgCertLen/sizeof(WCHAR));
            if ( lpszExchCert == NULL )
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }           
            
            //
            // Signature Certificate
            //
            lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchgCertLen), dwSigCertLen/sizeof(WCHAR));
            if(lpszSignCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }


            //
            // Root Certificate
            //
            lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchgCertLen+dwSigCertLen),
                                        dwRootCertLen/sizeof(WCHAR));
            if(lpszRootCert == NULL)
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                break;
            }

            dwRetCode = SetLSSPK(certdownloadResponse.GetSPK());
            if (dwRetCode != ERROR_SUCCESS)
            {
                break;
            }


            dwRetCode = DepositLSSPK();
            if (dwRetCode != ERROR_SUCCESS)
            {
                if (dwRetCode == IDS_ERR_DEPOSITSPK)
                {
                    dwRetCode = IDS_ERR_CERT_DEPOSIT_LSERROR;
                }
                break;
            }


            //
            //Deposit the Certs
            //
            dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
                                                lstrlenA(lpszExchCert),
                                                (PBYTE)lpszSignCert,
                                                lstrlenA(lpszSignCert),
                                                (PBYTE)lpszRootCert,
                                                lstrlenA(lpszRootCert)
                                              );
            if ( dwRetCode != ERROR_SUCCESS )
            {
                // If this happened and the SPK deposit succeeded, we have an 
                // inconsistent state, now
                DWORD dwReturn;
                DWORD dwOriginal = LRGetLastError();

                dwReturn = ResetLSSPK(FALSE);
                if (dwReturn != ERROR_SUCCESS)
                {
                    // what to do, if even this failed.  OUCH OUCH
                    dwRetCode = dwReturn;
                }
                LRSetLastError(dwOriginal);
                m_pRegistrationID[ 0] = 0;
                break;
            }
            else
            {
                dwRetCode = SetLRState(LRSTATE_NEUTRAL);
            }

        }
        while(false);
    }
    catch(...)
    {
        dwRetCode = IDS_ERR_EXCEPTION;
    }

    CloseCHRequest();


    // Now to send the Ack
    if (bToSendAck == true)
    {
        if (InitCHRequest() == ERROR_SUCCESS)
        {
            // Everything deposited OK
            // Time to send the Ack
            certackRequest.SetRegRequestId((BYTE *) certdownloadResponse.GetRegRequestId(),
                                       (lstrlen(certdownloadResponse.GetRegRequestId())+1)*sizeof(TCHAR));
            certackRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
            Dispatch((BYTE *) &certackRequest, sizeof(certackRequest));
            // Ignore the Return value --- So what if the Ack gets lost

            // Read the response
            FetchResponse((BYTE *) &certackResponse, sizeof(certackResponse),
                                  &dwResponseLength);
            // Ignore the Return value --- So what if the Ack gets lost
            CloseCHRequest();
        }
    }
    
    if ( lpszExchCert )
    {
        delete lpszExchCert;
    }

    if ( lpszSignCert )
    {
        delete lpszSignCert;
    }

    if ( lpszRootCert )
    {
        delete lpszRootCert;
    }

    if (lpszResData)
    {
        LocalFree(lpszResData);
    }


    return dwRetCode;
}







DWORD CGlobal::AuthenticateLS()
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    DWORD       dwResponseLength;
    BYTE *      lpszReqData = NULL;
    BYTE *      lpszResData = NULL;
    Validate_Response  valResponse;
    Validate_Request   valRequest;


    if (GetLSStatus() == LSERVERSTATUS_REGISTER_OTHER)
    {
        DWORD dwStatus;
        // This LS was registered on the phone.  First perform SignOnly, Then read the certs into memory
        dwRetCode = ProcessCASignOnlyRequest();
        if (dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }

        dwRetCode = GetLSCertificates(&dwStatus);
        if (dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }

        assert(dwStatus == LSERVERSTATUS_REGISTER_INTERNET);
    }
    

    //
    // Set Language Id
    //
    valRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(Validate_Request)+m_dwExchangeCertificateLen);
    if(lpszReqData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }
    valRequest.SetDataLen(m_dwExchangeCertificateLen);
    valRequest.SetCertBlobLen(m_dwExchangeCertificateLen);
    valRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));

    memcpy(lpszReqData, &valRequest, sizeof(Validate_Request));
    memcpy(lpszReqData+sizeof(Validate_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen);

    dwRetCode = Dispatch(lpszReqData, sizeof(Validate_Request)+m_dwExchangeCertificateLen);
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }

    // Let us read the response
    dwRetCode = FetchResponse((BYTE *) &valResponse, sizeof(Validate_Response),
                              &dwResponseLength);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }
    if (dwResponseLength != sizeof(Validate_Response))
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

//  if (valResponse.m_dwRetCode != ERROR_SUCCESS)
//  {
//      dwRetCode = valResponse.m_dwRetCode;
//      goto done;
//  }
    switch(valResponse.RequestHeader.GetResponseType())
    {
    case Response_Success:
        dwRetCode = ERROR_SUCCESS;
        break;

    case Response_Failure:
//      dwRetCode = IDS_ERR_CHFAILURE;
        dwRetCode = IDS_ERR_AUTH_FAILED;
        break;

    case Response_Reg_Bad_SPK:
        dwRetCode = IDS_ERR_SPKBAD;
        break;

    case Response_Reg_Bad_Cert:
        dwRetCode = IDS_ERR_CERTBAD;
        break;

    case Response_Reg_Expired:
        dwRetCode = IDS_ERR_CERTEXPIRED;
        break;

    case Response_Reg_Revoked:
        dwRetCode = IDS_ERR_CERTREVOKED;
        break;

    case Response_InvalidData:
        dwRetCode = IDS_ERR_CHINVALID_DATA;
        break;

    case Response_NotYetImplemented:
        dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
        break;

    case Response_ServerError:
        dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
        break;

    case Response_Invalid_Response:
    default:
        dwRetCode = IDS_ERR_CHBAD_DATA;
        break;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }


    // OK, allocate enough memory to read the rest fo the data
    lpszResData = (PBYTE) LocalAlloc(GPTR, valResponse.GetDataLen() + 1);
    if(lpszResData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }


    dwRetCode = FetchResponse(lpszResData, valResponse.GetDataLen() + 1,
                                      &dwResponseLength);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLength != valResponse.GetDataLen())
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    dwRetCode = SetCHCert ( REG_ROOT_CERT,
                            lpszResData, 
                            valResponse.GetCHRootCertLen());
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = SetCHCert ( REG_EXCHG_CERT,
                            lpszResData+valResponse.GetCHRootCertLen(),
                            valResponse.GetCHExchCertLen() );
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = SetCHCert ( REG_SIGN_CERT,
                            lpszResData+valResponse.GetCHRootCertLen()+valResponse.GetCHExchCertLen(),
                            valResponse.GetCHSignCertLen() );

done:
    CloseCHRequest();

    if (lpszReqData)
        LocalFree(lpszReqData);

    if (lpszResData)
        LocalFree(lpszResData);


    return dwRetCode;
}


DWORD CGlobal::DownloadLKPBatch(ProductType productTypeFilter)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    NewLKP_Request lkpRequest;
    NewLKP_AckRequest       lkpAckRequest;
    PBYTE  pbLKPRequest = NULL;
    DWORD  dwReqLen = 0;
    NewLKP_Response         lkpResponse;
    DWORD  dwResponseLen = 0;
    NewLKP_AckResponse      lkpAckResponse;
    PBYTE  lpszResData = NULL;
    bool bToSendAck = false;

    // Set Language ID
    lkpRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
        goto done;

    // Set LKP Request Attributes
    SetCHRequestAttributes();
    lkpRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));

    dwRetCode = CreateLKPRequest(&pbLKPRequest, &lkpRequest, dwReqLen, productTypeFilter);
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    dwRetCode = Dispatch(pbLKPRequest, dwReqLen);
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }

    // Let us first Fetch the certdownloadResponse
    dwRetCode = FetchResponse((BYTE *) &lkpResponse,
                              sizeof(NewLKP_Response), &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
        goto done;

    if (dwResponseLen != sizeof(NewLKP_Response))
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    bToSendAck = true;

    // OK, allocate enough memory to read the rest fo the data
    lpszResData = (PBYTE) LocalAlloc(GPTR, lkpResponse.GetDataLen() + 1);
    if(lpszResData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    dwRetCode = FetchResponse(lpszResData, lkpResponse.GetDataLen() + 1,
                              &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
        goto done;

    if (dwResponseLen != lkpResponse.GetDataLen())
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    switch(lkpResponse.RequestHeader.GetResponseType())
    {
        case Response_Success:
            if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_LICENSE_PAK)
            {
                //Modify the statuses, because some other batch may fail, and the
                //list will be shown to the user
                for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
                {
                    if (GetProductCodeFromKey(m_listRetailSPK[i].lpszSPK) == productTypeFilter)
                        m_listRetailSPK[i].tcStatus = RETAIL_SPK_OK;
                }
            }
            dwRetCode = ERROR_SUCCESS;
            break;

        case Response_Failure:
            dwRetCode = IDS_ERR_CHFAILURE;
            break;

        case Response_SelectMloLicense_NotValid:
            dwRetCode = IDS_ERR_INVALID_PROGINFO;
            break;

        case Response_InvalidData:
            if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_LICENSE_PAK)
            {
                // For retail, if all the LKP were not approved, show the list
                // to the user
                unsigned int filteredIndex = 0;
                for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
                {
                    if (GetProductCodeFromKey(m_listRetailSPK[i].lpszSPK) == productTypeFilter)
                    {
                        //We can't allow it to be tagged with ok, since it won't be
                        //sent to the license server until everything in the batch is ok
                        if (lkpResponse.m_dwRetailSPKStatus[filteredIndex] == RETAIL_SPK_OK)
                            m_listRetailSPK[i].tcStatus = RETAIL_SPK_NULL;
                        else
                            m_listRetailSPK[i].tcStatus = lkpResponse.m_dwRetailSPKStatus[filteredIndex];

                        filteredIndex++;
                    }
                }
                bToSendAck = false;
                dwRetCode = IDS_ERR_SPKERRORS;
            }
            else
                dwRetCode = IDS_ERR_CHINVALID_DATA;
            break;

        case Response_NotYetImplemented:
            dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
            break;

        case Response_ServerError:
            dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
            break;

        case Response_Invalid_Response:
        default:
            dwRetCode = IDS_ERR_CHBAD_DATA;
            break;
    }

    if (dwRetCode != ERROR_SUCCESS)
        goto done;

    DWORD* dwQuantity = NULL;

    dwQuantity = (DWORD*)(&lpszResData[lkpResponse.GetLKPLength() - sizeof(DWORD)]);

    m_ProductQuantity[productTypeFilter] += *dwQuantity;

    dwRetCode = DepositLKPResponse(lpszResData, lkpResponse.GetLKPLength());    

done:

    ClearCHRequestAttributes();

    CloseCHRequest();

    // Now to send the Ack
    if (bToSendAck == true)
    {
        if (InitCHRequest() == ERROR_SUCCESS)
        {
            // Everything deposited OK
            // Time to send the Ack
            lkpAckRequest.SetRegRequestId((BYTE *) lkpResponse.GetRegRequestId(),
                                       (lstrlen(lkpResponse.GetRegRequestId())+1)*sizeof(TCHAR));
            lkpAckRequest.SetLicenseReqId((BYTE *) lkpResponse.GetLicenseReqId(),
                                       (lstrlen(lkpResponse.GetLicenseReqId())+1)*sizeof(TCHAR));
            lkpAckRequest.SetAckType((dwRetCode == ERROR_SUCCESS));
            Dispatch((BYTE *) &lkpAckRequest, sizeof(NewLKP_AckRequest));
            // Ignore the Return value --- So what if the Ack gets lost

            // Read the response
            FetchResponse((BYTE *) &lkpAckResponse, sizeof(NewLKP_AckResponse),
                                  &dwResponseLen);
            // Ignore the Return value --- So what if the Ack gets lost
            CloseCHRequest();
        }
    }

    if(dwRetCode == ERROR_SUCCESS)
    {
        if ( pbLKPRequest ) 
            free(pbLKPRequest);
    }
    if (lpszResData)
        LocalFree(lpszResData);

    return dwRetCode;
}

DWORD CGlobal::ProcessDownloadLKP()
{
    DWORD dwRetCode = ERROR_SUCCESS;

    if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_LICENSE_PAK)
    {
        // Send individual LKP Requests
        for (int nProductTypeIndex = WIN2K_PERSEAT; nProductTypeIndex < NUM_PRODUCT_TYPES; nProductTypeIndex++)
        {
            if (FilteredRetailSPKEntered((ProductType)nProductTypeIndex) > 0)
            {
                DWORD dwIndRetCode = ERROR_SUCCESS;
                dwIndRetCode = DownloadLKPBatch((ProductType)nProductTypeIndex);
                if (dwIndRetCode != ERROR_SUCCESS)
                    dwRetCode = dwIndRetCode;
            }
        }

        //if (dwRetCode == ERROR_SUCCESS)
        //    InitSPKList();
    }
    else
        dwRetCode = DownloadLKPBatch(UNKNOWN_PRODUCT_TYPE);

    return dwRetCode;
}

//Only count codes that are NULL (haven't already been sent) and
//that match the product type filter
DWORD CGlobal::FilteredRetailSPKEntered(ProductType productTypeFilter)
{
    DWORD dwFilteredCount = 0;

    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
    {
        if ((GetProductCodeFromKey(m_listRetailSPK[i].lpszSPK) == productTypeFilter) &&
            (m_listRetailSPK[i].tcStatus == RETAIL_SPK_NULL))
        {
            dwFilteredCount++;
        }
    }

    return dwFilteredCount;
}


DWORD CGlobal::CreateLKPRequest(PBYTE *  ppRequest, NewLKP_Request * nlkppRequest,
                                DWORD &dwDataLen, ProductType productTypeFilter)
{
    DWORD           dwRetCode = ERROR_SUCCESS;
    STREAM_HDR      aStreamHdr;
    BLOCK_HDR       aBlkHdr;        

    DWORD           dwBufSize   = 0;
    BYTE *          pBuf        = NULL;

    PBYTE           pbCHCert = NULL;
    DWORD           dwCHCert = 0;

    PBYTE           pbEncryptedBuf = NULL;

    PBYTE           pbEncodedBlob = NULL;
    DWORD           dwEncodedBlob = 0;  
    DWORD           dwBufLen = 0;
    DWORD           i =0;

    dwDataLen = 0;

    HANDLE  hFile        = INVALID_HANDLE_VALUE;
    DWORD   dwRetSize   = 0;

    //Create the stream header
    _tcscpy ( aStreamHdr.m_szTitle, STREAM_HDR_TITLE );
    aStreamHdr.SetHeader(STREAM_HDR_TYPE);
    aStreamHdr.SetItemCount(0);

    dwBufSize = sizeof(STREAM_HDR);

    if ( ( pBuf = (BYTE *)malloc ( dwBufSize ) ) )
    {
        memcpy ( pBuf, &aStreamHdr, dwBufSize );
    }
    else
    {
        dwRetCode = IDS_ERR_OUTOFMEM;       
        goto done;
    }

    for ( i = 0; i < m_dwRegAttrCount; i++ )        
    {
        //Setup the header here - put name/value pair into a data buffer
        aBlkHdr.m_wType = BLOCK_TYPE_PROP_PAIR;
        aBlkHdr.SetNameSize(lstrlenW( ( m_pRegAttr + i)->lpszAttribute ) * sizeof(WCHAR) );
        aBlkHdr.SetValueSize(( m_pRegAttr + i)->dwValueLen );   
        
        BYTE* pTmpBuf;
        if ( ( pTmpBuf = (BYTE *)realloc (pBuf, dwBufSize + sizeof(BLOCK_HDR) + aBlkHdr.GetNameSize() + aBlkHdr.GetValueSize()) ) ) 
        {
            if (NULL != pTmpBuf)
            {
                pBuf = pTmpBuf;
            }
            else
            {
                dwRetCode = IDS_ERR_OUTOFMEM;
                goto done;
            }

            memcpy ( pBuf + dwBufSize, &aBlkHdr, sizeof ( BLOCK_HDR ) );
            memcpy ( pBuf + dwBufSize + sizeof(BLOCK_HDR) , ( m_pRegAttr + i)->lpszAttribute , aBlkHdr.GetNameSize());
            memcpy ( pBuf + dwBufSize + sizeof (BLOCK_HDR ) +  aBlkHdr.GetNameSize() , ( m_pRegAttr + i)->lpszValue , aBlkHdr.GetValueSize() );

            dwBufSize += sizeof(BLOCK_HDR) + aBlkHdr.GetNameSize()+ aBlkHdr.GetValueSize();

            ((STREAM_HDR*)pBuf)->SetItemCount(((STREAM_HDR*)pBuf)->GetItemCount() + 1 ); 
        }
        else
        {
            dwRetCode = IDS_ERR_OUTOFMEM;           
            goto done;
        }
    }

    dwBufLen =  dwBufSize + m_dwExchangeCertificateLen;

    DWORD dwFilteredProducts = FilteredRetailSPKEntered(productTypeFilter);

    // Also need to allocate the extra memory to hold the retail stuff
    if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_LICENSE_PAK)
        dwBufLen += ((dwFilteredProducts)*LR_RETAILSPK_LEN*sizeof(TCHAR));

    nlkppRequest->RequestHeader.SetLanguageId(GetLSLangId());
    nlkppRequest->SetDataLen(dwBufLen);
    nlkppRequest->SetNewLKPRequestLen(dwBufSize);
    nlkppRequest->SetCertBlobLen(m_dwExchangeCertificateLen);
    nlkppRequest->SetRetailSPKCount(dwFilteredProducts);

    *ppRequest = (PBYTE) malloc ( dwBufLen + sizeof(NewLKP_Request));
    if ( NULL == *ppRequest )
    {
        dwRetCode = IDS_ERR_OUTOFMEM;           
        goto done;
    }
    memset ( *ppRequest, 0, dwBufLen + sizeof(NewLKP_Request));
    memcpy((*ppRequest), nlkppRequest, sizeof(NewLKP_Request));
    memcpy ( ( *ppRequest )+sizeof(NewLKP_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );
    memcpy ( ( *ppRequest )+sizeof(NewLKP_Request)+m_dwExchangeCertificateLen, pBuf, dwBufSize);
    
    if (GetGlobalContext()->GetContactDataObject()->sProgramName == PROGRAM_LICENSE_PAK)
    {
        PBYTE pbCur = (*ppRequest)+sizeof(NewLKP_Request)+m_dwExchangeCertificateLen+dwBufSize; 
        for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
        {
            if (GetProductCodeFromKey(m_listRetailSPK[i].lpszSPK) == productTypeFilter)
            {
                memcpy(pbCur, m_listRetailSPK[i].lpszSPK, LR_RETAILSPK_LEN*sizeof(TCHAR));
                pbCur += LR_RETAILSPK_LEN*sizeof(TCHAR);
            }
        }
    }

    dwDataLen = sizeof(NewLKP_Request) + dwBufLen;

done:
    if ( pbEncryptedBuf )
    {
        LocalFree(pbEncryptedBuf);
    }

    if ( pBuf )
    {
        free ( pBuf );
    }

    if ( dwRetCode != ERROR_SUCCESS )
    {
        if (*ppRequest != NULL)
        {
            free ( *ppRequest );
        }
        dwBufLen = 0;
        *ppRequest = NULL;
    }

    return dwRetCode;
}




DWORD CGlobal::SetConfirmationNumber(TCHAR * tcConf)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    if (wcsspn(tcConf, BASE24_CHARACTERS) != LR_CONFIRMATION_LEN)
    {
        // Extraneous characters in the SPK string
        dwRetCode = IDS_ERR_INVALID_CONFIRMATION_NUMBER;
    } 
    else if (LKPLiteValConfNumber(m_pRegistrationID, m_pLicenseServerID, tcConf) 
                                                            != ERROR_SUCCESS)
    {
        dwRetCode = IDS_ERR_INVALID_CONFIRMATION_NUMBER;
    }

    return dwRetCode;
}




DWORD CGlobal::InitSPKList(void)
{
    for (register int i = 0; i < MAX_RETAILSPKS_IN_BATCH; i++)
    {
        m_listRetailSPK[ i].lpszSPK[ 0] = 0;
        m_listRetailSPK[ i].tcStatus = RETAIL_SPK_NULL;
    }

    m_dwRetailSPKEntered = 0;

    //Initialize the list of product quantities
    for (int nProducts = UNKNOWN_PRODUCT_TYPE; nProducts < NUM_PRODUCT_TYPES; nProducts++)
        m_ProductQuantity[nProducts] = 0;

    return ERROR_SUCCESS;
}



void CGlobal::DeleteRetailSPKFromList(TCHAR * lpszRetailSPK)
{
    bool bFound = false;

    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
    {
        if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
        {
            if (i < MAX_RETAILSPKS_IN_BATCH-1)
            {
                memcpy(m_listRetailSPK + i, 
                       m_listRetailSPK + i + 1,
                       sizeof(RETAILSPK)*(MAX_RETAILSPKS_IN_BATCH-i));
            }
            m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH-1].lpszSPK[ 0] = 0;
            m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH-1].tcStatus = RETAIL_SPK_NULL;
            bFound = true;
            m_dwRetailSPKEntered--;
            break;
        }
    }
    assert(bFound == true);

    return;
}

void CGlobal::ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK)
{
    bool bFound = false;

    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
    {
        if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszOldSPK) == 0)
        {
            if (i < MAX_RETAILSPKS_IN_BATCH-1)
            {
                _tcscpy(m_listRetailSPK[i].lpszSPK,lpszNewSPK);
                m_listRetailSPK[i].tcStatus = RETAIL_SPK_NULL;
            }       
            
            bFound = true;          
            break;
        }
    }
    assert(bFound == true);

    return;
}

int CGlobal::FindStringTruncationPoint(TCHAR* sOriginal, unsigned int nTruncationLength)
{
    if (wcslen(sOriginal) <= nTruncationLength)
        return 0;

    int nOriginalStringIndex = 0;
    for (nOriginalStringIndex = nTruncationLength - 1; nOriginalStringIndex >= 0; nOriginalStringIndex--)
    {
        if (sOriginal[nOriginalStringIndex] == L' ')
            break;
    }

    if (nOriginalStringIndex < 0)
        return nTruncationLength;

    return nOriginalStringIndex;
}

int CGlobal::GetProductWindowMaxStringLength(HWND hListView)
{
    LONG nMaxSize = 0;
    SIZE URLsize;
    HDC hURLWindowDC = GetDC(hListView);

    for (int nListBoxIndex = 0; nListBoxIndex < SendMessage(hListView, LB_GETCOUNT, 0, 0); nListBoxIndex++)
    {        
        TCHAR * pszProductString = NULL;
        
        // Get the text length so we can allocate enough room to hold it
        LRESULT nTextLength = SendMessage(hListView, LB_GETTEXTLEN, nListBoxIndex, 0);
        if (nTextLength == LB_ERR)
            break;

        // Allocate our string, add one for null termination
        pszProductString = (TCHAR*)LocalAlloc(LPTR, (nTextLength + 1) * sizeof(TCHAR));
        if (pszProductString == NULL)
            break;
        
        SendMessage(hListView, LB_GETTEXT, nListBoxIndex, (LPARAM)pszProductString);       

        GetTextExtentPoint32(hURLWindowDC, pszProductString, wcslen(pszProductString), &URLsize);
        if (URLsize.cx > nMaxSize)
            nMaxSize = URLsize.cx;

        LocalFree(pszProductString);
    }

    return (int)nMaxSize;
}

void CGlobal::AddStringToProductWindow(HWND hListView, TCHAR* sProductInfo, int nCurrentPoint, int nTruncationPoint)
{
    TCHAR sTruncatedMessage[PRODUCT_WINDOW_STRING_LENGTH + PRODUCT_WINDOW_NUM_OFFSET_SPACES + 1];
    memset(sTruncatedMessage, 0, sizeof(sTruncatedMessage));
    if (nCurrentPoint > 0)
    {
        for (int nOffsetIndex = 0; nOffsetIndex < PRODUCT_WINDOW_NUM_OFFSET_SPACES; nOffsetIndex++)
            sTruncatedMessage[nOffsetIndex] = L' ';
    }

    if (nTruncationPoint > 0)
        wcsncat(sTruncatedMessage, &sProductInfo[nCurrentPoint], nTruncationPoint);
    else
        wcscat(sTruncatedMessage, &sProductInfo[nCurrentPoint]);

    SendMessage(hListView, LB_ADDSTRING, 0, (LPARAM)(sTruncatedMessage));
    SendMessage(hListView, LB_SETHORIZONTALEXTENT, GetProductWindowMaxStringLength(hListView), 0);
}

//Only include those where the status is 'OK'
void CGlobal::LoadFinishedFromList(HWND hListView)
{
    for (int nProducts = WIN2K_PERSEAT; nProducts < NUM_PRODUCT_TYPES; nProducts++)
    {
        if (m_ProductQuantity[nProducts] > 0)
        {
            //Create the buffer which will be written to the control
            TCHAR sProductInfo[128];
            memset(sProductInfo, 0, sizeof(sProductInfo));

            //Write in the quantity
            TCHAR wQuantityBuf[12];
            memset(wQuantityBuf, 0, sizeof(wQuantityBuf));
            _ltow(m_ProductQuantity[nProducts], wQuantityBuf, 10);
            wcscpy(sProductInfo, wQuantityBuf);
    
            //Add a space character after the quantity
            sProductInfo[wcslen(sProductInfo)] = L' ';

            DWORD dwProductDescriptionID = 0;
            switch (nProducts)
            {
                case WIN2K_PERSEAT:
                    dwProductDescriptionID = IDS_INSTALLED_WIN2K_CLIENT_ACCESS;
                    break;
                case WIN2K_INTERNET:
                    dwProductDescriptionID = IDS_INSTALLED_WIN2K_INTERNET_CONNECTOR;
                    break;
                case WHISTLER_PERUSER:
                    dwProductDescriptionID = IDS_INSTALLED_WHISTLER_PER_USER;
                    break;
                case WHISTLER_PERSEAT:
                    dwProductDescriptionID = IDS_INSTALLED_WHISTLER_PER_SEAT;
                    break;
                default:
                    break;
            }

            if (dwProductDescriptionID)
            {
                //Add the string to the window, but break it up so it will all fit within the width
                LoadString(GetInstanceHandle(), dwProductDescriptionID, &sProductInfo[wcslen(sProductInfo)], ((sizeof(sProductInfo)/ sizeof(TCHAR)) - wcslen(sProductInfo)) );
                int nCurrentPoint = 0;
                int nTruncationPoint = 0;
                while (nTruncationPoint = FindStringTruncationPoint(&sProductInfo[nCurrentPoint], PRODUCT_WINDOW_STRING_LENGTH))
                {
                    AddStringToProductWindow(hListView, sProductInfo, nCurrentPoint, nTruncationPoint);
                    nCurrentPoint += nTruncationPoint;
                }
                AddStringToProductWindow(hListView, sProductInfo, nCurrentPoint, 0);
            }
        }
    }
}

//Exclude those where the status is 'OK'
void CGlobal::LoadUnfinishedFromList(HWND hListView)
{
    DWORD dwErr;
    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++) {
        if (m_listRetailSPK[i].tcStatus != RETAIL_SPK_OK) {
            dwErr = 
            InsertIntoSPKDisplayList(hListView,
                                     m_listRetailSPK[ i].lpszSPK,
                                     m_listRetailSPK[ i].tcStatus);
            if (dwErr != ERROR_SUCCESS) {
                LRMessageBox(NULL, dwErr, IDS_WIZARD_MESSAGE_TITLE);
            }
        }
    }
    return;
}

void CGlobal::LoadFromList(HWND hListView)
{
    DWORD dwErr;

    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++) {
        dwErr = 
        InsertIntoSPKDisplayList(hListView,
                                 m_listRetailSPK[ i].lpszSPK,
                                 m_listRetailSPK[ i].tcStatus);
        if (dwErr != ERROR_SUCCESS) {
            LRMessageBox(NULL, dwErr, IDS_WIZARD_MESSAGE_TITLE);
        }
    }

    return;
}



void CGlobal::UpdateSPKStatus(TCHAR * lpszRetailSPK,
                              TCHAR tcStatus)
{
    bool bFound = false;

    for (register unsigned int i = 0; i < m_dwRetailSPKEntered; i++)
    {
        if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
        {
            m_listRetailSPK[ i].tcStatus = tcStatus;
            bFound = true;
            break;
        }
    }

    assert(bFound == true);

    return;
}

//Fake code generator just used for testing
/*ProductType CGlobal::GetProductCodeFromKey(LPCTSTR lpLicenseKey)
{
    ProductType licenseKeyType = UNKNOWN_PRODUCT_TYPE;

    if (lpLicenseKey)
    {
        switch (lpLicenseKey[0] % 4)
        {
            case 0:
                licenseKeyType = WIN2K_PERSEAT;
                break;
            case 1:
                licenseKeyType = WIN2K_INTERNET;
                break;
            case 2:
                licenseKeyType = WHISTLER_PERUSER;
                break;
            case 3:
                licenseKeyType = WHISTLER_PERSEAT;
                break;
        }
    }

    return licenseKeyType;
}*/

ProductType CGlobal::GetProductCodeFromKey(LPCTSTR lpLicenseKey)
{
    ProductType licenseKeyType = UNKNOWN_PRODUCT_TYPE;

    TCHAR*  lpProductType = NULL;
    DWORD   dwGroupId = 0;
    DWORD   retval = 0;
    retval = GetLCProductType((TCHAR*)lpLicenseKey, &lpProductType, &dwGroupId);
    if (retval == 0)
    {
        if (lpProductType)
        {
            BOOL    fWin2000    = !m_fSupportConcurrent;
            DWORD   dwNumProducts = 0;
    
            if ((!m_fSupportWhistlerCAL) && (!m_fSupportConcurrent))
                dwNumProducts = IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START;
            else if(m_fSupportConcurrent && !(m_fSupportWhistlerCAL))
                dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
            else if((!m_fSupportConcurrent) && m_fSupportWhistlerCAL)
                dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 1;
            else if(m_fSupportConcurrent && m_fSupportWhistlerCAL)
                dwNumProducts = (IDS_PRODUCT_CONCURRENT - IDS_PRODUCT_START) + 2;

            for (DWORD dwIndex = IDS_PRODUCT_START; dwIndex < (IDS_PRODUCT_START + dwNumProducts); dwIndex++)
            {
                if (!m_fSupportConcurrent && (dwIndex == IDS_PRODUCT_CONCURRENT))
                    continue;

                if (!m_fSupportWhistlerCAL && (dwIndex == IDS_PRODUCT_WHISTLER))
                    continue;

                TCHAR lpProductDescription[LR_PRODUCT_DESC_LEN + LR_PRODUCT_CODE_LEN + 1];
                LoadString(GetInstanceHandle(), dwIndex, lpProductDescription, LR_PRODUCT_DESC_LEN + LR_PRODUCT_CODE_LEN + 1);
                
                TCHAR* lpProductCode = NULL;
                lpProductCode = wcsrchr(lpProductDescription, L':') + 1;
                if (lpProductCode)
                {
                    if (wcsncmp(lpProductType, lpProductCode, LR_PRODUCT_CODE_LEN) == 0)
                    {
                        //the code matches, so see which of our enumerations is corresponds to
                        switch (dwIndex)
                        {
                            case IDS_PRODUCT_W2K_CLIENT_ACCESS:
                                licenseKeyType = WIN2K_PERSEAT;
                                break;
                            case IDS_PRODUCT_W2K_INTERNET_CONNECTOR:
                                licenseKeyType = WIN2K_INTERNET;
                                break;
                            case IDS_PRODUCT_WHISTLER_PER_USER:
                                licenseKeyType = WHISTLER_PERUSER;
                                break;
                            case IDS_PRODUCT_WHISTLER_PER_SEAT:
                                licenseKeyType = WHISTLER_PERSEAT;
                                break;
                            default:
                                licenseKeyType = UNKNOWN_PRODUCT_TYPE;
                                break;
                        }
                    }
                }
            }
        }
    }

    return licenseKeyType;
}


//
// Return status
//
DWORD CGlobal::InsertIntoSPKDisplayList(HWND hListView,
                                        TCHAR * lpszRetailSPK,
                                        TCHAR tcStatus)
{
    LVITEM  lvItem;
    TCHAR   lpszBuffer[128];
    DWORD   dwStringToLoad = IDS_RETAILSPKSTATUS_UNKNOWN;
    DWORD   nItem;
    DWORD   dwRet = ERROR_SUCCESS;

    //Let's first make sure we recognize the product type. Otherwise
    //we don't want to insert it into the list
    ProductType nProductType = GetProductCodeFromKey(lpszRetailSPK);

    TCHAR lpProductType[LR_MAX_MSG_CAPTION];
    memset(lpProductType, 0, LR_MAX_MSG_CAPTION * sizeof(TCHAR));
    switch (nProductType) {
    case WIN2K_PERSEAT:
        LoadString(GetInstanceHandle(),IDS_WIN2K_PERSEAT,lpProductType,LR_MAX_MSG_CAPTION);
        break;
    case WIN2K_INTERNET:
        LoadString(GetInstanceHandle(),IDS_WIN2K_INTERNET,lpProductType,LR_MAX_MSG_CAPTION);
        break;
    case WHISTLER_PERUSER:
        LoadString(GetInstanceHandle(),IDS_WHISTLER_PERUSER,lpProductType,LR_MAX_MSG_CAPTION);
        break;
    case WHISTLER_PERSEAT:
        LoadString(GetInstanceHandle(),IDS_WHISTLER_PERSEAT,lpProductType,LR_MAX_MSG_CAPTION);
        break;
    default:
        dwRet = IDS_UNKNOWN_PRODUCTTYPE;
        return dwRet;
        break;
    }

    //Okay, now let's do the insertion
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.pszText = lpszRetailSPK;
    lvItem.cchTextMax = lstrlen(lpszRetailSPK);
    nItem = ListView_InsertItem(hListView, &lvItem);

    switch (tcStatus) {
    case RETAIL_SPK_NULL:
        dwStringToLoad = IDS_RETAILSPKSTATUS_PENDING;
        break;

    case RETAIL_SPK_OK:
        dwStringToLoad = IDS_RETAILSPKSTATUS_OK;
        break;

    case RETAIL_SPK_INVALID_SIGNATURE:
        dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_SIGNATURE;
        break;

    case RETAIL_SPK_INVALID_PRODUCT_TYPE:
        dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_PRODUCT_TYPE;
        break;

    case RETAIL_SPK_INVALID_SERIAL_NUMBER:
        dwStringToLoad = IDS_RETAILSPKSTATUS_INVALID_SERIAL_NUMBER;
        break;

    case RETAIL_SPK_ALREADY_REGISTERED:
        dwStringToLoad = IDS_RETAILSPKSTATUS_ALREADY_REGISTERED;
        break;
    }

    LoadString(GetInstanceHandle(), dwStringToLoad, lpszBuffer, sizeof(lpszBuffer)/sizeof(TCHAR));

    lvItem.iSubItem = 1;
    lvItem.iItem = nItem;
    lvItem.pszText = lpszBuffer;
    lvItem.cchTextMax = lstrlen(lpszBuffer);
    ListView_SetItem(hListView, &lvItem);

    //lpProductType was determined above
    lvItem.iSubItem = 2;
    lvItem.iItem = nItem;
    lvItem.pszText = lpProductType;
    lvItem.cchTextMax = lstrlen(lpProductType);
    ListView_SetItem(hListView, &lvItem);

    return dwRet;
}





DWORD CGlobal::AddRetailSPKToList(HWND hListView,
                                  TCHAR *lpszRetailSPK)
{
    if (m_dwRetailSPKEntered == MAX_RETAILSPKS_IN_BATCH) {
        return IDS_ERR_TOOMANYSPK;
    }

    assert(m_listRetailSPK[ m_dwRetailSPKEntered].lpszSPK[ 0] == 0);
    assert(m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus == RETAIL_SPK_NULL);

    DWORD dwRetCode = ERROR_SUCCESS;
    if (_tcsspn(lpszRetailSPK, BASE24_CHARACTERS) != LR_RETAILSPK_LEN) {
        // Extraneous characters in the SPK string
        dwRetCode = IDS_ERR_INVALIDSPK;
    }

    // Now check for duplication
    for (register unsigned int i = 0; dwRetCode == ERROR_SUCCESS && i < m_dwRetailSPKEntered; i++) {
        if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0) {
            dwRetCode = IDS_ERR_DUPLICATESPK;
        }
    }


    if (dwRetCode == ERROR_SUCCESS) {
        lstrcpy(m_listRetailSPK[ m_dwRetailSPKEntered].lpszSPK, lpszRetailSPK);
        m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus = RETAIL_SPK_NULL;

        dwRetCode =
        InsertIntoSPKDisplayList(
                                hListView, 
                                lpszRetailSPK,
                                m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus);

        if (dwRetCode == ERROR_SUCCESS) {
            m_dwRetailSPKEntered++;
        } else {
            //
            // Error so cancel the add
            //
            m_listRetailSPK[ m_dwRetailSPKEntered].lpszSPK[0] = 0;
            m_listRetailSPK[ m_dwRetailSPKEntered].tcStatus = RETAIL_SPK_NULL;
        }
    }

    return dwRetCode;
}


DWORD CGlobal::ValidateRetailSPK(TCHAR * lpszRetailSPK)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    if (_tcsspn(lpszRetailSPK, BASE24_CHARACTERS) != LR_RETAILSPK_LEN)
    {
        // Extraneous characters in the SPK string
        dwRetCode = IDS_ERR_INVALIDSPK;
    }

    // Now check for duplication
    for (register unsigned int i = 0; dwRetCode == ERROR_SUCCESS && i < m_dwRetailSPKEntered; i++)
    {
        if (lstrcmp(m_listRetailSPK[ i].lpszSPK, lpszRetailSPK) == 0)
        {
            dwRetCode = IDS_ERR_DUPLICATESPK;
        }
    }

    return dwRetCode;
}

DWORD CGlobal::ProcessCASignOnlyRequest()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    CertificateSignOnly_Request certsoRequest;
    CertificateSignOnly_Response certsoResponse;

    HCRYPTPROV  hCryptProv   = NULL;
    LPWSTR  lpwszExchgPKCS10 = NULL;
    LPWSTR  lpwszSignPKCS10  = NULL;
    LPBYTE  lpszReqData      = NULL;
    LPBYTE  lpszResData      = NULL;
    LPBYTE  lpszNextCopyPos  = NULL;
    LPSTR   lpszExchgPKCS10  = NULL;
    LPSTR   lpszSigPKCS10    = NULL;
    DWORD   dwExchangeLen = 0;
    DWORD   dwSignLen = 0;
    DWORD   dwRootLen = 0;
    DWORD   dwResponseLength = 0;
    LPSTR   lpszExchCert = NULL;
    LPSTR   lpszSignCert = NULL;
    LPSTR   lpszRootCert = NULL;

    //
    // Set Language Id
    //
    certsoRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode;
    }

    SetCARequestAttributes();


    //
    //This function will call the CryptAcquireContext and import the LS Keys 
    //          
    if ( ( dwRetCode = GetCryptContextWithLSKeys (&hCryptProv )  )!= ERROR_SUCCESS )
    {
        //
        // Newer LSs don't support this call - use alternate
        //

        dwRetCode = AskLSToCreatePKCS10(AT_KEYEXCHANGE, &lpszExchgPKCS10);
        if(dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }

        dwRetCode = AskLSToCreatePKCS10(AT_SIGNATURE, &lpszSigPKCS10);
        if(dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }
    }
    else
    {
        dwRetCode = CreateLSPKCS10(hCryptProv,AT_KEYEXCHANGE,&lpszExchgPKCS10);
        if(dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }

        dwRetCode = CreateLSPKCS10(hCryptProv,AT_SIGNATURE, &lpszSigPKCS10);
        if(dwRetCode != ERROR_SUCCESS)
        {
            goto done;
        }

        // Release the context
        if(hCryptProv)
        {
            DoneWithCryptContextWithLSKeys ( hCryptProv );
        }
    }
        
    //
    //Certificate Type
    //

    //Convert from multibyte to unicode
    lpwszExchgPKCS10 = AnsiToUnicode(lpszExchgPKCS10);
    lpwszSignPKCS10 = AnsiToUnicode(lpszSigPKCS10);

    dwExchangeLen = lstrlen(lpwszExchgPKCS10) * sizeof(WCHAR);
    dwSignLen = lstrlen(lpwszSignPKCS10) * sizeof(WCHAR);

    certsoRequest.SetExchgPKCS10Length(dwExchangeLen);
    certsoRequest.SetSignPKCS10Length(dwSignLen);
    certsoRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
    certsoRequest.SetDataLen(dwExchangeLen+dwSignLen);
   
    certsoRequest.SetServerName(m_lpstrLSName);

    //Allocate buffer for the request
    lpszReqData = (LPBYTE) LocalAlloc( GPTR, dwExchangeLen+dwSignLen+sizeof(certsoRequest) );
    if(lpszReqData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    lpszNextCopyPos = lpszReqData;
    memcpy(lpszNextCopyPos, &certsoRequest, sizeof(certsoRequest));
    lpszNextCopyPos += sizeof(certsoRequest);

    memcpy ( lpszNextCopyPos, lpwszExchgPKCS10, dwExchangeLen);
    lpszNextCopyPos += dwExchangeLen;

    memcpy ( lpszNextCopyPos, lpwszSignPKCS10, dwSignLen);      

    dwRetCode = Dispatch(lpszReqData, dwExchangeLen+dwSignLen+sizeof(certsoRequest));
    if ( lpszReqData )
    {
        LocalFree(lpszReqData);
    }
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }


    dwRetCode = FetchResponse((BYTE *) &certsoResponse, 
                              sizeof(CertificateSignOnly_Response),
                              &dwResponseLength);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLength != sizeof(CertificateSignOnly_Response))
    {
        // Got an invalid response back
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    switch(certsoResponse.RequestHeader.GetResponseType())
    {
    case Response_Success:
        dwRetCode = ERROR_SUCCESS;
        break;

    case Response_Failure:
//      dwRetCode = IDS_ERR_CHFAILURE;
        dwRetCode = IDS_ERR_AUTH_FAILED;
        break;

    case Response_Reg_Bad_SPK:
        dwRetCode = IDS_ERR_SPKBAD;
        break;

    case Response_Reg_Expired:
        dwRetCode = IDS_ERR_CERTEXPIRED;
        break;

    case Response_Reg_Revoked:
        dwRetCode = IDS_ERR_CERTREVOKED;
        break;

    case Response_InvalidData:
        dwRetCode = IDS_ERR_CHINVALID_DATA;
        break;

    case Response_NotYetImplemented:
        dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
        break;

    case Response_ServerError:
        dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
        break;

    case Response_Invalid_Response:
    default:
        dwRetCode = IDS_ERR_CHBAD_DATA;
        break;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }


    // OK, allocate enough memory to read the rest fo the data
    lpszResData = (PBYTE) LocalAlloc(GPTR, certsoResponse.GetDataLen() + 1);
    if(lpszResData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    dwRetCode = FetchResponse(lpszResData, certsoResponse.GetDataLen() + 1,
                              &dwResponseLength);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLength != certsoResponse.GetDataLen() ||
        dwResponseLength <= 0)
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    dwExchangeLen = certsoResponse.GetExchgPKCS7Length();
    dwSignLen = certsoResponse.GetSignPKCS7Length();
    dwRootLen = certsoResponse.GetRootCertLength();
    if(dwRootLen == 0 || dwExchangeLen == 0 || dwSignLen == 0 )
    {
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    //
    // Exchange Certificate
    //
    lpszExchCert = UnicodeToAnsi((LPWSTR)lpszResData, dwExchangeLen/sizeof(WCHAR));
    if ( lpszExchCert == NULL )
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }           
    
    //
    // Signature Certificate
    //
    lpszSignCert = UnicodeToAnsi((LPWSTR)(lpszResData + dwExchangeLen), dwSignLen/sizeof(WCHAR));
    if(lpszSignCert == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }


    //
    // Root Certificate
    //
    lpszRootCert = UnicodeToAnsi ((LPWSTR)(lpszResData+dwExchangeLen+dwSignLen),
                                dwRootLen/sizeof(WCHAR));
    if(lpszRootCert == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    //
    //Deposit the Certs
    //
    dwRetCode = DepositLSCertificates(  (PBYTE)lpszExchCert,
                                        lstrlenA(lpszExchCert),
                                        (PBYTE)lpszSignCert,
                                        lstrlenA(lpszSignCert),
                                        (PBYTE)lpszRootCert,
                                        lstrlenA(lpszRootCert)
                                      );
    if ( dwRetCode != ERROR_SUCCESS )
    {
        goto done;
    }


done:

    ClearCARequestAttributes();

    CloseCHRequest();
    //
    //Free up Certificate Mem
    //
    if(lpszExchgPKCS10)
    {
        delete lpszExchgPKCS10;
    }

    if(lpszSigPKCS10)
    {
        delete lpszSigPKCS10;
    }

    if ( lpwszExchgPKCS10 )
    {
        delete lpwszExchgPKCS10;
    }

    if (lpwszSignPKCS10)
    {
        delete lpwszSignPKCS10;
    }


    if ( lpszExchCert )
    {
        delete lpszExchCert;
    }

    if ( lpszSignCert )
    {
        delete lpszSignCert;
    }

    if ( lpszRootCert )
    {
        delete lpszRootCert;
    }

    if (lpszResData)
    {
        LocalFree(lpszResData);
    }

    return dwRetCode;
}







DWORD CGlobal::ProcessCHReissueLKPRequest()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    ReissueLKP_Request  lkpRequest;
    ReissueLKP_Response lkpResponse;
    PBYTE   lpszReqData = NULL;
    PBYTE   lpszResData = NULL;
    DWORD  dwResponseLen;

    //
    // Set Language Id
    //
    lkpRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }
    //
    // Set LKP Request Attributes
    //
    lkpRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
    lkpRequest.SetCertBlobLen(m_dwExchangeCertificateLen);
    lkpRequest.SetDataLen(m_dwExchangeCertificateLen);


    // OK, allocate enough memory to read the rest fo the data
    lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(ReissueLKP_Request)+m_dwExchangeCertificateLen);
    if(lpszReqData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    memcpy(lpszReqData, &lkpRequest, sizeof(ReissueLKP_Request));
    memcpy(lpszReqData+sizeof(ReissueLKP_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );

    dwRetCode = Dispatch(lpszReqData, sizeof(ReissueLKP_Request)+m_dwExchangeCertificateLen);
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }


    // Let us first Fetch the certdownloadResponse
    dwRetCode = FetchResponse((BYTE *) &lkpResponse,
                              sizeof(ReissueLKP_Response), &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLen != sizeof(ReissueLKP_Response))
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    switch(lkpResponse.RequestHeader.GetResponseType())
    {
    case Response_Success:
        dwRetCode = ERROR_SUCCESS;
        break;

    case Response_Failure:
        dwRetCode = IDS_ERR_CHFAILURE;
        break;

    case Response_InvalidData:
        dwRetCode = IDS_ERR_CHINVALID_DATA;
        break;

    case Response_NotYetImplemented:
        dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
        break;

    case Response_ServerError:
        dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
        break;

    case Response_Invalid_Response:
    default:
        dwRetCode = IDS_ERR_CHBAD_DATA;
        break;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    // OK, allocate enough memory to read the rest fo the data
    lpszResData = (PBYTE) LocalAlloc(GPTR, lkpResponse.GetDataLen() + 1);
    if(lpszResData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    dwRetCode = FetchResponse(lpszResData, lkpResponse.GetDataLen() + 1, &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }


    if (dwResponseLen != lkpResponse.GetDataLen() || dwResponseLen <= 0)
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    dwRetCode = DepositLKPResponse(lpszResData, lkpResponse.GetLKPLength());            


done:
    CloseCHRequest();

    if (lpszReqData)
    {
        LocalFree(lpszReqData);
    }

    if (lpszResData)
    {
        LocalFree(lpszResData);
    }


    return dwRetCode;
}




DWORD CGlobal::ProcessCHRevokeCert()
{
    DWORD dwRetCode = ERROR_SUCCESS;
    CertRevoke_Request  crRequest;
    CertRevoke_Response crResponse;
    PBYTE   lpszReqData = NULL;
    DWORD  dwResponseLen;
    error_status_t      esRPC           = ERROR_SUCCESS;

    //
    // Set Language Id
    //
    crRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Set CR Request Attributes
    //
    crRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
    crRequest.SetLName((BYTE *) (LPCTSTR) m_ContactData.sContactLName, (wcslen(m_ContactData.sContactLName)+1)*sizeof(TCHAR));
    crRequest.SetFName((BYTE *) (LPCTSTR) m_ContactData.sContactFName, (wcslen(m_ContactData.sContactFName)+1)*sizeof(TCHAR));
    crRequest.SetPhone((BYTE *) (LPCTSTR) m_ContactData.sContactPhone, (wcslen(m_ContactData.sContactPhone)+1)*sizeof(TCHAR));
    crRequest.SetFax((BYTE *) (LPCTSTR) m_ContactData.sContactFax, (wcslen(m_ContactData.sContactFax)+1)*sizeof(TCHAR));
    crRequest.SetEMail((BYTE *) (LPCTSTR) m_ContactData.sContactEmail, (wcslen(m_ContactData.sContactEmail)+1)*sizeof(TCHAR));
    crRequest.SetReasonCode((BYTE *) (LPCTSTR) m_ContactData.sReasonCode, (wcslen(m_ContactData.sReasonCode)+1)*sizeof(TCHAR));

    
    crRequest.SetExchgCertLen(m_dwExchangeCertificateLen);
    crRequest.SetSignCertLen(m_dwSignCertificateLen);

    crRequest.SetDataLen(m_dwExchangeCertificateLen+m_dwSignCertificateLen);


    // OK, allocate enough memory to read the rest fo the data
    lpszReqData = (PBYTE) LocalAlloc(GPTR, sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen+m_dwSignCertificateLen);
    if(lpszReqData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    memcpy(lpszReqData, &crRequest, sizeof(CertRevoke_Request));
    memcpy(lpszReqData+sizeof(CertRevoke_Request), m_pbExchangeCertificate, m_dwExchangeCertificateLen );
    memcpy(lpszReqData+sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen, 
           m_pbSignCertificate,
           m_dwSignCertificateLen );

    dwRetCode = Dispatch(lpszReqData, sizeof(CertRevoke_Request)+m_dwExchangeCertificateLen+m_dwSignCertificateLen);
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }

    dwRetCode = FetchResponse((BYTE *) &crResponse,
                              sizeof(CertRevoke_Response), &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLen != sizeof(CertRevoke_Response))
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    switch(crResponse.RequestHeader.GetResponseType())
    {
    case Response_Success:
        dwRetCode = ERROR_SUCCESS;
        break;

    case Response_Failure:
        dwRetCode = IDS_ERR_CHFAILURE;
        break;

    case Response_InvalidData:
        dwRetCode = IDS_ERR_CHINVALID_DATA;
        break;

    case Response_NotYetImplemented:
        dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
        break;

    case Response_ServerError:
        dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
        break;

    case Response_Invalid_Response:
    default:
        dwRetCode = IDS_ERR_CHBAD_DATA;
        break;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    // Make LS Regen Key call HERE
    dwRetCode = TLSTriggerReGenKey(m_phLSContext, TRUE, &esRPC);

    if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }

done:
    CloseCHRequest();

    DisconnectLS();

    if (lpszReqData)
    {
        LocalFree(lpszReqData);
    }

    return dwRetCode;
}

DWORD CGlobal::ProcessCHReissueCert()
{
    HKEY    hKey            = NULL;
    DWORD   dwDisposition   = 0;
    
    LPBYTE  lpszReqData      = NULL;
    LPBYTE  lpszNextCopyPos  = NULL;
    DWORD   dwLicenseServerIDLen = 0;

    CString sName   = m_ContactData.sContactLName + "~" + m_ContactData.sContactFName;
    CString sPhone  = m_ContactData.sContactPhone;
    CString sFax    = m_ContactData.sContactFax;
    CString sEmail  = m_ContactData.sContactEmail;

    DWORD dwRetCode = ERROR_SUCCESS;
    CertReissue_Request crRequest;
    CertReissue_Response    crResponse;
    DWORD  dwResponseLen;
    error_status_t      esRPC           = ERROR_SUCCESS;

    //
    // Set Language Id
    //
    crRequest.RequestHeader.SetLanguageId(GetLSLangId());

    dwRetCode = ConnectToLS();
    if(dwRetCode != ERROR_SUCCESS)
    {       
        goto done;
    }

    dwRetCode = InitCHRequest();
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Set CR Request Attributes
    //
    crRequest.SetSPK((BYTE *) m_pRegistrationID, (lstrlen(m_pRegistrationID)+1)*sizeof(TCHAR));
    crRequest.SetLName((BYTE *) (LPCTSTR) m_ContactData.sContactLName, (wcslen(m_ContactData.sContactLName)+1)*sizeof(TCHAR));
    crRequest.SetFName((BYTE *) (LPCTSTR) m_ContactData.sContactFName, (wcslen(m_ContactData.sContactFName)+1)*sizeof(TCHAR));
    crRequest.SetPhone((BYTE *) (LPCTSTR) m_ContactData.sContactPhone, (wcslen(m_ContactData.sContactPhone)+1)*sizeof(TCHAR));
    crRequest.SetFax((BYTE *) (LPCTSTR) m_ContactData.sContactFax, (wcslen(m_ContactData.sContactFax)+1)*sizeof(TCHAR));
    crRequest.SetEMail((BYTE *) (LPCTSTR) m_ContactData.sContactEmail, (wcslen(m_ContactData.sContactEmail)+1)*sizeof(TCHAR));
    crRequest.SetReasonCode((BYTE *) (LPCTSTR) m_ContactData.sReasonCode, (wcslen(m_ContactData.sReasonCode)+1)*sizeof(TCHAR));

    dwLicenseServerIDLen = sizeof(m_pLicenseServerID);
    crRequest.SetDataLen(dwLicenseServerIDLen);

    //Allocate buffer for the request
    lpszReqData = (LPBYTE) LocalAlloc( GPTR, dwLicenseServerIDLen+sizeof(crRequest) );
    if(lpszReqData == NULL)
    {
        dwRetCode = IDS_ERR_OUTOFMEM;
        goto done;
    }

    lpszNextCopyPos = lpszReqData;
    memcpy(lpszNextCopyPos, &crRequest, sizeof(crRequest));
    lpszNextCopyPos += sizeof(crRequest);

    memcpy ( lpszNextCopyPos, m_pLicenseServerID, dwLicenseServerIDLen);


    dwRetCode = Dispatch(lpszReqData, dwLicenseServerIDLen+sizeof(crRequest));
    if ( lpszReqData )
    {
        LocalFree(lpszReqData);
    }
    if (dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        goto done;
    }

    dwRetCode = FetchResponse((BYTE *) &crResponse, sizeof(CertReissue_Response), &dwResponseLen);
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    if (dwResponseLen != sizeof(CertReissue_Response))
    {
        // Didn't get the expected number of Bytes, also a problem
        dwRetCode = IDS_ERR_CHBAD_DATA;
        goto done;
    }

    switch(crResponse.RequestHeader.GetResponseType())
    {
    case Response_Success:
        dwRetCode = ERROR_SUCCESS;
        break;

    case Response_Failure:
        dwRetCode = IDS_ERR_CHFAILURE;
        break;

    case Response_InvalidData:
        dwRetCode = IDS_ERR_CHINVALID_DATA;
        break;

    case Response_NotYetImplemented:
        dwRetCode = IDS_ERR_CHNOT_IMPLEMENTED;
        break;

    case Response_ServerError:
        dwRetCode = IDS_ERR_CHSERVER_PROBLEM;
        break;

    case Response_Invalid_Response:
    default:
        dwRetCode = IDS_ERR_CHBAD_DATA;
        break;
    }

    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }


    // Make LS Regen Key call HERE
    dwRetCode = TLSTriggerReGenKey(m_phLSContext, TRUE, &esRPC);

    if(dwRetCode != RPC_S_OK || esRPC != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_RPC_FAILED;     
        goto done;
    }
    DisconnectLS();

    // Deposit the New SPK
    dwRetCode = SetLSSPK(crResponse.GetSPK());
    if (dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = DepositLSSPK();
    if(dwRetCode != ERROR_SUCCESS)
        goto done;

    // Set the new values in the Registry.
    dwRetCode = ConnectToLSRegistry();
    if(dwRetCode != ERROR_SUCCESS)
    {
        goto done;
    }

    dwRetCode = RegCreateKeyEx ( m_hLSRegKey,
                             REG_LRWIZ_PARAMS,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisposition);
    
    if(dwRetCode != ERROR_SUCCESS)
    {
        LRSetLastError(dwRetCode);
        dwRetCode = IDS_ERR_REGCREATE_FAILED;
        goto done;
    }   
/*  
    //Name  
    RegSetValueEx ( hKey, 
                    szOID_GIVEN_NAME_W,
                    0,
                    REG_SZ,
                    (CONST BYTE *)(LPCTSTR)sName,
                    sName.GetLength() * sizeof(TCHAR)
                   );   
    
    //Phone 
    RegSetValueEx ( hKey, 
                    szOID_TELEPHONE_NUMBER_W,
                    0,
                    REG_SZ,
                    (CONST BYTE *)(LPCTSTR)sPhone,
                    sPhone.GetLength() * sizeof(TCHAR)
                   );   

    //Email Address 
    RegSetValueEx ( hKey, 
                    szOID_RSA_emailAddr_W,
                    0,
                    REG_SZ,
                    (CONST BYTE *)(LPCTSTR)sEmail,
                    sEmail.GetLength() * sizeof(TCHAR)
                   );
*/
    
done:

    if(hKey)
        RegCloseKey(hKey);

    DisconnectLSRegistry();

    CloseCHRequest();

    DisconnectLS();

    return dwRetCode;
}


void CGlobal::SetCSRNumber(TCHAR * tcp)
{
    SetInRegistry(CSRNUMBER_KEY, tcp);

    lstrcpy(m_lpCSRNumber, tcp);
    return;
}

TCHAR * CGlobal::GetCSRNumber(void)
{
    return m_lpCSRNumber;
}

void CGlobal::SetWWWSite(TCHAR * tcp)
{
    lstrcpy(m_lpWWWSite, tcp);
    return;
}

TCHAR * CGlobal::GetWWWSite(void)
{
    return m_lpWWWSite;
}

void CGlobal::SetModifiedRetailSPK(CString sRetailSPK)
{
    m_sModifiedRetailsSPK = sRetailSPK;
}

void CGlobal::GetModifiedRetailSPK(CString &sRetailSPK)
{
    sRetailSPK = m_sModifiedRetailsSPK;
}

DWORD CGlobal::GetLSLangId()
{
    return m_dwLangId;
}

void  CGlobal::SetLSLangId(DWORD dwLangId)
{
    m_dwLangId = dwLangId;
}

int CALLBACK EnumFontFamExProc(
  CONST LOGFONTW *lpelfe,    // pointer to logical-font data
  CONST TEXTMETRICW *lpntme,  // pointer to physical-font data
  DWORD FontType,             // type of font
  LPARAM lParam             // application-defined data
)
{
    LOCALESIGNATURE ls;
    CHARSETINFO cs;
    BOOL rc ;
    DWORD dwLCID = LOCALE_USER_DEFAULT ;
 
    rc = GetLocaleInfo(dwLCID, LOCALE_FONTSIGNATURE, (LPWSTR)& ls, sizeof(ls) / sizeof(TCHAR));

    rc = TranslateCharsetInfo((ULONG *)lpelfe->lfCharSet, &cs, TCI_SRCCHARSET);


    if (rc != 0)
        rc = GetLastError();
 

    if (cs.fs.fsCsb[0] & ls.lsCsbSupported[0]){
        // return fontname
        _tcscpy((TCHAR *)lParam, lpelfe->lfFaceName);       
        return(0); // return 0 to finish the enumeration
    }
    return(1); // return 1 to continue
}
 

void GetDefaultFont(TCHAR *szFontName, HDC hdc)
{

//retrieve the list of installed fonts
LOGFONT lf ;

        
    //to enumerate all styles and charsets of all fonts:
    lf.lfFaceName[0] = '\0';
    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfWeight = FW_BOLD;


    EnumFontFamiliesEx(
    hdc,                   // handle to device context
    &lf,       // pointer to LOGFONT structure
    EnumFontFamExProc,  // pointer to callback function
    (LPARAM) szFontName,             // application-supplied data
    0// reserved; must be zero
    );
 

    
}

#define MARGINX     25//50      // X Margin in 100th of an inch
#define MARGINY     25//50      // Y Margin in 100th of an inch
//#define MAX_LABEL 30      // Max Number of chars in a label

#define MAX_PRINT_CHARS 32

int WordWrapAndPrint(HDC hdc, LPCTSTR lpcText, HFONT hBoldFont, long lCharHt, int iValueStartPosX, int iLineStartPosY) 
{
    TCHAR       szBuffer[1024]; 
    TCHAR       *lpTemp = NULL;
    
    if (NULL == lpcText)
    {
        return 0;
    }

    _tcscpy(szBuffer, lpcText);
    
    lpTemp = _tcstok(szBuffer,L"\r\n");

    // If no data , just go to the next line
    if(lpTemp == NULL)
        iLineStartPosY -= lCharHt;          

    while(lpTemp)
    {
        while (_tcslen(lpTemp) > MAX_PRINT_CHARS){
            SelectObject(hdc, hBoldFont);
            TextOut(hdc,iValueStartPosX,iLineStartPosY,lpTemp,MAX_PRINT_CHARS);
            iLineStartPosY -= lCharHt;  
            lpTemp += MAX_PRINT_CHARS ;         
        }

        if (_tcslen(lpTemp) > 0){
            SelectObject(hdc, hBoldFont);
            TextOut(hdc,iValueStartPosX,iLineStartPosY,lpTemp,_tcslen(lpTemp));

            iLineStartPosY -= lCharHt;  

            lpTemp = _tcstok(NULL,L"\r\n");
        }
    }
    return iLineStartPosY ;
}

UINT GetMaxLabelLength(HDC hdc, HFONT   m_hNormalFont, HINSTANCE hInstance)
{
        TCHAR   tcLabel[512] = {0};
        int     iTextExtent;
        int     iLen;
        SIZE    size;


        LoadString(hInstance, IDS_FAX, tcLabel, 512);
        iLen = _tcslen(tcLabel);
        SelectObject(hdc, m_hNormalFont);
        GetTextExtentPoint32( hdc, 
                                 tcLabel,
                                 iLen,
                                 &size );
        iTextExtent = size.cx;

        LoadString(hInstance, IDS_RETURN_FAX, tcLabel, 512);
        iLen = _tcslen(tcLabel);
        GetTextExtentPoint32( hdc, 
                                 tcLabel,
                                 iLen,
                                 &size );
        if (size.cx > iTextExtent)
            iTextExtent = size.cx;

        return(iTextExtent ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensinglink.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "licensinglink.h"

//Find the correct left starting point for text that will center it within the control
int GetCenteredLeftPoint(RECT rcControl, HWND hControl, TCHAR* tchText)
{
    SIZE URLsize;
    HDC hURLWindowDC = GetDC(hControl);
    GetTextExtentPoint32(hURLWindowDC, tchText, (wcslen(tchText) - 6), &URLsize); //Subtract the length of the tags
    return (int)(((RECTWIDTH(rcControl) - URLsize.cx) / 2) + rcControl.left);
}

void AddLicensingSiteLink(HWND hDialog)
{
    RECT rcTextCtrl;

    //Create the URL with hyperlink tags
    TCHAR tchBuffer[MAX_URL_LENGTH + 7]; //a little extra for the tags
    if (tchBuffer)
    {
        memset(tchBuffer, 0, MAX_URL_LENGTH + 7);
        wcscpy(tchBuffer, L"<a>");
        wcscat(tchBuffer, GetWWWSite());
        wcscat(tchBuffer, L"</a>");
    }

    //Get the control dimensions
    GetWindowRect(GetDlgItem(hDialog, IDC_WWWINFO) , &rcTextCtrl);
    
    //Registration info for the control
    MapWindowPoints(NULL, hDialog, (LPPOINT)&rcTextCtrl, 2);
    LinkWindow_RegisterClass();

    //Now create the window (using the same dimensions as the
    //hidden control) that will contain the link
    HWND hLW = CreateWindowEx(0,
                          TEXT("Link Window") ,
                          TEXT("") ,
                          WS_CLIPSIBLINGS | WS_TABSTOP | WS_CHILD | WS_VISIBLE,
                          GetCenteredLeftPoint(rcTextCtrl, GetDlgItem(hDialog, IDC_WWWINFO), tchBuffer),
                          rcTextCtrl.top,
                          RECTWIDTH(rcTextCtrl),
                          RECTHEIGHT(rcTextCtrl),
                          hDialog,
                          (HMENU)12,
                          NULL,
                          NULL);

    //Now write it to the link window
    SetWindowText(hLW, tchBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensetype.h ===
//Copyright (c) 2001 Microsoft Corporation
#ifndef _LICENSETYPE_H_
#define _LICENSETYPE_H_

#include "precomp.h"

enum LICENSE_PROGRAM
{
    LICENSE_PROGRAM_LICENSE_PAK,
    LICENSE_PROGRAM_OPEN_LICENSE,
    LICENSE_PROGRAM_SELECT,
    LICENSE_PROGRAM_ENTERPRISE,
    LICENSE_PROGRAM_CAMPUS,
    LICENSE_PROGRAM_SCHOOL,
    LICENSE_PROGRAM_APP_SERVICES,
    LICENSE_PROGRAM_OTHER,

    NUM_LICENSE_TYPES
};


CString              
GetProgramNameFromComboIdx(INT nItem);


LICENSE_PROGRAM                                    
GetLicenseProgramFromProgramName(CString& sProgramName);

void UpdateProgramControls(HWND hDialog, LICENSE_PROGRAM licProgram);

void AddProgramChoices(HWND hDialog, DWORD dwLicenseCombo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensecodelite.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0500
#endif
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "DigPid1.h"
#include "PidGen.h"
#include "ValidDP.h"
#include "LicenseCodeLite.h"
#include "SequenceRanges.h"

#define GROUP12TXT		_TEXT("06")
#define GROUP14TXT      _TEXT("07")
#define GROUP0TXT		_TEXT("00")


DWORD GetLCProductType(TCHAR * tcLicenceCode, TCHAR ** tcProductType, DWORD * dwGroupID)
{
	BOOL fOk = false;				// success flag
	TCHAR *pszMpc= _TEXT("12345");	// 5 numeral Microsoft Product Code
	TCHAR szPid2[32];				// Microsoft Product ID
	BYTE abPid3[DIGITALPIDMAXLEN];	// new Digital Product ID
	DWORD dwSeq = 0;				// 9 digit sequence number
	BOOL fOEM = FALSE;				// [IN] Is this an OEM Product Key, default to Retail
	BOOL fCCP = FALSE;				// [OUT] Compliance Checking Product (Is upgrade?)
	DWORD dwPge;					// PidGenError
	DWORD dwSearchLoop;
	TCHAR * tcGroupId;
	DWORD dwRetVal = ERROR_SUCCESS;

	szPid2[0] = _TEXT('\0');

		// Must set the first DWORD of abPid3 to the total length of the
		// buffer.  On return the first DWORD will be set the the length
		// actually used.

	*(LPDWORD)abPid3 = sizeof(abPid3);

		// Both Unicode and ANSI versions of PIDGenSimp are supported
#ifdef UNICODE
		// return value is a PidGenError (see PidGen.h)
	dwPge = PIDGenStatic(
			tcLicenceCode,	// [IN] 25-character Secure CD-Key (gets U-Cased)
			pszMpc,			// [IN] 5-character Microsoft Product Code
			L"",			// [IN] Stock Keeping Unit (formatted like 123-12345)
			NULL,			// [IN] 4-character OEM ID or NULL
			NULL,			// [IN] pointer to optional public key or NULL
			0,				// [IN] byte length of optional public key
			0,				// [IN] key pair index optional public key
			fOEM,			// [IN] is this an OEM install?

			szPid2,			// [OUT] PID 2.0, pass in ptr to 24 character array
			abPid3,			// [IN/OUT] pointer to binary PID3 buffer.
			&dwSeq,			// [OUT] optional ptr to sequence number (can be NULL)
			NULL);			// [OUT] ptr to Compliance Checking flag or NULL
#else
		// return value is a PidGenError (see PidGen.h)
	dwPge = PIDGenStatic(
			tcLicenceCode,	// [IN] 25-character Secure CD-Key (gets U-Cased)
			pszMpc,			// [IN] 5-character Microsoft Product Code
			"",				// [IN] Stock Keeping Unit (formatted like 123-12345)
			NULL,			// [IN] 4-character OEM ID or NULL
			fOEM,			// [IN] is this an OEM install?

			szPid2,			// [OUT] PID 2.0, pass in ptr to 24 character array
			abPid3,			// [IN/OUT] pointer to binary PID3 buffer.
			&dwSeq,			// [OUT] optional ptr to sequence number (can be NULL)
			NULL);			// [OUT] ptr to Compliance Checking flag or NULL
#endif

	if (pgeSuccess != dwPge)
	{
		dwRetVal = INVALID_PRODUCT_KEY;
		goto done;
	}

	//Using the PID2 object generated by PIDGen determine the GroupID
	//The ValidDP12.lib provides the PIDGen interface and is configured for only Group 12 and 0.
	tcGroupId = szPid2+18;

	if (!_tcsncmp( tcGroupId, GROUP12TXT, 2 ))
	{
		*dwGroupID = 12;
	} 
	else if (!_tcsncmp( tcGroupId, GROUP0TXT, 2 ))
	{
		*dwGroupID = 0;
	}
    else if(!_tcsncmp( tcGroupId, GROUP14TXT, 2 ))
    {
        *dwGroupID = 14;
    }
	else
	{
		*dwGroupID = -1;
		dwRetVal = INVALID_GROUP_ID;
		goto done;
	}


	//Check if the sequence number falls into one of the predefined product type ranges.
	for (dwSearchLoop = 0; dwSearchLoop < RANGE_SIZE; dwSearchLoop++)
	{
		if (g_ProductTypeRanges[dwSearchLoop].dwRangeStart <= dwSeq &&
			g_ProductTypeRanges[dwSearchLoop].dwRangeEnd >= dwSeq)
		{
			*tcProductType = g_ProductTypeRanges[dwSearchLoop].szProductType;
			fOk = true;	
			break;
		}
	}
	if (!fOk)
		dwRetVal = INVALID_SERIAL_NUMBER;

done:

	return dwRetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\global.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _GLOBAL_H_
#define	_GLOBAL_H_

#include "precomp.h"
#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
#include <wininet.h>
#include "wincrypt.h"
#include "license.h"
#include "tlsapip.h"
#include "lrwizapi.h"
#include "chstruct.h"

#define szOID_GIVEN_NAME_W					L"2.5.4.42"
#define szOID_COMMON_NAME_W					L"2.5.4.3"
#define szOID_COUNTRY_NAME_W				L"2.5.4.6"
#define szOID_LOCALITY_NAME_W				L"2.5.4.7"
#define szOID_STATE_OR_PROVINCE_NAME_W		L"2.5.4.8"
#define szOID_STREET_ADDRESS_W				L"2.5.4.9"
#define szOID_POSTAL_CODE_W					L"2.5.4.17"
#define szOID_TELEPHONE_NUMBER_W			L"2.5.4.20"
#define szOID_FACSIMILE_TELEPHONE_NUMBER_W  L"2.5.4.23"
#define szOID_RSA_emailAddr_W				L"1.2.840.113549.1.9.1"


#define szCertEXTENSION_OID				"1.3.6.1.4.1.311.18"
#define szCertEXTENSION_VALUE_FMT		_TEXT("TLS~%s")


#define CH_ERROR_SUCCESS		ERROR_SUCCESS
#define	CH_ERROR_BASE			0x3000
#define	CH_ERROR_BAD_DATA		(CH_ERROR_BASE + 1)
#define	CH_ERROR_BAD_PARAM		(CH_ERROR_BASE + 2)
#define	CH_ERROR_BAD_REQUEST	(CH_ERROR_BASE + 3)
#define	CH_ERROR_NO_DATA		(CH_ERROR_BASE + 4)
#define	CH_ERROR_OUT_OF_MEMORY	(CH_ERROR_BASE + 5)
#define	CH_ERROR_EXCEPTION		(CH_ERROR_BASE + 6)
#define	CH_ERROR_HTTPQRY_FAILED (CH_ERROR_BASE + 7)
#define	CH_ERROR_SERVER_ERROR	(CH_ERROR_BASE + 8)
#define	CH_ERROR_SEND_FAILED	(CH_ERROR_BASE + 9)
#define	CH_ERROR_BAD_MFBLOB		(CH_ERROR_BASE + 10)


#define NUMBER_OF_BATCHES			7
#define CHARS_IN_BATCH				5

#define REG_ICW_STATUS_PATH     L"Software\\Microsoft\\Internet Connection Wizard"
#define REG_ICW_COMPLETED       L"Completed"

#define RNC_NETWORKS            0x00000001

#define MAX_URL_LENGTH          255

#define RECTWIDTH( rc )  ((rc).right - (rc).left)
#define RECTHEIGHT( rc ) ((rc).bottom - (rc).top)
#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#define PRODUCT_WINDOW_STRING_LENGTH 50
#define PRODUCT_WINDOW_NUM_OFFSET_SPACES 5

enum ProductType
{
    UNKNOWN_PRODUCT_TYPE = 0,
    WIN2K_PERSEAT = 1,
    WIN2K_INTERNET = 2,
    WHISTLER_PERUSER = 3,
    WHISTLER_PERSEAT = 4,
    NUM_PRODUCT_TYPES = 5
};

enum ProductVersionType
{
    PRODUCT_VERSION_UNDEFINED = 0,
    PRODUCT_VERSION_W2K = 1,
    PRODUCT_VERSION_WHISTLER = 2
};


typedef struct
{
	TCHAR lpszSPK[ LR_RETAILSPK_LEN+1];
	TCHAR	tcStatus;
} RETAILSPK, *PRETAILSPK;


typedef struct
{
	LPWSTR	lpszAttribute;
	LPWSTR	lpszValue;
	DWORD	dwValueLen;
}REG_ATTR, * PREG_ATTR;

typedef struct 
{
	LPCSTR lpszOID;
	LPSTR lpszValue;
} REQ_ATTR, * PREQ_ATTR;

typedef struct _Enveloped_Data
{
    DWORD   cbEncryptedKey;
    PBYTE   pbEncryptedKey;
    DWORD   cbEncryptedData;
    PBYTE   pbEncryptedData;

} EnvData, * PEnvData;


typedef	struct _CONTACT_INFO_TAG
{
	//program related information
	CString sProgramName;			//Can be Select, MOLP, Retail ...

	CString sCertType;

	//Contact information
	CString sCompanyName;
	CString sOrgUnit;
	CString sContactLName;
	CString sContactFName;
	CString sContactAddress;	
	CString sContactPhone;
	CString sContactFax;
	CString sContactEmail;
	CString sEmailAddressConf;
	CString sCity;
	CString sCountryCode;
	CString sCountryDesc;
	CString sState;
	CString sZip;
	CString sReasonCode;
	CString sCSRFaxRegion;
	CString sCSRPhoneRegion;

	void Initialize()
	{
		sProgramName = sContactLName = sContactFName = sContactAddress = 
		sContactPhone = sCity = sCountryCode = sCountryDesc = sState = sZip = 
		sContactEmail = sCompanyName = sOrgUnit = sReasonCode = sContactFax = 
		sEmailAddressConf = sCertType = sCSRFaxRegion = sCSRPhoneRegion = 
        sCountryCode = sCountryDesc = "";
	};
} CONTACTINFO, *PCONTACTINFO;


// Formerly named "LICINFO", but that conflicts with ocidl.h

typedef	struct _LIC_INFO_TAG
{
	//Select Information
	CString sSelMastAgrNumber;
	CString sSelEnrollmentNumber;
	CString sSelProductType;
	CString sSelProductDesc;
	CString sSelQty;

	//MOLP information	
	CString sMOLPAuthNumber;		//authorization number
	CString sMOLPAgreementNumber;	//agreement number
	CString sMOLPProductType;		//product type
	CString sMOLPProductDesc;
	CString sMOLPQty;				//quantity 

	void Initialize()
	{
		sSelMastAgrNumber = sSelEnrollmentNumber = sSelProductType = sSelProductDesc = 
		sSelQty = sMOLPAuthNumber = sMOLPAgreementNumber  = sMOLPProductType = sMOLPProductDesc = 
		sMOLPQty = "";
	};
} TSLICINFO, *PTSLICINFO;




typedef struct FAX_DATA_TAG
{
	CString sRequestType;
	CString sAgreementType;
	CString sProductId;
	CString sLSId;
	CString sFName;
	CString sLName;	
	CString sCompanyName;
	CString sOrgUnit;
	CString sAddress;
	CString sCity;
	CString sState;
	CString sZip;
	CString sCountryCode;
	CString	sCountryDesc;	
	CString sPhoneNumber;
	CString sFaxNumber;
	CString sEmailAddress;
	CString sLicenseType;
	CString	sQuantity;
	CString	sSelEnrollNumber;
	CString sMolpAuthNumber;
	CString sMolpLicNumber;
	
	void Initialize() 
	{
		sRequestType	= "";
		sAgreementType	= "";
		sProductId		= "";
		sLSId			= "";
		sCompanyName	= "";		
		sOrgUnit		= "";
		sAddress		= "";
		sCity			= "";
		sState			= "";
		sCountryCode	= "";
		sCountryDesc	= "";
		sZip			= "";
		sLName			= "";
		sFName			= "";
		sPhoneNumber	= "";
		sFaxNumber		= "";
		sEmailAddress	= "";
		sLicenseType	= "";
		sQuantity		= "";
		sSelEnrollNumber= "";
		sMolpAuthNumber = "";
		sMolpLicNumber	= "";

	};
	
}FAX_DATA, * PFAX_DATA;

class CGlobal
{
public:

	CGlobal();
	~CGlobal();

	void FreeGlobal(void);

//Public Data Members
public:

//Public Member Functions
public:

	DWORD PingCH(void);

	void		SetInstanceHandle(HINSTANCE hInst);
	HINSTANCE	GetInstanceHandle();
	void		SetLSName(LPCTSTR lpwszLSName);
	DWORD		InitGlobal(); 
	DWORD		CheckRequieredFields();
	DWORD		LRGetLastError();
	int			LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwCaptionID = 0, DWORD dwErrorCode = 0);
	DWORD		AuthenticateLS();

	DWORD		SetCHCert(LPTSTR lpstrRegKey, PBYTE pCert, DWORD dwLen);
	DWORD		GetCHCert(LPTSTR lpstrRegKey, PBYTE * ppCert, DWORD * pdwLen );
	BOOL		IsLSRunning();	
	
	DWORD		GetLSCertificates(PDWORD pdwLSStatus);
	DWORD		IsLicenseServerRegistered(PDWORD pdwServerStatus);

	PCONTACTINFO	GetContactDataObject();
	PTSLICINFO	GetLicDataObject();

	DWORD		GetRequestType();
	void		SetRequestType(DWORD dwMode);

	DWORD		ResetLSSPK(BOOL bGenKey = TRUE);
	TCHAR *		GetRegistrationID(void);
	TCHAR *		GetLicenseServerID(void);

	BOOL		IsOnlineCertRequestCreated();

	DWORD		SetLRState(DWORD dwState);

	DWORD		ProcessRequest();

	DWORD		SetCertificatePIN(LPTSTR lpszPIN);
	
	DWORD		PopulateCountryComboBox(HWND hWndCmb);
	DWORD		GetCountryCode(CString sDesc,LPTSTR szCode);
	DWORD		GetCountryDesc(CString sCode,LPTSTR szDesc);

	DWORD		PopulateProductComboBox(HWND hWndCmb, ProductVersionType VerType);
	DWORD		GetProductCode(CString sDesc,LPTSTR szCode);
	
	DWORD		PopulateReasonComboBox(HWND hWndCmb, DWORD dwType);
	DWORD		GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType);
	DWORD		GetReasonDesc(CString sCode,LPTSTR szDesc, DWORD dwType);

    DWORD       PopulateCountryRegionComboBox(HWND hWndCmb);
    DWORD		PopulateCountryRegionListBox(HWND hWndCmb);
    void        ReadPhoneNumberFromRegistry(LPCTSTR lpCountry, LPTSTR lpPhoneNumber, DWORD nBufferSize);

    DWORD		CheckRegistryForPhoneNumbers();
	
	void		LRSetLastRetCode(DWORD dwCode);
	DWORD		LRGetLastRetCode();

	void		SetCSRNumber(TCHAR *);
	TCHAR *		GetCSRNumber(void);

	void		SetWWWSite(TCHAR *);
	TCHAR *		GetWWWSite(void);

	void		LRPush(DWORD dwPageId);
	DWORD		LRPop();
	void		ClearWizStack();

	DWORD		DepositLSSPK();
	DWORD		SetLSLKP(TCHAR * tcLKP);
	DWORD		SetLSSPK(TCHAR * tcLKP);


	BOOL		ValidateEmailId(CString sEmailId);
	BOOL		CheckProgramValidity(CString sProgramName);
	BOOL		ValidateLRString(CString sStr);

	LPSTR		UnicodeToAnsi( LPWSTR lpwszBuf);
	LPSTR		UnicodeToAnsi( LPWSTR lpwszBuf, DWORD dwLength );
	LPWSTR		AnsiToUnicode ( LPSTR lpszBuf );

	void	SetReFresh(DWORD dw) { m_dwRefresh = dw; }
	DWORD	GetReFresh(void)
	{
		return m_dwRefresh;
	}

	void  DeleteRetailSPKFromList(TCHAR * lpszRetailSPK);
	DWORD AddRetailSPKToList(HWND hListView, TCHAR * lpszRetailSPK);
    void  LoadUnfinishedFromList(HWND hListView);
    void  LoadFinishedFromList(HWND hListView);
    void  LoadFromList(HWND hListView);
	void  UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus);
	
	DWORD SetConfirmationNumber(TCHAR * tcConf);

	void SetModifiedRetailSPK(CString sRetailSPK);
	void GetModifiedRetailSPK(CString &sRetailSPK);

	void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK);
	DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK);

	DWORD GetLSLangId();
	void  SetLSLangId(DWORD dwLangId);	


	void SetLSStatus(DWORD dwStatus);
	DWORD GetLSStatus(void);

	DWORD GetEntryPoint(void);

	WIZCONNECTION	GetActivationMethod(void);
	void SetActivationMethod(WIZCONNECTION conn);

	WIZCONNECTION GetLSProp_ActivationMethod(void);
	void SetLSProp_ActivationMethod(WIZCONNECTION conn);

	WIZACTION	GetWizAction(void);
	void		SetWizAction(WIZACTION act);

    WIZTYPE     GetWizType()    {return m_WizType;}
    void        SetWizType(WIZTYPE t)   {m_WizType = t;}
	DWORD	SetInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue);
	DWORD GetFromRegistry(LPCSTR lpszOID, LPTSTR lpszBuffer, BOOL bConnect = TRUE);

	DWORD	SetEncodedInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue);
    DWORD   TransmitLKPData(NewLKP_Request &lkpRequest, NewLKP_Response* lkpResponse);

//Private Member functions
protected:
	void	LRSetLastError(DWORD dwErrorCode);

	DWORD	GetTempCryptContext(HCRYPTPROV * phCryptProv);
	void	DoneWithTempCryptContext(HCRYPTPROV hCryptProv);	

	DWORD	GetCryptContextWithLSKeys(HCRYPTPROV * lphCryptProv ); 
	void	DoneWithCryptContextWithLSKeys(HCRYPTPROV hProv);

	DWORD	LoadCountries();
	DWORD	LoadReasons();
	DWORD	LoadProducts();

	DWORD	ConnectToLSRegistry();
	void	DisconnectLSRegistry();
	DWORD	ConnectToLS();
	void	DisconnectLS();

	DWORD	ProcessDownloadLKP();
	DWORD	ProcessIRegRequest();
	DWORD	ProcessCertDownload();
	DWORD	ProcessCASignOnlyRequest();
	DWORD	ProcessCHReissueLKPRequest();
	DWORD	DepositLSLKP(void);
	DWORD	ProcessCHRevokeCert(void);
	DWORD	ProcessCHReissueCert(void);


	DWORD	CreateLKPRequest(PBYTE * ppbLKPRequest, NewLKP_Request * newlkpp, DWORD &dwBufLen, ProductType productTypeFilter);
	DWORD	DepositLKPResponse(PBYTE pbResponseData, DWORD dwResponseLen);

	DWORD	CreateLSPKCS10(HCRYPTPROV hCryptProv,int nType, CHAR **lppszPKCS10);

	DWORD	AskLSToCreatePKCS10(int nType, CHAR **lppszPKCS10);

	DWORD	DepositLSCertificates(PBYTE pbExchangePKCS7, 
								 DWORD dwExchangePKCS7Len,
								 PBYTE pbSignaturePKCS7,
								 DWORD dwSignaturePKCS7Len,
								 PBYTE pbRootCert,
								 DWORD dwRootCertLen);

	DWORD	SetCARequestAttributes();
	DWORD	SetCHRequestAttributes();
	
	void	ClearCHRequestAttributes();
	void	ClearCARequestAttributes();

	DWORD	SetRegistrationAttribute ( LPWSTR lpszAttribute, LPCWSTR lpszValue, DWORD dwLen );
	DWORD	SetDNAttribute(LPCSTR lpszOID, LPSTR lpszValue);

	
	void	PrepareLRString(CString &sStr);

	CERT_RDN_ATTR * CreateRDNAttr();

	//Crypto Related functions

	DWORD	EnvelopeData(
							PCCERT_CONTEXT		pCertContext,
							DWORD               cbMessage,
							PBYTE               pbMessage,
							PEnvData			pEnvelopedData,
							HCRYPTPROV			hCryptProv,
							HCERTSTORE			hCertStore
  		  				);

	DWORD	PackEnvData( 
							PEnvData     pEnvelopedData, 
							PDWORD       pcbPacked, 
							PBYTE        *ppbPacked 
						);
	DWORD GetCertforExtension (	HCRYPTPROV hCryptProv, 
								HCERTSTORE hCertStore, 
								LPSTR szOID_EXT, 
								PCCERT_CONTEXT * ppCertContext);


	DWORD VerifyCertChain (	HCRYPTPROV	hCryptProvider,			//handle to crypt prov
							HCERTSTORE	hCertStore,				//HAndle to store for verification
							PBYTE	pbRootCert,			//Root cert
							DWORD	dwcbRootCert
							);

	DWORD InitCHRequest(void);
	DWORD CloseCHRequest(void);
	DWORD Dispatch(BYTE * bpData, DWORD dwLen);

	DWORD FetchResponse(BYTE * bpResponse,
				  		DWORD dwMaxLength,
						PDWORD dwpDataLength);

	DWORD InitSPKList(void);
	DWORD InsertIntoSPKDisplayList(HWND hListView,
								  TCHAR * lpszRetailSPK,
								  TCHAR tcStatus);	

    BOOL CheckIfICWCompleted();

    ProductType GetProductCodeFromKey(LPCTSTR lpLicenseKey);

    DWORD FilteredRetailSPKEntered(ProductType productTypeFilter);
    DWORD DownloadLKPBatch(ProductType productTypeFilter);

    int FindStringTruncationPoint(TCHAR* sOriginal, unsigned int nTruncationLength);
    void AddStringToProductWindow(HWND hListView, TCHAR* sProductInfo, int nCurrentPoint, int nTruncationPoint);
    int GetProductWindowMaxStringLength(HWND hListView);


//Private Data members
private:	
	DWORD		m_dwLSStatus;
	HWND		m_hWndParent;
	HINSTANCE	m_hInstance;
	LPTSTR		m_lpstrLSName;
	LPWSTR		m_lpwstrLSName;
	LPTSTR		m_lpstrCHServer;
	LPTSTR		m_lpstrCHExtension;
	DWORD		m_dwErrorCode;
	HKEY		m_hLSRegKey;

	DWORD		m_dwExchangeCertificateLen;
	PBYTE		m_pbExchangeCertificate;

	DWORD		m_dwSignCertificateLen;
	PBYTE		m_pbSignCertificate;

	DWORD		m_dwExtenstionValueLen;
	PBYTE		m_pbExtensionValue;
	
	PREQ_ATTR	m_pReqAttr;					//For the Cert Request
	DWORD		m_dwReqAttrCount;

	PREG_ATTR   m_pRegAttr;					//For the LKP Request
	DWORD		m_dwRegAttrCount;

	PCONTEXT_HANDLE m_phLSContext;

    BOOL        m_fSupportConcurrent;

    BOOL        m_fSupportWhistlerCAL;

	CONTACTINFO	m_ContactData;
	TSLICINFO	m_LicData;

	DWORD       m_dwRequestType;
	DWORD		m_dwLRState;
	DWORD		m_dwLRCount;				//LKP Request Count

	LPTSTR		m_lpstrPIN;

	TCHAR		m_lpCSRNumber[MAX_COUNTRY_NUMBER_LENGTH + 1];
	TCHAR		m_lpWWWSite[MAX_URL_LENGTH];

	CStringArray	m_csaCountryCode;
	CStringArray	m_csaCountryDesc;

	CStringArray	m_csaProductCode;
	CStringArray	m_csaProductDesc;

	CStringArray	m_csaDeactReasonCode;
	CStringArray	m_csaDeactReasonDesc;

	CStringArray	m_csaReactReasonCode;
	CStringArray	m_csaReactReasonDesc;

	DWORD			m_dwLastRetCode;

	DWORD			m_dwRefresh;

	HINTERNET m_hOpenDirect;
	HINTERNET m_hConnect;
	HINTERNET m_hRequest;

	TCHAR m_pRegistrationID[ LR_REGISTRATIONID_LEN+1];
	TCHAR m_pLicenseServerID[ LR_LICENSESERVERID_LEN+1];
	TCHAR m_pLSLKP[ LR_REGISTRATIONID_LEN+1];
	TCHAR m_pLSSPK[ LR_REGISTRATIONID_LEN+1];


	//Stores page traversal order. Implemented as a stack
	DWORD		m_dwWizStack[NO_OF_PAGES];
	DWORD		m_dwTop;

	DWORD		m_dwRetailSPKEntered;
	RETAILSPK	m_listRetailSPK[ MAX_RETAILSPKS_IN_BATCH];
    DWORD       m_ProductQuantity[NUM_PRODUCT_TYPES];

	CString		m_sModifiedRetailsSPK;

	DWORD		m_dwLangId;

	WIZCONNECTION	m_ActivationMethod;
	WIZCONNECTION	m_LSProp_ActivationMethod;
	WIZACTION		m_WizAction;

    WIZTYPE         m_WizType;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensetype.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "licensetype.h"

//Write the sample text into the boxes (not all will be visible)
void SetSampleBoxText(HWND hDialog)
{
    TCHAR lpBuffer[16];

    //Sample boxes for retail
    memset(lpBuffer,0,sizeof(lpBuffer));
    LoadString(GetInstanceHandle(), IDS_PROGRAM_STATUS_BOX_SMALL, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
    if (lpBuffer)
    {
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SMALL_1, lpBuffer);
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SMALL_2, lpBuffer);
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SMALL_3, lpBuffer);
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SMALL_4, lpBuffer);
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SMALL_5, lpBuffer);
    }

    //Sample boxes for open license
    memset(lpBuffer,0,sizeof(lpBuffer));
    LoadString(GetInstanceHandle(), IDS_PROGRAM_STATUS_BOX_BIG_1, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
    if (lpBuffer)
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_BIG_1, lpBuffer);

    memset(lpBuffer,0,sizeof(lpBuffer));
    LoadString(GetInstanceHandle(), IDS_PROGRAM_STATUS_BOX_BIG_2, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
    if (lpBuffer)
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_BIG_2, lpBuffer);

    //Sample boxes for select
    memset(lpBuffer,0,sizeof(lpBuffer));
    LoadString(GetInstanceHandle(), IDS_PROGRAM_STATUS_BOX_SINGLE, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
    if (lpBuffer)
        SetDlgItemText(hDialog, IDC_PROGRAM_SAMPLE_SINGLE, lpBuffer);

}

//Figure out which sample boxes to show
void DetermineSampleBoxAvailabilities(HWND hDialog, LICENSE_PROGRAM licProgram)
{
    //Retail
    BOOL bDisplaySmallStatusBoxes = (licProgram == LICENSE_PROGRAM_LICENSE_PAK);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SMALL_1), bDisplaySmallStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SMALL_2), bDisplaySmallStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SMALL_3), bDisplaySmallStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SMALL_4), bDisplaySmallStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SMALL_5), bDisplaySmallStatusBoxes ? SW_SHOW : SW_HIDE);

    //Open License
    BOOL bDisplayBigStatusBoxes = (licProgram == LICENSE_PROGRAM_OPEN_LICENSE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_BIG_1), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_BIG_2), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_AUTHORIZATION_NUMBER), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_LICENSE_NUMBER), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_CH_MOLP_AGREEMENT_NUMBER_EXP), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_CH_MOLP_AGREEMENT_NUMBER_EXP2), bDisplayBigStatusBoxes ? SW_SHOW : SW_HIDE);
    

    //Select
    BOOL bDisplaySingleStatusBox = ((licProgram == LICENSE_PROGRAM_SELECT) ||
                                    (licProgram == LICENSE_PROGRAM_ENTERPRISE) ||
                                    (licProgram == LICENSE_PROGRAM_CAMPUS) ||
                                    (licProgram == LICENSE_PROGRAM_SCHOOL) ||
                                    (licProgram == LICENSE_PROGRAM_APP_SERVICES) ||
                                    (licProgram == LICENSE_PROGRAM_OTHER));
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SAMPLE_SINGLE), bDisplaySingleStatusBox ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_PROGRAM_SINGLE_LICNUMBER), bDisplaySingleStatusBox ? SW_SHOW : SW_HIDE);
}

//Display the appropriate text
void DisplayDynamicText(HWND hDialog, LICENSE_PROGRAM licProgram)
{
    TCHAR lpDescription[512];
    TCHAR lpRequiredDataFormat[512];
    TCHAR lpRequiredData[512];

    memset(lpDescription,0,sizeof(lpDescription));
    memset(lpRequiredData,0,sizeof(lpRequiredData));

    switch (licProgram)
    {
        case LICENSE_PROGRAM_LICENSE_PAK:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_LICENSE_PAK_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_LICENSE_PAK_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_OPEN_LICENSE:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_OPEN_LICENSE_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_OPEN_LICENSE_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_SELECT:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_SELECT_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_SELECT_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_ENTERPRISE:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_ENTERPRISE_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_ENTERPRISE_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_CAMPUS:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_CAMPUS_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_CAMPUS_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_SCHOOL:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_SCHOOL_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_SCHOOL_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_APP_SERVICES:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_APP_SERVICES_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_APP_SERVICES_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }

        case LICENSE_PROGRAM_OTHER:
        {
            LoadString(GetInstanceHandle(), IDS_PROGRAM_OTHER_DESC, lpDescription, sizeof(lpDescription)/sizeof(TCHAR));
            LoadString(GetInstanceHandle(), IDS_PROGRAM_OTHER_REQ, lpRequiredData, sizeof(lpRequiredData)/sizeof(TCHAR));
            break;
        }
    }

    if (lpDescription)
        SetDlgItemText(hDialog, IDC_PROGRAM_DESC, lpDescription);

    if (lpRequiredData)
        SetDlgItemText(hDialog, IDC_PROGRAM_REQ, lpRequiredData);
}

//Add the program types to the combo box
void AddProgramChoices(HWND hDialog, DWORD dwLicenseCombo)
{
    ComboBox_ResetContent(GetDlgItem(hDialog, dwLicenseCombo));
    TCHAR lpBuffer[CH_LICENSE_TYPE_LENGTH];
    for (int nIndex = 0; nIndex < NUM_LICENSE_TYPES; nIndex++)
    {
        memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(), IDS_PROGRAM_LICENSE_PAK + nIndex, lpBuffer, CH_LICENSE_TYPE_LENGTH);
        if (lpBuffer)
            ComboBox_InsertString(GetDlgItem(hDialog, dwLicenseCombo), LICENSE_PROGRAM_LICENSE_PAK + nIndex, lpBuffer);
    }
}

LICENSE_PROGRAM                                    
GetLicenseProgramFromProgramName(CString& sProgramName)
{
    LICENSE_PROGRAM licProgram = LICENSE_PROGRAM_LICENSE_PAK;

    if (sProgramName == PROGRAM_LICENSE_PAK)
    {
        licProgram = LICENSE_PROGRAM_LICENSE_PAK;
    }
    else if (sProgramName == PROGRAM_MOLP)
    {
        licProgram = LICENSE_PROGRAM_OPEN_LICENSE;
    }
    else if (sProgramName == PROGRAM_SELECT)
    {
        licProgram = LICENSE_PROGRAM_SELECT;
    }
    else if (sProgramName == PROGRAM_ENTERPRISE)
    {
        licProgram = LICENSE_PROGRAM_ENTERPRISE;
    }
    else if (sProgramName == PROGRAM_CAMPUS_AGREEMENT)
    {
        licProgram = LICENSE_PROGRAM_CAMPUS;
    }
    else if (sProgramName == PROGRAM_SCHOOL_AGREEMENT)
    {
        licProgram = LICENSE_PROGRAM_SCHOOL;
    }
    else if (sProgramName == PROGRAM_APP_SERVICES)
    {
        licProgram = LICENSE_PROGRAM_APP_SERVICES;
    }
    else if (sProgramName == PROGRAM_OTHER)
    {
        licProgram = LICENSE_PROGRAM_OTHER;
    }
    else
    {
        licProgram = LICENSE_PROGRAM_OTHER;
    }

    return licProgram;
}

CString              
GetProgramNameFromComboIdx(INT nItem)
{
    CString sProgramName;
    switch (nItem) {
    case LICENSE_PROGRAM_LICENSE_PAK:
        sProgramName = PROGRAM_LICENSE_PAK;
        break;
    case LICENSE_PROGRAM_OPEN_LICENSE:
        sProgramName = PROGRAM_MOLP;                   
        break;
    case LICENSE_PROGRAM_SELECT:
        sProgramName = PROGRAM_SELECT;                   
        break;
    case LICENSE_PROGRAM_ENTERPRISE:
        sProgramName = PROGRAM_ENTERPRISE;                   
        break;
    case LICENSE_PROGRAM_CAMPUS:
        sProgramName = PROGRAM_CAMPUS_AGREEMENT;
        break;
    case LICENSE_PROGRAM_SCHOOL:
        sProgramName = PROGRAM_SCHOOL_AGREEMENT;                   
        break;
    case LICENSE_PROGRAM_APP_SERVICES:
        sProgramName = PROGRAM_APP_SERVICES;                   
        break;
    case LICENSE_PROGRAM_OTHER:
        sProgramName = PROGRAM_OTHER;    
        break;
    default:
        sProgramName = PROGRAM_LICENSE_PAK;    
        break;
    }
    return sProgramName;
}

//This modifies the dynamic controls of the dialog box
void UpdateProgramControls(HWND hDialog, LICENSE_PROGRAM licProgram)
{
    //Write the sample text into the boxes (not all will be visible)
    SetSampleBoxText(hDialog);

    //Figure out which sample boxes to show
    DetermineSampleBoxAvailabilities(hDialog, licProgram);

    //Display the appropriate text
    DisplayDynamicText(hDialog, licProgram);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\lrwizapi.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "lrwizapi.h"
#include "lrwizdll.h"

DWORD LSRegister(HWND hWndParent,LPTSTR szLSName)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	BOOL bRefresh;

	dwRetCode = StartWizard(hWndParent, WIZACTION_REGISTERLS, (LPCTSTR) szLSName, &bRefresh);

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\licensinglink.h ===
//Copyright (c) 2001 Microsoft Corporation
#ifndef _LICENSINGLINK_H_
#define _LICENSINGLINK_H_

#include "precomp.h"
#include <afxwin.h>
#include <shellapi.h>

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

void AddLicensingSiteLink(HWND hDialog);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\lrwizdll.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif

#include "wincrypt.h"
#include "tlsapip.h"
#include "lrwizapi.h"
#include "wincrypt.h"
#include "dlgproc.h"
#include "propdlgs.h"

#include "global.h"
#include "utils.h"
#include "fonts.h"

#define  ACTIVATIONMETHOD_KEY			"ACTIVATIONMETHOD"

CGlobal		*g_CGlobal = NULL;


BOOL   WINAPI   DllMain (HANDLE hInst,ULONG ul_reason_for_call,LPVOID lpReserved)
{ 
	switch(ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		if (g_CGlobal == NULL)
		{
			g_CGlobal = new CGlobal;
			if (g_CGlobal == NULL)
			{
				return FALSE;
			}

			SetInstanceHandle((HINSTANCE)hInst);
		}
		break;

	case DLL_PROCESS_DETACH:
		if (g_CGlobal != NULL)
		{
			delete g_CGlobal;
			g_CGlobal = NULL;
		}
		break;

	default:
		break;
	}
	
	return TRUE;
}




DWORD 
IsLicenseServerRegistered(HWND hWndParent, 
						  LPCTSTR pszLSName,
						  PDWORD pdwServerStatus)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	
	GetGlobalContext()->SetLSName(pszLSName);

	if (!GetGlobalContext()->IsLSRunning())
	{		
		dwRetCode = LRWIZ_ERROR_LS_NOT_RUNNING;
		goto done;
	}	

	dwRetCode = GetGlobalContext()->IsLicenseServerRegistered(pdwServerStatus);

	if (dwRetCode == ERROR_SUCCESS && *pdwServerStatus == LSERVERSTATUS_UNREGISTER &&
		GetGlobalContext()->IsOnlineCertRequestCreated())
	{
		*pdwServerStatus = LSERVERSTATUS_WAITFORPIN;
	}

	GetGlobalContext()->FreeGlobal();

done:
	return dwRetCode;
}





DWORD
GetConnectionType(HWND hWndParent,
                    LPCTSTR pszLSName,
                    WIZCONNECTION* pConnectionType)
{
    DWORD dwRetCode = ERROR_SUCCESS;
    TCHAR lpBuffer[64];

    *pConnectionType = CONNECTION_DEFAULT;

    // Connect to the given LS Registry & read the current ConnectionType.
    GetGlobalContext()->SetLSName(pszLSName);
	
    dwRetCode = GetGlobalContext()->GetFromRegistry(ACTIVATIONMETHOD_KEY, lpBuffer, TRUE);
    
    if (dwRetCode == ERROR_SUCCESS)
    {
        if (_tcslen(lpBuffer) != 0)
        {
            *pConnectionType = (WIZCONNECTION) _ttoi(lpBuffer);

            if (*pConnectionType == CONNECTION_FAX)
                *pConnectionType = CONNECTION_DEFAULT;
        }
        else
            dwRetCode = ERROR_FILE_NOT_FOUND;
    }

	GetGlobalContext()->FreeGlobal();

    return dwRetCode;
}




DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPCTSTR pszLSName, 
    PBOOL pbRefresh
)
{
	DWORD			dwRetCode			= LRWIZ_SUCCESS;
    BOOL            bStatus             = TRUE;
    PageInfo        PageInfo            = {0};
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  ahpsp[NO_OF_PAGES]  = {0};
    PROPSHEETHEADER psh                 = {0};
	UINT			i = 0;
	DWORD			dwLSStatus = 0;
	
	GetGlobalContext()->SetWizAction(WizAction);

	GetGlobalContext()->SetLSName(pszLSName);

	if(!GetGlobalContext()->IsLSRunning())
	{
		LRMessageBox(hWndParent,IDS_ERR_LSCONNECT_FAILED,IDS_WIZARD_MESSAGE_TITLE);
		dwRetCode = LRWIZ_ERROR_LS_NOT_RUNNING;
		goto done;
	}

	dwRetCode = GetGlobalContext()->InitGlobal();
	if (dwRetCode != ERROR_SUCCESS)
	{
		LRMessageBox(hWndParent,dwRetCode,NULL,LRGetLastError());
		goto done;
	}

	dwRetCode = GetGlobalContext()->GetLSCertificates(&dwLSStatus);
	if (dwRetCode != ERROR_SUCCESS)
	{	
		LRMessageBox(hWndParent,dwRetCode,NULL,LRGetLastError());
		goto done;
	}	

	if (dwLSStatus == LSERVERSTATUS_UNREGISTER && GetGlobalContext()->IsOnlineCertRequestCreated())
	{
		dwLSStatus = LSERVERSTATUS_WAITFORPIN;
	}

	//
	// Show properties if WizAction is WIZACTION_SHOWPROPERTIES
	//
	if(WizAction == WIZACTION_SHOWPROPERTIES)
	{
		dwRetCode = ShowProperties(hWndParent);
		*pbRefresh = GetReFresh();
		return dwRetCode;
	}

	// verify the registry entries if the LS is already registered and the 
	// connection method is Internet
	if ((GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
		 GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT) 
		 && dwLSStatus == LSERVERSTATUS_REGISTER_INTERNET )
	{
		dwRetCode = GetGlobalContext()->CheckRequieredFields();
		if (dwRetCode != ERROR_SUCCESS)
		{
			LRMessageBox(hWndParent,dwRetCode,NULL,LRGetLastError());
			goto done;
		}
	}

	if (dwLSStatus == LSERVERSTATUS_WAITFORPIN)
	{
		GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);
	}

	assert(dwLSStatus == LSERVERSTATUS_UNREGISTER ||
		   dwLSStatus == LSERVERSTATUS_WAITFORPIN ||
		   dwLSStatus == LSERVERSTATUS_REGISTER_INTERNET ||
		   dwLSStatus == LSERVERSTATUS_REGISTER_OTHER);


	GetGlobalContext()->SetLSStatus(dwLSStatus);

	//Create All the pages here

    // New Welcome page which explains the process, etc.
    switch (WizAction)
    {
        case (WIZACTION_REGISTERLS):
        {
            psp.dwSize              = sizeof( psp );
            psp.hInstance           = GetInstanceHandle();
            psp.lParam              = (LPARAM)&PageInfo;	
	        psp.pfnDlgProc          = SimpleWelcomeDlgProc;
            psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate         = MAKEINTRESOURCE(IDD_WELCOME_ACTIVATION);
            ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );
            break;
        }
        
        case (WIZACTION_CONTINUEREGISTERLS):    
        {
            psp.dwSize              = sizeof( psp );
            psp.hInstance           = GetInstanceHandle();
            psp.lParam              = (LPARAM)&PageInfo;	
	        psp.pfnDlgProc          = ComplexWelcomeDlgProc;
            psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate         = MAKEINTRESOURCE(IDD_WELCOME_ACTIVATION);
            ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );
            break;
        }
        case (WIZACTION_DOWNLOADLKP):    
        case (WIZACTION_DOWNLOADLASTLKP):    
        {
            psp.dwSize              = sizeof( psp );
            psp.hInstance           = GetInstanceHandle();
            psp.lParam              = (LPARAM)&PageInfo;	
	        psp.pfnDlgProc          = ComplexWelcomeDlgProc;
            psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate         = MAKEINTRESOURCE(IDD_WELCOME_CLIENT_LICENSING);
            ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );
            break;
        }
        case (WIZACTION_REREGISTERLS):    
        {
            psp.dwSize              = sizeof( psp );
            psp.hInstance           = GetInstanceHandle();
            psp.lParam              = (LPARAM)&PageInfo;	
	        psp.pfnDlgProc          = ComplexWelcomeDlgProc;
            psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate         = MAKEINTRESOURCE(IDD_WELCOME_REACTIVATION);
            ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );
            break;
        }
        default:
        {
            psp.dwSize              = sizeof( psp );
            psp.hInstance           = GetInstanceHandle();
            psp.lParam              = (LPARAM)&PageInfo;	
	        psp.pfnDlgProc          = ComplexWelcomeDlgProc;
            psp.dwFlags             = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate         = MAKEINTRESOURCE(IDD_WELCOME);
            ahpsp[PG_NDX_WELCOME]	= CreatePropertySheetPage( &psp );
            break;
        }
    }

	// New page for choosing the Mode of Registration
    psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance           = GetInstanceHandle();
    psp.lParam              = (LPARAM)&PageInfo;	
	psp.pfnDlgProc          = GetModeDlgProc;
    psp.pszHeaderTitle		= MAKEINTRESOURCE( IDS_TITLE20 );
    psp.pszHeaderSubTitle	= MAKEINTRESOURCE( IDS_SUBTITLE20 );
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_DLG_GETREGMODE );
    ahpsp[PG_NDX_GETREGMODE]= CreatePropertySheetPage( &psp );


	//
	//Customer Information(2) page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ContactInfo1DlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE4 );
    psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE4 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_CONTACTINFO1 );
    ahpsp[PG_NDX_CONTACTINFO1]	= CreatePropertySheetPage( &psp );


	//
	//Customer Information(1) page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ContactInfo2DlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE3 );
    psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE3 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_CONTACTINFO2 );
    ahpsp[PG_NDX_CONTACTINFO2]	= CreatePropertySheetPage( &psp );	

	
#ifdef XXX
	//
	//Processing Request page(Online)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ProcessingDlgProc;	
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE5 );    
	psp.pszHeaderSubTitle		= MAKEINTRESOURCE( IDS_SUBTITLE5 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_PROCESSING );
    ahpsp[PG_NDX_PROCESSING]	= CreatePropertySheetPage( &psp );
#endif


	//
	//Registration Complete page for CA Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_HIDEHEADER;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= ProgressDlgProc;    
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_PROGRESS );
    ahpsp[PG_NDX_PROGRESS]		= CreatePropertySheetPage( &psp );

	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT | PSP_HIDEHEADER;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= (LPARAM)&PageInfo;
	psp.pfnDlgProc				= Progress2DlgProc;
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_PROGRESS2 );
    ahpsp[PG_NDX_PROGRESS2]	    = CreatePropertySheetPage( &psp );



	//
	//Certificate PIN page for CA Request(Online)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= PINDlgProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE9 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE9 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_PIN );
    ahpsp[PG_NDX_DLG_PIN]				= CreatePropertySheetPage( &psp );

	//
	//Choose Program page for CH Request(Online/Offline)
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CustInfoLicenseType;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE10 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE10 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_LICENSETYPE );
    ahpsp[PG_NDX_CH_REGISTER_1]			= CreatePropertySheetPage( &psp );

	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CHRegisterDlgProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE12 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE12 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_CH_REGISTER );
    ahpsp[PG_NDX_CH_REGISTER]		    = CreatePropertySheetPage( &psp );


	//
	// Options after registering
	//
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= ContinueReg;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE18 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE18 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_CONTINUEREG );
    ahpsp[PG_NDX_CONTINUEREG]			= CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Telephone Registration
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelRegProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE19 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE19 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELREG);
    ahpsp[PG_NDX_TELREG]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Telephone LKP stuff
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelLKPProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE21 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE21 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELLKP);
    ahpsp[PG_NDX_TELLKP]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Retail SPK Implementation
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= RetailSPKProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE22 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE22 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_RETAILSPK );
    ahpsp[PG_NDX_RETAILSPK]	   		    = CreatePropertySheetPage( &psp );


	// New Dialog Box to complete the Cert Log Infor (before re-issuing/revoking certs)
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CertLogProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE24 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE24 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_CERTLOG_INFO );
    ahpsp[PG_NDX_CERTLOG]   		    = CreatePropertySheetPage( &psp );


	// Telephone Revocation
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= ConfRevokeProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE25 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE25 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_CONFREVOKE );
    ahpsp[PG_NDX_CONFREVOKE]   		    = CreatePropertySheetPage( &psp );

	// Telephone re-issue
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= TelReissueProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE26 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE26 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_TELREG_REISSUE );
    ahpsp[PG_NDX_TELREG_REISSUE] 	    = CreatePropertySheetPage( &psp );

	// WWW re-issue
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= WWWReissueProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE26 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE26 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_WWWREG_REISSUE );
    ahpsp[PG_NDX_WWWREG_REISSUE] 	    = CreatePropertySheetPage( &psp );


	// Telephone Country/Region
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= CountryRegionProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE27 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE27 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_COUNTRYREGION );
    ahpsp[PG_NDX_COUNTRYREGION] 	    = CreatePropertySheetPage( &psp );


	// WWW Registration
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= WWWRegProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE28 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE28 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_WWWREG);
    ahpsp[PG_NDX_WWWREG]		 	    = CreatePropertySheetPage( &psp );

	// WWW LKP Download
	memset(&psp,0,sizeof(psp));
	psp.dwSize							= sizeof( psp );
    psp.dwFlags							= PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance						= GetInstanceHandle();
    psp.lParam							= (LPARAM)&PageInfo;
	psp.pfnDlgProc						= WWWLKPProc;
    psp.pszHeaderTitle					= MAKEINTRESOURCE( IDS_TITLE29 );
	psp.pszHeaderSubTitle				= MAKEINTRESOURCE( IDS_SUBTITLE29 );
    psp.pszTemplate						= MAKEINTRESOURCE( IDD_DLG_WWWLKP);
    ahpsp[PG_NDX_WWWLKP]			    = CreatePropertySheetPage( &psp );

    //Add the other welcome screens. Their order will differ depending
    //on the wiz action, because the relevant one will need to be the
    //first dialog of the wizard...the others will be added to the end
    switch (WizAction)
    {
        case (WIZACTION_REGISTERLS):    
        case (WIZACTION_CONTINUEREGISTERLS):    
        {
            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_CLIENT_LICENSING);
            ahpsp[PG_NDX_WELCOME_1]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_REACTIVATION);
            ahpsp[PG_NDX_WELCOME_2]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME);
            ahpsp[PG_NDX_WELCOME_3]			    = CreatePropertySheetPage( &psp );
            break;
        }
        case (WIZACTION_DOWNLOADLKP):    
        case (WIZACTION_DOWNLOADLASTLKP):    
        {
            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_ACTIVATION);
            ahpsp[PG_NDX_WELCOME_1]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_REACTIVATION);
            ahpsp[PG_NDX_WELCOME_2]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME);
            ahpsp[PG_NDX_WELCOME_3]			    = CreatePropertySheetPage( &psp );
            break;
        }
        case (WIZACTION_REREGISTERLS):    
        {
            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_ACTIVATION);
            ahpsp[PG_NDX_WELCOME_1]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_CLIENT_LICENSING);
            ahpsp[PG_NDX_WELCOME_2]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME);
            ahpsp[PG_NDX_WELCOME_3]			    = CreatePropertySheetPage( &psp );
            break;
        }
        default:
        {
            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_ACTIVATION);
            ahpsp[PG_NDX_WELCOME_1]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
	        psp.dwSize							= sizeof( psp );
            psp.dwFlags							= PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance						= GetInstanceHandle();
            psp.lParam							= (LPARAM)&PageInfo;
	        psp.pfnDlgProc						= ComplexWelcomeDlgProc;
            psp.pszTemplate						= MAKEINTRESOURCE(IDD_WELCOME_CLIENT_LICENSING);
            ahpsp[PG_NDX_WELCOME_2]			    = CreatePropertySheetPage( &psp );

            memset(&psp,0,sizeof(psp));
            psp.dwSize                          = sizeof( psp );
            psp.dwFlags                         = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance                       = GetInstanceHandle();
            psp.lParam                          = (LPARAM)&PageInfo;
            psp.pfnDlgProc                      = ComplexWelcomeDlgProc;
            psp.pszTemplate                     = MAKEINTRESOURCE(IDD_WELCOME_REACTIVATION);
            ahpsp[PG_NDX_WELCOME_3]             = CreatePropertySheetPage( &psp );
            break;
        }
    }

    //
    // Enter license code (e.g. select type licenses)
    //
    memset(&psp,0,sizeof(psp));
    psp.dwSize                          = sizeof( psp );
    psp.dwFlags                         = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance                       = GetInstanceHandle();
    psp.lParam                          = (LPARAM)&PageInfo;
    psp.pfnDlgProc                      = EnterCustomLicenseProc;
    psp.pszHeaderTitle                  = MAKEINTRESOURCE( IDS_ENTER_LICENSE_WIZARD_HEADER );
    psp.pszHeaderSubTitle               = MAKEINTRESOURCE( IDS_ENTER_LICENSE_WIZARD_SUBHEADER );
    psp.pszTemplate                     = MAKEINTRESOURCE( IDD_DLG_ENTER_LIC );
    ahpsp[PG_NDX_ENTERLICENSE]          = CreatePropertySheetPage( &psp );


    psh.dwFlags             = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;

    //psh.pszbmWatermark      = 0;
    //psh.pszbmHeader         = 0;
    psh.pszbmWatermark      = MAKEINTRESOURCE(IDB_CLIENT_CONN);
    psh.pszbmHeader         = MAKEINTRESOURCE(IDB_CLIENT_CONN_HDR);

    psh.dwSize              = sizeof( psh );
    psh.hInstance           = GetInstanceHandle();
    psh.hwndParent          = hWndParent;
    psh.pszCaption          = MAKEINTRESOURCE( IDS_TITLE4 );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = NO_OF_PAGES;
    PageInfo.TotalPages     = NO_OF_PAGES;


    //
    // Create the bold fonts.
    // 
    SetupFonts( GetInstanceHandle(), NULL, &PageInfo.hBigBoldFont, &PageInfo.hBoldFont );

    //
    // Validate all the pages.
    //
    for(i = 0; i < NO_OF_PAGES; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

    //
    // Display the wizard.
    //
    if( bStatus )
    {   
        if( PropertySheet( &psh ) == -1 )
        {
            bStatus = FALSE;
        }
    }

    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for(i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }

    //
    // Destroy the fonts that were created.
    //
    DestroyFonts( PageInfo.hBigBoldFont, PageInfo.hBoldFont );

done:
	if(!bStatus)
	{
		LRMessageBox(hWndParent,IDS_ERR_CREATE_FAILED,IDS_WIZARD_MESSAGE_TITLE);
		dwRetCode = LRWIZ_ERROR_CREATE_FAILED;
	}

	if (dwRetCode == 0 || dwRetCode == LRWIZ_SUCCESS)
	{
		*pbRefresh = GetReFresh();
	}

	GetGlobalContext()->FreeGlobal();

    return dwRetCode;
}


DWORD ShowProperties(HWND hWndParent)
{
	DWORD			dwRetCode = ERROR_SUCCESS;
	BOOL            bStatus             = TRUE;    
    PROPSHEETPAGE   psp                 = {0};
    HPROPSHEETPAGE  ahpsp[NO_OF_PROP_PAGES]  = {0};
    PROPSHEETHEADER psh                 = {0};
	UINT i = 0;

	//
	//Create All the pages here
	//

	// Registration Mode Page
	memset(&psp,0,sizeof(psp));
    psp.dwSize              = sizeof( psp );
    psp.dwFlags             = PSP_DEFAULT | PSP_USETITLE | PSP_PREMATURE ; 
    psp.hInstance           = GetInstanceHandle();
    psp.lParam              = NULL;	
	psp.pfnDlgProc          = PropModeDlgProc;
    psp.pszTitle			= MAKEINTRESOURCE( IDS_TITLE36 );
	psp.pszHeaderTitle		= MAKEINTRESOURCE( IDS_TITLE36 );
    psp.pszTemplate         = MAKEINTRESOURCE( IDD_DLG_PROP_MODE);
	
    ahpsp[PG_NDX_PROP_MODE]= CreatePropertySheetPage( &psp );
	
	// Customer Information (I) page
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT |  PSP_USETITLE | PSP_PREMATURE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= NULL;
	psp.pfnDlgProc				= PropCustInfoADlgProc;
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE38 );
	psp.pszTitle				= MAKEINTRESOURCE( IDS_TITLE38 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_DLG_PROP_CUSTINFO_a);
    ahpsp[PG_NDX_PROP_CUSTINFO_a]	= CreatePropertySheetPage( &psp );


	// Customer Information (II) page
	memset(&psp,0,sizeof(psp));
	psp.dwSize					= sizeof( psp );
    psp.dwFlags					= PSP_DEFAULT |  PSP_USETITLE | PSP_PREMATURE;
    psp.hInstance				= GetInstanceHandle();
    psp.lParam					= NULL;
	psp.pfnDlgProc				= PropCustInfoBDlgProc;
    psp.pszHeaderTitle			= MAKEINTRESOURCE( IDS_TITLE39 );
	psp.pszTitle				= MAKEINTRESOURCE( IDS_TITLE39 );
    psp.pszTemplate				= MAKEINTRESOURCE( IDD_DLG_PROP_CUSTINFO_b);
    ahpsp[PG_NDX_PROP_CUSTINFO_b]	= CreatePropertySheetPage( &psp );


	psh.dwFlags             = PSH_DEFAULT | PSH_PROPTITLE | PSH_NOAPPLYNOW| PSH_NOCONTEXTHELP;
    psh.dwSize              = sizeof( psh );
    psh.hInstance           = GetInstanceHandle();
    psh.hwndParent          = hWndParent;
    psh.pszCaption          = MAKEINTRESOURCE( IDS_PROPERTIES_TITLE );
    psh.phpage              = ahpsp;
    psh.nStartPage          = 0;
    psh.nPages              = NO_OF_PROP_PAGES;    

    //
    // Validate all the pages.
    //
    for( i = 0; i < NO_OF_PROP_PAGES; i++ )
    {
        if( ahpsp[i] == 0 )
        {
            bStatus = FALSE;
        }
    }

    //
    // Display the wizard.
    //
    if( bStatus )
    {   
        if( PropertySheet( &psh ) == -1 )
        {
            bStatus = FALSE;
        }
    }

    if( !bStatus )
    {
        //
        // Manually destroy the pages if something failed.
        //
        for(i = 0; i < psh.nPages; i++)
        {
            if( ahpsp[i] )
            {
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }    

	if(!bStatus)
	{
		LRMessageBox(hWndParent,IDS_ERR_CREATE_FAILED,IDS_WIZARD_MESSAGE_TITLE);
		dwRetCode = LRWIZ_ERROR_CREATE_FAILED;
	}

	return dwRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\lrwizdll.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _LRWIZDLL_H_
#define _LRWIZDLL_H_

#include "def.h"
#include "lrwizapi.h"

struct PageInfo
{	
	int				LRMode;
	int				LROperation;
	DWORD			dwPrevPage;
    UINT			CurrentPage;
    UINT			TotalPages;
	HFONT			hBigBoldFont;
	HFONT			hBoldFont;
};

BOOL WINAPI
DllMain(
	HANDLE hInstance,
	ULONG ul_reason_for_call,
	LPVOID lpReserved);

DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPTSTR pszLSName, 
    PBOOL pbRefresh
);

#ifdef XX
DWORD 
StartLRWiz(
	HWND hWndParent,
	LPTSTR wszLSName);
#endif

BOOL 
LRIsLSRunning();

DWORD ShowProperties(HWND hWndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\oper.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>

extern HINSTANCE g_hInstance;


void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;



LRW_DLG_INT CALLBACK
TelReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	DWORD dwRetCode;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
			cwRegistrationID = GetGlobalContext()->GetRegistrationID();
			hwndLSID = GetDlgItem(hwnd, IDC_MSID);
			swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
				 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
				 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
				 cwRegistrationID + 30);
	
			SetWindowText(hwndLSID, awBuffer);
		}
		break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
 				SetWindowText(GetDlgItem(hwnd, IDC_PRODUCT_ID), GetLicenseServerID());                break;
                break;

            case PSN_WIZNEXT:
				{
					// Let us get the Information Entered First & concatenate everything into
					// One String
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					
					// OK, Now we have the Information provided by the user
					// Need to validate
					if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
					{
						// Extraneous characters in the SPK string
						LRMessageBox(hwnd, IDS_ERR_INVALIDLSID,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_DLG_TELREG_REISSUE;
					}
					else 
					{
						dwRetCode = SetLSSPK(tcUserValue);
						if (dwRetCode != ERROR_SUCCESS)
						{
							LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);	
							dwNextPage = IDD_DLG_TELREG_REISSUE;
						}
						else
						{
							dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
							dwNextPage = IDD_PROGRESS;
							LRPush(IDD_DLG_TELREG_REISSUE);
						}
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}




LRW_DLG_INT CALLBACK
ConfRevokeProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	DWORD dwRetCode;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        
		SendDlgItemMessage (hwnd, IDC_REVOKE_CONFIRMATION_NUMBER, EM_SETLIMITTEXT,
							LR_CONFIRMATION_LEN, 0);
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
			cwRegistrationID = GetGlobalContext()->GetRegistrationID();
			hwndLSID = GetDlgItem(hwnd, IDC_MSID2);
			swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
				 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
				 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
				 cwRegistrationID + 30);
	
			SetWindowText(hwndLSID, awBuffer);
		}
		break;


    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                break;

            case PSN_WIZNEXT:
				{
					TCHAR lpBuffer[ LR_CONFIRMATION_LEN+1];

					GetDlgItemText(hwnd,IDC_REVOKE_CONFIRMATION_NUMBER, lpBuffer,
								   LR_CONFIRMATION_LEN+1);

					if (SetConfirmationNumber(lpBuffer) != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CONFIRMATION_NUMBER,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage = IDD_DLG_CONFREVOKE;
					}
					else
					{
						dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_CONFREVOKE);
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}



LRW_DLG_INT CALLBACK
CertLogProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		SendDlgItemMessage (hwnd , IDC_TXT_LNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0);
		SendDlgItemMessage (hwnd , IDC_TXT_FNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
		SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,	EM_SETLIMITTEXT, CA_EMAIL_LEN,0);

		SetDlgItemText(hwnd, IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
		SetDlgItemText(hwnd, IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
		SetDlgItemText(hwnd, IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);

        break;

	case WM_SHOWWINDOW:
		//bad bad.  The view should get data from 
		//the doc and render it as it wants!
		if ( GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS )
		{
			PopulateReasonComboBox(GetDlgItem(hwnd,IDC_COMBO_REASONS), CODE_TYPE_DEACT);

			// Reason code is not required here - CR23
			// Hack - combo is hidden and first reason code is sent over to the backend
			ShowWindow(GetDlgItem(hwnd,IDC_COMBO_REASONS),SW_HIDE);
			ShowWindow(GetDlgItem(hwnd,IDC_LBL_REASON),SW_HIDE);
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_COMBO_REASONS),0);
		}
		if ( GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS )
		{
			PopulateReasonComboBox(GetDlgItem(hwnd,IDC_COMBO_REASONS), CODE_TYPE_REACT);

			// Reason codes are required in this case
			ShowWindow(GetDlgItem(hwnd,IDC_COMBO_REASONS),SW_SHOW);
			ShowWindow(GetDlgItem(hwnd,IDC_LBL_REASON),SW_SHOW);
		}
		

		break;
    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				//Populate the values which were read from the Registry during Global Init
				//
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                break;

            case PSN_WIZNEXT:
				{
					CString sLastName;
					CString sFirstName;
					CString sEmail;
					CString sReasonDesc;
					CString sReasonCode;

					LPTSTR  lpVal = NULL;					
					DWORD dwRetCode;

					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);

					int nCurSel = -1;

					nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_COMBO_REASONS));
					lpVal = sReasonDesc.GetBuffer(LR_REASON_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd,IDC_COMBO_REASONS), nCurSel, lpVal);
					sReasonDesc.ReleaseBuffer(-1);

					sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sEmail.TrimLeft();	 sEmail.TrimRight();					
					sReasonDesc.TrimLeft();sReasonDesc.TrimRight();
					
					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || 
                       sReasonDesc.IsEmpty() )
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY,IDS_WIZARD_MESSAGE_TITLE);	
						dwNextPage	= IDD_DLG_CERTLOG_INFO;
						goto NextDone;
					}
					
					// Check for the Invalid Characters
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sEmail)       
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_DLG_CERTLOG_INFO;
						goto NextDone;
					}
					
					if(!sEmail.IsEmpty())
					{
						if(!ValidateEmailId(sEmail))
						{
							LRMessageBox(hwnd,IDS_ERR_INVALID_EMAIL,IDS_WIZARD_MESSAGE_TITLE);
							dwNextPage = IDD_DLG_CERTLOG_INFO;
							goto NextDone;
						}
					}

					lpVal = sReasonCode.GetBuffer(LR_REASON_CODE_LEN+1);
					if ( GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS )
					{
						GetReasonCode(sReasonDesc,lpVal, CODE_TYPE_DEACT);
					}
					else if ( GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS )
					{
						GetReasonCode(sReasonDesc,lpVal, CODE_TYPE_REACT);
					}

					
					sReasonCode.ReleaseBuffer(-1);
					

					//Finally update CAData object
                    GetGlobalContext()->GetContactDataObject()->sContactEmail = sEmail;
					GetGlobalContext()->GetContactDataObject()->sContactFName = sFirstName;
					GetGlobalContext()->GetContactDataObject()->sContactLName = sLastName;
					GetGlobalContext()->GetContactDataObject()->sReasonCode   = sReasonCode;
					
					//If no Error , go to the next page
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush( IDD_DLG_CERTLOG_INFO );
NextDone:
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\mode.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _MODE_H_
#define _MODE_H_

#include "precomp.h"

void SetConnectionMethodText(HWND hDialog);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\lrwizapi.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef __LRWIZAPI_H__
#define __LRWIZAPI_H__

#include "windows.h"

#define LRWIZ_ERROR_BASE				6000
//Return codes for LRWIZAPI
#define LRWIZ_SUCCESS					ERROR_SUCCESS
#define LRWIZ_OPERATION_CANCELLED		(LRWIZ_ERROR_BASE + 1)
#define LRWIZ_OPERATION_EXIT			(LRWIZ_ERROR_BASE + 2)
#define LRWIZ_ERROR_INITIALIZE			(LRWIZ_ERROR_BASE + 3)
#define LRWIZ_ERROR_PREREG				(LRWIZ_ERROR_BASE + 4)
#define LRWIZ_ERROR_AUTHENTICATE		(LRWIZ_ERROR_BASE + 5)
#define LRWIZ_INVALID_REQUEST_TYPE		(LRWIZ_ERROR_BASE + 6)
#define LRWIZ_ERROR_ACCEPTING_PKCS7		(LRWIZ_ERROR_BASE + 7)
#define LRWIZ_ERROR_DEPOSITING_CH_CERT	(LRWIZ_ERROR_BASE + 8)
#define LRWIZ_ERROR_PROCSSING_CH_DISK   (LRWIZ_ERROR_BASE + 9)
#define LRWIZ_ERROR_CREATING_PKCS10		(LRWIZ_ERROR_BASE + 10)
#define ERROR_CONNECTING_TO_RA			(LRWIZ_ERROR_BASE + 11)
#define ERROR_INVALID_RA_RESPONSE		(LRWIZ_ERROR_BASE + 12)
#define LRWIZ_ERROR_NO_CERT				(LRWIZ_ERROR_BASE + 13)
#define ERROR_CONNECTING_TO_CH			(LRWIZ_ERROR_BASE + 14)
#define ERROR_INVALID_CH_RESPONSE		(LRWIZ_ERROR_BASE + 15)
#define LRWIZ_ERROR_UPGRADE_REQUIRED	(LRWIZ_ERROR_BASE + 16)
#define	LRWIZ_ERROR_LS_NOT_RUNNING		(LRWIZ_ERROR_BASE + 17)
#define	LRWIZ_ERROR_CREATE_FAILED		(LRWIZ_ERROR_BASE + 18)
#define LRWIZ_ERROR_NTVERSION_LT_5		(LRWIZ_ERROR_BASE + 19)


#define LSERVERSTATUS_UNREGISTER        0   // server not register
#define LSERVERSTATUS_WAITFORPIN        1   // server is waiting for PIN
#define LSERVERSTATUS_REGISTER_INTERNET 2   // server is internet register
#define LSERVERSTATUS_REGISTER_OTHER    3   // server is non-internet register

typedef enum {
    WIZACTION_REGISTERLS,
    WIZACTION_DOWNLOADLKP,
    WIZACTION_UNREGISTERLS,
    WIZACTION_REREGISTERLS,
    WIZACTION_DOWNLOADLASTLKP,
    WIZACTION_SHOWPROPERTIES,
	WIZACTION_CONTINUEREGISTERLS
} WIZACTION;

typedef enum {
    WIZTYPE_ACTIVATION,
    WIZTYPE_CAL
} WIZTYPE;


typedef enum {
    CONNECTION_DEFAULT,
    CONNECTION_INTERNET,
    CONNECTION_WWW,
    CONNECTION_PHONE,
    CONNECTION_FAX      // only used for backwards compatibility
} WIZCONNECTION;

#ifdef __cplusplus
extern "C"
{
#endif

//
// Function return ERROR_SUCCESS or error code, 
// pConnectionType returns connection type set 
// by user
//
DWORD
GetConnectionType(
    HWND hWndParent,
    LPCTSTR pszLSName,
    WIZCONNECTION* pConnectionType       
);


//
// Function return ERROR_SUCCESS or error code.
// pdwServerStatus returns LSERVERSTATUS_XXXX
//
DWORD 
IsLicenseServerRegistered(
    HWND hWndParent, 
    LPCTSTR pszLSName,
    PDWORD pdwServerStatus
);


//
// Function return ERRROR_SUCCESS or error code.
// pbRefresh returns TRUE if LicMgr need to refresh server, 
// FALSE otherwise.
//
DWORD 
StartWizard(
    HWND hWndParent, 
    WIZACTION WizAction,
    LPCTSTR pszLSName, 
    PBOOL pbRefresh
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\mode.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation

#include "mode.h"

void SetConnectionMethodText(HWND hDialog)
{
	DWORD dwRetCode = ERROR_SUCCESS;
	TCHAR lpBuffer[512];

    //Now base the dynamic text on the combo box selection
    dwRetCode = ComboBox_GetCurSel(GetDlgItem(hDialog, IDC_MODEOFREG));
	if(dwRetCode == 0)
	{
		memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(),IDS_INTERNET_CONNECTION_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_DESC,lpBuffer);

		memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(),IDS_INTERNET_CONNECTION_REQ,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_REQ,lpBuffer);
    }

	if(dwRetCode == 1)
	{
		memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(),IDS_WWW_CONNECTION_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_DESC,lpBuffer);

		memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(),IDS_WWW_CONNECTION_REQ,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_REQ,lpBuffer);
	}	

	if(dwRetCode == 2)
	{
		memset(lpBuffer,0,sizeof(lpBuffer));
        LoadString(GetInstanceHandle(),IDS_PHONE_CONNECTION_DESC,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_DESC,lpBuffer);

		memset(lpBuffer,0,sizeof(lpBuffer));
    	LoadString(GetInstanceHandle(),IDS_PHONE_CONNECTION_REQ,lpBuffer,sizeof(lpBuffer)/sizeof(TCHAR));
		if (lpBuffer)
            SetDlgItemText(hDialog,IDC_CONNECTION_REQ,lpBuffer);
	}        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\pidgen.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    PIDGen.h

Abstract:

    public header

--*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef MAC
    #define PIDGenA PIDGen
#else
#if defined(WIN32) || defined(_WIN32)

    #ifdef UNICODE
        #define PIDGen  PIDGenW
        #define PIDGenSimp  PIDGenSimpW
    #else
        #define PIDGen  PIDGenA
        #define PIDGenSimp  PIDGenSimpA
    #endif // UNICODE

#else

    #include <string.h>
    #include <compobj.h>

    typedef BOOL NEAR *PBOOL;
    typedef BOOL FAR *LPBOOL;

    typedef FILETIME FAR *LPFILETIME;

    #define PIDGenA PIDGen
    #define lstrlenA lstrlen
    #define lstrcpyA lstrcpy
    #define wsprintfA wsprintf

    #define TEXT(s) __T(s)

    #define ZeroMemory(pb, cb) memset(pb, 0, cb)
    #define CopyMemory(pb, ab, cb) memcpy(pb, ab, cb)


#endif // defined(WIN32) || defined(_WIN32)
#endif // MAC


#define DIGITALPIDMAXLEN 256 // Max length of digital PID 3.0 data blob

#define INVALID_PID 0xFFFFFFFF

// PidGenSimp error code values

enum PidGenError { // pge

    //  Call succeded
    pgeSuccess = 0,

    //  Unable to validate product key.  Most likely causes:
    //      * Product Key was mistyped by user
    //      * Product Key not compatable with this .dll (wrong GroupId)
    pgeProductKeyInvalid = 1,

    //  Product Key's sequence number is not allowed by this .dll.
    //  Most likely causes:
    //      * Using Select or MSDN key with a PidGen/PidCa
    //        that specifically excludes them
    pgeProductKeyExcluded = 2,

    //  NULL was passed in for the required Product Key. (Must
    //  point to valid Product key.)
    pgeProductKeyNull = 3,

    //  Product Key is wrong length.  After removing any dashes, the length
    //  is required to be 25 characters
    pgeProductKeyBadLen = 4,

    //  NULL was passed in for the required SKU. (Must point to
    //  valid SKU.)
    pgeSkuNull = 5,

    //  SKU is wrong length (too long).
    pgeSkuBadLen = 6,


    //  NULL was passed in for the required PID2. (Must
    //  point to buffer for return PID.)
    pgePid2Null = 7,

    //  NULL was passed in for the required DigPid. (Must
    //  point to buffer for generated DigitalPID.)
    pgeDigPidNull = 8,

    //  DigPid is wrong length (too small).
    pgeDigPidBadLen = 9,

    //  NULL was passed in for the required MPC.
    pgeMpcNull = 10,

    //  MPC is wrong length. Must be exactly 5 characters.
    pgeMpcBadLen = 11,

    //  OemId is bad. If passed (it's not required) it must
    //  be 4 characters.
    pgeOemIdBadLen = 12,

    //  Local char set is bad. If provided, must be 24 characters.
    pgeLocalBad = 13,

    // ProductKey Unicode conversion failed
    pgeProductKeyBadUnicode = 14,

    // Mpc Unicode conversion failed
    pgeMpcBadUnicode = 15,

    // SKU Unicode conversion failed
    pgeSkuBadUnicode = 16,

    // OemId Unicode conversion failed
    pgeOemIdBadUnicode = 17,

    // Local Unicode conversion failed
    pgeLocalBadUnicode = 18,

    // Pid2 Unicode conversion failed
    pgePid2BadUnicode = 19,

    // Out of memory error
    pgeMemory = 20
};


typedef struct {
    DWORD       dwKeyIdx;
    BYTE        abPublicKey[1];
} BINKEY, *PBINKEY, FAR *LPBINKEY;


// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenA(
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPSTR   lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE  lpbPublicKey,       // [IN] pointer to optional public key or NULL
    DWORD   dwcbPublicKey,      // [IN] byte length of optional public key
    DWORD   dwKeyIdx,           // [IN] key pair index optional public key
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

#ifdef MAC
DWORD STDAPICALLTYPE PIDGenSimp(
#else
DWORD STDAPICALLTYPE PIDGenSimpA(
#endif
    LPSTR   lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCSTR  lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCSTR  lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCSTR  lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPSTR   lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

#if defined(WIN32) || defined(_WIN32)


// Original, outdated, interface to PidGen

BOOL STDAPICALLTYPE PIDGenW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    LPWSTR  lpstrLocal24,       // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
    LPBYTE lpbPublicKey,        // [IN] pointer to optional public key or NULL
    DWORD  dwcbPublicKey,       // [IN] byte length of optional public key
    DWORD  dwKeyIdx,            // [IN] key pair index optional public key
    BOOL   fOem,                // [IN] is this an OEM install?

    LPWSTR lpstrPid2,           // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number (can be NULL)
    LPBOOL  pfCCP,              // [OUT] optional ptr to Compliance Checking flag (can be NULL)
    LPBOOL  pfPSS);             // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)


// Simplified interface to PidGen

DWORD STDAPICALLTYPE PIDGenSimpW(
    LPWSTR  lpstrSecureCdKey,   // [IN] 25-character Secure CD-Key (gets U-Cased)
    LPCWSTR lpstrMpc,           // [IN] 5-character Microsoft Product Code
    LPCWSTR lpstrSku,           // [IN] Stock Keeping Unit (formatted like 123-12345)
    LPCWSTR lpstrOemId,         // [IN] 4-character OEM ID or NULL
    BOOL    fOem,               // [IN] is this an OEM install?

    LPWSTR  lpstrPid2,          // [OUT] PID 2.0, pass in ptr to 24 character array
    LPBYTE  lpbDigPid,          // [IN/OUT] pointer to DigitalPID buffer. First DWORD is the length
    LPDWORD lpdwSeq,            // [OUT] optional ptr to sequence number or NULL
    LPBOOL  pfCCP);             // [OUT] ptr to Compliance Checking flag or NULL

#endif // defined(WIN32) || defined(_WIN32)

// extern HINSTANCE g_hinst; // Moved to PIDGenPriv

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\pindlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _PINDLG_H_
#define _PINDLG_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\pindlg.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "PINDlg.h"

LRW_DLG_INT CALLBACK
PINDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	TCHAR * cwLicenseServerID;
	HWND	hwndLSID;

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );					
		cwLicenseServerID = GetLicenseServerID();

  		// Get the License Server ID, provided by the License Server
		hwndLSID = GetDlgItem(hwnd, IDC_MSID);

		// Let us format the License Server ID for showing.
		SetWindowText(hwndLSID, cwLicenseServerID);
		SendDlgItemMessage (hwnd , IDC_TXT_PIN,	EM_SETLIMITTEXT, CA_PIN_LEN,0);
		
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				{
					CString	sPIN;
					LPTSTR	lpVal = NULL;
					DWORD dwRetCode;
					
					lpVal = sPIN.GetBuffer(CA_PIN_LEN + 1);
					GetDlgItemText(hwnd,IDC_TXT_PIN,lpVal,CA_PIN_LEN+1);
					sPIN.ReleaseBuffer(-1);

					sPIN.TrimLeft(); sPIN.TrimRight();

					if (sPIN.IsEmpty())
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						dwNextPage	= IDD_DLG_PIN;						
					}
					else
					{				
						SetCertificatePIN((LPTSTR)(LPCTSTR)sPIN);
						dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

                        dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_PIN);
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
					
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}








LRW_DLG_INT CALLBACK
ContinueReg(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

		//
		//By default Check the first RADIO button.
		//
		SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED)
		{
			switch (LOWORD(wParam))
			{
			case IDC_REG_POSTPONE:
				if (SendDlgItemMessage(hwnd, IDC_REG_POSTPONE, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					TCHAR szBuf[ LR_MAX_MSG_TEXT];
					LoadString(GetInstanceHandle(), IDS_ALTFINISHTEXT, szBuf,LR_MAX_MSG_TEXT);
					//PropSheet_CancelToClose(GetParent( hwnd ));
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH );
//					PropSheet_SetFinishText( GetParent( hwnd ), szBuf);
				}
				break;

			case IDC_REG_COMPLETE:
				if (SendDlgItemMessage(hwnd, IDC_REG_COMPLETE, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				break;

			case IDC_REG_RESTART:
				if (SendDlgItemMessage(hwnd, IDC_REG_RESTART, BM_GETCHECK, 
									(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				break;
			}
		}
		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:   
				SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0);  //Fix bug# 627
				SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0);  //Fix bug# 627
				SendDlgItemMessage(hwnd,IDC_REG_RESTART,BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0);  //Fix bug# 627


				if(SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				else if (SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					TCHAR szBuf[ LR_MAX_MSG_TEXT];
					LoadString(GetInstanceHandle(), IDS_ALTFINISHTEXT, szBuf,LR_MAX_MSG_TEXT);
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH | PSWIZB_BACK);
//					PropSheet_SetFinishText( GetParent( hwnd ), szBuf);
				}
				else 
				{
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
				}
				
//                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);
                break;

            case PSN_WIZNEXT:
				if(SendDlgItemMessage(hwnd,IDC_REG_COMPLETE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					GetGlobalContext()->SetLSStatus(LSERVERSTATUS_WAITFORPIN);
					GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);

					dwNextPage = IDD_DLG_PIN;
				}
				else if (SendDlgItemMessage(hwnd,IDC_REG_POSTPONE,BM_GETCHECK,(WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
//					GetGlobalContext()->GetContactDataObject()->sProgramName = PROGRAM_MOLP;
//					EndDialog(hwnd);
//					PropSheet_PressButton(hwnd, PSWIZB_FINISH);
				}
				else 
				{
					// Restart
					GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
					GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
					GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
					GetGlobalContext()->ClearWizStack();
					dwNextPage = IDD_WELCOME_ACTIVATION;
				}
				
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
				if (dwNextPage != IDD_WELCOME_ACTIVATION)
				{
					LRPush(IDD_CONTINUEREG);
				}

                break;

            case PSN_WIZBACK:
				GetGlobalContext()->SetLSStatus(LSERVERSTATUS_WAITFORPIN);
				GetGlobalContext()->SetWizAction(WIZACTION_CONTINUEREGISTERLS);
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\propdlgs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _PROP_DLGS_H_
#define _PROP_DLGS_H_

LRW_DLG_INT CALLBACK 
PropModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
PropProgramDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


LRW_DLG_INT CALLBACK
PropCustInfoADlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
PropCustInfoBDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif //_PROP_DLGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\propdlgs.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "licensetype.h"
#include "fonts.h"
#include "mode.h"

LRW_DLG_INT CALLBACK 
PropModeDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
    DWORD	dwRetCode = ERROR_SUCCESS;	
    BOOL	bStatus = TRUE;    	

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			TCHAR		lpBuffer[ 512];			
			LVFINDINFO	lvFindInfo;
			int			nItem = 0;

			HWND	hWndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);

            memset(lpBuffer,0,sizeof(lpBuffer));
			dwRetCode = LoadString(GetInstanceHandle(), IDS_INTERNETMODE, lpBuffer, 512);
			ComboBox_AddString(hWndComboBox,lpBuffer);		

			memset(lpBuffer,0,sizeof(lpBuffer));		
			dwRetCode = LoadString(GetInstanceHandle(), IDS_WWWMODE, lpBuffer, 512);				
			ComboBox_AddString(hWndComboBox,lpBuffer);

			memset(lpBuffer,0,sizeof(lpBuffer));
			dwRetCode = LoadString(GetInstanceHandle(), IDS_TELEPHONEMODE, lpBuffer, 512);
			ComboBox_AddString(hWndComboBox,lpBuffer);		
            HWND hCountryRegion = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION);


			// Set the Current Activation Method
			GetGlobalContext()->SetLSProp_ActivationMethod(GetGlobalContext()->GetActivationMethod());

			ComboBox_ResetContent(hCountryRegion);

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET ||
			   GetGlobalContext()->GetActivationMethod() == CONNECTION_DEFAULT)
			{
				ComboBox_SetCurSel(hWndComboBox, 0);

            	EnableWindow(hCountryRegion,FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION_LABEL), FALSE);
			}

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW )
			{
				ComboBox_SetCurSel(hWndComboBox, 1);

            	EnableWindow(hCountryRegion,FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION_LABEL), FALSE);
			}	

			if(GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE )
			{
				ComboBox_SetCurSel(hWndComboBox, 2);

				dwRetCode = PopulateCountryRegionComboBox(hCountryRegion);
				if (dwRetCode != ERROR_SUCCESS)
				{					
					LRMessageBox(hwnd, dwRetCode, NULL, LRGetLastError());
				}

                nItem = ComboBox_FindStringExact(hCountryRegion, -1, GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion);
                ComboBox_SetCurSel(hCountryRegion, nItem);

            	EnableWindow(hCountryRegion,TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION_LABEL), TRUE);
            }

            SetDlgItemText(hwnd, IDC_LABEL_PRODUCTID, GetGlobalContext()->GetLicenseServerID());
		}

        SetConnectionMethodText(hwnd);

		break;


	case WM_COMMAND:
		if(HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_MODEOFREG)
		{
			LVFINDINFO	lvFindInfo;
			int			nItem = 0;

			HWND	hWndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
            HWND hCountryRegion = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION);

			SetReFresh(1);
			dwRetCode = ComboBox_GetCurSel((HWND)lParam);

            ComboBox_ResetContent(hCountryRegion);

			//Enable Country/Region List Box in case of Telephone
			if(dwRetCode == 2)
			{
                GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_PHONE);

                dwRetCode = PopulateCountryRegionComboBox(hCountryRegion);
                if (dwRetCode != ERROR_SUCCESS)
                {					
                    LRMessageBox(hwnd, dwRetCode, NULL, LRGetLastError());
                }

                nItem = ComboBox_FindStringExact(hCountryRegion, -1, GetGlobalContext()->GetContactDataObject()->sCSRPhoneRegion);
                ComboBox_SetCurSel(hCountryRegion, nItem);

            	EnableWindow(hCountryRegion,TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION_LABEL), TRUE);
            }
			else
			{
				if(dwRetCode == 0) // Internet
				{
					GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_INTERNET);
				}
				else
				{
					GetGlobalContext()->SetLSProp_ActivationMethod(CONNECTION_WWW);	
				}

                EnableWindow(hCountryRegion,FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_COUNTRYREGION_LABEL), FALSE);
			}			

            SetConnectionMethodText(hwnd);
		}


        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
                break;
            
			case PSN_APPLY:
				{
					HWND	hWndComboBox = GetDlgItem(hwnd,IDC_MODEOFREG);
					HWND	hCountryRegion = GetDlgItem(hwnd, IDC_PHONE_COUNTRYREGION );

					long	lReturnStatus = PSNRET_NOERROR;

					TCHAR	szItemText[MAX_COUNTRY_NAME_LENGTH + 1];
					int		nItem = 0;

					dwRetCode = ComboBox_GetCurSel(hWndComboBox);
					assert(dwRetCode >= 0 && dwRetCode <= 2);

					//Internet
					if(dwRetCode == 0)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_INTERNET);
					}

					// WWW
					if(dwRetCode == 1)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_WWW);						
					}

					// Phone
					if(dwRetCode == 2)
					{
						GetGlobalContext()->SetActivationMethod(CONNECTION_PHONE);

                        nItem = ComboBox_GetCurSel(hCountryRegion);
						if(nItem == -1)
						{
							LRMessageBox(hwnd, IDS_ERR_NOCOUNTRYSELECTED);
							lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
							goto done;
						}

                        ComboBox_GetLBText(hCountryRegion, nItem, szItemText);
                        GetGlobalContext()->SetInRegistry(REG_LRWIZ_CSPHONEREGION,szItemText);

                        TCHAR szPhoneNumber[128];
                        GetGlobalContext()->ReadPhoneNumberFromRegistry(szItemText, szPhoneNumber, (DWORD)sizeof(szPhoneNumber));
                        GetGlobalContext()->SetCSRNumber(szPhoneNumber);
					}

done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_MODE);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}



LRW_DLG_INT CALLBACK
PropCustInfoADlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   	
    BOOL	bStatus = TRUE;    
    CString sCountryDesc;
    CString sCountryCode;

    switch (uMsg) 
    {
    case WM_INITDIALOG:        

        SendDlgItemMessage (hwnd , IDC_TXT_COMPANYNAME,	EM_SETLIMITTEXT, CA_COMPANY_NAME_LEN,0);
        SendDlgItemMessage (hwnd , IDC_TXT_LNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0);
        SendDlgItemMessage (hwnd , IDC_TXT_FNAME,	EM_SETLIMITTEXT, CA_NAME_LEN,0); 	
        

        //Populate the values which were read from the Registry during Global Init
        SetDlgItemText(hwnd,IDC_TXT_LNAME, GetGlobalContext()->GetContactDataObject()->sContactLName);
        SetDlgItemText(hwnd,IDC_TXT_FNAME, GetGlobalContext()->GetContactDataObject()->sContactFName);
        SetDlgItemText(hwnd,IDC_TXT_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);

        //Set up the country/region combo box
        PopulateCountryComboBox(GetDlgItem(hwnd,IDC_COUNTRY_REGION));

        GetCountryDesc(GetGlobalContext()->GetContactDataObject()->sCountryCode,
        sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1));
        sCountryDesc.ReleaseBuffer();

        ComboBox_SetCurSel(GetDlgItem(hwnd,IDC_COUNTRY_REGION), 
        ComboBox_FindStringExact(GetDlgItem(hwnd, IDC_COUNTRY_REGION), 0, sCountryDesc));

        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
                DisplayPrivacyHelp();
                break;

            case PSN_SETACTIVE:				
				{
					TCHAR szBuf[ 255];

                    LoadString(GetInstanceHandle(),IDS_FAXOPTION_LABEL,szBuf,sizeof(szBuf)/sizeof(TCHAR));

					SetDlgItemText(hwnd, IDC_LBL_FAX, szBuf);

                    AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
				}
                break;

			case PSN_APPLY:
				{
					CString sCompanyName;
					CString sLastName;
					CString sFirstName;
					CString sCountryDesc;
                    CString sCountryCode;
					LPTSTR  lpVal = NULL;					

					long	lReturnStatus = PSNRET_NOERROR;

					//Read all the fields
					lpVal = sCompanyName.GetBuffer(CA_COMPANY_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_COMPANYNAME,lpVal,CA_COMPANY_NAME_LEN+1);
					sCompanyName.ReleaseBuffer(-1);

					lpVal = sLastName.GetBuffer(CA_NAME_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_LNAME,lpVal,CA_NAME_LEN+1);
					sLastName.ReleaseBuffer(-1);
					
					lpVal = sFirstName.GetBuffer(CA_NAME_LEN+1);
	 				GetDlgItemText(hwnd,IDC_TXT_FNAME,lpVal,CA_NAME_LEN+1);
					sFirstName.ReleaseBuffer(-1);

                    int nCurSel = -1;
                    nCurSel = ComboBox_GetCurSel(GetDlgItem(hwnd,IDC_COUNTRY_REGION));

					lpVal = sCountryDesc.GetBuffer(LR_COUNTRY_DESC_LEN+1);
					ComboBox_GetLBText(GetDlgItem(hwnd, IDC_COUNTRY_REGION), nCurSel, lpVal);
					sCountryDesc.ReleaseBuffer(-1);

					sFirstName.TrimLeft();   sFirstName.TrimRight();
					sLastName.TrimLeft();   sLastName.TrimRight();
					sCompanyName.TrimLeft(); sCompanyName.TrimRight();
					sCountryDesc.TrimLeft();sCountryDesc.TrimRight();

					if(sLastName.IsEmpty() || sFirstName.IsEmpty() || sCompanyName.IsEmpty())
					{
						LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}
					
					// Check for the Invalid Characters
					if( !ValidateLRString(sFirstName)	||
						!ValidateLRString(sLastName)	||
						!ValidateLRString(sCountryDesc)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}										
					
                    //Check for unselected country/region
                    if(sCountryDesc.IsEmpty())
                    {
                        LRMessageBox(hwnd,IDS_ERR_FIELD_EMPTY);	
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}

                    //Get the country code assicated with the selected country
					lpVal = sCountryCode.GetBuffer(LR_COUNTRY_CODE_LEN+1);
					if (sCountryDesc.IsEmpty())
						lstrcpy(lpVal, _TEXT(""));
					else
						GetCountryCode(sCountryDesc,lpVal);
					sCountryCode.ReleaseBuffer(-1);

                    // Put into regsitery
                    GetGlobalContext()->SetInRegistry(szOID_COMMON_NAME, sFirstName);
                    GetGlobalContext()->SetInRegistry(szOID_SUR_NAME, sLastName);
                    GetGlobalContext()->SetInRegistry(szOID_ORGANIZATION_NAME, sCompanyName);
                    GetGlobalContext()->SetInRegistry(szOID_COUNTRY_NAME, sCountryDesc);
                    GetGlobalContext()->SetInRegistry(szOID_DESCRIPTION, sCountryCode);

done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_CUSTINFO_a);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


LRW_DLG_INT CALLBACK
PropCustInfoBDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   	
    BOOL	bStatus = TRUE;    

    switch (uMsg) 
    {
    case WM_INITDIALOG:        

        SendDlgItemMessage (hwnd , IDC_TXT_EMAIL,	EM_SETLIMITTEXT, CA_EMAIL_LEN,0);
        SendDlgItemMessage (hwnd , IDC_TXT_ADDRESS1,	EM_SETLIMITTEXT, CA_ADDRESS_LEN,0);
        SendDlgItemMessage (hwnd , IDC_TXT_CITY,		EM_SETLIMITTEXT, CA_CITY_LEN,0); 	
        SendDlgItemMessage (hwnd , IDC_TXT_STATE,		EM_SETLIMITTEXT, CA_STATE_LEN,0);
        SendDlgItemMessage (hwnd , IDC_TXT_ZIP,			EM_SETLIMITTEXT, CA_ZIP_LEN,0); 	
        SendDlgItemMessage (hwnd , IDC_COMPANY_DIV, EM_SETLIMITTEXT, CA_ORG_UNIT_LEN,0);

        //Populate the values which were read from the Registry during Global Init
        SetDlgItemText(hwnd,IDC_TXT_EMAIL, GetGlobalContext()->GetContactDataObject()->sContactEmail);
        SetDlgItemText(hwnd,IDC_TXT_ADDRESS1, GetGlobalContext()->GetContactDataObject()->sContactAddress);
        SetDlgItemText(hwnd,IDC_TXT_CITY	, GetGlobalContext()->GetContactDataObject()->sCity);
        SetDlgItemText(hwnd,IDC_TXT_STATE	, GetGlobalContext()->GetContactDataObject()->sState);
        SetDlgItemText(hwnd,IDC_TXT_ZIP		, GetGlobalContext()->GetContactDataObject()->sZip);
        SetDlgItemText(hwnd,IDC_COMPANY_DIV , GetGlobalContext()->GetContactDataObject()->sOrgUnit);

        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
                DisplayPrivacyHelp();
                break;

            case PSN_SETACTIVE:
                TCHAR szBuf[ 255];                          
                AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);

                break;
			case PSN_APPLY:
				{
					LPTSTR  lpVal = NULL;
					CString sAddress1;
					CString sCity;
					CString sState;					
					CString sZip;
					CString sOrgUnit;
                    CString sEmail;
					int		nCurSel = -1;

					long	lReturnStatus = PSNRET_NOERROR;

					//Read all the fields
					lpVal = sEmail.GetBuffer(CA_EMAIL_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_EMAIL,lpVal,CA_EMAIL_LEN+1);
					sEmail.ReleaseBuffer(-1);

					lpVal = sAddress1.GetBuffer(CA_ADDRESS_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ADDRESS1,lpVal,CA_ADDRESS_LEN+1);
					sAddress1.ReleaseBuffer(-1);
					
					lpVal = sCity.GetBuffer(CA_CITY_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_CITY,lpVal,CA_CITY_LEN+1);
					sCity.ReleaseBuffer(-1);

					lpVal = sState.GetBuffer(CA_STATE_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_STATE,lpVal,CA_STATE_LEN+1);
					sState.ReleaseBuffer(-1);

					lpVal = sZip.GetBuffer(CA_ZIP_LEN+1);
					GetDlgItemText(hwnd,IDC_TXT_ZIP,lpVal,CA_ZIP_LEN+1);
					sZip.ReleaseBuffer(-1);

					lpVal = sOrgUnit.GetBuffer(CA_ORG_UNIT_LEN+1);
					GetDlgItemText(hwnd,IDC_COMPANY_DIV,lpVal,CA_ORG_UNIT_LEN+1);
					sOrgUnit.ReleaseBuffer(-1);
			
					sAddress1.TrimLeft(); sAddress1.TrimRight();
					sCity.TrimLeft(); sCity.TrimRight();
					sState.TrimLeft(); sState.TrimRight();
					sZip.TrimLeft(); sZip.TrimRight();
                    sEmail.TrimLeft();	 sEmail.TrimRight();
					sOrgUnit.TrimLeft(); sOrgUnit.TrimRight();

					if(
					   !ValidateLRString(sAddress1)	||
					   !ValidateLRString(sCity)		||
					   !ValidateLRString(sState)	||
                       !ValidateLRString(sEmail)	||	
					   !ValidateLRString(sZip)		||
					   !ValidateLRString(sOrgUnit)
					  )
					{
						LRMessageBox(hwnd,IDS_ERR_INVALID_CHAR);
						lReturnStatus = PSNRET_INVALID_NOCHANGEPAGE;
						goto done;
					}

                    GetGlobalContext()->SetInRegistry(szOID_RSA_emailAddr, (LPCTSTR) sEmail);
                    GetGlobalContext()->SetInRegistry(szOID_LOCALITY_NAME, sCity);
                    GetGlobalContext()->SetInRegistry(szOID_STREET_ADDRESS, sAddress1);
                    GetGlobalContext()->SetInRegistry(szOID_POSTAL_CODE, sZip);
                    GetGlobalContext()->SetInRegistry(szOID_STATE_OR_PROVINCE_NAME, sState);
                    GetGlobalContext()->SetInRegistry(szOID_ORGANIZATIONAL_UNIT_NAME, sOrgUnit);
done:
					if(lReturnStatus != PSNRET_NOERROR)
						PropSheet_SetCurSel(GetParent(hwnd),NULL,PG_NDX_PROP_CUSTINFO_b);

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, lReturnStatus);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\prgrss2.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "commdlg.h"
#include "fonts.h"

void InitializeFailedCodeList(HWND hDialog)
{
	HWND hWndListView = GetDlgItem(hDialog, IDC_FAILED_CODES );

    //Setup columns in list view
	LV_COLUMN	lvColumn;
	TCHAR		lpszHeader[128];
	
	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx  = 225;

	LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSPK, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
	lvColumn.pszText = lpszHeader;
	ListView_InsertColumn(hWndListView, 0, &lvColumn);

	lvColumn.cx  = 80;
	LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSTATUS, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
	lvColumn.pszText = lpszHeader;
	ListView_InsertColumn(hWndListView, 1, &lvColumn);

	lvColumn.cx  = 160;
	LoadString(GetInstanceHandle(), IDS_PRODUCT_TYPE, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
	lvColumn.pszText = lpszHeader;
	ListView_InsertColumn(hWndListView, 2, &lvColumn);

	// Now that this is done, pre-populate the List Control from the Internal
	// List, if any
 	ListView_SetItemCount(hWndListView, MAX_RETAILSPKS_IN_BATCH);
}

void ShowErrorWindow(HWND hDialog, BOOL bShow)
{
    HWND hWndList = GetDlgItem(hDialog, IDC_FAILED_CODES);
    HWND hWndListLabel = GetDlgItem(hDialog, IDC_FAILED_CODES_LABEL);

    ShowWindow(hWndList, bShow);
    ShowWindow(hWndListLabel, bShow);
    
    ShowWindow(GetDlgItem(hDialog, IDC_CODE_ERROR_SUGGESTION), bShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDialog, IDC_KEY_PACK_SUCCESS), bShow ? SW_HIDE : SW_SHOW);

	PropSheet_SetWizButtons(GetParent(hDialog), PSWIZB_FINISH);
}

void PopulateSuccessCodeList(HWND hDialog)
{
    HWND hWndList = GetDlgItem(hDialog, IDC_SUCCEEDED_CODES);

    SendMessage(hWndList, LB_RESETCONTENT, 0, 0);
    LoadFinishedFromList(hWndList);
}

void PopulateErrorCodeList(HWND hDialog)
{
    HWND hWndList = GetDlgItem(hDialog, IDC_FAILED_CODES);

    ListView_DeleteAllItems(hWndList);
    LoadUnfinishedFromList(hWndList);
}

void ModifyErrorSpecificAppearance(HWND hDialog, DWORD dwRetCode)
{
    TCHAR szBuf[LR_MAX_MSG_TEXT];
    UINT nMessageID = ((dwRetCode == ERROR_SUCCESS) ? IDS_FINALSUCCESSMESSAGE2 : IDS_FINALFAILMESSAGE);
    LoadString(GetInstanceHandle(), nMessageID, szBuf, LR_MAX_MSG_TEXT);
    SetDlgItemText(hDialog, IDC_MESSAGE, szBuf);

    //We'll always do this because even if the return code
    //indicated a failure, some codes may have succeeded
    PopulateSuccessCodeList(hDialog);

    ShowErrorWindow(hDialog, (dwRetCode != ERROR_SUCCESS));

    if (dwRetCode != ERROR_SUCCESS)
    {
        ShowErrorWindow(hDialog, TRUE);
        PopulateErrorCodeList(hDialog);
        PropSheet_SetWizButtons(GetParent(hDialog), PSWIZB_BACK | PSWIZB_FINISH);
    }
    else
    {
        ShowErrorWindow(hDialog, FALSE);
    	dwRetCode = IDS_MSG_LKP_PROCESSED;
        SetReFresh(1);
        SetLRState(LRSTATE_NEUTRAL);
    }
}


BOOL HandleNotify(HWND hDialog, LPARAM lParam)
{
	DWORD	dwNextPage = 0;
    LPNMHDR pnmh = (LPNMHDR)lParam;

    switch(pnmh->code)
    {
        case PSN_SETACTIVE:
        {
			DWORD	dwRetCode	= 0;
			TCHAR	szMsg[LR_MAX_MSG_TEXT];

            dwRetCode = LRGetLastRetCode();

			// If everything successful, display the message depending on the Mode
			ModifyErrorSpecificAppearance(hDialog, dwRetCode);

            break;
        }

        case PSN_WIZBACK:
        {
			dwNextPage = LRPop();
			LRW_SETWINDOWLONG(hDialog,  LRW_DWL_MSGRESULT, dwNextPage);
			return TRUE;
	        break;
        }

        default:
        {
            return FALSE;
            break;
        }
    }

    return TRUE;
}

LRW_DLG_INT CALLBACK 
Progress2DlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
        case WM_INITDIALOG:
	    {
		    pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
		    LRW_SETWINDOWLONG(hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi);

		    //Set the Font for the Title Fields
		    SetControlFont(pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);	    	

            InitializeFailedCodeList(hwnd);

            break;
	    }

        case WM_DESTROY:
        {
            LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
            break;
        }

        case WM_NOTIFY:
        {
            bStatus = HandleNotify(hwnd, lParam);
            break;
        }
        default:
        {
            bStatus = FALSE;
            break;
        }
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\progress.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "commdlg.h"
#include "fonts.h"

LRW_DLG_INT CALLBACK 
ProgressDlgProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

    switch (uMsg) 
    {
    case WM_INITDIALOG:
		{
			pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
			LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

			//
			//Set the Font for the Title Fields
			//
			SetControlFont( pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);	    			
		}
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:
		if (HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDC_NEXTACTION)
		{

			if (SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_GETCHECK, 
								(WPARAM)0,(LPARAM)0) == BST_CHECKED)
			{
				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT);
			}
			else
			{
				PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
			}
		}
		break;

    case WM_NOTIFY:
        {
			DWORD	dwNextPage = 0;
            LPNMHDR pnmh = (LPNMHDR)lParam;
		
            switch( pnmh->code )
            {
            case PSN_SETACTIVE:
				{
					DWORD	dwRetCode	= 0;
					DWORD	dwErrorCode = 0;
					TCHAR	szBuf[LR_MAX_MSG_TEXT];
					TCHAR	szMsg[LR_MAX_MSG_TEXT];
                    TCHAR   szCompletionMsg[LR_MAX_MSG_TEXT];

					dwRetCode = LRGetLastRetCode();

					//
					// If everything successful, display the message depending
					// on the Mode
					//			
					SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_SETCHECK,
						   (WPARAM)BST_UNCHECKED,(LPARAM)0);
					ShowWindow(GetDlgItem(hwnd, IDC_NEXTACTION), SW_HIDE);
					ShowWindow(GetDlgItem(hwnd, IDC_BTN_PRINT), SW_HIDE);

					if (dwRetCode == ERROR_SUCCESS)
					{
                        switch (GetGlobalContext()->GetWizAction())
                        {
							case WIZACTION_CONTINUEREGISTERLS:
							case WIZACTION_REGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT);
								ShowWindow(GetDlgItem(hwnd, IDC_NEXTACTION), SW_SHOW);
								dwRetCode = IDS_MSG_CERT_INSTALLED;
								SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_SETCHECK,
									   (WPARAM)BST_CHECKED,(LPARAM)0);
						        LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
        						LoadString(GetInstanceHandle(), IDS_FINALSUCCESSMESSAGE, szBuf,LR_MAX_MSG_TEXT);
								SetReFresh(1);
								break;

							case WIZACTION_DOWNLOADLKP:
                            case WIZACTION_DOWNLOADLASTLKP:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_LKP_PROCESSED;
						        LoadString(GetInstanceHandle(),IDS_KEY_PACKS_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
        						LoadString(GetInstanceHandle(), IDS_FINAL_KEYPACK_SUCCESS_MESSAGE, szBuf,LR_MAX_MSG_TEXT);
								SetReFresh(1);
								break;

							case WIZACTION_REREGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_CERT_REISSUED;
        						LoadString(GetInstanceHandle(), IDS_FINAL_REACTIVATION_SUCCESS, szBuf,LR_MAX_MSG_TEXT);
						        LoadString(GetInstanceHandle(),IDS_REACTIVATION_COMPLETION_WIZARD,szCompletionMsg,LR_MAX_MSG_TEXT);
								SetReFresh(1);
								break;

							case WIZACTION_UNREGISTERLS:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
								dwRetCode = IDS_MSG_CERT_REVOKED;
        						LoadString(GetInstanceHandle(), IDS_FINALSUCCESSMESSAGE, szBuf,LR_MAX_MSG_TEXT);
						        LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
								SetReFresh(1);
								break;

							default:
								PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_FINISH);
        						LoadString(GetInstanceHandle(), IDS_FINALSUCCESSMESSAGE, szBuf,LR_MAX_MSG_TEXT);
						        LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
								break;
                        }
						SetDlgItemText(hwnd, IDC_MESSAGE, szBuf);

                        SetLRState(LRSTATE_NEUTRAL);

						LoadString(GetInstanceHandle(),dwRetCode,szMsg,LR_MAX_MSG_TEXT);
					}
					else //Include the Error code , if any ,in the msg 
					{
						LoadString(GetInstanceHandle(), IDS_FINALFAILMESSAGE, szBuf,LR_MAX_MSG_TEXT);
                        memset(szCompletionMsg, 0, LR_MAX_MSG_TEXT);
						SetDlgItemText(hwnd, IDC_MESSAGE, szBuf);

                        //
                        // Load the big-bold title string
                        switch (GetGlobalContext()->GetWizAction()) {
                        case WIZACTION_CONTINUEREGISTERLS:
                        case WIZACTION_REGISTERLS:
                            LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
                            break;

                        case WIZACTION_DOWNLOADLKP:
                        case WIZACTION_DOWNLOADLASTLKP:
                            LoadString(GetInstanceHandle(),IDS_KEY_PACKS_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
                            break;

                        case WIZACTION_REREGISTERLS:
                            LoadString(GetInstanceHandle(),IDS_REACTIVATION_COMPLETION_WIZARD,szCompletionMsg,LR_MAX_MSG_TEXT);
                            break;

                        case WIZACTION_UNREGISTERLS:
                            LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
                            break;

                        default:
                            LoadString(GetInstanceHandle(),IDS_ACTIVATION_COMPLETION_MESSAGE,szCompletionMsg,LR_MAX_MSG_TEXT);
                            break;
                        }

						LoadString(GetInstanceHandle(),dwRetCode,szBuf,LR_MAX_MSG_TEXT);
						dwErrorCode = LRGetLastError();
						if( dwErrorCode != 0)
						{
							_stprintf(szMsg,szBuf,dwErrorCode);
						}
						else
						{
							_tcscpy(szMsg,szBuf);
						}

						//Enable Back button in case of error
						//LRPop();
						PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_BACK);
					}		

					SetDlgItemText(hwnd,IDC_BIGBOLDTITLE,szCompletionMsg);						
					SetDlgItemText(hwnd,IDC_EDIT1,szMsg);						
				}				
                break;

            case PSN_WIZNEXT:				
				if (SendDlgItemMessage(hwnd, IDC_NEXTACTION, BM_GETCHECK,
								       (WPARAM)0,(LPARAM)0) == BST_CHECKED)
				{
					switch (GetGlobalContext()->GetWizAction())
					{
					case WIZACTION_REGISTERLS:
					case WIZACTION_CONTINUEREGISTERLS:
						// Go to Obtain LKPs
						// Go to the PIN screen
						DWORD dwStatus;
						DWORD dwRetCode = GetGlobalContext()->GetLSCertificates(&dwStatus);

						// Error Handling $$BM

						GetGlobalContext()->ClearWizStack();
						dwNextPage = IDD_WELCOME_CLIENT_LICENSING;

						if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET)
						{
							GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
							GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
						}
						else
						{
							GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
							GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_OTHER);
						}
						GetGlobalContext()->SetWizAction(WIZACTION_DOWNLOADLKP);
						break;
					}
					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
	            break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\retail.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include <commctrl.h>
#include "utils.h"
#include "fancypasting.h"

extern HINSTANCE g_hInstance;

void SetDeleteKeyStatus(int iValue) ;
int GetDeleteKeyStatus(void) ;

void MoveCaretRetail(int nID, HWND  hwnd )
{
	POINT Pt;
	int iCaretIndex  ;
	DWORD	dwNext = 0;	
	TCHAR tcUserValue[ CHARS_IN_BATCH + 1];
	DWORD dwLen ;


	GetCaretPos(&Pt); 
	iCaretIndex = (int) SendMessage(GetDlgItem(hwnd,nID), EM_CHARFROMPOS, 0, MAKELPARAM(Pt.x, Pt.y));

	GetDlgItemText(hwnd,nID, tcUserValue, CHARS_IN_BATCH+1);
	dwLen = _tcslen(tcUserValue);

	switch(iCaretIndex)
	{

	case 0: //Move to left edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_RETAILSPK2:		
				dwNext = IDC_RETAILSPK1;
			break ;

			case IDC_RETAILSPK3:		
				dwNext = IDC_RETAILSPK2;
			break ;


			case IDC_RETAILSPK4:		
				dwNext = IDC_RETAILSPK3;
			break ;

			case IDC_RETAILSPK5:		
				dwNext = IDC_RETAILSPK4;
			break ;			
		}
		


		if (dwNext != -1 && dwLen == 0 && GetDeleteKeyStatus() == 0)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_END,0);
		}
		break;

	case 5: //Move to right edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_RETAILSPK1:		
				dwNext = IDC_RETAILSPK2;
			break ;

			case IDC_RETAILSPK2:		
				dwNext = IDC_RETAILSPK3;
			break ;

			case IDC_RETAILSPK3:
				dwNext = IDC_RETAILSPK4;
			break ;

			case IDC_RETAILSPK4:
				dwNext = IDC_RETAILSPK5;
			break ;
		}

		if (dwNext != -1)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_HOME,0);
		}
		break;
	}

}



LRW_DLG_INT CALLBACK 
RetailSPKProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
	HWND	hWndListView = GetDlgItem(hwnd, IDC_RETAILSPKLIST );
	HWND	hSPKField = GetDlgItem(hwnd, IDC_RETAILSPK1);

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );

	int lo = LOWORD(wParam);
	int hi = HIWORD(wParam);

	if(hi == 1)
	{
		int b = 0;
	}

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );     
		SendDlgItemMessage (hwnd, IDC_RETAILSPK1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_RETAILSPK5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);		

		//Setup columns in list view
		{
			LV_COLUMN	lvColumn;
			TCHAR		lpszHeader[ 128];
			
			lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
			lvColumn.fmt = LVCFMT_LEFT;
			lvColumn.cx  = 225;

			LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSPK, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndListView, 0, &lvColumn);

			lvColumn.cx  = 80;
			LoadString(GetInstanceHandle(), IDS_RETAIL_HEADERSTATUS, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndListView, 1, &lvColumn);

			lvColumn.cx  = 160;
			LoadString(GetInstanceHandle(), IDS_PRODUCT_TYPE, lpszHeader, sizeof(lpszHeader)/sizeof(TCHAR));
			lvColumn.pszText = lpszHeader;
			ListView_InsertColumn(hWndListView, 2, &lvColumn);

			// Now that this is done, pre-populate the List Control from the Internal
			// List, if any
 			ListView_SetItemCount(hWndListView, MAX_RETAILSPKS_IN_BATCH);
		}
        break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			// List is being shown
			// Clean-it up & Load the list view
			ListView_DeleteAllItems(hWndListView);
			LoadUnfinishedFromList(hWndListView);
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaretRetail(LOWORD(wParam), hwnd ) ;		
			
		}

		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		else
		{
			switch ( LOWORD(wParam) )		//from which control
			{	
			case IDC_ADDBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];

					GetDlgItemText(hwnd,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					
					if ((dwRetCode=AddRetailSPKToList(hWndListView, lpVal)) != ERROR_SUCCESS)
					{					
						// Could not validate the SPK because of SOME reason
						LRMessageBox(hwnd,dwRetCode);

						if(dwRetCode == IDS_ERR_TOOMANYSPK)
						{
							// Blank out the field & continue
							SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
							SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));
						}
					}
					else
					{

						// Blank out the field & continue
						SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));
					}
					SetFocus(hSPKField);
				}
				break;

			case IDC_DELETEBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];
					int nItem = ListView_GetSelectionMark(hWndListView);

					if (nItem != -1)
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 0;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = LR_RETAILSPK_LEN+1;

						ListView_GetItem(hWndListView, &lvItem);

						// Something is selected, Delete it
						ListView_DeleteItem(hWndListView, nItem);

						DeleteRetailSPKFromList(lvItem.pszText);

						ListView_SetSelectionMark(hWndListView, -1);
					}
					SetFocus(hSPKField);
				}
				break;

			case IDC_EDITBUTTON:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					CString sModifiedRetailSPK;
					TCHAR lpVal[ LR_RETAILSPK_LEN+1];
					int nItem = ListView_GetSelectionMark(hWndListView);

					if (nItem != -1 )
					{
						LVITEM	lvItem;
						lvItem.mask = LVIF_TEXT;
						lvItem.iItem = nItem;
						lvItem.iSubItem = 0;
						lvItem.pszText = lpVal;
						lvItem.cchTextMax = LR_RETAILSPK_LEN+1;

						ListView_GetItem(hWndListView, &lvItem);
						
						SetModifiedRetailSPK(lvItem.pszText);
					
						//Show dialog box to Edit the SPK
						if ( DialogBox ( GetInstanceHandle(),
										 MAKEINTRESOURCE(IDD_EDIT_RETAILSPK),
										 hwnd,
										 EditRetailSPKDlgProc
										 ) == IDOK )
						{
							//Get the modified SPK
							GetModifiedRetailSPK(sModifiedRetailSPK);
							ModifyRetailSPKFromList(lvItem.pszText,(LPTSTR)(LPCTSTR)sModifiedRetailSPK);
							ListView_SetItemText(hWndListView,nItem,0,(LPTSTR)(LPCTSTR)sModifiedRetailSPK);						
						}
						ListView_SetSelectionMark(GetDlgItem(hwnd,IDC_RETAILSPKLIST),-1);
					}
					SetFocus(hSPKField);
				}
                break;

            case IDC_RETAILSPK1:
                if (HIWORD(wParam) == EN_MAXTEXT)
                    InsertClipboardDataIntoIDFields(hwnd, IDC_RETAILSPK1, IDC_RETAILSPK5);
                break;
            }
		}
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
		{
			BOOL  bGoNextPage = TRUE ;
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				{
					DWORD dwStyle = BS_DEFPUSHBUTTON|BS_CENTER|BS_VCENTER|BS_NOTIFY|WS_GROUP;
					SendDlgItemMessage (hwnd, IDC_ADDBUTTON, BM_SETSTYLE,(WPARAM)LOWORD(dwStyle), MAKELPARAM(TRUE, 0));
					PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
				}
                break;

            case PSN_WIZNEXT:
				TCHAR lpVal[ LR_RETAILSPK_LEN+1];	

				if (GetFocus() == GetDlgItem(hwnd,IDC_ADDBUTTON)) //Fix bug #312
				{
					bGoNextPage = FALSE;
				}

				// Read the SPK from the Field
				GetDlgItemText(hwnd,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);

				if (lstrlen(lpVal) != 0)
				{
					dwRetCode = AddRetailSPKToList(hWndListView, lpVal);					
					if (dwRetCode != IDS_ERR_TOOMANYSPK && dwRetCode != ERROR_SUCCESS)
					{
						// Could not validate the SPK because of SOME reason
						dwNextPage = IDD_DLG_RETAILSPK;
						LRMessageBox(hwnd, dwRetCode);
						SetFocus(hSPKField);
					}
					else
					{
						SetDlgItemText(hwnd, IDC_RETAILSPK1, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK2, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK3, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK4, _TEXT(""));
						SetDlgItemText(hwnd, IDC_RETAILSPK5, _TEXT(""));

						
						if (bGoNextPage == FALSE)
						{
							dwNextPage = IDD_DLG_RETAILSPK;
							SetFocus(hSPKField);
						}
						else
							dwNextPage = IDD_PROGRESS2;
                    }
				}
				else if (ListView_GetItemCount(hWndListView) <= 0)
				{
					LRMessageBox(hwnd, IDS_NOSPKSTOPROCESS);	
					dwNextPage = IDD_DLG_RETAILSPK;
				}
				else 
				{
					dwNextPage = IDD_PROGRESS2;

					LRPush(IDD_DLG_RETAILSPK);
				}

				if (dwNextPage == IDD_PROGRESS2)
				{
                    dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);

					LRPush( IDD_DLG_RETAILSPK );
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;                
                break;
			
			case NM_KILLFOCUS:
				if(pnmh->idFrom == IDC_RETAILSPKLIST && GetFocus() != GetDlgItem(hwnd,IDC_ADDBUTTON) &&
				     GetFocus() != GetDlgItem(hwnd,IDC_EDITBUTTON) && GetFocus() != GetDlgItem(hwnd,IDC_DELETEBUTTON))
				{
					ListView_SetSelectionMark(GetDlgItem(hwnd,IDC_RETAILSPKLIST),-1);
				}
				break;
            default:
                bStatus = FALSE;
                break;
            }
        }
        break;
	
    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}


LRW_DLG_INT CALLBACK EditRetailSPKDlgProc(  IN HWND hwndDlg,  // handle to dialog box
											IN UINT uMsg,     // message  
											IN WPARAM wParam, // first message parameter
											IN LPARAM lParam  // second message parameter
										 )
{
	BOOL	bRetCode = FALSE;
	TCHAR lpVal[ LR_RETAILSPK_LEN+1];
	
	
	switch ( uMsg )
	{
	case WM_INITDIALOG:
		{
			CString sFullRetailSPK;
			CString sSPK1,sSPK2,sSPK3,sSPK4,sSPK5;
			int		nIndex = 0;


			sFullRetailSPK.Empty();
			sSPK1.Empty();
			sSPK2.Empty();
			sSPK3.Empty();
			sSPK4.Empty();
			sSPK5.Empty();

			GetModifiedRetailSPK(sFullRetailSPK);

			sSPK1 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK2 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK3 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK4 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);
			nIndex += CHARS_IN_BATCH;
			sSPK5 = sFullRetailSPK.Mid(nIndex,CHARS_IN_BATCH);

			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
			SendDlgItemMessage (hwndDlg, IDC_RETAILSPK5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);

			SetDlgItemText(hwndDlg, IDC_RETAILSPK1, sSPK1);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK2, sSPK2);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK3, sSPK3);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK4, sSPK4);
			SetDlgItemText(hwndDlg, IDC_RETAILSPK5, sSPK5);

			bRetCode = TRUE;
		}
		break;

	case WM_COMMAND:
		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaretRetail(LOWORD(wParam), hwndDlg ) ;		
			
		}

		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		else
		{
			switch ( LOWORD(wParam) )		//from which control
			{
			case IDOK:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					DWORD dwRetCode = ERROR_SUCCESS;
					CString sOldRetailSPK;

					GetModifiedRetailSPK(sOldRetailSPK);

					GetDlgItemText(hwndDlg,IDC_RETAILSPK1, lpVal, CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK2, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK3, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK4, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);
					GetDlgItemText(hwndDlg,IDC_RETAILSPK5, lpVal+lstrlen(lpVal), CHARS_IN_BATCH+1);

					//Set the new spk only if changed 
					if(_tcsicmp(sOldRetailSPK,(LPCTSTR)lpVal))
					{
						dwRetCode = ValidateRetailSPK(lpVal);
						if(dwRetCode != ERROR_SUCCESS)
						{
							LRMessageBox(hwndDlg, dwRetCode);
							return TRUE;
						}

						SetModifiedRetailSPK(lpVal);
					}				

					EndDialog(hwndDlg, IDOK);
					bRetCode = TRUE;
				}
				break;

			case IDCANCEL:
				if (HIWORD(wParam) == BN_CLICKED)
				{
					EndDialog(hwndDlg, IDCANCEL);
					bRetCode = TRUE;
				}

			default:
				break;
			}
		}
		break;
	default:
		break;

	}
	return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:


Abstract:

    Precompiled header file

Author:


Revision History:

--*/
#pragma warning (disable: 4514) /* Unreferenced inline function removed     */
#pragma warning (disable: 4201) /* Nameless union/struct                    */
#pragma warning (disable: 4706) /* Assignment within conditional expression */

#include <afx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define INC_OLE2
//#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <tchar.h>

#include <htmlhelp.h>
#include <afxwin.h>
#include <shellapi.h>

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;





#ifdef _WIN64
#define LRW_GWL_USERDATA    GWLP_USERDATA
#define LRW_DWL_MSGRESULT   DWLP_MSGRESULT
#define LRW_DLG_INT         __int64
#define LRW_LONG_PTR        LONG_PTR
#define LRW_GETWINDOWLONG   GetWindowLongPtr
#define LRW_SETWINDOWLONG   SetWindowLongPtr
#else
#define LRW_GWL_USERDATA    GWL_USERDATA
#define LRW_DWL_MSGRESULT   DWL_MSGRESULT
#define LRW_DLG_INT         INT
#define LRW_LONG_PTR        LONG
#define LRW_GETWINDOWLONG   GetWindowLong
#define LRW_SETWINDOWLONG   SetWindowLong
#endif




#include "lrwizdll.h"
#include "resource.h"
#include "def.h"
#include "utils.h"
#include "dlgproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LRWizDLL.rc
//
#define IDS_UNKNOWN_REGISTRATION_ERROR  6
#define IDS_REQUIRED_FIELDS             9
#define IDS_PROCESS_CA_REQUEST          11
#define IDS_PROCESS_LKP_REQUEST         12
#define IDS_ERROR_ACCEPT_PKCS7          19
#define IDS_ERROR_DEPOSITING_CH_CERT    20
#define IDS_PHONE                       21
#define IDS_EMAIL                       22
#define IDS_WELCOME_CAPTION             23
#define IDS_CAREQUEST1_CAPTION          24
#define IDS_CAREQUEST2_CAPTION          25
#define IDS_CAREQUEST3_CAPTION          26
#define IDS_CHREQUEST1_CAPTION          27
#define IDS_CHREQUEST2_CAPTION          28
#define IDS_CHREQUEST_RETAIL_CAPTION    29
#define IDS_CUSTOMER_INFO               30
#define IDS_MAKE_DISK                   31
#define IDS_PROCESSING_REQUEST          32
#define IDS_SHIPPING_ADDRESS            33
#define IDS_CERT_NOT_ENOUGH             34
#define IDS_SUCCESS_INSTALL_CERT_ONLINE 35
#define IDS_FAIL_INSTALL_CERT_ONLINE    36
#define IDS_PIN_CAPTION                 37
#define IDS_SUCCESS_CREATE_ONLINE       38
#define IDS_TITLE                       39
#define IDS_SUCCESS_CREATE_CA_ONLINE    40
#define IDS_FAIL_CA_CREATE_ONLINE       41
#define IDS_FAIL_CH_CREATE_ONLINE       42
#define IDS_UPGRADE_REQD                43
#define IDS_REQUIRED_EMAIL              44
#define IDS_EMAIL_FORMAT                45
#define IDS_SUCCESS_INSTALL_GET_LKP     46
#define IDS_OUTBOUND_DISK_CA            47
#define IDS_INTERNETMODE                48
#define IDS_TELEPHONEMODE               49
#define IDD_DLG_PROP_MODE               112
#define IDB_STAR                        129
#define IDB_PANEL01                     131
#define IDB_PANEL02                     132
#define IDB_DISK                        133
#define IDB_LINE                        139
#define IDC_WELCOME_LOGO                141
#define IDC_BOLDTITLE                   141
#define IDD_CA_REQUEST_2                142
#define IDC_BOLDTITLE2                  142
#define IDC_RD_MANUAL                   143
#define IDC_BOLDTITLE3                  143
#define IDD_DLG_CUSTOMERINFO            144
#define IDC_BOLDTITLE4                  144
#define IDC_RD_INSTALL                  145
#define IDD_CA_REQUEST_4                146
#define IDD_CA_REQUEST_3                146
#define IDC_RD_INTERNET                 147
#define IDC_HYPERLINK_MOREINFO          200
#define IDC_BTN_NEXT                    1001
#define IDC_FINISH                      1002
#define IDC_COMBO_MODE                  1002
#define IDC_BACK                        1003
#define IDC_DONE                        1004
#define IDC_LBL_FAX                     1004
#define IDC_BMP_LOGO                    1005
#define IDC_TXT_PIN                     1008
#define IDC_HELP1                       1009
#define IDC_PROGRESSBAR                 1010
#define IDC_TOTAL_SIZE                  1011
#define IDC_RATE                        1012
#define IDC_EST_TIME                    1013
#define IDC_BTN_LKP                     1014
#define IDC_STATIC_EMAIL_STAR           1015
#define IDC_COMBO1                      1018
#define IDC_CH_LICENSE_TYPE             1018
#define IDC_SPIN1                       1020
#define IDC_LIST1                       1022
#define IDC_RETAILSPKLIST               1022
#define IDC_SUCCEEDED_CODES             1022
#define IDC_BIGBOLDTITLE                1023
#define IDC_LBL_EMAIL                   1024
#define IDC_EDIT1                       1025
#define IDC_LBL_EMAIL2                  1025
#define IDC_LBL_REASON                  1025
#define IDC_LBL_COUNTRY_REGION          1025
#define IDC_LBL_COUNTRY_REGION2         1026
#define IDC_LBL_CAPTION                 1027
#define IDC_TXT_CONF_EMAIL              1028
#define IDC_MODEOFREG                   1029
#define IDC_TELEPHONEINFO               1031
#define IDC_TELEPHONEREQUESTTAG         1031
#define IDC_TELEINFOTAG                 1032
#define IDC_TXT_TELEINFO                1033
#define IDC_REGISTRATIONID              1036
#define IDC_LICENSESERVERID             1039
#define IDC_MSID                        1042
#define IDC_LICENSESERVERIDOLD          1042
#define IDC_RETAILSPK                   1043
#define IDC_MSID2                       1043
#define IDC_ADDBUTTON                   1044
#define IDC_DELETEBUTTON                1045
#define IDC_STATIC_LSID                 1046
#define IDC_DOWN_NEWLKP                 1047
#define IDC_DOWN_LASTLKP                1048
#define IDC_REISSUE_CERT                1049
#define IDC_REVOKE_CERT                 1050
#define IDC_COMBO_REASONS               1051
#define IDCREVOKE_CONFIRMATION_NUMBER   1052
#define IDC_REVOKE_CONFIRMATION_NUMBER  1052
#define IDC_CSRINFO                     1054
#define IDC_COUNTRYREGION               1055
#define IDC_PHONE_COUNTRYREGION         1055
#define IDC_EDITBUTTON                  1060
#define IDC_TXT_DESC                    1062
#define IDC_TXT_WWWINFO                 1063
#define IDC_WWWINFO                     1064
#define IDC_TXT_FAX                     1065
#define IDC_BTN_PRINT                   1066
#define IDC_TAB1                        1067
#define IDC_CHANGEACTMETHOD             1068
#define IDC_TXT_COMPANYNAME             1069
#define IDC_CHANGECUSTINFO              1069
#define IDC_TXT_ORGUNIT                 1070
#define IDC_RESTARTACTIVATION           1071
#define IDC_NEXTACTION                  1072
#define IDC_REG_COMPLETE                1074
#define IDC_REG_POSTPONE                1075
#define IDC_REG_RESTART                 1076
#define IDC_COMPANYNAME                 1079
#define IDC_ACTIVATIONMETHOD            1080
#define IDC_LICENSETYPE                 1081
#define IDC_PRODUCTID                   1082
#define IDC_DESCRIPTION                 1084
#define IDC_CONNECTION_DESC             1088
#define IDC_CONNECTION_WHEN             1090
#define IDC_PROGRAM_DESC                1091
#define IDC_PROGRAM_REQ                 1092
#define IDC_PROGRAM_FORMAT              1093
#define IDC_PROGRAM_SAMPLE_SMALL_3      1094
#define IDC_PROGRAM_SAMPLE_SMALL_4      1095
#define IDC_PROGRAM_SAMPLE_SMALL_5      1096
#define IDC_PROGRAM_SAMPLE_SMALL_2      1097
#define IDC_PROGRAM_SAMPLE_BIG_1        1099
#define IDC_PROGRAM_SAMPLE_BIG_2        1100
#define IDC_PROGRAM_SAMPLE_SMALL_1      1101
#define IDC_PROGRAM_AUTHORIZATION_NUMBER 1102
#define IDC_PROGRAM_LICENSE_NUMBER      1103
#define IDC_PROGRAM_SAMPLE_SINGLE       1104
#define IDC_LICENSE_PROGRAM             1105
#define IDC_COUNTRY_REGION              1106
#define IDC_PRIVACY                     1107
#define IDC_PRODUCT_ID                  1108
#define IDC_LICENSESERVER_ID            1109
#define IDC_COMPANY_DIV                 1110
#define IDC_LICENSE_EXPLANATION         1111
#define IDC_WHEN_LABEL                  1114
#define IDC_DESCRIPTION_LABEL           1115
#define IDC_CH_SELECT_LICENSE_NUMBER    1117
#define IDC_LICENSE_NUMBER_LABEL        1118
#define IDC_CH_LICENSE_NUMBER_LABEL     1118
#define IDC_CH_SAMPLE_SELECT_LICENSE_NUMBER 1118
#define IDC_LICENSE_NUMBER_BOTTOM       1119
#define IDC_CH_MOLP_AGREEMENT_NUMBER    1119
#define IDC_AUTHORIZATION_NUMBER        1120
#define IDC_CH_MOLP_AUTHORIZATION_NUMBER 1120
#define IDC_AUTHORIZATION_NUMBER_EXP    1121
#define IDC_CH_MOLP_AUTHORIZATION_NUMBER_EXP 1121
#define IDC_LICENSE_NUMBER_BOTTOM_EXP   1123
#define IDC_CH_MOLP_AGREEMENT_NUMBER_EXP 1123
#define IDC_LICENSE_NUMBER_TOP_EXP      1124
#define IDC_CH_SELECT_LICENSE_NUMBER_EXP 1124
#define IDC_CH_MOLP_AGREEMENT_NUMBER_EXP2 1124
#define IDC_LICENSE_NUMBER_LOCATION     1125
#define IDC_CH_PRODUCT_TYPE             1126
#define IDC_CH_QUANTITY                 1127
#define IDC_PRODUCT_TYPE_EXP            1128
#define IDC_TXT_WWWINFO1                1129
#define IDC_TXT_WWWINFO2                1130
#define IDC_TXT_WWWINFO3                1131
#define IDC_TXT_WWWINFO4                1132
#define IDC_TXT_WWWINFO5                1133
#define IDC_TXT_WWWINFO6                1134
#define IDC_TXT_WWWINFO7                1135
#define IDC_COUNTRYREGION_LABEL         1136
#define IDC_FAILED_CODES                1140
#define IDC_FAILED_CODES_LABEL          1141
#define IDC_CODE_ERROR_SUGGESTION       1142
#define IDC_KEY_PACK_SUCCESS            1143
#define IDC_HOTKEY2                     1146
#define IDC_SCROLLBAR1                  1147
#define IDC_VERIFY_LICENSE_LABEL        1148
#define IDC_SAMPLE_LABEL                1149
#define IDC_LICPROG_LABEL               1150
#define IDC_LICENSE_PROGRAM_LABEL       1151
#define IDC_LICENSE_PROGRAM_STATIC      1152
#define IDC_AGREEMENT_LABEL             1153
#define IDC_PROGRAM_SINGLE_LICNUMBER    1155
#define IDC_PROGRAM_SAMPLE_SINGLE3      1156
#define IDC_INSTALLATION_LABEL          1157
#define IDC_LABEL_PRODUCTID             1158
#define IDC_CONNECTION_REQ              1159
#define IDD_CA_REQUEST_1                1200
#define IDC_RD_SELECT                   1201
#define IDC_RD_OTHER                    1202
#define IDC_CERT_TYPE                   1301
#define IDC_TXT_NAME                    1302
#define IDC_TXT_ORG_UNIT                1303
#define IDC_TXT_ADDRESS1                1305
#define IDC_TXT_ADDRESS2                1306
#define IDC_TXT_ADDRESS3                1307
#define IDC_TXT_STATE                   1309
#define IDC_TXT_ZIP                     1311
#define IDC_TXT_PHONE                   1314
#define IDC_TXT_EMAIL                   1315
#define IDC_TXT_TELEINFO1               1350
#define IDC_TXT_TELEINFO2               1351
#define IDC_TXT_TELEINFO3               1352
#define IDC_TXT_TELEINFO4               1353
#define IDC_TXT_TELEINFO5               1354
#define IDC_TXT_TELEINFO6               1355
#define IDC_TXT_TELEINFO7               1356
#define IDD_CH_SHIPPING_ADDRESS         1400
#define IDD_SHIPPING_ADDRESS            1400
#define IDC_TXT_SHIP_PHONE              1403
#define IDC_TXT_SHIP_EMAIL              1404
#define IDD_LICENSETYPE                 1500
#define IDC_RD_REG_SELECT               1501
#define IDC_RD_REG_MOLP                 1502
#define IDC_RD_REG_OTHER                1503
#define IDD_CH_REGISTER_SELECT          1600
#define IDC_TXT_ENROLLMENT_NUMBER       1603
#define IDD_CH_REGISTER_MOLP            1700
#define IDC_TXT_CUSTOMER_NAME           1701
#define IDC_TXT_AUTH_NUMBER             1702
#define IDC_TXT_AGREEMENT_NUMBER        1703
#define IDC_TXT_MAILING_ADDRESS4        1710
#define IDC_TXT_MAILING_ADDRESS3        1711
#define IDC_CMD_PRODUCT_TYPE            1716
#define IDC_TXT_QUANTITY                1717
#define IDD_CH_REGISTER_OTHER           1800
#define IDC_CMB_LOCATION                1801
#define IDC_CHK_SHIPPING_ADDRESS        1802
#define IDC_TXT_LNAME                   1803
#define IDC_TXT_FNAME                   1804
#define IDC_TXT_PHONE_NUMBER            1805
#define IDC_TXT_EMAIL_ADDRESS           1806
#define IDC_TXT_MAILING_ADDRESS         1807
#define IDC_TXT_MAILING_ADDRESS2        1808
#define IDC_TXT_MAILING_ADDRESS5        1809
#define IDC_TXT_CITY                    1810
#define IDC_TXT_STATE_PROVINCE          1811
#define IDC_TXT_COUNTRY                 1812
#define IDC_TXT_POSTAL_CODE             1813
#define IDC_CMB_DRIVE_SELECT            1901
#define IDC_MESSAGE                     1902
#define IDC_RETAILSPK1                  1910
#define IDC_RETAILSPK2                  1911
#define IDC_RETAILSPK3                  1912
#define IDC_RETAILSPK4                  1913
#define IDC_RETAILSPK5                  1914
#define IDC_CH_PRODUCT_VERSION          1915
#define IDD_DLG_PHONEINFO               5004
#define IDD_DLG_WWWLKP                  5004
#define IDD_PROGRESS                    5005
#define IDD_CONTACTINFO1                5006
#define IDD_CONTACTINFO2                5007
#define IDD_DLG_CUSTOMERINFO_a          5008
#define IDD_DLG_PROP_CUSTINFO_a         5008
#define IDD_DLG_CUSTOMERINFO_b          5009
#define IDD_DLG_PROP_CUSTINFO_b         5009
#define IDD_SHIPPING_ADDRESS_a          5010
#define IDD_SHIPPING_ADDRESS_b          5011
#define IDD_AUTHENTICATE                5013
#define IDB_CLIENT_CONN                 5014
#define IDB_CLIENT_CONN_HDR             5015
#define IDB_LIC_REGISTR                 5016
#define IDB_LIC_REGISTR_HDR             5018
#define IDD_CONFIRM_EMAIL               5020
#define IDD_DLG_PIN                     5025
#define IDD_DLG_GETREGMODE              5026
#define IDD_DLG_TELREG                  5027
#define IDD_DLG_RETAILSPK               5028
#define IDD_DLG_OPERATIONS              5029
#define IDD_DLG_CERTLOG_INFO            5030
#define IDD_DLG_CONFREVOKE              5031
#define IDD_DLG_TELREG_REISSUE          5032
#define IDD_DLG_COUNTRYREGION           5033
#define IDD_EDIT_RETAILSPK              5034
#define IDD_DLG_WWWREG                  5035
#define IDD_DLG_TELLKP1                 5036
#define IDD_DLG_TELLKP                  5036
#define IDD_CONTINUEREG                 5049
#define IDD_DIALOG1                     5050
#define IDD_CONTINUEREGFAX              5050
#define IDD_DLG_PROP_PROGRAM            5051
#define IDD_CH_REGISTER                 5052
#define IDD_PROGRESS2                   5054
#define IDD_DLG_WWW_REISSUE             5055
#define IDD_DLG_WWWREG_REISSUE          5055
#define IDD_WELCOME_KEY_PACKS           5056
#define IDD_WELCOME                     5057
#define IDD_WELCOME_ACTIVATION          5058
#define IDD_WELCOME_CLIENT_LICENSING    5059
#define IDD_WELCOME_REACTIVATION        5060
#define IDD_DLG_ENTER_LIC               5061
#define IDS_REG_ERR_AX00001             10001
#define IDS_REG_ERR_AX00002             10002
#define IDS_REG_ERR_AX00003             10003
#define IDS_REG_ERR_AX00004             10004
#define IDS_REG_ERR_AX00005             10005
#define IDS_REG_ERR_AX00006             10006
#define IDS_REG_ERR_RG00001             20001
#define IDS_REG_ERR_RG00002             20002
#define IDS_REG_ERR_RG00003             20003
#define IDS_REG_ERR_RG00004             20004
#define IDS_REG_ERR_RG00005             20005
#define IDS_REG_ERR_RG00006             20006
#define IDS_REG_ERR_RG00007             20007
#define IDS_REG_ERR_RG00008             20008
#define IDS_REG_ERR_RG00009             20009
#define IDS_REG_ERR_RG00010             20010
#define IDS_REG_ERR_RG00011             20011
#define IDS_REG_ERR_RG00012             20012
#define IDS_REG_ERR_RG00013             20013
#define IDS_REG_ERR_RG00014             20014
#define IDS_REG_ERR_RG00020             20020
#define IDS_ERROR_CONTACTING_CH         20021
#define IDS_REG_ERR_RG00024             20024
#define IDS_REG_ERR_RG00025             20025
#define IDS_REG_ERR_RG00027             20027
#define IDS_REG_ERR_RG00028             20028
#define IDS_REG_ERR_RG00029             20029
#define IDS_REG_ERR_RG00030             20030
#define IDS_REG_ERR_RG00041             20041
#define IDS_REG_ERR_RG00042             20042
#define IDS_REG_ERR_RG00043             20043
#define IDS_REG_ERR_RG00044             20044
#define IDS_REG_ERR_RG00045             20045
#define IDS_REG_ERR_RG00046             20046
#define IDS_REG_ERR_RG00047             20047
#define IDS_REG_ERR_RG00048             20048
#define IDS_REG_ERR_RG00049             20049
#define IDS_REG_ERR_RG00050             20050
#define IDS_TITLE1                      20051
#define IDS_TITLE2                      20053
#define IDS_TITLE3                      20054
#define IDS_LARGEFONTNAME               20055
#define IDS_LARGEFONTSIZE               20056
#define IDS_TITLE4                      20057
#define IDS_TITLE5                      20058
#define IDS_TITLE6                      20059
#define IDS_LS_NOT_REGISTERED           20060
#define IDS_LBL_EMAIL_ONLINE            20061
#define IDS_LBL_EMAIL_OFFLINE           20062
#define IDS_TITLE7                      20063
#define IDS_TITLE8                      20064
#define IDS_TITLE9                      20065
#define IDS_TITLE10                     20066
#define IDS_TITLE11                     20067
#define IDS_TITLE12                     20068
#define IDS_TITLE13                     20069
#define IDS_TITLE14                     20070
#define IDS_TITLE15                     20071
#define IDS_TITLE16                     20072
#define IDS_ERR_CREATE_FAILED           20073
#define IDS_ERR_LSCONNECT_FAILED        20074
#define IDS_ERR_RPC_FAILED              20075
#define IDS_ERR_NO_CERT                 20076
#define IDS_ERR_LS_ERROR                20077
#define IDS_ERR_CRYPT_ERROR             20078
#define IDS_ERR_OUTOFMEM                20079
#define IDS_ERR_CH_ERROR                20080
#define IDS_ERR_REGCONNECT_FAILD        20081
#define IDS_ERR_REGCREATE_FAILED        20082
#define IDS_ERR_CHCERTKEY_EMPTY         20083
#define IDS_ERR_CHURLKEY_EMPTY          20084
#define IDS_ERR_RAURLKEY_EMPTY          20085
#define IDS_ERR_CERT_DEPOSIT_LSERROR    20087
#define IDS_ERR_CERT_DEPOSIT_RPCERROR   20088
#define IDS_ERR_RPC_ERROR               20089
#define IDS_ERR_LSKEY_IMPORT_FAILED     20090
#define IDS_ERR_FIELD_EMPTY             20092
#define IDS_ERR_INVALID_CHAR            20093
#define IDS_ERR_INVALID_EMAIL           20094
#define IDS_ERR_DRIVE_LOAD_FAILED       20097
#define IDS_TITLE17                     20098
#define IDS_ERR_INVALID_OP              20099
#define IDS_ERR_EXCEPTION               20100
#define IDS_ERR_RA_ERROR                20101
#define IDS_ERR_INVALID_PIN             20102
#define IDS_ERR_SELECT_DRIVE            20103
#define IDS_ERR_MFG_READ_FAILED         20104
#define IDS_ERR_DEPOSIT_LKP_FAILED      20105
#define IDS_ERR_WRITE_FILE_FAILED       20106
#define IDS_ERR_CHDISK_READ_FAILED      20107
#define IDS_ERR_EXCHG_READ_FAILED       20108
#define IDS_ERR_SIGCERT_READ_FAILED     20109
#define IDS_ERR_ROOTCERT_READ_FAILED    20110
#define IDS_ERR_CHEXCHG_READ_FAILED     20111
#define IDS_ERR_CHSIG_READ_FAILED       20112
#define IDS_ERR_CHROOT_READ_FAILED      20113
#define IDS_MSG_PROCESSING              20114
#define IDS_ERR_EMPTY_RES_FILE          20115
#define IDS_MSG_CR_SUBMITTED            20116
#define IDS_MSG_LKP_PROCESSED           20117
#define IDS_MSG_CERT_INSTALLED          20118
#define IDS_MSG_CR_CREATED              20119
#define IDS_MSG_LR_CREATED              20120
#define IDS_SUBTITLE1                   20121
#define IDS_SUBTITLE2                   20122
#define IDS_SUBTITLE3                   20123
#define IDS_SUBTITLE4                   20124
#define IDS_SUBTITLE5                   20125
#define IDS_SUBTITLE6                   20126
#define IDS_SUBTITLE7                   20127
#define IDS_SUBTITLE8                   20128
#define IDS_SUBTITLE9                   20129
#define IDS_SUBTITLE10                  20130
#define IDS_SUBTITLE11                  20131
#define IDS_SUBTITLE12                  20132
#define IDS_SUBTITLE13                  20133
#define IDS_SUBTITLE14                  20134
#define IDS_SUBTITLE15                  20135
#define IDS_SUBTITLE16                  20136
#define IDS_SUBTITLE17                  20137
#define IDS_MSG_AUTHENTICATING          20138
#define IDS_TITLE18                     20139
#define IDS_SUBTITLE18                  20140
#define IDS_MSG_AUTHENTICATE            20141
#define IDS_MSG_PROCESS                 20142
#define IDS_ERR_AUTH_FAILED             20143
#define IDS_ERR_CHEXT_NOT_FOUND         20144
#define IDS_ERR_LSRAEXT_NOT_FOUND       20145
#define IDS_ERR_LKPREQ_FAILED           20146
#define IDS_ERR_CERTREQ_FAILED          20147
#define IDS_LBL_CONTACT_ONLINE          20148
#define IDS_LBL_CONTACT_OFFLINE         20149
#define IDS_ERR_CERT_NOT_ENOUGH         20150
#define IDS_LSNAME                      20151
#define IDS_ERR_INVALID_QTY             20152
#define IDS_ERR_DUPLICATE_LKP           20153
#define IDS_EMAIL_MISMATCH              20154
#define IDS_ERR_INVALID_CERT_CHAIN      20155
#define IDS_ERR_BAD_MFGBLOB             20156
#define IDS_TITLE19                     20157
#define IDS_SUBTITLE19                  20158
#define IDS_ERR_LCONNECTTRUST_FAILED    20163
#define IDS_ERR_INVALIDLENGTH           20164
#define IDS_TITLE20                     20165
#define IDS_SUBTITLE20                  20166
#define IDS_ERR_NOLSID                  20167
#define IDS_ERR_DEPOSITSPK              20168
#define IDS_TITLE21                     20169
#define IDS_SUBTITLE21                  20170
#define IDS_ERR_DEPOSITLKP              20171
#define IDS_TITLE22                     20172
#define IDS_SUBTITLE22                  20173
#define IDS_IDS_ERR_CONNECTFAILED       20174
#define IDS_RETAIL_HEADERSPK            20175
#define IDS_RETAIL_HEADERSTATUS         20176
#define IDS_RETAILSPKSTATUS_PENDING     20177
#define IDS_RETAILSPKSTATUS_UNKNOWN     20178
#define IDS_ERR_INVALIDSPK              20179
#define IDS_ERR_DUPLICATESPK            20180
#define IDS_TITLE23                     20181
#define IDS_SUBTITLE23                  20182
#define IDS_ERR_SEND_FAILED             20183
#define IDS_ERR_CHFETCHRESPONSE         20184
#define IDS_ERR_CHBAD_DATA              20185
#define IDS_ERR_SPKERRORS               20186
#define IDS_RETAILSPKSTATUS_OK          20187
#define IDS_RETAILSPKSTATUS_INVALID_SIGNATURE 20188
#define IDS_RETAILSPKSTATUS_INVALID_PRODUCT_TYPE 20189
#define IDS_RETAILSPKSTATUS_INVALID_SERIAL_NUMBER 20190
#define IDS_RETAILSPKSTATUS_ALREADY_REGISTERED 20191
#define IDS_ERR_CHSERVER_PROBLEM        20192
#define IDS_ERR_CHINVALID_DATA          20193
#define IDS_ERR_CHFAILURE               20194
#define IDS_ERR_CHNOT_IMPLEMENTED       20195
#define IDS_MSG_CERT_REVOKED            20196
#define IDS_MSG_REVOKECERT              20197
#define IDS_MSG_CERT_REISSUED           20198
#define IDS_TITLE24                     20199
#define IDS_SUBTITLE24                  20200
#define IDS_TITLE25                     20201
#define IDS_SUBTITLE25                  20202
#define IDS_TITLE26                     20203
#define IDS_SUBTITLE26                  20204
#define IDS_ERR_INVALID_CONFIRMATION_NUMBER 20205
#define IDS_ERR_INVALID_SPK             20206
#define IDS_TITLE27                     20207
#define IDS_SUBTITLE27                  20208
#define IDS_COUNTRYREGION_HEADER        20209
#define IDS_CSNUMBER_HEADER             20210
#define IDS_DUPLICATESPK                20210
#define IDS_NOSPKSTOPROCESS             20211
#define IDS_ERR_INVALIDID               20212
#define IDS_ERR_TOOMANYSPK              20213
#define IDS_ERR_NOCOUNTRYSELECTED       20214
#define IDS_MSG_LSIDACCEPTED            20215
#define IDS_ERR_CERTBAD                 20216
#define IDS_ERR_CERTREVOKED             20217
#define IDS_ERR_CERTEXPIRED             20218
#define IDS_ERR_SPKBAD                  20219
#define IDS_ERR_REGERROR                20220
#define IDS_MSG_REQUEST_LKP_NOW         20221
#define IDS_WWWMODE                     20222
#define IDS_INTERNET_DESC               20223
#define IDS_TELEPHONE_DESC              20224
#define IDS_WWW_DESC                    20225
#define IDS_TITLE28                     20226
#define IDS_SUBTITLE28                  20227
#define IDS_TITLE29                     20228
#define IDS_SUBTITLE29                  20229
#define IDS_WWWINFO                     20230
#define IDS_MSG_WWWREG_SUCCESS          20231
#define IDS_AGREEMENT_SELECT            20236
#define IDS_AGREEMENT_MOLP              20237
#define IDS_AGREEMENT_OTHER             20238
#define IDS_TO                          20242
#define IDS_FAX                         20243
#define IDS_DATE                        20244
#define IDS_PAGES                       20245
#define IDS_RETURN_FAX                  20246
#define IDS_COMMENT1                    20247
#define IDS_REQUEST                     20248
#define IDS_AGREEMENT                   20249
#define IDS_PRODUCT_ID                  20250
#define IDS_LSID                        20251
#define IDS_FIRST_NAME                  20252
#define IDS_LAST_NAME                   20253
#define IDS_COMPANY                     20254
#define IDS_ORGUNIT                     20255
#define IDS_ADDRESS                     20256
#define IDS_CITY                        20257
#define IDS_STATE                       20258
#define IDS_ZIP                         20259
#define IDS_COUNTRY                     20260
#define IDS_PHONE_NUMBER                20261
#define IDS_EMAIL_ADDRESS               20262
#define IDS_LIC_TYPE                    20263
#define IDS_QUANTITY                    20264
#define IDS_ENROLL                      20265
#define IDS_AUTH                        20266
#define IDS_LIC                         20267
#define IDS_LIC_CODES                   20268
#define IDS_FAX_TO                      20269
#define IDS_TITLE30                     20270
#define IDS_SUBTITLE30                  20271
#define IDS_TITLE31                     20272
#define IDS_SUBTITLE31                  20273
#define IDS_MSG_CONTINUEREGISTRATION    20274
#define IDS_MSG_UNREGISTERED            20275
#define IDS_MSG_DOWNLOADLKP             20276
#define IDS_MSG_CBOX_CONTREGISTRATION   20277
#define IDS_COUNTRYREGION_HEADER2       20277
#define IDS_MSG_CBOX_OBTAINLKPS         20278
#define IDS_TITLE36                     20278
#define IDS_MSG_REREGISTRATION          20279
#define IDS_MSG_UNREGISTRATION          20280
#define IDS_FINALFAILMESSAGE            20281
#define IDS_ALTFINISHTEXT               20282
#define IDS_TITLE37                     20283
#define IDS_TITLE38                     20284
#define IDS_TITLE39                     20285
#define IDS_MSG_DOWNLOADLASTLKP         20286
#define IDS_FINALSUCCESSMESSAGE         20287
#define IDS_FAX_LABEL                   20288
#define IDS_FAXOPTION_LABEL             20289
#define IDS_EMAIL_LABEL                 20292
#define IDS_EMAILOPTION_LABEL           20293
#define IDS_ERR_INVALIDLSID             20294
#define IDS_ERR_INVALID_PROGINFO        20295
#define IDS_SELECT_DESCRIPTION          20296
#define IDS_OPEN_DESCRIPTION            20297
#define IDS_OTHER_DESCRIPTION           20298
#define IDS_ERR_REQ_FIELD_EMPTY         20299
#define IDS_INTERNET_CONNECTION_DESC    20300
#define IDS_INTERNET_CONNECTION_REQ     20301
#define IDS_INTERNET_CONNECTION_WHEN    20302
#define IDS_CONNECTION_DESC_HEADER      20303
#define IDS_CONNECTION_REQ_HEADER       20304
#define IDS_CONNECTION_WHEN_HEADER      20305
#define IDS_WWW_CONNECTION_DESC         20306
#define IDS_WWW_CONNECTION_REQ          20307
#define IDS_WWW_CONNECTION_WHEN         20308
#define IDS_PHONE_CONNECTION_DESC       20309
#define IDS_PHONE_CONNECTION_REQ        20310
#define IDS_PHONE_CONNECTION_WHEN       20311
#define IDS_PROGRAM_LICENSE_PAK         20312
#define IDS_PROGRAM_OPEN_LICENSE        20313
#define IDS_PROGRAM_SELECT              20314
#define IDS_PROGRAM_ENTERPRISE          20315
#define IDS_PROGRAM_CAMPUS_AGREEMENT    20316
#define IDS_PROGRAM_SCHOOL_AGREEMENT    20317
#define IDS_PROGRAM_APP_SERVICES_AGREEMENT 20318
#define IDS_PROGRAM_OTHER               20319
#define IDS_PROGRAM_LICENSE_PAK_DESC    20320
#define IDS_PROGRAM_LICENSE_PAK_REQ     20321
#define IDS_PROGRAM_LICENSE_PAK_FORMAT  20322
#define IDS_PROGRAM_OPEN_LICENSE_DESC   20323
#define IDS_PROGRAM_OPEN_LICENSE_REQ    20324
#define IDS_PROGRAM_OPEN_LICENSE_FORMAT 20325
#define IDS_PROGRAM_SECECT_DESC         20326
#define IDS_PROGRAM_SELECT_DESC         20326
#define IDS_PROGRAM_SECECT_REQ          20327
#define IDS_PROGRAM_SELECT_REQ          20327
#define IDS_PROGRAM_SECECT_FORMAT       20328
#define IDS_PROGRAM_ENTERPRISE_DESC     20329
#define IDS_PROGRAM_ENTERPRISE_REQ      20330
#define IDS_PROGRAM_ENTERPRISE_FORMAT   20331
#define IDS_PROGRAM_CAMPUS_DESC         20332
#define IDS_PROGRAM_CAMPUS_REQ          20333
#define IDS_PROGRAM_CAMPUS_FORMAT       20334
#define IDS_PROGRAM_SCHOOL_DESC         20335
#define IDS_PROGRAM_SCHOOL_REQ          20336
#define IDS_PROGRAM_SCHOOL_FORMAT       20337
#define IDS_PROGRAM_APP_SERVICES_DESC   20338
#define IDS_PROGRAM_APP_SERVICES_REQ    20339
#define IDS_PROGRAM_APP_SERVICES_FORMAT 20340
#define IDS_PROGRAM_OTHER_DESC          20341
#define IDS_PROGRAM_OTHER_REQ           20342
#define IDS_PROGRAM_OTHER_FORMAT        20343
#define IDS_PROGRAM_STATUS_BOX_SMALL    20344
#define IDS_PROGRAM_STATUS_BOX_BIG_1    20345
#define IDS_PROGRAM_STATUS_BOX_BIG_2    20346
#define IDS_PROGRAM_STATUS_BOX_SINGLE   20347
#define IDS_SEND_FAILED_NO_CONN         20348
#define IDS_SEND_FAILED_NO_NIC          20349
#define IDS_SEND_FAILED_NO_OTHER        20350
#define IDS_WWW_BROWSER_LAUNCH_ERROR    20351
#define IDS_WIZARD_MESSAGE_TITLE        20352
#define IDS_CH_LICENSE_NUMBERS          20353
#define IDS_CH_LICENSE_NUMBER           20354
#define IDS_PRODUCT_TYPE_EXP_W2K_CLIENT 20355
#define IDS_PRODUCT_TYPE_EXP_W2K_IC     20356
#define IDS_PRODUCT_TYPE_EXP_WHISTLER_PER_SEAT 20357
#define IDS_PRODUCT_TYPE_EXP_WHISTLER_PER_USER 20358
#define IDS_FINALREACTIVATIONSUCCESSMESSAGE 20359
#define IDS_PRODUCT_TYPE                20360
#define IDS_FINALSUCCESSMESSAGE2        20361
#define IDS_PROPERTIES_TITLE            20362
#define IDS_KEY_PACKS_WELCOME           20363
#define IDS_ACTIVATION_WELCOME          20364
#define IDS_OTHER_WELCOME               20365
#define IDS_KEY_PACKS_TITLE             20366
#define IDS_ACTIVATION_TITLE            20367
#define IDS_REACTIVATION_TITLE          20368
#define IDS_OTHER_TITLE                 20369
#define IDS_WIN2K_PERSEAT               20370
#define IDS_WIN2K_INTERNET              20371
#define IDS_WHISTLER_PERUSER            20372
#define IDS_WHISTLER_PERSEAT            20373
#define IDS_UNKNOWN_PRODUCTTYPE         20374
#define IDS_ACTIVATION_COMPLETION_MESSAGE 20375
#define IDS_KEY_PACKS_COMPLETION_MESSAGE 20376
#define IDS_REACTIVATION_COMPLETION_WIZARD 20377
#define IDS_FINAL_KEYPACK_SUCCESS_MESSAGE 20378
#define IDS_FINAL_REACTIVATION_SUCCESS  20379
#define IDS_INSTALLED_WIN2K_CLIENT_ACCESS 20380
#define IDS_INSTALLED_WIN2K_INTERNET_CONNECTOR 20381
#define IDS_INSTALLED_WHISTLER_PER_SEAT 20382
#define IDS_INSTALLED_WHISTLER_PER_USER 20383
#define IDS_PRODUCT_VERSION_W2K         20384
#define IDS_PRODUCT_VERSION_WHISTLER    20385
#define IDS_ENTER_LICENSE_WIZARD_SUBHEADER 20386
#define IDS_ENTER_LICENSE_WIZARD_HEADER 20387
#define IDS_CALWIZ_TITLE                20388

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5062
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1161
#define _APS_NEXT_SYMED_VALUE           201
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\sequenceranges.h ===
#ifndef _SEQUENCERANGES_H_
#define _SEQUENCERANGES_H_

#define RANGE_SIZE				7
#define W2KCAL					_TEXT("001")
#define ICL						_TEXT("002")
#define PERSESS					_TEXT("003")
#define XPCAL					_TEXT("004")

typedef struct _PRODUCTTYPE_RANGE
{
	DWORD dwRangeStart;
	DWORD dwRangeEnd;
	TCHAR * szProductType;

} PRODUCTTYPE_RANGE, *PPRODUCTTYPE_RANGE;

//When you adjust the ranges make sure you update the RANGE_SIZE define
const PRODUCTTYPE_RANGE g_ProductTypeRanges[RANGE_SIZE] = 
		{	
			{15059000,15091019,W2KCAL}, 
			{17000000,18999999,W2KCAL}, 
			{50000000,99999999,W2KCAL},
			{100000000,139999999,XPCAL},
			{150000000,189999999,PERSESS},
			{19000000,19999999,PERSESS},
			{20000000,20999999,XPCAL}
		};

#endif	//_SEQUENCERANGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\telrproc.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include <assert.h>
#include "precomp.h"

void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;

LRW_DLG_INT CALLBACK 
TelRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	DWORD   dwReturn;
	HWND    hwndLSID;
	TCHAR * cwLicenseServerID;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
		break ;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwLicenseServerID = GetLicenseServerID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_LICENSESERVER_ID);
				SetWindowText(hwndLSID, cwLicenseServerID);
				SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
				{
					// Extraneous characters in the SPK string
					LRMessageBox(hwnd, IDS_ERR_INVALIDLSID,IDS_WIZARD_MESSAGE_TITLE);
					dwNextPage = IDD_DLG_TELREG;
				}
				else 
				{
					dwReturn = GetGlobalContext()->SetLSSPK(tcUserValue);
					if (dwReturn != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd, dwReturn, NULL, LRGetLastError());
						dwNextPage = IDD_DLG_TELREG;
					}
					else
					{
						dwReturn = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_TELREG);
					}
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\telproc.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include <assert.h>
#include "precomp.h"


static int iDeleteKeyStatus = 0;


void SetDeleteKeyStatus(int iValue)
{
	iDeleteKeyStatus = iValue;
}

int GetDeleteKeyStatus(void) 
{
	return iDeleteKeyStatus ;
}


void MoveCaret(int nID, HWND  hwnd )
{
	POINT Pt;
	int iCaretIndex  ;
	DWORD	dwNext = 0;	
	TCHAR tcUserValue[ CHARS_IN_BATCH + 1];
	DWORD dwLen ;


	GetCaretPos(&Pt); 
	iCaretIndex = (int) SendMessage(GetDlgItem(hwnd,nID), EM_CHARFROMPOS, 0, MAKELPARAM(Pt.x, Pt.y));

	GetDlgItemText(hwnd,nID, tcUserValue, CHARS_IN_BATCH+1);
	dwLen = _tcslen(tcUserValue);

	switch(iCaretIndex)
	{

	case 0: //Move to left edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_TXT_TELEINFO2:		
				dwNext = IDC_TXT_TELEINFO1;
			break ;

			case IDC_TXT_TELEINFO3:		
				dwNext = IDC_TXT_TELEINFO2;
			break ;


			case IDC_TXT_TELEINFO4:		
				dwNext = IDC_TXT_TELEINFO3;
			break ;

			case IDC_TXT_TELEINFO5:		
				dwNext = IDC_TXT_TELEINFO4;
			break ;

			case IDC_TXT_TELEINFO6:
				dwNext = IDC_TXT_TELEINFO5;
			break ;

			case IDC_TXT_TELEINFO7:		
				dwNext = IDC_TXT_TELEINFO6;
			break ;
		}
		


		if (dwNext != -1 && dwLen == 0 && GetDeleteKeyStatus() == 0)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_END,0);
		}
		break;

	case 5: //Move to right edit box
		dwNext = -1 ;
		switch(nID)
		{
			case IDC_TXT_TELEINFO1:		
				dwNext = IDC_TXT_TELEINFO2;
			break ;

			case IDC_TXT_TELEINFO2:		
				dwNext = IDC_TXT_TELEINFO3;
			break ;

			case IDC_TXT_TELEINFO3:
				dwNext = IDC_TXT_TELEINFO4;
			break ;

			case IDC_TXT_TELEINFO4:
				dwNext = IDC_TXT_TELEINFO5;
			break ;

			case IDC_TXT_TELEINFO5:
				dwNext = IDC_TXT_TELEINFO6;
			break ;

			case IDC_TXT_TELEINFO6:
				dwNext = IDC_TXT_TELEINFO7;
			break ;
		}

		if (dwNext != -1)
		{
			SetFocus(GetDlgItem(hwnd, dwNext));
			SendMessage(GetDlgItem(hwnd,dwNext),WM_KEYDOWN, VK_HOME,0);
		}
		break;
	}

}


LRW_DLG_INT CALLBACK 
TelLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE; 
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	DWORD dwRetCode;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );

        // Now set the Limit of the data entry fields
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));
		break;


	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}

		
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwRegistrationID = GetGlobalContext()->GetRegistrationID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_MSID);
				swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
						 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
						 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
						 cwRegistrationID + 30);
			
				SetWindowText(hwndLSID, awBuffer);
				SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				dwRetCode = SetLSLKP(tcUserValue);
				if (dwRetCode != ERROR_SUCCESS)
				{
					LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);	
					dwNextPage = IDD_DLG_TELLKP;
				}
				else 
				{
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_DLG_TELLKP);
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\welcome.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include <assert.h>
#include "fonts.h"

static DWORD    g_dwAuthRetCode = ERROR_SUCCESS;

DWORD WINAPI AuthThread(void *pData);


LRW_DLG_INT CALLBACK 
AuthProc(
        IN HWND     hwnd,   
        IN UINT     uMsg,       
        IN WPARAM   wParam, 
        IN LPARAM   lParam  
        );

DWORD WINAPI AuthThread(void *pData)
{
    g_dwAuthRetCode = AuthenticateLS(); 

    ExitThread(0);

    return 0;
}

DWORD DetermineWelcomePage()
{
    switch (GetGlobalContext()->GetWizAction()) {
    case (WIZACTION_REGISTERLS):    
    case (WIZACTION_CONTINUEREGISTERLS):    
        {
            return IDD_WELCOME_ACTIVATION;
            break;
        }
    case (WIZACTION_DOWNLOADLKP):    
    case (WIZACTION_DOWNLOADLASTLKP):    
        {
            return IDD_WELCOME_CLIENT_LICENSING;
            break;
        }
    case (WIZACTION_REREGISTERLS):    
        {
            return IDD_WELCOME_REACTIVATION;
            break;
        }
    default:
        {
            return IDD_WELCOME;
            break;
        }
    }

    return IDD_WELCOME;
}

void DisplayAboutTSLicensingHelp()
{
    TCHAR * pHtml = L"ts_lice_c_015.htm";

    HtmlHelp(AfxGetMainWnd()->m_hWnd, L"tslic.chm", HH_DISPLAY_TOPIC,(DWORD_PTR)pHtml);
}

//
// Simple Welcome dialogs
//
LRW_DLG_INT SimpleWelcomeDlgProc(IN HWND     hwnd,  
                                 IN UINT     uMsg,        
                                 IN WPARAM   wParam,  
                                 IN LPARAM   lParam)
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    DWORD   dwNextPage = 0; 
    BOOL    bStatus = TRUE;

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) {
    case WM_INITDIALOG:

        TCHAR   szMsg[LR_MAX_MSG_TEXT];
        TCHAR   szWelcomeTitle[LR_MAX_MSG_TEXT];

        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

        SetControlFont( pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);      
        GetGlobalContext()->ClearWizStack();

        switch (GetGlobalContext()->GetWizAction()) {
        case WIZACTION_REGISTERLS:
            LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTERED,
                       szMsg,LR_MAX_MSG_TEXT);
            LoadString(GetInstanceHandle(), IDS_ACTIVATION_WELCOME,
                       szWelcomeTitle, LR_MAX_MSG_TEXT);
            break;

        case WIZACTION_CONTINUEREGISTERLS:
            LoadString(GetInstanceHandle(), IDS_MSG_CONTINUEREGISTRATION,
                       szMsg,LR_MAX_MSG_TEXT);
            LoadString(GetInstanceHandle(), IDS_OTHER_WELCOME, szWelcomeTitle,
                       LR_MAX_MSG_TEXT);
            break;

        }
        SetDlgItemText(hwnd, IDC_BIGBOLDTITLE, szWelcomeTitle);
        SetDlgItemText(hwnd, IDC_BOLDTITLE, szMsg);


        AddHyperLinkToStaticCtl(hwnd, IDC_HYPERLINK_MOREINFO);
        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch ( pnmh->code ) {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:

                if ( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
                    break;

                // else fall through

            case NM_RETURN: 
            case NM_CLICK:
                DisplayAboutTSLicensingHelp();
                break;

            case PSN_SETACTIVE:                
                {
                    TCHAR   szMsg[LR_MAX_MSG_TEXT];
                    TCHAR   szWelcomeTitle[LR_MAX_MSG_TEXT];

                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT );

                    LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTERED, szMsg,LR_MAX_MSG_TEXT);
                    LoadString(GetInstanceHandle(), IDS_ACTIVATION_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);

                    SetDlgItemText(hwnd, IDC_BIGBOLDTITLE, szWelcomeTitle);

                    AddHyperLinkToStaticCtl(hwnd, IDC_HYPERLINK_MOREINFO);
                }
                break;

            case PSN_WIZNEXT:
                {
                    dwNextPage = IDD_DLG_GETREGMODE;

                    LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                    if (dwNextPage != DetermineWelcomePage()) {
                        LRPush(DetermineWelcomePage());
                    }
                    bStatus = -1;
                }
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

//
// Complex welcome dlg proc - contains license server settings
//
LRW_DLG_INT ComplexWelcomeDlgProc(IN HWND     hwnd, 
                                  IN UINT     uMsg,        
                                  IN WPARAM   wParam,  
                                  IN LPARAM   lParam)
{
    DWORD   dwRetCode = ERROR_SUCCESS;
    DWORD   dwNextPage = 0; 
    BOOL    bStatus = TRUE;

    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );


    switch (uMsg) {
    case WM_INITDIALOG:
        pi = (PageInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, (LRW_LONG_PTR)pi );        

        SetControlFont( pi->hBigBoldFont, hwnd, IDC_BIGBOLDTITLE);      
        GetGlobalContext()->ClearWizStack();

        if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLKP ||
            GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLASTLKP) {
            AddHyperLinkToStaticCtl(hwnd, IDC_HYPERLINK_MOREINFO);
        } else {
            AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
        }

        break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch ( pnmh->code ) {
            //Trap keystokes/clicks on the hyperlink
            case NM_CHAR:

                if ( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
                    break;

                // else fall through

            case NM_RETURN: 
            case NM_CLICK:
                {
                    //
                    // Figure out which type of help to display based
                    // on the welcome dialog
                    //
                    DWORD dwWizAction = GetGlobalContext()->GetWizAction();
                    if (WIZACTION_DOWNLOADLKP == dwWizAction ||
                        WIZACTION_DOWNLOADLASTLKP == dwWizAction) {
                        DisplayAboutTSLicensingHelp();
                    } else {
                        DisplayPrivacyHelp();
                    }
                }

            case PSN_SETACTIVE:                
                {
                    TCHAR   szMsg[LR_MAX_MSG_TEXT];
                    TCHAR   szWelcomeTitle[LR_MAX_MSG_TEXT];

                    SetDlgItemText(hwnd, IDC_PRODUCTID, GetGlobalContext()->GetLicenseServerID());

                    if (GetGlobalContext()->GetWizAction() != WIZACTION_REGISTERLS &&
                        GetGlobalContext()->GetWizAction() != WIZACTION_CONTINUEREGISTERLS) {
                        SetDlgItemText(hwnd, IDC_COMPANYNAME, GetGlobalContext()->GetContactDataObject()->sCompanyName);                    

                        DWORD dwStringId;
                        dwStringId = 
                        GetStringIDFromProgramName(
                                                  GetGlobalContext()->GetContactDataObject()->sProgramName);
                        LoadString(GetInstanceHandle(), dwStringId, szMsg, LR_MAX_MSG_TEXT);

                        SetDlgItemText(hwnd, IDC_LICENSETYPE, szMsg);

                        if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET) {
                            LoadString(GetInstanceHandle(),IDS_INTERNETMODE,szMsg,LR_MAX_MSG_TEXT);
                            SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
                        }

                        if (GetGlobalContext()->GetActivationMethod() == CONNECTION_WWW) {
                            LoadString(GetInstanceHandle(),IDS_WWWMODE,szMsg,LR_MAX_MSG_TEXT);
                            SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
                        }

                        if (GetGlobalContext()->GetActivationMethod() == CONNECTION_PHONE) {
                            LoadString(GetInstanceHandle(),IDS_TELEPHONEMODE,szMsg,LR_MAX_MSG_TEXT);
                            SetDlgItemText(hwnd, IDC_ACTIVATIONMETHOD, szMsg);
                        }

                    }
                    PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT );

                    switch (GetGlobalContext()->GetWizAction()) {
                    case WIZACTION_DOWNLOADLKP:
                        LoadString(GetInstanceHandle(), IDS_MSG_DOWNLOADLKP, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_KEY_PACKS_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_HYPERLINK_MOREINFO);
                        break;

                    case WIZACTION_REGISTERLS:
                        LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTERED, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_ACTIVATION_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
                        break;

                    case WIZACTION_CONTINUEREGISTERLS:
                        LoadString(GetInstanceHandle(), IDS_MSG_CONTINUEREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_OTHER_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
                        break;

                    case WIZACTION_REREGISTERLS:
                        LoadString(GetInstanceHandle(), IDS_MSG_REREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_REACTIVATION_TITLE, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
                        break;

                    case WIZACTION_UNREGISTERLS:
                        LoadString(GetInstanceHandle(), IDS_MSG_UNREGISTRATION, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_OTHER_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_PRIVACY);
                        break;

                    case WIZACTION_DOWNLOADLASTLKP:
                        LoadString(GetInstanceHandle(), IDS_MSG_DOWNLOADLASTLKP, szMsg,LR_MAX_MSG_TEXT);
                        LoadString(GetInstanceHandle(), IDS_KEY_PACKS_WELCOME, szWelcomeTitle, LR_MAX_MSG_TEXT);
                        AddHyperLinkToStaticCtl(hwnd, IDC_HYPERLINK_MOREINFO);
                        break;
                    }
                    SetDlgItemText(hwnd, IDC_BIGBOLDTITLE, szWelcomeTitle);
                    SetDlgItemText(hwnd, IDC_BOLDTITLE, szMsg);
                }
                break;

            case PSN_WIZNEXT:
                if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLASTLKP) {
                    if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET) {
                        // Solve Bug 610 BEGIN
                        dwRetCode = ShowProgressBox(hwnd, AuthThread, IDS_CALWIZ_TITLE, 0, 0);
                        if (g_dwAuthRetCode == ERROR_SUCCESS) {
                            //Previos code BEGIN
                            dwRetCode = ShowProgressBox(hwnd, ProcessThread, IDS_CALWIZ_TITLE, 0, 0);
                            if (dwRetCode == ERROR_SUCCESS) {
                                dwRetCode = LRGetLastRetCode();
                            }

                            if (dwRetCode != ERROR_SUCCESS) {
                                LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);
                                dwNextPage = DetermineWelcomePage();
                            } else {
                                dwNextPage = IDD_PROGRESS;
                            }
                            //Previous code END
                        } else if (g_dwAuthRetCode == IDS_ERR_SPKBAD ||
                                   g_dwAuthRetCode == IDS_ERR_CERTREVOKED) {
                            TCHAR   szMsg[LR_MAX_MSG_TEXT];
                            TCHAR   szCaption[LR_MAX_MSG_CAPTION];  

                            LoadString(GetInstanceHandle(),g_dwAuthRetCode, szMsg,LR_MAX_MSG_TEXT);
                            LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);

                            if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES) {
                                SetCursor(LoadCursor(NULL,IDC_WAIT));
                                g_dwAuthRetCode = ResetLSSPK();
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                if (g_dwAuthRetCode == ERROR_SUCCESS) {
                                    // Start all over again
                                    GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
                                    GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
                                    GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
                                    GetGlobalContext()->ClearWizStack();
                                    dwNextPage = DetermineWelcomePage();
                                } else {
                                    LRMessageBox(hwnd,g_dwAuthRetCode,NULL,LRGetLastError());
                                    dwNextPage = DetermineWelcomePage();
                                }
                            } else {
                                dwNextPage = DetermineWelcomePage();
                            }
                        } else if (g_dwAuthRetCode == IDS_ERR_CERTBAD ||
                                   g_dwAuthRetCode == IDS_ERR_CERTEXPIRED) {
                            TCHAR   szMsg[LR_MAX_MSG_TEXT];
                            TCHAR   szCaption[LR_MAX_MSG_CAPTION];  

                            LoadString(GetInstanceHandle(), g_dwAuthRetCode, szMsg, LR_MAX_MSG_TEXT);
                            LoadString(GetInstanceHandle(), IDS_TITLE, szCaption, LR_MAX_MSG_CAPTION);

                            if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES) {
                                // Go to Reissue Cert
                                GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
                                GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
                                GetGlobalContext()->SetWizAction(WIZACTION_REREGISTERLS);
                                dwNextPage = IDD_DLG_CERTLOG_INFO;
                            } else {
                                dwNextPage = DetermineWelcomePage();
                            }
                        } else {
                            LRMessageBox(hwnd,g_dwAuthRetCode,NULL,LRGetLastError());
                            dwNextPage = DetermineWelcomePage();
                        }
                    } else {
                        dwNextPage = GetGlobalContext()->GetEntryPoint();
                    }
                    // Solve Bug 610 END
                } else if (GetGlobalContext()->GetWizAction() == WIZACTION_REGISTERLS) {
                    dwNextPage = IDD_DLG_GETREGMODE;
                } else if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLKP ||
                           GetGlobalContext()->GetWizAction() == WIZACTION_UNREGISTERLS ||
                           GetGlobalContext()->GetWizAction() == WIZACTION_REREGISTERLS) {
                    if (GetGlobalContext()->GetActivationMethod() == CONNECTION_INTERNET) {
                        BOOL fIsCalWizard = FALSE;
                        if (GetGlobalContext()->GetWizAction() == WIZACTION_DOWNLOADLKP) {
                            fIsCalWizard = TRUE;
                        }

                        dwRetCode = ShowProgressBox(hwnd, AuthThread,
                                                    fIsCalWizard ? IDS_CALWIZ_TITLE : 0, 0, 0);
                        if (g_dwAuthRetCode == ERROR_SUCCESS) {
                            dwNextPage = GetGlobalContext()->GetEntryPoint();
                        } else if (g_dwAuthRetCode == IDS_ERR_SPKBAD ||
                                   g_dwAuthRetCode == IDS_ERR_CERTREVOKED) {
                            TCHAR   szMsg[LR_MAX_MSG_TEXT];
                            TCHAR   szCaption[LR_MAX_MSG_CAPTION];  

                            LoadString(GetInstanceHandle(),g_dwAuthRetCode, szMsg,LR_MAX_MSG_TEXT);
                            LoadString(GetInstanceHandle(),IDS_TITLE,szCaption,LR_MAX_MSG_CAPTION);

                            if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES) {
                                SetCursor(LoadCursor(NULL,IDC_WAIT));
                                g_dwAuthRetCode = ResetLSSPK();
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                if (g_dwAuthRetCode == ERROR_SUCCESS) {
                                    // Start all over again
                                    GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
                                    GetGlobalContext()->SetLSStatus(LSERVERSTATUS_UNREGISTER);
                                    GetGlobalContext()->SetWizAction(WIZACTION_REGISTERLS);
                                    GetGlobalContext()->ClearWizStack();
                                    dwNextPage = DetermineWelcomePage();
                                } else {
                                    LRMessageBox(hwnd,g_dwAuthRetCode,NULL,LRGetLastError());
                                    dwNextPage = DetermineWelcomePage();
                                }
                            } else {
                                dwNextPage = DetermineWelcomePage();
                            }
                        } else if (g_dwAuthRetCode == IDS_ERR_CERTBAD ||
                                   g_dwAuthRetCode == IDS_ERR_CERTEXPIRED) {
                            TCHAR   szMsg[LR_MAX_MSG_TEXT];
                            TCHAR   szCaption[LR_MAX_MSG_CAPTION];  

                            LoadString(GetInstanceHandle(), g_dwAuthRetCode, szMsg, LR_MAX_MSG_TEXT);
                            LoadString(GetInstanceHandle(), IDS_TITLE, szCaption, LR_MAX_MSG_CAPTION);

                            if (MessageBox(hwnd,szMsg, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES) {
                                // Go to Reissue Cert
                                GetGlobalContext()->SetLRState(LRSTATE_NEUTRAL);
                                GetGlobalContext()->SetLSStatus(LSERVERSTATUS_REGISTER_INTERNET);
                                GetGlobalContext()->SetWizAction(WIZACTION_REREGISTERLS);
                                dwNextPage = IDD_DLG_CERTLOG_INFO;
                            } else {
                                dwNextPage = DetermineWelcomePage();
                            }
                        } else {
                            LRMessageBox(hwnd,g_dwAuthRetCode,NULL,LRGetLastError());
                            dwNextPage = DetermineWelcomePage();
                        }
                    } else {
                        dwNextPage = GetGlobalContext()->GetEntryPoint();
                    }
                } else {
                    dwNextPage = GetGlobalContext()->GetEntryPoint();
                }

                LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
                if (dwNextPage != DetermineWelcomePage()) {
                    LRPush(DetermineWelcomePage());
                }
                bStatus = -1;
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\utils.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _UTILS_H_
#define	_UTILS_H_
#include "global.h"



#ifndef TLSPERF
CGlobal * GetGlobalContext(void);
#else
CGlobalPerf * GetGlobalContext(void);
#endif


DWORD ShowProgressBox(HWND hwnd,
					  DWORD (*pfnThread)(void *),
					  DWORD dwTitle,
					  DWORD dwProgressText,
					  void * vpData = NULL);
                      

DWORD WINAPI ProcessThread(void *pData);

int			LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwCaptionID = 0,DWORD dwErrorCode = 0);
void		SetInstanceHandle(HINSTANCE hInst);
HINSTANCE	GetInstanceHandle();
//DWORD		CheckServerNT5 ();
void	SetLSName(LPTSTR lpstrLSName);
DWORD	InitGlobal();
DWORD	CheckRequieredFields();
BOOL	IsLSRunning();
DWORD	AuthenticateLS();
DWORD	LRGetLastError();



void SetRequestType(DWORD dwMode);
int GetRequestType(void);

TCHAR * SetRegistrationID(void);
TCHAR * GetLicenseServerID(void);

BOOL	IsOnlineCertRequestCreated();

DWORD	SetLRState(DWORD dwState);

DWORD LSBase64EncodeA(BYTE const *pbIn,DWORD cbIn,CHAR *pchOut,DWORD *pcchOut);
DWORD LSBase64DecodeA(CHAR const *pchIn,DWORD cchIn,BYTE *pbOut,DWORD *pcbOut);

DWORD SetCertificatePIN(LPTSTR lpszPIN);

DWORD	PopulateCountryComboBox(HWND hWndCmb);
DWORD	GetCountryCode(CString sDesc,LPTSTR szCode);

DWORD	PopulateProductComboBox(HWND hWndCmb, ProductVersionType VerType);
DWORD	GetProductCode(CString sDesc,LPTSTR szCode);

DWORD PopulateReasonComboBox(HWND hWndCmb, DWORD dwType);
DWORD GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType);

DWORD	ProcessRequest();

void	LRSetLastRetCode(DWORD dwId);
DWORD	LRGetLastRetCode();

void	LRPush(DWORD dwPageId);
DWORD	LRPop();

BOOL	ValidateEmailId(CString sEmailId);
BOOL	CheckProgramValidity(CString sProgramName);
BOOL	ValidateLRString(CString sStr);

extern DWORD SetLSLKP(TCHAR * tcLKP);
extern DWORD PingCH(void);
extern DWORD AddRetailSPKToList(HWND hListView, TCHAR *lpszRetailSPK);
extern void DeleteRetailSPKFromList(TCHAR * lpszRetailSPK);
extern void LoadFinishedFromList(HWND hListView);
extern void LoadUnfinishedFromList(HWND hListView);
extern void LoadFromList(HWND hListView);
extern void UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus);
extern DWORD SetLSSPK(TCHAR * tcp);

extern DWORD SetConfirmationNumber(TCHAR * tcConf);
extern DWORD PopulateCountryRegionListBox(HWND hWndLst);
extern void  ReadPhoneNumberFromRegistry(LPCTSTR lpCountry, LPTSTR lpPhoneNumber, DWORD nBufferSize);
extern DWORD PopulateCountryRegionComboBox(HWND hWndCmb);

extern DWORD ResetLSSPK(void);

extern void	SetCSRNumber(TCHAR *);
extern TCHAR * GetCSRNumber(void);

extern void	SetWWWSite(TCHAR *);
extern TCHAR * GetWWWSite(void);

extern void	SetReFresh(DWORD dw);
extern DWORD GetReFresh(void);

extern void SetModifiedRetailSPK(CString sRetailSPK);
extern void GetModifiedRetailSPK(CString &sRetailSPK);

extern void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK);
extern DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK);

extern	DWORD	GetCountryDesc(CString sCode,LPTSTR szDesc);

void AddHyperLinkToStaticCtl(HWND hDialog, DWORD nTextBox);
void DisplayPrivacyHelp();
DWORD
GetStringIDFromProgramName(
    CString& szProgName
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\utils.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
//
//This file contains wrapper C functions for CGlobal Object
//

#include "precomp.h"
#include "utils.h"

#ifndef TLSPERF
#include "global.h"
extern CGlobal *g_CGlobal;
#else
#include "globalPerf.h"
extern CGlobalPerf *g_CGlobal;
#endif

#include "assert.h"


// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD LSBase64EncodeA(
							IN BYTE const *pbIn,
							IN DWORD cbIn,
							OUT CHAR *pchOut,
							OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
    }
    else
    {
	DWORD cCol;

	assert(cchOutEncode <= *pcchOut);
	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		*pchOutT++ = '\r';
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    memset(ab3, 0, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}
	*pchOutT++ = '\r';
	*pchOutT++ = '\n';
	assert((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}

DWORD LSBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    DWORD err = ERROR_SUCCESS;
    DWORD cchInDecode, cbOutDecode;
    CHAR const *pchInEnd;
    CHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // skip all whitespace

	    if (*pchInT == ' ' ||
	        *pchInT == '\t' ||
	        *pchInT == '\r' ||
	        *pchInT == '\n')
	    {
		continue;
	    }

	    if (0 != cchInDecode)
	    {
		if ((cchInDecode % 4) == 0)
		{
		    break;			// ends on quantum boundary
		}

		// The length calculation may stop in the middle of the last
		// translation quantum, because the equal sign padding
		// characters are treated as invalid input.  If the last
		// translation quantum is not 4 bytes long, it must be 2 or 3
		// bytes long.

		if (*pchInT == '=' && (cchInDecode % 4) != 1)
		{
		    break;				// normal termination
		}
	    }
	    err = ERROR_INVALID_DATA;
	    goto error;
	}
	cchInDecode++;
    }
    assert(pchInT <= pchInEnd);
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	assert(cbOutDecode <= *pcbOut);
	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    memset(ab4, 0, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		assert(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	assert((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}



#ifndef TLSPERF
CGlobal * GetGlobalContext(void)
#else
CGlobalPerf * GetGlobalContext(void)
#endif
{
	return g_CGlobal;
}



DWORD WINAPI ProcessThread(void *pData)
{
	DWORD	dwRetCode  = ERROR_SUCCESS;

	dwRetCode = ProcessRequest();

	/*
	DWORD	dwTime		= 1;
	HWND	*phProgress	= (HWND *)pData;

	SendMessage(g_hProgressWnd, PBM_SETRANGE, 0, MAKELPARAM(0,PROGRESS_MAX_VAL));
	
	//
	// Increment the progress bar every second till you get Progress Event
	//
	SendMessage(g_hProgressWnd, PBM_SETPOS ,(WPARAM)1, 0);
	do
	{		
		SendMessage(g_hProgressWnd, PBM_DELTAPOS ,(WPARAM)PROGRESS_STEP_VAL, 0);
	}
	while(WAIT_TIMEOUT == WaitForSingleObject(g_hProgressEvent,PROGRESS_SLEEP_TIME));
 
	SendMessage(g_hProgressWnd, PBM_SETPOS  ,(WPARAM)PROGRESS_MAX_VAL, 0);

	*/

	ExitThread(0);

	return 0;
}



static	DWORD (*g_pfnThread)(void *);
static void * g_vpData;
static DWORD g_dwProgressTitleID = 0;
LRW_DLG_INT CALLBACK 
ProgressProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );


//
// fActivationWizard is TRUE for the activation wizard
// otherwise it's the CAL wizard
//
DWORD ShowProgressBox(HWND hwnd,
					  DWORD (*pfnThread)(void *vpData),
					  DWORD dwTitle,
					  DWORD dwProgressText,
					  void * vpData)
{
	DWORD dwReturn = ERROR_SUCCESS;

	g_pfnThread = pfnThread;
	g_vpData = vpData;
    g_dwProgressTitleID = dwTitle;

	DialogBox( GetGlobalContext()->GetInstanceHandle(), 
			   MAKEINTRESOURCE(IDD_AUTHENTICATE),
			   hwnd,
			   ProgressProc);

	return dwReturn;
}




LRW_DLG_INT CALLBACK 
ProgressProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL	bStatus = FALSE;
	static int nCounter;
	static HWND hProgress;
	static HANDLE hThread;
    TCHAR  szMsg[LR_MAX_MSG_TEXT];

    if (uMsg == WM_INITDIALOG)
	{
		DWORD	dwTID		=	0;

		ShowWindow(hwnd, SW_SHOWNORMAL);

		SetTimer(hwnd, 1, 500, NULL);

		hProgress = GetDlgItem(hwnd, IDC_PROGRESSBAR);
		hThread = CreateThread(NULL, 0, g_pfnThread, g_vpData, 0, &dwTID);

        if (g_dwProgressTitleID) {
            if (-1 != LoadString(GetInstanceHandle(), g_dwProgressTitleID,
                                 szMsg,LR_MAX_MSG_TEXT)) {
                SetWindowText(hwnd, szMsg);
            }
        }

		//Set the range & the initial position
		SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,PROGRESS_MAX_VAL));
		SendMessage(hProgress, PBM_SETPOS  ,(WPARAM)0, 0);


		// Set Title & the Introductory text


		// Create thread to process the request
	}
	else if (uMsg == WM_CLOSE)
	{
		KillTimer(hwnd, 1);
	}
	else if (uMsg == WM_TIMER)
	{
		if (WAIT_OBJECT_0 != WaitForSingleObject(hThread, 0))
		{
			nCounter++;

			if (nCounter < PROGRESS_MAX_VAL-5)
			{
				SendMessage(hProgress, PBM_DELTAPOS ,(WPARAM)PROGRESS_STEP_VAL, 0);
			}
		}
		else
		{
			SendMessage(hProgress, PBM_SETPOS  ,(WPARAM)PROGRESS_MAX_VAL, 0);
			CloseHandle(hThread);
			EndDialog(hwnd, 0);
		}
	}

    return bStatus;
}










void SetInstanceHandle(HINSTANCE hInst)
{
	g_CGlobal->SetInstanceHandle(hInst);
}

void SetLSName(LPTSTR lpstrLSName)
{
	g_CGlobal->SetLSName(lpstrLSName);
}

HINSTANCE GetInstanceHandle()
{
	return g_CGlobal->GetInstanceHandle();
}

DWORD InitGlobal()
{
	return g_CGlobal->InitGlobal();
}

DWORD CheckRequieredFields()
{
	return g_CGlobal->CheckRequieredFields();
}
//
//	This function loads the Message Text from the String Table and displays 
//	the given message
//               
int LRMessageBox(HWND hWndParent,DWORD dwMsgId,DWORD dwCaptionID /*= 0*/,DWORD dwErrorCode /*=0*/)
{
	return g_CGlobal->LRMessageBox(hWndParent,dwMsgId,dwCaptionID,dwErrorCode);
}

// 
//	This function tries to connect to the LS using LSAPI and returns TRUE if 
//	successful to connect else returns FALSE
//
BOOL IsLSRunning()
{
	return g_CGlobal->IsLSRunning();
}

//
//	This function gets LS Certs and stores Certs & Cert Extensions in the
//	CGlobal object. If no certs , it returns IDS_ERR_NO_CERT
//


//
// This function is used only in ONLINE mode to authenticate LS. 
// Assumption - GetLSCertificates should have been called before calling
// this function.
//
DWORD AuthenticateLS()
{
	return g_CGlobal->AuthenticateLS();
}

DWORD LRGetLastError()
{
	return g_CGlobal->LRGetLastError();
}


TCHAR * GetRegistrationID(void)
{
	return g_CGlobal->GetRegistrationID();
}


TCHAR * GetLicenseServerID(void)
{
	return g_CGlobal->GetLicenseServerID();
}


void SetRequestType(DWORD dwMode)
{
	g_CGlobal->SetRequestType(dwMode);
}


int GetRequestType(void)
{
	return g_CGlobal->GetRequestType();
}


BOOL IsOnlineCertRequestCreated()
{
	return g_CGlobal->IsOnlineCertRequestCreated();
}

DWORD SetLRState(DWORD dwState)
{
	return g_CGlobal->SetLRState(dwState);
}

DWORD SetCertificatePIN(LPTSTR lpszPIN)
{
	return g_CGlobal->SetCertificatePIN(lpszPIN);
}

DWORD PopulateCountryComboBox(HWND hWndCmb)
{
	return g_CGlobal->PopulateCountryComboBox(hWndCmb);
}

DWORD GetCountryCode(CString sDesc,LPTSTR szCode)
{
	return g_CGlobal->GetCountryCode(sDesc,szCode);
}

DWORD PopulateProductComboBox(HWND hWndCmb, ProductVersionType VerType)
{
	return g_CGlobal->PopulateProductComboBox(hWndCmb, VerType);
}

DWORD GetProductCode(CString sDesc,LPTSTR szCode)
{
	return g_CGlobal->GetProductCode(sDesc,szCode);
}

DWORD PopulateReasonComboBox(HWND hWndCmb, DWORD dwType)
{
	return g_CGlobal->PopulateReasonComboBox(hWndCmb, dwType);
}

DWORD GetReasonCode(CString sDesc,LPTSTR szCode, DWORD dwType)
{
	return g_CGlobal->GetReasonCode(sDesc,szCode, dwType);
}


DWORD ProcessRequest()
{
	return g_CGlobal->ProcessRequest();
}

void LRSetLastRetCode(DWORD dwCode)
{
	g_CGlobal->LRSetLastRetCode(dwCode);
}

DWORD LRGetLastRetCode()
{
	return g_CGlobal->LRGetLastRetCode();
}

void LRPush(DWORD dwPageId)
{
	g_CGlobal->LRPush(dwPageId);
}

DWORD LRPop()
{
	return g_CGlobal->LRPop();
}

BOOL ValidateEmailId(CString sEmailId)
{
	return g_CGlobal->ValidateEmailId(sEmailId);
}

BOOL CheckProgramValidity(CString sProgramName)
{
	return g_CGlobal->CheckProgramValidity(sProgramName);
}

BOOL ValidateLRString(CString sStr)
{
	return g_CGlobal->ValidateLRString(sStr);
}

void ReadPhoneNumberFromRegistry(LPCTSTR lpCountry, LPTSTR lpPhoneNumber, DWORD nBufferSize)
{
	g_CGlobal->ReadPhoneNumberFromRegistry(lpCountry, lpPhoneNumber, nBufferSize);
}

DWORD PopulateCountryRegionComboBox(HWND hWndCmb)
{
	return g_CGlobal->PopulateCountryRegionComboBox(hWndCmb);
}


DWORD PopulateCountryRegionListBox(HWND hWndLst)
{
	return g_CGlobal->PopulateCountryRegionListBox(hWndLst);
}

DWORD SetLSLKP(TCHAR * tcLKP)
{
	return g_CGlobal->SetLSLKP(tcLKP);
}



DWORD PingCH(void)
{
	return g_CGlobal->PingCH();
}


DWORD AddRetailSPKToList(HWND hListView, TCHAR * lpszRetailSPK)
{
	return g_CGlobal->AddRetailSPKToList(hListView, lpszRetailSPK);
}



void DeleteRetailSPKFromList(TCHAR * lpszRetailSPK)
{
	g_CGlobal->DeleteRetailSPKFromList(lpszRetailSPK);

	return;
}


void LoadFinishedFromList(HWND hListView)
{
	g_CGlobal->LoadFinishedFromList(hListView);

	return;
}

void LoadUnfinishedFromList(HWND hListView)
{
	g_CGlobal->LoadUnfinishedFromList(hListView);

	return;
}

void LoadFromList(HWND hListView)
{
	g_CGlobal->LoadFromList(hListView);

	return;
}


void UpdateSPKStatus(TCHAR * lpszRetailSPK, TCHAR tcStatus)
{
	g_CGlobal->UpdateSPKStatus(lpszRetailSPK, tcStatus);

	return;
}


DWORD SetConfirmationNumber(TCHAR * tcConf)
{
	return g_CGlobal->SetConfirmationNumber(tcConf);
}


DWORD SetLSSPK(TCHAR * tcp)
{
	return g_CGlobal->SetLSSPK(tcp);
}



void	SetCSRNumber(TCHAR * tcp)
{
	g_CGlobal->SetCSRNumber(tcp);

	return;
}

TCHAR * GetCSRNumber(void)
{
	return g_CGlobal->GetCSRNumber();
}

void	SetWWWSite(TCHAR * tcp)
{
	g_CGlobal->SetWWWSite(tcp);

	return;
}

TCHAR * GetWWWSite(void)
{
	return g_CGlobal->GetWWWSite();
}


DWORD ResetLSSPK(void)
{
	return g_CGlobal->ResetLSSPK();

}


void SetReFresh(DWORD dw)
{
	g_CGlobal->SetReFresh(dw);
}


DWORD GetReFresh(void)
{
	return g_CGlobal->GetReFresh();
}

void SetModifiedRetailSPK(CString sRetailSPK)
{
	g_CGlobal->SetModifiedRetailSPK(sRetailSPK);
}

void GetModifiedRetailSPK(CString &sRetailSPK)
{
	g_CGlobal->GetModifiedRetailSPK(sRetailSPK);
}

void ModifyRetailSPKFromList(TCHAR * lpszOldSPK,TCHAR * lpszNewSPK)
{
	g_CGlobal->ModifyRetailSPKFromList(lpszOldSPK,lpszNewSPK);
}

DWORD ValidateRetailSPK(TCHAR * lpszRetailSPK)
{
	return g_CGlobal->ValidateRetailSPK(lpszRetailSPK);
}

DWORD	GetCountryDesc(CString sCode,LPTSTR szDesc)
{
	return g_CGlobal->GetCountryDesc(sCode, szDesc);
}


DWORD CGlobal::SetEncodedInRegistry(LPCSTR lpszOID, LPCTSTR lpszValue)
{
	HKEY	hKey = NULL;
	DWORD	dwDisposition = 0;
	DWORD	dwRetCode = ERROR_SUCCESS;
	DWORD   dwLen = 0;
	char * cpOut;

	HCRYPTPROV	hProv = NULL;
	HCRYPTKEY	hCKey = NULL;
	HCRYPTHASH	hHash = NULL;

	PBYTE pbKey = NULL;
	DWORD cbKey = 0;

	if(!CryptAcquireContext(&hProv,
							 NULL,
							 NULL,
							 PROV_RSA_FULL,
							 CRYPT_VERIFYCONTEXT))
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptCreateHash(hProv,
					   CALG_MD5,
					   0,
					   0,
					   &hHash))	
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptHashData(hHash,
					 (BYTE *) lpszValue,
					 lstrlen(lpszValue)*sizeof(TCHAR),
					 0))	
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptDeriveKey(hProv,
					  CALG_RC4,
					  hHash,
					  CRYPT_EXPORTABLE,
					  &hCKey))
	{
		dwRetCode = GetLastError();
		goto done;
	}

	if(!CryptExportKey(
						hCKey,
						NULL,
						PUBLICKEYBLOB,
						0,
						NULL,
						&cbKey))
	{
		dwRetCode = GetLastError();
		if(dwRetCode != ERROR_SUCCESS && dwRetCode != ERROR_MORE_DATA)
			goto done;

		pbKey = (PBYTE)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,cbKey);

		if(!CryptExportKey(
							hCKey,
							NULL,
							PUBLICKEYBLOB,
							0,
							pbKey,
							&cbKey))
		{
			dwRetCode = GetLastError();
			goto done;
		}
	}


	dwRetCode = ConnectToLSRegistry();
	if(dwRetCode != ERROR_SUCCESS)
	{
		goto done;
	}

	dwRetCode = RegCreateKeyEx ( m_hLSRegKey,
							 REG_LRWIZ_PARAMS,
							 0,
							 NULL,
							 REG_OPTION_NON_VOLATILE,
							 KEY_ALL_ACCESS,
							 NULL,
							 &hKey,
							 &dwDisposition);
	
	if(dwRetCode != ERROR_SUCCESS)
	{
		LRSetLastError(dwRetCode);
		dwRetCode = IDS_ERR_REGCREATE_FAILED;
		goto done;
	}

	if (_tcslen(lpszValue) != 0)
	{
	    LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), NULL, &dwLen);

		cpOut = new char[dwLen+1];
		if (cpOut == NULL)
		{
			dwRetCode = IDS_ERR_OUTOFMEM;
			goto done;
		}

		memset(cpOut, 0, dwLen+1);
        
		LSBase64EncodeA ((PBYTE) lpszValue, _tcslen(lpszValue)*sizeof(TCHAR), cpOut, &dwLen);
	}
	else
	{
		cpOut = new char[2];
		memset(cpOut, 0, 2);
	}
	
	RegSetValueExA ( hKey, 
					lpszOID,
					0,
					REG_SZ,
					(PBYTE) cpOut,
					dwLen
				   );	
	delete[] cpOut;

done:
	if (hKey != NULL)
	{
		RegCloseKey(hKey);
	}

	DisconnectLSRegistry();

	return dwRetCode;
}



void AddHyperLinkToStaticCtl(HWND hDialog, DWORD nTextBox)
{
    RECT rcTextCtrl;

    //Read the text that's already in the control.
    TCHAR tchBuffer[512];
    GetWindowText(GetDlgItem(hDialog, nTextBox), tchBuffer, SIZE_OF_BUFFER(tchBuffer));

    //Get the control dimensions
    GetWindowRect(GetDlgItem(hDialog, nTextBox) , &rcTextCtrl);
    
    //Registration info for the control
    MapWindowPoints(NULL, hDialog, (LPPOINT)&rcTextCtrl, 2);
    LinkWindow_RegisterClass();

    //Now create the window (using the same dimensions as the
    //hidden control) that will contain the link
    HWND hLW = CreateWindowEx(0,
                          TEXT("Link Window") ,
                          TEXT("") ,
                          WS_CLIPSIBLINGS | WS_CHILD | WS_VISIBLE,
                          rcTextCtrl.left,
                          rcTextCtrl.top,
                          RECTWIDTH(rcTextCtrl),
                          RECTHEIGHT(rcTextCtrl),
                          hDialog,
                          (HMENU)12,
                          NULL,
                          NULL);

    //Now write it to the link window
    SetWindowText(hLW, tchBuffer);
}

void DisplayPrivacyHelp()
{
    TCHAR * pHtml = L"ts_lice_c_070.htm";
    HtmlHelp(AfxGetMainWnd()->m_hWnd, L"tslic.chm", HH_DISPLAY_TOPIC,(DWORD_PTR)pHtml);
}

DWORD                                    
GetStringIDFromProgramName(CString& sProgramName)
{
    DWORD dwId = -1;

    if (sProgramName == PROGRAM_LICENSE_PAK)
    {
        dwId = IDS_PROGRAM_LICENSE_PAK;
    }
    else if (sProgramName == PROGRAM_MOLP)
    {
        dwId = IDS_PROGRAM_OPEN_LICENSE;
    }
    else if (sProgramName == PROGRAM_SELECT)
    {
        dwId = IDS_PROGRAM_SELECT;
    }
    else if (sProgramName == PROGRAM_ENTERPRISE)
    {
        dwId = IDS_PROGRAM_ENTERPRISE;
    }
    else if (sProgramName == PROGRAM_CAMPUS_AGREEMENT)
    {
        dwId = IDS_PROGRAM_CAMPUS_AGREEMENT;
    }
    else if (sProgramName == PROGRAM_SCHOOL_AGREEMENT)
    {
        dwId = IDS_PROGRAM_SCHOOL_AGREEMENT;
    }
    else if (sProgramName == PROGRAM_APP_SERVICES)
    {
        dwId = IDS_PROGRAM_APP_SERVICES_AGREEMENT;
    }
    else if (sProgramName == PROGRAM_OTHER)
    {
        dwId = IDS_PROGRAM_OTHER;
    }
    else
    {
        dwId = IDS_PROGRAM_OTHER;
    }

    return dwId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\wwwlkp.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include <assert.h>
#include "precomp.h"
#include "fancypasting.h"
#include "licensinglink.h"

void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;




LRW_DLG_INT CALLBACK 
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
	DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	HWND    hwndLSID;
	DWORD dwRetCode;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];
//	TCHAR	szWWWInfo[512];
//	TCHAR	szWWWInfoFormat[512];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));

        AddLicensingSiteLink(hwnd);
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
        if (HIWORD(wParam) == EN_MAXTEXT)
        {
            //Only insert if the paste operation 
            //originated in the leftmost edit field
            if (LOWORD(wParam) == IDC_TXT_TELEINFO1)
                InsertClipboardDataIntoIDFields(hwnd, IDC_TXT_TELEINFO1, IDC_TXT_TELEINFO7);
        }

		break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;


            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwRegistrationID = GetGlobalContext()->GetRegistrationID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_MSID);
				swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
						 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
						 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
						 cwRegistrationID + 30);
			
				SetWindowText(hwndLSID, awBuffer);

                AddLicensingSiteLink(hwnd);
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				dwRetCode = SetLSLKP(tcUserValue);
				if (dwRetCode != ERROR_SUCCESS)
				{
					LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);	
					dwNextPage = IDD_DLG_WWWLKP;
				}
				else 
				{
					dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
					dwNextPage = IDD_PROGRESS;
					LRPush(IDD_DLG_WWWLKP);
				}


				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
                //A value less than 32 indicates an error launching the process
                if ((ShellExecute(NULL, L"open", GetWWWSite(), NULL, NULL, SW_SHOWNORMAL)) <= (HINSTANCE)32)
                {
	                TCHAR lpBuffer[512];
                    memset(lpBuffer,0,sizeof(lpBuffer));
                    LoadString(GetInstanceHandle(), IDS_WWW_BROWSER_LAUNCH_ERROR, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
                }
                break;

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\wwwreg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _WWWREG_H_
#define _WWWREG_H_

LRW_DLG_INT CALLBACK
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

LRW_DLG_INT CALLBACK
WWWLKPProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    );

#endif //_WWWREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\wwwreg.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include <assert.h>
#include "precomp.h"
#include "wwwreg.h"
#include "fancypasting.h"
#include "licensinglink.h"

void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;


LRW_DLG_INT CALLBACK 
WWWRegProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    DWORD	dwNextPage = 0;	
    BOOL	bStatus = TRUE;
    PageInfo *pi = (PageInfo *)LRW_GETWINDOWLONG( hwnd, LRW_GWL_USERDATA );
	DWORD   dwReturn;
	HWND    hwndLSID;
	TCHAR * cwLicenseServerID;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_TELEINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO1), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO2), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO3), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO4), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO5), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO6), _T(""));
		SetWindowText(GetDlgItem(hwnd, IDC_TXT_TELEINFO7), _T(""));

        AddLicensingSiteLink(hwnd);
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

	case WM_COMMAND:

        if (HIWORD(wParam) == EN_CHANGE)
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}

        if (HIWORD(wParam) == EN_MAXTEXT)
        {
            //Only insert if the paste operation 
            //originated in the leftmost edit field
            if (LOWORD(wParam) == IDC_TXT_TELEINFO1)
                InsertClipboardDataIntoIDFields(hwnd, IDC_TXT_TELEINFO1, IDC_TXT_TELEINFO7);
        }
    break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
				cwLicenseServerID = GetLicenseServerID();
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT|PSWIZB_BACK);
				// Get the License Server ID, provided by the License Server
				hwndLSID = GetDlgItem(hwnd, IDC_PRODUCT_ID);
				SetWindowText(hwndLSID, cwLicenseServerID);
                AddLicensingSiteLink(hwnd);
                break;

            case PSN_WIZNEXT:
				// Let us get the Information Entered First & concatenate everything into
				// One String
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO1, tcUserValue, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				GetDlgItemText(hwnd,IDC_TXT_TELEINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
				
				// OK, Now we have the Information provided by the user
				// Need to validate
				if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
				{
					// Extraneous characters in the SPK string
					LRMessageBox(hwnd, IDS_ERR_INVALIDLSID,IDS_ACTIVATION_TITLE);
					dwNextPage = IDD_DLG_WWWREG;
				}
				else 
				{
					dwReturn = GetGlobalContext()->SetLSSPK(tcUserValue);
					if (dwReturn != ERROR_SUCCESS)
					{
						LRMessageBox(hwnd, dwReturn, NULL, LRGetLastError());
						dwNextPage = IDD_DLG_WWWREG;
					}
					else
					{
						dwReturn = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
						dwNextPage = IDD_PROGRESS;
						LRPush(IDD_DLG_WWWREG);
					}
				}

				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
			{
                //A value less than 32 indicates an error launching the process
                if ((ShellExecute(NULL, L"open", GetWWWSite(), NULL, NULL, SW_SHOWNORMAL)) <= (HINSTANCE)32)
                {
	                TCHAR lpBuffer[512];
                    memset(lpBuffer,0,sizeof(lpBuffer));
                    LoadString(GetInstanceHandle(), IDS_WWW_BROWSER_LAUNCH_ERROR, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
                }
                break;
            }

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lsreport\lsrepdef.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsrepdef.h
//
// Contents:    Definitions for LSReport, including resource defs
//
// History:     06-15-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#ifndef __lslsdef_h
#define __lslsdef_h

#define TYPESTR_LENGTH 3*10
#define PRODSTR_LENGTH 3*26
#define NOEXPIRE_LENGTH 3*13
#define HEADER_LENGTH 3*74
#define TLS_ERROR_LENGTH 256

#define ERROR_BASE        (1 << 29)
#define ERROR_NO_SERVERS  (ERROR_BASE+1)
#define ERROR_BAD_SYNTAX  (ERROR_BASE+2)
#define ERROR_BAD_CONNECT (ERROR_BASE+3)

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND 2
#endif

/* Resource table defines */
#define IDS_NO_FOPEN               100
#define IDS_NO_SERVERS             101
#define IDS_NOT_LS                 ERROR_FILE_NOT_FOUND
#define IDS_ENUMERATE_FAILED       103
#define IDS_BAD_LOOP               104

#define IDS_TEMPORARY_LICENSE      120
#define IDS_ACTIVE_LICENSE         121
#define IDS_UPGRADED_LICENSE       122
#define IDS_REVOKED_LICENSE        123
#define IDS_PENDING_LICENSE        124
#define IDS_CONCURRENT_LICENSE     125
#define IDS_UNKNOWN_LICENSE        126

#define IDS_HELP_USAGE1            130
#define IDS_HELP_USAGE2            131
#define IDS_HELP_USAGE3            132
#define IDS_HELP_USAGE4            133
#define IDS_HELP_USAGE5            134
#define IDS_HELP_USAGE6            135
#define IDS_HELP_USAGE7            136
#define IDS_HELP_USAGE8            137
#define IDS_HELP_USAGE9            138
#define IDS_HELP_USAGE10           139
#define IDS_HELP_USAGE11           140
#define IDS_HELP_USAGE12           141
#define IDS_HELP_USAGE13           142
#define IDS_HELP_USAGE14		   143

#define IDS_DEFAULT_FILE           160
#define IDS_HEADER_TEXT            161
#define IDS_NO_EXPIRE              162

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lrwizapi\wwwreissue.cpp ===
//Copyright (c) 1998 - 2001 Microsoft Corporation
#include "precomp.h"
#include "utils.h"
#include "fancypasting.h"
#include "licensinglink.h"
#include <assert.h>

extern HINSTANCE g_hInstance;


void MoveCaret(int nID, HWND  hwnd ) ;
void SetDeleteKeyStatus(int iValue) ;



LRW_DLG_INT CALLBACK
WWWReissueProc(
    IN HWND     hwnd,	
    IN UINT     uMsg,		
    IN WPARAM   wParam,	
    IN LPARAM   lParam 	
    )
{   
    BOOL	bStatus = TRUE;
	DWORD	dwNextPage = 0;
	HWND    hwndLSID;
	TCHAR * cwRegistrationID;
	TCHAR awBuffer[ 128];
	DWORD dwRetCode;
	TCHAR tcUserValue[ CHARS_IN_BATCH*NUMBER_OF_BATCHES + 1];

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        // Now set the Limit of the data entry fields
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO1, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO2, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO3, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO4, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO5, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO6, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		SendDlgItemMessage (hwnd, IDC_TXT_WWWINFO7, EM_SETLIMITTEXT, CHARS_IN_BATCH,0);
		assert(NUMBER_OF_BATCHES == 7);

        AddLicensingSiteLink(hwnd);
    break;

	case WM_SHOWWINDOW:
		if (wParam)
		{
			//SetWindowText(GetDlgItem(hwnd, IDC_CSRINFO), GetCSRNumber());
			cwRegistrationID = GetGlobalContext()->GetRegistrationID();
			hwndLSID = GetDlgItem(hwnd, IDC_MSID);
			swprintf(awBuffer, L"%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s-%5.5s", 
				 cwRegistrationID, cwRegistrationID + 5, cwRegistrationID + 10,
				 cwRegistrationID + 15, cwRegistrationID + 20, cwRegistrationID + 25,
				 cwRegistrationID + 30);
	
			SetWindowText(hwndLSID, awBuffer);
		}
		break;

	case WM_COMMAND:

		if (HIWORD(wParam) == EN_CHANGE)
		{
			MoveCaret(LOWORD(wParam), hwnd ) ;		
			
		}
		if (HIWORD(wParam) == EN_UPDATE)
		{
			if (GetKeyState(VK_DELETE) == -128)
				SetDeleteKeyStatus(1) ;
			else
				SetDeleteKeyStatus(0) ;
		}
        if (HIWORD(wParam) == EN_MAXTEXT)
        {
            //Only insert if the paste operation 
            //originated in the leftmost edit field
            if (LOWORD(wParam) == IDC_TXT_WWWINFO1)
                InsertClipboardDataIntoIDFields(hwnd, IDC_TXT_WWWINFO1, IDC_TXT_WWWINFO7);
        }
		break;

    case WM_DESTROY:
        LRW_SETWINDOWLONG( hwnd, LRW_GWL_USERDATA, NULL );
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {
            case PSN_SETACTIVE:                
                PropSheet_SetWizButtons( GetParent( hwnd ), PSWIZB_NEXT | PSWIZB_BACK);                
                AddLicensingSiteLink(hwnd);
				SetWindowText(GetDlgItem(hwnd, IDC_PRODUCT_ID), GetLicenseServerID());                
                break;

            case PSN_WIZNEXT:
				{
					// Let us get the Information Entered First & concatenate everything into
					// One String
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO1, tcUserValue, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO2, tcUserValue+1*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO3, tcUserValue+2*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO4, tcUserValue+3*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO5, tcUserValue+4*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO6, tcUserValue+5*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					GetDlgItemText(hwnd,IDC_TXT_WWWINFO7, tcUserValue+6*CHARS_IN_BATCH, CHARS_IN_BATCH+1);
					
					// OK, Now we have the Information provided by the user
					// Need to validate
					if (wcsspn(tcUserValue, BASE24_CHARACTERS) != LR_REGISTRATIONID_LEN)
					{
						// Extraneous characters in the SPK string
						LRMessageBox(hwnd, IDS_ERR_INVALIDLSID,IDS_WIZARD_MESSAGE_TITLE);
						dwNextPage = IDD_DLG_WWWREG_REISSUE;
					}
					else 
					{
						dwRetCode = SetLSSPK(tcUserValue);
						if (dwRetCode != ERROR_SUCCESS)
						{
							LRMessageBox(hwnd, dwRetCode,IDS_WIZARD_MESSAGE_TITLE);	
							dwNextPage = IDD_DLG_WWWREG_REISSUE;
						}
						else
						{
							dwRetCode = ShowProgressBox(hwnd, ProcessThread, 0, 0, 0);
							dwNextPage = IDD_PROGRESS;
							LRPush(IDD_DLG_WWWREG_REISSUE);
						}
					}

					LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
					bStatus = -1;
				}
                break;

            case PSN_WIZBACK:
				dwNextPage = LRPop();
				LRW_SETWINDOWLONG(hwnd,  LRW_DWL_MSGRESULT, dwNextPage);
				bStatus = -1;
                break;

            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lParam )->ch != VK_SPACE )
					break;

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
			{
                //A value less than 32 indicates an error launching the process
                if ((ShellExecute(NULL, L"open", GetWWWSite(), NULL, NULL, SW_SHOWNORMAL)) <= (HINSTANCE)32)
                {
	                TCHAR lpBuffer[512];
                    memset(lpBuffer,0,sizeof(lpBuffer));
                    LoadString(GetInstanceHandle(), IDS_WWW_BROWSER_LAUNCH_ERROR, lpBuffer, sizeof(lpBuffer)/sizeof(TCHAR));
                }
                break;
            }

            default:
                bStatus = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lsreport\lsreport.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsreport.h
//
// Contents:    Prototypes and structures for LSReport.
//
// History:     06-05-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#ifndef __lsls_h
#define __lsls_h

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <windef.h>
#include <winnt.h>
#include <rpc.h>
#include <hydrals.h>
#include <tlsapi.h>
#include <winsta.h>

typedef struct _ServerHolder {
    LPWSTR *pszNames;
    DWORD dwCount;
} ServerHolder, *PServerHolder;

BOOL
InitLSReportStrings(VOID);

DWORD
ShowError(
    IN DWORD dwStatus,
    IN INT_PTR *args,
    IN BOOL fSysError
);

DWORD
ExportLicenses(
    IN FILE *OutFile,
    IN PServerHolder pshServers,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid
);

VOID
PrintLicense(
    IN LPCTSTR szName,
    IN const LPLSLicense pLSLicense,
    IN LPCTSTR szProductId,
    IN FILE *outFile,
	IN BOOL fHwid
);

BOOL 
ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN OUT HANDLE dwUserData
);

INT
CompDate(
    IN DWORD dwWhen,
    IN const PSYSTEMTIME pstWhen
);

int
usage(
    IN int retVal
);

DWORD
LicenseLoop(
    IN FILE *OutFile,
    IN LPWSTR szName,
    IN DWORD dwKeyPackId,
    IN LPCTSTR szProductId,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid
);

DWORD
KeyPackLoop(
    IN FILE *OutFile,
    IN LPWSTR szName,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME pstStart,
    IN const PSYSTEMTIME pstEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid
);

void
UnixTimeToFileTime(
    IN time_t t,
    OUT LPFILETIME pft
);

void
UnixTimeToSystemTime(
    IN time_t t,
    OUT LPSYSTEMTIME pst
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\pidapi\inc\shortsig.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------


// MS CD Key
#ifdef __cplusplus
extern "C" {
#endif

typedef int SSRETCODE;  // type for return codes

#define SS_OK 0
#define SS_BAD_KEYLENGTH 1
#define SS_OTHER_ERROR 2
#define SS_INVALID_SIGNATURE 3

SSRETCODE CryptVerifySig(
    LONG cbMsg,         // [IN] number of bytes in message
    LPVOID pvMsg,       // [IN] binary message to verify
    LONG  cbKeyPublic,  // [IN] number of bytes in public key (from CryptGetKeyLens)
    LPVOID pvKeyPublic, // [IN] the generated public key (from CryptKeyGen)
    LONG  cbitsSig,     // [IN] the number of bits in the sig
    LPVOID pvSig);      // [IN] the digital signature (from CryptSign)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\pidapi\inc\digpid1.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


// Note: be careful not to alter this definition (or at least it's definition).
// When more fields are needed, create a DIGITALPID2 or similar.  Too much external
// code depends on this header to change it.

typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\pidapi\inc\digpid.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lsreport\main.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        main.cpp
//
// Contents:    Front end to license "needer"; lists TS licenses
//
// History:     06-05-99    t-BStern    Created
//
//---------------------------------------------------------------------------

// The goal here is to export
//  all [temporary] licenses [issued between <shortdate1> and <shortdate2>]
//  to a file [named <outFile>] [only from server[s] <S>]
//
// So possible command lines are:
//  lsls    |    lsls /T /D 1/1/99 2/2/00 /F outfile ls-server ls2 ls3

#include "lsreport.h"
#include "lsrepdef.h"
#include <oleauto.h>


// I found that ErrorPrintf didn't do %1-style formatting, so this does
// complete formatting and stderr output.  It is referenced by code in
// lsreport.cpp, so if the program becomes GUI-based, ShowError needs to
// maintain a presence.

DWORD
ShowError(
    IN DWORD dwStatus, // This is both the return value and the resource ID.
    IN INT_PTR *args, // Casted to va_list* and passed to FormatMessage.
    IN BOOL fSysError // Use the system message table (T) or the module (F)?
) {
    LPTSTR lpSysError;
    TCHAR szBuffer[TLS_ERROR_LENGTH];
    DWORD dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    DWORD dwRet;
    
    if ((dwStatus == ERROR_FILE_NOT_FOUND) || !fSysError)
    {
        // We need to special-case File-not-Found because the system error
        // is insufficiently educational.  FnF really means that the server
        // is not running TS.
        int retVal;
        retVal = LoadString(NULL, dwStatus, szBuffer, TLS_ERROR_LENGTH);
        if (!retVal)
        {
            // This is a more serious error.
            
            dwStatus = GetLastError();
        }
        else
        {
            dwFlag = FORMAT_MESSAGE_FROM_STRING;
        }
    }
    dwRet = FormatMessage(dwFlag |
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_ARGUMENT_ARRAY, // Tell FM to use INT_PTRs internally.
        szBuffer,
        dwStatus,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpSysError,
        0,
        (va_list *)args); // FormatMessage requires va_lists, even
            // if the arguments are flagged as being INT_PTRs.

    if ((dwRet != 0) && (lpSysError != NULL))
    {
        _fputts(lpSysError, stderr);
        LocalFree(lpSysError);
    }

    return dwStatus;
}


// Used only to enumerate the License Servers around, and thereby build a list
// Used in EnumerateTlsServer()

BOOL 
ServerEnumCallBack(
                   IN TLS_HANDLE hHandle,
                   IN LPCWSTR pszServerName,
                   IN HANDLE dwUserData // Really a PServerHolder
                   ) {
    LPWSTR *block;
    PServerHolder pSrvHold; // The casts get so hairy that I'll do this.
    pSrvHold = (PServerHolder)dwUserData;
    if ((hHandle != NULL) && (pSrvHold != NULL))
    {
        if (pSrvHold->pszNames == NULL)
        {
            // We need to allocate the names list for the first time.
            
            block = (LPWSTR *)LocalAlloc(LMEM_FIXED, sizeof (LPWSTR));
        } else {
            // The names list needs to get bigger.
            
            block = (LPWSTR *)LocalReAlloc(pSrvHold->pszNames,
                (1+pSrvHold->dwCount) * sizeof (LPWSTR),
                LMEM_MOVEABLE);
        }
        if (block != NULL)
        {
            // We can add a name to the list.
            
            pSrvHold->pszNames = block;
            pSrvHold->pszNames[pSrvHold->dwCount] = (LPWSTR)LocalAlloc(LMEM_FIXED, (_tcslen(pszServerName)+1)*sizeof(pszServerName[0]));
			if(pSrvHold->pszNames[pSrvHold->dwCount])
			{
				_tcscpy(pSrvHold->pszNames[pSrvHold->dwCount], pszServerName);

            pSrvHold->dwCount++;
			}
        }
        // It's okay if we have to stick with the names we already have.
    }
    return FALSE;
}

BOOL
SortDates(
    PSYSTEMTIME pstStart,
    PSYSTEMTIME pstEnd)
{
    BOOL fSwapped = FALSE;
    FILETIME ftStart, ftEnd;
    SYSTEMTIME stHolder;
    SystemTimeToFileTime(pstStart, &ftStart);
    SystemTimeToFileTime(pstEnd, &ftEnd);

    if ((ftStart.dwHighDateTime > ftEnd.dwHighDateTime) ||
        ((ftStart.dwHighDateTime == ftEnd.dwHighDateTime) &&
        (ftStart.dwLowDateTime > ftEnd.dwLowDateTime)))
    {
        // We need to swap.

        stHolder.wYear = pstStart->wYear;
        stHolder.wMonth = pstStart->wMonth;
        stHolder.wDay = pstStart->wDay;

        pstStart->wYear = pstEnd->wYear;
        pstStart->wMonth = pstEnd->wMonth;
        pstStart->wDay = pstEnd->wDay;

        pstEnd->wYear = stHolder.wYear;
        pstEnd->wMonth = stHolder.wMonth;
        pstEnd->wDay = stHolder.wDay;

        fSwapped = TRUE;
    }
    return fSwapped;
}


// All that wmain needs to do is parse the command line and
// therefore collect a list of machines to connect to, along with
// any options passed, and open & close the (possibly command-line
// specified) output file.

extern "C" int _cdecl
wmain(
    int argc,
    WCHAR *argv[]
) {
    // These represent which command-line options were chosen.
    BOOL fTempOnly = FALSE;
    BOOL fError = FALSE;
    BOOL fDateSpec = FALSE;
	BOOL fHwid = FALSE;
    
    DWORD dwStatus;
    DWORD dwSrvLoc; // This is a bitfield.
    ServerHolder srvHold; // This holds all the servers.
    
    // These are for parsing the command-line-specified date(s).
    DATE startDate;
    DATE endDate;
    UDATE usDate;
    UDATE ueDate;
    
    // Basic file I/O.
    TCHAR ofName[MAX_PATH+1] = { 0 };
    FILE *outFile;
    
    int i;
    INT_PTR arg; // All of my strings have at most 1 parm.
    
    dwSrvLoc = 0;
    srvHold.dwCount = 0;
    srvHold.pszNames = NULL;
    if (!(LoadString(NULL, IDS_DEFAULT_FILE, ofName, MAX_PATH) &&
        InitLSReportStrings()))
    {
        return ShowError(GetLastError(), NULL, TRUE);
    }
    for (i = 1; (i < argc) && !fError; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (argv[i][1]) {
            case 'F': case 'f': // format: /F [path\]filename
                if (i+1 == argc)
                {
                    // They didn't include enough parameters.

                    fError = TRUE;
                } else {
                    i++;
                    _tcsncpy(ofName, argv[i], MAX_PATH);
                }
                break;
            case 'D': case 'd': // format: /D startdate [enddate]

                // Do a lot of date manipulation.

                if (i+1 == argc)
                {
                    fError = TRUE;
                }
                else
                {
                    i++;
                    dwStatus = VarDateFromStr(argv[i],
                        LOCALE_USER_DEFAULT,
                        VAR_DATEVALUEONLY,
                        &startDate);
                    if (dwStatus != S_OK)
                    {
                        // The date couldn't get converted.

                        ShowError(dwStatus, NULL, TRUE);
                        fError = TRUE;
                        break;
                    }
                    if (VarUdateFromDate(startDate, 0, &usDate) != S_OK)
                    {
                        // We don't want to set error, because the user can't
                        // fix this with command line syntax.  We're out of
                        // memory or something.  ABEND.
                        
                        return ShowError(GetLastError(), NULL, TRUE);
                    }
                    i++;
                    if (i < argc)
                    {
                        dwStatus = VarDateFromStr(argv[i],
                            LOCALE_USER_DEFAULT,
                            VAR_DATEVALUEONLY,
                            &endDate);
                        if (dwStatus != S_OK)
                        {
                            ShowError(dwStatus, NULL, TRUE);
                            fError = TRUE;
                            break;
                        }
                        if (VarUdateFromDate(endDate, 0, &ueDate) != S_OK)
                        {
                            return ShowError(GetLastError(), NULL, TRUE);
                        }
                    }
                    else
                    {
                        // We have to use today's date, because they didn't
                        // give us an EndDate.
                        
                        GetSystemTime(&ueDate.st); // Fill in the SystemTime.
                    }
                    
                    // Check if the dates are in the right order.
                    // If the user gives us only /D 1/1/2022 and it is 1999, I
                    // choose not to have a fit and die.

                    SortDates(&usDate.st, &ueDate.st);
                    fDateSpec = TRUE;
                }
                break;
            case 'T': case 't': // Format: /T
                fTempOnly = TRUE;
                break;
			case 'W': case 'w':
				fHwid = TRUE;
				break;
            // case '?': case 'H': case 'h': // Format: /?
            default: // Let the default get this, since it'll work the same.

                // This'll show syntax help.

                fError = TRUE;
                break;
            } // switch
        }
        else
        {
            // It wasn't -T or /F or something.
            // It must be a server name, since it's not anything else.
            
            dwSrvLoc |= (1 << i); // Tag this is as a server name.
            srvHold.dwCount++;
			
        }
    } // argc loop

    if (fError)
    {
        ShowError(IDS_HELP_USAGE1, NULL, FALSE);
        // Set the exe name:
        arg = (INT_PTR)argv[0];
        ShowError(IDS_HELP_USAGE2, &arg, FALSE);
        ShowError(IDS_HELP_USAGE3, NULL, FALSE);
        ShowError(IDS_HELP_USAGE4, NULL, FALSE);
        ShowError(IDS_HELP_USAGE5, NULL, FALSE);
        ShowError(IDS_HELP_USAGE6, NULL, FALSE);
        ShowError(IDS_HELP_USAGE7, NULL, FALSE);
		ShowError(IDS_HELP_USAGE14, NULL, FALSE);
        ShowError(IDS_HELP_USAGE8, NULL, FALSE);
        ShowError(IDS_HELP_USAGE9, NULL, FALSE);
        ShowError(IDS_HELP_USAGE10, NULL, FALSE);
        ShowError(IDS_HELP_USAGE11, NULL, FALSE);
        ShowError(IDS_HELP_USAGE12, &arg, FALSE);
        ShowError(IDS_HELP_USAGE13, &arg, FALSE);
        
        return ERROR_BAD_SYNTAX;
    }
    outFile = _tfopen(ofName, _T("w"));
    if (outFile == NULL)
    {
        // This is an extra level of indirection for FormatMessage.
        arg = (INT_PTR)ofName;
        ShowError(IDS_NO_FOPEN, &arg, FALSE);
        return ShowError(GetLastError(), NULL, TRUE);
    }

    TLSInit();

    if (dwSrvLoc)
    {
        int holder;

		
        
        srvHold.pszNames = (LPWSTR *)LocalAlloc(LMEM_FIXED,
            srvHold.dwCount * sizeof (LPWSTR *));
        if (srvHold.pszNames == NULL)
        {
            dwStatus = ShowError(GetLastError(), NULL, TRUE);
            goto done;
        }

        holder = 0;
        for (i = 1; i < argc; i++) { // argc (less one) == max # of servers.
            if (dwSrvLoc & (1 << i)) {
                srvHold.pszNames[holder] = (LPWSTR)LocalAlloc(LMEM_FIXED, (_tcslen(argv[i])+1)*sizeof(argv[i][0]));
			    if(srvHold.pszNames[holder])
			    {
				   _tcscpy(srvHold.pszNames[holder], argv[i]);
				   
                   
				}

                holder++;
            }
        }
    }
    else
    {
        // We need to collect a list of servers.
        LPTSTR *pszEntSrvNames;
        DWORD dwEntSrvNum;
        HRESULT hrEntResult;
        
        dwStatus = EnumerateTlsServer(
            ServerEnumCallBack,
           (LPVOID)&srvHold,
            3000, // seems a good timeout
            FALSE);

        hrEntResult = GetAllEnterpriseServers(&pszEntSrvNames, &dwEntSrvNum);
        if (SUCCEEDED(hrEntResult))
        {
            DWORD j, k;
            BOOL fFound;
            
            for (k = 0; k < dwEntSrvNum; k++) {
                fFound = FALSE;
                for (j = 0; j < srvHold.dwCount; j++) {
                    if (!_tcscmp(srvHold.pszNames[j], pszEntSrvNames[k]))
                    {
                        fFound = TRUE;
                        break;
                    }
                }
                if (!fFound)
                {
                    // This is a new name.
                    
                    LPTSTR *block;
                    if (srvHold.pszNames == NULL)
                    {
                        // We have to allocate names for the first time.
                        
                        block = (LPTSTR *)LocalAlloc(LMEM_FIXED, sizeof (LPTSTR));
                    }
                    else
                    {
                        // Try to increase the array.
                        
                        block = (LPTSTR *)LocalReAlloc(srvHold.pszNames,
                            (1+srvHold.dwCount) * sizeof (LPTSTR),
                            LMEM_MOVEABLE);
                        
                    }

                    if (block != NULL)
                    {
                        // We can add a name to the list.
                        
                        srvHold.pszNames = block;
                        srvHold.pszNames[srvHold.dwCount] = pszEntSrvNames[k];
                        srvHold.dwCount++;
                    }
                    else
                    {
                        // If we can't copy it into our array, we should drop it.

                        LocalFree(pszEntSrvNames[k]);
                    }
                    
                    // End need to add name
                }
                
                // End loop through existing servers
            }

            // We've removed all of the names from this one way or the other.
            LocalFree(pszEntSrvNames);
            
            // End <GetEntSrv worked>
        }
        
        // Autodiscovery complete.
    }
	
    if (srvHold.dwCount)
    {
        dwStatus = ExportLicenses(
            outFile,
            &srvHold,
            fTempOnly,
            &usDate.st,
            &ueDate.st,
            fDateSpec,
			fHwid);
			while (srvHold.dwCount){						
               LocalFree(srvHold.pszNames[--srvHold.dwCount]);			
            } 
        LocalFree(srvHold.pszNames);

    }
    else
    {
        arg = (INT_PTR)argv[0];
        ShowError(IDS_NO_SERVERS, &arg, FALSE);
        dwStatus = ERROR_NO_SERVERS;
    }

done:
    fclose(outFile);
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\lsreport\lsreport.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1999
//
// File:        lsreport.cpp
//
// Contents:    LSReport engine - complete back end
//
// History:     06-10-99    t-BStern    Created
//
//---------------------------------------------------------------------------

#include "lsreport.h"
#include "lsrepdef.h"
#include <time.h>
#include <oleauto.h>

TCHAR noExpire[NOEXPIRE_LENGTH] = { 0 };
TCHAR header[HEADER_LENGTH] = { 0 };

TCHAR szTemp[TYPESTR_LENGTH] = { 0 };
TCHAR szActive[TYPESTR_LENGTH] = { 0 };
TCHAR szUpgrade[TYPESTR_LENGTH] = { 0 };
TCHAR szRevoked[TYPESTR_LENGTH] = { 0 };
TCHAR szPending[TYPESTR_LENGTH] = { 0 };
TCHAR szConcur[TYPESTR_LENGTH] = { 0 };
TCHAR szUnknown[TYPESTR_LENGTH] = { 0 };

//-----------------------------
DWORD
GetPageSize( VOID ) {

    static DWORD dwPageSize = 0;

    if ( !dwPageSize ) {

      SYSTEM_INFO sysInfo = { 0 };
        
      GetSystemInfo( &sysInfo ); // cannot fail.

      dwPageSize = sysInfo.dwPageSize;

    }

    return dwPageSize;

}

/*++**************************************************************
  NAME:      MyVirtualAlloc

  as Malloc, but automatically protects the last page of the 
  allocation.  This simulates pageheap behavior without requiring
  it.

  MODIFIES:  ppvData -- receives memory

  TAKES:     dwSize  -- minimum amount of data to get

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set
  Free with MyVirtualFree

  
 **************************************************************--*/

BOOL
MyVirtualAlloc( IN  DWORD  dwSize,
            OUT PVOID *ppvData )
 {

    PBYTE pbData;
    DWORD dwTotalSize;
    PVOID pvLastPage;

    // ensure that we allocate one extra page

    dwTotalSize = dwSize / GetPageSize();
    if( dwSize % GetPageSize() ) {
        dwTotalSize ++;
    }

    // this is the guard page
    dwTotalSize++;
    dwTotalSize *= GetPageSize();

    // do the alloc

    pbData = (PBYTE) VirtualAlloc( NULL, // don't care where
                                   dwTotalSize,
                                   MEM_COMMIT |
                                   MEM_TOP_DOWN,
                                   PAGE_READWRITE );
    
    if ( pbData ) {

      pbData += dwTotalSize;

      // find the LAST page.

      pbData -= GetPageSize();

      pvLastPage = pbData;

      // now, carve out a chunk for the caller:

      pbData -= dwSize;

      // last, protect the last page:

      if ( VirtualProtect( pvLastPage,
                           1, // protect the page containing the last byte
                           PAGE_NOACCESS,
                           &dwSize ) ) {

        *ppvData = pbData;
        return TRUE;

      } 

      VirtualFree( pbData, 0, MEM_RELEASE );

    }

    return FALSE;

}


VOID
MyVirtualFree( IN PVOID pvData ) 
{

    VirtualFree( pvData, 0, MEM_RELEASE ); 

}




// Returns TRUE on success.

BOOL
InitLSReportStrings(VOID)
{
    return (
        LoadString(NULL, IDS_HEADER_TEXT, header, HEADER_LENGTH) &&
        
        LoadString(NULL, IDS_NO_EXPIRE, noExpire, NOEXPIRE_LENGTH) &&
        
        LoadString(NULL, IDS_TEMPORARY_LICENSE, szTemp, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_ACTIVE_LICENSE, szActive, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_UPGRADED_LICENSE, szUpgrade, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_REVOKED_LICENSE, szRevoked, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_PENDING_LICENSE, szPending, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_CONCURRENT_LICENSE, szConcur, TYPESTR_LENGTH) &&
        LoadString(NULL, IDS_UNKNOWN_LICENSE, szUnknown, TYPESTR_LENGTH)
    );
}

typedef DWORD (WINAPI* PTLSGETLASTERRORFIXED) (
                                TLS_HANDLE hHandle,
                                LPTSTR *pszBuffer,
                                PDWORD pdwErrCode
                                );

RPC_STATUS
TryGetLastError(PCONTEXT_HANDLE hBinding,
                LPTSTR *pszBuffer)
{
    RPC_STATUS status;
    DWORD      dwErrCode;
    HINSTANCE  hModule = LoadLibrary(L"mstlsapi.dll");

    if (hModule)
    {
        PTLSGETLASTERRORFIXED pfnGetLastErrorFixed = (PTLSGETLASTERRORFIXED) GetProcAddress(hModule,"TLSGetLastErrorFixed");

        if (pfnGetLastErrorFixed)
        {
            status = pfnGetLastErrorFixed(hBinding,pszBuffer,&dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS && pszBuffer != NULL)
            {
                FreeLibrary(hModule);
                return status;
            }
        }

        FreeLibrary(hModule);
    }

    {

        LPTSTR     lpszError = NULL;
        status = ERROR_NOACCESS;
        try
        {
            if ( !MyVirtualAlloc( ( TLS_ERROR_LENGTH ) * sizeof( TCHAR ),
                              (PVOID*) &lpszError ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = TLS_ERROR_LENGTH ;

            memset(lpszError, 0, ( TLS_ERROR_LENGTH ) * sizeof( TCHAR ));


            status = TLSGetLastError(hBinding,uSize,lpszError,&dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS)
            {
                *pszBuffer = (LPTSTR)MIDL_user_allocate((TLS_ERROR_LENGTH+1)*sizeof(TCHAR));

                if (NULL != *pszBuffer)
                {
                    _tcscpy(*pszBuffer,lpszError);
                }
            }
        }
        catch (...)
        {
            status = ERROR_NOACCESS;
        }
        
        if(lpszError)
            MyVirtualFree(lpszError);
    }

    return status;
}

// Given a keypack and a machine to connect to, read every license in that kp.
// Is not called directly.

DWORD
LicenseLoop(
    IN FILE *OutFile,
    IN LPWSTR szName, // who owns this keypack?
    IN DWORD kpID, // which keypack
    IN LPCTSTR szProductDesc,
    IN BOOL bTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid) // are the above 2 parms valid
{
    TLS_HANDLE subHand;
    DWORD dwStatus;
    DWORD dwErrCode = ERROR_SUCCESS;
    WCHAR *msg = NULL;
    LSLicense lsl;

    subHand = TLSConnectToLsServer(szName);

    if (subHand == NULL)
    {
        // The machine suddenly went away.

        ShowError(GetLastError(), NULL, TRUE);
        dwErrCode = ERROR_BAD_CONNECT;
    }
    else
    {
        lsl.dwKeyPackId = kpID;
        dwStatus = TLSLicenseEnumBegin(
            subHand,
            LSLICENSE_SEARCH_KEYPACKID,
            TRUE,
            &lsl,
            &dwErrCode);

        if (dwErrCode != ERROR_SUCCESS)
        {
            TryGetLastError(subHand, &msg);

            if (NULL != msg)
            {
                _fputts(msg, stderr);

                MIDL_user_free(msg);
            }
            return dwErrCode;
        }
        else if (dwStatus)
        {
            return dwStatus;
        }
        do {
            dwStatus = TLSLicenseEnumNext(subHand, &lsl, &dwErrCode);
            if ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS)) {
                if ((lsl.ucLicenseStatus == LSLICENSE_STATUS_TEMPORARY) ||
                    !bTempOnly) { // Does it fit the temp. requirements?
                    // We want to print if at any of the following are true:
                    // a) There are no limits
                    // b) Issued between stStart and stEnd
                    // c) Expired between stStart and stEnd
                    // d) issued before stStart and expired after stEnd
                    if (!fUseLimits // case a
                        || ((CompDate(lsl.ftIssueDate, stStart) >= 0) &&
                        (CompDate(lsl.ftIssueDate, stEnd) <= 0)) // case b
                        || ((CompDate(lsl.ftExpireDate, stStart) >= 0) &&
                        (CompDate(lsl.ftExpireDate, stEnd) <= 0)) // case c
                        || ((CompDate(lsl.ftIssueDate, stStart) <= 0) &&
                        (CompDate(lsl.ftExpireDate, stEnd) >= 0))) // case d
                    {
                        PrintLicense(szName, // print it.
                            &lsl,
                            szProductDesc,
                            OutFile,
							fHwid);
                    } // end check cases
                } // end check for temp license
            } // end good getnext
        } while ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS));

        if (dwStatus != RPC_S_OK)
        {
            return ShowError(dwStatus, NULL, TRUE);
        }

        if (dwErrCode != LSERVER_I_NO_MORE_DATA)
        {
            TryGetLastError(subHand, &msg);
            if (NULL != msg)
            {
                _fputts(msg, stderr);

                MIDL_user_free(msg);

                msg = NULL;
            }
        }

        TLSLicenseEnumEnd(subHand, &dwErrCode);

        if (dwErrCode != ERROR_SUCCESS)
        {
            TryGetLastError(subHand, &msg);
            if (NULL != msg)
            {
                _fputts(msg, stderr);

                MIDL_user_free(msg);
            }
        }

        TLSDisconnectFromServer(subHand);
    }
    return dwErrCode;
}

// Given a machine to connect to, iterate through the keypacks.
// Is not called directly.
DWORD
KeyPackLoop(
    IN FILE *OutFile,
    IN LPWSTR szName, // machine to connect to
    IN BOOL bTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid) // do we care about the previous 2 parms?
{
    TLS_HANDLE hand;
    DWORD dwStatus, dwErrCode;
    LSKeyPack lskpKeyPack;
    TCHAR *msg = NULL;
    
    hand = TLSConnectToLsServer(szName);
    if (hand == NULL)
    {
        return GetLastError();
    }

	memset(&lskpKeyPack, 0, sizeof(lskpKeyPack));
    lskpKeyPack.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
    dwStatus = TLSKeyPackEnumBegin(hand,
        LSKEYPACK_SEARCH_ALL,
        FALSE,
        &lskpKeyPack,
        &dwErrCode);
    if (dwErrCode != ERROR_SUCCESS)
    {
        return dwErrCode;
    }
    if (dwStatus != RPC_S_OK)
    {
        return dwStatus;
    }
    do {
        dwStatus = TLSKeyPackEnumNext(hand, &lskpKeyPack, &dwErrCode);
        if ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS))
        {
            LicenseLoop(OutFile,
                szName,
                lskpKeyPack.dwKeyPackId,
                lskpKeyPack.szProductDesc,
                bTempOnly,
                stStart,
                stEnd,
                fUseLimits,
				fHwid);
        }
    } while ((dwStatus == RPC_S_OK) && (dwErrCode == ERROR_SUCCESS));
    if (dwStatus != RPC_S_OK)
    {
        return ShowError(dwStatus, NULL, TRUE);
    }
    if (dwErrCode != LSERVER_I_NO_MORE_DATA)
    {
        TryGetLastError(hand, &msg);
        if (NULL != msg)
        {
            _fputts(msg, stderr);
            
            MIDL_user_free(msg);
            
            msg = NULL;
        }
    }
    TLSKeyPackEnumEnd(hand, &dwErrCode);
    if (dwErrCode != ERROR_SUCCESS)
    {
        TryGetLastError(hand, &msg);
        if (NULL != msg)
        {
            _fputts(msg, stderr);
            
            MIDL_user_free(msg);
        }
    }
    TLSDisconnectFromServer(hand);
    return dwErrCode;
}

// If bTempOnly is FALSE, all licenses will be dumped to the file.  Otherwise,
// only Temporary licenses will be written.  This is the one function to call
// to do all of the program's magic.
DWORD
ExportLicenses(
    IN FILE *OutFile, // must be opened for writing first
    IN PServerHolder pshServers,
    IN BOOL fTempOnly,
    IN const PSYSTEMTIME stStart,
    IN const PSYSTEMTIME stEnd,
    IN BOOL fUseLimits,
	IN BOOL fHwid) // are the above 2 parms valid?
{
    DWORD i;
    DWORD dwStatus;
    DWORD dwRetVal = ERROR_SUCCESS;
    
    _fputts(header, OutFile);
    for (i = 0; i < pshServers->dwCount; i++) {
        dwStatus = KeyPackLoop(OutFile,
            pshServers->pszNames[i],
            fTempOnly,
            stStart,
            stEnd,
            fUseLimits,
			fHwid);
        if (dwStatus != ERROR_SUCCESS)
        {
            INT_PTR arg;

            dwRetVal = dwStatus;
            arg = (INT_PTR)pshServers->pszNames[i];
            ShowError(IDS_BAD_LOOP, &arg, FALSE);
            ShowError(dwStatus, NULL, TRUE);
        }
    }
    if (dwRetVal == ERROR_SUCCESS)
    {
        // Show a success banner.
        
        ShowError(ERROR_SUCCESS, NULL, TRUE);
    }
    return dwRetVal;
}

// Performs actual output.  of must be open.
// Not called directly.
VOID
PrintLicense(
    IN LPCWSTR szName, // server allocating this license
    IN const LPLSLicense p,
    IN LPCTSTR szProductDesc,
    IN FILE *of,
	IN BOOL fHwid)
{
    // All of these are used solely to convert a time_t to a short date.
    BSTR bszDate;
    UDATE uDate;
    DATE Date;
    HRESULT hr;
    LPTSTR szType;
	TCHAR tc;
		
	
    
    // server name
    _fputts(szName, of);
    
    // license ID and keypack ID
    _ftprintf(of, _T("\t%d\t%d\t"),
        p->dwLicenseId,
        p->dwKeyPackId);

	 // license holder (machine)
    _fputts(p->szMachineName, of);
    _fputtc('\t', of);
    
    // license requestor (username)
    _fputts(p->szUserName, of);
    _fputtc('\t', of);
    
    // Print issue date in locale-appropriate way
    UnixTimeToSystemTime((const time_t)p->ftIssueDate, &uDate.st);

    hr = VarDateFromUdate(&uDate, 0, &Date);

    if (S_OK != hr)
    {
        return;
    }

    hr = VarBstrFromDate(Date, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), VAR_DATEVALUEONLY, &bszDate);

    if (S_OK != hr)
    {
        return;
    }

    _fputts(bszDate, of);
    SysFreeString(bszDate);
    _fputtc('\t', of);
    
    // print either "No Expiration" or locale-nice expiration date
    if (0x7FFFFFFF == p->ftExpireDate)
    {
        _fputts(noExpire, of);
    }
    else
    {
        UnixTimeToSystemTime((const time_t)p->ftExpireDate, &uDate.st);

        hr = VarDateFromUdate(&uDate, 0, &Date);

        if (S_OK != hr)
        {
            return;
        }

        hr = VarBstrFromDate(Date, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), VAR_DATEVALUEONLY, &bszDate);

        if (S_OK != hr)
        {
            return;
        }

        _fputts(bszDate, of);
        SysFreeString(bszDate);
    }
    _fputtc('\t', of);
    
    // Assign the right kind of text for the type of license,
    // and then print the license type.
    switch (p->ucLicenseStatus) {
    case LSLICENSE_STATUS_TEMPORARY:
        szType = szTemp;
        break;
    case LSLICENSE_STATUS_ACTIVE:
        szType = szActive;
        break;
    case LSLICENSE_STATUS_UPGRADED:
        szType = szUpgrade;
        break;
    case LSLICENSE_STATUS_REVOKE:
        szType = szRevoked;
        break;
    case LSLICENSE_STATUS_PENDING:
        szType = szPending;
        break;
    case LSLICENSE_STATUS_CONCURRENT:
        szType = szConcur;
        break;
    case LSLICENSE_STATUS_UNKNOWN:
        // Fall through
    default:
        szType = szUnknown;
    }
    _fputts(szType, of);
    _fputtc('\t', of);
    
    // Print the description
    _fputts(szProductDesc, of);
    _fputtc('\t', of);


	//Doughu: Representation algorithm
   //We have only 36 informational chars I0 through I35 due to szHWID being TCHAR[37]
   //and we have to represent this in client HWID format, which is:  
   //0xI0I10000I2I3, 0xI4I5I6I7I8I9I10I11,  0xI12I13I14I15I16I17I18I19, 0xI20I21I22I23I24I25I26I27, 0xI28I29I30I31I32I33I34I35 

	if (fHwid)
	{
		for (int i=0; (((tc=p->szHWID[i])!=NULL)&&(i<36)); i++)		
		{
    		//this if statement is for prepending 0x
		if (i==0)
		{
			_fputtc('0', of);_fputtc('x', of);	   	   
		}
		
    		_fputtc(tc,of);
	    	 
		//this if statement is for 4 zeroes that need to be print since they were masked
		if (i==1)
		{
			_fputtc('0', of); _fputtc('0', of); _fputtc('0', of); _fputtc('0', of);	   	   
		}
		
    		//this if statement is for I3, I11, I19 and I26 values where we put comma followed by space and 0x
    		if((((i+5)%8)==0) &&( i!=35))
    		{
    	 		_fputtc(',', of); _fputtc(' ', of); _fputtc('0', of); _fputtc('x', of);	   	   
    		}
		}
		_fputtc('\n', of);
	}
	else
	{
    _fputtc('\n', of);
	} 


}



// returns <0 if when is before st, ==0 if they are the same date, and
// >0 if when is after st.
int CompDate(
    IN DWORD when, // treated as a time_t
    IN const PSYSTEMTIME st)
{
    time_t when_t;

    //
    // time_t is 64 bits in win64.  Convert, being careful to sign extend.
    //

    when_t = (time_t)((LONG)(when));
    struct tm *t = localtime(&when_t);

    if ((t->tm_year+1900) < st->wYear) {
        return -1;
    }
    if ((t->tm_year+1900) > st->wYear) {
        return 1;
    }
    if  ((t->tm_mon+1) < st->wMonth) {
        return -1;
    }
    if ((t->tm_mon+1) > st->wMonth) {
        return 1;
    }
    if (t->tm_mday < st->wDay) {
        return -1;
    }
    if (t->tm_mday > st->wDay) {
        return 1;
    }
    return 0;
}


// From the Platform SDK.
void
UnixTimeToFileTime(
    IN time_t t,
    OUT LPFILETIME pft)
{
    // Note that LONGLONG is a 64-bit value
    LONGLONG ll;
    
    ll = Int32x32To64(t, 10000000) + 116444736000000000;
    pft->dwLowDateTime = (DWORD)ll;
    pft->dwHighDateTime = (DWORD)(ll >> 32);
}

// Also from the Platform SDK.
void
UnixTimeToSystemTime(
    IN time_t t,
    OUT LPSYSTEMTIME pst)
{
    FILETIME ft;
	FILETIME ftloc;
	
    
    UnixTimeToFileTime(t, &ft);
	FileTimeToLocalFileTime(&ft, &ftloc);
    FileTimeToSystemTime(&ftloc, pst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\common.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        
//
// Contents:    
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "common.h"

//---------------------------------------------------------------------------
// FUNCTION: LogEvent(	DWORD   dwEventType,                 	     
//                      DWORD   dwIdEvent,               
//                      WORD    cStrings,                            
//                      LPTSTR *apwszStrings);           
//                                                        
// PURPOSE: add the event to the event log                
//                                                               
// INPUT: the event ID to report in the log, the number of insert
//        strings, and an array of null-terminated insert strings
//                                                               
// RETURNS: none                                                 
//---------------------------------------------------------------------------
HRESULT LogEvent(LPTSTR lpszSource,
                 DWORD  dwEventType,
                 WORD   wCatalog,
                 DWORD  dwIdEvent,
                 WORD   cStrings,
                 TCHAR **apwszStrings)
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType;

    wElogType = (WORD) dwEventType;
    if(hAppLog=RegisterEventSource(NULL, lpszSource)) 
    {
        bSuccess = ReportEvent(hAppLog,
		    	               wElogType,
			                   wCatalog,
			                   dwIdEvent,
			                   NULL,
			                   cStrings,
    			               0,
	    		               (const TCHAR **) apwszStrings,
		    	               NULL);

        DeregisterEventSource(hAppLog);
    }

    return((bSuccess) ? S_OK : GetLastError());
}

//---------------------------------------------------------------------------
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = _TEXT('\0');  //remove cr and newline character
        _sntprintf( lpszBuf, dwSize, _TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}

BOOL
ConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    BOOL fOk = FALSE;
    BSTR bstr;

    do
    {
    bstr = NULL;
    if (NULL != pwc)
    {
        if (-1 == cb)
        {
            cb = wcslen(pwc) * sizeof(WCHAR);
        }
        bstr = SysAllocStringByteLen((char const *) pwc, cb);
        if (NULL == bstr)
        {
            break;
        }
    }
    if (NULL != *pbstr)
    {
        SysFreeString(*pbstr);
    }
    *pbstr = bstr;
    fOk = TRUE;
    } while (FALSE);
    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\common.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        common.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Modified from MSDN RPC Service Sample
//
//---------------------------------------------------------------------------
#ifndef _LS_COMMON_H
#define _LS_COMMON_H

#include <windows.h>
#include <wincrypt.h>
#include <ole2.h>

#ifdef __cplusplus
extern "C" {
#endif

    HRESULT LogEvent(LPTSTR lpszSource,
                     DWORD  dwEventType,
                     WORD   wCatalog,
                     DWORD  dwIdEvent,
                     WORD   cStrings,
                     TCHAR **apwszStrings);

    LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


    BOOL
    ConvertWszToBstr( OUT BSTR *pbstr,
                      IN WCHAR const *pwc,
                      IN LONG cb);
    

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\dbgout.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include "dbgout.h"
#include "locks.h"

//CCriticalSection CS;

void
DebugOutput(
    HANDLE hConsole,
    LPTSTR format,
    va_list* vaList
    )
/*++
++*/
{
    TCHAR  buf[8096];
    DWORD  dump;
    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    // CS.Lock();

    try {
        memset(buf, 0, sizeof(buf));
        _sntprintf(
                buf,
                sizeof(buf)/sizeof(buf[0]),
                _TEXT(" %d [%d:%d:%d:%d:%d.%d] : "),
                GetCurrentThreadId(),
                sysTime.wMonth,
                sysTime.wDay,
                sysTime.wHour,
                sysTime.wMinute,
                sysTime.wSecond,
                sysTime.wMilliseconds
            );
        buf[8095] = 0;

        _vsntprintf(
                buf + lstrlen(buf),
                sizeof(buf)/sizeof(buf[0]) - lstrlen(buf),
                format,
                *vaList
            );

        OutputDebugString(buf);
        if(hConsole != NULL)
        {
            WriteConsole(
                        hConsole,
                        buf,
                        _tcslen(buf),
                        &dump,
                        NULL
                    );
        }
    }
    catch(...) {
    }

    // CS.UnLock();

    return;
}


void
TLSDebugOutput(
    HANDLE hConsole,
    LPTSTR format, ...
    )
/*++
++*/
{
    va_list marker;
    va_start(marker, format);

    DebugOutput(hConsole, format, &marker);

    va_end(marker);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\dbgout.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __DEBUG_OUTPUT__
#define __DEBUG_OUTPUT__

#include <windows.h>
#include <stdio.h>
#include <tchar.h>


#ifdef __cplusplus
extern "C" {
#endif

void
TLSDebugOutput(
    HANDLE hConsole,
    LPTSTR format, ...
);

void
DebugOutput(
    HANDLE hConsole,
    LPTSTR format,
    va_list* vaList
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\secstore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:
//
//	secstore.c
//
// Contents:    
//
// History:     
//---------------------------------------------------------------------------
#include "secstore.h"
#include <stdlib.h>
#include <tchar.h>

///////////////////////////////////////////////////////////////////////////////
DWORD
RetrieveKey(
    PWCHAR      pwszKeyName,
    PBYTE *     ppbKey,
    DWORD *     pcbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, pwszKeyName );

    Status = OpenPolicy( NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    if (NULL == pSecretData)
    {
        return ERROR_INTERNAL_ERROR;
    }

    if(pSecretData->Length)
    {
        *ppbKey = ( LPBYTE )LocalAlloc( LPTR, pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    SecureZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
DWORD
StoreKey(
    PWCHAR  pwszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( &SecretKeyName, pwszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


///////////////////////////////////////////////////////////////////////////////
DWORD
OpenPolicy(
    LPWSTR      ServerName,
    DWORD       DesiredAccess,
    PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    SecureZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle ) );
}


///////////////////////////////////////////////////////////////////////////////
void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR              String )
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\secstore.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __SECSTORE_H__
#define __SECSTORE_H__

#include <windows.h>
#include <ntsecapi.h>

#ifdef __cplusplus
extern "C"{
#endif

DWORD
RetrieveKey(PWCHAR      pwszKeyName,
            PBYTE *     ppbKey,
            DWORD *     pcbKey );

DWORD
StoreKey(   PWCHAR  pwszKeyName,
            BYTE *  pbKey,
            DWORD   cbKey );

DWORD
OpenPolicy( LPWSTR      ServerName,
            DWORD       DesiredAccess,
            PLSA_HANDLE PolicyHandle );

void
InitLsaString(  PLSA_UNICODE_STRING LsaString,
                LPWSTR              String );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\svcrole.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        svcrole.c
//
// Contents:    This is the include to include common we need
//
// History:     
//
//---------------------------------------------------------------------------
#include "svcrole.h"
#include "secstore.h"
#include <dsgetdc.h>
#include <dsrole.h>

///////////////////////////////////////////////////////////////////////////////////

BOOL
GetMachineGroup(
    LPWSTR pszMachineName,
    LPWSTR* pszGroupName
    )

/*++


Note:

    Code modified from DISPTRUS.C

--*/

{
    LSA_HANDLE PolicyHandle; 
    DWORD dwStatus;
    NTSTATUS Status; 
    NET_API_STATUS nas = NERR_Success; // assume success 
 
    BOOL bSuccess = FALSE; // assume this function will fail 

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain = NULL; 
    LPWSTR szPrimaryDomainName = NULL; 
    LPWSTR DomainController = NULL; 
 
    // 
    // open the policy on the specified machine 
    // 
    Status = OpenPolicy( 
                    pszMachineName, 
                    POLICY_VIEW_LOCAL_INFORMATION, 
                    &PolicyHandle 
                ); 
 
    if(Status != ERROR_SUCCESS) 
    { 
        SetLastError( dwStatus = LsaNtStatusToWinError(Status) ); 
        return FALSE;
    } 
 
    // 
    // get the primary domain 
    // 
    Status = LsaQueryInformationPolicy( 
                            PolicyHandle, 
                            PolicyPrimaryDomainInformation, 
                            (PVOID *)&PrimaryDomain 
                        ); 

    if(Status != ERROR_SUCCESS) 
    {
        goto cleanup;  
    }

    *pszGroupName = (LPWSTR)LocalAlloc( 
                                    LPTR,
                                    PrimaryDomain->Name.Length + sizeof(WCHAR) // existing length + NULL 
                                ); 
 
    if(*pszGroupName != NULL) 
    { 
        // 
        // copy the existing buffer to the new storage, appending a NULL 
        // 
        lstrcpynW( 
            *pszGroupName, 
            PrimaryDomain->Name.Buffer, 
            (PrimaryDomain->Name.Length / sizeof(WCHAR)) + 1 
            ); 

        bSuccess = TRUE;
    } 
 

cleanup:

    if(PrimaryDomain != NULL)
    {
        LsaFreeMemory(PrimaryDomain); 
    }


    // 
    // close the policy handle 
    // 
    if(PolicyHandle != INVALID_HANDLE_VALUE) 
    {
        LsaClose(PolicyHandle); 
    }

    if(!bSuccess) 
    { 
        if(Status != ERROR_SUCCESS) 
        {
            SetLastError( LsaNtStatusToWinError(Status) ); 
        }
        else if(nas != NERR_Success) 
        {
            SetLastError( nas ); 
        }
    } 
 
    return bSuccess; 
}

///////////////////////////////////////////////////////////////////////////////////
BOOL 
IsDomainController(
    LPWSTR Server, 
    LPBOOL bDomainController 
    ) 
/*++


++*/
{
    PSERVER_INFO_101 si101;
    NET_API_STATUS nas;
    nas = NetServerGetInfo( (LPTSTR)Server,
                            101,
                            (LPBYTE *)&si101 );

    if(nas != NERR_Success) 
    {
        SetLastError(nas);
        return FALSE; 
    }

    if( (si101->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
        (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) )
    {
        // we are dealing with a DC
        // 
        *bDomainController = TRUE;
    }
    else 
    {
        *bDomainController = FALSE;
    }

    NetApiBufferFree(si101);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\common\svcrole.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        svcrole.h
//
// Contents:    This is the include to include common we need
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __SVCROLE_H__
#define __SVCROLE_H__

#include <windows.h>
#include <ntsecapi.h>

// Netxxx API includes
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>

typedef enum _SERVER_ROLE_IN_DOMAIN
{
    SERVERROLE_ERROR,
    SERVERROLE_NOT4,
    SERVERROLE_NOTSERVER,
    SERVERROLE_STANDALONE,
    SERVERROLE_SERVER,
    SERVERROLE_PDC,
    SERVERROLE_BDC,
    SERVERROLE_NT4DOMAIN
} SERVER_ROLE_IN_DOMAIN;

#ifdef __cplusplus
extern "C" {
#endif

    BOOL
    GetMachineGroup(
        LPWSTR pszServer,
        LPWSTR* pszGroupName
    );
    
    BOOL 
    IsDomainController( 
        LPWSTR Server, 
        LPBOOL bDomainController 
    );

    SERVER_ROLE_IN_DOMAIN 
    GetServerRoleInDomain( 
        LPWSTR Server 
    );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\debug\tsctst\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Client License Dump"
#define VER_INTERNALNAME_STR        "tsctst"
#define VER_ORIGINALFILENAME_STR    "tsctst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\debug\tslicmode\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server License Mode Utility"
#define VER_INTERNALNAME_STR        "tslicmode"
#define VER_ORIGINALFILENAME_STR    "tslicmode.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\debug\tsctst\tsctst.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <rpc.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <crt/io.h>
#include <wincrypt.h>
#include "license.h"
#include "certutil.h"

BYTE        g_pSecretKey[1024];
DWORD       g_cbSecretKey=sizeof(g_pSecretKey);

#define SAFESTRCPY(dest, source) \
    _tcsncpy(dest, source, min(_tcslen(source), sizeof(dest) - sizeof(TCHAR)))

#define COMMON_STORE    TEXT("Software\\Microsoft\\MSLicensing\\Store")
#define LICENSE_VAL     TEXT("ClientLicense")

LPCTSTR 
FileTimeText( 
    FILETIME *pft )
{
    static TCHAR buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime( pft, &ftLocal );

    if( FileTimeToSystemTime( &ftLocal, &st ) )
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
    
        _tcscpy(buf, _wasctime(&ctm));
    
        buf[_tcslen(buf)-1] = 0;
    }
    else
    {
        swprintf( buf, 
                 L"<FILETIME %08lX:%08lX>", 
                 pft->dwHighDateTime,
                 pft->dwLowDateTime );
    }

    return buf;
}

void MyReportError(DWORD errCode)
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             errCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

    if(dwRet != 0)
    {
        _tprintf(_TEXT("Error : %s (%d)\n"), lpszTemp, errCode);
        if(lpszTemp)
            LocalFree((HLOCAL)lpszTemp);
    }

    return;
}
//------------------------------------------------------------------------------------------
void DumpLicensedProduct(PLICENSEDPRODUCT pLicensedInfo, BOOL fAdvanced)
{
    if(fAdvanced == TRUE)
    {
        _tprintf(_TEXT("TS Certificate Version - 0x%08x\n"), pLicensedInfo->dwLicenseVersion);
        _tprintf(_TEXT("Licensed Product\n"));
        _tprintf(_TEXT("\tHWID - 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x\n"),
                 pLicensedInfo->Hwid.dwPlatformID,
                 pLicensedInfo->Hwid.Data1,
                 pLicensedInfo->Hwid.Data2,
                 pLicensedInfo->Hwid.Data3,
                 pLicensedInfo->Hwid.Data4);
        _tprintf(_TEXT("\tClient Platform ID - 0x%08x\n"), pLicensedInfo->LicensedProduct.dwPlatformID ); 
        _tprintf(_TEXT("\tCompany Name - %s\n"), pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName);
    }


    _tprintf(_TEXT("Issuer - %s\n"), pLicensedInfo->szIssuer);
    _tprintf(_TEXT("Scope - %s\n"), pLicensedInfo->szIssuerScope);

    if(pLicensedInfo->szLicensedClient)
        _tprintf(_TEXT("Issued to machine - %s\n"), pLicensedInfo->szLicensedClient);

    if(pLicensedInfo->szLicensedUser)
        _tprintf(_TEXT("Issued to user - %s\n"), pLicensedInfo->szLicensedUser);

    
    if(fAdvanced == TRUE)
    {
		_tprintf(_TEXT("\tTS Locale ID - 0x%08x\n"), pLicensedInfo->LicensedProduct.dwLanguageID);           
	}
    
    _tprintf(_TEXT("\tLicense ID - %s\n"), pLicensedInfo->LicensedProduct.pProductInfo->pbProductID);

    for(DWORD i=0; i < pLicensedInfo->dwNumLicensedVersion; i++)
    {
        if(fAdvanced == TRUE)
        {
            _tprintf(_TEXT("Licensed Product Version %04d.%04d, Flag 0x%08x\n"),
                     pLicensedInfo->pLicensedVersion[i].wMajorVersion,
                     pLicensedInfo->pLicensedVersion[i].wMinorVersion,
                     pLicensedInfo->pLicensedVersion[i].dwFlags);
        }

        if (pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_TEMPORARY)
        {
            _tprintf(_TEXT("Temporary\t"));
        }
        else
        {
            _tprintf(_TEXT("Permanent\t"));
        }

        if (pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_RTM)
        {
            _tprintf(_TEXT("RTM\t"));
        }
        else
        {
            _tprintf(_TEXT("Beta\t"));
        }

        _tprintf(_TEXT("\n"));
    }

    _tprintf(L"Valid from - %x %x %s\n",
             pLicensedInfo->NotBefore.dwHighDateTime,
             pLicensedInfo->NotBefore.dwLowDateTime,
             FileTimeText(&pLicensedInfo->NotBefore));
    
    _tprintf(L"Expires on - %x %x %s\n",
             pLicensedInfo->NotAfter.dwHighDateTime,
             pLicensedInfo->NotAfter.dwLowDateTime,
             FileTimeText(&pLicensedInfo->NotAfter));
}

int __cdecl wmain(int argc, LPCWSTR argv[])
{
    HKEY hKey, hKeyStore;
    LPBYTE  lpKeyValue=NULL;
    DWORD   cbKeyValue;
    DWORD   dwStatus;
    DWORD   dwKeyType;
    TCHAR   lpName[128];
    DWORD   cName;
    FILETIME ftWrite;
    LICENSEDPRODUCT LicensedInfo[10];
    DWORD   dwNum;
    ULARGE_INTEGER  SerialNumber;
    BYTE pbKey[1024];
    DWORD cbKey=1024;
    LICENSE_STATUS lstatus;
    BOOL fAdvanced = FALSE;

    if(argc > 2 || ((argc == 2) && (_wcsicmp(argv[1], L"/a") != 0)) )
    {             
        _tprintf(_T("Usage: tsctst /A\n"));
        _tprintf(_T("/A \t Displays advanced license information in addition to default basics.\n"));        
	    
        return 0;
    }
    
    

    if(argc == 2)
    {
        fAdvanced = TRUE;
    }

    dwStatus=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          COMMON_STORE,
                          0,
                          KEY_READ,
                          &hKey);
                          
    if(dwStatus != ERROR_SUCCESS)
    {
        _tprintf(_TEXT("Can't open key - %ld\n"), dwStatus);
        return 0;
    }

    LSInitCertutilLib( 0 );

    LicenseGetSecretKey( &cbKey, pbKey );

    for (DWORD dwKey = 0; dwStatus == ERROR_SUCCESS; dwKey++)
    {
        cName = sizeof(lpName) / sizeof(TCHAR);

        dwStatus=RegEnumKeyEx(hKey,
                              dwKey,
                              lpName,
                              &cName,
                              NULL,
                              NULL,
                              NULL,
                              &ftWrite);
                          
        if (ERROR_SUCCESS == dwStatus)
        {
            if(!cName)
            {
                _tprintf(_TEXT("Can't open key - %ld\n"), dwStatus);
                goto cleanup;
            }
           
            dwStatus = RegOpenKeyEx(hKey,
                                    lpName,
                                    0,
                                    KEY_READ,
                                    &hKeyStore);
            
            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't open store %s - %d\n"), lpName, dwStatus);
                continue;
            }

            cbKeyValue=0;
            dwStatus = RegQueryValueEx(hKeyStore,
                                       LICENSE_VAL,
                                       NULL,
                                       &dwKeyType,
                                       NULL,
                                       &cbKeyValue);

            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't get value size - %d\n"), dwStatus);
                RegCloseKey(hKeyStore);
                continue;
            }

            lpKeyValue = (LPBYTE)malloc(cbKeyValue);
            if(!lpKeyValue)
            {
                _tprintf(_TEXT("Can't allocate %d bytes\n"), cbKeyValue);
                RegCloseKey(hKeyStore);
                goto cleanup;
            }

            dwStatus = RegQueryValueEx(hKeyStore,
                                       LICENSE_VAL,
                                       NULL,
                                       &dwKeyType,
                                       lpKeyValue,
                                       &cbKeyValue);
            if(dwStatus != ERROR_SUCCESS)
            {
                _tprintf(_TEXT("can't get value - %d\n"), dwStatus);
                free(lpKeyValue);
                RegCloseKey(hKeyStore);
                continue;
            }

            memset(LicensedInfo, 0, sizeof(LicensedInfo));

            dwNum = 10;

            lstatus = LSVerifyDecodeClientLicense(lpKeyValue, cbKeyValue, pbKey, cbKey, &dwNum, LicensedInfo);

            if (lstatus == LICENSE_STATUS_OK)
            {
                for (DWORD i = 0; i < dwNum; i++)
                {
                    _tprintf(_TEXT("\n*** License # %d ***\n"), i+1);
                    DumpLicensedProduct(LicensedInfo+i, fAdvanced);
                }
                LSFreeLicensedProduct(LicensedInfo);
            }
            else
            {
                _tprintf(_TEXT("can't decode license - %d, %d\n"), lstatus, GetLastError());
                free(lpKeyValue);
                RegCloseKey(hKeyStore);
                continue;
            }

            free(lpKeyValue);

            RegCloseKey(hKeyStore);

            _tprintf(_TEXT("\n\n"));
        }//endif
		else
		{
			if(dwKey == 0)
			{
				_tprintf(_TEXT("\nThe client does not have a license\n"));
			}

		}
    }//endfor   	   
        
cleanup:
    RegCloseKey(hKey);

    LSShutdownCertutilLib();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\esetup\publish.cpp ===
/*
**	Copyright (c) 1998 Microsoft Corporation
**	All Rights Reserved
**
*/
#include <windows.h>
#include <wchar.h>
#include <objbase.h>
#include <winbase.h>

// Required by SSPI.H
#define SECURITY_WIN32
#include <sspi.h>

#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <activeds.h>

#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define LICENSE_SETTINGS                L"TS-Enterprise-License-Server"
#define LICENSE_SETTINGS2               L"CN=TS-Enterprise-License-Server"
#define LICENSE_SETTINGS_OBJECT_CLASS   L"LicensingSiteSettings"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)
#define SITES               L"sites"
#define SITES_SIZE          CWSTR_SIZE(SITES)
#define SITE_SERVER         L"siteServer"
#define SITE_FORMAT         L"LDAP://CN=%ws,CN=%ws,%ws"
#define SITE_FORMAT_SIZE    CWSTR_SIZE(SITE_FORMAT)
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define ROOT_DSE_PATH       L"LDAP://RootDSE"

HRESULT GetLicenseSettingsObjectP(VARIANT *pvar,
                                 LPWSTR *ppwszLicenseSettings,
                                 LPWSTR *ppwszSiteName,
                                 IADs **ppADs)
{
    HRESULT          hr;
    DWORD            dwErr;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs = NULL;

    VariantInit(pvar);
    
    dwErr = DsGetSiteName(NULL, ppwszSiteName);

    if (dwErr != 0)
    {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetSiteName failed %d - 0x%x\n",dwErr,HRESULT_FROM_WIN32(dwErr));
#endif
        return HRESULT_FROM_WIN32(dwErr);
    }

    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed 0x%x \n",ROOT_DSE_PATH,dwErr);
#endif
        goto CleanExit;
    }

    BSTR bstrval = SysAllocString(CONFIG_CNTNR);
    if(NULL == bstrval)
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = pADs->Get(bstrval, pvar);

    SysFreeString(bstrval);

    if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Get (%ws) failed 0x%x \n",CONFIG_CNTNR,hr);
#endif
        goto CleanExit;
    }

    if (V_VT(pvar) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Bad pvar 0x%x \n",hr);
#endif
        goto CleanExit;
    }

    pwszConfigContainer = pvar->bstrVal;  // For sake of readability.

    //
    // Build the X.500 path to the LicenseSettings object.
    //

    *ppwszLicenseSettings = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    LICENSE_SETTINGS_FORMAT_SIZE
                                        + LICENSE_SETTINGS_SIZE
                                        + DWSTR_SIZE(*ppwszSiteName)
                                        + SITES_SIZE
                                        + DWSTR_SIZE(pwszConfigContainer)
                                        + sizeof(WCHAR));

    if (*ppwszLicenseSettings == NULL) {
        hr = E_OUTOFMEMORY;
#ifdef PRIVATEDEBUG
        wprintf(L"LocalAlloc failed 0x%x \n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(*ppwszLicenseSettings,
             LICENSE_SETTINGS_FORMAT,
             LICENSE_SETTINGS,
             *ppwszSiteName,
             SITES,
             pwszConfigContainer);

    hr = ADsGetObject(*ppwszLicenseSettings, IID_IADs, (void **)ppADs);

CleanExit:

#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed? 0x%x \n",*ppwszLicenseSettings,hr);
#endif

    if (NULL != pADs) {
        pADs->Release();
    }

    return hr;
}

HRESULT
GetServerPos(IADs *pADs,
              VARIANT *pvar,
              LONG *plLower,
              LONG *plUpper,
              LONG *plPos,
              WCHAR *ComputerName
             )
{
    HRESULT          hr;
    VARIANT          var;
    SAFEARRAY        *psaServers;

    VariantInit(&var);
    BSTR bstrval = SysAllocString(SITE_SERVER);

    if(bstrval == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = pADs->GetEx(bstrval,pvar);
    
    SysFreeString(bstrval);
    
    if (FAILED(hr))
    {
        hr = S_FALSE;   // already gone
        goto CleanExit;
    }

    psaServers = V_ARRAY(pvar);
    if (NULL == psaServers)
    {
        hr = S_FALSE;      // already gone
        goto CleanExit;
    }

    hr= SafeArrayGetLBound( psaServers, 1, plLower );
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    hr= SafeArrayGetUBound( psaServers, 1, plUpper );
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    for( *plPos = *plLower; *plPos <= *plUpper; *plPos++ )
    {
        VariantClear( &var );
        hr = SafeArrayGetElement( psaServers, plPos, &var );
        if (SUCCEEDED(hr) && (V_VT(&var) == VT_BSTR) && (V_BSTR(&var) != NULL))
        {
            if (0 == lstrcmpi(V_BSTR(&var),ComputerName))
            {
                hr = S_OK;
                goto CleanExit;
            }
        }
    }

    hr = S_FALSE;

CleanExit:
    VariantClear(&var);

    return hr;
}

extern "C" 
HRESULT
PublishEnterpriseServer()
{
    LPWSTR           pwszSiteName = NULL;
    DWORD            dwErr;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs         = NULL;
    IADs *           pADs2        = NULL;
    IADsContainer *  pADsContainer = NULL;
    VARIANT          var;
    VARIANT          var2;
    VARIANT          var3;
    VARIANT          var4;
    LPWSTR           pwszLicenseSettings = NULL;
    LPWSTR           pwszSite = NULL;
    IDispatch *      pDisp = NULL;
	WCHAR            ComputerName[MAX_PATH+1];
    ULONG            ulen;
   	BOOL             br;
    HRESULT          hr;
    LONG             lLower,lUpper,lPos;
    SAFEARRAYBOUND   sabServers;
    LPWSTR           pwszDN         = NULL;
    DS_NAME_RESULT * pDsResult      = NULL;
    HANDLE           hDS;
    LPWSTR           rgpwszNames[2];
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    LPWSTR           pwszDomain;
    WCHAR            wszName[MAX_PATH + 1];
    BSTR             bstrObjectclass = NULL;
    BSTR             bstrSettings = NULL;

    //
	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE
    //
	hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    
    if (FAILED(hr))
    {
#ifdef PRIVATEDEBUG
        wprintf(L"CoInitializeEx failed 0x%lx\n",hr);
#endif
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    VariantInit(&var3);
    VariantInit(&var4);
    
    // Get the computer name of the local computer.
    ulen = sizeof(ComputerName) / sizeof(TCHAR);
    br = GetComputerName(ComputerName, &ulen);

    if (!br)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
#ifdef PRIVATEDEBUG
        wprintf(L"GetComputerName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Get domain name
    //
    hr = DsGetDcName(NULL,
                     NULL,
                     NULL,
                     NULL,
                     DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_FLAT_NAME,
                     &pDCInfo);


    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetDcName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszDomain = pDCInfo->DomainName;

    //
    // Bind to the DS (get a handle for use with DsCrackNames).
    //

    hr = DsBind(NULL, pwszDomain, &hDS);

    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsBind failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Request the DS-DN of this server's computer object.
    //

    if (lstrlen(pwszDomain) + lstrlen(ComputerName) + 3 > sizeof(wszName) / sizeof(WCHAR))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Domain or ComputerName too long\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(wszName,
             L"%ws\\%ws$",
             pwszDomain,
             ComputerName);

    rgpwszNames[0] = wszName;
    rgpwszNames[1] = NULL;

    hr = DsCrackNames(hDS,
                      DS_NAME_NO_FLAGS,
                      DS_UNKNOWN_NAME,
                      DS_FQDN_1779_NAME,
                      1,
                      &rgpwszNames[0],
                      &pDsResult);

    DsUnBind(&hDS);

    if (hr != ERROR_SUCCESS)
    {

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (pDsResult->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDsResult->rItems[0].status == DS_NAME_ERROR_RESOLVING) {
            hr = ERROR_PATH_NOT_FOUND;
        }
        else {
            hr = pDsResult->rItems[0].status;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames (%ws) result bad 0x%lx\n",ComputerName,hr);
#endif
        goto CleanExit;
    }

    V_VT(&var3) = VT_BSTR;
    pwszDN = pDsResult->rItems[0].pName;
    V_BSTR(&var3) = SysAllocString(pwszDN);
    
    if (NULL == V_BSTR(&var3))
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = GetLicenseSettingsObjectP(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);

    pwszConfigContainer = var.bstrVal;

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        // Doesn't yet exist, create it

        //
        // Build the X.500 path to the Site object.
        //

        pwszSite = (LPWSTR)LocalAlloc(LPTR,
                                      SITE_FORMAT_SIZE
                                      + DWSTR_SIZE(pwszSiteName)
                                      + SITES_SIZE
                                      + DWSTR_SIZE(pwszConfigContainer)
                                      + sizeof(WCHAR));

        if (pwszSite == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        wsprintf(pwszSite,
                 SITE_FORMAT,
                 pwszSiteName,
                 SITES,
                 pwszConfigContainer);

        hr = ADsGetObject(pwszSite,
                          IID_IADsContainer,
                          (void **)&pADsContainer);
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsGetObject (%ws) failed 0x%lx\n",pwszSite,hr);
#endif
            goto CleanExit;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"Got container (%ws)\n",pwszSite);
#endif

        //
        // Create the license settings leaf object.
        //

        bstrObjectclass = SysAllocString(LICENSE_SETTINGS_OBJECT_CLASS);

        if(NULL == bstrObjectclass)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }
        bstrSettings = SysAllocString(LICENSE_SETTINGS2);
        
        if(NULL == bstrSettings)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        hr = pADsContainer->Create(bstrObjectclass,
                                   bstrSettings,
                                   &pDisp);
    
        SysFreeString(bstrObjectclass);
    
        SysFreeString(bstrSettings);       

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Create (LICENSE_SETTINGS) failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"Created (%ws)\n",LICENSE_SETTINGS2);
#endif

        hr = pDisp->QueryInterface(IID_IADs,
                                   (void **)&pADs2);

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"QueryInterface failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

        bstrSettings = SysAllocString(SITE_SERVER);
        if(NULL == bstrSettings)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        hr = pADs2->Put(bstrSettings,var3);
        
        SysFreeString(bstrSettings);
    
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"Put (%ws) failed 0x%lx\n",SITE_SERVER,hr);
#endif
            goto CleanExit;
        }

        //
        // Persist the change via SetInfo.
        //

        hr = pADs2->SetInfo();
        
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"SetInfo (%ws)=(%ws) failed 0x%lx\n",SITE_SERVER,V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

    } else if (SUCCEEDED(hr))
    {
        // Already exists; update it

        hr = GetServerPos(pADs,&var2,&lLower,&lUpper,&lPos,pwszDN);

        if (FAILED(hr) || (hr == S_OK))
        {
#ifdef PRIVATEDEBUG
        wprintf(L"GetServerPos failed ? 0x%lx\n",hr);
#endif
            goto CleanExit;
        }

        hr = ADsBuildVarArrayStr( &(V_BSTR(&var3)), 1, &var4);
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"ADsBuildVarArrayStr (%ws) failed 0x%lx\n",V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

        bstrSettings = SysAllocString(SITE_SERVER);

        if(NULL == bstrSettings)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        hr = pADs->PutEx(ADS_PROPERTY_APPEND,bstrSettings,var4);

        SysFreeString(bstrSettings);        

        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"PutEx (%ws)=(%ws) failed 0x%lx\n",SITE_SERVER,V_BSTR(&var3),hr);
#endif
            goto CleanExit;
        }

        hr = pADs->SetInfo();
        if (FAILED(hr)) {
#ifdef PRIVATEDEBUG
        wprintf(L"SetInfo 2 failed 0x%lx\n",hr);
#endif
            goto CleanExit;
        }
    } else
    {
#ifdef PRIVATEDEBUG
        wprintf(L"GetLicenseSettingsObject failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);
    VariantClear(&var3);
    VariantClear(&var4);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (pwszSite != NULL) {
        LocalFree(pwszSite);
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (NULL != pADs2) {
        pADs2->Release();
    }

    if (NULL != pDisp) {
        pDisp->Release();
    }

    if (NULL != pADsContainer) {
        pADsContainer->Release();
    }

    if (pDsResult != NULL) {
        DsFreeNameResult(pDsResult);
    }

    if (pDCInfo != NULL) {
        NetApiBufferFree(pDCInfo); // Allocated from DsGetDcName
    }

    CoUninitialize();

    return hr;
}

extern "C"
HRESULT
UnpublishEnterpriseServer()
{
    IADs *           pADs         = NULL;
    HRESULT          hr;
    LPWSTR           pwszLicenseSettings = NULL;
    LPWSTR           pwszSiteName = NULL;
    VARIANT          var;
    VARIANT          var2;
    VARIANT          var3;
    SAFEARRAYBOUND   sabServers;
	WCHAR            ComputerName[MAX_PATH+1];
    ULONG            ulen;
   	BOOL             br;
    LONG             lPos,lLower, lUpper;
    DS_NAME_RESULT * pDsResult      = NULL;
    HANDLE           hDS;
    LPWSTR           rgpwszNames[2];
    LPWSTR           pwszDN;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    LPWSTR           pwszDomain;
    WCHAR            wszName[MAX_PATH + 1];

	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE

	hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    VariantInit(&var3);
    
    // Get the computer name of the local computer.
    ulen = sizeof(ComputerName) / sizeof(TCHAR);
    br=GetComputerName(ComputerName,
                       &ulen);
    if (!br)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanExit;
    }

    //
    // Get domain name
    //
    hr = DsGetDcName(NULL,
                     NULL,
                     NULL,
                     NULL,
                     DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_FLAT_NAME,
                     &pDCInfo);


    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsGetDcName failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    pwszDomain = pDCInfo->DomainName;

    //
    // Bind to the DS (get a handle for use with DsCrackNames).
    //

    hr = DsBind(NULL, pwszDomain, &hDS);

    if (hr != ERROR_SUCCESS) {
#ifdef PRIVATEDEBUG
        wprintf(L"DsBind failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    //
    // Request the DS-DN of this server's computer object.
    //

    if (lstrlen(pwszDomain) + lstrlen(ComputerName) + 3 > sizeof(wszName) / sizeof(WCHAR))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
#ifdef PRIVATEDEBUG
        wprintf(L"Domain or ComputerName too long\n",hr);
#endif
        goto CleanExit;
    }

    wsprintf(wszName,
             L"%ws\\%ws$",
             pwszDomain,
             ComputerName);

    rgpwszNames[0] = wszName;
    rgpwszNames[1] = NULL;

    hr = DsCrackNames(hDS,
                      DS_NAME_NO_FLAGS,
                      DS_UNKNOWN_NAME,
                      DS_FQDN_1779_NAME,
                      1,
                      &rgpwszNames[0],
                      &pDsResult);

    DsUnBind(&hDS);

    if (hr != ERROR_SUCCESS)
    {

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames failed 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    if (pDsResult->rItems[0].status != DS_NAME_NO_ERROR) {
        if (pDsResult->rItems[0].status == DS_NAME_ERROR_RESOLVING) {
            hr = ERROR_PATH_NOT_FOUND;
        }
        else {
            hr = pDsResult->rItems[0].status;
        }

#ifdef PRIVATEDEBUG
        wprintf(L"DsCrackNames result bad 0x%lx\n",hr);
#endif
        goto CleanExit;
    }

    V_VT(&var3) = VT_BSTR;
    pwszDN = pDsResult->rItems[0].pName;
    V_BSTR(&var3) = SysAllocString(pwszDN);
    
    if (NULL == V_BSTR(&var3))
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }

    hr = GetLicenseSettingsObjectP(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
    {
        hr = S_OK;      // already gone
        goto CleanExit;
    }

    if (FAILED(hr))
    {
        goto CleanExit;
    }

#ifdef PRIVATEDEBUG
        wprintf(L"pADs %ws NULL \n",(pADs == NULL) ? L"==" : L"!=");
        if (NULL == pADs)
        {
            goto CleanExit;
        }
#endif

    hr = GetServerPos(pADs,&var2,&lLower,&lUpper,&lPos,pwszDN);

    if (FAILED(hr))
    {
        goto CleanExit;
    }

    if (hr == S_FALSE)
    {
        hr = S_OK;      // Already gone
        goto CleanExit;
    }

    if (lLower == lUpper)
    {
        BSTR bstrval = SysAllocString(SITE_SERVER);
        if(NULL == bstrval)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }
        // only one element, delete
        hr = pADs->PutEx(ADS_PROPERTY_CLEAR,bstrval,var2);
        SysFreeString(bstrval);
        bstrval = NULL;
        if (FAILED(hr)) {
            goto CleanExit;
        }
    }
    else
    {
        if (lPos != lUpper)
        {
            // move the last element here
            hr = SafeArrayGetElement(V_ARRAY(&var2),&lUpper,&var3);
            if(SUCCEEDED(hr))
            {
                hr = SafeArrayPutElement(V_ARRAY(&var2),&lPos,&var3);
            }
            if (FAILED(hr))
            {
                goto CleanExit;
            }
        }

        sabServers.lLbound = lLower;
        sabServers.cElements = lUpper-lLower;

        hr = SafeArrayRedim(V_ARRAY(&var2),&sabServers);

        if(FAILED(hr))
        {
            hr = E_FAIL;
            goto CleanExit;
        }

        BSTR bstrval = SysAllocString(SITE_SERVER);
        if(NULL == bstrval)
        {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }
                    
        hr = pADs->Put(bstrval,var2);
    
        SysFreeString (bstrval);
    
        if (FAILED(hr)) {
            goto CleanExit;
        }
    }

    hr = pADs->SetInfo();
    if (FAILED(hr)) {
        goto CleanExit;
    }

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);
    VariantClear(&var3);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (pDCInfo != NULL) {
        NetApiBufferFree(pDCInfo); // Allocated from DsGetDcName
    }

    CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\debug\tslicmode\tslicmode.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <rpc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <crt/io.h>
#include <wincrypt.h>
#include <winsta.h>
#include <license.h>



/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

extern "C" void __RPC_FAR * __RPC_USER
midl_user_allocate(
    size_t Size
    )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}

/*****************************************************************************
 *
 *  MIDL_user_free
 *
 *    Handles RPC's de-allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_USER
midl_user_free(
    void __RPC_FAR *p
    )
{
    LocalFree( p );
}

void MyReportError(DWORD errCode)
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet=FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             errCode,
                             LANG_NEUTRAL,
                             (LPTSTR)&lpszTemp,
                             0,
                             NULL);

    if(dwRet != 0)
    {
        _tprintf(_TEXT("Error : %s (%d)\n"), lpszTemp, errCode);
        if(lpszTemp)
            LocalFree((HLOCAL)lpszTemp);
    }

    return;
}

void Usage(char * szName)
{
    wprintf(L"Usage: %S\n"
        L"\t-s <mode> - Set licensing mode\n"
        L"\t-g - Get licensing mode\n"
        L"\t-l - List available licensing modes\n"
        L"\t-i <mode> - Get information about licensing mode\n"
        L"\n"
        L"\t\t0:\tPersonal Terminal Server\n"
        L"\t\t1:\tRemote Administration\n"
        L"\t\t2:\tPer Seat\n"
        L"\t\t3:\tInternet Connector\n"
        L"\t\t4:\tPer User\n"
            ,
            szName
        );
    return;
}

int __cdecl main(int argc, char *argv[])
{
    DWORD       dwStatus;
    DWORD       dwNewStatus;
    BOOL        fSet = FALSE;
    BOOL        fGet = FALSE;
    BOOL        fList = FALSE;
    BOOL        fInfo = FALSE;
    ULONG       ulMode;
    HANDLE      hServer = NULL;
    BOOL        fRet;
    ULONG       *pulPolicyIds = NULL;
    ULONG       cPolicies;
    ULONG       ulInfoStructVersion = LCPOLICYINFOTYPE_CURRENT;
    LPLCPOLICYINFO_V1W pPolicyInfo = NULL;

    if (argc < 2)
    {
        Usage(argv[0]);
        goto cleanup;
    }

    if ((argv[1][1] == 's') || (argv[1][1] == 'S'))
    {
        if (argc < 3)
        {
            Usage(argv[0]);
            goto cleanup;
        }

        ulMode = atol(argv[2]);

        fSet = TRUE;
    }
    else if ((argv[1][1] == 'i') || (argv[1][1] == 'I'))
    {
        if (argc < 3)
        {
            Usage(argv[0]);
            goto cleanup;
        }

        ulMode = atol(argv[2]);

        fInfo = TRUE;
    }
    else if ((argv[1][1] == 'g') || (argv[1][1] == 'G'))
    {
        fGet = TRUE;
    }
    else if ((argv[1][1] == 'l') || (argv[1][1] == 'L'))
    {
        fList = TRUE;
    }
    else
    {
        Usage(argv[0]);
        goto cleanup;
    }

    hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        wprintf(L"Connect to server failed\n");
        MyReportError(GetLastError());
        goto cleanup;
    }

    if (fGet)
    {
        fRet = ServerLicensingGetPolicy(
                                        hServer,
                                        &ulMode
                                        );

        wprintf(L"Get Mode\n");

        if (fRet)
        {
            wprintf(L"Mode: %d\n"
                    ,
                    ulMode
                    );
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
    }
    else if (fList)
    {
        fRet = ServerLicensingGetAvailablePolicyIds(
                                                    hServer,
                                                    &pulPolicyIds,
                                                    &cPolicies
                                                    );
        wprintf(L"List Modes\n");

        if (fRet)
        {
            wprintf(L"Modes: \n");

            for (ULONG i = 0; i < cPolicies; i++)
            {
                wprintf(L"%d "
                        ,
                        pulPolicyIds[i]
                        );
            }

            wprintf(L"\n");

            MIDL_user_free(pulPolicyIds);
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
    }
    else if (fSet)
    {
        dwStatus = ServerLicensingSetPolicy(hServer,
                                            ulMode,
                                            &dwNewStatus);

        wprintf(L"Set Mode\n"
                L"RPC Status: %d\n"
                L"New Mode Status: %d\n"
                ,
                dwStatus,
                dwNewStatus
                );

        if (ERROR_SUCCESS != dwStatus)
            MyReportError(dwStatus);
        else if (ERROR_SUCCESS != dwNewStatus)
            MyReportError(dwNewStatus);

    }
    else if (fInfo)
    {
        fRet = ServerLicensingGetPolicyInformation(
                                                   hServer,
                                                   ulMode,
                                                   &ulInfoStructVersion,
                                                   (LPLCPOLICYINFOGENERIC *) &pPolicyInfo
                                                   );

        if (fRet)
        {
            wprintf(L"Get Mode Info\n"
                    L"Name: %s\n"
                    L"Description: %s\n"
                    ,
                    pPolicyInfo->lpPolicyName,
                    pPolicyInfo->lpPolicyDescription
                );

            ServerLicensingFreePolicyInformation((LPLCPOLICYINFOGENERIC *)&pPolicyInfo);
        }
        else
        {
            wprintf(L"Failed\n");
            MyReportError(GetLastError());
        }
}

    ServerLicensingClose(hServer);

cleanup:

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\esetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       esetup.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-02-98   RobLeit     Created
//
//----------------------------------------------------------------------------

#ifndef __ESETUP_H__
#define __ESETUP_H__

#ifdef __cplusplus
extern "C" {
#endif

HRESULT PublishEnterpriseServer();
HRESULT UnpublishEnterpriseServer();

#ifdef __cplusplus
};
#endif

#endif // __ESETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\hpool.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef __HANDLE_POOL_H__
#define __HANDLE_POOL_H__

#include <windows.h>
#include <limits.h>
#include "locks.h"


/////////////////////////////////////////////////////////////////////////////
//
//  handle pool template class
//
//  Note that STL's LIST class is used instead of VECTOR
//
/////////////////////////////////////////////////////////////////////////////
template<class T, DWORD max=ULONG_MAX>
class CHandlePool 
{
private:
    long m_NumWaiting;

    // HUEIWANG 1/23/98
    // C++ compiler 10.00.5256 can't compile STL
    // _STD list<T> m_Handles;                // STL's list 

    typedef struct _HandleList {
        BOOL bAvailable;
        T m_Value;
        struct _HandleList *next;
    } HandleList, *LPHandleList;

    //
    // List of handles in the pool
    //
    LPHandleList m_Handles;
    DWORD m_TotalHandles;

    //
    // Semaphore for available handles
    //
    CTSemaphore<0, LONG_MAX> m_Available;

    // critical section guarding m_Handles.
    CCriticalSection m_CS;                  
    
    //DWORD m_MaxHandles;                     

public:

    CHandlePool();
    ~CHandlePool();   

    HRESULT 
    AcquireHandle(
        T* pHandle, 
        DWORD dwWaitFile=INFINITE
    );

    BOOL
    AcquireHandleEx(
        IN HANDLE hWaitHandle,
        IN OUT T* pHandle, 
        IN DWORD dwWaitFime=INFINITE
    );

    void 
    ReleaseHandle(
        T pRetHandle
    );

    DWORD 
    GetNumberAvailable();

    DWORD 
    GetMaxHandles() { 
        return max; 
    }
};

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline CHandlePool<T, max>::CHandlePool()
{
    // m_MaxHandles=max;

    m_NumWaiting=0;
    m_Handles=NULL;
    m_TotalHandles=0;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline CHandlePool<T, max>::~CHandlePool()
{
    // delete all handles still in cache
    // might result in handle leak.
    //for(_STD list<T>::iterator it=m_Handles.begin(); it != m_Handles.end(); it++)
    //    delete it;

    while(m_Handles)
    {
        LPHandleList ptr;

        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
    }
}

//--------------------------------------------------------------------------------    

template<class T, DWORD max>
inline BOOL 
CHandlePool<T, max>::AcquireHandleEx(
    IN HANDLE hWaitHandle,
    IN OUT T* pHandle, 
    IN DWORD dwWaitFime /* infinite */
    )
/*
*/
{
    BOOL bSuccess;

    InterlockedIncrement(&m_NumWaiting);
    bSuccess = m_Available.AcquireEx(
                                hWaitHandle, 
                                dwWaitFime, 
                                FALSE
                            );

    // Available is a semaphore not mutex object.
    if(bSuccess == TRUE)
    {
        // Object Constructor will lock critical section and
        // destructor will unlock critical section
        CCriticalSectionLocker locker(m_CS);

        //assert(m_Handles.size());
        //*pHandle = m_Handles.front();
        //m_Handles.pop_front();
        LPHandleList ptr;

        assert(m_Handles != NULL);
        *pHandle = m_Handles->m_Value;
        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
        m_TotalHandles--;
    }

    InterlockedDecrement(&m_NumWaiting);
    return bSuccess;
}


//--------------------------------------------------------------------------------    
template<class T, DWORD max>
inline HRESULT CHandlePool<T, max>::AcquireHandle(
    IN OUT T* pHandle, 
    IN DWORD dwWaitFime /* infinite */
    )
/*
*/
{
    DWORD status;

    InterlockedIncrement(&m_NumWaiting);
    status = m_Available.Acquire(dwWaitFime, FALSE);

    // Available is a semaphore not mutex object.
    if(status == WAIT_OBJECT_0)
    {
        // Object Constructor will lock critical section and
        // destructor will unlock critical section
        CCriticalSectionLocker locker(m_CS);

        //assert(m_Handles.size());
        //*pHandle = m_Handles.front();
        //m_Handles.pop_front();
        LPHandleList ptr;

        assert(m_Handles != NULL);
        *pHandle = m_Handles->m_Value;
        ptr=m_Handles;
        m_Handles = m_Handles->next;
        delete ptr;
        m_TotalHandles--;

        status = ERROR_SUCCESS;
    }

    InterlockedDecrement(&m_NumWaiting);
    return status;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline void CHandlePool<T, max>::ReleaseHandle(
    T pRetHandle
    )
/*
*/
{
    if(pRetHandle)
    {
        CCriticalSectionLocker lock(m_CS);
        if( InterlockedExchange(&m_NumWaiting, m_NumWaiting) > 0 || 
            m_TotalHandles < max)
        {
            //m_Handles.push_back(pRetHandle);
            LPHandleList ptr;

            ptr = new HandleList;
            ptr->m_Value = pRetHandle;
            ptr->next = m_Handles;
            m_Handles = ptr;
            m_TotalHandles++;
            m_Available.Release(1);
        }
        else
        {
            // only cache so many handles.
            delete pRetHandle;
        }
    }

    return;
}

//--------------------------------------------------------------------------------
template<class T, DWORD max>
inline DWORD CHandlePool<T, max>::GetNumberAvailable()
{
    UINT numAvailable;

    m_CS.Lock();

    // numAvailable = m_Handles.size();
    numAvailable = m_TotalHandles;

    m_CS.UnLock();
    return numAvailable;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\lscommon.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        lscommon.h
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __LSCOMMON_H__
#define __LSCOMMON_H__

//
// Setup related
//
#define SZAPPNAME                       "lserver"
#define SZSERVICENAME                   "TermServLicensing"
#define SZSERVICEDISPLAYNAME            "Terminal Server Licensing"
#define LSERVER_DEFAULT_DBDIR           "lserver"
#define SZDEPENDENCIES                  "RPCSS\0\0"
#define SZACCESSDRIVERNAME              "Microsoft Access Driver (*.mdb)"

//
// These are the old locations, only used to migrate
//

#define LSERVER_LSA_PASSWORD_KEYNAME_OLD     _TEXT("TermServLiceningPwd-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LASTRUN_OLD              _TEXT("TermServLicensingStatus-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_SETUPID_OLD              _TEXT("TermServLicensingSetupId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_PRIVATEKEY_SIGNATURE_OLD _TEXT("TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_PRIVATEKEY_EXCHANGE_OLD  _TEXT("TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LSERVERID_OLD            _TEXT("TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

//
// These are the new locations, with an L$ prepended so that only local callers
// can read or write
//

#define LSERVER_LSA_PASSWORD_KEYNAME         _TEXT("L$TermServLiceningPwd-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LASTRUN                  _TEXT("L$TermServLicensingStatus-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_SETUPID                  _TEXT("L$TermServLicensingSetupId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_PRIVATEKEY_SIGNATURE     _TEXT("L$TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_PRIVATEKEY_EXCHANGE      _TEXT("L$TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")

#define LSERVER_LSA_LSERVERID                _TEXT("L$TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080d")


//
// Keep this here for License Server OC setup.
//
#define LSERVER_LSA_STRUCT_VERSION      0x00010000  // version 1.0
typedef struct {
    DWORD dwVersion;
    DWORD dwMaxKeyPackId;
    DWORD dwMaxLicenseId;
} TLServerLastRunState, *LPTLServerLastRunState;

#define LSERVER_LSA_LASTRUN_VER_CURRENT LSERVER_LSA_STRUCT_VERSION20
typedef struct {
    DWORD dwVersion;
    DWORD dwMaxKeyPackId;
    DWORD dwMaxLicenseId;
    FILETIME ftLastShutdownTime;
} TLServerLastRun, *LPTLServerLastRun;

#define LSERVER_LSA_STRUCT_VERSION20    0x00020000

#define LSERVER_DEFAULT_DBPATH          _TEXT("%SYSTEMROOT%\\SYSTEM32\\LSERVER\\")
#define LSERVER_DEFAULT_USER            _TEXT("sa")
#define LSERVER_DEFAULT_PWD             _TEXT("password")
#define LSERVER_DEFAULT_EDB             _TEXT("TLSLic.edb")
#define LSERVER_DEFAULT_EMPTYEDB        _TEXT("Empty.edb")


//-----------------------------------------------------------------------------
//
// TODO - client need to define this
//
#define LSERVER_DISCOVERY_PARAMETER_KEY "Software\\Microsoft\\MSLicensing\\Parameters"
#define LSERVER_LOOKUP_TIMEOUT          "TimeOut"
#define LSERVER_LOOKUP_DEFAULT_TIMEOUT  1*1000  // default to 1 second timeout


//-----------------------------------------------------------------------------
//
// RPC 
//
#define RPC_ENTRYNAME           "/.:/HydraLSFrontEnd"
#define RPC_PROTOSEQTCP         "ncacn_ip_tcp"
#define RPC_PROTOSEQLPC         "ncalrpc"

 
#define RPC_PROTOSEQNP          "ncacn_np" 
#define HLSPIPENAME             "HydraLsPipe"
#define LSNAMEPIPE              "\\pipe\\HydraLsPipe"


#define SERVERMAILSLOTNAME     "HydraLsServer"
#define CLIENTMAILSLOTNAME     "HydraLsClient"


#define MAX_MAILSLOT_MSG_SIZE   MAX_COMPUTERNAME_LENGTH+_MAX_PATH+80

//
// Currently supported mailslot protocol
//
#define LSERVER_DISCOVERY       "DISC"
#define LSERVER_CHALLENGE       "CHAL"
#define LSERVER_OPEN_BLK        '<'
#define LSERVER_CLOSE_BLK       '>'

// -------------------------------------------------------------------------------
//
// Current database version
//
//

#define W2K_BETA3_JETBLUE_DBVERSION     0x00000001
#define W2K_RTM_JETBLUE_DBVERSION       0x00000002
#define ENFORCE_JETBLUE_DBVERSION       0x80000000

#ifdef ENFORCE_LICENSING

#define TLS_BETA_DBVERSION      ENFORCE_JETBLUE_DBVERSION | W2K_BETA3_JETBLUE_DBVERSION
#define TLS_CURRENT_DBVERSION   ENFORCE_JETBLUE_DBVERSION | W2K_RTM_JETBLUE_DBVERSION

#else

#define TLS_BETA_DBVERSION      W2K_BETA3_JETBLUE_DBVERSION
#define TLS_CURRENT_DBVERSION   W2K_RTM_JETBLUE_DBVERSION

#endif

#define IS_ENFORCE_VERSION(x) (x & 0x80000000)
#define DATABASE_VERSION(x) (x & 0x7FFFFFFF)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\tlsassrt.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSASSERT_H__
#define __TLSASSERT_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#define TLSASSERT(exp)  ASSERT(exp)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\locks.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        
//
// Contents:    
//
// History:     12-09-97    HueiWang    
//
//---------------------------------------------------------------------------
#ifndef __LS_LOCKS_H
#define __LS_LOCKS_H

#include <windows.h>
#include "assert.h"
extern BOOL g_bLockValid;

#define ARRAY_COUNT(a) sizeof(a) / sizeof(a[0])

typedef enum { WRITER_LOCK, READER_LOCK, NO_LOCK } RWLOCK_TYPE;
//-------------------------------------------------------------------------
template <int init_count, int max_count>
class CTSemaphore {
private:
    HANDLE m_semaphore;

public:
    CTSemaphore() : m_semaphore(NULL)
    { 
        m_semaphore=CreateSemaphore(NULL, init_count, max_count, NULL); 
        assert(m_semaphore != NULL);
    }

    ~CTSemaphore()                 
    { 
        if(m_semaphore) 
            CloseHandle(m_semaphore); 
    }

    DWORD Acquire(int WaitTime=INFINITE, BOOL bAlertable=FALSE) 
    { 
        if(m_semaphore == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        return WaitForSingleObjectEx(m_semaphore, WaitTime, bAlertable);
    }

    BOOL
    AcquireEx(
            HANDLE hHandle, 
            int dwWaitTime=INFINITE, 
            BOOL bAlertable=FALSE
        ) 
    /*++

    --*/
    { 
        BOOL bSuccess = TRUE;
        DWORD dwStatus;
        HANDLE hHandles[] = {m_semaphore, hHandle};

        if(hHandle == NULL || hHandle == INVALID_HANDLE_VALUE)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            bSuccess = FALSE;
        }
        else
        {
            if(m_semaphore == NULL || hHandle == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            dwStatus = WaitForMultipleObjectsEx(
                                        sizeof(hHandles)/sizeof(hHandles[0]),
                                        hHandles,
                                        FALSE,
                                        dwWaitTime,
                                        bAlertable
                                    );

            if(dwStatus != WAIT_OBJECT_0)
            {
                bSuccess = FALSE;
            }
        }

        return bSuccess;
    }


    BOOL Release(long count=1)          
    { 
        if(m_semaphore == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        return ReleaseSemaphore(m_semaphore, count, NULL); 
    }

    BOOL IsGood()
    { 
        return m_semaphore != NULL; 
    }
};
//-------------------------------------------------------------------------
class CCriticalSection {
    CRITICAL_SECTION m_CS;
    BOOL m_bGood;
public:
    CCriticalSection(
        DWORD dwSpinCount = 4000    // see InitializeCriticalSection...
    ) : m_bGood(TRUE)
    { 
        
        __try {
            if(!InitializeCriticalSectionAndSpinCount(&m_CS,  dwSpinCount))
                m_bGood = FALSE;
        } 
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError(GetExceptionCode());
            m_bGood = FALSE;
        }
    }

    ~CCriticalSection()              
    { 
        if(IsGood() == TRUE)
        {
            DeleteCriticalSection(&m_CS); 
        }
    }

    BOOL
    IsGood() { return m_bGood; }

    void Lock() 
    {
        if(IsGood() == TRUE)
        {       
            EnterCriticalSection(&m_CS);
        }
    }

    void UnLock()
    {
        if(IsGood() == TRUE)
        {
            LeaveCriticalSection(&m_CS);
        }
    }

    BOOL TryLock()
    {
        if(IsGood() == TRUE)
        {
            return TryEnterCriticalSection(&m_CS);
        }
        else
            return FALSE;
    }
};
//--------------------------------------------------------------------------
class CCriticalSectionLocker {
public:
    CCriticalSectionLocker( CCriticalSection& m ) : m_cs(m) 
    { 
        m.Lock(); 
    }

    ~CCriticalSectionLocker() 
    { 
        m_cs.UnLock(); 
    }
private:
    CCriticalSection& m_cs;
};

//-----------------------------------------------------------
class CSafeCounter {
private:
    //CCriticalSection m_cs;
    long m_Counter;

    //inline void 
    //Lock() 
    //{
    //    m_cs.Lock();
    //}

    //inline void 
    //Unlock() 
    //{
    //    m_cs.UnLock();
    //}

public:

    CSafeCounter(
        long init_value=0
        ) : 
        m_Counter(init_value) 
    /*++

    --*/
    {
    }

    ~CSafeCounter() 
    {
    }

    operator+=(long dwValue)
    {
        long dwNewValue;

        //Lock();
        //dwNewValue = (m_Counter += dwValue);
        //Unlock();
        //return dwNewValue;

        dwNewValue = InterlockedExchangeAdd( &m_Counter, dwValue );
        return dwNewValue += dwValue;
    }

    operator-=(long dwValue)
    {
        long dwNewValue;

        //Lock();
        //dwNewValue = (m_Counter -= dwValue);
        //Unlock();
        //return dwNewValue;

        dwNewValue = InterlockedExchangeAdd( &m_Counter, -dwValue );
        return dwNewValue -= dwValue;
    }

    operator++() 
    {
        //long dwValue;
        //Lock();
        //dwValue = ++m_Counter;
        //Unlock();
        //return dwValue;        

        return InterlockedIncrement(&m_Counter);
    }

    operator++(int) 
    {
        //long dwValue;
        //Lock();
        //dwValue = m_Counter++;
        //Unlock();
        //return dwValue;

        long lValue;
        lValue = InterlockedIncrement(&m_Counter);
        return --lValue;
    }

    operator--() 
    {
        //long dwValue;
        //Lock();
        //dwValue = --m_Counter;
        //Unlock();
        //return dwValue;        

        return InterlockedDecrement(&m_Counter);
    }

    operator--(int) 
    {
        //long dwValue;

        //Lock();
        //dwValue = m_Counter--;
        //Unlock();
        //return dwValue;        
        long lValue;

        lValue = InterlockedDecrement(&m_Counter);
        return ++lValue;
    }

    operator long()
    {
        //long lValue;

        //Lock();
        //lValue = m_Counter;
        //Unlock();
        //return lValue;

        return InterlockedExchange(&m_Counter, m_Counter);
    }

    //operator DWORD()
    //{
    //    long dwValue;

    //    Lock();
    //    dwValue = m_Counter;
    //    Unlock();
    //    return dwValue;
    //}

    operator=(const long dwValue)
    {
        //Lock();
        //m_Counter = dwValue;
        //Unlock();
        //return dwValue;

        InterlockedExchange(&m_Counter, dwValue);
        return dwValue;
    }
};    

//-------------------------------------------------------------------------
// HueiWang 12/23/97 need more testing...
class CRWLock 
{ 
private:
    HANDLE hMutex;
    HANDLE hWriterMutex;
    HANDLE hReaderEvent;
    long   iReadCount;
    long   iWriteCount;

    long   iReadEntry;
    long   iWriteEntry;

public:

    CRWLock()  
    { 
        BOOL bSuccess=Init(); 
        assert(bSuccess == TRUE);
    }

    ~CRWLock() 
    { 
        Cleanup();  
    }

    //-----------------------------------------------------------
    BOOL 
    Init()
    {
        hReaderEvent=CreateEvent(NULL,TRUE,FALSE,NULL);
        hMutex = CreateEvent(NULL,FALSE,TRUE,NULL);
        hWriterMutex = CreateMutex(NULL,FALSE,NULL);
        if(!hReaderEvent || !hMutex || !hWriterMutex)
            return FALSE;

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;

        return (TRUE);
    }

    //-----------------------------------------------------------
    void 
    Cleanup()
    {
        if(hReaderEvent != NULL)
        {
            CloseHandle(hReaderEvent);
        }
        if(hMutex != NULL)
        {
            CloseHandle(hMutex);
        }
        if(hWriterMutex != NULL)
        {
            CloseHandle(hWriterMutex);
        }

        iReadCount = -1;
        iWriteCount = -1;
        iReadEntry = 0;
        iWriteEntry = 0;
    }

    //-----------------------------------------------------------
    void 
    Acquire(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        {  
            InterlockedIncrement(&iWriteCount);
            if(hWriterMutex != NULL)
            {
                WaitForSingleObject(hWriterMutex,INFINITE);
            }
            if(hMutex != NULL)
            {
                WaitForSingleObject(hMutex, INFINITE);
            }

            assert(InterlockedIncrement(&iWriteEntry) == 1);
            assert(InterlockedExchange(&iReadEntry, iReadEntry) == 0);
        } 
        else 
        {
            if(hReaderEvent != NULL)
            {
                if (InterlockedIncrement(&iReadCount) == 0) 
                { 
                    if(hMutex != NULL)
                    {
                        WaitForSingleObject(hMutex, INFINITE);
                    }
                    SetEvent(hReaderEvent);
                }

                WaitForSingleObject(hReaderEvent,INFINITE);
            }
            InterlockedIncrement(&iReadEntry);
            assert(InterlockedExchange(&iWriteEntry, iWriteEntry) == 0);
        }
    }

    //-----------------------------------------------------------
    void 
    Release(
        RWLOCK_TYPE lockType
        )
    /*++

    ++*/
    {
        if (lockType == WRITER_LOCK) 
        { 
            InterlockedDecrement(&iWriteEntry);
            InterlockedDecrement(&iWriteCount);
            if(hMutex != NULL)
            {
                SetEvent(hMutex);
            }
            if(hWriterMutex != NULL)
            {
                ReleaseMutex(hWriterMutex);
            }
        } 
        else if(lockType == READER_LOCK) 
        {
            InterlockedDecrement(&iReadEntry);
            if (InterlockedDecrement(&iReadCount) < 0) 
            {
              if(hReaderEvent != NULL)
              {
                ResetEvent(hReaderEvent);
              }
              if(hMutex != NULL)
              {
                SetEvent(hMutex);
              }
            }
        }
    }

    long GetReadCount()   
    { 
        return iReadCount+1;  
    }

    long GetWriteCount()  
    { 
        return iWriteCount+1; 
    }
};

//---------------------------------------------------------------------
// 
//
class CCMutex {
public:
    HANDLE  hMutex;

    CCMutex() : hMutex(NULL) { 
        hMutex=CreateMutex(NULL, FALSE, NULL); 
    }

    ~CCMutex() { 
        if(hMutex != NULL)
        {
            CloseHandle(hMutex); 
        }
    }  

    DWORD Lock(
            DWORD dwWaitTime=INFINITE, 
            BOOL bAlertable=FALSE
    ) 
    { 
        if(hMutex != NULL)
        {
            return WaitForSingleObjectEx(
                            hMutex, 
                            dwWaitTime, 
                            bAlertable);
        }
        else
        {
            return WAIT_FAILED;
        }
    }

    BOOL Unlock() {
        if(hMutex != NULL)
        {
            return ReleaseMutex(hMutex);
        }
        else
            return FALSE;
    }
};

//---------------------------------------------------------------------------------

class CCEvent {
    BOOL    bManual;

public:
    HANDLE  hEvent;
    

    CCEvent(
        BOOL bManual, 
        BOOL bInitState) : 
    hEvent(NULL), 
    bManual(bManual) 
    {        
        hEvent=CreateEvent(
                        NULL, 
                        bManual, 
                        bInitState, 
                        NULL);
        g_bLockValid = TRUE;
    }

    ~CCEvent() {
        if(hEvent)
        {
            CloseHandle(hEvent);
        }
        g_bLockValid = FALSE;
    }

    DWORD Lock( DWORD dwWaitTime=INFINITE, 
                BOOL bAlertable=FALSE) 
    {
        if(hEvent)
        {
            return WaitForSingleObjectEx(
                            hEvent, 
                            dwWaitTime, 
                            bAlertable);
        }
        else
            return WAIT_FAILED;
    
    }

    BOOL SetEvent() {
        if(hEvent)
        {
            return ::SetEvent(hEvent);
        }
        else
            return FALSE;
    }

    BOOL ResetEvent() {
        if(hEvent)
        {
            return ::ResetEvent(hEvent);
        }
        else
            return FALSE;
    }

    BOOL PulseEvent() {
        if(hEvent)
        {
            return ::PulseEvent(hEvent);
        }
        else
            return FALSE;
    }

    BOOL IsManual() {
        return bManual;
    }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\tlsstl.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
// stl.h supplemental header
#ifndef _STL_H_
#define _STL_H_
#include <algorithm>
#include <deque>
#include <functional>
#include <iterator>
#include <list>
#include <map>
#include <memory>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <utility>
#include <vector>
using namespace std;


#endif	/* _STL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\trust.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSTRUST_H__
#define __TLSTRUST_H__


#define RANDOM_CHALLENGE_DATASIZE   32  // 128 bits data.
#define RUN_MD5_HASH_TIMES          5   // time to hash data.

#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI
TLSEstablishTrustWithServer(
    IN TLS_HANDLE hHandle,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSGenerateRandomChallengeData(
    IN HCRYPTPROV hCryptProv,
    IN PBYTE* ppbChallengeData,
    IN PDWORD pcbChallengeData
);

DWORD WINAPI
TLSVerifyChallengeResponse(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallengeData,
    IN PTLSCHALLENGERESPONSEDATA pServerChallengeResponseData
);

DWORD
TLSGenerateChallengeResponseData(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pChallengeData,
    OUT PBYTE* pbResponseData,
    OUT PDWORD cbResponseData
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\include\tlsapip.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef __TLSAPIP_H__
#define __TLSAPIP_H__

#include <wincrypt.h>
#include "tlsapi.h"
#include "tlsrpc.h"

#define TLSCERT_TYPE_EXCHANGE    1
#define TLSCERT_TYPE_SIGNATURE   2

#define ENTERPRISE_SERVER_MULTI   L"EnterpriseServerMulti"

#define TLS_RTM_VERSION_BIT 0x20000000
#define IS_LSSERVER_RTM(x) ((x & TLS_RTM_VERSION_BIT) > 0)

#define TLS_VERSION_ENTERPRISE_BIT  0x80000000
#define CURRENT_TLSERVER_VERSION(version)  HIBYTE(LOWORD(version))

#define GET_LSSERVER_MAJOR_VERSION(version)   HIBYTE(LOWORD(version))
#define GET_LSSERVER_MINOR_VERSION(version)   LOBYTE(LOWORD(version))
#define IS_ENFORCE_LSSERVER(version) \
    ((version & 0x40000000) > 0)

//#define PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY (30)  /* 30 seconds */
#define PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY (60*60*24*7)  /* 7 days */

//
// TLSInstallCertificate() certificate type.
//
#define CERTIFICATE_CA_TYPE     1
#define CERTITICATE_MF_TYPE     2
#define CERTIFICATE_CH_TYPE     3
#define CERTIFICATE_SPK_TYPE    4

#define CERTIFICATE_LEVEL_ROOT  0

typedef struct _LSHydraCertRequest {
    DWORD                   dwHydraVersion;
    PBYTE                   pbEncryptedHwid;
    DWORD                   cbEncryptedHwid;
    LPTSTR                  szSubjectRdn;
    PCERT_PUBLIC_KEY_INFO   SubjectPublicKeyInfo;
    DWORD                   dwNumCertExtension;
    PCERT_EXTENSION         pCertExtensions;
} LSHydraCertRequest, *LPLSHydraCertRequest, *PLSHydraCertRequest;


#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI
RequestToTlsRequest( 
    const LICENSEREQUEST* lpRequest, 
    TLSLICENSEREQUEST* lpRpcRequest 
);

DWORD WINAPI
TlsRequestToRequest(
    TLSLICENSEREQUEST* lpRpcRequest ,
    LICENSEREQUEST* lpRequest
);

DWORD WINAPI 
TLSReplicateKeyPack(
    TLS_HANDLE hHandle,
    DWORD cbLsIdentification,
    PBYTE pbLsIdentification,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
);

DWORD WINAPI 
TLSAuditLicenseKeyPack(
    TLS_HANDLE hHandle,
    DWORD dwKeyPackId,
    FILETIME ftStartTime,
    FILETIME ftEndTime,
    BOOL bResetCounter,
    LPTLSKeyPackAudit lplsAudit,
    PDWORD dwErrCode
);

DWORD WINAPI
TLSRetrieveTermServCert( 
    TLS_HANDLE hHandle,
    DWORD cbResponseData,
    PBYTE pbResponseData,
    PDWORD cbCert,
    PBYTE* pbCert,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSRequestTermServCert( 
    TLS_HANDLE hHandle,
    LPLSHydraCertRequest pRequest,
    PDWORD cbChallengeData,
    PBYTE* pbChallengeData,
    PDWORD pdwErrCode
);

DWORD WINAPI 
TLSInstallCertificate( 
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     DWORD dwCertLevel,
     DWORD cbSingnatureCert,
     PBYTE pbSingnatureCert,
     DWORD cbExchangeCert,
     PBYTE pbExchangeCert,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerCertificate( 
     TLS_HANDLE hHandle,
     BOOL bSignCert,
     PBYTE *ppCertBlob,
     PDWORD pdwCertBlobLen,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSRegisterLicenseKeyPack( 
     TLS_HANDLE hHandle,
     LPBYTE pbCHCertBlob,
     DWORD cbCHCertBlobSize,
     LPBYTE pbRootCertBlob,
     DWORD cbRootCertBlob,
     LPBYTE lpKeyPackBlob,
     DWORD dwKeyPackBlobLen,
     PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetLSPKCS10CertRequest(
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     PDWORD pcbdata,
     PBYTE* ppbData,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSKeyPackAdd( 
     TLS_HANDLE hHandle,
     LPLSKeyPack lpKeypack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackSetStatus( 
     TLS_HANDLE hHandle,
     DWORD dwSetParm,
     LPLSKeyPack lpKeyPack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseSetStatus( 
     TLS_HANDLE hHandle,
     DWORD dwSetParam,
     LPLSLicense lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSReturnKeyPack( 
     TLS_HANDLE hHandle,
     DWORD dwKeyPackId,
     DWORD dwReturnReason,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSReturnLicense( 
    TLS_HANDLE hHandle,
    DWORD dwKeyPackId,
    DWORD dwLicenseId,
    DWORD dwReturnReason,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSAnnounceServer(
    TLS_HANDLE hHandle,
    DWORD dwType,
    FILETIME* ftTime,
    LPTSTR pszSetupId,
    LPTSTR pszDomainName,
    LPTSTR pszMachineName,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSLookupServer(
    TLS_HANDLE hHandle,
    LPTSTR pszLookupSetupId,
    LPTSTR pszLsSetupId,
    PDWORD pcbSetupId,
    LPTSTR pszDomainName,
    PDWORD pcbDomainName,
    LPTSTR pszLsName,
    PDWORD pcbMachineName,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSLookupServerFixed(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR *pszLsSetupId,
    OUT LPTSTR *pszDomainName,
    OUT LPTSTR *pszLsName,
    IN OUT PDWORD pdwErrCode
    );

DWORD WINAPI
TLSAnnounceLicensePack(
    TLS_HANDLE hHandle,
    PTLSReplRecord pReplRecord,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnLicensedProduct( 
    PCONTEXT_HANDLE phContext,
    PTLSLicenseToBeReturn pClientLicense,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSTriggerReGenKey(
    IN TLS_HANDLE hHandle,
    IN BOOL bReserved,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSSetTlsPrivateData(
    IN TLS_HANDLE hHandle,
    IN DWORD dwPrivateDataType,
    IN PTLSPrivateDataUnion pPrivateData,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetTlsPrivateData(
    IN TLS_HANDLE hHandle,
    IN DWORD dwGetDataType,
    IN PTLSPrivateDataUnion pGetParm,
    OUT PDWORD pdwRetDataType,
    OUT PTLSPrivateDataUnion* ppRetData,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSResponseServerChallenge(
    IN TLS_HANDLE hHandle,
    IN PTLSCHALLENGERESPONSEDATA pClientResponse,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSChallengeServer(
    IN TLS_HANDLE hHandle,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallenge,
    OUT PTLSCHALLENGERESPONSEDATA* ppServerResponse,
    OUT PTLSCHALLENGEDATA* ppServerChallenge,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSTelephoneRegisterLKP(
    TLS_HANDLE hHandle,
    DWORD cbData,
    PBYTE pbData,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerUniqueId(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerPID(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetServerSPK(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbByte,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSDepositeServerSPK(
    TLS_HANDLE hHandle,
    DWORD cbSPK,
    PBYTE pbSPK,
    PCERT_EXTENSIONS pCertExtensions,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSAllocateInternetLicense(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PDWORD pcbLicense,
    OUT PBYTE* ppbLicense,
    IN OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnInternetLicense(
    IN TLS_HANDLE hHandle,
    IN const DWORD cbLicense,
    IN const PBYTE pbLicense,
    OUT PDWORD pdwErrCode
);


DWORD WINAPI
TLSAllocateInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PTLSInternetLicense pInternetLicense,
    OUT PDWORD pdwErrCode
);

DWORD WINAPI
TLSReturnInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const LICENSEREQUEST* pRequest,
    IN const ULARGE_INTEGER* pulSerialNumber,
    IN const DWORD dwQuantity,
    OUT PDWORD pdwErrCode
);

BOOL
TLSIsBetaNTServer();

BOOL
TLSIsLicenseEnforceEnable();

BOOL
TLSRefreshLicenseServerCache(
    DWORD dwTimeOut
);

DWORD WINAPI
TLSGenerateCustomerCert(
    IN TLS_HANDLE hHandle,
    DWORD dwCertEncodingType,
    DWORD dwNameAttrCount,
    CERT_RDN_ATTR rgNameAttr[],
    DWORD *pcbCert,
    BYTE **ppbCert,
    DWORD *pdwErrCode
);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\license\tlserver\jetblue\jetblue.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#include "JetBlue.h"
#include "locks.h"


#ifdef USE_SINGLE_JET_CALL
CCriticalSection g_JetCallLock;
#define SINGLE_JET_CALL  CCriticalSectionLocker lock(g_JetCallLock)
#else
#define SINGLE_JET_CALL
#endif


DWORD
DeleteFilesInDirectory(
    IN LPTSTR szDir,
    IN LPTSTR szFilesToBeDelete,
    IN BOOL bIncludeSubdir
    )
/*++


--*/
{
    TCHAR  szFile[MAX_PATH+1];
    HANDLE hFile;
    WIN32_FIND_DATA findData;
    BOOL bSuccess = TRUE;
    DWORD dwStatus = ERROR_SUCCESS;

    if (lstrlen(szDir) + lstrlen(szFilesToBeDelete) + 2 > sizeof(szFile) / sizeof(TCHAR))
    {
        return ERROR_INVALID_DATA;
    }

    wsprintf(
            szFile,
            _TEXT("%s\\%s"),
            szDir,
            szFilesToBeDelete
        );

    hFile = FindFirstFile(
                        szFile,
                        &findData
                    );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }

    // _tprintf(_TEXT("Deleting %s\n"), szDir);

    while(bSuccess == TRUE)
    {
        if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && bIncludeSubdir == TRUE)
        {
            if( lstrcmp(findData.cFileName, _TEXT(".")) != 0 &&
                lstrcmp(findData.cFileName, _TEXT("..")) != 0 )
            {

                if (lstrlen(szDir) + lstrlen(findData.cFileName) + 2 <= sizeof(szFile) / sizeof(TCHAR))
                {
                    wsprintf(szFile, _TEXT("%s\\%s"), szDir, findData.cFileName);
                    bSuccess = DeleteFilesInDirectory(
                                        szFile,
                                        szFilesToBeDelete,
                                        bIncludeSubdir
                                        );
                }
            }
        }
        else
        {
            if (lstrlen(szDir) + lstrlen(findData.cFileName) + 2 <= sizeof(szFile) / sizeof(TCHAR))
            {
                wsprintf(
                    szFile,
                    _TEXT("%s\\%s"),
                    szDir,
                    findData.cFileName
                    );

                bSuccess = DeleteFile(szFile);
            }
        }

        if(bSuccess == TRUE)
        {
            // return FALSE with error code set to ERROR_NO_MORE_FILES
            bSuccess = FindNextFile(hFile, &findData);
        }
    }

    dwStatus = GetLastError();

    FindClose(hFile);

    return (dwStatus == ERROR_NO_MORE_FILES) ? ERROR_SUCCESS : dwStatus;
}



//----------------------------------------------------------------
JET_ERR
ConvertTLSJbColumnDefToJbColumnCreate(
    IN const PTLSJBColumn pTlsJbColumn,
    IN OUT JET_COLUMNCREATE* pJetColumnCreate
    )
/*
*/
{
    pJetColumnCreate->cbStruct = sizeof(JET_COLUMNCREATE);
    if(ConvertWstrToJBstr(pTlsJbColumn->pszColumnName, &pJetColumnCreate->szColumnName) == FALSE)
    {
        return JET_errInvalidParameter;
    }

    pJetColumnCreate->coltyp = pTlsJbColumn->colType;
    pJetColumnCreate->cbMax = pTlsJbColumn->cbMaxLength;
    pJetColumnCreate->grbit = pTlsJbColumn->jbGrbit;
    pJetColumnCreate->pvDefault = pTlsJbColumn->pbDefValue;
    pJetColumnCreate->cbDefault = pTlsJbColumn->cbDefValue;
    pJetColumnCreate->cp = pTlsJbColumn->colCodePage;

    return JET_errSuccess;
}

//----------------------------------------------------------------
JET_ERR
ConvertTlsJBTableIndexDefToJbIndexCreate(
    IN const PTLSJBIndex pTlsJbTableIndex,
    IN OUT JET_INDEXCREATE* pJetIndexCreate
    )
/*
*/
{
    JET_ERR jetError = JET_errSuccess;
    DWORD count=0;

    pJetIndexCreate->cbStruct = sizeof(JET_INDEXCREATE);
    if(ConvertWstrToJBstr(pTlsJbTableIndex->pszIndexName, &pJetIndexCreate->szIndexName) == FALSE)
    {
        jetError = JET_errInvalidParameter;
        goto cleanup;
    }

    if(pTlsJbTableIndex->pszIndexKey && pTlsJbTableIndex->cbKey == 0)
    {
        count++;

        // need double NULL terminate
        while(pTlsJbTableIndex->pszIndexKey[count] != _TEXT('\0') ||
              pTlsJbTableIndex->pszIndexKey[count-1] != _TEXT('\0'))
        {
            //
            // this max. is pseudo impose.
            //
            if(count >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
            {
                jetError = JET_errInvalidParameter;
                goto cleanup;
            }

            count++;
        }

        // pTlsJbTableIndex->cbKey = count;
    }
    else
    {
        count = pTlsJbTableIndex->cbKey;
    }

    if(ConvertMWstrToMJBstr(pTlsJbTableIndex->pszIndexKey, count, &pJetIndexCreate->szKey) == FALSE)
    {
        jetError = JET_errInvalidParameter;
        goto cleanup;
    }

    pJetIndexCreate->cbKey = pTlsJbTableIndex->cbKey;
    pJetIndexCreate->grbit = pTlsJbTableIndex->jbGrbit;
    pJetIndexCreate->ulDensity = pTlsJbTableIndex->ulDensity;


cleanup:
    return jetError;
}



//////////////////////////////////////////////////////////////////////
//
// JBInstance implementaion
//
//////////////////////////////////////////////////////////////////////
JBInstance::JBInstance() :
    JBError(),
    m_JetInstance(0),
    m_bInit(FALSE),
    m_NumSession(0)
{
}

//--------------------------------------------------------------------

JBInstance::~JBInstance()
{
    if(m_bInit == FALSE)
    {
        return;
    }

    //JB_ASSERT(m_NumSession == 0);
    //if(m_NumSession != 0)
    //{
    //    throw JBError(JET_errTooManyActiveUsers);
    //}

    JBTerminate();
}

//--------------------------------------------------------------------

BOOL
JBInstance::JBInitJetInstance()
{
    char szLogFilePath[MAX_PATH+1];
    LPTSTR pszLogPath=NULL;
    BOOL bSuccess;


    if(m_bInit == TRUE)
    {
        SetLastJetError(JET_errAlreadyInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetInit(&m_JetInstance);

    if(m_JetErr == JET_errMissingLogFile)
    {
        //
        // Delete log file and retry operation again
        //
        bSuccess = GetSystemParameter(
                                    0,
                                    JET_paramLogFilePath,
                                    NULL,
                                    (PBYTE)szLogFilePath,
                                    sizeof(szLogFilePath)
                                );

        if(bSuccess == TRUE && ConvertJBstrToWstr(szLogFilePath, &pszLogPath))
        {
            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_RESLOG,
                            FALSE
                        );

            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_EDBLOG,
                            FALSE
                        );

            m_JetErr = JetInit(&m_JetInstance);
        }
    }

    m_bInit = IsSuccess();
    return m_bInit;
}

//--------------------------------------------------------------------

BOOL
JBInstance::JBTerminate(
    IN JET_GRBIT grbit,
    IN BOOL bDeleteLogFile
    )
{
    char szLogFilePath[MAX_PATH+1];
    LPTSTR pszLogPath=NULL;
    BOOL bSuccess;

    if(m_bInit == FALSE)
        return TRUE;

    //
    // LSTESTER bug - one thread was still in enumeration while
    //  the other thread shutdown server
    //

    //if(m_NumSession > 0)
    //{
    //    JB_ASSERT(m_NumSession == 0);
    //    SetLastJetError(JET_errTooManyActiveUsers);
    //    return FALSE;
    //}

    SINGLE_JET_CALL;

    m_JetErr = JetTerm2(m_JetInstance, grbit);
    // JB_ASSERT(m_JetErr == JET_errSuccess);

    if(m_JetErr == JET_errSuccess && bDeleteLogFile == TRUE)
    {
        //
        // Delete log file.
        //
        bSuccess = GetSystemParameter(
                                    0,
                                    JET_paramLogFilePath,
                                    NULL,
                                    (PBYTE)szLogFilePath,
                                    sizeof(szLogFilePath)
                                );

        if(bSuccess == TRUE && ConvertJBstrToWstr(szLogFilePath, &pszLogPath))
        {
            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_RESLOG,
                            FALSE
                        );

            DeleteFilesInDirectory(
                            pszLogPath,
                            JETBLUE_EDBLOG,
                            FALSE
                        );
        }
    }

    m_bInit = FALSE;

    // need to add operator= to this class.
    // m_NumSession = 0;   // force terminate.

    if(pszLogPath != NULL)
    {
        LocalFree(pszLogPath);
    }

    return (m_JetErr == JET_errSuccess);
}

//--------------------------------------------------------------------

BOOL
JBInstance::SetSystemParameter(
    IN JET_SESID SesId,
    IN unsigned long lParamId,
    IN ULONG_PTR lParam,
    IN PBYTE sz
    )
{
    LPSTR lpszParm=NULL;

    if(lParamId == JET_paramSystemPath ||
       lParamId == JET_paramTempPath ||
       lParamId == JET_paramLogFilePath )
    {
        if(ConvertWstrToJBstr((LPTSTR)sz, &lpszParm) == FALSE)
        {
            SetLastJetError(JET_errInvalidParameter);
            return FALSE;
        }
    }
    else
    {
        lpszParm = (LPSTR)sz;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetSetSystemParameter(
                    &m_JetInstance,
                    SesId,
                    lParamId,
                    lParam,
                    (const char *)lpszParm
                );

    if(lParamId == JET_paramSystemPath || lParamId == JET_paramTempPath ||
       lParamId == JET_paramLogFilePath )
    {
        FreeJBstr(lpszParm);
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBInstance::GetSystemParameter(
    IN JET_SESID SesId,
    IN unsigned long lParamId,
    IN ULONG_PTR* plParam,
    IN PBYTE sz,
    IN unsigned long cbMax
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetGetSystemParameter(
                    m_JetInstance,
                    SesId,
                    lParamId,
                    plParam,
                    (char *)sz,
                    cbMax
                );

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_SESID
JBInstance::BeginJetSession(
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszPwd
    )
{
    JET_SESID sesId = JET_sesidNil;
    LPSTR lpszUserName=NULL;
    LPSTR lpszPwd=NULL;

    if(m_bInit == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return JET_sesidNil;
    }

    if(ConvertWstrToJBstr(pszUserName, &lpszUserName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszPwd, &lpszPwd) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetBeginSession(
                            m_JetInstance,
                            &sesId,
                            lpszUserName,
                            lpszPwd
                        );
    }

    if(IsSuccess() == TRUE)
    {
        m_NumSession++;
    }

cleanup:

    FreeJBstr(lpszUserName);
    FreeJBstr(lpszPwd);

    return IsSuccess() ? sesId : JET_sesidNil;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBInstance::EndJetSession(
    IN JET_SESID JetSessionID,
    IN JET_GRBIT grbit
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetEndSession(JetSessionID, grbit);

    if(IsSuccess() == TRUE)
    {
        m_NumSession--;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBInstance::EndSession(
    IN JET_SESID sesId,
    IN JET_GRBIT grbit
    )
{
    return EndJetSession( sesId, grbit );
}


//----------------------------------------------------------------------------
// Implementation for JBSession
//----------------------------------------------------------------------------

JBSession::JBSession(
    IN JBInstance& JetInstance,
    IN JET_SESID JetSessID
    ) :
    JBError(),
    m_JetInstance(JetInstance),
    m_JetSessionID(JetSessID),
    m_TransactionLevel(0),
    m_JetDBInitialized(0)
/*

*/
{
}

//-----------------------------------------------------------

JBSession::JBSession(
    IN JBSession& JetSession
    ) :
    JBError(),
    m_JetInstance(JetSession.GetJetInstance()),
    m_JetSessionID(JET_sesidNil),
    m_TransactionLevel(0),
    m_JetDBInitialized(0)
{
    if(DuplicateSession(JetSession.GetJetSessionID()) == FALSE)
    {
        JB_ASSERT(FALSE);
        throw JBError(GetLastJetError());
    }
}

//-----------------------------------------------------------

JBSession::~JBSession()
/*

*/
{
    if(IsValid() == TRUE && EndSession() == FALSE)
    {
        // do nothing, license server uses only global instance
        // JB_ASSERT(FALSE);
        // throw JBError(GetLastJetError());
    }
}

//----------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::DuplicateSession(
    IN JET_SESID sessID
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetDupSession(sessID, &m_JetSessionID);
    return IsSuccess();
}


//----------------------------------------------------------

CLASS_PRIVATE JET_DBID
JBSession::OpenJetDatabase(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszConnect,
    IN JET_GRBIT grbit
    )
{
    JET_DBID jdbId = JET_dbidNil;
    LPSTR lpszFile=NULL;
    LPSTR lpszConnect=NULL;

    if(ConvertWstrToJBstr(pszFile, &lpszFile) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszConnect, &lpszConnect) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(AttachDatabase(pszFile, grbit) == FALSE)
        goto cleanup;

    {
        SINGLE_JET_CALL;

        m_JetErr = JetOpenDatabase(
                            m_JetSessionID,
                            lpszFile,
                            lpszConnect,
                            &jdbId,
                            grbit
                        );
    }

    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized++;
    }

cleanup:
    FreeJBstr(lpszFile);
    FreeJBstr(lpszConnect);

    return IsSuccess() ? jdbId : JET_dbidNil;
}

//----------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::CloseJetDatabase(
    IN JET_DBID jdbId,
    IN JET_GRBIT grbit
    )
{
    SINGLE_JET_CALL;

    m_JetErr = JetCloseDatabase(
                        m_JetSessionID,
                        jdbId,
                        grbit
                    );

    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized--;
    }

    return (IsSuccess());
}

//----------------------------------------------------------

CLASS_PRIVATE JET_DBID
JBSession::CreateJetDatabase(
    IN LPCTSTR pszFile,
    IN LPCTSTR pszConnect,
    IN JET_GRBIT grbit
    )
{
    JET_DBID jdbId = JET_dbidNil;

    LPSTR lpszFile=NULL;
    LPSTR lpszConnect=NULL;

    if(ConvertWstrToJBstr(pszFile, &lpszFile) == FALSE)
    {
        SetLastError(JET_errInvalidParameter);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszConnect, &lpszConnect) == FALSE)
    {
        SetLastError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateDatabase(
                            m_JetSessionID,
                            lpszFile,
                            lpszConnect,
                            &jdbId,
                            grbit
                        );
    }


    if(IsSuccess() == TRUE)
    {
        m_JetDBInitialized++;
    }

cleanup:
    FreeJBstr(lpszFile);
    FreeJBstr(lpszConnect);

    return IsSuccess() ? jdbId : JET_dbidNil;
}

//----------------------------------------------------------

BOOL
JBSession::BeginSession(
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszPwd
    )
/*

*/
{
    BOOL bSuccess;

    if(m_JetInstance.IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_JetSessionID != JET_sesidNil)
    {
        SetLastJetError(JET_errAlreadyInitialized);
        return FALSE;
    }

    m_JetSessionID = m_JetInstance.BeginJetSession(
                            pszUserName,
                            pszPwd
                        );

    if(m_JetSessionID == JET_sesidNil)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//----------------------------------------------------------

BOOL
JBSession::EndSession(
    IN JET_GRBIT grbit /* JET_bitTermComplete  */
    )
/*

*/
{
    BOOL bSuccess;

    if(GetTransactionLevel() != 0)
    {
        //
        // Terminate existing transaction
        //
        bSuccess = EndAllTransaction(FALSE);
        if(bSuccess == FALSE)
        {
            JB_ASSERT(FALSE);
            SetLastJetError(JET_errTransTooDeep);
            return FALSE;
        }
    }

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    if(m_JetDBInitialized > 0)
    {
        JB_ASSERT(m_JetDBInitialized);
        SetLastJetError(JET_errTooManyActiveUsers);
        return FALSE;
    }

    //
    // Huei - routine to be phrased out ?
    //
    bSuccess=m_JetInstance.EndSession(
                            m_JetSessionID,
                            grbit
                        );

    if(bSuccess == TRUE)
    {
        m_JetSessionID = JET_sesidNil;
    }
    else
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//------------------------------------------------------------

BOOL
JBSession::SetSystemParameter(
    IN unsigned long lParamId,
    IN ULONG_PTR lParam,
    IN const PBYTE sz
    )
{
    BOOL bSuccess;

    bSuccess = m_JetInstance.SetSystemParameter(
                            m_JetSessionID,
                            lParamId,
                            lParam,
                            sz
                        );

    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::GetSystemParameter(
    IN unsigned long lParamId,
    IN ULONG_PTR* plParam,
    IN PBYTE sz,
    IN unsigned long cbMax
    )
{
    BOOL bSuccess;

    bSuccess = m_JetInstance.GetSystemParameter(
                            m_JetSessionID,
                            lParamId,
                            plParam,
                            sz,
                            cbMax
                        );

    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetInstance.GetLastJetError();
    }

    return IsSuccess();
}

//--------------------------------------------------------------------
BOOL
JBSession::AttachDatabase(
    IN LPCTSTR pszFileName,
    IN JET_GRBIT grbit
    )
{
    LPSTR lpszFileName=NULL;

    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszFileName, &lpszFileName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetAttachDatabase(
                            m_JetSessionID,
                            lpszFileName,
                            grbit
                        );
    }

cleanup:

    FreeJBstr(lpszFileName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::DetachDatabase(
    IN LPCTSTR pszFileName
    )
{
    LPSTR lpszFileName = NULL;

    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszFileName, &lpszFileName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetDetachDatabase(
                            m_JetSessionID,
                            lpszFileName
                        );
    }

cleanup:

    FreeJBstr(lpszFileName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::BeginTransaction()
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetBeginTransaction(
                        m_JetSessionID
                    );

    if(IsSuccess() == TRUE)
    {
        m_TransactionLevel++;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::CommitTransaction(
    IN JET_GRBIT grbit
    )
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetCommitTransaction(
                        m_JetSessionID,
                        grbit
                    );

    if(IsSuccess() == TRUE)
    {
        m_TransactionLevel --;
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::RollbackTransaction(
    IN JET_GRBIT grbit
    )
{
    if(m_JetSessionID == JET_sesidNil)
    {
        SetLastJetError(JET_errNotInitialized);
        return FALSE;
    }

    SINGLE_JET_CALL;

    m_JetErr = JetRollback(
                        m_JetSessionID,
                        grbit
                    );
    if(IsSuccess() == TRUE)
        m_TransactionLevel--;

    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBSession::EndAllTransaction(
    IN BOOL bCommit,
    IN JET_GRBIT grbit
    )
{
    BOOL bEnd = TRUE;

    while(m_TransactionLevel > 0 && bEnd == TRUE)
    {
        bEnd = (bCommit == TRUE) ?
                    CommitTransaction(grbit) : RollbackTransaction(grbit);
    }

    return bEnd;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBSession::CloseDatabase(
    JET_DBID jdbId,
    JET_GRBIT grbit
    )
{
    return CloseJetDatabase(jdbId, grbit);
}



//////////////////////////////////////////////////////////////////////
//
// JBDatabase
//
//////////////////////////////////////////////////////////////////////

JBDatabase::JBDatabase(
    IN JBSession& jbSession,
    IN JET_DBID jdbId,              /* JET_dbidNil */
    IN LPCTSTR pszDatabase          // NULL
    ) :
    JBError(),
    m_JetSession(jbSession),
    m_JetDbId(jdbId),
    m_TableOpened(0)
/*

*/
{
    if(pszDatabase)
    {
        _tcscpy(m_szDatabaseFile, pszDatabase);
    }
    else
    {
        memset(m_szDatabaseFile, 0, sizeof(m_szDatabaseFile));
    }
}

//--------------------------------------------------------------------

JBDatabase::~JBDatabase()
{
    if(CloseDatabase() == FALSE)
    {
        // do nothing, license server uses only global instance.
        // JB_ASSERT(FALSE);
        // throw JBError(GetLastJetError());
    }
}

//--------------------------------------------------------------------

BOOL
JBDatabase::CloseDatabase(
    IN JET_GRBIT grbit
    )
{
    BOOL bSuccess;

    //
    // Verify we have properly initialized
    //
    if(IsValid() == FALSE)
        return TRUE;

    //
    // No table is still opened from the DB ID
    //
    if(m_TableOpened > 0)
    {
        JB_ASSERT(FALSE);
        SetLastJetError(JET_errTooManyActiveUsers);
        return FALSE;
    }

    //
    // Close the database
    //
    bSuccess = m_JetSession.CloseJetDatabase(
                            m_JetDbId,
                            grbit
                        );

    if(bSuccess == FALSE || m_JetSession.DetachDatabase(m_szDatabaseFile) == FALSE)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        m_JetDbId = JET_dbidNil;
        memset(m_szDatabaseFile, 0, sizeof(m_szDatabaseFile));
    }

    return IsSuccess();
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::OpenJetTable(
    IN LPCTSTR pszTableName,
    IN void* pvParam,  // NULL
    IN unsigned long cbParam, // 0
    JET_GRBIT grbit // JET_bitTableUpdatable
    )
/*

*/
{
    LPSTR lpszTableName = NULL;

    JET_TABLEID tableid = JET_tableidNil;
    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr=JetOpenTable(
                    m_JetSession.GetJetSessionID(),
                    m_JetDbId,
                    lpszTableName,
                    pvParam,
                    cbParam,
                    grbit,
                    &tableid
                );
    }

    if(IsSuccess() == TRUE)
    {
        m_TableOpened++;
    }

cleanup:

    FreeJBstr(lpszTableName);
    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::DuplicateJetCursor(
    // IN JET_SESID sesId,
    IN JET_TABLEID srcTableid,
    IN JET_GRBIT grbit
    )
/*

*/
{
    JET_TABLEID tableid = JET_tableidNil;

    SINGLE_JET_CALL;
    m_JetErr = JetDupCursor(
                        GetJetSessionID(),
                        srcTableid,
                        &tableid,
                        0  // grbit must be zero
                    );

    if(IsSuccess() == TRUE)
    {
        m_TableOpened++;
    }

    return (IsSuccess() == TRUE) ? tableid : JET_tableidNil;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBDatabase::CloseJetTable(
    // IN JET_SESID sesId,
    IN JET_TABLEID tableid
    )
/*
*/
{
    // JetBlue AC with empty table
    SINGLE_JET_CALL;

    m_JetErr = JetCloseTable(
                        GetJetSessionID(),
                        tableid
                    );    

    if(IsSuccess())
    {
        m_TableOpened--;
    }

    return IsSuccess();
}


//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::CreateJetTable(
    LPCTSTR pszTableName,
    unsigned long lPage, // 0
    unsigned long lDensity // 20
    )
/*
*/
{
    JET_TABLEID tableid = JET_tableidNil;
    JB_STRING lpszTableName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateTable(
                        GetJetSessionID(),
                        m_JetDbId,
                        lpszTableName,
                        lPage,
                        lDensity,
                        &tableid
                    );
    }

    if(IsSuccess() == FALSE)
    {
        goto cleanup;
    }

    m_TableOpened++;

cleanup:

    FreeJBstr(lpszTableName);
    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE JET_TABLEID
JBDatabase::CreateJetTableEx(
        LPCTSTR pszTableName,
        const PTLSJBTable table_attribute,
        const PTLSJBColumn columns,
        const DWORD num_columns,
        const PTLSJBIndex table_index,
        const DWORD num_table_index
    )
/*

*/
{
    JET_TABLEID tableid = JET_tableidNil;
    JB_STRING lpszTableName=NULL;
    JET_TABLECREATE table_create;
    JET_COLUMNCREATE* column_create=NULL;
    JET_INDEXCREATE* index_create=NULL;
    DWORD index=0;

    SINGLE_JET_CALL;

    table_create.szTableName = NULL;
    table_create.szTemplateTableName = NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }


    table_create.cbStruct = sizeof(JET_TABLECREATE);
    table_create.szTableName = lpszTableName;

    if(ConvertWstrToJBstr(table_attribute->pszTemplateTableName, &table_create.szTemplateTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    table_create.ulPages = table_attribute->ulPages;
    table_create.ulDensity = (table_attribute->ulDensity < 20 || table_attribute->ulDensity > 100) ?
                                        TLS_JETBLUE_DEFAULT_TABLE_DENSITY : table_attribute->ulDensity;

    table_create.grbit = table_attribute->jbGrbit;

    //
    // form a JET_TABLECREATE structure
    //
    column_create = (JET_COLUMNCREATE *)AllocateMemory(
                                            sizeof(JET_COLUMNCREATE) * num_columns
                                        );

    if(column_create == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    index_create = (JET_INDEXCREATE *)AllocateMemory(
                                            sizeof(JET_INDEXCREATE) * num_table_index
                                        );

    if(index_create == NULL)
    {
        SetLastJetError(JET_errOutOfMemory);
        goto cleanup;
    }

    for(index=0; index < num_columns; index++)
    {
        if(ConvertTLSJbColumnDefToJbColumnCreate( columns+index, column_create+index ) == FALSE)
        {
            goto cleanup;
        }
    }

    for(index=0; index < num_table_index; index++)
    {
        if(ConvertTlsJBTableIndexDefToJbIndexCreate( table_index+index, index_create+index ) == FALSE)
            goto cleanup;
    }

    table_create.rgcolumncreate = column_create;
    table_create.cColumns = num_columns;
    table_create.rgindexcreate = index_create;
    table_create.cIndexes = num_table_index;

    m_JetErr = JetCreateTableColumnIndex(
                                GetJetSessionID(),
                                GetJetDatabaseID(),
                                &table_create
                            );
    if(IsSuccess() == TRUE)
    {
        tableid = table_create.tableid;
    }

cleanup:
    if(column_create != NULL)
    {
        for(index=0; index < num_columns; index++)
        {
            if(column_create[index].szColumnName != NULL)
            {
                FreeJBstr(column_create[index].szColumnName);
            }
        }

        FreeMemory(column_create);
    }

    if(index_create != NULL)
    {
        for(index=0; index < num_table_index; index++)
        {
            if(index_create[index].szIndexName != NULL)
            {
                FreeJBstr(index_create[index].szIndexName);
            }

            if(index_create[index].szKey != NULL)
            {
                FreeJBstr(index_create[index].szKey);
            }
        }

        FreeMemory(index_create);
    }

    if(table_create.szTemplateTableName)
        FreeJBstr(table_create.szTemplateTableName);

    if(table_create.szTableName)
        FreeJBstr(table_create.szTableName);

    return tableid;
}

//--------------------------------------------------------------------

JET_TABLEID
JBDatabase::CreateTable(
    LPCTSTR pszTableName,
    unsigned long lPage, // 0
    unsigned long lDensity // 20
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = CreateJetTable(
                        pszTableName,
                        lPage,
                        lDensity
                    );

    if(tableid == JET_tableidNil)
    {
        m_JetErr = GetLastJetError();
    }

    return tableid;
}

//-------------------------------------------------------------------

JET_TABLEID
JBDatabase::CreateTableEx(
    LPCTSTR pszTableName,
    const PTLSJBTable table_attribute,
    const PTLSJBColumn columns,
    DWORD num_columns,
    const PTLSJBIndex index,
    DWORD num_index
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = CreateJetTableEx(
                        pszTableName,
                        table_attribute,
                        columns,
                        num_columns,
                        index,
                        num_index
                    );

    if(tableid == JET_tableidNil)
    {
        m_JetErr = GetLastJetError();
    }

    return tableid;
}

//--------------------------------------------------------------------

CLASS_PRIVATE BOOL
JBDatabase::CloseTable(
    JET_TABLEID tableid
    )
/*
    ? Verify this table ID is from this DB/Session
*/
{
    return CloseJetTable( tableid );
}

//--------------------------------------------------------------------

BOOL
JBDatabase::DeleteTable(
    IN LPCTSTR pszTableName
    )
/*
    TODO - ? verify this table is in this database
*/
{
    JB_STRING lpszTableName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errNotInitialized);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszTableName, &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errInvalidParameter);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetDeleteTable(
                        GetJetSessionID(),
                        GetJetDatabaseID(),
                        lpszTableName
                    );
    }

    //if(IsSuccess() == FALSE)
    //    goto cleanup;

cleanup:

    FreeJBstr(lpszTableName);
    return IsSuccess();
}

//--------------------------------------------------------------------

BOOL
JBDatabase::OpenDatabase(
    LPCTSTR szFile,
    LPCTSTR szConnect,      // NULL
    JET_GRBIT grbit         // 0
    )
/*
*/
{
    m_JetDbId = m_JetSession.OpenJetDatabase(
                                szFile,
                                szConnect,
                                grbit
                            );

    if(m_JetDbId == JET_dbidNil)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        _tcscpy(m_szDatabaseFile, szFile);
    }

    return m_JetDbId != JET_dbidNil;
}

//--------------------------------------------------------------------

BOOL
JBDatabase::CreateDatabase(
    LPCTSTR szFile,
    LPCTSTR szConnect,      // NULL
    JET_GRBIT grbit         // 0
    )
/*
*/
{
    m_JetDbId = m_JetSession.CreateJetDatabase(
                                szFile,
                                szConnect,
                                grbit
                            );

    if(m_JetDbId == JET_dbidNil)
    {
        m_JetErr = m_JetSession.GetLastJetError();
    }
    else
    {
        _tcscpy(m_szDatabaseFile, szFile);
    }

    return m_JetDbId != JET_dbidNil;
}


//////////////////////////////////////////////////////////////////////
//
// JBTable
//
//////////////////////////////////////////////////////////////////////
JBColumn JBTable::m_ErrColumn;


JBTable::JBTable(
    JBDatabase& JetDatabase,
    LPCTSTR pszTableName,
    JET_TABLEID tableid
) :
JBError(),
m_JetDatabase(JetDatabase),
m_JetTableId(tableid),
m_JetColumns(NULL),
m_NumJetColumns(0),
m_InEnumeration(FALSE),
m_InsertRepositionBookmark(FALSE)
/*

*/
{
    if(pszTableName)
    {
        _tcscpy(m_szTableName, pszTableName);
    }
    else
    {
        memset(m_szTableName, 0, sizeof(m_szTableName));
    }
}

//--------------------------------------------------------------------

JBTable::JBTable(
    JBTable& jbTable
) :
JBError(),
m_JetDatabase(jbTable.GetJetDatabase()),
m_JetColumns(NULL),
m_NumJetColumns(0),
m_InEnumeration(FALSE)
/*
*/
{
    // duplicate jet cursor
    _tcscpy(m_szTableName, jbTable.GetTableName());

    m_JetTableId = m_JetDatabase.DuplicateJetCursor(
                                    jbTable.GetJetTableID(),
                                    0
                                );
    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }
}

//--------------------------------------------------------------------

JBTable::~JBTable()
{
    if(m_JetTableId == JET_tableidNil)
        return;

    CloseTable();
}


//--------------------------------------------------------------------
CLASS_PRIVATE JET_COLUMNID
JBTable::AddJetColumn(
        LPCTSTR pszColumnName,
        const JET_COLUMNDEF* pColumnDef,
        const PVOID pbDefaultValue,         // NULL
        const unsigned long cbDefaultValue // 0
    )
/*
*/
{
    DebugOutput(
            _TEXT("Adding column %s to table %s, type %d\n"),
            pszColumnName,
            GetTableName(),
            pColumnDef->coltyp
        );

    JB_STRING lpszColumnName=NULL;
    JET_COLUMNID columnid = (DWORD)JET_NIL_COLUMN;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszColumnName, &lpszColumnName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetAddColumn(
                        GetJetSessionID(),
                        GetJetTableID(),
                        lpszColumnName,
                        pColumnDef,
                        pbDefaultValue,
                        cbDefaultValue,
                        &columnid
                    );
    }

cleanup:

    DebugOutput(
            _TEXT("AddJetColumn returns %d\n"),
            GetLastJetError()
        );

    FreeJBstr(lpszColumnName);
    return columnid;
}


//--------------------------------------------------------------------
BOOL
JBTable::AddIndex(
    JBKeyBase* key
    )
/*
*/
{
    return AddJetIndex(
                key->GetIndexName(),
                key->GetIndexKey(),
                key->GetKeyLength(),
                key->GetJetGrbit(),
                key->GetJetDensity()
            );
}

//--------------------------------------------------------------------

BOOL
JBTable::AddJetIndex(
    LPCTSTR pszIndexName,
    LPCTSTR pszKey,
    unsigned long cbKey,
    JET_GRBIT grbit, /* 0 */
    unsigned long lDensity /* 20 */
    )
/*

*/
{
    DebugOutput(
            _TEXT("Adding Index %s to table %s\n"),
            pszIndexName,
            GetTableName()
        );

    JB_STRING lpszIndexName=NULL;
    JB_STRING lpszKeyName=NULL;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertMWstrToMJBstr(pszKey, cbKey, &lpszKeyName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetCreateIndex(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            grbit,
                            lpszKeyName,
                            cbKey,
                            lDensity
                        );
    }

cleanup:
    DebugOutput(
            _TEXT("Adding index %s returns %d\n"),
            pszIndexName,
            GetLastJetError()
        );

    FreeJBstr(lpszIndexName);
    FreeJBstr(lpszKeyName);

    return IsSuccess();
}

BOOL
JBTable::DoesIndexExist(
    LPCTSTR pszIndexName
    )
{
    JB_STRING lpszIndexName=NULL;
    JET_INDEXID idx;

    if(IsValid() == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    if(ConvertWstrToJBstr(pszIndexName, &lpszIndexName) == FALSE)
    {
        SetLastJetError(JET_errInvalidDatabaseId);
        goto cleanup;
    }

    {
        SINGLE_JET_CALL;

        m_JetErr = JetGetTableIndexInfo(
                            GetJetSessionID(),
                            GetJetTableID(),
                            lpszIndexName,
                            &idx,
                            sizeof(JET_INDEXID),
                            JET_IdxInfoIndexId
                            );

        // if this succeeds, the index exists
    }

cleanup:

    FreeJBstr(lpszIndexName);

    return IsSuccess();

}


//--------------------------------------------------------------------
BOOL
JBTable::CloseTable()
{
    BOOL bSuccess;

    if(m_JetTableId == JET_tableidNil)
        return TRUE;

    bSuccess = m_JetDatabase.CloseTable(
                                m_JetTableId
                            );
    if(bSuccess == FALSE)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    //
    // Force close on table.
    //
    m_JetTableId = JET_tableidNil;

    if(m_JetColumns)
        delete [] m_JetColumns;

    m_JetColumns = NULL;
    m_NumJetColumns = 0;

    return bSuccess;
}

//--------------------------------------------------------------------

BOOL
JBTable::CreateOpenTable(
    IN LPCTSTR pszTableName,
    IN unsigned long lPage, // 0
    IN unsigned long lDensity // 20
    )
/*
*/
{
    if(m_JetTableId != JET_tableidNil)
    {
        SetLastJetError(JET_errInvalidParameter);
        return FALSE;
    }

    DebugOutput(
            _TEXT("Creating Table %s\n"),
            pszTableName
        );

    m_JetTableId = m_JetDatabase.CreateJetTable(
                                    pszTableName,
                                    lPage,
                                    lDensity
                                );

    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return (m_JetTableId != JET_tableidNil);
}

//--------------------------------------------------------------------

BOOL
JBTable::OpenTable(
    IN LPCTSTR pszTableName,
    IN void* pvParam,
    IN unsigned long cbParam,
    IN JET_GRBIT grbit
    )
/*
*/
{
    DebugOutput(
            _TEXT("Opening table %s\n"),
            pszTableName
        );

    JB_ASSERT(m_JetTableId == JET_tableidNil);

    if(m_JetTableId != JET_tableidNil)
    {
        SetLastJetError(JET_errTableInUse);
        return FALSE;
    }

    m_JetTableId = m_JetDatabase.OpenJetTable(
                                pszTableName,
                                pvParam,
                                cbParam,
                                grbit
                            );

    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }
    else
    {
        // load column info in the table
        _tcscpy(m_szTableName, pszTableName);

        if(LoadTableInfo() == FALSE)
        {
            // force a close on table
            CloseTable();
        }
    }

    DebugOutput(
            _TEXT("Open table %s return code %d\n"),
            pszTableName,
            GetLastJetError()
        );

    return (m_JetTableId != JET_tableidNil);
}

//--------------------------------------------------------------------

JBTable*
JBTable::DuplicateCursor(
    JET_GRBIT grbit /* 0 */
    )
/*
*/
{
    JET_TABLEID tableid;

    tableid = m_JetDatabase.DuplicateJetCursor(
                                    m_JetTableId,
                                    grbit
                                );
    if(tableid == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return new JBTable(
                    m_JetDatabase,
                    GetTableName(),
                    tableid
                );
}


//--------------------------------------------------------------------

JBTable&
JBTable::operator=(const JBTable& srcTable)
{
    if(this == &srcTable)
        return *this;

    // database has to be the same
    // verify database is consistent


    _tcscpy(m_szTableName, srcTable.GetTableName());

    m_JetTableId = m_JetDatabase.DuplicateJetCursor(
                                    srcTable.GetJetTableID(),
                                    0
                                );
    if(m_JetTableId == JET_tableidNil)
    {
        m_JetErr = m_JetDatabase.GetLastJetError();
    }

    return *this;
}

//--------------------------------------------------------------------
int
JBTable::AddColumn(
    int numColumns,
    PTLSJBColumn pColumnDef
    )
/*
*/
{
    JET_COLUMNDEF  column;
    JET_COLUMNID   jet_columnid;

    for(int i=0; i < numColumns; i++)
    {
        memset(&column, 0, sizeof(column));

        column.cbStruct = sizeof(JET_COLUMNDEF);
        column.coltyp = (pColumnDef+i)->colType;
        column.wCountry = (pColumnDef+i)->wCountry;
        column.langid = (pColumnDef+i)->langid;
        column.cp = (pColumnDef+i)->colCodePage;
        column.cbMax = (pColumnDef+i)->cbMaxLength;
        column.grbit = (pColumnDef+i)->jbGrbit;

        jet_columnid = AddJetColumn(
                                (pColumnDef+i)->pszColumnName,
                                &column,
                                (pColumnDef+i)->pbDefValue,
                                (pColumnDef+i)->cbDefValue
                            );

        if(jet_columnid == JET_NIL_COLUMN)
            break;
    }

    // return which column cause trouble
    return i;
}

//--------------------------------------------------------------------
int
JBTable::AddIndex(
    int numIndex,
    PTLSJBIndex pIndex
    )
/*
*/
{
    unsigned long keylength;

    for(int i=0; i < numIndex; i++)
    {
        if((pIndex+i)->cbKey == -1)
        {
            // calculate index key length
            keylength = 2;

            while((pIndex+i)->pszIndexKey[keylength-1] != _TEXT('\0') ||
                  (pIndex+i)->pszIndexKey[keylength-2] != _TEXT('\0'))
            {
                if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
                {
                    SetLastJetError(JET_errInvalidParameter);
                    break;
                }

                keylength++;
            }
        }
        else
        {
            keylength = (pIndex+i)->cbKey;
        }

        if(keylength >= TLS_JETBLUE_MAX_INDEXKEY_LENGTH)
        {
            SetLastJetError(JET_errInvalidParameter);
            break;
        }

        if(AddJetIndex(
                    (pIndex+i)->pszIndexName,
                    (pIndex+i)->pszIndexKey,
                    keylength,
                    (pIndex+i)->jbGrbit,
                    (pIndex+i)->ulDensity
                ) == FALSE)
        {
            break;
        }
    }

    return (i >= numIndex) ? 0 : i;
}

//-------------------------------------------------------------

CLASS_PRIVATE BOOL
JBTable::LoadTableInfo()
/*
*/
{
#if 1
    LPSTR lpszTableName=NULL;
    JET_COLUMNLIST columns;
    unsigned long cbMax;
    JET_RETINFO jetRetInfo;
    char lpszColumnName[MAX_JETBLUE_NAME_LENGTH+1];
    int NumChars;
    unsigned long index;

    SINGLE_JET_CALL;

    if(ConvertWstrToJBstr(GetTableName(), &lpszTableName) == FALSE)
    {
        SetLastJetError(JET_errI